metric_name,file
org.apache.tools.ant.AntClassLoader,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.lang.reflect.*;
import java.util.*;
import java.util.zip.*;
import java.io.*;
import org.apache.tools.ant.types.Path;
/**
 * Used to load classes within ant with a different claspath from that used to start ant.
 * Note that it is possible to force a class into this loader even when that class is on the
 * system classpath by using the forceLoadClass method. Any subsequent classes loaded by that
 * class will then use this loader rather than the system class loader.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>
 * @author <a href=""mailto:Jesse.Glick@netbeans.com"">Jesse Glick</a>
 */
public class AntClassLoader  extends ClassLoader {
    /**
     * The size of buffers to be used in this classloader.
     */
    static private final int BUFFER_SIZE = 1024;
    /**
     * The classpath that is to be used when loading classes using this class loader.
     */ 
    private Path classpath;
    /**
     * The project to which this class loader belongs.
     */
    private Project project;
    /**
     * Indicates whether the system class loader should be 
     * consulted before trying to load with this class loader. 
     */
    private boolean systemFirst = true;
    /**
     * These are the package roots that are to be loaded by the system class loader
     * regardless of whether the system class loader is being searched first or not.
     */
    private Vector systemPackages = new Vector();
    /**
     * These are the package roots that are to be loaded by this class loader
     * regardless of whether the system class loader is being searched first or not.
     */
    private Vector loaderPackages = new Vector();
    /**
     * This flag indicates that the classloader will ignore the base
     * classloader if it can;t find a class.
     */
    private boolean ignoreBase = false;
    private static Method getProtectionDomain = null;
    private static Method defineClassProtectionDomain = null;
    static {
        try {
            getProtectionDomain = Class.class.getMethod(""getProtectionDomain"", new Class[0]);
            Class protectionDomain = Class.forName(""java.security.ProtectionDomain"");
            Class[] args = new Class[] {String.class, byte[].class, Integer.TYPE, Integer.TYPE, protectionDomain};
            defineClassProtectionDomain = ClassLoader.class.getDeclaredMethod(""defineClass"", args);
        }
        catch (Exception e) {}
    }
    /**
     * Create a classloader for the given project using the classpath given.
     *
     * @param project the project to ehich this classloader is to belong.
     * @param classpath the classpath to use to load the classes.  This
     *                is combined with the system classpath in a manner
     *                determined by the value of ${build.sysclasspath}
     */
    public AntClassLoader(Project project, Path classpath) {
        this.project = project;
        this.classpath = classpath.concatSystemClasspath(""ignore"");
        // JDK > 1.1 should add these by default, but some VMs don't
        addSystemPackageRoot(""java"");
        addSystemPackageRoot(""javax"");
    }
    /**
     * Create a classloader for the given project using the classpath given.
     *
     * @param project the project to which this classloader is to belong.
     * @param classpath the classpath to use to load the classes.
     */
    public AntClassLoader(Project project, Path classpath, boolean systemFirst) {
        this(project, classpath);
        this.systemFirst = systemFirst;
    }
    /**
     * Set this classloader to run in isolated mode. In isolated mode, classes not
     * found on the given classpath will not be referred to the base class loader
     * but will cause a classNotFoundException.
     */
    public void setIsolated(boolean isolated) {
        ignoreBase = isolated;
    }
    /**
     * Add a package root to the list of packages which must be loaded on the 
     * system loader.
     *
     * All subpackages are also included.
     *
     * @param packageRoot the root of all packages to be included.
     */
    public void addSystemPackageRoot(String packageRoot) {
        systemPackages.addElement(packageRoot + ""."");
    }
    /**
     * Add a package root to the list of packages which must be loaded using
     * this loader.
     *
     * All subpackages are also included.
     *
     * @param packageRoot the root of akll packages to be included.
     */
    public void addLoaderPackageRoot(String packageRoot) {
        loaderPackages.addElement(packageRoot + ""."");
    }
    /**
     * Load a class through this class loader even if that class is available on the
     * system classpath.
     *
     * This ensures that any classes which are loaded by the returned class will use this
     * classloader.
     *
     * @param classname the classname to be loaded.
     * 
     * @return the required Class object
     *
     * @throws ClassNotFoundException if the requested class does not exist on
     * this loader's classpath.
     */
    public Class forceLoadClass(String classname) throws ClassNotFoundException {
        project.log(""force loading "" + classname, Project.MSG_DEBUG);
        Class theClass = findLoadedClass(classname);
        if (theClass == null) {
            theClass = findClass(classname);
        }
        return theClass;
    }
    /**
     * Load a class through this class loader but defer to the system class loader
     *
     * This ensures that instances of the returned class will be compatible with instances which
     * which have already been loaded on the system loader.
     *
     * @param classname the classname to be loaded.
     * 
     * @return the required Class object
     *
     * @throws ClassNotFoundException if the requested class does not exist on
     * this loader's classpath.
     */
    public Class forceLoadSystemClass(String classname) throws ClassNotFoundException {
        project.log(""force system loading "" + classname, Project.MSG_DEBUG);
        Class theClass = findLoadedClass(classname);
        if (theClass == null) {
            theClass = findBaseClass(classname);
        }
        return theClass;
    }
    /**
     * Get a stream to read the requested resource name.
     *
     * @param name the name of the resource for which a stream is required.
     *
     * @return a stream to the required resource or null if the resource cannot be
     * found on the loader's classpath.
     */
    public InputStream getResourceAsStream(String name) {
        // we need to search the components of the path to see if we can find the 
        // class we want. 
        InputStream stream = null;
        String[] pathElements = classpath.list();
        for (int i = 0; i < pathElements.length && stream == null; ++i) {
            File pathComponent = project.resolveFile((String)pathElements[i]);
            stream = getResourceStream(pathComponent, name);
        }
        return stream;
    }
    /**
     * Get an inputstream to a given resource in the given file which may
     * either be a directory or a zip file.
     *
     * @param file the file (directory or jar) in which to search for the resource.
     * @param resourceName the name of the resource for which a stream is required.
     *
     * @return a stream to the required resource or null if the resource cannot be
     * found in the given file object
     */
    private InputStream getResourceStream(File file, String resourceName) {
        try {
            if (!file.exists()) {
                return null;
            }
            if (file.isDirectory()) {
                File resource = new File(file, resourceName); 
                if (resource.exists()) {   
                    return new FileInputStream(resource);
                }
            }
            else {
                ZipFile zipFile = null;
                try {
                    zipFile = new ZipFile(file);
                    ZipEntry entry = zipFile.getEntry(resourceName);
                    if (entry != null) {
                        // we need to read the entry out of the zip file into
                        // a baos and then 
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        byte[] buffer = new byte[BUFFER_SIZE];
                        int bytesRead;
                        InputStream stream = zipFile.getInputStream(entry);
                        while ((bytesRead = stream.read(buffer, 0, BUFFER_SIZE)) != -1) {
                            baos.write(buffer, 0, bytesRead);
                        }
                        return new ByteArrayInputStream(baos.toByteArray());   
                    }
                }
                finally {
                    if (zipFile != null) {
                        zipFile.close();
                    }
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return null;   
    }
    /**
     * Load a class with this class loader.
     *
     * This method will load a class. 
     *
     * This class attempts to load the class firstly using the parent class loader. For
     * JDK 1.1 compatability, this uses the findSystemClass method.
     *
     * @param classname the name of the class to be loaded.
     * @param resolve true if all classes upon which this class depends are to be loaded.
     * 
     * @return the required Class object
     *
     * @throws ClassNotFoundException if the requested class does not exist on
     * the system classpath or this loader's classpath.
     */
    protected Class loadClass(String classname, boolean resolve) throws ClassNotFoundException {
        // default to the global setting and then see
        // if this class belongs to a package which has been
        // designated to use a specific loader first (this one or the system one)
        boolean useSystemFirst = systemFirst; 
        for (Enumeration e = systemPackages.elements(); e.hasMoreElements();) {
            String packageName = (String)e.nextElement();
            if (classname.startsWith(packageName)) {
                useSystemFirst = true;
                break;
            }
        }
        for (Enumeration e = loaderPackages.elements(); e.hasMoreElements();) {
            String packageName = (String)e.nextElement();
            if (classname.startsWith(packageName)) {
                useSystemFirst = false;
                break;
            }
        }
        Class theClass = findLoadedClass(classname);
        if (theClass == null) {
            if (useSystemFirst) {
                try {
                    theClass = findBaseClass(classname);
                    project.log(""Class "" + classname + "" loaded from system loader"", Project.MSG_DEBUG);
                }
                catch (ClassNotFoundException cnfe) {
                    theClass = findClass(classname);
                    project.log(""Class "" + classname + "" loaded from ant loader"", Project.MSG_DEBUG);
                }
            }
            else {
                try {
                    theClass = findClass(classname);
                    project.log(""Class "" + classname + "" loaded from ant loader"", Project.MSG_DEBUG);
                }
                catch (ClassNotFoundException cnfe) {
                    if (ignoreBase) {
                        throw cnfe;
                    }
                    theClass = findBaseClass(classname);
                    project.log(""Class "" + classname + "" loaded from system loader"", Project.MSG_DEBUG);
                }
            }
        }
        if (resolve) {
            resolveClass(theClass);
        }
        return theClass;
    }
    /**
     * Convert the class dot notation to a file system equivalent for
     * searching purposes.
     *
     * @param classname the class name in dot format (ie java.lang.Integer)
     *
     * @return the classname in file system format (ie java/lang/Integer.class)
     */
    private String getClassFilename(String classname) {
        return classname.replace('.', '/') + "".class"";
    }
    /**
     * Read a class definition from a stream.
     *
     * @param stream the stream from which the class is to be read.
     * @param classname the class name of the class in the stream.
     *
     * @return the Class object read from the stream.
     *
     * @throws IOException if there is a problem reading the class from the
     * stream.
     */
    private Class getClassFromStream(InputStream stream, String classname) 
                throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        int bytesRead = -1;
        byte[] buffer = new byte[1024];
        while ((bytesRead = stream.read(buffer, 0, 1024)) != -1) {
            baos.write(buffer, 0, bytesRead);
        }
        byte[] classData = baos.toByteArray();
        // Simply put:
        // defineClass(classname, classData, 0, classData.length, Project.class.getProtectionDomain());
        // Made more elaborate to be 1.1-safe.
        if (defineClassProtectionDomain != null) {
            try {
                Object domain = getProtectionDomain.invoke(Project.class, new Object[0]);
                Object[] args = new Object[] {classname, classData, new Integer(0), new Integer(classData.length), domain};
                return (Class)defineClassProtectionDomain.invoke(this, args);
            }
            catch (InvocationTargetException ite) {
                Throwable t = ite.getTargetException();
                if (t instanceof ClassFormatError) {
                    throw (ClassFormatError)t;
                }
                else {
                    throw new IOException(t.toString());
                }
            }
            catch (Exception e) {
                throw new IOException(e.toString());
            }
        }
        else {
            return defineClass(classname, classData, 0, classData.length); 
        }
    }
    /**
     * Search for and load a class on the classpath of this class loader.
     *
     * @param name the classname to be loaded.
     * 
     * @return the required Class object
     *
     * @throws ClassNotFoundException if the requested class does not exist on
     * this loader's classpath.
     */
    public Class findClass(String name) throws ClassNotFoundException {
        project.log(""Finding class "" + name, Project.MSG_DEBUG);
        try {
            return findClass(name, classpath);
        }
        catch (ClassNotFoundException e) {
            throw e;
        }
    }
    /**
     * Find a class on the given classpath.
     */
    private Class findClass(String name, Path path) throws ClassNotFoundException {
        // we need to search the components of the path to see if we can find the 
        // class we want. 
        InputStream stream = null;
        String classFilename = getClassFilename(name);
        try {
            String[] pathElements = path.list();
            for (int i = 0; i < pathElements.length && stream == null; ++i) {
                File pathComponent = project.resolveFile((String)pathElements[i]);
                stream = getResourceStream(pathComponent, classFilename);
            }
            if (stream == null) {
                throw new ClassNotFoundException();
            }
            return getClassFromStream(stream, name);
        }
        catch (IOException ioe) {
            ioe.printStackTrace();
            throw new ClassNotFoundException();
        }
        finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            }
            catch (IOException e) {}
        }
    }
    /**
     * Find a system class (which should be loaded from the same classloader as the Ant core).
     */
    private Class findBaseClass(String name) throws ClassNotFoundException {
        ClassLoader base = AntClassLoader.class.getClassLoader();
        if (base == null) {
            return findSystemClass(name);
        }
        else {
            return base.loadClass(name);
        }
    }
}
"
org.apache.tools.ant.BuildEvent,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.EventObject;
public class BuildEvent extends EventObject {
    private Project project;
    private Target target;
    private Task task;
    private String message;
    private int priority = Project.MSG_VERBOSE;
    private Throwable exception;
    /**
     * Construct a BuildEvent for a project level event
     *
     * @param project the project that emitted the event.
     */
    public BuildEvent(Project project) {
        super(project);
        this.project = project;
        this.target = null;
        this.task = null;
    }
    /**
     * Construct a BuildEvent for a target level event
     *
     * @param target the target that emitted the event.
     */
    public BuildEvent(Target target) {
        super(target);
        this.project = target.getProject();
        this.target = target;
        this.task = null;
    }
    /**
     * Construct a BuildEvent for a task level event
     *
     * @param task the task that emitted the event.
     */
    public BuildEvent(Task task) {
        super(task);
        this.project = task.getProject();
        this.target = task.getOwningTarget();
        this.task = task;
    }
    public void setMessage(String message, int priority) {
        this.message = message;
        this.priority = priority;
    }
    public void setException(Throwable exception) {
        this.exception = exception;
    }
    /**
     *  Returns the project that fired this event.
     */
    public Project getProject() {
        return project;
    }
    /**
     *  Returns the target that fired this event.
     */
    public Target getTarget() {
        return target;
    }
    /**
     *  Returns the task that fired this event.
     */
    public Task getTask() {
        return task;
    }
    /**
     *  Returns the logging message. This field will only be set
     *  for ""messageLogged"" events.
     *
     *  @see BuildListener#messageLogged(BuildEvent)
     */
    public String getMessage() {
        return message;
    }
    /**
     *  Returns the priority of the logging message. This field will only
     *  be set for ""messageLogged"" events.
     *
     *  @see BuildListener#messageLogged(BuildEvent)
     */
    public int getPriority(){
        return priority;
    }
    /**
     *  Returns the exception that was thrown, if any. This field will only
     *  be set for ""taskFinished"", ""targetFinished"", and ""buildFinished"" events.
     *
     *  @see BuildListener#taskFinished(BuildEvent)
     *  @see BuildListener#targetFinished(BuildEvent)
     *  @see BuildListener#buildFinished(BuildEvent)
     */
    public Throwable getException() {
        return exception;
    }
}
"
org.apache.tools.ant.BuildException,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
/**
 * Signals an error condition during a build.
 *
 * @author James Duncan Davidson
 */
public class BuildException extends RuntimeException {
    /** Exception that might have caused this one. */
    private Throwable cause;
    /** Location in the build file where the exception occured */
    private Location location = Location.UNKNOWN_LOCATION;
    /**
     * Constructs a build exception with no descriptive information.
     */
    public BuildException() {
        super();
    }
    /**
     * Constructs an exception with the given descriptive message.
     * @param msg Description of or information about the exception.
     */
    public BuildException(String msg) {
        super(msg);
    }
    /**
     * Constructs an exception with the given message and exception as
     * a root cause.
     * @param msg Description of or information about the exception.
     * @param cause Throwable that might have cause this one.
     */
    public BuildException(String msg, Throwable cause) {
        super(msg);
        this.cause = cause;
    }
    /**
     * Constructs an exception with the given message and exception as
     * a root cause and a location in a file.
     * @param msg Description of or information about the exception.
     * @param cause Exception that might have cause this one.
     * @param location Location in the project file where the error occured.
     */
    public BuildException(String msg, Throwable cause, Location location) {
        this(msg, cause);
        this.location = location;
    }
    /**
     * Constructs an exception with the given exception as a root cause.
     * @param cause Exception that might have caused this one.
     */
    public BuildException(Throwable cause) {
        super(cause.toString());
        this.cause = cause;
    }
    /**
     * Constructs an exception with the given descriptive message and a location
     * in a file.
     * @param msg Description of or information about the exception.
     * @param location Location in the project file where the error occured.
     */
    public BuildException(String msg, Location location) {
        super(msg);
        this.location = location;
    }
    /**
     * Constructs an exception with the given exception as
     * a root cause and a location in a file.
     * @param cause Exception that might have cause this one.
     * @param location Location in the project file where the error occured.
     */
    public BuildException(Throwable cause, Location location) {
        this(cause);
        this.location = location;
    }
    /**
     * Returns the nested exception.
     */
    public Throwable getException() {
        return cause;
    }
    /**
     * Returns the location of the error and the error message.
     */
    public String toString() {
        return location.toString() + getMessage();
    }
    /**
     * Sets the file location where the error occured.
     */
    public void setLocation(Location location) {
        this.location = location;
    }
    /**
     * Returns the file location where the error occured.
     */
    public Location getLocation() {
        return location;
    }
    // Override stack trace methods to show original cause:
    public void printStackTrace() {
        printStackTrace(System.err);
    }
    public void printStackTrace(PrintStream ps) {
        synchronized (ps) {
            ps.println(this);
            if (cause != null) {
                ps.println(""--- Nested Exception ---"");
                cause.printStackTrace(ps);
            }
        }
    }
    public void printStackTrace(PrintWriter pw) {
        synchronized (pw) {
            pw.println(this);
            if (cause != null) {
                pw.println(""--- Nested Exception ---"");
                cause.printStackTrace(pw);
            }
        }
    }
}
"
org.apache.tools.ant.BuildListener,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.EventListener;
/**
 *  Classes that implement this interface will be notified when
 *  things happend during a build.
 *
 *  @see BuildEvent
 *  @see Project#addBuildListener(BuildListener)
 */
public interface BuildListener extends EventListener {
    /**
     *  Fired before any targets are started.
     */
    public void buildStarted(BuildEvent event);
    /**
     *  Fired after the last target has finished. This event
     *  will still be thrown if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void buildFinished(BuildEvent event);
    /**
     *  Fired when a target is started.
     *
     *  @see BuildEvent#getTarget()
     */
    public void targetStarted(BuildEvent event);
    /**
     *  Fired when a target has finished. This event will
     *  still be thrown if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void targetFinished(BuildEvent event);
    /**
     *  Fired when a task is started.
     *
     *  @see BuildEvent#getTask()
     */
    public void taskStarted(BuildEvent event);
    /**
     *  Fired when a task has finished. This event will still
     *  be throw if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void taskFinished(BuildEvent event);
    /**
     *  Fired whenever a message is logged.
     *
     *  @see BuildEvent#getMessage()
     *  @see BuildEvent#getPriority()
     */
    public void messageLogged(BuildEvent event);
}"
org.apache.tools.ant.BuildLogger,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
/**
 * Interface used by Ant to log the build output. 
 *
 * A build logger is a build listener which has the 'right' to send output to the
 * ant log, which is usually System.out unles redirected by the -logfile option.
 *
 * @author Conor MacNeill
 */
public interface BuildLogger extends BuildListener {
    /**
     * Set the msgOutputLevel this logger is to respond to.
     *
     * Only messages with a message level lower than or equal to the given level are 
     * output to the log.
     * <P>
     * Constants for the message levels are in Project.java. The order of
     * the levels, from least to most verbose, is MSG_ERR, MSG_WARN,
     * MSG_INFO, MSG_VERBOSE, MSG_DEBUG.
     *
     * @param level the logging level for the logger.
     */
    public void setMessageOutputLevel(int level);
    /**
     * Set the output stream to which this logger is to send its output.
     *
     * @param output the output stream for the logger.
     */
    public void setOutputPrintStream(PrintStream output);
    /**
     * Set this logger to produce emacs (and other editor) friendly output.
     *
     * @param emacsMode true if output is to be unadorned so that emacs and other
     * editors can parse files names, etc.
     */
    public void setEmacsMode(boolean emacsMode);
    /**
     * Set the output stream to which this logger is to send error messages.
     *
     * @param err the error stream for the logger.
     */
    public void setErrorPrintStream(PrintStream err);
}
"
org.apache.tools.ant.Constants,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included with this distribution in
 * the LICENSE file.
 */
package org.apache.tools.ant;
/**
 * Abstract interface to hold constants.
 * 
 * @author <a href=""mailto:donaldp@apache.org"">Peter Donald</a>
 */
interface Constants {
}
"
org.apache.tools.ant.DefaultLogger,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
/**
 *  Writes build event to a PrintStream. Currently, it
 *  only writes which targets are being executed, and
 *  any messages that get logged.
 */
public class DefaultLogger implements BuildLogger {
    private static int LEFT_COLUMN_SIZE = 12;
    protected PrintStream out;
    protected PrintStream err;
    protected int msgOutputLevel = Project.MSG_ERR;
    private long startTime = System.currentTimeMillis();
    protected static String lSep = System.getProperty(""line.separator"");
    protected boolean emacsMode = false;
    /**
     * Set the msgOutputLevel this logger is to respond to.
     *
     * Only messages with a message level lower than or equal to the given level are 
     * output to the log.
     * <P>
     * Constants for the message levels are in Project.java. The order of
     * the levels, from least to most verbose, is MSG_ERR, MSG_WARN,
     * MSG_INFO, MSG_VERBOSE, MSG_DEBUG.
     *
     * The default message level for DefaultLogger is Project.MSG_ERR.
     *
     * @param level the logging level for the logger.
     */
    public void setMessageOutputLevel(int level) {
        this.msgOutputLevel = level;
    }
    /**
     * Set the output stream to which this logger is to send its output.
     *
     * @param output the output stream for the logger.
     */
    public void setOutputPrintStream(PrintStream output) {
        this.out = output;
    }
    /**
     * Set the output stream to which this logger is to send error messages.
     *
     * @param err the error stream for the logger.
     */
    public void setErrorPrintStream(PrintStream err) {
        this.err = err;
    }
    /**
     * Set this logger to produce emacs (and other editor) friendly output.
     *
     * @param emacsMode true if output is to be unadorned so that emacs and other
     * editors can parse files names, etc.
     */
    public void setEmacsMode(boolean emacsMode) {
        this.emacsMode = emacsMode;
    }
    public void buildStarted(BuildEvent event) {
        startTime = System.currentTimeMillis();
    }
    /**
     *  Prints whether the build succeeded or failed, and
     *  any errors the occured during the build.
     */
    public void buildFinished(BuildEvent event) {
        Throwable error = event.getException();
        if (error == null) {
            out.println(lSep + ""BUILD SUCCESSFUL"");
        }
        else {
            err.println(lSep + ""BUILD FAILED"" + lSep);
            error.printStackTrace(err);
        }
        out.println(lSep + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
    }
    public void targetStarted(BuildEvent event) {
        if (Project.MSG_INFO <= msgOutputLevel) {
            out.println(lSep + event.getTarget().getName() + "":"");
        }
    }
    public void targetFinished(BuildEvent event) {
    }
    public void taskStarted(BuildEvent event) {}
    public void taskFinished(BuildEvent event) {}
    public void messageLogged(BuildEvent event) {
        PrintStream logTo = event.getPriority() == Project.MSG_ERR ? err : out;
        // Filter out messages based on priority
        if (event.getPriority() <= msgOutputLevel) {
            // Print out the name of the task if we're in one
            if (event.getTask() != null) {
                String name = event.getTask().getTaskName();
                if (!emacsMode) {
                    String msg = ""["" + name + ""] "";
                    for (int i = 0; i < (LEFT_COLUMN_SIZE - msg.length()); i++) {
                        logTo.print("" "");
                    }
                    logTo.print(msg);
                }
            }
            // Print the message
            logTo.println(event.getMessage());
        }
    }
    protected static String formatTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        if (minutes > 0) {
            return Long.toString(minutes) + "" minute""
                + (minutes == 1 ? "" "" : ""s "")
                + Long.toString(seconds%60) + "" second""
                + (seconds%60 == 1 ? """" : ""s"");
        }
        else {
            return Long.toString(seconds) + "" second""
                + (seconds%60 == 1 ? """" : ""s"");
        }
    }
}
"
org.apache.tools.ant.DesirableFilter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */ 
package org.apache.tools.ant;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
/**
 * Filters filenames to determine whether or not the file is desirable.
 *
 * @author Jason Hunter [jhunter@servlets.com]
 * @author james@x180.com
 */
public class DesirableFilter implements FilenameFilter {
    /**
     * Test the given filename to determine whether or not it's desirable.
     * This helps tasks filter temp files and files used by CVS.
     */
    public boolean accept(File dir, String name) {
        // emacs save file
        if (name.endsWith(""~"")) {
            return false;
        }
        // emacs autosave file
        if (name.startsWith(""#"") && name.endsWith(""#"")) {
            return false;
        }
        // openwindows text editor does this I think
        if (name.startsWith(""%"") && name.endsWith(""%"")) {
            return false;
        }
        /* CVS stuff -- hopefully there won't be a case with
         * an all cap file/dir named ""CVS"" that somebody wants
         * to keep around...
         */
        if (name.equals(""CVS"")) {
            return false;
        }
        /* If we are going to ignore CVS might as well ignore 
         * this one as well...
         */
        if (name.equals("".cvsignore"")){
            return false;
        }
        // default
        return true;
    }
}
"
org.apache.tools.ant.DirectoryScanner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
import java.util.*;
/**
 * Class for scanning a directory for files/directories that match a certain
 * criteria.
 * <p>
 * These criteria consist of a set of include and exclude patterns. With these
 * patterns, you can select which files you want to have included, and which
 * files you want to have excluded.
 * <p>
 * The idea is simple. A given directory is recursively scanned for all files
 * and directories. Each file/directory is matched against a set of include
 * and exclude patterns. Only files/directories that match at least one
 * pattern of the include pattern list, and don't match a pattern of the
 * exclude pattern list will be placed in the list of files/directories found.
 * <p>
 * When no list of include patterns is supplied, ""**"" will be used, which
 * means that everything will be matched. When no list of exclude patterns is
 * supplied, an empty list is used, such that nothing will be excluded.
 * <p>
 * The pattern matching is done as follows:
 * The name to be matched is split up in path segments. A path segment is the
 * name of a directory or file, which is bounded by
 * <code>File.separator</code> ('/' under UNIX, '\' under Windows).
 * E.g. ""abc/def/ghi/xyz.java"" is split up in the segments ""abc"", ""def"", ""ghi""
 * and ""xyz.java"".
 * The same is done for the pattern against which should be matched.
 * <p>
 * Then the segments of the name and the pattern will be matched against each
 * other. When '**' is used for a path segment in the pattern, then it matches
 * zero or more path segments of the name.
 * <p>
 * There are special case regarding the use of <code>File.separator</code>s at
 * the beginningof the pattern and the string to match:<br>
 * When a pattern starts with a <code>File.separator</code>, the string
 * to match must also start with a <code>File.separator</code>.
 * When a pattern does not start with a <code>File.separator</code>, the
 * string to match may not start with a <code>File.separator</code>.
 * When one of these rules is not obeyed, the string will not
 * match.
 * <p>
 * When a name path segment is matched against a pattern path segment, the
 * following special characters can be used:
 * '*' matches zero or more characters,
 * '?' matches one character.
 * <p>
 * Examples:
 * <p>
 * ""**\*.class"" matches all .class files/dirs in a directory tree.
 * <p>
 * ""test\a??.java"" matches all files/dirs which start with an 'a', then two
 * more characters and then "".java"", in a directory called test.
 * <p>
 * ""**"" matches everything in a directory tree.
 * <p>
 * ""**\test\**\XYZ*"" matches all files/dirs that start with ""XYZ"" and where
 * there is a parent directory called test (e.g. ""abc\test\def\ghi\XYZ123"").
 * <p>
 * Example of usage:
 * <pre>
 *   String[] includes = {""**\\*.class""};
 *   String[] excludes = {""modules\\*\\**""};
 *   ds.setIncludes(includes);
 *   ds.setExcludes(excludes);
 *   ds.setBasedir(new File(""test""));
 *   ds.scan();
 *
 *   System.out.println(""FILES:"");
 *   String[] files = ds.getIncludedFiles();
 *   for (int i = 0; i < files.length;i++) {
 *     System.out.println(files[i]);
 *   }
 * </pre>
 * This will scan a directory called test for .class files, but excludes all
 * .class files in all directories under a directory called ""modules""
 *
 * @author Arnout J. Kuiper <a href=""mailto:ajkuiper@wxs.nl"">ajkuiper@wxs.nl</a>
 */
public class DirectoryScanner implements FileScanner {
    /**
     * Patterns that should be excluded by default.
     *
     * @see #addDefaultExcludes()
     */
    protected final static String[] DEFAULTEXCLUDES = {
        ""**/*~"",
        ""**/#*#"",
        ""**/%*%"",
        ""**/CVS"",
        ""**/CVS/**"",
        ""**/.cvsignore""
    };
    /**
     * The base directory which should be scanned.
     */
    protected File basedir;
    /**
     * The patterns for the files that should be included.
     */
    protected String[] includes;
    /**
     * The patterns for the files that should be excluded.
     */
    protected String[] excludes;
    /**
     * The files that where found and matched at least one includes, and matched
     * no excludes.
     */
    protected Vector filesIncluded;
    /**
     * The files that where found and did not match any includes.
     */
    protected Vector filesNotIncluded;
    /**
     * The files that where found and matched at least one includes, and also
     * matched at least one excludes.
     */
    protected Vector filesExcluded;
    /**
     * The directories that where found and matched at least one includes, and
     * matched no excludes.
     */
    protected Vector dirsIncluded;
    /**
     * The directories that where found and did not match any includes.
     */
    protected Vector dirsNotIncluded;
    /**
     * The files that where found and matched at least one includes, and also
     * matched at least one excludes.
     */
    protected Vector dirsExcluded;
    /**
     * Have the Vectors holding our results been built by a slow scan?
     */
    protected boolean haveSlowResults = false;
    /**
     * Constructor.
     */
    public DirectoryScanner() {
    }
    /**
     * Does the path match the start of this pattern up to the first ""**"".
     +
     * <p>This is not a general purpose test and should only be used if you
     * can live with false positives.</p>
     *
     * <p><code>pattern=**\\a</code> and <code>str=b</code> will yield true.
     *
     * @param pattern the (non-null) pattern to match against
     * @param str     the (non-null) string (path) to match
     */
    protected static boolean matchPatternStart(String pattern, String str) {
        // When str starts with a File.separator, pattern has to start with a
        // File.separator.
        // When pattern starts with a File.separator, str has to start with a
        // File.separator.
        if (str.startsWith(File.separator) !=
            pattern.startsWith(File.separator)) {
            return false;
        }
        Vector patDirs = new Vector();
        StringTokenizer st = new StringTokenizer(pattern,File.separator);
        while (st.hasMoreTokens()) {
            patDirs.addElement(st.nextToken());
        }
        Vector strDirs = new Vector();
        st = new StringTokenizer(str,File.separator);
        while (st.hasMoreTokens()) {
            strDirs.addElement(st.nextToken());
        }
        int patIdxStart = 0;
        int patIdxEnd   = patDirs.size()-1;
        int strIdxStart = 0;
        int strIdxEnd   = strDirs.size()-1;
        // up to first '**'
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = (String)patDirs.elementAt(patIdxStart);
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir,(String)strDirs.elementAt(strIdxStart))) {
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd) {
            // String is exhausted
            return true;
        } else if (patIdxStart > patIdxEnd) {
            // String not exhausted, but pattern is. Failure.
            return false;
        } else {
            // pattern now holds ** while string is not exhausted
            // this will generate false positives but we can live with that.
            return true;
        }
    }
    /**
     * Matches a path against a pattern.
     *
     * @param pattern the (non-null) pattern to match against
     * @param str     the (non-null) string (path) to match
     *
     * @return <code>true</code> when the pattern matches against the string.
     *         <code>false</code> otherwise.
     */
    protected static boolean matchPath(String pattern, String str) {
        // When str starts with a File.separator, pattern has to start with a
        // File.separator.
        // When pattern starts with a File.separator, str has to start with a
        // File.separator.
        if (str.startsWith(File.separator) !=
            pattern.startsWith(File.separator)) {
            return false;
        }
        Vector patDirs = new Vector();
        StringTokenizer st = new StringTokenizer(pattern,File.separator);
        while (st.hasMoreTokens()) {
            patDirs.addElement(st.nextToken());
        }
        Vector strDirs = new Vector();
        st = new StringTokenizer(str,File.separator);
        while (st.hasMoreTokens()) {
            strDirs.addElement(st.nextToken());
        }
        int patIdxStart = 0;
        int patIdxEnd   = patDirs.size()-1;
        int strIdxStart = 0;
        int strIdxEnd   = strDirs.size()-1;
        // up to first '**'
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = (String)patDirs.elementAt(patIdxStart);
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir,(String)strDirs.elementAt(strIdxStart))) {
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd) {
            // String is exhausted
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (!patDirs.elementAt(i).equals(""**"")) {
                    return false;
                }
            }
            return true;
        } else {
            if (patIdxStart > patIdxEnd) {
                // String not exhausted, but pattern is. Failure.
                return false;
            }
        }
        // up to last '**'
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = (String)patDirs.elementAt(patIdxEnd);
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir,(String)strDirs.elementAt(strIdxEnd))) {
                return false;
            }
            patIdxEnd--;
            strIdxEnd--;
        }
        if (strIdxStart > strIdxEnd) {
            // String is exhausted
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (!patDirs.elementAt(i).equals(""**"")) {
                    return false;
                }
            }
            return true;
        }
        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
            int patIdxTmp = -1;
            for (int i = patIdxStart+1; i <= patIdxEnd; i++) {
                if (patDirs.elementAt(i).equals(""**"")) {
                    patIdxTmp = i;
                    break;
                }
            }
            if (patIdxTmp == patIdxStart+1) {
                // '**/**' situation, so skip one
                patIdxStart++;
                continue;
            }
            // Find the pattern between padIdxStart & padIdxTmp in str between
            // strIdxStart & strIdxEnd
            int patLength = (patIdxTmp-patIdxStart-1);
            int strLength = (strIdxEnd-strIdxStart+1);
            int foundIdx  = -1;
strLoop:
            for (int i = 0; i <= strLength - patLength; i++) {
                for (int j = 0; j < patLength; j++) {
                    String subPat = (String)patDirs.elementAt(patIdxStart+j+1);
                    String subStr = (String)strDirs.elementAt(strIdxStart+i+j);
                    if (!match(subPat,subStr)) {
                        continue strLoop;
                    }
                }
                foundIdx = strIdxStart+i;
                break;
            }
            if (foundIdx == -1) {
                return false;
            }
            patIdxStart = patIdxTmp;
            strIdxStart = foundIdx+patLength;
        }
        for (int i = patIdxStart; i <= patIdxEnd; i++) {
            if (!patDirs.elementAt(i).equals(""**"")) {
                return false;
            }
        }
        return true;
    }
    /**
     * Matches a string against a pattern. The pattern contains two special
     * characters:
     * '*' which means zero or more characters,
     * '?' which means one and only one character.
     *
     * @param pattern the (non-null) pattern to match against
     * @param str     the (non-null) string that must be matched against the
     *                pattern
     *
     * @return <code>true</code> when the string matches against the pattern,
     *         <code>false</code> otherwise.
     */
    protected static boolean match(String pattern, String str) {
        char[] patArr = pattern.toCharArray();
        char[] strArr = str.toCharArray();
        int patIdxStart = 0;
        int patIdxEnd   = patArr.length-1;
        int strIdxStart = 0;
        int strIdxEnd   = strArr.length-1;
        char ch;
        boolean containsStar = false;
        for (int i = 0; i < patArr.length; i++) {
            if (patArr[i] == '*') {
                containsStar = true;
                break;
            }
        }
        if (!containsStar) {
            // No '*'s, so we make a shortcut
            if (patIdxEnd != strIdxEnd) {
                return false; // Pattern and string do not have the same size
            }
            for (int i = 0; i <= patIdxEnd; i++) {
                ch = patArr[i];
                if (ch != '?' && ch != strArr[i]) {
                    return false; // Character mismatch
                }
            }
            return true; // String matches against pattern
        }
        if (patIdxEnd == 0) {
            return true; // Pattern contains only '*', which matches anything
        }
        // Process characters before first star
        while((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {
            if (ch != '?' && ch != strArr[strIdxStart]) {
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd) {
            // All characters in the string are used. Check if only '*'s are
            // left in the pattern. If so, we succeeded. Otherwise failure.
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (patArr[i] != '*') {
                    return false;
                }
            }
            return true;
        }
        // Process characters after last star
        while((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {
            if (ch != '?' && ch != strArr[strIdxEnd]) {
                return false;
            }
            patIdxEnd--;
            strIdxEnd--;
        }
        if (strIdxStart > strIdxEnd) {
            // All characters in the string are used. Check if only '*'s are
            // left in the pattern. If so, we succeeded. Otherwise failure.
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (patArr[i] != '*') {
                    return false;
                }
            }
            return true;
        }
        // process pattern between stars. padIdxStart and patIdxEnd point
        // always to a '*'.
        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
            int patIdxTmp = -1;
            for (int i = patIdxStart+1; i <= patIdxEnd; i++) {
                if (patArr[i] == '*') {
                    patIdxTmp = i;
                    break;
                }
            }
            if (patIdxTmp == patIdxStart+1) {
                // Two stars next to each other, skip the first one.
                patIdxStart++;
                continue;
            }
            // Find the pattern between padIdxStart & padIdxTmp in str between
            // strIdxStart & strIdxEnd
            int patLength = (patIdxTmp-patIdxStart-1);
            int strLength = (strIdxEnd-strIdxStart+1);
            int foundIdx  = -1;
strLoop:
            for (int i = 0; i <= strLength - patLength; i++) {
                for (int j = 0; j < patLength; j++) {
                    ch = patArr[patIdxStart+j+1];
                    if (ch != '?' && ch != strArr[strIdxStart+i+j]) {
                        continue strLoop;
                    }
                }
                foundIdx = strIdxStart+i;
                break;
            }
            if (foundIdx == -1) {
                return false;
            }
            patIdxStart = patIdxTmp;
            strIdxStart = foundIdx+patLength;
        }
        // All characters in the string are used. Check if only '*'s are left
        // in the pattern. If so, we succeeded. Otherwise failure.
        for (int i = patIdxStart; i <= patIdxEnd; i++) {
            if (patArr[i] != '*') {
                return false;
            }
        }
        return true;
    }
    /**
     * Sets the basedir for scanning. This is the directory that is scanned
     * recursively. All '/' and '\' characters are replaced by
     * <code>File.separatorChar</code>. So the separator used need not match
     * <code>File.separatorChar</code>.
     *
     * @param basedir the (non-null) basedir for scanning
     */
    public void setBasedir(String basedir) {
        setBasedir(new File(basedir.replace('/',File.separatorChar).replace('\\',File.separatorChar)));
    }
    /**
     * Sets the basedir for scanning. This is the directory that is scanned
     * recursively.
     *
     * @param basedir the basedir for scanning
     */
    public void setBasedir(File basedir) {
        this.basedir = basedir;
    }
    /**
     * Gets the basedir that is used for scanning. This is the directory that
     * is scanned recursively.
     *
     * @return the basedir that is used for scanning
     */
    public File getBasedir() {
        return basedir;
    }
    /**
     * Sets the set of include patterns to use. All '/' and '\' characters are
     * replaced by <code>File.separatorChar</code>. So the separator used need
     * not match <code>File.separatorChar</code>.
     * <p>
     * When a pattern ends with a '/' or '\', ""**"" is appended.
     *
     * @param includes list of include patterns
     */
    public void setIncludes(String[] includes) {
        if (includes == null) {
            this.includes = null;
        } else {
            this.includes = new String[includes.length];
            for (int i = 0; i < includes.length; i++) {
                String pattern;
                pattern = includes[i].replace('/',File.separatorChar).replace('\\',File.separatorChar);
                if (pattern.endsWith(File.separator)) {
                    pattern += ""**"";
                }
                this.includes[i] = pattern;
            }
        }
    }
    /**
     * Sets the set of exclude patterns to use. All '/' and '\' characters are
     * replaced by <code>File.separatorChar</code>. So the separator used need
     * not match <code>File.separatorChar</code>.
     * <p>
     * When a pattern ends with a '/' or '\', ""**"" is appended.
     *
     * @param excludes list of exclude patterns
     */
    public void setExcludes(String[] excludes) {
        if (excludes == null) {
            this.excludes = null;
        } else {
            this.excludes = new String[excludes.length];
            for (int i = 0; i < excludes.length; i++) {
                String pattern;
                pattern = excludes[i].replace('/',File.separatorChar).replace('\\',File.separatorChar);
                if (pattern.endsWith(File.separator)) {
                    pattern += ""**"";
                }
                this.excludes[i] = pattern;
            }
        }
    }
    /**
     * Scans the base directory for files that match at least one include
     * pattern, and don't match any exclude patterns.
     *
     * @exception IllegalStateException when basedir was set incorrecly
     */
    public void scan() {
        if (basedir == null) {
            throw new IllegalStateException(""No basedir set"");
        }
        if (!basedir.exists()) {
            throw new IllegalStateException(""basedir does not exist"");
        }
        if (!basedir.isDirectory()) {
            throw new IllegalStateException(""basedir is not a directory"");
        }
        if (includes == null) {
            // No includes supplied, so set it to 'matches all'
            includes = new String[1];
            includes[0] = ""**"";
        }
        if (excludes == null) {
            excludes = new String[0];
        }
        filesIncluded    = new Vector();
        filesNotIncluded = new Vector();
        filesExcluded    = new Vector();
        dirsIncluded     = new Vector();
        dirsNotIncluded  = new Vector();
        dirsExcluded     = new Vector();
        scandir(basedir, """", true);
    }
    /**
     * Toplevel invocation for the scan.
     *
     * <p>Returns immediately if a slow scan has already been requested.
     */
    protected void slowScan() {
        if (haveSlowResults) {
            return;
        }
        String[] excl = new String[dirsExcluded.size()];
        dirsExcluded.copyInto(excl);
        String[] notIncl = new String[dirsNotIncluded.size()];
        dirsNotIncluded.copyInto(notIncl);
        for (int i=0; i<excl.length; i++) {
            scandir(new File(basedir, excl[i]), excl[i]+File.separator, false);
        }
        for (int i=0; i<notIncl.length; i++) {
            if (!couldHoldIncluded(notIncl[i])) {
                scandir(new File(basedir, notIncl[i]), 
                        notIncl[i]+File.separator, false);
            }
        }
        haveSlowResults  = true;
    }
    /**
     * Scans the passed dir for files and directories. Found files and
     * directories are placed in their respective collections, based on the
     * matching of includes and excludes. When a directory is found, it is
     * scanned recursively.
     *
     * @param dir   the directory to scan
     * @param vpath the path relative to the basedir (needed to prevent
     *              problems with an absolute path when using dir)
     *
     * @see #filesIncluded
     * @see #filesNotIncluded
     * @see #filesExcluded
     * @see #dirsIncluded
     * @see #dirsNotIncluded
     * @see #dirsExcluded
     */
    protected void scandir(File dir, String vpath, boolean fast) {
        String[] newfiles = dir.list();
        if (newfiles == null) {
            /*
             * two reasons are mentioned in the API docs for File.list
             * (1) dir is not a directory. This is impossible as
             *     we wouldn't get here in this case.
             * (2) an IO error occurred (why doesn't it throw an exception 
             *     then???)
             */
            throw new BuildException(""IO error scanning directory ""
                                     + dir.getAbsolutePath());
        }
        for (int i = 0; i < newfiles.length; i++) {
            String name = vpath+newfiles[i];
            File   file = new File(dir,newfiles[i]);
            if (file.isDirectory()) {
                if (isIncluded(name)) {
                    if (!isExcluded(name)) {
                        dirsIncluded.addElement(name);
                        if (fast) {
                            scandir(file, name+File.separator, fast);
                        }
                    } else {
                        dirsExcluded.addElement(name);
                    }
                } else {
                    dirsNotIncluded.addElement(name);
                    if (fast && couldHoldIncluded(name)) {
                        scandir(file, name+File.separator, fast);
                    }
                }
                if (!fast) {
                    scandir(file, name+File.separator, fast);
                }
            } else if (file.isFile()) {
                if (isIncluded(name)) {
                    if (!isExcluded(name)) {
                        filesIncluded.addElement(name);
                    } else {
                        filesExcluded.addElement(name);
                    }
                } else {
                    filesNotIncluded.addElement(name);
                }
            }
        }
    }
    /**
     * Tests whether a name matches against at least one include pattern.
     *
     * @param name the name to match
     * @return <code>true</code> when the name matches against at least one
     *         include pattern, <code>false</code> otherwise.
     */
    protected boolean isIncluded(String name) {
        for (int i = 0; i < includes.length; i++) {
            if (matchPath(includes[i],name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Tests whether a name matches the start of at least one include pattern.
     *
     * @param name the name to match
     * @return <code>true</code> when the name matches against at least one
     *         include pattern, <code>false</code> otherwise.
     */
    protected boolean couldHoldIncluded(String name) {
        for (int i = 0; i < includes.length; i++) {
            if (matchPatternStart(includes[i],name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Tests whether a name matches against at least one exclude pattern.
     *
     * @param name the name to match
     * @return <code>true</code> when the name matches against at least one
     *         exclude pattern, <code>false</code> otherwise.
     */
    protected boolean isExcluded(String name) {
        for (int i = 0; i < excludes.length; i++) {
            if (matchPath(excludes[i],name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get the names of the files that matched at least one of the include
     * patterns, an matched none of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getIncludedFiles() {
        int count = filesIncluded.size();
        String[] files = new String[count];
        for (int i = 0; i < count; i++) {
            files[i] = (String)filesIncluded.elementAt(i);
        }
        return files;
    }
    /**
     * Get the names of the files that matched at none of the include patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getNotIncludedFiles() {
        slowScan();
        int count = filesNotIncluded.size();
        String[] files = new String[count];
        for (int i = 0; i < count; i++) {
            files[i] = (String)filesNotIncluded.elementAt(i);
        }
        return files;
    }
    /**
     * Get the names of the files that matched at least one of the include
     * patterns, an matched also at least one of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getExcludedFiles() {
        slowScan();
        int count = filesExcluded.size();
        String[] files = new String[count];
        for (int i = 0; i < count; i++) {
            files[i] = (String)filesExcluded.elementAt(i);
        }
        return files;
    }
    /**
     * Get the names of the directories that matched at least one of the include
     * patterns, an matched none of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getIncludedDirectories() {
        int count = dirsIncluded.size();
        String[] directories = new String[count];
        for (int i = 0; i < count; i++) {
            directories[i] = (String)dirsIncluded.elementAt(i);
        }
        return directories;
    }
    /**
     * Get the names of the directories that matched at none of the include
     * patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getNotIncludedDirectories() {
        slowScan();
        int count = dirsNotIncluded.size();
        String[] directories = new String[count];
        for (int i = 0; i < count; i++) {
            directories[i] = (String)dirsNotIncluded.elementAt(i);
        }
        return directories;
    }
    /**
     * Get the names of the directories that matched at least one of the include
     * patterns, an matched also at least one of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getExcludedDirectories() {
        slowScan();
        int count = dirsExcluded.size();
        String[] directories = new String[count];
        for (int i = 0; i < count; i++) {
            directories[i] = (String)dirsExcluded.elementAt(i);
        }
        return directories;
    }
    /**
     * Adds the array with default exclusions to the current exclusions set.
     *
     */
    public void addDefaultExcludes() {
        int excludesLength = excludes == null ? 0 : excludes.length;
        String[] newExcludes;
        newExcludes = new String[excludesLength + DEFAULTEXCLUDES.length];
        if (excludesLength > 0) {
            System.arraycopy(excludes,0,newExcludes,0,excludesLength);
        }
        for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {
            newExcludes[i+excludesLength] = DEFAULTEXCLUDES[i].replace('/',File.separatorChar).replace('\\',File.separatorChar);
        }
        excludes = newExcludes;
    }
}
"
org.apache.tools.ant.FileScanner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
/**
 * An interface used to describe the actions required by any type of 
 * directory scanner.
 */
public interface FileScanner {
    /**
     * Adds an array with default exclusions to the current exclusions set.
     *
     */
    public void addDefaultExcludes();
    /**
     * Gets the basedir that is used for scanning. This is the directory that
     * is scanned recursively.
     *
     * @return the basedir that is used for scanning
     */
    public File getBasedir();
    /**
     * Get the names of the directories that matched at least one of the include
     * patterns, an matched also at least one of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getExcludedDirectories();
    /**
     * Get the names of the files that matched at least one of the include
     * patterns, an matched also at least one of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getExcludedFiles();
    /**
     * Get the names of the directories that matched at least one of the include
     * patterns, an matched none of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getIncludedDirectories();
    /**
     * Get the names of the files that matched at least one of the include
     * patterns, an matched none of the exclude patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getIncludedFiles();
    /**
     * Get the names of the directories that matched at none of the include
     * patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the directories
     */
    public String[] getNotIncludedDirectories();
    /**
     * Get the names of the files that matched at none of the include patterns.
     * The names are relative to the basedir.
     *
     * @return the names of the files
     */
    public String[] getNotIncludedFiles();
    /**
     * Scans the base directory for files that match at least one include
     * pattern, and don't match any exclude patterns.
     *
     * @exception IllegalStateException when basedir was set incorrecly
     */
    public void scan();
    /**
     * Sets the basedir for scanning. This is the directory that is scanned
     * recursively. 
     *
     * @param basedir the (non-null) basedir for scanning
     */
    public void setBasedir(String basedir);
    /**
     * Sets the basedir for scanning. This is the directory that is scanned
     * recursively.
     *
     * @param basedir the basedir for scanning
     */
    public void setBasedir(File basedir);
    /**
     * Sets the set of exclude patterns to use.
     *
     * @param excludes list of exclude patterns
     */
    public void setExcludes(String[] excludes);
    /**
     * Sets the set of include patterns to use.
     *
     * @param includes list of include patterns
     */
    public void setIncludes(String[] includes);
}
"
org.apache.tools.ant.IncludeTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import org.apache.tools.ant.taskdefs.TaskdefsTest;
/**
 * Test the build file inclusion using XML entities.
 *
 * @author Conor MacNeill
 */
public class IncludeTest extends TaskdefsTest { 
    public IncludeTest(String name) { 
        super(name);
    }    
    public void test1() { 
        configureProject(""src/etc/testcases/core/include/basic/include.xml"");
        expectLog(""test1"", ""from included entity"");
    }
    public void test2() { 
        configureProject(""src/etc/testcases/core/include/frag#ment/include.xml"");
        expectLog(""test1"", ""from included entity"");
    }
    public void test3() { 
        configureProject(""src/etc/testcases/core/include/frag#ment/simple.xml"");
        expectLog(""test1"", ""from simple buildfile"");
    }
    public void test4() { 
        configureProject(""src/etc/testcases/core/include/basic/relative.xml"");
        expectLog(""test1"", ""from included entity"");
    }
    public void test5() { 
        configureProject(""src/etc/testcases/core/include/frag#ment/relative.xml"");
        expectLog(""test1"", ""from included entity"");
    }
}
"
org.apache.tools.ant.IntrospectionHelper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.EnumeratedAttribute;
import java.lang.reflect.*;
import java.io.File;
import java.util.*;
/**
 * Helper class that collects the methods a task or nested element
 * holds to set attributes, create nested elements or hold PCDATA
 * elements.
 *
 * @author Stefan Bodewig <a href=""mailto:stefan.bodewig@megabit.net"">stefan.bodewig@megabit.net</a> 
 */
public class IntrospectionHelper  {
    /**
     * holds the types of the attributes that could be set.
     */
    private Hashtable attributeTypes;
    /**
     * holds the attribute setter methods.
     */
    private Hashtable attributeSetters;
    /**
     * Holds the types of nested elements that could be created.
     */
    private Hashtable nestedTypes;
    /**
     * Holds methods to create nested elements.
     */
    private Hashtable nestedCreators;
    /**
     * The method to add PCDATA stuff.
     */
    private Method addText = null;
    /**
     * The Class that's been introspected.
     */
    private Class bean;
    /**
     * instances we've already created
     */
    private static Hashtable helpers = new Hashtable();
    private IntrospectionHelper(final Class bean) {
        attributeTypes = new Hashtable();
        attributeSetters = new Hashtable();
        nestedTypes = new Hashtable();
        nestedCreators = new Hashtable();
        this.bean = bean;
        Method[] methods = bean.getMethods();
        for (int i=0; i<methods.length; i++) {
            final Method m = methods[i];
            final String name = m.getName();
            Class returnType = m.getReturnType();
            Class[] args = m.getParameterTypes();
            // not really user settable properties on tasks
            if (org.apache.tools.ant.Task.class.isAssignableFrom(bean) 
                && args.length == 1 &&
                (
                 (
                  ""setLocation"".equals(name) && org.apache.tools.ant.Location.class.equals(args[0])
                  ) || (
                   ""setTaskType"".equals(name) && java.lang.String.class.equals(args[0])
                  )
                 )) {
                continue;
            }
            if (""addText"".equals(name)
                && java.lang.Void.TYPE.equals(returnType)
                && args.length == 1
                && java.lang.String.class.equals(args[0])) {
                addText = methods[i];
            } else if (name.startsWith(""set"")
                       && java.lang.Void.TYPE.equals(returnType)
                       && args.length == 1
                       && !args[0].isArray()) {
                String propName = getPropertyName(name, ""set"");
                AttributeSetter as = createAttributeSetter(m, args[0]);
                if (as != null) {
                    attributeTypes.put(propName, args[0]);
                    attributeSetters.put(propName, as);
                }
            } else if (name.startsWith(""create"")
                       && !returnType.isArray()
                       && !returnType.isPrimitive()
                       && args.length == 0) {
                String propName = getPropertyName(name, ""create"");
                nestedTypes.put(propName, returnType);
                nestedCreators.put(propName, new NestedCreator() {
                        public Object create(Object parent) 
                            throws InvocationTargetException, 
                            IllegalAccessException {
                            return m.invoke(parent, new Object[] {});
                        }
                    });
            } else if (name.startsWith(""add"")
                       && java.lang.Void.TYPE.equals(returnType)
                       && args.length == 1
                       && !java.lang.String.class.equals(args[0])
                       && !args[0].isArray()
                       && !args[0].isPrimitive()) {
                try {
                    final Constructor c = 
                        args[0].getConstructor(new Class[] {});
                    String propName = getPropertyName(name, ""add"");
                    nestedTypes.put(propName, args[0]);
                    nestedCreators.put(propName, new NestedCreator() {
                            public Object create(Object parent) 
                                throws InvocationTargetException, IllegalAccessException, InstantiationException {
                                Object o = c.newInstance(new Object[] {});
                                m.invoke(parent, new Object[] {o});
                                return o;
                            }
                        });
                } catch (NoSuchMethodException nse) {
                }
            }
        }
    }
    /**
     * Factory method for helper objects.
     */
    public synchronized static IntrospectionHelper getHelper(Class c) {
        IntrospectionHelper ih = (IntrospectionHelper) helpers.get(c);
        if (ih == null) {
            ih = new IntrospectionHelper(c);
            helpers.put(c, ih);
        }
        return ih;
    }
    /**
     * Sets the named attribute.
     */
    public void setAttribute(Project p, Object element, String attributeName, 
                             String value)
        throws BuildException {
        AttributeSetter as = (AttributeSetter) attributeSetters.get(attributeName);
        if (as == null) {
            String msg = ""Class "" + element.getClass().getName() +
                "" doesn't support the \"""" + attributeName + ""\"" attribute"";
            throw new BuildException(msg);
        }
        try {
            as.set(p, element, value);
        } catch (IllegalAccessException ie) {
            // impossible as getMethods should only return public methods
            throw new BuildException(ie);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }
    /**
     * Adds PCDATA areas.
     */
    public void addText(Object element, String text) {
        if (addText == null) {
            String msg = ""Class "" + element.getClass().getName() +
                "" doesn't support nested text elements"";
            throw new BuildException(msg);
        }
        try {
            addText.invoke(element, new String[] {text});
        } catch (IllegalAccessException ie) {
            // impossible as getMethods should only return public methods
            throw new BuildException(ie);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }
    /**
     * Creates a named nested element.
     */
    public Object createElement(Object element, String elementName) 
        throws BuildException {
        NestedCreator nc = (NestedCreator) nestedCreators.get(elementName);
        if (nc == null) {
            String msg = ""Class "" + element.getClass().getName() +
                "" doesn't support the nested \"""" + elementName + ""\"" element"";
            throw new BuildException(msg);
        }
        try {
            return nc.create(element);
        } catch (IllegalAccessException ie) {
            // impossible as getMethods should only return public methods
            throw new BuildException(ie);
        } catch (InstantiationException ine) {
            // impossible as getMethods should only return public methods
            throw new BuildException(ine);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }
    /**
     * returns the type of a named nested element.
     */
    public Class getElementType(String elementName) 
        throws BuildException {
        Class nt = (Class) nestedTypes.get(elementName);
        if (nt == null) {
            String msg = ""Class "" + bean.getName() +
                "" doesn't support the nested \"""" + elementName + ""\"" element"";
            throw new BuildException(msg);
        }
        return nt;
    }
    /**
     * returns the type of a named attribute.
     */
    public Class getAttributeType(String attributeName) 
        throws BuildException {
        Class at = (Class) attributeTypes.get(attributeName);
        if (at == null) {
            String msg = ""Class "" + bean.getName() +
                "" doesn't support the \"""" + attributeName + ""\"" attribute"";
            throw new BuildException(msg);
        }
        return at;
    }
    /**
     * Does the introspected class support PCDATA?
     */
    public boolean supportsCharacters() {
        return addText != null;
    }
    /**
     * Return all attribues supported by the introspected class.
     */
    public Enumeration getAttributes() {
        return attributeSetters.keys();
    }
    /**
     * Return all nested elements supported by the introspected class.
     */
    public Enumeration getNestedElements() {
        return nestedTypes.keys();
    }
    /**
     * Create a proper implementation of AttributeSetter for the given
     * attribute type.  
     */
    private AttributeSetter createAttributeSetter(final Method m,
                                                  final Class arg) {
        // simplest case - setAttribute expects String
        if (java.lang.String.class.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new String[] {value});
                    }
                };
        // now for the primitive types, use their wrappers
        } else if (java.lang.Character.class.equals(arg)
                   || java.lang.Character.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Character[] {new Character(value.charAt(0))});
                    }
                };
        } else if (java.lang.Byte.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Byte[] {new Byte(value)});
                    }
                };
        } else if (java.lang.Short.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Short[] {new Short(value)});
                    }
                };
        } else if (java.lang.Integer.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Integer[] {new Integer(value)});
                    }
                };
        } else if (java.lang.Long.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Long[] {new Long(value)});
                    }
                };
        } else if (java.lang.Float.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Float[] {new Float(value)});
                    }
                };
        } else if (java.lang.Double.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Double[] {new Double(value)});
                    }
                };
        // boolean gets an extra treatment, because we have a nice method 
        // in Project
        } else if (java.lang.Boolean.class.equals(arg) 
                   || java.lang.Boolean.TYPE.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, 
                                 new Boolean[] {new Boolean(Project.toBoolean(value))});
                    }
                };
        // Class doesn't have a String constructor but a decent factory method
        } else if (java.lang.Class.class.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                        try {
                            m.invoke(parent, new Class[] {Class.forName(value)});
                        } catch (ClassNotFoundException ce) {
                            throw new BuildException(ce);
                        }
                    }
                };
        // resolve relative paths through Project
        } else if (java.io.File.class.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new File[] {p.resolveFile(value)});
                    }
                };
        // resolve relative paths through Project
        } else if (org.apache.tools.ant.types.Path.class.equals(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException {
                        m.invoke(parent, new Path[] {new Path(p, value)});
                    }
                };
        // EnumeratedAttributes have their own helper class
        } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(arg)) {
            return new AttributeSetter() {
                    public void set(Project p, Object parent, String value) 
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                        try {
                            org.apache.tools.ant.types.EnumeratedAttribute ea = (org.apache.tools.ant.types.EnumeratedAttribute)arg.newInstance();
                            ea.setValue(value);
                            m.invoke(parent, new EnumeratedAttribute[] {ea});
                        } catch (InstantiationException ie) {
                            throw new BuildException(ie);
                        }
                    }
                };
        // worst case. look for a public String constructor and use it
        } else {
            try {
                final Constructor c = 
                    arg.getConstructor(new Class[] {java.lang.String.class});
                return new AttributeSetter() {
                        public void set(Project p, Object parent, 
                                        String value) 
                            throws InvocationTargetException, IllegalAccessException, BuildException {
                            try {
                                m.invoke(parent, new Object[] {c.newInstance(new String[] {value})});
                            } catch (InstantiationException ie) {
                                throw new BuildException(ie);
                            }
                        }
                    };
            } catch (NoSuchMethodException nme) {
            }
        }
        return null;
    }
    /**
     * extract the name of a property from a method name - subtracting
     * a given prefix.  
     */
    private String getPropertyName(String methodName, String prefix) {
        int start = prefix.length();
        return methodName.substring(start).toLowerCase();
    }
    private interface NestedCreator {
        public Object create(Object parent) 
            throws InvocationTargetException, IllegalAccessException, InstantiationException;
    }
    private interface AttributeSetter {
        public void set(Project p, Object parent, String value)
            throws InvocationTargetException, IllegalAccessException, 
                   BuildException;
    }
}
"
org.apache.tools.ant.IntrospectionHelperTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import junit.framework.TestCase;
import junit.framework.AssertionFailedError;
import java.io.File;
import java.util.*;
/**
 * JUnit 3 testcases for org.apache.tools.ant.IntrospectionHelper.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class IntrospectionHelperTest extends TestCase {
    public static boolean isUnixStyle = File.pathSeparatorChar == ':';
    public IntrospectionHelperTest(String name) {
        super(name);
    }
    public void testAddText() throws BuildException {
        IntrospectionHelper ih = IntrospectionHelper.getHelper(java.lang.String.class);
        try {
            ih.addText("""", ""test"");
            fail(""String doesn\'t support addText"");
        } catch (BuildException be) {
        }
        ih = IntrospectionHelper.getHelper(getClass());
        ih.addText(this, ""test"");
        try {
            ih.addText(this, ""test2"");
            fail(""test2 shouldn\'t be equal to test"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
    }
    public void testSupportsCharacters() {
        IntrospectionHelper ih = IntrospectionHelper.getHelper(java.lang.String.class);
        assert(""String doesn\'t support addText"", !ih.supportsCharacters());
        ih = IntrospectionHelper.getHelper(getClass());
        assert(""IntrospectionHelperTest supports addText"", 
               ih.supportsCharacters());
    }
    public void addText(String text) {
        assertEquals(""test"", text);
    }
    public void testElementCreators() throws BuildException {
        IntrospectionHelper ih = IntrospectionHelper.getHelper(getClass());
        try {
            ih.getElementType(""one"");
            fail(""don't have element type one"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""two"");
            fail(""createTwo takes arguments"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""three"");
            fail(""createThree returns void"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""four"");
            fail(""createFour returns array"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""five"");
            fail(""createFive returns primitive type"");
        } catch (BuildException be) {
        }
        assertEquals(java.lang.String.class, ih.getElementType(""six""));
        assertEquals(""test"", ih.createElement(this, ""six""));
        try {
            ih.getElementType(""seven"");
            fail(""addSeven takes two arguments"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""eight"");
            fail(""addEight takes no arguments"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""nine"");
            fail(""nine return non void"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""ten"");
            fail(""addTen takes array argument"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""eleven"");
            fail(""addTen takes primitive argument"");
        } catch (BuildException be) {
        }
        try {
            ih.getElementType(""twelve"");
            fail(""no primitive constructor for java.lang.Class"");
        } catch (BuildException be) {
        }
        assertEquals(java.lang.StringBuffer.class, ih.getElementType(""thirteen""));
        assertEquals(""test"", ih.createElement(this, ""thirteen"").toString());
        try {
            ih.createElement(this, ""fourteen"");
            fail(""fourteen throws NullPointerException"");
        } catch (BuildException be) {
            assert(be.getException() instanceof NullPointerException);
        }
        try {
            ih.createElement(this, ""fourteen"");
            fail(""fifteen throws NullPointerException"");
        } catch (BuildException be) {
            assert(be.getException() instanceof NullPointerException);
        }
    }
    public void testGetNestedElements() {
        Hashtable h = new Hashtable();
        h.put(""six"", java.lang.String.class);
        h.put(""thirteen"", java.lang.StringBuffer.class);
        h.put(""fourteen"", java.lang.StringBuffer.class);
        h.put(""fifteen"", java.lang.StringBuffer.class);
        IntrospectionHelper ih = IntrospectionHelper.getHelper(getClass());
        Enumeration enum = ih.getNestedElements();
        while (enum.hasMoreElements()) {
            String name = (String) enum.nextElement();
            Class expect = (Class) h.get(name);
            assertNotNull(""Support for ""+name+"" in IntrospectioNHelperTest?"",
                          expect);
            assertEquals(""Return type of ""+name, expect, ih.getElementType(name));
            h.remove(name);
        }
        assert(""Found all"", h.isEmpty());
    }
    public Object createTwo(String s) {
        return null;
    }
    public void createThree() {}
    public Object[] createFour() {
        return null;
    }
    public int createFive() {
        return 0;
    }
    public String createSix() {
        return ""test"";
    }
    public StringBuffer createFifteen() {
        throw new NullPointerException();
    }
    public void addSeven(String s, String s2) {}
    public void addEight() {}
    public String addNine(String s) {
        return null;
    }
    public void addTen(String[] s) {}
    public void addEleven(int i) {}
    public void addTwelve(Class c) {}
    public void addThirteen(StringBuffer sb) {
        sb.append(""test"");
    }
    public void addFourteen(StringBuffer s) {
        throw new NullPointerException();
    }
    public void testAttributeSetters() throws BuildException {
        Project p = new Project();
        p.setBasedir(""/tmp"");
        IntrospectionHelper ih = IntrospectionHelper.getHelper(getClass());
        try {
            ih.setAttribute(p, this, ""one"", ""test"");
            fail(""setOne doesn't exist"");
        } catch (BuildException be) {
        }
        try {
            ih.setAttribute(p, this, ""two"", ""test"");
            fail(""setTwo returns non void"");
        } catch (BuildException be) {
        }
        try {
            ih.setAttribute(p, this, ""three"", ""test"");
            fail(""setThree takes no args"");
        } catch (BuildException be) {
        }
        try {
            ih.setAttribute(p, this, ""four"", ""test"");
            fail(""setFour takes two args"");
        } catch (BuildException be) {
        }
        try {
            ih.setAttribute(p, this, ""five"", ""test"");
            fail(""setFive takes array arg"");
        } catch (BuildException be) {
        }
        try {
            ih.setAttribute(p, this, ""six"", ""test"");
            fail(""Project doesn't have a String constructor"");
        } catch (BuildException be) {
        }
        ih.setAttribute(p, this, ""seven"", ""2"");
        try {
            ih.setAttribute(p, this, ""seven"", ""3"");
            fail(""2 shouldn't be equals to three"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""eight"", ""2"");
        try {
            ih.setAttribute(p, this, ""eight"", ""3"");
            fail(""2 shouldn't be equals to three - as int"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""nine"", ""2"");
        try {
            ih.setAttribute(p, this, ""nine"", ""3"");
            fail(""2 shouldn't be equals to three - as Integer"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""ten"", ""2"");
        try {
            ih.setAttribute(p, this, ""ten"", ""3"");
            fail(""/tmp/2 shouldn't be equals to /tmp/3"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""eleven"", ""2"");
        try {
            ih.setAttribute(p, this, ""eleven"", ""on"");
            fail(""on shouldn't be false"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""twelve"", ""2"");
        try {
            ih.setAttribute(p, this, ""twelve"", ""on"");
            fail(""on shouldn't be false"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""thirteen"", ""org.apache.tools.ant.Project"");
        try {
            ih.setAttribute(p, this, ""thirteen"", ""org.apache.tools.ant.ProjectHelper"");
            fail(""org.apache.tools.ant.Project shouldn't be equal to org.apache.tools.ant.ProjectHelper"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        try {
            ih.setAttribute(p, this, ""thirteen"", ""org.apache.tools.ant.Project2"");
            fail(""org.apache.tools.ant.Project2 doesn't exist"");
        } catch (BuildException be) {
            assert(be.getException() instanceof ClassNotFoundException);
        }
        ih.setAttribute(p, this, ""fourteen"", ""2"");
        try {
            ih.setAttribute(p, this, ""fourteen"", ""on"");
            fail(""2 shouldn't be equals to three - as StringBuffer"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""fifteen"", ""abcd"");
        try {
            ih.setAttribute(p, this, ""fifteen"", ""on"");
            fail(""o shouldn't be equal to a"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
        ih.setAttribute(p, this, ""sixteen"", ""abcd"");
        try {
            ih.setAttribute(p, this, ""sixteen"", ""on"");
            fail(""o shouldn't be equal to a"");
        } catch (BuildException be) {
            assert(be.getException() instanceof AssertionFailedError);
        }
    }
    public void testGetAttributes() {
        Hashtable h = new Hashtable();
        h.put(""seven"", java.lang.String.class);
        h.put(""eight"", java.lang.Integer.TYPE);
        h.put(""nine"", java.lang.Integer.class);
        h.put(""ten"", java.io.File.class);
        h.put(""eleven"", java.lang.Boolean.TYPE);
        h.put(""twelve"", java.lang.Boolean.class);
        h.put(""thirteen"", java.lang.Class.class);
        h.put(""fourteen"", java.lang.StringBuffer.class);
        h.put(""fifteen"", java.lang.Character.TYPE);
        h.put(""sixteen"", java.lang.Character.class);
        IntrospectionHelper ih = IntrospectionHelper.getHelper(getClass());
        Enumeration enum = ih.getAttributes();
        while (enum.hasMoreElements()) {
            String name = (String) enum.nextElement();
            Class expect = (Class) h.get(name);
            assertNotNull(""Support for ""+name+"" in IntrospectionHelperTest?"",
                          expect);
            assertEquals(""Type of ""+name, expect, ih.getAttributeType(name));
            h.remove(name);
        }
        assert(""Found all"", h.isEmpty());
    }
    public int setTwo(String s) {
        return 0;
    }
    public void setThree() {}
    public void setFour(String s1, String s2) {}
    public void setFive(String[] s) {}
    public void setSix(Project p) {}
    public void setSeven(String s) {
        assertEquals(""2"", s);
    }
    public void setEight(int i) {
        assertEquals(2, i);
    }
    public void setNine(Integer i) {
        assertEquals(2, i.intValue());
    }
    public void setTen(File f) {
        if (isUnixStyle) { 
            assertEquals(""/tmp/2"", f.getAbsolutePath());
        } else {
            assertEquals("":\\tmp\\2"", f.getAbsolutePath().toLowerCase().substring(1));
        }
    }
    public void setEleven(boolean b) {
        assert(!b);
    }
    public void setTwelve(Boolean b) {
        assert(!b.booleanValue());
    }
    public void setThirteen(Class c) {
        assertEquals(Project.class, c);
    }
    public void setFourteen(StringBuffer sb) {
        assertEquals(""2"", sb.toString());
    }
    public void setFifteen(char c) {
        assertEquals(c, 'a');
    }
    public void setSixteen(Character c) {
        assertEquals(c.charValue(), 'a');
    }
}// IntrospectionHelperTest
"
org.apache.tools.ant.Location,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
/**
 * Stores the file name and line number in a file.
 */
public class Location {
    private String fileName;
    private int lineNumber;
    private int columnNumber;
    public static final Location UNKNOWN_LOCATION = new Location();
    /**
     * Creates an ""unknown"" location.
     */
    private Location() {
        this(null, 0, 0);
    }
    /**
     * Creates a location consisting of a file name but no line number.
     */
    public Location(String fileName) {
        this(fileName, 0, 0);
    }
    /**
     * Creates a location consisting of a file name and line number.
     */
    public Location(String fileName, int lineNumber, int columnNumber) {
        this.fileName = fileName;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
    /**
     * Returns the file name, line number and a trailing space. An error
     * message can be appended easily. For unknown locations, returns
     * an empty string.
     */
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (fileName != null) {
            buf.append(fileName);
            if (lineNumber != 0) {
                buf.append("":"");
                buf.append(lineNumber);
            }
            buf.append("": "");
        }
        return buf.toString();
    }
}
"
org.apache.tools.ant.Main,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
import java.util.*;
/**
 * Command line entry point into Ant. This class is entered via the
 * cannonical `public static void main` entry point and reads the
 * command line arguments. It then assembles and executes an Ant
 * project.
 * <p>
 * If you integrating Ant into some other tool, this is not the class
 * to use as an entry point. Please see the source code of this
 * class to see how it manipulates the Ant project classes.
 *
 * @author duncan@x180.com
 */
public class Main {
    /** The default build file name */
    public static final String DEFAULT_BUILD_FILENAME = ""build.xml"";
    /** Our current message output status. Follows Project.MSG_XXX */
    private int msgOutputLevel = Project.MSG_INFO;
    /** File that we are using for configuration */
    private File buildFile; /** null */
    /** Stream that we are using for logging */
    private PrintStream out = System.out;
    /** Stream that we are using for logging error messages */
    private PrintStream err = System.err;
    /** The build targets */
    private Vector targets = new Vector(5);
    /** Set of properties that can be used by tasks */
    private Properties definedProps = new Properties();
    /** Names of classes to add as listeners to project */
    private Vector listeners = new Vector(5);
    /**
     * The Ant logger class. There may be only one logger. It will have the
     * right to use the 'out' PrintStream. The class must implements the BuildLogger
     * interface
     */
    private String loggerClassname = null;
    /**
     * Indicates whether output to the log is to be unadorned.
     */
    private boolean emacsMode = false;
    /**
     * Indicates if this ant should be run.
     */
    private boolean readyToRun = false;
    /**
     * Indicates we should only parse and display the project help information
     */
    private boolean projectHelp = false;
    /**
     * Prints the message of the Throwable if it's not null.
     */
    private static void printMessage(Throwable t) {
        String message = t.getMessage();
        if (message != null) {
            System.err.println(message);
        }
    }
    /**
     * Command line entry point. This method kicks off the building
     * of a project object and executes a build using either a given
     * target or the default target.
     *
     * @param args Command line args.
     */
    public static void main(String[] args) {
        Main m = null;
        try {
            m = new Main(args);
        } catch(Throwable exc) {
            printMessage(exc);
            System.exit(1);
        }
        try {
            m.runBuild();
            System.exit(0);
        } catch (BuildException be) {
            if (m.err != System.err) {
                printMessage(be);
            }
            System.exit(1);
        } catch(Throwable exc) {
            printMessage(exc);
            System.exit(1);
        }
    }
    protected Main(String[] args) throws BuildException {
        String searchForThis = null;
        // cycle through given args
        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.equals(""-help"")) {
                printUsage();
                return;
            } else if (arg.equals(""-version"")) {
                printVersion();
                return;
            } else if (arg.equals(""-quiet"") || arg.equals(""-q"")) {
                msgOutputLevel = Project.MSG_WARN;
            } else if (arg.equals(""-verbose"") || arg.equals(""-v"")) {
                printVersion();
                msgOutputLevel = Project.MSG_VERBOSE;
            } else if (arg.equals(""-debug"")) {
                printVersion();
                msgOutputLevel = Project.MSG_DEBUG;
            } else if (arg.equals(""-logfile"") || arg.equals(""-l"")) {
                try {
                    File logFile = new File(args[i+1]);
                    i++;
                    out = new PrintStream(new FileOutputStream(logFile));
                    err = out;
                    System.setOut(out);
                    System.setErr(out);
                } catch (IOException ioe) {
                    String msg = ""Cannot write on the specified log file. "" +
                        ""Make sure the path exists and you have write permissions."";
                    System.out.println(msg);
                    return;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a log file when "" +
                        ""using the -log argument"";
                    System.out.println(msg);
                    return;
                }
            } else if (arg.equals(""-buildfile"") || arg.equals(""-file"") || arg.equals(""-f"")) {
                try {
                    buildFile = new File(args[i+1]);
                    i++;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a buildfile when "" +
                        ""using the -buildfile argument"";
                    System.out.println(msg);
                    return;
                }
            } else if (arg.equals(""-listener"")) {
                try {
                    listeners.addElement(args[i+1]);
                    i++;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a classname when "" +
                        ""using the -listener argument"";
                    System.out.println(msg);
                    return;
                }
            } else if (arg.startsWith(""-D"")) {
                /* Interestingly enough, we get to here when a user
                 * uses -Dname=value. However, in some cases, the JDK
                 * goes ahead * and parses this out to args
                 *   {""-Dname"", ""value""}
                 * so instead of parsing on ""="", we just make the ""-D""
                 * characters go away and skip one argument forward.
                 *
                 * I don't know how to predict when the JDK is going
                 * to help or not, so we simply look for the equals sign.
                 */
                String name = arg.substring(2, arg.length());
                String value = null;
                int posEq = name.indexOf(""="");
                if (posEq > 0) {
                    value = name.substring(posEq+1);
                    name = name.substring(0, posEq);
                } else if (i < args.length-1)
                    value = args[++i];
                definedProps.put(name, value);
            } else if (arg.equals(""-logger"")) {
                if (loggerClassname != null) {
                    System.out.println(""Only one logger class may be specified."");
                    return;
                }
                loggerClassname = args[++i];
            } else if (arg.equals(""-emacs"")) {
                emacsMode = true;
            } else if (arg.equals(""-projecthelp"")) {
                // set the flag to display the targets and quit
                projectHelp = true;
            } else if (arg.equals(""-find"")) {
                // eat up next arg if present, default to build.xml
                if (i < args.length-1) {
                    searchForThis = args[++i];
                } else {
                    searchForThis = DEFAULT_BUILD_FILENAME;
                }
            } else if (arg.startsWith(""-"")) {
                // we don't have any more args to recognize!
                String msg = ""Unknown argument: "" + arg;
                System.out.println(msg);
                printUsage();
                return;
            } else {
                // if it's no other arg, it may be the target
                targets.addElement(arg);
            }
        }
        // if buildFile was not specified on the command line,
        if (buildFile == null) {
            // but -find then search for it
            if (searchForThis != null) {
                buildFile = findBuildFile(""."", searchForThis);
            } else {
                buildFile = new File(DEFAULT_BUILD_FILENAME);
            }
        }
        // make sure buildfile exists
        if (!buildFile.exists()) {
            System.out.println(""Buildfile: "" + buildFile + "" does not exist!"");
            throw new BuildException(""Build failed"");
        }
        // make sure it's not a directory (this falls into the ultra
        // paranoid lets check everything catagory
        if (buildFile.isDirectory()) {
            System.out.println(""What? Buildfile: "" + buildFile + "" is a dir!"");
            throw new BuildException(""Build failed"");
        }
        readyToRun = true;
    }
    /**
     * Helper to get the parent file for a given file.
     *
     * <P>Added to simulate File.getParentFile() from JDK 1.2.
     *
     * @param file   File
     * @return       Parent file or null if none
     */
    private File getParentFile(File file) {
        String filename = file.getAbsolutePath();
        file = new File(filename);
        filename = file.getParent();
        if (filename != null && msgOutputLevel >= Project.MSG_VERBOSE) {
            System.out.println(""Searching in ""+filename);
        }
        return (filename == null) ? null : new File(filename);
    }
    /**
     * Search parent directories for the build file.
     *
     * <P>Takes the given target as a suffix to append to each
     *    parent directory in seach of a build file.  Once the
     *    root of the file-system has been reached an exception
     *    is thrown.
     *
     * @param suffix    Suffix filename to look for in parents.
     * @return          A handle to the build file
     *
     * @exception BuildException    Failed to locate a build file
     */
    private File findBuildFile(String start, String suffix) throws BuildException {
        if (msgOutputLevel >= Project.MSG_INFO) {
            System.out.println(""Searching for "" + suffix + "" ..."");
        }
        File parent = new File(new File(start).getAbsolutePath());
        File file = new File(parent, suffix);
        // check if the target file exists in the current directory
        while (!file.exists()) {
            // change to parent directory
            parent = getParentFile(parent);
            // if parent is null, then we are at the root of the fs,
            // complain that we can't find the build file.
            if (parent == null) {
                throw new BuildException(""Could not locate a build file!"");
            }
            // refresh our file handle
            file = new File(parent, suffix);
        }
        return file;
    }
    /**
     * Executes the build.
     */
    private void runBuild() throws BuildException {
        if (!readyToRun) {
            return;
        }
        // track when we started
        if (msgOutputLevel >= Project.MSG_INFO) {
            System.out.println(""Buildfile: "" + buildFile);
        }
        Project project = new Project();
        Throwable error = null;
        try {
            addBuildListeners(project);
            project.fireBuildStarted();
            project.init();
            // set user-define properties
            Enumeration e = definedProps.keys();
            while (e.hasMoreElements()) {
                String arg = (String)e.nextElement();
                String value = (String)definedProps.get(arg);
                project.setUserProperty(arg, value);
            }
            project.setUserProperty( ""ant.file"" , buildFile.getAbsolutePath() );
            // first use the ProjectHelper to create the project object
            // from the given build file.
            try {
                Class.forName(""javax.xml.parsers.SAXParserFactory"");
                ProjectHelper.configureProject(project, buildFile);
            } catch (NoClassDefFoundError ncdfe) {
                throw new BuildException(""No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."", ncdfe);
            } catch (ClassNotFoundException cnfe) {
                throw new BuildException(""No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."", cnfe);
            } catch (NullPointerException npe) {
                throw new BuildException(""No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."", npe);
            }
            // make sure that we have a target to execute
            if (targets.size() == 0) {
                targets.addElement(project.getDefaultTarget());
            }
            if (projectHelp) {
                printTargets(project);
            } else {
                // actually do some work
                project.executeTargets(targets);
            }
        }
        catch(RuntimeException exc) {
            error = exc;
            throw exc;
        }
        catch(Error err) {
            error = err;
            throw err;
        }
        finally {
            project.fireBuildFinished(error);
        }
    }
    protected void addBuildListeners(Project project) {
        // Add the default listener
        project.addBuildListener(createLogger());
        for (int i = 0; i < listeners.size(); i++) {
            String className = (String) listeners.elementAt(i);
            try {
                BuildListener listener =
                    (BuildListener) Class.forName(className).newInstance();
                project.addBuildListener(listener);
            }
            catch(Exception exc) {
                throw new BuildException(""Unable to instantiate listener "" + className, exc);
            }
        }
    }
    /**
     *  Creates the default build logger for sending build events to the ant log.
     */
    private BuildLogger createLogger() {
        BuildLogger logger = null;
        if (loggerClassname != null) {
            try {
                logger = (BuildLogger)(Class.forName(loggerClassname).newInstance());
            }
            catch (ClassCastException e) {
                System.err.println(""The specified logger class "" + loggerClassname +
                                         "" does not implement the BuildLogger interface"");
                throw new RuntimeException();
            }
            catch (Exception e) {
                System.err.println(""Unable to instantiate specified logger class "" +
                                           loggerClassname + "" : "" + e.getClass().getName());
                throw new RuntimeException();
            }
        }
        else {
            logger = new DefaultLogger();
        }
        logger.setMessageOutputLevel(msgOutputLevel);
        logger.setOutputPrintStream(out);
        logger.setErrorPrintStream(err);
        logger.setEmacsMode(emacsMode);
        return logger;
    }
    /**
     * Prints the usage of how to use this class to System.out
     */
    private static void printUsage() {
        String lSep = System.getProperty(""line.separator"");
        StringBuffer msg = new StringBuffer();
        msg.append(""ant [options] [target [target2 [target3] ...]]"" + lSep);
        msg.append(""Options: "" + lSep);
        msg.append(""  -help                  print this message"" + lSep);
        msg.append(""  -projecthelp           print project help information"" + lSep);
        msg.append(""  -version               print the version information and exit"" + lSep);
        msg.append(""  -quiet                 be extra quiet"" + lSep);
        msg.append(""  -verbose               be extra verbose"" + lSep);
        msg.append(""  -debug                 print debugging information"" + lSep);
        msg.append(""  -emacs                 produce logging information without adornments"" + lSep);
        msg.append(""  -logfile <file>        use given file for log"" + lSep);
        msg.append(""  -logger <classname>    the class which is to perform logging"" + lSep);
        msg.append(""  -listener <classname>  add an instance of class as a project listener"" + lSep);
        msg.append(""  -buildfile <file>      use given buildfile"" + lSep);
        msg.append(""  -D<property>=<value>   use value for given property"" + lSep);
        msg.append(""  -find <file>           search for buildfile towards the root of the"" + lSep);
        msg.append(""                         filesystem and use it"" + lSep);
        System.out.println(msg.toString());
    }
    private static void printVersion() {
        try {
            Properties props = new Properties();
            InputStream in =
                Main.class.getResourceAsStream(""/org/apache/tools/ant/version.txt"");
            props.load(in);
            in.close();
            String lSep = System.getProperty(""line.separator"");
            StringBuffer msg = new StringBuffer();
            msg.append(""Ant version "");
            msg.append(props.getProperty(""VERSION""));
            msg.append("" compiled on "");
            msg.append(props.getProperty(""DATE""));
            msg.append(lSep);
            System.out.println(msg.toString());
        } catch (IOException ioe) {
            System.err.println(""Could not load the version information."");
            System.err.println(ioe.getMessage());
        } catch (NullPointerException npe) {
            System.err.println(""Could not load the version information."");
        }
    }
    /**
     * Print out a list of all targets in the current buildfile
     */
    private static void printTargets(Project project) {
        // find the target with the longest name
        int maxLength = 0;
        Enumeration ptargets = project.getTargets().elements();
        String targetName;
        String targetDescription;
        Target currentTarget;
        // split the targets in top-level and sub-targets depending
        // on the presence of a description
        Vector topNames = new Vector();
        Vector topDescriptions = new Vector();
        Vector subNames = new Vector();
        while (ptargets.hasMoreElements()) {
            currentTarget = (Target)ptargets.nextElement();
            targetName = currentTarget.getName();
            targetDescription = currentTarget.getDescription();
            // maintain a sorted list of targets
            if (targetDescription == null) {
                int pos = findTargetPosition(subNames, targetName);
                subNames.insertElementAt(targetName, pos);
            } else {
                int pos = findTargetPosition(topNames, targetName);
                topNames.insertElementAt(targetName, pos);
                topDescriptions.insertElementAt(targetDescription, pos);
                if (targetName.length() > maxLength) {
                    maxLength = targetName.length();
                }
            }
        }
        printTargets(topNames, topDescriptions, ""Main targets:"", maxLength);
        printTargets(subNames, null, ""Subtargets:"", 0);
    }
    /**
     * Search for the insert position to keep names a sorted list of Strings
     */
    private static int findTargetPosition(Vector names, String name) {
        int res = names.size();
        for (int i=0; i<names.size() && res == names.size(); i++) {
            if (name.compareTo((String)names.elementAt(i)) < 0) {
                res = i;
            }
        }
        return res;
    }
    /**
     * Output a formatted list of target names with an optional description
     */
    private static void printTargets(Vector names, Vector descriptions, String heading, int maxlen) {
        // now, start printing the targets and their descriptions
        String lSep = System.getProperty(""line.separator"");
        // got a bit annoyed that I couldn't find a pad function
        String spaces = ""    "";
        while (spaces.length()<maxlen) {
            spaces += spaces;
        }
        StringBuffer msg = new StringBuffer();
        msg.append(heading + lSep + lSep);
        for (int i=0; i<names.size(); i++) {
            msg.append("" "");
            msg.append(names.elementAt(i));
            if (descriptions != null) {
                msg.append(spaces.substring(0, maxlen - ((String)names.elementAt(i)).length() + 2));
                msg.append(descriptions.elementAt(i));
            }
            msg.append(lSep);
        }
        System.out.println(msg.toString());
    }
}
"
org.apache.tools.ant.NoBannerLogger,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
/**
 * Extends DefaultLogger to strip out empty targets.
 *
 * @author <a href=""mailto:donaldp@apache.org"">Peter Donald</a>
 */
public class NoBannerLogger extends DefaultLogger {
    protected String targetName;
    public void targetStarted(BuildEvent event) {
        targetName = event.getTarget().getName();
    }
    public void targetFinished(BuildEvent event) {
        targetName = null;
    }
    public void messageLogged(BuildEvent event) {
        if( event.getPriority() > msgOutputLevel ||
                null == event.getMessage() || 
            """".equals( event.getMessage().trim() ) ) {
            return;
        }
        if( null != targetName ) {
            out.println(lSep + targetName + "":"");
            targetName = null;
        }
        super.messageLogged( event );
    }
}
"
org.apache.tools.ant.PathTokenizer,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.*;
import java.io.*;
/**
 * A Path tokenizer takes a path and returns the components that make up
 * that path.
 *
 * The path can use path separators of either ':' or ';' and file separators
 * of either '/' or '\'
 *
 * @author Conor MacNeill (conor@ieee.org)
 *
 */ 
public class PathTokenizer {
    /**
     * A tokenizer to break the string up based on the ':' or ';' separators.
     */
    private StringTokenizer tokenizer;
    /**
     * A String which stores any path components which have been read ahead.
     */
    private String lookahead = null;
    /**
     * Flag to indicate whether we are running on a platform with a DOS style
     * filesystem
     */
    private boolean dosStyleFilesystem;
    public PathTokenizer(String path) {
       tokenizer = new StringTokenizer(path, "":;"", false);
       dosStyleFilesystem = File.pathSeparatorChar == ';'; 
    }
    public boolean hasMoreTokens() {
        if (lookahead != null) {
            return true;
        }
        return tokenizer.hasMoreTokens();
    }
    public String nextToken() throws NoSuchElementException {
        String token = null;
        if (lookahead != null) {
            token = lookahead;
            lookahead = null;
        }
        else {
            token = tokenizer.nextToken().trim();
        }            
        if (token.length() == 1 && Character.isLetter(token.charAt(0))
                                && dosStyleFilesystem
                                && tokenizer.hasMoreTokens()) {
            // we are on a dos style system so this path could be a drive
            // spec. We look at the next token
            String nextToken = tokenizer.nextToken().trim();
            if (nextToken.startsWith(""\\"") || nextToken.startsWith(""/"")) {
                // we know we are on a DOS style platform and the next path starts with a
                // slash or backslash, so we know this is a drive spec
                token += "":"" + nextToken;
            }
            else {
                // store the token just read for next time
                lookahead = nextToken;
            }
        }
        return token;
    }
}
"
org.apache.tools.ant.Project,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
import java.util.*;
import java.text.*;
/**
 * Central representation of an Ant project. This class defines a
 * Ant project with all of it's targets and tasks. It also provides
 * the mechanism to kick off a build using a particular target name.
 * <p>
 * This class also encapsulates methods which allow Files to be refered
 * to using abstract path names which are translated to native system
 * file paths at runtime as well as defining various project properties.
 *
 * @author duncan@x180.com
 */
public class Project {
    public static final int MSG_ERR = 0;
    public static final int MSG_WARN = 1;
    public static final int MSG_INFO = 2;
    public static final int MSG_VERBOSE = 3;
    public static final int MSG_DEBUG = 4;
    // private set of constants to represent the state
    // of a DFS of the Target dependencies
    private static final String VISITING = ""VISITING"";
    private static final String VISITED = ""VISITED"";
    private static String javaVersion;
    public static final String JAVA_1_0 = ""1.0"";
    public static final String JAVA_1_1 = ""1.1"";
    public static final String JAVA_1_2 = ""1.2"";
    public static final String JAVA_1_3 = ""1.3"";
    public static final String TOKEN_START = ""@"";
    public static final String TOKEN_END = ""@"";
    private String name;
    private Hashtable properties = new Hashtable();
    private Hashtable userProperties = new Hashtable();
    private Hashtable references = new Hashtable();
    private String defaultTarget;
    private Hashtable dataClassDefinitions = new Hashtable();
    private Hashtable taskClassDefinitions = new Hashtable();
    private Hashtable targets = new Hashtable();
    private Hashtable filters = new Hashtable();
    private File baseDir;
    private Vector listeners = new Vector();
    private static java.lang.reflect.Method setLastModified = null;
    private static Object lockReflection = new Object();
    static {
        // Determine the Java version by looking at available classes
        // java.lang.StrictMath was introduced in JDK 1.3
        // java.lang.ThreadLocal was introduced in JDK 1.2
        // java.lang.Void was introduced in JDK 1.1
        // Count up version until a NoClassDefFoundError ends the try
        try {
            javaVersion = JAVA_1_0;
            Class.forName(""java.lang.Void"");
            javaVersion = JAVA_1_1;
            Class.forName(""java.lang.ThreadLocal"");
            javaVersion = JAVA_1_2;
            Class.forName(""java.lang.StrictMath"");
            javaVersion = JAVA_1_3;
        } catch (ClassNotFoundException cnfe) {
            // swallow as we've hit the max class version that
            // we have
        }
    }
    public Project() {
    }
    /**
     * Initialise the project.
     *
     * This involves setting the default task definitions and loading the
     * system properties.
     */
    public void init() throws BuildException {
        setJavaVersionProperty();
        String defs = ""/org/apache/tools/ant/taskdefs/defaults.properties"";
        try {
            Properties props = new Properties();
            InputStream in = this.getClass().getResourceAsStream(defs);
            if (in == null) { 
                throw new BuildException(""Can't load default task list"");
            }
            props.load(in);
            in.close();
            Enumeration enum = props.propertyNames();
            while (enum.hasMoreElements()) {
                String key = (String) enum.nextElement();
                String value = props.getProperty(key);
                try {
                    Class taskClass = Class.forName(value);
                    addTaskDefinition(key, taskClass);
                } catch (NoClassDefFoundError ncdfe) {
                    // ignore...
                } catch (ClassNotFoundException cnfe) {
                    // ignore...
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(""Can't load default task list"");
        }
        String dataDefs = ""/org/apache/tools/ant/types/defaults.properties"";
        try{
            Properties props = new Properties();
            InputStream in = this.getClass().getResourceAsStream(dataDefs);
            if (in == null) { 
                throw new BuildException(""Can't load default datatype list"");
            }
            props.load(in);
            in.close();
            Enumeration enum = props.propertyNames();
            while (enum.hasMoreElements()) {
                String key = (String) enum.nextElement();
                String value = props.getProperty(key);
                try {
                    Class dataClass = Class.forName(value);
                    addDataTypeDefinition(key, dataClass);
                } catch (NoClassDefFoundError ncdfe) {
                    // ignore...
                } catch (ClassNotFoundException cnfe) {
                    // ignore...
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(""Can't load default datatype list"");
        }
        Properties systemP = System.getProperties();
        Enumeration e = systemP.keys();
        while (e.hasMoreElements()) {
            String name = (String) e.nextElement();
            String value = (String) systemP.get(name);
            this.setProperty(name, value);
        }
    }
    public void addBuildListener(BuildListener listener) {
        listeners.addElement(listener);
    }
    public void removeBuildListener(BuildListener listener) {
        listeners.removeElement(listener);
    }
    public Vector getBuildListeners() {
        return listeners;
    }
    public void log(String msg) {
        log(msg, MSG_INFO);
    }
    public void log(String msg, int msgLevel) {
        fireMessageLogged(this, msg, msgLevel);
    }
    public void log(Task task, String msg, int msgLevel) {
        fireMessageLogged(task, msg, msgLevel);
    }
    public void log(Target target, String msg, int msgLevel) {
        fireMessageLogged(target, msg, msgLevel);
    }
    public void setProperty(String name, String value) {
        // command line properties take precedence
        if (null != userProperties.get(name))
            return;
        log(""Setting project property: "" + name + "" -> "" +
            value, MSG_DEBUG);
        properties.put(name, value);
    }
    public void setUserProperty(String name, String value) {
        log(""Setting ro project property: "" + name + "" -> "" +
            value, MSG_DEBUG);
        userProperties.put(name, value);
        properties.put(name, value);
    }
    public String getProperty(String name) {
        if (name == null) return null;
        String property = (String) properties.get(name);
        return property;
    }
    public String getUserProperty(String name) {
        if (name == null) return null;
        String property = (String) userProperties.get(name);
        return property;
    }
    public Hashtable getProperties() {
        return properties;
    }
    public Hashtable getUserProperties() {
        return userProperties;
    }
    public void setDefaultTarget(String defaultTarget) {
        this.defaultTarget = defaultTarget;
    }
    // deprecated, use setDefault
    public String getDefaultTarget() {
        return defaultTarget;
    }
    // match the attribute name
    public void setDefault(String defaultTarget) {
        this.defaultTarget = defaultTarget;
    }
    public void setName(String name) {
        setUserProperty(""ant.project.name"",  name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void addFilter(String token, String value) {
        if (token == null) return;
        log(""Setting token to filter: "" + token + "" -> ""
            + value, MSG_DEBUG);
        this.filters.put(token, value);
    }
    public Hashtable getFilters() {
        return filters;
    }
    // match basedir attribute in xml
    public void setBasedir(String baseD) throws BuildException {
        try {
            setBaseDir(new File(new File(baseD).getCanonicalPath()));
        } catch (IOException ioe) {
            String msg = ""Can't set basedir "" + baseD + "" due to "" +
                ioe.getMessage();
            throw new BuildException(msg);
        }
    }
    public void setBaseDir(File baseDir) {
        this.baseDir = baseDir;
        setProperty( ""basedir"", baseDir.getAbsolutePath());
        String msg = ""Project base dir set to: "" + baseDir;
        log(msg, MSG_VERBOSE);
    }
    public File getBaseDir() {
        if (baseDir == null) {
            try {
                setBasedir(""."");
            } catch (BuildException ex) {
              ex.printStackTrace();
            }
        }
        return baseDir;
    }
    public static String getJavaVersion() {
        return javaVersion;
    }
    public void setJavaVersionProperty() {
        setProperty(""ant.java.version"", javaVersion);
        // sanity check
        if (javaVersion == JAVA_1_0) {
            throw new BuildException(""Ant cannot work on Java 1.0"");
        }
        log(""Detected Java Version: "" + javaVersion, MSG_VERBOSE);
        log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
    }
    public void addTaskDefinition(String taskName, Class taskClass) {
        String msg = "" +User task: "" + taskName + ""     "" + taskClass.getName();
        log(msg, MSG_DEBUG);
        taskClassDefinitions.put(taskName, taskClass);
    }
    public Hashtable getTaskDefinitions() {
        return taskClassDefinitions;
    }
    public void addDataTypeDefinition(String typeName, Class typeClass) {
        String msg = "" +User datatype: "" + typeName + ""     "" + typeClass.getName();
        log(msg, MSG_DEBUG);
        dataClassDefinitions.put(typeName, typeClass);
    }
    public Hashtable getDataTypeDefinitions() {
        return dataClassDefinitions;
    }
    /**
     * This call expects to add a <em>new</em> Target.
     * @param target is the Target to be added to the current
     * Project.
     * @exception BuildException if the Target already exists
     * in the project.
     * @see Project#addOrReplaceTarget to replace existing Targets.
     */
    public void addTarget(Target target) {
        String name = target.getName();
        if (targets.get(name) != null) {
            throw new BuildException(""Duplicate target: `""+name+""'"");
        }
        addOrReplaceTarget(name, target);
    }
    /**
     * This call expects to add a <em>new</em> Target.
     * @param target is the Target to be added to the current
     * Project.
     * @param targetName is the name to use for the Target
     * @exception BuildException if the Target already exists
     * in the project.
     * @see Project#addOrReplaceTarget to replace existing Targets.
     */
     public void addTarget(String targetName, Target target)
         throws BuildException {
         if (targets.get(targetName) != null) {
             throw new BuildException(""Duplicate target: `""+targetName+""'"");
         }
         addOrReplaceTarget(targetName, target);
     }
    /**
     * @param target is the Target to be added or replaced in
     * the current Project.
     */
    public void addOrReplaceTarget(Target target) {
        addOrReplaceTarget(target.getName(), target);
    }
    /**
     * @param target is the Target to be added/replaced in
     * the current Project.
     * @param targetName is the name to use for the Target
     */
    public void addOrReplaceTarget(String targetName, Target target) {
        String msg = "" +Target: "" + targetName;
        log(msg, MSG_DEBUG);
        target.setProject(this);
        targets.put(targetName, target);
    }
    public Hashtable getTargets() {
        return targets;
    }
    public Task createTask(String taskType) throws BuildException {
        Class c = (Class) taskClassDefinitions.get(taskType);
        if (c == null)
            return null;
        try {
            Object o = c.newInstance();
            Task task = null;
            if( o instanceof Task ) {
               task=(Task)o;
            } else {
                // ""Generic"" Bean - use the setter pattern
                // and an Adapter
                TaskAdapter taskA=new TaskAdapter();
                taskA.setProxy( o );
                task=taskA;
            }
            task.setProject(this);
            task.setTaskType(taskType);
            // set default value, can be changed by the user
            task.setTaskName(taskType);
            String msg = ""   +Task: "" + taskType;
            log (msg, MSG_DEBUG);
            return task;
        } catch (Throwable t) {
            String msg = ""Could not create task of type: ""
                 + taskType + "" due to "" + t;
            throw new BuildException(msg, t);
        }
    }
    public Object createDataType(String typeName) throws BuildException {
        Class c = (Class) dataClassDefinitions.get(typeName);
        if (c == null)
            return null;
        try {
            java.lang.reflect.Constructor ctor = null;
            boolean noArg = false;
            // DataType can have a ""no arg"" constructor or take a single 
            // Project argument.
            try {
                ctor = c.getConstructor(new Class[0]);
                noArg = true;
            } catch (NoSuchMethodException nse) {
                ctor = c.getConstructor(new Class[] {getClass()});
                noArg = false;
            }
            Object o = null;
            if (noArg) {
                 o = ctor.newInstance(new Object[0]);
            } else {
                 o = ctor.newInstance(new Object[] {this});
            }
            String msg = ""   +DataType: "" + typeName;
            log (msg, MSG_DEBUG);
            return o;
        } catch (java.lang.reflect.InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            String msg = ""Could not create datatype of type: ""
                 + typeName + "" due to "" + t;
            throw new BuildException(msg, t);
        } catch (Throwable t) {
            String msg = ""Could not create datatype of type: ""
                 + typeName + "" due to "" + t;
            throw new BuildException(msg, t);
        }
    }
    public void executeTargets(Vector targetNames) throws BuildException {
        Throwable error = null;
        for (int i = 0; i < targetNames.size(); i++) {
            executeTarget((String)targetNames.elementAt(i));
        }
    }
    public void executeTarget(String targetName) throws BuildException {
        // sanity check ourselves, if we've been asked to build nothing
        // then we should complain
        if (targetName == null) {
            String msg = ""No target specified"";
            throw new BuildException(msg);
        }
        // Sort the dependency tree, and run everything from the
        // beginning until we hit our targetName.
        // Sorting checks if all the targets (and dependencies)
        // exist, and if there is any cycle in the dependency
        // graph.
        Vector sortedTargets = topoSort(targetName, targets);
        int curidx = 0;
        Target curtarget;
        do {
            curtarget = (Target) sortedTargets.elementAt(curidx++);
            runTarget(curtarget);
        } while (!curtarget.getName().equals(targetName));
    }
    public File resolveFile(String fileName) {
        fileName = fileName.replace('/', File.separatorChar).replace('\\', File.separatorChar);
        // deal with absolute files
        if (fileName.startsWith(File.separator)) {
            try {
                return new File(new File(fileName).getCanonicalPath());
            } catch (IOException e) {
                log(""IOException getting canonical path for "" + fileName 
                    + "": "" + e.getMessage(), MSG_ERR);
                return new File(fileName);
            }
        }
        // Eliminate consecutive slashes after the drive spec
        if (fileName.length() >= 2 &&
            Character.isLetter(fileName.charAt(0)) &&
            fileName.charAt(1) == ':') {
            char[] ca = fileName.replace('/', '\\').toCharArray();
            char c;
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < ca.length; i++) {
                if ((ca[i] != '\\') ||
                    (ca[i] == '\\' &&
                        i > 0 &&
                        ca[i - 1] != '\\')) {
                    if (i == 0 &&
                        Character.isLetter(ca[i]) &&
                        i < ca.length - 1 &&
                        ca[i + 1] == ':') {
                        c = Character.toUpperCase(ca[i]);
                    } else {
                        c = ca[i];
                    }
                    sb.append(c);
                }
            }
            return new File(sb.toString());
        }
        File file = new File(baseDir.getAbsolutePath());
        StringTokenizer tok = new StringTokenizer(fileName, File.separator, false);
        while (tok.hasMoreTokens()) {
            String part = tok.nextToken();
            if (part.equals("".."")) {
                String parentFile = file.getParent();
                if (parentFile == null) {
                    throw new BuildException(""The file or path you specified ("" + fileName + "") is invalid releative to "" + baseDir.getAbsolutePath());
                }
                file = new File(parentFile);
            } else if (part.equals(""."")) {
                // Do nothing here
            } else {
                file = new File(file, part);
            }
        }
        try {
            return new File(file.getCanonicalPath());
        }
        catch (IOException e) {
            log(""IOException getting canonical path for "" + file + "": "" +
                e.getMessage(), MSG_ERR);
            return new File(file.getAbsolutePath());
        }
    }
    /**
     * Translate a path into its native (platform specific) format. 
     * <p>
     * This method uses the PathTokenizer class to separate the input path
     * into its components. This handles DOS style paths in a relatively
     * sensible way. The file separators are then converted to their platform
     * specific versions.
     *
     * @param to_process the path to be converted   
     *
     * @return the native version of to_process or 
     *         an empty string if to_process is null or empty
     */
    static public String translatePath(String to_process) {
        if ( to_process == null || to_process.length() == 0 ) {
            return """";
        }
        StringBuffer path = new StringBuffer(to_process.length() + 50);
        PathTokenizer tokenizer = new PathTokenizer(to_process);
        while (tokenizer.hasMoreTokens()) {
            String pathComponent = tokenizer.nextToken();
            pathComponent = pathComponent.replace('/', File.separatorChar);
            pathComponent = pathComponent.replace('\\', File.separatorChar);
            if (path.length() != 0) {
                path.append(File.pathSeparatorChar);
            }
            path.append(pathComponent);
        }
        return path.toString();
    }
    /**
     * Convienence method to copy a file from a source to a destination.
     * No filtering is performed.
     *
     * @throws IOException
     */
    public void copyFile(String sourceFile, String destFile) throws IOException {
        copyFile(new File(sourceFile), new File(destFile), false);
    }
    /**
     * Convienence method to copy a file from a source to a destination
     * specifying if token filtering must be used.
     *
     * @throws IOException
     */
    public void copyFile(String sourceFile, String destFile, boolean filtering)
        throws IOException
    {
        copyFile(new File(sourceFile), new File(destFile), filtering);
    }
    /**
     * Convienence method to copy a file from a source to a
     * destination specifying if token filtering must be used and if
     * source files may overwrite newer destination files.
     *
     * @throws IOException 
     */
    public void copyFile(String sourceFile, String destFile, boolean filtering,
                         boolean overwrite) throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filtering, 
                 overwrite);
    }
     /**
     * Convienence method to copy a file from a source to a
     * destination specifying if token filtering must be used, if
     * source files may overwrite newer destination files and the
     * last modified time of <code>destFile</code> file should be made equal
     * to the last modified time of <code>sourceFile</code>.
     *
     * @throws IOException 
     */
    public void copyFile(String sourceFile, String destFile, boolean filtering,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filtering, 
                 overwrite, preserveLastModified);
    }
    /**
     * Convienence method to copy a file from a source to a destination.
     * No filtering is performed.
     *
     * @throws IOException
     */
    public void copyFile(File sourceFile, File destFile) throws IOException {
        copyFile(sourceFile, destFile, false);
    }
    /**
     * Convienence method to copy a file from a source to a destination
     * specifying if token filtering must be used.
     *
     * @throws IOException
     */
    public void copyFile(File sourceFile, File destFile, boolean filtering)
        throws IOException {
        copyFile(sourceFile, destFile, filtering, false);
    }
    /**
     * Convienence method to copy a file from a source to a
     * destination specifying if token filtering must be used and if
     * source files may overwrite newer destination files.
     *
     * @throws IOException 
     */
    public void copyFile(File sourceFile, File destFile, boolean filtering,
                         boolean overwrite) throws IOException {
        copyFile(sourceFile, destFile, filtering, overwrite, false);
    }
    /**
     * Convienence method to copy a file from a source to a
     * destination specifying if token filtering must be used, if
     * source files may overwrite newer destination files and the
     * last modified time of <code>destFile</code> file should be made equal
     * to the last modified time of <code>sourceFile</code>.
     *
     * @throws IOException 
     */
    public void copyFile(File sourceFile, File destFile, boolean filtering,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        if (overwrite ||
            destFile.lastModified() < sourceFile.lastModified()) {
            log(""Copy: "" + sourceFile.getAbsolutePath() + "" -> ""
                    + destFile.getAbsolutePath(), MSG_VERBOSE);
            // ensure that parent dir of dest file exists!
            // not using getParentFile method to stay 1.1 compat
            File parent = new File(destFile.getParent());
            if (!parent.exists()) {
                parent.mkdirs();
            }
            if (filtering) {
                BufferedReader in = new BufferedReader(new FileReader(sourceFile));
                BufferedWriter out = new BufferedWriter(new FileWriter(destFile));
                int length;
                String newline = null;
                String line = in.readLine();
                while (line != null) {
                    if (line.length() == 0) {
                        out.newLine();
                    } else {
                        newline = replace(line, filters);
                        out.write(newline);
                        out.newLine();
                    }
                    line = in.readLine();
                }
                out.close();
                in.close();
            } else {
                FileInputStream in = new FileInputStream(sourceFile);
                FileOutputStream out = new FileOutputStream(destFile);
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    out.write(buffer, 0, count);
                    count = in.read(buffer, 0, buffer.length);
                } while (count != -1);
                in.close();
                out.close();
            }
            if (preserveLastModified) {
                setFileLastModified(destFile, sourceFile.lastModified());
            }
        }
    }
    /**
     * Calls File.setLastModified(long time) in a Java 1.1 compatible way.
     */
    void setFileLastModified(File file, long time) throws BuildException {
        if (getJavaVersion() == JAVA_1_1) {
            log(""Cannot change the modification time of "" + file
                + "" in JDK 1.1"", Project.MSG_WARN);
            return;
        }
        if (setLastModified == null) {
            synchronized (lockReflection) {
                if (setLastModified == null) {
                    try {
                        setLastModified = 
                            java.io.File.class.getMethod(""setLastModified"", 
                                                         new Class[] {Long.TYPE});
                    } catch (NoSuchMethodException nse) {
                        throw new BuildException(""File.setlastModified not in JDK > 1.1?"",
                                                 nse);
                    }
                }
            }
        }
        Long[] times = new Long[1];
        if (time < 0) {
            times[0] = new Long(System.currentTimeMillis());
        } else {
            times[0] = new Long(time);
        }
        try {
            log(""Setting modification time for "" + file, MSG_VERBOSE);
            setLastModified.invoke(file, times);
        } catch (java.lang.reflect.InvocationTargetException ite) {
            Throwable nested = ite.getTargetException();
            throw new BuildException(""Exception setting the modification time ""
                                     + ""of "" + file, nested);
        } catch (Throwable other) {
            throw new BuildException(""Exception setting the modification time ""
                                     + ""of "" + file, other);
        }
    }
    /**
     * Does replacement on the given string using the given token table.
     *
     * @returns the string with the token replaced.
     */
    private String replace(String s, Hashtable tokens) {
        int index = s.indexOf(TOKEN_START);
        if (index > -1) {
            try {
                StringBuffer b = new StringBuffer();
                int i = 0;
                String token = null;
                String value = null;
                do {
                    int endIndex = s.indexOf(TOKEN_END, 
                                             index + TOKEN_START.length() + 1);
                    if (endIndex == -1) {
                        break;
                    }
                    token = s.substring(index + TOKEN_START.length(), endIndex);
                    b.append(s.substring(i, index));
                    if (tokens.containsKey(token)) {
                        value = (String) tokens.get(token);
                        log(""Replacing: "" + TOKEN_START + token + TOKEN_END + "" -> "" + value, MSG_VERBOSE);
                        b.append(value);
                        i = index + TOKEN_START.length() + token.length() + TOKEN_END.length();
                    } else {
                        // just append TOKEN_START and search further
                        b.append(TOKEN_START);
                        i = index + TOKEN_START.length();
                    }
                } while ((index = s.indexOf(TOKEN_START, i)) > -1);
                b.append(s.substring(i));
                return b.toString();
            } catch (StringIndexOutOfBoundsException e) {
                return s;
            }
        } else {
            return s;
        }
    }
    /**
     * returns the boolean equivalent of a string, which is considered true
     * if either ""on"", ""true"", or ""yes"" is found, ignoring case.
     */
    public static boolean toBoolean(String s) {
        return (s.equalsIgnoreCase(""on"") ||
                s.equalsIgnoreCase(""true"") ||
                s.equalsIgnoreCase(""yes""));
    }
    // Given a string defining a target name, and a Hashtable
    // containing the ""name to Target"" mapping, pick out the
    // Target and execute it.
    public void runTarget(Target target)
        throws BuildException {
        try {
            fireTargetStarted(target);
            target.execute();
            fireTargetFinished(target, null);
        }
        catch(RuntimeException exc) {
            fireTargetFinished(target, exc);
            throw exc;
        }
    }
    /**
     * Topologically sort a set of Targets.
     * @param root is the (String) name of the root Target. The sort is
     * created in such a way that the sequence of Targets uptil the root
     * target is the minimum possible such sequence.
     * @param targets is a Hashtable representing a ""name to Target"" mapping
     * @return a Vector of Strings with the names of the targets in
     * sorted order.
     * @exception BuildException if there is a cyclic dependency among the
     * Targets, or if a Target does not exist.
     */
    public final Vector topoSort(String root, Hashtable targets)
        throws BuildException {
        Vector ret = new Vector();
        Hashtable state = new Hashtable();
        Stack visiting = new Stack();
        // We first run a DFS based sort using the root as the starting node.
        // This creates the minimum sequence of Targets to the root node.
        // We then do a sort on any remaining unVISITED targets.
        // This is unnecessary for doing our build, but it catches
        // circular dependencies or missing Targets on the entire
        // dependency tree, not just on the Targets that depend on the
        // build Target.
        tsort(root, targets, state, visiting, ret);
        log(""Build sequence for target `""+root+""' is ""+ret, MSG_VERBOSE);
        for (Enumeration en=targets.keys(); en.hasMoreElements();) {
            String curTarget = (String)(en.nextElement());
            String st = (String) state.get(curTarget);
            if (st == null) {
                tsort(curTarget, targets, state, visiting, ret);
            }
            else if (st == VISITING) {
                throw new RuntimeException(""Unexpected node in visiting state: ""+curTarget);
            }
        }
        log(""Complete build sequence is ""+ret, MSG_VERBOSE);
        return ret;
    }
    // one step in a recursive DFS traversal of the Target dependency tree.
    // - The Hashtable ""state"" contains the state (VISITED or VISITING or null)
    // of all the target names.
    // - The Stack ""visiting"" contains a stack of target names that are
    // currently on the DFS stack. (NB: the target names in ""visiting"" are
    // exactly the target names in ""state"" that are in the VISITING state.)
    // 1. Set the current target to the VISITING state, and push it onto
    // the ""visiting"" stack.
    // 2. Throw a BuildException if any child of the current node is
    // in the VISITING state (implies there is a cycle.) It uses the
    // ""visiting"" Stack to construct the cycle.
    // 3. If any children have not been VISITED, tsort() the child.
    // 4. Add the current target to the Vector ""ret"" after the children
    //   have been visited. Move the current target to the VISITED state.
    //   ""ret"" now contains the sorted sequence of Targets upto the current
    //   Target.
    private final void tsort(String root, Hashtable targets,
                             Hashtable state, Stack visiting,
                             Vector ret)
        throws BuildException {
        state.put(root, VISITING);
        visiting.push(root);
        Target target = (Target)(targets.get(root));
        // Make sure we exist
        if (target == null) {
            StringBuffer sb = new StringBuffer(""Target `"");
            sb.append(root);
            sb.append(""' does not exist in this project. "");
            visiting.pop();
            if (!visiting.empty()) {
                String parent = (String)visiting.peek();
                sb.append(""It is used from target `"");
                sb.append(parent);
                sb.append(""'."");
            }
            throw new BuildException(new String(sb));
        }
        for (Enumeration en=target.getDependencies(); en.hasMoreElements();) {
            String cur = (String) en.nextElement();
            String m=(String)state.get(cur);
            if (m == null) {
                // Not been visited
                tsort(cur, targets, state, visiting, ret);
            }
            else if (m == VISITING) {
                // Currently visiting this node, so have a cycle
                throw makeCircularException(cur, visiting);
            }
        }
        String p = (String) visiting.pop();
        if (root != p) {
            throw new RuntimeException(""Unexpected internal error: expected to pop ""+root+"" but got ""+p);
        }
        state.put(root, VISITED);
        ret.addElement(target);
    }
    private static BuildException makeCircularException(String end, Stack stk) {
        StringBuffer sb = new StringBuffer(""Circular dependency: "");
        sb.append(end);
        String c;
        do {
            c = (String)stk.pop();
            sb.append("" <- "");
            sb.append(c);
        } while(!c.equals(end));
        return new BuildException(new String(sb));
    }
    public void addReference(String name, Object value) {
        references.put(name,value);
    }
    public Hashtable getReferences() {
        return references;
    }
    protected void fireBuildStarted() {
        BuildEvent event = new BuildEvent(this);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.buildStarted(event);
        }
    }
    protected void fireBuildFinished(Throwable exception) {
        BuildEvent event = new BuildEvent(this);
        event.setException(exception);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.buildFinished(event);
        }
    }
    protected void fireTargetStarted(Target target) {
        BuildEvent event = new BuildEvent(target);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.targetStarted(event);
        }
    }
    protected void fireTargetFinished(Target target, Throwable exception) {
        BuildEvent event = new BuildEvent(target);
        event.setException(exception);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.targetFinished(event);
        }
    }
    protected void fireTaskStarted(Task task) {
        BuildEvent event = new BuildEvent(task);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.taskStarted(event);
        }
    }
    protected void fireTaskFinished(Task task, Throwable exception) {
        BuildEvent event = new BuildEvent(task);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.taskFinished(event);
        }
    }
    private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
        event.setMessage(message, priority);
        for (int i = 0; i < listeners.size(); i++) {
            BuildListener listener = (BuildListener) listeners.elementAt(i);
            listener.messageLogged(event);
        }
    }
    protected void fireMessageLogged(Project project, String message, int priority) {
        BuildEvent event = new BuildEvent(project);
        fireMessageLoggedEvent(event, message, priority);
    }
    protected void fireMessageLogged(Target target, String message, int priority) {
        BuildEvent event = new BuildEvent(target);
        fireMessageLoggedEvent(event, message, priority);
    }
    protected void fireMessageLogged(Task task, String message, int priority) {
        BuildEvent event = new BuildEvent(task);
        fireMessageLoggedEvent(event, message, priority);
    }
}
"
org.apache.tools.ant.ProjectHelper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
import java.util.*;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.apache.tools.ant.taskdefs.*;
import javax.xml.parsers.*;
/**
 * Configures a Project (complete with Targets and Tasks) based on
 * a XML build file.
 *
 * @author duncan@x180.com
 */
public class ProjectHelper {
    private static SAXParserFactory parserFactory = null;
    private org.xml.sax.Parser parser;
    private Project project;
    private File buildFile;
    private File buildFileParent;
    private Locator locator;
    /**
     * Configures the Project with the contents of the specified XML file.
     */
    public static void configureProject(Project project, File buildFile) throws BuildException {
        new ProjectHelper(project, buildFile).parse();
    }
    /**
     * Constructs a new Ant parser for the specified XML file.
     */
    private ProjectHelper(Project project, File buildFile) {
        this.project = project;
        this.buildFile = new File(buildFile.getAbsolutePath());
        buildFileParent = new File(this.buildFile.getParent());
    }
    /**
     * Parses the project file.
     */
    private void parse() throws BuildException {
        FileInputStream inputStream = null;
        InputSource inputSource = null;
        try {
            SAXParser saxParser = getParserFactory().newSAXParser();
            parser = saxParser.getParser();
            String uri = ""file:"" + buildFile.getAbsolutePath().replace('\\', '/');
            for (int index = uri.indexOf('#'); index != -1; index = uri.indexOf('#')) {
                uri = uri.substring(0, index) + ""%23"" + uri.substring(index+1);
            }
            inputStream = new FileInputStream(buildFile);
            inputSource = new InputSource(inputStream);
            inputSource.setSystemId(uri);
            project.log(""parsing buildfile "" + buildFile + "" with URI = "" + uri, Project.MSG_VERBOSE);
            saxParser.parse(inputSource, new RootHandler());
        }
        catch(ParserConfigurationException exc) {
            throw new BuildException(""Parser has not been configured correctly"", exc);
        }
        catch(SAXParseException exc) {
            Location location =
                new Location(buildFile.toString(), exc.getLineNumber(), exc.getColumnNumber());
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                BuildException be = (BuildException) t;
                if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                    be.setLocation(location);
                }
                throw be;
            }
            throw new BuildException(exc.getMessage(), t, location);
        }
        catch(SAXException exc) {
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(exc.getMessage(), t);
        }
        catch(FileNotFoundException exc) {
            throw new BuildException(exc);
        }
        catch(IOException exc) {
            throw new BuildException(""Error reading project file"", exc);
        }
        finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                }
                catch (IOException ioe) {
                    // ignore this
                }
            }
        }
    }
    /**
     * The common superclass for all sax event handlers in Ant. Basically
     * throws an exception in each method, so subclasses should override
     * what they can handle.
     *
     * Each type of xml element (task, target, etc) in ant will
     * have its own subclass of AbstractHandler.
     *
     * In the constructor, this class    takes over the handling of sax
     * events from the parent handler, and returns
     * control back to the parent in the endElement method.
     */
    private class AbstractHandler extends HandlerBase {
        protected DocumentHandler parentHandler;
        public AbstractHandler(DocumentHandler parentHandler) {
            this.parentHandler = parentHandler;
            // Start handling SAX events
            parser.setDocumentHandler(this);
        }
        public void startElement(String tag, AttributeList attrs) throws SAXParseException {
            throw new SAXParseException(""Unexpected element \"""" + tag + ""\"""", locator);
        }
        public void characters(char[] buf, int start, int end) throws SAXParseException {
            String s = new String(buf, start, end).trim();
            if (s.length() > 0) {
                throw new SAXParseException(""Unexpected text \"""" + s + ""\"""", locator);
            }
        }
        /**
         * Called when this element and all elements nested into it have been
         * handeled.
         */
        protected void finished() {}
        public void endElement(String name) throws SAXException {
            finished();
            // Let parent resume handling SAX events
            parser.setDocumentHandler(parentHandler);
        }
    }
    /**
     * Handler for the root element. It's only child must be the ""project"" element.
     */
    private class RootHandler extends HandlerBase {
        /**
         * resolve file: URIs as relative to the build file.
         */
        public InputSource resolveEntity(String publicId,
                                         String systemId) {
            project.log(""resolving systemId: "" + systemId, Project.MSG_VERBOSE);
            if (systemId.startsWith(""file:"")) {
                String path = systemId.substring(5);
                int index = path.indexOf(""file:"");
                // we only have to handle these for backward compatibility
                // since they are in the FAQ.
                while (index != -1) {
                    path = path.substring(0, index) + path.substring(index + 5);
                    index = path.indexOf(""file:"");
                }
                String entitySystemId = path;
                index = path.indexOf(""%23"");
                // convert these to #
                while (index != -1) {
                    path = path.substring(0, index) + ""#"" + path.substring(index + 3);
                    index = path.indexOf(""%23"");
                }
                File file = new File(path);
                if (!file.isAbsolute()) {
                    file = new File(buildFileParent, path);
                }
                try {
                    InputSource inputSource = new InputSource(new FileInputStream(file));
                    inputSource.setSystemId(""file:"" + entitySystemId);
                    return inputSource;
                } catch (FileNotFoundException fne) {
                    project.log(file.getAbsolutePath()+"" could not be found"", 
                                Project.MSG_WARN);
                }
            }
            // use default if not file or file not found
            return null;
        }
        public void startElement(String tag, AttributeList attrs) throws SAXParseException {
            if (tag.equals(""project"")) {
                new ProjectHandler(this).init(tag, attrs);
            } else {
                throw new SAXParseException(""Config file is not of expected XML type"", locator);
            }
        }
        public void setDocumentLocator(Locator locator) {
            ProjectHelper.this.locator = locator;
        }
    }
    /**
     * Handler for the top level ""project"" element.
     */
    private class ProjectHandler extends AbstractHandler {
        public ProjectHandler(DocumentHandler parentHandler) {
            super(parentHandler);
        }
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            String def = null;
            String name = null;
            String id = null;
            String baseDir = null;
            for (int i = 0; i < attrs.getLength(); i++) {
                String key = attrs.getName(i);
                String value = attrs.getValue(i);
                if (key.equals(""default"")) {
                    def = value;
                } else if (key.equals(""name"")) {
                    name = value;
                } else if (key.equals(""id"")) {
                    id = value;
                } else if (key.equals(""basedir"")) {
                    baseDir = value;
                } else {
                    throw new SAXParseException(""Unexpected attribute \"""" + attrs.getName(i) + ""\"""", locator);
                }
            }
            if (def == null) {
                throw new SAXParseException(""The default attribute of project is required"", 
                                            locator);
            }
            project.setDefaultTarget(def);
            if (name != null) {
                project.setName(name);
                project.addReference(name, project);
            }
            if (id != null) project.addReference(id, project);
            if (project.getProperty(""basedir"") != null) {
                project.setBasedir(project.getProperty(""basedir""));
            } else {
                if (baseDir == null) {
                    project.setBasedir(buildFileParent.getAbsolutePath());
                } else {
                    // check whether the user has specified an absolute path
                    if ((new File(baseDir)).isAbsolute()) {
                        project.setBasedir(baseDir);
                    } else {
                        project.setBasedir((new File(buildFileParent, baseDir)).getAbsolutePath());
                    }
                }
            }
        }
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            if (name.equals(""taskdef"")) {
                handleTaskdef(name, attrs);
            } else if (name.equals(""property"")) {
                handleProperty(name, attrs);
            } else if (name.equals(""target"")) {
                handleTarget(name, attrs);
            } else if (project.getDataTypeDefinitions().get(name) != null) {
                handleDataType(name, attrs);
            } else {
                throw new SAXParseException(""Unexpected element \"""" + name + ""\"""", locator);
            }
        }
        private void handleTaskdef(String name, AttributeList attrs) throws SAXParseException {
            (new TaskHandler(this, null)).init(name, attrs);
        }
        private void handleProperty(String name, AttributeList attrs) throws SAXParseException {
            (new TaskHandler(this, null)).init(name, attrs);
        }
        private void handleTarget(String tag, AttributeList attrs) throws SAXParseException {
            new TargetHandler(this).init(tag, attrs);
        }
        private void handleDataType(String name, AttributeList attrs) throws SAXParseException {
            new DataTypeHandler(this).init(name, attrs);
        }
    }
    /**
     * Handler for ""target"" elements.
     */
    private class TargetHandler extends AbstractHandler {
        private Target target;
        public TargetHandler(DocumentHandler parentHandler) {
            super(parentHandler);
        }
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            String name = null;
            String depends = """";
            String ifCond = null;
            String unlessCond = null;
            String id = null;
            String description = null;
            for (int i = 0; i < attrs.getLength(); i++) {
                String key = attrs.getName(i);
                String value = attrs.getValue(i);
                if (key.equals(""name"")) {
                    name = value;
                } else if (key.equals(""depends"")) {
                    depends = value;
                } else if (key.equals(""if"")) {
                    ifCond = value;
                } else if (key.equals(""unless"")) {
                    unlessCond = value;
                } else if (key.equals(""id"")) {
                    id = value;
                } else if (key.equals(""description"")) {
                    description = value;
                } else {
                    throw new SAXParseException(""Unexpected attribute \"""" + key + ""\"""", locator);
                }
            }
            if (name == null) {
                throw new SAXParseException(""target element appears without a name attribute"", locator);
            }
            target = new Target();
            target.setName(name);
            target.setIf(ifCond);
            target.setUnless(unlessCond);
            target.setDescription(description);
            project.addTarget(name, target);
            if (id != null && !id.equals(""""))
                project.addReference(id, target);
            // take care of dependencies
            if (depends.length() > 0) {
                StringTokenizer tok =
                    new StringTokenizer(depends, "","", false);
                while (tok.hasMoreTokens()) {
                    target.addDependency(tok.nextToken().trim());
                }
            }
        }
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            new TaskHandler(this, target).init(name, attrs);
        }
    }
    /**
     * Handler for all task elements.
     */
    private class TaskHandler extends AbstractHandler {
        private Target target;
        private Task task;
        private RuntimeConfigurable wrapper = null;
        public TaskHandler(DocumentHandler parentHandler, Target target) {
            super(parentHandler);
            this.target = target;
        }
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            try {
                task = project.createTask(tag);
            } catch (BuildException e) {
                // swallow here, will be thrown again in 
                // UnknownElement.maybeConfigure if the problem persists.
            }
            if (task == null) {
                task = new UnknownElement(tag);
                task.setProject(project);
            }
            task.setLocation(new Location(buildFile.toString(), locator.getLineNumber(), locator.getColumnNumber()));
            configureId(task, attrs);
            // Top level tasks don't have associated targets
            if (target != null) {
                task.setOwningTarget(target);
                target.addTask(task);
                task.init();
                wrapper = task.getRuntimeConfigurableWrapper();
                wrapper.setAttributes(attrs);
            } else {
                task.init();
                configure(task, attrs, project);
            }
        }
        protected void finished() {
            if (task != null && target == null) {
                task.execute();
            }
        }
        public void characters(char[] buf, int start, int end) throws SAXParseException {
            if (wrapper == null) {
                try {
                    addText(task, buf, start, end);
                } catch (BuildException exc) {
                    throw new SAXParseException(exc.getMessage(), locator, exc);
                }
            } else {
                wrapper.addText(buf, start, end);
            }
        }
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            new NestedElementHandler(this, task, wrapper).init(name, attrs);
        }
    }
    /**
     * Handler for all nested properties.
     */
    private class NestedElementHandler extends AbstractHandler {
        private Object target;
        private Object child;
        private RuntimeConfigurable parentWrapper;
        private RuntimeConfigurable childWrapper = null;
        public NestedElementHandler(DocumentHandler parentHandler, 
                                    Object target,
                                    RuntimeConfigurable parentWrapper) {
            super(parentHandler);
            if (target instanceof TaskAdapter) {
                this.target = ((TaskAdapter) target).getProxy();
            } else {
                this.target = target;
            }
            this.parentWrapper = parentWrapper;
        }
        public void init(String propType, AttributeList attrs) throws SAXParseException {
            Class targetClass = target.getClass();
            IntrospectionHelper ih = 
                IntrospectionHelper.getHelper(targetClass);
            try {
                if (target instanceof UnknownElement) {
                    child = new UnknownElement(propType.toLowerCase());
                    ((UnknownElement) target).addChild((UnknownElement) child);
                } else {
                    child = ih.createElement(target, propType.toLowerCase());
                }
                configureId(child, attrs);
                if (parentWrapper != null) {
                    childWrapper = new RuntimeConfigurable(child);
                    childWrapper.setAttributes(attrs);
                    parentWrapper.addChild(childWrapper);
                } else {
                    configure(child, attrs, project);
                }
            } catch (BuildException exc) {
                throw new SAXParseException(exc.getMessage(), locator, exc);
            }
        }
        public void characters(char[] buf, int start, int end) throws SAXParseException {
            if (parentWrapper == null) {
                try {
                    addText(child, buf, start, end);
                } catch (BuildException exc) {
                    throw new SAXParseException(exc.getMessage(), locator, exc);
                }
            } else {
                childWrapper.addText(buf, start, end);
            }
        }
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            new NestedElementHandler(this, child, childWrapper).init(name, attrs);
        }
    }
    /**
     * Handler for all data types at global level.
     */
    private class DataTypeHandler extends AbstractHandler {
        private Object element;
        public DataTypeHandler(DocumentHandler parentHandler) {
            super(parentHandler);
        }
        public void init(String propType, AttributeList attrs) throws SAXParseException {
            try {
                element = project.createDataType(propType);
                if (element == null) {
                    throw new BuildException(""Unknown data type ""+propType);
                }
                configureId(element, attrs);
                configure(element, attrs, project);
            } catch (BuildException exc) {
                throw new SAXParseException(exc.getMessage(), locator, exc);
            }
        }
        public void characters(char[] buf, int start, int end) throws SAXParseException {
            try {
                addText(element, buf, start, end);
            } catch (BuildException exc) {
                throw new SAXParseException(exc.getMessage(), locator, exc);
            }
        }
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            new NestedElementHandler(this, element, null).init(name, attrs);
        }
    }
    public static void configure(Object target, AttributeList attrs, 
                                 Project project) throws BuildException {
        if( target instanceof TaskAdapter )
            target=((TaskAdapter)target).getProxy();
        IntrospectionHelper ih = 
            IntrospectionHelper.getHelper(target.getClass());
        for (int i = 0; i < attrs.getLength(); i++) {
            // reflect these into the target
            String value=replaceProperties(project, attrs.getValue(i), 
                                           project.getProperties() );
            try {
                ih.setAttribute(project, target, 
                                attrs.getName(i).toLowerCase(), value);
            } catch (BuildException be) {
                // id attribute must be set externally
                if (!attrs.getName(i).equals(""id"")) {
                    throw be;
                }
            }
        }
    }
    /**
     * Adds the content of #PCDATA sections to an element.
     */
    public static void addText(Object target, char[] buf, int start, int end)
        throws BuildException {
        addText(target, new String(buf, start, end));
    }
    /**
     * Adds the content of #PCDATA sections to an element.
     */
    public static void addText(Object target, String text)
        throws BuildException {
        if (text == null || text.trim().length() == 0) {
            return;
        }
        if(target instanceof TaskAdapter)
            target = ((TaskAdapter) target).getProxy();
        IntrospectionHelper.getHelper(target.getClass()).addText(target, text);
    }
    /** Replace ${NAME} with the property value
     */
    public static String replaceProperties(Project project, String value, Hashtable keys )
        throws BuildException
    {
        // XXX use Map instead of proj, it's too heavy
        // XXX need to replace this code with something better.
        StringBuffer sb=new StringBuffer();
        int i=0;
        int prev=0;
        // assert value!=nil
        int pos;
        while( (pos=value.indexOf( ""$"", prev )) >= 0 ) {
            if(pos>0) {
                sb.append( value.substring( prev, pos ) );
            }
            if( pos == (value.length() - 1)) {
                sb.append('$');
                prev = pos + 1;
            }
            else if (value.charAt( pos + 1 ) != '{' ) {
                sb.append( value.charAt( pos + 1 ) );
                prev=pos+2; // XXX
            } else {
                int endName=value.indexOf( '}', pos );
                if( endName < 0 ) {
                    throw new BuildException(""Syntax error in prop: "" +
                                             value );
                }
                String n=value.substring( pos+2, endName );
                if (!keys.containsKey(n)) {
                    project.log(""Property ${"" + n + ""} has not been set"", Project.MSG_VERBOSE);
                }
                String v = (keys.containsKey(n)) ? (String) keys.get(n) : ""${""+n+""}""; 
                //System.out.println(""N: "" + n + "" "" + "" V:"" + v);
                sb.append( v );
                prev=endName+1;
            }
        }
        if( prev < value.length() ) sb.append( value.substring( prev ) );
        //      System.out.println(""After replace: "" + sb.toString());
        // System.out.println(""Before replace: "" + value);
        return sb.toString();
    }
    private static SAXParserFactory getParserFactory() {
        if (parserFactory == null) {
            parserFactory = SAXParserFactory.newInstance();
        }
        return parserFactory;
    }
    /**
     * Scan AttributeList for the id attribute and maybe add a
     * reference to project.  
     *
     * <p>Moved out of {@link #configure configure} to make it happen
     * at parser time.</p> 
     */
    private void configureId(Object target, AttributeList attr) {
        String id = attr.getValue(""id"");
        if (id != null) {
            project.addReference(id, target);
        }
    }
}
"
org.apache.tools.ant.ProjectTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import org.apache.tools.ant.types.*;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
/**
 * Very limited test class for Project. Waiting to be extended.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class ProjectTest extends TestCase {
    private Project p;
    public ProjectTest(String name) {
        super(name);
    }
    public void setUp() {
        p = new Project();
        p.init();
    }
    public void testDataTypes() throws BuildException {
        assertNull(""dummy is not a known data type"", 
                   p.createDataType(""dummy""));
        Object o = p.createDataType(""fileset"");
        assertNotNull(""fileset is a known type"", o);
        assert(""fileset creates FileSet"", o instanceof FileSet);
        assert(""PatternSet"", 
               p.createDataType(""patternset"") instanceof PatternSet);
        assert(""Path"", p.createDataType(""path"") instanceof Path);
    }
}
"
org.apache.tools.ant.RuntimeConfigurable,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.Enumeration;
import java.util.Vector;
import org.xml.sax.AttributeList;
import org.xml.sax.helpers.AttributeListImpl;
/**
 * Wrapper class that holds the attributes of a Task (or elements
 * nested below that level) and takes care of configuring that element
 * at runtime.
 *
 * @author <a href=""stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class RuntimeConfigurable {
    private Vector children = new Vector();
    private Object wrappedObject = null;
    private AttributeList attributes;
    private StringBuffer characters = new StringBuffer();
    /**
     * @param proxy The element to wrap.
     */
    public RuntimeConfigurable(Object proxy) {
        wrappedObject = proxy;
    }
    void setProxy(Object proxy) {
        wrappedObject = proxy;
    }
    /**
     * Set's the attributes for the wrapped element.
     */
    public void setAttributes(AttributeList attributes) {
        this.attributes = new AttributeListImpl(attributes);
    }
    /**
     * Returns the AttributeList of the wrapped element.
     */
    public AttributeList getAttributes() {
        return attributes;
    }
    /**
     * Adds child elements to the wrapped element.
     */
    public void addChild(RuntimeConfigurable child) {
        children.addElement(child);
    }
    /**
     * Returns the child with index <code>index</code>.
     */
    RuntimeConfigurable getChild(int index) {
        return (RuntimeConfigurable) children.elementAt(index);
    }
    /**
     * Add characters from #PCDATA areas to the wrapped element.
     */
    public void addText(String data) {
        characters.append(data);
    }
    /**
     * Add characters from #PCDATA areas to the wrapped element.
     */
    public void addText(char[] buf, int start, int end) {
        addText(new String(buf, start, end));
    }
    /**
     * Configure the wrapped element and all children.
     */
    public void maybeConfigure(Project p) throws BuildException {
        if (attributes != null) {
            ProjectHelper.configure(wrappedObject, attributes, p);
            attributes = null;
        }
        if (characters.length() != 0) {
            ProjectHelper.addText(wrappedObject, characters.toString());
            characters.setLength(0);
        }
        Enumeration enum = children.elements();
        while (enum.hasMoreElements()) {
            RuntimeConfigurable child = (RuntimeConfigurable) enum.nextElement();
            child.maybeConfigure(p);
        }
    }
}
"
org.apache.tools.ant.Target,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.*;
/**
 * This class implements a target object with required parameters.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 */
public class Target {
    private String name;
    private String ifCondition = """";
    private String unlessCondition = """";
    private Vector dependencies = new Vector(2);
    private Vector tasks = new Vector(5);
    private Project project;
    private String description = null;
    public void setProject(Project project) {
        this.project = project;
    }
    public Project getProject() {
        return project;
    }
    public void setDepends(String depS) {
        if (depS.length() > 0) {
            StringTokenizer tok =
                new StringTokenizer(depS, "","", false);
            while (tok.hasMoreTokens()) {
                addDependency(tok.nextToken().trim());
            }
        }
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void addTask(Task task) {
        tasks.addElement(task);
    }
	/** 
	 * Get the current set of tasks to be executed by this target.
	 * 
     * @return The current set of tasks.
	 */
    public Task[] getTasks() {
        Task[] retval = new Task[tasks.size()];
        tasks.copyInto(retval);
        return retval;
    }
    public void addDependency(String dependency) {
        dependencies.addElement(dependency);
    }
    public Enumeration getDependencies() {
        return dependencies.elements();
    }
    public void setIf(String property) {
        this.ifCondition = (property == null) ? """" : property;
    }
    public void setUnless(String property) {
        this.unlessCondition = (property == null) ? """" : property;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public String getDescription() {
        return description;
    }
    public String toString() {
        return name;
    }
    public void execute() throws BuildException {
        if (testIfCondition() && testUnlessCondition()) {
            Enumeration enum = tasks.elements();
            while (enum.hasMoreElements()) {
                Task task = (Task) enum.nextElement();
                try {
                    project.fireTaskStarted(task);
                    task.maybeConfigure();
                    task.execute();
                    project.fireTaskFinished(task, null);
                }
                catch(RuntimeException exc) {
                    if (exc instanceof BuildException) {
                        BuildException be = (BuildException) exc;
                        if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                            be.setLocation(task.getLocation());
                        }
                    }
                    project.fireTaskFinished(task, exc);
                    throw exc;
                }
            }
        } else if (!testIfCondition()) {
            project.log(this, ""Skipped because property '"" + this.ifCondition + ""' not set."", 
                        Project.MSG_VERBOSE);
        } else {
            project.log(this, ""Skipped because property '"" + this.unlessCondition + ""' set."",
                        Project.MSG_VERBOSE);
        }
    }
    void replaceTask(UnknownElement el, Task t) {
        int index = -1;
        while ((index = tasks.indexOf(el)) >= 0) {
            tasks.setElementAt(t, index);
        }
    }
    private boolean testIfCondition() {
        return """".equals(ifCondition) 
            || project.getProperty(ifCondition) != null;
    }
    private boolean testUnlessCondition() {
        return """".equals(unlessCondition) 
            || project.getProperty(unlessCondition) == null;
    }
}
"
org.apache.tools.ant.Task,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
/**
 * Base class for all tasks.
 *
 * <p>Use {@link Project#createTask Project.createTask} to create a new Task.
 */
public abstract class Task {
    protected Project project = null;
    protected Target target = null;
    protected String description=null;
    protected Location location = Location.UNKNOWN_LOCATION;
    protected String taskName = null;
    protected String taskType = null;
    protected RuntimeConfigurable wrapper;
    /**
     * Sets the project object of this task. This method is used by
     * project when a task is added to it so that the task has
     * access to the functions of the project. It should not be used
     * for any other purpose.
     *
     * @param project Project in whose scope this task belongs.
     */
    void setProject(Project project) {
        this.project = project;
    }
    /**
     * Get the Project to which this task belongs
     *
     * @return the task's project.
     */
    public Project getProject() {
        return project;
    }
    /**
     * Sets the target object of this task.
     *
     * @param target Target in whose scope this task belongs.
     */
    public void setOwningTarget(Target target) {
        this.target = target;
    }
    /**
     * Get the Target to which this task belongs
     *
     * @return the task's target.
     */
    public Target getOwningTarget() {
        return target;
    }
    /**
     * Set the name to use in logging messages.
     *
     * @param name the name to use in logging messages.
     */
    public void setTaskName(String name) {
        this.taskName = name;
    }
    /**
     * Get the name to use in logging messages.
     *
     * @return the name to use in logging messages.
     */
    public String getTaskName() {
        return taskName;
    }
    /**
     * Set the name with which the task has been invoked.
     *
     * @param type the name the task has been invoked as.
     */
    void setTaskType(String type) {
        this.taskType = type;
    }
    /**
     * Log a message with the default (INFO) priority.
     *
     * @param the message to be logged.
     */
    public void log(String msg) {
        log(msg, Project.MSG_INFO);
    }
    /**
     * Log a mesage with the give priority.
     *
     * @param the message to be logged.
     * @param msgLevel the message priority at which this message is to be logged.
     */
    public void log(String msg, int msgLevel) {
        project.log(this, msg, msgLevel);
    }
    /** Sets a description of the current action. It will be usefull in commenting
     *  what we are doing.
     */
    public void setDescription( String desc ) {
        description=desc;
    }
    public String getDescription() {
        return description;
    }
    /**
     * Called by the project to let the task initialize properly. 
     *
     * @throws BuildException if someting goes wrong with the build
     */
    public void init() throws BuildException {}
    /**
     * Called by the project to let the task do it's work. This method may be 
     * called more than once, if the task is invoked more than once. For example, 
     * if target1 and target2 both depend on target3, then running 
     * ""ant target1 target2"" will run all tasks in target3 twice.
     *
     * @throws BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {}
    /**
     * Returns the file location where this task was defined.
     */
    public Location getLocation() {
        return location;
    }
    /**
     * Sets the file location where this task was defined.
     */
    public void setLocation(Location location) {
        this.location = location;
    }
    /**
     * Returns the wrapper class for runtime configuration.
     */
    public RuntimeConfigurable getRuntimeConfigurableWrapper() {
        if (wrapper == null) {
            wrapper = new RuntimeConfigurable(this);
        }
        return wrapper;
    }
    protected void setRuntimeConfigurableWrapper(RuntimeConfigurable wrapper) {
        this.wrapper = wrapper;
    }
    /**
     * Configure this task - if it hasn't been done already.
     */
    public void maybeConfigure() throws BuildException {
        if (wrapper != null) {
            wrapper.maybeConfigure(project);
        }
    }
}
"
org.apache.tools.ant.TaskAdapter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.lang.reflect.*;
import java.util.*;
/**
 *  Use introspection to ""adapt"" an arbitrary Bean ( not extending Task, but with similar
 *  patterns).
 *
 * @author costin@dnt.ro
 */
public class TaskAdapter extends Task {
    Object proxy;
    /**
     * Do the execution.
     */
    public void execute() throws BuildException {
        Method executeM=null;
        try {
            Class c=proxy.getClass();
            executeM=c.getMethod( ""execute"", new Class[0] );
            if( executeM == null ) {
                log(""No execute in "" + proxy.getClass(), Project.MSG_ERR);
                throw new BuildException(""No execute in "" + proxy.getClass());
            }
            executeM.invoke(proxy, null);
            return; 
        } catch( Exception ex ) {
            log(""Error in "" + proxy.getClass(), Project.MSG_ERR);
            throw new BuildException( ex );
        }
    }
    /**
     * Set the target object class
     */
    public void setProxy(Object o) {
        this.proxy = o;
    }
    public Object getProxy() {
        return this.proxy ;
    }
}
"
org.apache.tools.ant.UnknownElement,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.util.Vector;
/**
 * Wrapper class that holds all information necessary to create a task
 * that did not exist when Ant started.
 *
 * @author <a href=""stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class UnknownElement extends Task {
    private String elementName;
    private Task realTask;
    private Vector children = new Vector();
    public UnknownElement (String elementName) {
        this.elementName = elementName;
    }
    /**
     * return the corresponding XML tag.
     */
    public String getTag() {
        return elementName;
    }
    public void maybeConfigure() throws BuildException {
        realTask = project.createTask(elementName);
        if (realTask == null) {
            log(""Could not create task of type: "" + elementName + "" Common solutions"" +
                "" are adding the task to defaults.properties and executing bin/bootstrap"",
                Project.MSG_DEBUG);
            throw new BuildException(""Could not create task of type: "" + elementName +
                                     "". Common solutions are to use taskdef to declare"" +
                                     "" your task, or, if this is an optional task,"" +
                                     "" to put the optional.jar in the lib directory of"" +
                                     "" your ant installation (ANT_HOME)."", location);
        }
        realTask.setLocation(location);
        String id = wrapper.getAttributes().getValue(""id"");
        if (id != null) {
            project.addReference(id, realTask);
        }
        realTask.init();
        // UnknownElement always has an associated target
        realTask.setOwningTarget(target);
        wrapper.setProxy(realTask);
        realTask.setRuntimeConfigurableWrapper(wrapper);
        handleChildren(realTask, wrapper);
        realTask.maybeConfigure();
        target.replaceTask(this, realTask);
    }
    /**
     * Called when the real task has been configured for the first time.
     */
    public void execute() {
        if (realTask == null) {
            // plain impossible to get here, maybeConfigure should 
            // have thrown an exception.
            throw new BuildException(""Could not create task of type: ""
                                     + elementName, location);
        }
        realTask.execute();
    }
    public void addChild(UnknownElement child) {
        children.addElement(child);
    }
    protected void handleChildren(Object parent, 
                                  RuntimeConfigurable parentWrapper) 
        throws BuildException {
        if (parent instanceof TaskAdapter) {
            parent = ((TaskAdapter) parent).getProxy();
        }
        Class parentClass = parent.getClass();
        IntrospectionHelper ih = IntrospectionHelper.getHelper(parentClass);
        for (int i=0; i<children.size(); i++) {
            UnknownElement child = (UnknownElement) children.elementAt(i);
            Object realChild = ih.createElement(parent, child.getTag());
            RuntimeConfigurable childWrapper = parentWrapper.getChild(i);
            childWrapper.setProxy(realChild);
            child.handleChildren(realChild, childWrapper);
        }
    }
}// UnknownElement
"
org.apache.tools.ant.XmlLogger,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant;
import java.io.*;
import java.util.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.apache.tools.ant.util.DOMElementWriter;
/**
 *  Generates a ""log.xml"" file in the current directory with
 *  an XML description of what happened during a build.
 *
 *  @see Project#addBuildListener(BuildListener)
 */
public class XmlLogger implements BuildListener {
    private static final DocumentBuilder builder = getDocumentBuilder();
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        }
        catch(Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }
    // XML constants for tag names and attribute names
    private static final String BUILD_TAG = ""build"";
    private static final String TARGET_TAG = ""target"";
    private static final String TASK_TAG = ""task"";
    private static final String MESSAGE_TAG = ""message"";
    private static final String NAME_ATTR = ""name"";
    private static final String TIME_ATTR = ""time"";
    private static final String PRIORITY_ATTR = ""priority"";
    private static final String LOCATION_ATTR = ""location"";
    private static final String ERROR_ATTR = ""error"";
    private Document doc;
    private Element buildElement;
    private Element targetElement;
    private Element taskElement;
    private long buildStartTime;
    private long targetStartTime;
    private long taskStartTime;
    private Stack targetTimeStack = new Stack();
    private Stack targetStack = new Stack();
    private Stack taskTimeStack = new Stack();
    private Stack taskStack = new Stack();
    /**
     *  Constructs a new BuildListener that logs build events to an XML file.
     */
    public XmlLogger() {
    }
    public void buildStarted(BuildEvent event) {
        buildStartTime = System.currentTimeMillis();
        doc = builder.newDocument();
        buildElement = doc.createElement(BUILD_TAG);
    }
    public void buildFinished(BuildEvent event) {
        long totalTime = System.currentTimeMillis() - buildStartTime;
        buildElement.setAttribute(TIME_ATTR, DefaultLogger.formatTime(totalTime));
        if (event.getException() != null) {
            buildElement.setAttribute(ERROR_ATTR, event.getException().toString());
        }
        try {
            String outFilename = 
                event.getProject().getProperty(""XmlLogger.file"");
            if (outFilename == null) {
                outFilename = ""log.xml"";
            }
            Writer out = new FileWriter(outFilename);
            out.write(""<?xml:stylesheet type=\""text/xsl\"" href=\""log.xsl\""?>\n\n"");
            (new DOMElementWriter()).write(buildElement, out, 0, ""\t"");
            out.flush();
            out.close();
        } catch(IOException exc) {
            throw new BuildException(""Unable to close log file"", exc);
        }
        buildElement = null;
    }
    public void targetStarted(BuildEvent event) {
        if (targetElement != null) {
            targetTimeStack.push(new Long(targetStartTime));
            targetStack.push(targetElement);
        }
        targetStartTime = System.currentTimeMillis();
        targetElement = doc.createElement(TARGET_TAG);
        targetElement.setAttribute(NAME_ATTR, event.getTarget().getName());
    }
    public void targetFinished(BuildEvent event) {
        long totalTime = System.currentTimeMillis() - targetStartTime;
        targetElement.setAttribute(TIME_ATTR, DefaultLogger.formatTime(totalTime));
        if (taskElement == null) {
            buildElement.appendChild(targetElement);
        } else {
            taskElement.appendChild(targetElement);
        }
        targetElement = null;
        if (!targetStack.isEmpty()) {
            targetStartTime = ((Long) targetTimeStack.pop()).longValue();
            targetElement = (Element) targetStack.pop();
        }
    }
    public void taskStarted(BuildEvent event) {
        if (taskElement != null) {
            taskTimeStack.push(new Long(taskStartTime));
            taskStack.push(taskElement);
        }
        taskStartTime = System.currentTimeMillis();
        taskElement = doc.createElement(TASK_TAG);
        String name = event.getTask().getClass().getName();
        int pos = name.lastIndexOf(""."");
        if (pos != -1) {
            name = name.substring(pos + 1);
        }
        taskElement.setAttribute(NAME_ATTR, name);
        taskElement.setAttribute(LOCATION_ATTR, event.getTask().getLocation().toString());
    }
    public void taskFinished(BuildEvent event) {
        long totalTime = System.currentTimeMillis() - taskStartTime;
        taskElement.setAttribute(TIME_ATTR, DefaultLogger.formatTime(totalTime));
        targetElement.appendChild(taskElement);
        taskElement = null;
        if (!taskStack.isEmpty()) {
            taskStartTime = ((Long) taskTimeStack.pop()).longValue();
            taskElement = (Element) taskStack.pop();
        }
    }
    public void messageLogged(BuildEvent event) {
        Element messageElement = doc.createElement(MESSAGE_TAG);
        String name = ""debug"";
        switch(event.getPriority()) {
            case Project.MSG_ERR: name = ""error""; break;
            case Project.MSG_WARN: name = ""warn""; break;
            case Project.MSG_INFO: name = ""info""; break;
            default: name = ""debug""; break;
        }
        messageElement.setAttribute(PRIORITY_ATTR, name);
        Text messageText = doc.createTextNode(event.getMessage());
        messageElement.appendChild(messageText);
        if (taskElement != null) {
            taskElement.appendChild(messageElement);
        }
        else if (targetElement != null) {
            targetElement.appendChild(messageElement);
        }
        else {
            buildElement.appendChild(messageElement);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Ant,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.*;
/**
 * Call Ant in a sub-project
 *
 *  <pre>
 *    <target name=""foo"" depends=""init"">
 *    <ant antfile=""build.xml"" target=""bar"" >
 *      <property name=""property1"" value=""aaaaa"" />
 *      <property name=""foo"" value=""baz"" />
 *     </ant>
 *  </target>
 *
 * <target name=""bar"" depends=""init"">
 *    <echo message=""prop is ${property1} ${foo}"" />
 * </target>
 * </pre>
 *
 *
 * @author costin@dnt.ro
 */
public class Ant extends Task {
    private File dir = null;
    private String antFile = null;
    private String target = null;
    private String output = null;
    Vector properties=new Vector();
    Project p1;
    public void init() {
        p1 = new Project();
        p1.setJavaVersionProperty();
        p1.addTaskDefinition(""property"", 
                             (Class)project.getTaskDefinitions().get(""property""));
    }
    private void reinit() {
        init();
        for (int i=0; i<properties.size(); i++) {
            Property p = (Property) properties.elementAt(i);
            Property newP = (Property) p1.createTask(""property"");
            newP.setName(p.getName());
            if (p.getValue() != null) {
                newP.setValue(p.getValue());
            }
            if (p.getFile() != null) {
                newP.setFile(p.getFile());
            } 
            if (p.getResource() != null) {
                newP.setResource(p.getResource());
            }
            properties.setElementAt(newP, i);
        }
    }
    private void initializeProject() {
        Vector listeners = project.getBuildListeners();
        for (int i = 0; i < listeners.size(); i++) {
            p1.addBuildListener((BuildListener)listeners.elementAt(i));
        }
        if (output != null) {
            try {
                PrintStream out = new PrintStream(new FileOutputStream(output));
                DefaultLogger logger = new DefaultLogger();
                logger.setMessageOutputLevel(Project.MSG_INFO);
                logger.setOutputPrintStream(out);
                logger.setErrorPrintStream(out);
                p1.addBuildListener(logger);
            }
            catch( IOException ex ) {
                log( ""Ant: Can't set output to "" + output );
            }
        }
        Hashtable taskdefs = project.getTaskDefinitions();
        Enumeration et = taskdefs.keys();
        while (et.hasMoreElements()) {
            String taskName = (String) et.nextElement();
            Class taskClass = (Class) taskdefs.get(taskName);
            p1.addTaskDefinition(taskName, taskClass);
        }
        Hashtable typedefs = project.getDataTypeDefinitions();
        Enumeration e = typedefs.keys();
        while (e.hasMoreElements()) {
            String typeName = (String) e.nextElement();
            Class typeClass = (Class) typedefs.get(typeName);
            p1.addDataTypeDefinition(typeName, typeClass);
        }
        // set user-define properties
        Hashtable prop1 = project.getProperties();
        e = prop1.keys();
        while (e.hasMoreElements()) {
            String arg = (String) e.nextElement();
            String value = (String) prop1.get(arg);
            p1.setProperty(arg, value);
        }
    }
    /**
     * Do the execution.
     */
    public void execute() throws BuildException {
        try {
            if (p1 == null) {
                reinit();
            }
            if(dir == null) 
                dir = project.getBaseDir();
            initializeProject();
            p1.setBaseDir(dir);
            p1.setUserProperty(""basedir"" , dir.getAbsolutePath());
            // Override with local-defined properties
            Enumeration e = properties.elements();
            while (e.hasMoreElements()) {
                Property p=(Property) e.nextElement();
                p.execute();
            }
            if (antFile == null) 
                antFile = ""build.xml"";
            File file = new File(antFile);
            if (!file.isAbsolute()) {
                antFile = (new File(dir, antFile)).getAbsolutePath();
                file = (new File(antFile)) ;
                if( ! file.isFile() ) {
                  throw new BuildException(""Build file "" + file + "" not found."");
                }
            }
            p1.setUserProperty( ""ant.file"" , antFile );
            ProjectHelper.configureProject(p1, new File(antFile));
            if (target == null) {
                target = p1.getDefaultTarget();
            }
            // Are we trying to call the target in which we are defined?
            if (p1.getBaseDir().equals(project.getBaseDir()) &&
                p1.getProperty(""ant.file"").equals(project.getProperty(""ant.file"")) &&
                target.equals(this.getOwningTarget().getName())) { 
                throw new BuildException(""ant task calling its own parent target"");
            }
            p1.executeTarget(target);
        } finally {
            // help the gc
            p1 = null;
        }
    }
    public void setDir(File d) {
        this.dir = d;
    }
    public void setAntfile(String s) {
        this.antFile = s;
    }
    public void setTarget(String s) {
        this.target = s;
    }
    public void setOutput(String s) {
        this.output = s;
    }
    public Property createProperty() {
        if (p1 == null) {
            reinit();
        }
        Property p=(Property)p1.createTask(""property"");
        p.setUserProperty(true);
        properties.addElement( p );
        return p;
    }
}
"
org.apache.tools.ant.taskdefs.AntStructure,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.IntrospectionHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.io.*;
/**
 * Creates a partial DTD for Ant from the currently known tasks.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class AntStructure extends Task {
    private final String lSep = System.getProperty(""line.separator"");
    private Hashtable visited = new Hashtable();
    private File output;
    /**
     * The output file.
     */
    public void setOutput(File output) {
        this.output = output;
    }
    public void execute() throws BuildException {
        if (output == null) {
            throw new BuildException(""output attribute is required"", location);
        }
        PrintWriter out = null;
        try {
            try {
                out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(output), ""ISO8859_1""));
            } catch (UnsupportedEncodingException ue) {
                /*
                 * Plain impossible with ISO8859_1, see
                 * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html
                 *
                 * fallback to platform specific anyway.
                 */
                out = new PrintWriter(new FileWriter(output));
            }
            Enumeration dataTypes = project.getDataTypeDefinitions().keys();
            printHead(out, dataTypes);
            Vector tasks = new Vector();
            Enumeration enum = project.getTaskDefinitions().keys();
            while (enum.hasMoreElements()) {
                String taskName = (String) enum.nextElement();
                tasks.addElement(taskName);
            }
            printTargetDecl(out, tasks);
            dataTypes = project.getDataTypeDefinitions().keys();
            while (dataTypes.hasMoreElements()) {
                String typeName = (String) dataTypes.nextElement();
                printElementDecl(out, typeName, 
                                 (Class) project.getDataTypeDefinitions().get(typeName));
            }
            for (int i=0; i<tasks.size(); i++) {
                String taskName = (String) tasks.elementAt(i);
                printElementDecl(out, taskName, 
                                 (Class) project.getTaskDefinitions().get(taskName));
            }
            printTail(out);
        } catch (IOException ioe) {
            throw new BuildException(""Error writing ""+output.getAbsolutePath(),
                                     ioe, location);
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }
    private void printHead(PrintWriter out, Enumeration enum) {
        out.println(""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>"");
        out.println(""<!ENTITY % boolean \""(true|false|on|off|yes|no)\"">"");
        out.println("""");
        out.print(""<!ELEMENT project (target | property | taskdef"");
        while (enum.hasMoreElements()) {
            String typeName = (String) enum.nextElement();
            out.print("" | ""+typeName);
        }
        out.println("")*>"");
        out.println(""<!ATTLIST project"");
        out.println(""          name    CDATA #REQUIRED"");
        out.println(""          default CDATA #REQUIRED"");
        out.println(""          basedir CDATA #IMPLIED>"");
        out.println("""");
    }
    private void printTargetDecl(PrintWriter out, Vector tasks) {
        out.print(""<!ELEMENT target ("");
        for (int i=0; i<tasks.size(); i++) {
            String taskName = (String) tasks.elementAt(i);
            if (i > 0) {
                out.print("" | "");
            }
            out.print(taskName);
        }
        out.println("")*>"");
        out.println("""");
        out.println(""<!ATTLIST target"");
        out.println(""          id          ID    #IMPLIED"");
        out.println(""          name        CDATA #REQUIRED"");
        out.println(""          if          CDATA #IMPLIED"");
        out.println(""          unless      CDATA #IMPLIED"");
        out.println(""          depends     CDATA #IMPLIED"");
        out.println(""          description CDATA #IMPLIED>"");
        out.println("""");
    }
    private void printElementDecl(PrintWriter out, String name, Class element) 
        throws BuildException {
        if (visited.containsKey(name)) {
            return;
        }
        visited.put(name, """");
        IntrospectionHelper ih = IntrospectionHelper.getHelper(element);
        StringBuffer sb = new StringBuffer(""<!ELEMENT "");
        sb.append(name).append("" "");
        if (org.apache.tools.ant.types.Reference.class.equals(element)) {
            sb.append(""EMPTY>"").append(lSep);
            sb.append(""<!ATTLIST "").append(name);
            sb.append(lSep).append(""          id ID #IMPLIED"");
            sb.append(lSep).append(""          refid IDREF #IMPLIED"");
            sb.append("">"").append(lSep);
            out.println(sb);
            return;
        }
        Vector v = new Vector();
        if (ih.supportsCharacters()) {
            v.addElement(""#PCDATA"");
        }
        Enumeration enum = ih.getNestedElements();
        while (enum.hasMoreElements()) {
            v.addElement((String) enum.nextElement());
        }
        if (v.isEmpty()) {
            sb.append(""EMPTY"");
        } else {
            sb.append(""("");
            for (int i=0; i<v.size(); i++) {
                if (i != 0) {
                    sb.append("" | "");
                }
                sb.append(v.elementAt(i));
            }
            sb.append("")"");
            if (v.size() > 1 || !v.elementAt(0).equals(""#PCDATA"")) {
                sb.append(""*"");
            }
        }
        sb.append("">"");
        out.println(sb);
        sb.setLength(0);
        sb.append(""<!ATTLIST "").append(name);
        sb.append(lSep).append(""          id ID #IMPLIED"");
        enum = ih.getAttributes();
        while (enum.hasMoreElements()) {
            String attrName = (String) enum.nextElement();
            if (""id"".equals(attrName)) continue;
            sb.append(lSep).append(""          "").append(attrName).append("" "");
            Class type = ih.getAttributeType(attrName);
            if (type.equals(java.lang.Boolean.class) || 
                type.equals(java.lang.Boolean.TYPE)) {
                sb.append(""%boolean; "");
            } else if (org.apache.tools.ant.types.Reference.class.isAssignableFrom(type)) { 
                sb.append(""IDREF "");
            } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(type)) {
                try {
                    EnumeratedAttribute ea = 
                        (EnumeratedAttribute)type.newInstance();
                    String[] values = ea.getValues();
                    if (values == null || values.length == 0) {
                        sb.append(""CDATA "");
                    } else {
                        sb.append(""("");
                        for (int i=0; i < values.length; i++) {
                            if (i != 0) {
                                sb.append("" | "");
                            }
                            sb.append(values[i]);
                        }
                        sb.append("") "");
                    }
                } catch (InstantiationException ie) {
                    sb.append(""CDATA "");
                } catch (IllegalAccessException ie) {
                    sb.append(""CDATA "");
                }
            } else {
                sb.append(""CDATA "");
            }
            sb.append(""#IMPLIED"");
        }
        sb.append("">"").append(lSep);
        out.println(sb);
        for (int i=0; i<v.size(); i++) {
            String nestedName = (String) v.elementAt(i);
            if (!""#PCDATA"".equals(nestedName)) {
                printElementDecl(out, nestedName, ih.getElementType(nestedName));
            }
        }
    }
    private void printTail(PrintWriter out) {}
}
"
org.apache.tools.ant.taskdefs.Available,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
/**
 * Will set the given property if the requested resource is available at runtime.
 *
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 */
public class Available extends Task {
    private String property;
    private String classname;
    private File file;
    private String resource;
    private Path classpath;
    private AntClassLoader loader;
    private String value = ""true"";
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(project);
        }
        return this.classpath.createPath();
    }
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    public void setProperty(String property) {
        this.property = property;
    }
    public void setValue(String value) {
        this.value = value;
    }
    public void setClassname(String classname) {
        if (!"""".equals(classname)) {
            this.classname = classname;
        }
    }
    public void setFile(File file) {
        this.file = file;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public void execute() throws BuildException {
        if (property == null) {
            throw new BuildException(""property attribute is required"", location);
        }
        if (classname == null && file == null && resource == null) {
            throw new BuildException(""At least one of (classname|file|resource) is required"", location);
        }
        if (classpath != null) {
            this.loader = new AntClassLoader(project, classpath, false);
        }
        if ((classname != null) && !checkClass(classname)) {
            log(""Unable to load class "" + classname + "" to set property "" + property, Project.MSG_VERBOSE);
            return;
        }
        if ((file != null) && !checkFile(file)) {
            log(""Unable to find file "" + file + "" to set property "" + property, Project.MSG_VERBOSE);
            return;
        }
        if ((resource != null) && !checkResource(resource)) {
            log(""Unable to load resource "" + resource + "" to set property "" + property, Project.MSG_VERBOSE);
            return;
        }
        this.project.setProperty(property, value);
    }
    private boolean checkFile(File file) {
        return file.exists();
    }
    private boolean checkResource(String resource) {
        if (loader != null) {
            return (loader.getResourceAsStream(resource) != null);
        } else {
            ClassLoader cL = this.getClass().getClassLoader();
            if (cL != null) {
                return (cL.getResourceAsStream(resource) != null);
            } else {
                return 
                    (ClassLoader.getSystemResourceAsStream(resource) != null);
            }
        }
    }
    private boolean checkClass(String classname) {
        try {
            if (loader != null) {
                loader.loadClass(classname);
            } else {
                ClassLoader l = this.getClass().getClassLoader();
                // Can return null to represent the bootstrap class loader.
                // see API docs of Class.getClassLoader.
                if (l != null) {
                    l.loadClass(classname);
                } else {
                    Class.forName(classname);
                }
            }
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        } catch (NoClassDefFoundError e) {
            return false;
        }
    }
}
"
org.apache.tools.ant.taskdefs.CallTarget,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
/**
 * Call another target in the same project.
 *
 *  <pre>
 *    <target name=""foo"">
 *      <antcall target=""bar"">
 *        <param name=""property1"" value=""aaaaa"" />
 *        <param name=""foo"" value=""baz"" />
 *       </antcall>
 *    </target>
 *
 *    <target name=""bar"" depends=""init"">
 *      <echo message=""prop is ${property1} ${foo}"" />
 *    </target>
 * </pre>
 *
 * <p>This only works as expected if neither property1 nor foo are
 * defined in the project itself.
 *
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class CallTarget extends Task {
    private Ant callee;
    private String subTarget;
    public void init() {
        callee = (Ant) project.createTask(""ant"");
        callee.setOwningTarget(target);
        callee.setTaskName(getTaskName());
        callee.setLocation(location);
        callee.init();
    }
    public void execute() {
        if (subTarget == null) {
            throw new BuildException(""Attribute target is required."", 
                                     location);
        }
        callee.setDir(project.getBaseDir());
        callee.setAntfile(project.getProperty(""ant.file""));
        callee.setTarget(subTarget);
        callee.execute();
    }
    public Property createParam() {
        return callee.createProperty();
    }
    public void setTarget(String target) {
        subTarget = target;
    }
}
"
org.apache.tools.ant.taskdefs.Chmod,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.*;
/**
 * Chmod equivalent for unix-like environments.
 *
 * @author costin@eng.sun.com
 * @author Mariusz Nowostawski (Marni) <a href=""mailto:mnowostawski@infoscience.otago.ac.nz"">mnowostawski@infoscience.otago.ac.nz</a>
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class Chmod extends ExecuteOn {
    private FileSet defaultSet = new FileSet();
    private boolean havePerm = false;
    public Chmod() {
        super.setExecutable(""chmod"");
        super.setParallel(true);
    }
    public void setFile(File src) {
        FileSet fs = new FileSet();
        fs.setDir(new File(src.getParent()));
        fs.createInclude().setName(src.getName());
        addFileset(fs);
    }
    public void setDir(File src) {
        defaultSet.setDir(src);
    }
    public void setPerm(String perm) {
        createArg().setValue(perm);
        havePerm = true;
    }
    /**
     * add a name entry on the include list
     */
    public PatternSet.NameEntry createInclude() {
        return defaultSet.createInclude();
    }
    /**
     * add a name entry on the exclude list
     */
    public PatternSet.NameEntry createExclude() {
        return defaultSet.createExclude();
    }
    /**
     * add a set of patterns
     */
    public PatternSet createPatternSet() {
        return defaultSet.createPatternSet();
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        defaultSet.setIncludes(includes);
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        defaultSet.setExcludes(excludes);
    }
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        defaultSet.setDefaultexcludes(useDefaultExcludes);
    }
    protected void checkConfiguration() {
        if (!havePerm) {
            throw new BuildException(""Required attribute perm not set in chmod"", 
                                     location);
        }
        if (defaultSet.getDir(project) != null) {
            addFileset(defaultSet);
        }
        super.checkConfiguration();
    }
    public void setExecutable(String e) {
        throw new BuildException(taskType+"" doesn\'t support the executable attribute"", location);
    }
    public void setCommand(String e) {
        throw new BuildException(taskType+"" doesn\'t support the command attribute"", location);
    }
    protected boolean isValidOs() {
        // XXX if OS=unix
        return System.getProperty(""path.separator"").equals("":"") 
            && (!System.getProperty(""os.name"").startsWith(""Mac"") 
                 || System.getProperty(""os.name"").endsWith(""X""))
            && super.isValidOs();
    }
}
"
org.apache.tools.ant.taskdefs.CompileTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.PatternSet;
import java.util.*;
/**
 * This task will compile and load a new taskdef all in one step.
 * At times, this is useful for eliminating ordering dependencies
 * which otherwise would require multiple executions of Ant.
 *
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 *
 * @deprecated use &lt;taskdef&gt; elements nested into &lt;target&gt;s instead
 */
public class CompileTask extends Javac {
    protected Vector taskList = new Vector();
    /**
     * add a new task entry on the task list
     */
    public Taskdef createTaskdef() {
        Taskdef task = new Taskdef();
        taskList.addElement(task);
        return task;
    }
    /**
     * do all the real work in init
     */
    public void init() {
        log(""!! CompileTask is deprecated. !!"");
        log(""Use <taskdef> elements nested into <target>s instead"");
        // create all the include entries from the task defs
        for (Enumeration e=taskList.elements(); e.hasMoreElements(); ) {
            Taskdef task = (Taskdef)e.nextElement();
            String source = task.getClassname().replace('.','/') + "".java"";
            PatternSet.NameEntry include = super.createInclude();
            include.setName(""**/"" + source);
        }
        // execute Javac
        super.init();        
        super.execute();        
        // now define all the new tasks
        for (Enumeration e=taskList.elements(); e.hasMoreElements(); ) {
            Taskdef task = (Taskdef)e.nextElement();
            task.init();
        }
    }
    /**
     * have execute do nothing
     */
    public void execute() {
    }
}
"
org.apache.tools.ant.taskdefs.Copy,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.util.*;
import java.io.*;
import java.util.*;
/**
 * A consolidated copy task.  Copies a file or directory to a new file 
 * or directory.  Files are only copied if the source file is newer
 * than the destination file, or when the destination file does not 
 * exist.  It is possible to explicitly overwrite existing files.</p>
 *
 * <p>This implementation is based on Arnout Kuiper's initial design
 * document, the following mailing list discussions, and the 
 * copyfile/copydir tasks.</p>
 *
 * @author Glenn McAllister <a href=""mailto:glennm@ca.ibm.com"">glennm@ca.ibm.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Copy extends Task {
    protected File file = null;     // the source file 
    protected File destFile = null; // the destination file 
    protected File destDir = null;  // the destination directory
    protected Vector filesets = new Vector();
    protected boolean filtering = false;
    protected boolean preserveLastModified = false;
    protected boolean forceOverwrite = false;
    protected boolean flatten = false;
    protected int verbosity = Project.MSG_VERBOSE;
    protected boolean includeEmpty = true;
    protected Hashtable fileCopyMap = new Hashtable();
    protected Hashtable dirCopyMap = new Hashtable();
    protected Mapper mapperElement = null;
    /**
     * Sets a single source file to copy.
     */
    public void setFile(File file) {
        this.file = file;
    }
    /**
     * Sets the destination file.
     */
    public void setTofile(File destFile) {
        this.destFile = destFile;
    }
    /**
     * Sets the destination directory.
     */
    public void setTodir(File destDir) {
        this.destDir = destDir;
    }
    /**
     * Give the copied files the same last modified time as the original files.
     */
    public void setPreserveLastModified(String preserve) {
        preserveLastModified = Project.toBoolean(preserve);
    }
    /**
     * Sets filtering.
     */
    public void setFiltering(boolean filtering) {
        this.filtering = filtering;
    }
    /**
     * Overwrite any existing destination file(s).
     */
    public void setOverwrite(boolean overwrite) {
        this.forceOverwrite = overwrite;
    }
    /**
     * When copying directory trees, the files can be ""flattened""
     * into a single directory.  If there are multiple files with
     * the same name in the source directory tree, only the first
     * file will be copied into the ""flattened"" directory, unless
     * the forceoverwrite attribute is true.
     */
    public void setFlatten(boolean flatten) {
        this.flatten = flatten;
    }
    /**
     * Used to force listing of all names of copied files.
     */
    public void setVerbose(boolean verbose) {
        if (verbose) {
            this.verbosity = Project.MSG_INFO;
        } else {
            this.verbosity = Project.MSG_VERBOSE;
        } 
    } 
    /**
     * Used to copy empty directories.
     */
    public void setIncludeEmptyDirs(boolean includeEmpty) {
        this.includeEmpty = includeEmpty;
    }
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * Defines the FileNameMapper to use (nested mapper element).
     */
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     location);
        }
        mapperElement = new Mapper(project);
        return mapperElement;
    }
    /**
     * Performs the copy operation.
     */
    public void execute() throws BuildException {
        // make sure we don't have an illegal set of options
        validateAttributes();   
        // deal with the single file
        if (file != null) {
            if (file.exists()) {
                if (destFile == null) {
                    destFile = new File(destDir, file.getName());
                }
                if (forceOverwrite || 
                    (file.lastModified() > destFile.lastModified())) {
                    fileCopyMap.put(file.getAbsolutePath(), destFile.getAbsolutePath());
                }
            } else {
                log(""Could not find file "" + file.getAbsolutePath() + "" to copy."");
            }
        }
        // deal with the filesets
        for (int i=0; i<filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            File fromDir = fs.getDir(project);
            String[] srcFiles = ds.getIncludedFiles();
            String[] srcDirs = ds.getIncludedDirectories();
            scan(fromDir, destDir, srcFiles, srcDirs);
        }
        // do all the copy operations now...
        doFileOperations();
        // clean up destDir again - so this instance can be used a second
        // time without throwing an exception
        if (destFile != null) {
            destDir = null;
        }
    }
//************************************************************************
//  protected and private methods
//************************************************************************
    /**
     * Ensure we have a consistent and legal set of attributes, and set
     * any internal flags necessary based on different combinations 
     * of attributes.
     */
    protected void validateAttributes() throws BuildException {
        if (file == null && filesets.size() == 0) {
            throw new BuildException(""Specify at least one source - a file or a fileset."");
        }
        if (destFile != null && destDir != null) {
            throw new BuildException(""Only one of destfile and destdir may be set."");
        }
        if (destFile == null && destDir == null) {
            throw new BuildException(""One of destfile or destdir must be set."");
        }
        if (file != null && file.exists() && file.isDirectory()) {
            throw new BuildException(""Use a fileset to copy directories."");
        }
        if (destFile != null && filesets.size() > 0) {
            throw new BuildException(""Cannot concatenate multple files into a single file."");
        }
        if (destFile != null) {
            destDir = new File(destFile.getParent());   // be 1.1 friendly
        }
    }
    /**
     * Compares source files to destination files to see if they should be
     * copied.
     */
    protected void scan(File fromDir, File toDir, String[] files, String[] dirs) {
        FileNameMapper mapper = null;
        if (mapperElement != null) {
            mapper = mapperElement.getImplementation();
        } else if (flatten) {
            mapper = new FlatFileNameMapper();
        } else {
            mapper = new IdentityMapper();
        }
        buildMap(fromDir, toDir, files, mapper, fileCopyMap);
        if (includeEmpty) {
            buildMap(fromDir, toDir, dirs, mapper, dirCopyMap);
        }
    }
    protected void buildMap(File fromDir, File toDir, String[] names,
                            FileNameMapper mapper, Hashtable map) {
        String[] toCopy = null;
        if (forceOverwrite) {
            Vector v = new Vector();
            for (int i=0; i<names.length; i++) {
                if (mapper.mapFileName(names[i]) != null) {
                    v.addElement(names[i]);
                }
            }
            toCopy = new String[v.size()];
            v.copyInto(toCopy);
        } else {
            SourceFileScanner ds = new SourceFileScanner(this);
            toCopy = ds.restrict(names, fromDir, toDir, mapper);
        }
        for (int i = 0; i < toCopy.length; i++) {
            File src = new File(fromDir, toCopy[i]);
            File dest = new File(toDir, mapper.mapFileName(toCopy[i])[0]);
            map.put( src.getAbsolutePath(), dest.getAbsolutePath() );
        }
    }
    /**
     * Actually does the file (and possibly empty directory) copies.
     * This is a good method for subclasses to override.
     */
    protected void doFileOperations() {
        if (fileCopyMap.size() > 0) {
            log(""Copying "" + fileCopyMap.size() + 
                "" file"" + (fileCopyMap.size() == 1 ? """" : ""s"") + 
                "" to "" + destDir.getAbsolutePath() );
            Enumeration e = fileCopyMap.keys();
            while (e.hasMoreElements()) {
                String fromFile = (String) e.nextElement();
                String toFile = (String) fileCopyMap.get(fromFile);
                if( fromFile.equals( toFile ) ) {
                    log(""Skipping self-copy of "" + fromFile, verbosity);
                    continue;
                }
                try {
                    log(""Copying "" + fromFile + "" to "" + toFile, verbosity);
                    project.copyFile(fromFile, 
                                     toFile, 
                                     filtering, 
                                     forceOverwrite,
                                     preserveLastModified);
                } catch (IOException ioe) {
                    String msg = ""Failed to copy "" + fromFile + "" to "" + toFile
                        + "" due to "" + ioe.getMessage();
                    throw new BuildException(msg, ioe, location);
                }
            }
        }
        if (includeEmpty) {
            Enumeration e = dirCopyMap.elements();
            int count = 0;
            while (e.hasMoreElements()) {
                File d = new File((String)e.nextElement());
                if (!d.exists()) {
                    if (!d.mkdirs()) {
                        log(""Unable to create directory "" + d.getAbsolutePath(), Project.MSG_ERR);
                    } else {
                        count++;
                    }
                }
            }
            if (count > 0) {
                log(""Copied "" + count + 
                    "" empty director"" + 
                    (count==1?""y"":""ies"") + 
                    "" to "" + destDir.getAbsolutePath());
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Copydir,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
/**
 * Copies a directory.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 *
 * @deprecated The copydir task is deprecated.  Use copy instead.
 */
public class Copydir extends MatchingTask {
    private File srcDir;
    private File destDir;
    private boolean filtering = false;
    private boolean flatten = false;
    private boolean forceOverwrite = false;
    private Hashtable filecopyList = new Hashtable();
    public void setSrc(File src) {
        srcDir = src;
    }
    public void setDest(File dest) {
        destDir = dest;
    }
    public void setFiltering(boolean filter) {
        filtering = filter;
    }
    public void setFlatten(boolean flatten) {
        this.flatten = flatten;
    }
    public void setForceoverwrite(boolean force) {
        forceOverwrite = force;
    }
    public void execute() throws BuildException {
        log(""DEPRECATED - The copydir task is deprecated.  Use copy instead."");
        if (srcDir == null) {
            throw new BuildException(""src attribute must be set!"", 
                                     location);
        }
        if (!srcDir.exists()) {
            throw new BuildException(""srcdir ""+srcDir.toString()
                                     +"" does not exist!"", location);
        }
        if (destDir == null) {
            throw new BuildException(""The dest attribute must be set."", location);
        }
        if (srcDir.equals(destDir)) {
            log(""Warning: src == dest"");
        }
        DirectoryScanner ds = super.getDirectoryScanner(srcDir);
        String[] files = ds.getIncludedFiles();
        scanDir(srcDir, destDir, files);
        if (filecopyList.size() > 0) {
            log(""Copying "" + filecopyList.size() + "" file""
                + (filecopyList.size() == 1 ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());
            Enumeration enum = filecopyList.keys();
            while (enum.hasMoreElements()) {
                String fromFile = (String) enum.nextElement();
                String toFile = (String) filecopyList.get(fromFile);
                try {
                    project.copyFile(fromFile, toFile, filtering, 
                                     forceOverwrite);
                } catch (IOException ioe) {
                    String msg = ""Failed to copy "" + fromFile + "" to "" + toFile
                        + "" due to "" + ioe.getMessage();
                    throw new BuildException(msg, ioe, location);
                }
            }
        }
    }
    private void scanDir(File from, File to, String[] files) {
        for (int i = 0; i < files.length; i++) {
            String filename = files[i];
            File srcFile = new File(from, filename);
            File destFile;
            if (flatten) {
                destFile = new File(to, new File(filename).getName());
            } else {
                destFile = new File(to, filename);
            }
            if (forceOverwrite ||
                (srcFile.lastModified() > destFile.lastModified())) {
                filecopyList.put(srcFile.getAbsolutePath(),
                                 destFile.getAbsolutePath());
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Copyfile,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
/**
 * Copies a file.
 *
 * @author duncan@x180.com
 *
 * @deprecated The copyfile task is deprecated.  Use copy instead.
 */
public class Copyfile extends Task {
    private File srcFile;
    private File destFile;
    private boolean filtering = false;
    private boolean forceOverwrite = false;
    public void setSrc(File src) {
        srcFile = src;
    }
    public void setForceoverwrite(boolean force) {
        forceOverwrite = force;
    }
    public void setDest(File dest) {
        destFile = dest;
    }
    public void setFiltering(String filter) {
        filtering = Project.toBoolean(filter);
    }
    public void execute() throws BuildException {
        log(""DEPRECATED - The copyfile task is deprecated.  Use copy instead."");
        if (srcFile == null) {
            throw new BuildException(""The src attribute must be present."", location);
        }
        if (!srcFile.exists()) {
            throw new BuildException(""src "" + srcFile.toString()
                                     + "" does not exist."", location);
        }
        if (destFile == null) {
            throw new BuildException(""The dest attribute must be present."", location);
        }
        if (srcFile.equals(destFile)) {
            log(""Warning: src == dest"");
        }
        if (forceOverwrite || srcFile.lastModified() > destFile.lastModified()) {
            try {
                project.copyFile(srcFile, destFile, filtering, forceOverwrite);
            } catch (IOException ioe) {
                String msg = ""Error copying file: "" + srcFile.getAbsolutePath()
                    + "" due to "" + ioe.getMessage();
                throw new BuildException(msg);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Cvs,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import java.io.*;
/**
 *
 *
 * @author costin@dnt.ro
 * @author stefano@apache.org
 * @author Wolfgang Werner <a href=""mailto:wwerner@picturesafe.de"">wwerner@picturesafe.de</a>
 */
public class Cvs extends Task {
    private Commandline cmd = new Commandline();
    /**
     * the CVSROOT variable.
     */
    private String cvsRoot;
    /**
     * the package/module to check out.
     */
    private String pack;
    /**
     * the CVS command to execute.
     */
    private String command = ""checkout"";
    /**
     * suppress information messages.
     */
    private boolean quiet = false;
    /**
     * report only, don't change any files.
     */
    private boolean noexec = false;
    /**
     * the directory where the checked out files should be placed.
     */
    private File dest;
    /**
     * the file to direct standard output from the command.
     */
    private File output;
    /**
     * the file to direct standard error from the command.
     */
    private File error; 
    public void execute() throws BuildException {
        // XXX: we should use JCVS (www.ice.com/JCVS) instead of command line
        // execution so that we don't rely on having native CVS stuff around (SM)
        // We can't do it ourselves as jCVS is GPLed, a third party task 
        // outside of jakarta repositories would be possible though (SB).
        Commandline toExecute = new Commandline();
        toExecute.setExecutable(""cvs"");
        if (cvsRoot != null) { 
            toExecute.createArgument().setValue(""-d"");
            toExecute.createArgument().setValue(cvsRoot);
        }
        if (noexec) {
            toExecute.createArgument().setValue(""-n"");
        }
        if (quiet) {
            toExecute.createArgument().setValue(""-q"");
        }
        toExecute.createArgument().setLine(command);
        toExecute.addArguments(cmd.getCommandline());
        if (pack != null) {
            toExecute.createArgument().setLine(pack);
        }
        ExecuteStreamHandler streamhandler = null;
        OutputStream outputstream = null;
        OutputStream errorstream = null; 
        if (error == null && output == null) {
            streamhandler = new LogStreamHandler(this, Project.MSG_INFO,
                                                 Project.MSG_WARN);
        }
        else {
            if (output != null) {
                try {
                    outputstream = new PrintStream(new BufferedOutputStream(new FileOutputStream(output)));
                } catch (IOException e) {
                    throw new BuildException(e, location);
                }
            }
            else {
                outputstream = new LogOutputStream(this, Project.MSG_INFO);
            }
            if (error != null) {
                try {
                    errorstream = new PrintStream(new BufferedOutputStream(new FileOutputStream(error)));
                } catch (IOException e) {
                    throw new BuildException(e, location);
                }
            }
            else {
                errorstream = new LogOutputStream(this, Project.MSG_WARN);
            }
            streamhandler = new PumpStreamHandler(outputstream, errorstream);
        }
        Execute exe = new Execute(streamhandler, 
                                  null);
        exe.setAntRun(project);
        if (dest == null) dest = project.getBaseDir();
        exe.setWorkingDirectory(dest);
        exe.setCommandline(toExecute.getCommandline());
        try {
            exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, location);
        } finally {
            if (output != null) {
                try {
                    outputstream.close();
                } catch (IOException e) {}
            }
            if (error != null) {
                try {
                    errorstream.close();
                } catch (IOException e) {}
            }
        }
    }
    public void setCvsRoot(String root) {
        // Check if not real cvsroot => set it to null 
        if (root != null) { 
            if (root.trim().equals("""")) 
                root = null; 
        } 
        this.cvsRoot = root;
    }
    public void setDest(File dest) {
        this.dest = dest;
    }
    public void setPackage(String p) {
        this.pack = p;
    }
    public void setTag(String p) { 
        // Check if not real tag => set it to null 
        if (p != null && p.trim().length() > 0) {
            cmd.createArgument().setValue(""-r"");
            cmd.createArgument().setValue(p);
        }
    } 
    public void setDate(String p) {
        if(p != null && p.trim().length() > 0) {
            cmd.createArgument().setValue(""-D"");
            cmd.createArgument().setValue(p);
        }
    }
    public void setCommand(String c) {
        this.command = c;
    }
    public void setQuiet(boolean q) {
        quiet = q;
    }
    public void setNoexec(boolean ne) {
        noexec = ne;
    }
    public void setOutput(File output) {
        this.output = output;
    }
    public void setError(File error) {
        this.error = error;
    }
}
"
org.apache.tools.ant.taskdefs.Delete,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.*;
/**
 * Deletes a file or directory, or set of files defined by a fileset.
 * The original delete task would delete a file, or a set of files 
 * using the include/exclude syntax.  The deltree task would delete a 
 * directory tree.  This task combines the functionality of these two
 * originally distinct tasks.
 * <p>Currently Delete extends MatchingTask.  This is intend <i>only</i>
 * to provide backwards compatibility for a release.  The future position
 * is to use nested filesets exclusively.</p>
 * 
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Tom Dimock <a href=""mailto:tad1@cornell.edu"">tad1@cornell.edu</a>
 * @author Glenn McAllister <a href=""mailto:glennm@ca.ibm.com"">glennm@ca.ibm.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@latchkey.com"">jon@latchkey.com</a>
 */
public class Delete extends MatchingTask {
    protected File file = null;
    protected File dir = null;
    protected Vector filesets = new Vector();
    protected boolean usedMatchingTask = false;
    protected boolean includeEmpty = false;	// by default, remove matching empty dirs
    private int verbosity = Project.MSG_VERBOSE;
    private boolean quiet = false;
    /**
     * Set the name of a single file to be removed.
     * 
     * @param file the file to be deleted
     */
    public void setFile(File file) {
        this.file = file;
    } 
    /**
     * Set the directory from which files are to be deleted
     * 
     * @param dir the directory path.
     */
    public void setDir(File dir) {
        this.dir = dir;
    } 
    /**
     * Used to force listing of all names of deleted files.
     * 
     * @param verbose ""true"" or ""on""
     */
    public void setVerbose(boolean verbose) {
        if (verbose) {
            this.verbosity = Project.MSG_INFO;
        } else {
            this.verbosity = Project.MSG_VERBOSE;
        } 
    } 
    /**
     * If the file does not exist, do not display a diagnostic 
     * message or modify the exit status to reflect an error.
     * This means that if a file or directory cannot be deleted,
     * then no error is reported. This setting emulates the 
     * -f option to the Unix &quot;rm&quot; command.
     * Default is false meaning things are &quot;noisy&quot;
     * @param quiet ""true"" or ""on""
     */
    public void setQuiet(boolean quiet) {
        this.quiet = quiet;
    } 
    /**
     * Used to delete empty directories.
     */
    public void setIncludeEmptyDirs(boolean includeEmpty) {
        this.includeEmpty = includeEmpty;
    }
   /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * add a name entry on the include list
     */
    public PatternSet.NameEntry createInclude() {
        usedMatchingTask = true;
        return super.createInclude();
    }
    /**
     * add a name entry on the exclude list
     */
    public PatternSet.NameEntry createExclude() {
        usedMatchingTask = true;
        return super.createExclude();
    }
    /**
     * add a set of patterns
     */
    public PatternSet createPatternSet() {
        usedMatchingTask = true;
        return super.createPatternSet();
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        usedMatchingTask = true;
        super.setIncludes(includes);
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        usedMatchingTask = true;
        super.setExcludes(excludes);
    }
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        usedMatchingTask = true;
        super.setDefaultexcludes(useDefaultExcludes);
    }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param includesfile A string containing the filename to fetch
     * the include patterns from.  
     */
    public void setIncludesfile(File includesfile) {
        usedMatchingTask = true;
        super.setIncludesfile(includesfile);
    }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param excludesfile A string containing the filename to fetch
     * the include patterns from.  
     */
    public void setExcludesfile(File excludesfile) {
        usedMatchingTask = true;
        super.setExcludesfile(excludesfile);
    }
    /**
     * Delete the file(s).
     */
    public void execute() throws BuildException {
        if (usedMatchingTask) {
            log(""DEPRECATED - Use of the implicit FileSet is deprecated.  Use a nested fileset element instead."");
        }
        if (file == null && dir == null && filesets.size() == 0) {
            throw new BuildException(""At least one of the file or dir attributes, or a fileset element, must be set."");
        } 
        // delete the single file
        if (file != null) {
            if (file.exists()) {
                if (file.isDirectory()) {
                    log(""Directory "" + file.getAbsolutePath() + "" cannot be removed using the file attribute.  Use dir instead."");
                } else {
                    log(""Deleting: "" + file.getAbsolutePath());
                    if (!file.delete() && !quiet) {
                        throw new BuildException(""Unable to delete file "" + file.getAbsolutePath());
                    } 
                } 
            } else {
                log(""Could not find file "" + file.getAbsolutePath() + "" to delete."");
            }
        }
        // delete the directory
        if (dir != null && dir.exists() && dir.isDirectory() && !usedMatchingTask) {
            /*
               If verbosity is MSG_VERBOSE, that mean we are doing regular logging
               (backwards as that sounds).  In that case, we want to print one 
               message about deleting the top of the directory tree.  Otherwise, 
               the removeDir method will handle messages for _all_ directories.
             */
            if (verbosity == Project.MSG_VERBOSE) {
                log(""Deleting directory "" + dir.getAbsolutePath());
            }
            removeDir(dir);
        }
        // delete the files in the filesets
        for (int i=0; i<filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            String[] files = ds.getIncludedFiles();
            String[] dirs = ds.getIncludedDirectories();
            removeFiles(fs.getDir(project), files, dirs);
        }
        // delete the files from the default fileset
        if (usedMatchingTask && dir != null) {
            DirectoryScanner ds = super.getDirectoryScanner(dir);
            String[] files = ds.getIncludedFiles();
            String[] dirs = ds.getIncludedDirectories();
            removeFiles(dir, files, dirs);
        }
    } 
//************************************************************************
//  protected and private methods
//************************************************************************
    protected void removeDir(File d) {
        String[] list = d.list();
        if (list == null) list = new String[0];
        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                removeDir(f);
            } else {
                log(""Deleting "" + f.getAbsolutePath(), verbosity);
                if (!f.delete() && !quiet) {
                    throw new BuildException(""Unable to delete file "" + f.getAbsolutePath());
                }
            }
        }
        log(""Deleting directory "" + d.getAbsolutePath(), verbosity);
        if (!d.delete() && !quiet) {
            throw new BuildException(""Unable to delete directory "" + dir.getAbsolutePath());
        }
    }
    protected void removeFiles(File d, String[] files, String[] dirs) {
        if (files.length > 0) {
            log(""Deleting "" + files.length + "" files from "" + d.getAbsolutePath());
            for (int j=0; j<files.length; j++) {
                File f = new File(d, files[j]);
                log(""Deleting "" + f.getAbsolutePath(), verbosity);
                if (!f.delete() && !quiet) {
                    throw new BuildException(""Unable to delete file "" + f.getAbsolutePath());
                }
            }
        }
        if (dirs.length > 0 && includeEmpty) {
            int dirCount = 0;
            for (int j=0; j<dirs.length; j++) {
                File dir = new File(d, dirs[j]);
                String[] dirFiles = dir.list();
                if (dirFiles == null || dirFiles.length == 0) {
                    log(""Deleting "" + dir.getAbsolutePath(), verbosity);
                    if (!dir.delete() && !quiet) {
                        throw new BuildException(""Unable to delete directory "" + dir.getAbsolutePath());
                    } else {
                        dirCount++;
                    }
                }
            }
            if (dirCount > 0) {
                log(""Deleted "" + dirCount + "" director"" + 
                    (dirCount==1 ? ""y"" : ""ies"") + 
                    "" from "" + d.getAbsolutePath());
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Deltree,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
/**
 *
 *
 * @author duncan@x180.com
 *
 * @deprecated The deltree task is deprecated.  Use delete instead.
 */
public class Deltree extends Task {
    private File dir;
    public void setDir(File dir) {
	this.dir = dir;
    }
    public void execute() throws BuildException {
        log(""DEPRECATED - The deltree task is deprecated.  Use delete instead."");
        if (dir == null) {
            throw new BuildException(""dir attribute must be set!"", location);
        } 
	if (dir.exists()) {
	    if (!dir.isDirectory()) {
		if (!dir.delete()) {
        	    throw new BuildException(""Unable to delete directory "" 
                                             + dir.getAbsolutePath(),
                                             location);
	        }
		return;
		// String msg = ""Given dir: "" + dir.getAbsolutePath() +
		// "" is not a dir"";
		// throw new BuildException(msg);
	    }
            log(""Deleting: "" + dir.getAbsolutePath());
            try {
                removeDir(dir);
            } catch (IOException ioe) {
                String msg = ""Unable to delete "" + dir.getAbsolutePath();
                throw new BuildException(msg, location);
            }
        }
    }
    private void removeDir(File dir) throws IOException {
        // check to make sure that the given dir isn't a symlink
        // the comparison of absolute path and canonical path
        // catches this
	//        if (dir.getCanonicalPath().equals(dir.getAbsolutePath())) {
	// (costin) It will not work if /home/costin is symlink to /da0/home/costin ( taz
	// for example )
	String[] list = dir.list();
	for (int i = 0; i < list.length; i++) {
	    String s = list[i];
	    File f = new File(dir, s);
	    if (f.isDirectory()) {
		removeDir(f);
	    } else {
		if (!f.delete()) {
        	    throw new BuildException(""Unable to delete file "" + f.getAbsolutePath());
	        }
	    }
	}
        if (!dir.delete()) {
	    throw new BuildException(""Unable to delete directory "" + dir.getAbsolutePath());
	}
    }
}
"
org.apache.tools.ant.taskdefs.Echo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.EnumeratedAttribute;
import java.io.*;
/**
 * Echo
 *
 * @author costin@dnt.ro
 */
public class Echo extends Task {
    protected String message = """"; // required
    protected File file = null;
    protected boolean append = false;
    // by default, messages are always displayed
    protected int logLevel = Project.MSG_WARN;   
    /**
     * Does the work.
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        if (file == null) {
            log(message, logLevel);
        } else {
            FileWriter out = null;
            try {
                out = new FileWriter(file.getAbsolutePath(), append);
                out.write(message, 0, message.length());
            } catch (IOException ioe) {
                throw new BuildException(ioe, location);
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (IOException ioex) {}
                }
            }
        }
    }
    /**
     * Sets the message variable.
     *
     * @param msg Sets the value for the message variable.
     */
    public void setMessage(String msg) {
        this.message = msg;
    }
    /**
     * Sets the file attribute.
     */
    public void setFile(File file) {
        this.file = file;
    }
    /**
     * Shall we append to an existing file?
     */
    public void setAppend(boolean append) {
        this.append = append;
    }
    /**
     * Set a multiline message.
     */
    public void addText(String msg) {
        message += 
            ProjectHelper.replaceProperties(project, msg, project.getProperties());
    }
    /**
     * Set the logging level to one of
     * <ul>
     *  <li>error</li>
     *  <li>warning</li>
     *  <li>info</li>
     *  <li>verbose</li>
     *  <li>debug</li>
     * <ul>
     * <p>The default is &quot;warning&quot; to ensure that messages are
     * displayed by default when using the -quiet command line option.</p>
     */
    public void setLevel(EchoLevel echoLevel) {
        String option = echoLevel.getValue();
        if (option.equals(""error"")) {
            logLevel = Project.MSG_ERR;
        } else if (option.equals(""warning"")) {
            logLevel = Project.MSG_WARN;
        } else if (option.equals(""info"")) {
            logLevel = Project.MSG_INFO;
        } else if (option.equals(""verbose"")) {
            logLevel = Project.MSG_VERBOSE;
        } else {
            // must be ""debug""
            logLevel = Project.MSG_DEBUG;
        }
    }
    public static class EchoLevel extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[] {""error"", ""warning"", ""info"", ""verbose"", ""debug""};
        }
    }
}
"
org.apache.tools.ant.taskdefs.Exec,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
/**
 * Executes a given command if the os platform is appropriate.
 *
 * @author duncan@x180.com
 * @author rubys@us.ibm.com
 *
 * @deprected Instead of using this class, please extend ExecTask or
 * delegate to Execute.  
 */
public class Exec extends Task {
    private String os;
    private String out;
    private File dir;
    private String command;
    protected PrintWriter fos = null;
    private boolean failOnError = false;
    private static final int BUFFER_SIZE = 512;
    public void execute() throws BuildException {
        run(command);
    }
    protected int run(String command) throws BuildException {
        int err = -1; // assume the worst
        // test if os match
        String myos = System.getProperty(""os.name"");
        log(""Myos = "" + myos, Project.MSG_VERBOSE);
        if ((os != null) && (os.indexOf(myos) < 0)){
            // this command will be executed only on the specified OS
            log(""Not found in "" + os, Project.MSG_VERBOSE);
            return 0;
        }
        // default directory to the project's base directory
        if (dir == null) dir = project.getBaseDir();
        if (myos.toLowerCase().indexOf(""windows"") >= 0) {
            if (!dir.equals(project.resolveFile("".""))) {
                if (myos.toLowerCase().indexOf(""nt"") >= 0) {
                    command = ""cmd /c cd "" + dir + "" && "" + command;
                }
                else {
                    String ant = project.getProperty(""ant.home"");
                    if (ant == null) {
                        throw new BuildException(""Property 'ant.home' not found"", location);
                    }
                    String antRun = project.resolveFile(ant + ""/bin/antRun.bat"").toString();
                    command = antRun + "" "" + dir + "" "" + command;
                }
            }
        } else {
            String ant = project.getProperty(""ant.home"");
            if (ant == null) throw new BuildException(""Property 'ant.home' not found"", location);
            String antRun = project.resolveFile(ant + ""/bin/antRun"").toString();
            command = antRun + "" "" + dir + "" "" + command;
        }
        try {
            // show the command
            log(command, Project.MSG_VERBOSE);
            // exec command on system runtime
            Process proc = Runtime.getRuntime().exec(command);
            if( out!=null )  {
                fos=new PrintWriter( new FileWriter( out ) );
                log(""Output redirected to "" + out, Project.MSG_VERBOSE);
            }
            // copy input and error to the output stream
            StreamPumper inputPumper =
                new StreamPumper(proc.getInputStream(), Project.MSG_INFO, this);
            StreamPumper errorPumper =
                new StreamPumper(proc.getErrorStream(), Project.MSG_WARN, this);
            // starts pumping away the generated output/error
            inputPumper.start();
            errorPumper.start();
            // Wait for everything to finish
            proc.waitFor();
            inputPumper.join();
            errorPumper.join();
            proc.destroy();
            // close the output file if required
            logFlush();
            // check its exit value
            err = proc.exitValue();
            if (err != 0) {
                if (failOnError) {
                    throw new BuildException(""Exec returned: ""+err, location);
                } else {
                    log(""Result: "" + err, Project.MSG_ERR);
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(""Error exec: "" + command, ioe, location);
        } catch (InterruptedException ex) {}
        return err;
    }
    public void setDir(String d) {
        this.dir = project.resolveFile(d);
    }
    public void setOs(String os) {
        this.os = os;
    }
    public void setCommand(String command) {
        this.command = command;
    }
    public void setOutput(String out) {
        this.out = out;
    }
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    protected void outputLog(String line, int messageLevel) {
        if (fos == null) {
            log(line, messageLevel); 
        } else {
            fos.println(line);
        }
    };
    protected void logFlush() {
        if (fos != null) fos.close();
    }
    // Inner class for continually pumping the input stream during
    // Process's runtime.
    class StreamPumper extends Thread {
        private BufferedReader din;
        private int messageLevel;
        private boolean endOfStream = false;
        private int SLEEP_TIME = 5;
        private Exec parent;
        public StreamPumper(InputStream is, int messageLevel, Exec parent) {
            this.din = new BufferedReader(new InputStreamReader(is));
            this.messageLevel = messageLevel;
            this.parent = parent;
        }
        public void pumpStream()
            throws IOException
        {
            byte[] buf = new byte[BUFFER_SIZE];
            if (!endOfStream) {
                String line = din.readLine();
                if (line != null) {
                    outputLog(line, messageLevel);
                } else {
                    endOfStream = true;
                }
            }
        }
        public void run() {
            try {
                try {
                    while (!endOfStream) {
                        pumpStream();
                        sleep(SLEEP_TIME);
                    }
                } catch (InterruptedException ie) {}
                din.close();
            } catch (IOException ioe) {}
        }
    }
}
"
org.apache.tools.ant.taskdefs.ExecTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
/**
 * Executes a given command if the os platform is appropriate.
 *
 * @author duncan@x180.com
 * @author rubys@us.ibm.com
 * @author thomas.haas@softwired-inc.com
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 * @author <a href=""mailto:mariusz@rakiura.org"">Mariusz Nowostawski</a> 
 */
public class ExecTask extends Task {
    private String os;
    private File out;
    private File dir;
    protected boolean failOnError = false;
    protected boolean newEnvironment = false;
    private Integer timeout = null;
    private Environment env = new Environment();
    protected Commandline cmdl = new Commandline();
    private FileOutputStream fos = null;
    /**
     * Timeout in milliseconds after which the process will be killed.
     */
    public void setTimeout(Integer value) {
        timeout = value;
    }
    /**
     * The command to execute.
     */
    public void setExecutable(String value) {
        cmdl.setExecutable(value);
    }
    /**
     * The working directory of the process
     */
    public void setDir(File d) {
        this.dir = d;
    }
    /**
     * Only execute the process if <code>os.name</code> is included in this string.
     */
    public void setOs(String os) {
        this.os = os;
    }
    /**
     * The full commandline to execute, executable + arguments.
     */
    public void setCommand(Commandline cmdl) {
        log(""The command attribute is deprecated. "" +
            ""Please use the executable attribute and nested arg elements."",
            Project.MSG_WARN);
        this.cmdl = cmdl;
    }
    /**
     * File the output of the process is redirected to.
     */
    public void setOutput(File out) {
        this.out = out;
    }
    /**
     * Throw a BuildException if process returns non 0.
     */
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    /**
     * Use a completely new environment
     */
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }
    /**
     * Add a nested env element - an environment variable.
     */
    public void addEnv(Environment.Variable var) {
        env.addVariable(var);
    }
    /**
     * Add a nested arg element - a command line argument.
     */
    public Commandline.Argument createArg() {
        return cmdl.createArgument();
    }
    /**
     * Do the work.
     */
    public void execute() throws BuildException {
        checkConfiguration();
        if (isValidOs()) {
            runExec(prepareExec());
        }
    }
    /**
     * Has the user set all necessary attributes?
     */
    protected void checkConfiguration() throws BuildException {
        if (cmdl.getExecutable() == null) {
            throw new BuildException(""no executable specified"", location);
        }
        if (dir != null && !dir.exists()) {
        	throw new BuildException(""The directory you specified does not exist"");
        }
        if (dir != null && !dir.isDirectory()) {
        	throw new BuildException(""The directory you specified is not a directory"");
        }
    }
    /**
     * Is this the OS the user wanted?
     */
    protected boolean isValidOs() {
        // test if os match
        String myos = System.getProperty(""os.name"");
        log(""Myos = "" + myos, Project.MSG_VERBOSE);
        if ((os != null) && (os.indexOf(myos) < 0)){
            // this command will be executed only on the specified OS
            log(""Not found in "" + os, Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }
    /**
     * Create an Execute instance with the correct working directory set.
     */
    protected Execute prepareExec() throws BuildException {
        // default directory to the project's base directory
        if (dir == null) dir = project.getBaseDir();
        // show the command
        log(cmdl.toString(), Project.MSG_VERBOSE);
        Execute exe = new Execute(createHandler(), createWatchdog());
        exe.setAntRun(project);
        exe.setWorkingDirectory(dir);
        String[] environment = env.getVariables();
        if (environment != null) {
            for (int i=0; i<environment.length; i++) {
                log(""Setting environment variable: ""+environment[i],
                    Project.MSG_VERBOSE);
            }
        }
        exe.setNewenvironment(newEnvironment);
        exe.setEnvironment(environment);
        return exe;
    }
    /**
     * Run the command using the given Execute instance.
     */
    protected void runExec(Execute exe) throws BuildException {
        int err = -1; // assume the worst
        try {
            exe.setCommandline(cmdl.getCommandline());
            err = exe.execute();
            if (err != 0) {
                if (failOnError) {
                    throw new BuildException(""Exec returned: ""+err, location);
                } else {
                    log(""Result: "" + err, Project.MSG_ERR);
                }
            }
        } catch (IOException e) {
            throw new BuildException(""Execute failed: "" + e, e, location);
        } finally {
            // close the output file if required
            logFlush();
        }
    }
    /**
     * Create the StreamHandler to use with our Execute instance.
     */
    protected ExecuteStreamHandler createHandler() throws BuildException {
        if(out!=null)  {
            try {
                fos = new FileOutputStream(out);
                log(""Output redirected to "" + out, Project.MSG_VERBOSE);
                return new PumpStreamHandler(fos);
            } catch (FileNotFoundException fne) {
                throw new BuildException(""Cannot write to ""+out, fne, location);
            } catch (IOException ioe) {
                throw new BuildException(""Cannot write to ""+out, ioe, location);
            }
        } else {
            return new LogStreamHandler(this,
                                        Project.MSG_INFO, Project.MSG_WARN);
        }
    }
    /**
     * Create the Watchdog to kill a runaway process.
     */
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        if (timeout == null) return null;
        return new ExecuteWatchdog(timeout.intValue());
    }
    /**
     * Flush the output stream - if there is one.
     */
    protected void logFlush() {
        try {
            if (fos != null) fos.close();
        } catch (IOException io) {}
    }
}
"
org.apache.tools.ant.taskdefs.Execute,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Commandline;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Vector;
/**
 * Runs an external program.
 *
 * @author thomas.haas@softwired-inc.com
 */
public class Execute {
    /** Invalid exit code. **/
    public final static int INVALID = Integer.MAX_VALUE;
    private String[] cmdl = null;
    private String[] env = null;
    private int exitValue = INVALID;
    private ExecuteStreamHandler streamHandler;
    private ExecuteWatchdog watchdog;
    private File workingDirectory = null;
    private Project project = null;
    private boolean newEnvironment = false;
    private static String antWorkingDirectory = System.getProperty(""user.dir"");
    private static CommandLauncher launcher = createCommandLauncher();
    private static Vector procEnvironment = null;
    /** 
     * Builds a command launcher for the OS and JVM we are running under
     */
    private static CommandLauncher createCommandLauncher()
    {
        // Try using a JDK 1.3 launcher
        try {
            return new Java13CommandLauncher();
        }
        catch ( NoSuchMethodException exc ) {
            // Ignore and keep try
        }
        String osname = System.getProperty(""os.name"").toLowerCase();
        if ( osname.indexOf(""mac os"") >= 0 ) {
            // Mac
            return new MacCommandLauncher(new CommandLauncher());
        }
        else if ( osname.indexOf(""os/2"") >= 0 ) {
            // OS/2 - use same mechanism as Windows 2000
            return new WinNTCommandLauncher(new CommandLauncher());
        }
        else if ( osname.indexOf(""windows"") >= 0 ) {
            // Windows.  Need to determine which JDK we're running in
            CommandLauncher baseLauncher;
            if ( System.getProperty(""java.version"").startsWith(""1.1"") ) {
                // JDK 1.1
                baseLauncher = new Java11CommandLauncher();
            }
            else {
                // JDK 1.2
                baseLauncher = new CommandLauncher();
            }
            // Determine if we're running under 2000/NT or 98/95
            if ( osname.indexOf(""nt"") >= 0 || osname.indexOf(""2000"") >= 0 ) {
                // Windows 2000/NT
                return new WinNTCommandLauncher(baseLauncher);
            }
            else {
                // Windows 98/95 - need to use an auxiliary script
                return new ScriptCommandLauncher(""bin/antRun.bat"", baseLauncher);
            }
        }
        else {
            // Generic
            return new ScriptCommandLauncher(""bin/antRun"", new CommandLauncher());
        }
    }
    /**
     * Find the list of environment variables for this process.
     */
    public static synchronized Vector getProcEnvironment() {
        if (procEnvironment != null) return procEnvironment;
        procEnvironment = new Vector();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Execute exe = new Execute(new PumpStreamHandler(out));
            exe.setCommandline(getProcEnvCommand());
            // Make sure we do not recurse forever
            exe.setNewenvironment(true);
            int retval = exe.execute();
            if ( retval != 0 ) {
                // Just try to use what we got
            }
            BufferedReader in = 
                new BufferedReader(new StringReader(out.toString()));
            String line;
            while ((line = in.readLine()) != null) {
                procEnvironment.addElement(line);
            }
        } 
        catch (java.io.IOException exc) {
            exc.printStackTrace();
            // Just try to see how much we got
        }
        return procEnvironment;
    }
    private static String[] getProcEnvCommand() {
        String osname = System.getProperty(""os.name"").toLowerCase();
        if ( osname.indexOf(""mac os"") >= 0 ) {
            // Mac
            // TODO: I have no idea how to get it, someone must fix it
            String[] cmd = null;
            return cmd;
        }
        else if ( osname.indexOf(""os/2"") >= 0 ) {
            // OS/2 - use same mechanism as Windows 2000
            // Not sure
            String[] cmd = {""cmd"", ""/c"", ""set"" };
            return cmd;
        }
        else if ( osname.indexOf(""indows"") >= 0 ) {
            // Determine if we're running under 2000/NT or 98/95
            if ( osname.indexOf(""nt"") >= 0 || osname.indexOf(""2000"") >= 0 ) {
                // Windows 2000/NT
                String[] cmd = {""cmd"", ""/c"", ""set"" };
                return cmd;
            }
            else {
                // Windows 98/95 - need to use an auxiliary script
                String[] cmd = {""command.com"", ""/c"", ""set"" };
                return cmd;
            }
        }
        else {
            // Generic UNIX
            // Alternatively one could use: /bin/sh -c env
            String[] cmd = {""/usr/bin/env""};
            return cmd;
        }
    }
    /**
     * Creates a new execute object using <code>PumpStreamHandler</code> for
     * stream handling.
     */
    public Execute() {
        this(new PumpStreamHandler(), null);
    }
    /**
     * Creates a new execute object.
     *
     * @param streamHandler the stream handler used to handle the input and
     *        output streams of the subprocess.
     */
    public Execute(ExecuteStreamHandler streamHandler) {
        this(streamHandler, null);
    }
    /**
     * Creates a new execute object.
     *
     * @param streamHandler the stream handler used to handle the input and
     *        output streams of the subprocess.
     * @param watchdog a watchdog for the subprocess or <code>null</code> to
     *        to disable a timeout for the subprocess.
     */
    public Execute(ExecuteStreamHandler streamHandler, ExecuteWatchdog watchdog) {
        this.streamHandler = streamHandler;
        this.watchdog = watchdog;
    }
    /**
     * Returns the commandline used to create a subprocess.
     *
     * @return the commandline used to create a subprocess
     */
    public String[] getCommandline() {
        return cmdl;
    }
    /**
     * Sets the commandline of the subprocess to launch.
     *
     * @param commandline the commandline of the subprocess to launch
     */
    public void setCommandline(String[] commandline) {
        cmdl = commandline;
    }
    /**
     * Set whether to propagate the default environment or not.
     *
     * @param newenv whether to propagate the process environment.
     */
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }
    /**
     * Returns the environment used to create a subprocess.
     *
     * @return the environment used to create a subprocess
     */
    public String[] getEnvironment() {
        if (env == null || newEnvironment) return env;
        return patchEnvironment();
    }
    /**
     * Sets the environment variables for the subprocess to launch.
     *
     * @param commandline array of Strings, each element of which has
     * an environment variable settings in format <em>key=value</em> 
     */
    public void setEnvironment(String[] env) {
        this.env = env;
    }
    /**
     * Sets the working directory of the process to execute.
     *
     * <p>This is emulated using the antRun scripts unless the OS is
     * Windows NT in which case a cmd.exe is spawned,
     * or MRJ and setting user.dir works, or JDK 1.3 and there is
     * official support in java.lang.Runtime.
     *
     * @param wd the working directory of the process.
     */
    public void setWorkingDirectory(File wd) {
        if (wd == null || wd.getAbsolutePath().equals(antWorkingDirectory))
            workingDirectory = null;
        else
            workingDirectory = wd;
    }
    /**
     * Set the name of the antRun script using the project's value.
     *
     * @param project the current project.
     */
    public void setAntRun(Project project) throws BuildException {
        this.project = project;
    }
    /**
     * Runs a process defined by the command line and returns its exit status.
     *
     * @return the exit status of the subprocess or <code>INVALID</code>
     * @exception java.io.IOExcpetion The exception is thrown, if launching
     *            of the subprocess failed
     */
    public int execute() throws IOException {
        final Process process = launcher.exec(project, getCommandline(), getEnvironment(), workingDirectory);
        try {
            streamHandler.setProcessInputStream(process.getOutputStream());
            streamHandler.setProcessOutputStream(process.getInputStream());
            streamHandler.setProcessErrorStream(process.getErrorStream());
        } catch (IOException e) {
            process.destroy();
            throw e;
        }
        streamHandler.start();
        if (watchdog != null) watchdog.start(process);
        waitFor(process);
        if (watchdog != null) watchdog.stop();
        streamHandler.stop();
        if (watchdog != null) watchdog.checkException();
        return getExitValue();
    }
    protected void waitFor(Process process) {
        try {
            process.waitFor();
            setExitValue(process.exitValue());
        } catch (InterruptedException e) {}
    }
    protected void setExitValue(int value) {
        exitValue = value;
    }
    public int getExitValue() {
        return exitValue;
    }
    /**
     * Patch the current environment with the new values from the user.
     * @return the patched environment
     */
    private String[] patchEnvironment() {
        Vector osEnv = (Vector) getProcEnvironment().clone();
        for (int i = 0; i < env.length; i++) {
            int pos = env[i].indexOf('=');
            // Get key including ""=""
            String key = env[i].substring(0, pos+1);
            int size = osEnv.size();
            for (int j = 0; j < size; j++) {
                if (((String)osEnv.elementAt(j)).startsWith(key)) {
                    osEnv.removeElementAt(j);
                    break;
                }
            }
            osEnv.addElement(env[i]);
        }
        String[] result = new String[osEnv.size()];
        osEnv.copyInto(result);
        return result;
    }
    /**
     * A utility method that runs an external command.  Writes the output and
     * error streams of the command to the project log.
     *
     * @param task      The task that the command is part of.  Used for logging
     * @param cmdline   The command to execute.
     *
     * @throws BuildException if the command does not return 0.
     */
    public static void runCommand(Task task, String[] cmdline) throws BuildException
    {
        try {
            task.log(Commandline.toString(cmdline), Project.MSG_VERBOSE);
            Execute exe = new Execute(new LogStreamHandler(task, 
                                                           Project.MSG_INFO,
                                                           Project.MSG_ERR));
            exe.setAntRun(task.getProject());
            exe.setCommandline(cmdline);
            int retval = exe.execute();
            if ( retval != 0 ) {
                throw new BuildException(cmdline[0] + "" failed with return code "" + retval, task.getLocation());
            }
        } 
        catch (java.io.IOException exc) {
            throw new BuildException(""Could not launch "" + cmdline[0] + "": "" + exc, task.getLocation());
        }
    }
    /**
     * A command launcher for a particular JVM/OS platform.  This class is
     * a general purpose command launcher which can only launch commands in
     * the current working directory.
     */
    private static class CommandLauncher
    {
        /** 
         * Launches the given command in a new process.
         *
         * @param project       The project that the command is part of
         * @param cmd           The command to execute
         * @param env           The environment for the new process.  If null,
         *                      the environment of the current proccess is used.
         */
        public Process exec(Project project, String[] cmd, String[] env) throws IOException
        {
            if (project != null) {
                project.log(""Execute:CommandLauncher: "" +
                            Commandline.toString(cmd), Project.MSG_DEBUG);
            }                            
            return Runtime.getRuntime().exec(cmd, env);
        }
        /** 
         * Launches the given command in a new process, in the given working
         * directory.
         *
         * @param project       The project that the command is part of
         * @param cmd           The command to execute
         * @param env           The environment for the new process.  If null,
         *                      the environment of the current proccess is used.
         * @param workingDir    The directory to start the command in.  If null,
         *                      the current directory is used
         */
        public Process exec(Project project, String[] cmd, String[] env, File workingDir) throws IOException
        {
            if ( workingDir == null ) {
                return exec(project, cmd, env);
            }
            throw new IOException(""Cannot execute a process in different directory under this JVM"");
        }
    }
    /**
     * A command launcher for JDK/JRE 1.1 under Windows.  Fixes quoting problems
     * in Runtime.exec().  Can only launch commands in the current working
     * directory
     */
    private static class Java11CommandLauncher extends CommandLauncher
    {
        /**
         * Launches the given command in a new process.  Needs to quote
         * arguments
         */
        public Process exec(Project project, String[] cmd, String[] env) throws IOException 
        {
            // Need to quote arguments with spaces, and to escape quote characters
            String[] newcmd = new String[cmd.length];
            for ( int i = 0; i < cmd.length; i++ ) {
                newcmd[i] = Commandline.quoteArgument(cmd[i]);
            }
            if (project != null) {
                project.log(""Execute:Java11CommandLauncher: "" +
                            Commandline.toString(newcmd), Project.MSG_DEBUG);
            }                            
            return Runtime.getRuntime().exec(newcmd, env);
        }
    }
    /**
     * A command launcher for JDK/JRE 1.3 (and higher).  Uses the built-in
     * Runtime.exec() command
     */
    private static class Java13CommandLauncher extends CommandLauncher
    {
        public Java13CommandLauncher() throws NoSuchMethodException
        {
            // Locate method Runtime.exec(String[] cmdarray, String[] envp, File dir)
            _execWithCWD = Runtime.class.getMethod(""exec"", new Class[] {String[].class, String[].class, File.class});
        }
        /** 
         * Launches the given command in a new process, in the given working
         * directory
         */
        public Process exec(Project project, String[] cmd, String[] env, File workingDir) 
            throws IOException
        {
            try {
                if (project != null) {
                    project.log(""Execute:Java13CommandLauncher: "" +
                                Commandline.toString(cmd), Project.MSG_DEBUG);
                }                                
                Object[] arguments = { cmd, env, workingDir };
                return (Process)_execWithCWD.invoke(Runtime.getRuntime(), arguments);
            } 
            catch ( InvocationTargetException exc ) {
                Throwable realexc = exc.getTargetException();
                if ( realexc instanceof ThreadDeath ) {
                    throw (ThreadDeath)realexc;
                } 
                else if ( realexc instanceof IOException ) {
                    throw (IOException)realexc;
                } 
                else {
                    throw new IOException(realexc.getMessage());
                }
            } 
            catch ( Exception exc ) {
                // IllegalAccess, IllegalArgument, ClassCast
                throw new IOException(exc.getMessage());
            }
        }
        private Method _execWithCWD;
    }
    /**
     * A command launcher that proxies another command launcher.  
     *
     * Sub-classes override exec(args, env, workdir)
     */
    private static class CommandLauncherProxy extends CommandLauncher
    {
        CommandLauncherProxy(CommandLauncher launcher)
        {
            _launcher = launcher;
        }
        /** 
         * Launches the given command in a new process.  Delegates this
         * method to the proxied launcher
         */
        public Process exec(Project project, String[] cmd, String[] env) throws IOException
        {
            return _launcher.exec(project, cmd, env);
        }
        private CommandLauncher _launcher;
    }
    /**
     * A command launcher for Windows 2000/NT that uses 'cmd.exe' when
     * launching commands in directories other than the current working
     * directory.
     */
    private static class WinNTCommandLauncher extends CommandLauncherProxy
    {
        WinNTCommandLauncher(CommandLauncher launcher)
        {
            super(launcher);
        }
        /** 
         * Launches the given command in a new process, in the given working
         * directory.
         */
        public Process exec(Project project, String[] cmd, String[] env, File workingDir) throws IOException
        {
            if ( workingDir == null ) {
                return exec(project, cmd, env);
            }
            // Use cmd.exe to change to the specified directory before running
            // the command
            final int preCmdLength = 6;
            String[] newcmd = new String[cmd.length + preCmdLength];
            newcmd[0] = ""cmd"";
            newcmd[1] = ""/c"";
            newcmd[2] = ""cd"";
            newcmd[3] = ""/d"";
            newcmd[4] = workingDir.getAbsolutePath();
            newcmd[5] = ""&&"";
            System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);
            return exec(project, newcmd, env);
        }
    }
    /**
     * A command launcher for Mac that uses a dodgy mechanism to change
     * working directory before launching commands.
     */
    private static class MacCommandLauncher extends CommandLauncherProxy
    {
        MacCommandLauncher(CommandLauncher launcher)
        {
            super(launcher);
        }
        /** 
         * Launches the given command in a new process, in the given working
         * directory
         */
        public Process exec(Project project, String[] cmd, String[] env, File workingDir) throws IOException
        {
            if ( workingDir == null ) {
                return exec(project, cmd, env);
            }
            System.getProperties().put(""user.dir"", workingDir.getAbsolutePath());
            try {
                return exec(project, cmd, env);
            } 
            finally {
                System.getProperties().put(""user.dir"", antWorkingDirectory);
            }
        }
    }
    /**
     * A command launcher that uses an auxiliary script to launch commands
     * in directories other than the current working directory.
     */
    private static class ScriptCommandLauncher extends CommandLauncherProxy
    {
        ScriptCommandLauncher(String script, CommandLauncher launcher)
        {
            super(launcher);
            _script = script;
        }
        /** 
         * Launches the given command in a new process, in the given working
         * directory
         */
        public Process exec(Project project, String[] cmd, String[] env, File workingDir) throws IOException
        {
            if ( workingDir == null ) {
                return exec(project, cmd, env);
            }
            // Locate the auxiliary script
            if ( project == null ) {
                throw new IOException(""Cannot locate antRun script: No project provided"");
            }
            String antHome = project.getProperty(""ant.home"");
            if ( antHome == null ) {
                throw new IOException(""Cannot locate antRun script: Property 'ant.home' not found"");
            }
            String antRun = project.resolveFile(antHome + File.separator + _script).toString();
            // Build the command
            String[] newcmd = new String[cmd.length + 2];
            newcmd[0] = antRun;
            newcmd[1] = workingDir.getAbsolutePath();
            System.arraycopy(cmd, 0, newcmd, 2, cmd.length);
            return exec(project, newcmd, env);
        }
        private String _script;
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteJava,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.io.*;
/*
 *
 * @author thomas.haas@softwired-inc.com
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class ExecuteJava {
    private Commandline javaCommand = null;
    private Path classpath = null;
    private CommandlineJava.SysProperties sysProperties = null;
    private PrintStream out;
    public void setJavaCommand(Commandline javaCommand) {
        this.javaCommand = javaCommand;
    }
    public void setClasspath(Path p) {
        classpath = p;
    }
    public void setSystemProperties(CommandlineJava.SysProperties s) {
        sysProperties = s;
    }
    /**
     * All output (System.out as well as System.err) will be written
     * to this Stream.
     */
    public void setOutput(PrintStream out) {
        this.out = out;
    }
    public void execute(Project project) throws BuildException{
        PrintStream sOut = System.out;
        PrintStream sErr = System.err;
        final String classname = javaCommand.getExecutable();
        final Object[] argument = { javaCommand.getArguments() };
        try {
            if (sysProperties != null) {
                sysProperties.setSystem();
            }
            if (out != null) {
                System.setErr(out);
                System.setOut(out);
            }
            final Class[] param = { Class.forName(""[Ljava.lang.String;"") };
            Class target = null;
            if (classpath == null) {
                target = Class.forName(classname);
            } else {
                AntClassLoader loader = new AntClassLoader(project, classpath, false);
                loader.setIsolated(true);
                target = loader.forceLoadClass(classname);
            }
            final Method main = target.getMethod(""main"", param);
            main.invoke(null, argument);
        } catch (NullPointerException e) {
            throw new BuildException(""Could not find main() method in "" + classname);
        } catch (ClassNotFoundException e) {
            throw new BuildException(""Could not find "" + classname + "". Make sure you have it in your classpath"");
        } catch (InvocationTargetException e) {
            Throwable t = e.getTargetException();
            if (!(t instanceof SecurityException)) {
                throw new BuildException(t);
            }
            // else ignore because the security exception is thrown
            // if the invoked application tried to call System.exit()
        } catch (Exception e) {
            throw new BuildException(e);
        } finally {
            if (sysProperties != null) {
                sysProperties.restoreSystem();
            }
            if (out != null) {
                System.setOut(sOut);
                System.setErr(sErr);
                out.close();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteOn,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.util.Vector;
import java.io.File;
import java.io.IOException;
/**
 * Executes a given command, supplying a set of files as arguments. 
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:mariusz@rakiura.org"">Mariusz Nowostawski</a> 
 */
public class ExecuteOn extends ExecTask {
    protected Vector filesets = new Vector();
    private boolean parallel = false;
    protected String type = ""file"";
    protected Commandline.Marker srcFilePos = null;
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * Shall the command work on all specified files in parallel?
     */
    public void setParallel(boolean parallel) {
        this.parallel = parallel;
    }
    /**
     * Shall the command work only on files, directories or both?
     */
    public void setType(FileDirBoth type) {
        this.type = type.getValue();
    }
    /**
     * Marker that indicates where the name of the source file should
     * be put on the command line.
     */
    public Commandline.Marker createSrcfile() {
        if (srcFilePos != null) {
            throw new BuildException(taskType + "" doesn\'t support multiple srcfile elements."",
                                     location);
        }
        srcFilePos = cmdl.createMarker();
        return srcFilePos;
    }
    protected void checkConfiguration() {
        super.checkConfiguration();
        if (filesets.size() == 0) {
            throw new BuildException(""no filesets specified"", location);
        }
    }
    protected void runExec(Execute exe) throws BuildException {
        try {
            for (int i=0; i<filesets.size(); i++) {
                Vector v = new Vector();
                FileSet fs = (FileSet) filesets.elementAt(i);
                File base = fs.getDir(project);
                DirectoryScanner ds = fs.getDirectoryScanner(project);
                if (!""dir"".equals(type)) {
                    String[] s = getFiles(base, ds);
                    for (int j=0; j<s.length; j++) {
                        v.addElement(s[j]);
                    }
                }
                if (!""file"".equals(type)) {
                    String[] s = getDirs(base, ds);;
                    for (int j=0; j<s.length; j++) {
                        v.addElement(s[j]);
                    }
                }
                String[] s = new String[v.size()];
                v.copyInto(s);
                int err = -1;
                if (parallel) {
                    String[] command = getCommandline(s, base);
                    log(""Executing "" + Commandline.toString(command), 
                        Project.MSG_VERBOSE);
                    exe.setCommandline(command);
                    err = exe.execute();
                    if (err != 0) {
                        if (failOnError) {
                            throw new BuildException(""Exec returned: ""+err, 
                                                     location);
                        } else {
                            log(""Result: "" + err, Project.MSG_ERR);
                        }
                    }
                } else {
                    for (int j=0; j<s.length; j++) {
                        String[] command = getCommandline(s[j], base);
                        log(""Executing "" + Commandline.toString(command), 
                            Project.MSG_VERBOSE);
                        exe.setCommandline(command);
                        err = exe.execute();
                        if (err != 0) {
                            if (failOnError) {
                                throw new BuildException(""Exec returned: ""+err, 
                                                         location);
                            } else {
                                log(""Result: "" + err, Project.MSG_ERR);
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            throw new BuildException(""Execute failed: "" + e, e, location);
        } finally {
            // close the output file if required
            logFlush();
        }
    }
    /**
     * Construct the command line for parallel execution.
     *
     * @param srcFiles The filenames to add to the commandline
     * @param baseDir filenames are relative to this dir
     */
    protected String[] getCommandline(String[] srcFiles, File baseDir) {
        String[] orig = cmdl.getCommandline();
        String[] result = new String[orig.length+srcFiles.length];
        int index = orig.length;
        if (srcFilePos != null) {
            index = srcFilePos.getPosition();
        }
        System.arraycopy(orig, 0, result, 0, index);
        for (int i=0; i < srcFiles.length; i++) {
            result[index+i] = (new File(baseDir, srcFiles[i])).getAbsolutePath();
        }
        System.arraycopy(orig, index, result, index+srcFiles.length, 
                         orig.length-index);
        return result;
    }
    /**
     * Construct the command line for serial execution.
     *
     * @param srcFile The filename to add to the commandline
     * @param baseDir filename is relative to this dir
     */
    protected String[] getCommandline(String srcFile, File baseDir) {
        return getCommandline(new String[] {srcFile}, baseDir);
    }
    /**
     * Return the list of files from this DirectoryScanner that should
     * be included on the command line.
     */
    protected String[] getFiles(File basedir, DirectoryScanner ds) {
        return ds.getIncludedFiles();
    }
    /**
     * Return the list of Directories from this DirectoryScanner that
     * should be included on the command line.
     */
    protected String[] getDirs(File basedir, DirectoryScanner ds) {
        return ds.getIncludedDirectories();
    }
    /**
     * Enumerated attribute with the values ""file"", ""dir"" and ""both""
     * for the type attribute.  
     */
    public static class FileDirBoth extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[] {""file"", ""dir"", ""both""};
        }
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteStreamHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
/**
 * Used by <code>Execute</code> to handle input and output stream of
 * subprocesses.
 *
 * @author thomas.haas@softwired-inc.com
 */
public interface ExecuteStreamHandler {
    /**
     * Install a handler for the input stream of the subprocess.
     *
     * @param os output stream to write to the standard input stream of the
     *           subprocess
     */
    public void setProcessInputStream(OutputStream os) throws IOException;
    /**
     * Install a handler for the error stream of the subprocess.
     *
     * @param is input stream to read from the error stream from the subprocess
     */
    public void setProcessErrorStream(InputStream is) throws IOException;
    /**
     * Install a handler for the output stream of the subprocess.
     *
     * @param is input stream to read from the error stream from the subprocess
     */
    public void setProcessOutputStream(InputStream is) throws IOException;
    /**
     * Start handling of the streams.
     */
    public void start() throws IOException;
    /**
     * Stop handling of the streams - will not be restarted.
     */
    public void stop();
}
"
org.apache.tools.ant.taskdefs.ExecuteWatchdog,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
/**
 * Destroys a process running for too long.
 * For example:
 * <pre>
 * ExecuteWatchdog watchdog = new ExecuteWatchdog(30000);
 * Execute exec = new Execute(myloghandler, watchdog);
 * exec.setCommandLine(mycmdline);
 * int exitvalue = exec.execute();
 * if (exitvalue != SUCCESS && watchdog.killedProcess()){
 *              // it was killed on purpose by the watchdog
 * }
 * </pre>
 * @author thomas.haas@softwired-inc.com
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 * @see Execute
 */
public class ExecuteWatchdog implements Runnable {
    /** the process to execute and watch for duration */
    private Process process;
    /** timeout duration. Once the process running time exceeds this it should be killed */
    private int timeout;
    /** say whether or not the watchog is currently monitoring a process */
    private boolean watch = false;
    /** exception that might be thrown during the process execution */
    private Exception caught = null;
    /** say whether or not the process was killed due to running overtime */
    private boolean     killedProcess = false;
    /**
     * Creates a new watchdog with a given timeout.
     *
     * @param timeout the timeout for the process in milliseconds. It must be greather than 0.
     */
    public ExecuteWatchdog(int timeout) {
        if (timeout < 1) {
            throw new IllegalArgumentException(""timeout lesser than 1."");
        }
        this.timeout = timeout;
    }
    /**
     * Watches the given process and terminates it, if it runs for too long.
     * All information from the previous run are reset.
     * @param process the process to monitor. It cannot be <tt>null</tt>
     * @throws IllegalStateException    thrown if a process is still being monitored.
     */
    public synchronized void start(Process process) {
        if (process == null) {
            throw new NullPointerException(""process is null."");
        }
        if (this.process != null) {
            throw new IllegalStateException(""Already running."");
        }
        this.caught = null;
        this.killedProcess = false;
        this.watch = true;
        this.process = process;
        final Thread thread = new Thread(this, ""WATCHDOG"");
        thread.setDaemon(true);
        thread.start();
    }
    /**
     * Stops the watcher. It will notify all threads possibly waiting on this object.
     */
    public synchronized void stop() {
        watch = false;
        notifyAll();
    }
    /**
     * Watches the process and terminates it, if it runs for to long.
     */
    public synchronized void run() {
        try {
            // This isn't a Task, don't have a Project object to log.
            // project.log(""ExecuteWatchdog: timeout = ""+timeout+"" msec"",  Project.MSG_VERBOSE);
            final long until = System.currentTimeMillis() + timeout;
            long now;
            while (watch && until > (now = System.currentTimeMillis())) {
                try {
                    wait(until - now);
                } catch (InterruptedException e) {}
            }
            // if we are here, either someone stopped the watchdog,
            // we are on timeout and the process must be killed, or
            // we are on timeout and the process has already stopped.
            try {
                // We must check if the process was not stopped
                // before being here
                process.exitValue();
            } catch (IllegalThreadStateException e){
                // the process is not terminated, if this is really
                // a timeout and not a manual stop then kill it.
                if (watch){
                    killedProcess = true;
                    process.destroy();
                }
            }
        } catch(Exception e) {
            caught = e;
        } finally {
            cleanUp();
        }
    }
    /**
     * reset the monitor flag and the process.
     */
    protected void cleanUp() {
        watch = false;
        process = null;
    }
    /**
     * This method will rethrow the exception that was possibly caught during the
     * run of the process. It will only remains valid once the process has been
     * terminated either by 'error', timeout or manual intervention. Information
     * will be discarded once a new process is ran.
     * @throws  BuildException  a wrapped exception over the one that was silently
     * swallowed and stored during the process run.
     */
    public void checkException() throws BuildException {
        if (caught != null) {
            throw new BuildException(""Exception in ExecuteWatchdog.run: ""
                                     + caught.getMessage(), caught);
        }
    }
    /**
     * Indicates whether or not the watchdog is still monitoring the process.
     * @return  <tt>true</tt> if the process is still running, otherwise <tt>false</tt>.
     */
    public boolean isWatching(){
        return watch;
    }
    /**
     * Indicates whether the last process run was killed on timeout or not.
     * @return  <tt>true</tt> if the process was killed otherwise <tt>false</tt>.
     */
    public boolean killedProcess(){
        return killedProcess;
    }
}
"
org.apache.tools.ant.taskdefs.Exit,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
/**
 * Just exit the active build, giving an additional message 
 * if available.
 *
 * @author Nico Seessle <nico@seessle.de>
 */
public class Exit extends Task { 
    private String message;
    public void setMessage(String value) { 
        this.message = value;
    }
    public void execute() throws BuildException {
        if (message != null && message.length() > 0) { 
            throw new BuildException(message);
        } else {
            throw new BuildException(""No message"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.Expand,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.zip.*;
/**
 * Unzip a file. 
 *
 * @author costin@dnt.ro
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class Expand extends MatchingTask {
    private File dest; // req
    private File source; // req
    /**
     * Do the work.
     *
     * @exception BuildException Thrown in unrecoverable error.
     */
    // XXX move it to util or tools
    public void execute() throws BuildException {
        if (""expand"".equals(taskType)) {
            log(""!! expand is deprecated. Use unzip instead. !!"");
        }
        Touch touch = (Touch) project.createTask(""touch"");
        touch.setOwningTarget(target);
        touch.setTaskName(getTaskName());
        touch.setLocation(getLocation());
        if (source == null) {
            throw new BuildException(""Source attribute must be specified"");
        }
        if (dest == null) {
            throw new BuildException(""Dest attribute must be specified"");
        }
        if (source.isDirectory()) {
            // get all the files in the descriptor directory
            DirectoryScanner ds = super.getDirectoryScanner(source);
            String[] files = ds.getIncludedFiles();
            for (int i = 0; i < files.length; ++i) {
                File file = new File(source, files[i]);
                expandFile(touch, file, dest);
            }
        }
        else {
            expandFile(touch, source, dest);
        }
    }
    private void expandFile(Touch touch, File srcF, File dir) {
        ZipInputStream zis = null;
        try {
            log(""Expanding: "" + srcF + "" into "" + dir, Project.MSG_INFO);
            // code from WarExpand
            zis = new ZipInputStream(new FileInputStream(srcF));
            ZipEntry ze = null;
            while ((ze = zis.getNextEntry()) != null) {
                File f = new File(dir, project.translatePath(ze.getName()));
                try {
                    log(""expand-file "" + ze.getName() , Project.MSG_VERBOSE );
                    // create intermediary directories - sometimes zip don't add them
                    File dirF=new File(f.getParent());
                    dirF.mkdirs();
                    if (ze.isDirectory()) {
                        f.mkdirs(); 
                    } else {
                        byte[] buffer = new byte[1024];
                        int length = 0;
                        FileOutputStream fos = new FileOutputStream(f);
                        while ((length = zis.read(buffer)) >= 0) {
                            fos.write(buffer, 0, length);
                        }
                        fos.close();
                    }
                    if (project.getJavaVersion() != Project.JAVA_1_1) {
                        touch.setFile(f);
                        touch.setMillis(ze.getTime());
                        touch.touch();
                    }
                } catch( FileNotFoundException ex ) {
                    log(""Unable to expand to file "" + f.getPath(), Project.MSG_WARN);
                }
            }
            log(""expand complete"", Project.MSG_VERBOSE );
        } catch (IOException ioe) {
            throw new BuildException(""Error while expanding "" + srcF.getPath(), ioe);
        } finally {
            if (zis != null) {
                try {
                    zis.close();
                }
                catch (IOException e) {}
            }
        }
    }
    /**
     * Set the destination directory. File will be unzipped into the
     * destination directory.
     *
     * @param d Path to the directory.
     */
    public void setDest(File d) {
        this.dest=d;
    }
    /**
     * Set the path to zip-file.
     *
     * @param s Path to zip-file.
     */
    public void setSrc(File s) {
        this.source = s;
    }
}
"
org.apache.tools.ant.taskdefs.Filter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.util.Enumeration;
import java.util.Properties;
import java.io.File;
import java.io.FileInputStream;
import org.apache.tools.ant.*;
/**
 * This task sets a token filter that is used by the file copy methods
 * of the project to do token substitution, or sets mutiple tokens by
 * reading these from a file.
 *
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Gero Vermaas <a href=""mailto:gero@xs4all.nl"">gero@xs4all.nl</a>
 */
public class Filter extends Task {
    private String token;
    private String value;
    private File filtersFile;
    public void setToken(String token) {
        this.token = token;
    }
    public void setValue(String value) {
        this.value = value;
    }
    public void setFiltersfile(File filtersFile) {
        this.filtersFile = filtersFile;
    }
    public void execute() throws BuildException {
        boolean isFiltersFromFile = filtersFile != null && token == null && value == null;
        boolean isSingleFilter = filtersFile == null && token != null && value != null;
        if (!isFiltersFromFile && !isSingleFilter) {
            throw new BuildException(""both token and value parameters, or only a filtersFile parameter is required"", location);
        }
        if (isSingleFilter) {
            project.addFilter(token, value);
        }
        if (isFiltersFromFile) {
            readFilters();
        }
    }
    protected void readFilters() throws BuildException {
        log(""Reading filters from "" + filtersFile, Project.MSG_VERBOSE);
        FileInputStream in = null;
        try {
            Properties props = new Properties();
            in = new FileInputStream(filtersFile);
            props.load(in);
            Project proj = getProject();
            Enumeration enum = props.propertyNames();
            while (enum.hasMoreElements()) {
                String strPropName = (String)enum.nextElement();
                String strValue = props.getProperty(strPropName);
                proj.addFilter(strPropName, strValue);
            }
        } catch (Exception e) {
            throw new BuildException(""Could not read filters from file: "" + filtersFile);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (java.io.IOException ioex) {}
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.FixCRLF,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.EnumeratedAttribute;
import java.io.*;
import java.util.*;
import java.text.*;
/**
 * Task to convert text source files to local OS formatting conventions, as
 * well as repair text files damaged by misconfigured or misguided editors or
 * file transfer programs.
 * <p>
 * This task can take the following arguments:
 * <ul>
 * <li>srcdir
 * <li>destdir
 * <li>include
 * <li>exclude
 * <li>cr
 * <li>tab
 * <li>eof
 * </ul>
 * Of these arguments, only <b>sourcedir</b> is required.
 * <p>
 * When this task executes, it will scan the srcdir based on the include
 * and exclude properties.
 * <p>
 * <em>Warning:</em> do not run on binary or carefully formatted files.
 * this may sound obvious, but if you don't specify asis, presume that
 * your files are going to be modified.  If you want tabs to be fixed,
 * whitespace characters may be added or removed as necessary.  Similarly,
 * for CR's - in fact cr=""add"" can result in cr characters being removed.
 * (to handle cases where other programs have converted CRLF into CRCRLF).
 *
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 */
public class FixCRLF extends MatchingTask {
    private int addcr;      // cr:  -1 => remove, 0 => asis, +1 => add
    private int addtab;     // tab: -1 => remove, 0 => asis, +1 => add
    private int ctrlz;      // eof: -1 => remove, 0 => asis, +1 => add
    private int tablength = 8;  // length of tab in spaces
    private File srcDir;
    private File destDir = null;
    /**
     * Defaults the properties based on the system type.
     * <ul><li>Unix: cr=""remove"" tab=""asis"" eof=""remove""
     *     <li>DOS: cr=""add"" tab=""asis"" eof=""asis""</ul>
     */
    public FixCRLF() {
        if (System.getProperty(""path.separator"").equals("":"")) {
            addcr = -1; // remove
            ctrlz = -1; // remove
        } else {
            addcr = +1; // add
            ctrlz = 0;  // asis
        }
    }
    /**
     * Set the source dir to find the source text files.
     */
    public void setSrcdir(File srcDir) {
        this.srcDir = srcDir;
    }
    /**
     * Set the destination where the fixed files should be placed.
     * Default is to replace the original file.
     */
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }
    /**
     * Specify how carriage return (CR) charaters are to be handled
     *
     * @param option valid values:
     * <ul>
     * <li>add: ensure that there is a CR before every LF
     * <li>asis: leave CR characters alone
     * <li>remove: remove all CR characters
     * </ul>
     */
    public void setCr(AddAsisRemove attr) {
        String option = attr.getValue();
        if (option.equals(""remove"")) {
            addcr = -1;
        } else if (option.equals(""asis"")) {
            addcr = 0;
        } else {
            // must be ""add""
            addcr = +1;
        }
    }
    /**
     * Specify how tab charaters are to be handled
     *
     * @param option valid values:
     * <ul>
     * <li>add: convert sequences of spaces which span a tab stop to tabs
     * <li>asis: leave tab and space characters alone
     * <li>remove: convert tabs to spaces
     * </ul>
     */
    public void setTab(AddAsisRemove attr) {
        String option = attr.getValue();
        if (option.equals(""remove"")) {
            addtab = -1;
        } else if (option.equals(""asis"")) {
            addtab = 0;
        } else {
            // must be ""add""
            addtab = +1;
        }
    }
    /**
     * Specify tab length in characters
     *
     * @param tlength specify the length of tab in spaces, has to be a power of 2
     */
    public void setTablength(int tlength) throws BuildException {
        if (tlength < 2 || (tlength & (tlength-1)) != 0) {
            throw new BuildException(""tablength must be a positive power of 2"",
                                     location);
        }
        tablength = tlength;
    }
    /**
     * Specify how DOS EOF (control-z) charaters are to be handled
     *
     * @param option valid values:
     * <ul>
     * <li>add: ensure that there is an eof at the end of the file
     * <li>asis: leave eof characters alone
     * <li>remove: remove any eof character found at the end
     * </ul>
     */
    public void setEof(AddAsisRemove attr) {
        String option = attr.getValue();
        if (option.equals(""remove"")) {
            ctrlz = -1;
        } else if (option.equals(""asis"")) {
            ctrlz = 0;
        } else {
            // must be ""add""
            ctrlz = +1;
        }
    }
    /**
     * Executes the task.
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a srcdir and destdir
        if (srcDir == null) {
            throw new BuildException(""srcdir attribute must be set!"");
        }
        if (!srcDir.exists()) {
            throw new BuildException(""srcdir does not exist!"");
        }
        if (!srcDir.isDirectory()) {
            throw new BuildException(""srcdir is not a directory!"");
        }
        if (destDir != null) {
            if (!destDir.exists()) {
                throw new BuildException(""destdir does not exist!"");
            }
            if (!destDir.isDirectory()) {
                throw new BuildException(""destdir is not a directory!"");
            }
        }
        // log options used
        log(""options:"" +
            "" cr="" + (addcr==-1 ? ""add"" : addcr==0 ? ""asis"" : ""remove"") +
            "" tab="" + (addtab==-1 ? ""add"" : addtab==0 ? ""asis"" : ""remove"") +
            "" eof="" + (ctrlz==-1 ? ""add"" : ctrlz==0 ? ""asis"" : ""remove"") +
            "" tablength="" + tablength,
            Project.MSG_VERBOSE);
        DirectoryScanner ds = super.getDirectoryScanner(srcDir);
        String[] files = ds.getIncludedFiles();
        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(srcDir, files[i]);
            // read the contents of the file
            int count = (int)srcFile.length();
            byte indata[] = new byte[count];
            try {
                FileInputStream inStream = new FileInputStream(srcFile);
                inStream.read(indata);
                inStream.close();
            } catch (IOException e) {
                throw new BuildException(e);
            }
            // count the number of cr, lf,  and tab characters
            int cr = 0;
            int lf = 0;
            int tab = 0;
            for (int k=0; k<count; k++) {
                byte c = indata[k];
                if (c == '\r') cr++;
                if (c == '\n') lf++;
                if (c == '\t') tab++;
            }
            // check for trailing eof
            boolean eof = ((count>0) && (indata[count-1] == 0x1A));
            // log stats (before fixes)
            log(srcFile + "": size="" + count + "" cr="" + cr +
                        "" lf="" + lf + "" tab="" + tab + "" eof="" + eof,
                        Project.MSG_VERBOSE);
            // determine the output buffer size (slightly pessimisticly)
            int outsize = count;
            if (addcr  !=  0) outsize-=cr;
            if (addcr  == +1) outsize+=lf;
            if (addtab == -1) outsize+=tab*(tablength-1);
            if (ctrlz  == +1) outsize+=1;
            // copy the data
            byte outdata[] = new byte[outsize];
            int o = 0;    // output offset
            int line = o; // beginning of line
            int col = 0;  // desired column
            for (int k=0; k<count; k++) {
                switch (indata[k]) {
                    case (byte)' ':
                        // advance column
                        if (addtab == 0) outdata[o++]=(byte)' ';
                        col++;
                        break;
                    case (byte)'\t':
                        if (addtab == 0) {
                            // treat like any other character
                            outdata[o++]=(byte)'\t';
                            col++;
                        } else {
                            // advance column to next tab stop
                            col = (col|(tablength-1))+1;
                        }
                        break;
                    case (byte)'\r':
                        if (addcr == 0) {
                            // treat like any other character
                            outdata[o++]=(byte)'\r';
                            col++;
                        }
                        break;
                    case (byte)'\n':
                        // start a new line (optional CR followed by LF)
                        if (addcr == +1) outdata[o++]=(byte)'\r';
                        outdata[o++]=(byte)'\n';
                        line=o;
                        col=0;
                        break;
                    default:
                        // add tabs if two or more spaces are required
                        if (addtab>0 && o+1<line+col) {
                            // determine logical column
                            int diff=o-line;
                            // add tabs until this column would be passed
                            // note: the start of line is adjusted to match
                            while ((diff|(tablength-1))<col) {
                                outdata[o++]=(byte)'\t';
                                line-=(tablength-1)-(diff&(tablength-1));
                                diff=o-line;
                            };
                        };
                        // space out to desired column
                        while (o<line+col) outdata[o++]=(byte)' ';
                        // append desired character
                        outdata[o++]=indata[k];
                        col++;
                }
            }
            // add or remove an eof character as required
            if (ctrlz == +1) {
                if (outdata[o-1]!=0x1A) outdata[o++]=0x1A;
            } else if (ctrlz == -1) {
                if (o>2 && outdata[o-1]==0x0A && outdata[o-2]==0x1A) o--;
                if (o>1 && outdata[o-1]==0x1A) o--;
            }
            // output the data
            try {
                File destFile = srcFile;
                if (destDir != null) destFile = new File(destDir, files[i]);
                FileOutputStream outStream = new FileOutputStream(destFile);
                outStream.write(outdata,0,o);
                outStream.close();
            } catch (IOException e) {
                throw new BuildException(e);
            }
        } /* end for */
    }
    /**
     * Enumerated attribute with the values ""asis"", ""add"" and ""remove"".
     */
    public static class AddAsisRemove extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[] {""add"", ""asis"", ""remove""};
        }
    }
}
"
org.apache.tools.ant.taskdefs.GenerateKey,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
/**
 * Generates a key.
 * 
 * @author <a href=""mailto:donaldp@apache.org"">Peter Donald</a>
 */
public class GenerateKey extends Task {
    public static class DnameParam {
        private String name;
        private String value;
        public void setName(String name) {
            this.name = name;
        }
        public String getName() {
            return name;
        }
        public void setValue(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
    }
    public static class DistinguishedName {
        private String name;
        private String path;
        private Vector params = new Vector();
        public Object createParam() {
            DnameParam param = new DnameParam();
            params.addElement(param);
            return param;
        }
        public Enumeration getParams() {
            return params.elements();
        }
        public String toString() {
            final int size = params.size();
            final StringBuffer sb = new StringBuffer();
            boolean firstPass = true;
            for( int i = 0; i < size; i++ ) {
                if( !firstPass ) {
                    sb.append("" ,"");
                }
                firstPass = false;
                final DnameParam param = (DnameParam)params.elementAt( i );
                sb.append( encode( param.getName() ) );
                sb.append( '=' );
                sb.append( encode( param.getValue() ) );
            }
            return sb.toString();
        }
        public String encode( final String string ) {
            int end = string.indexOf(',');
            if( -1 == end ) return string;
            final StringBuffer sb = new StringBuffer();
            int start = 0;
            while( -1 != end )
            {
                sb.append( string.substring( start, end ) );
                sb.append( ""\\,"" );
                start = end + 1;
                end = string.indexOf( ',', start );
            }
            sb.append( string.substring( start ) );
            return sb.toString();                
        }
    }
    /**
     * The alias of signer.
     */
    protected String alias;
    /**
     * The name of keystore file.
     */
    protected String keystore;
    protected String storepass;
    protected String storetype;
    protected String keypass;
    protected String sigalg;
    protected String keyalg;
    protected String dname;
    protected DistinguishedName expandedDname;
    protected int keysize;
    protected int validity;
    protected boolean verbose;
    public DistinguishedName createDname() throws BuildException {
        if( null != expandedDname ) {
            throw new BuildException( ""DName sub-element can only be specified once."" );
        }
        if( null != dname ) {
            throw new BuildException( ""It is not possible to specify dname both "" +
                                      ""as attribute and element."" );
        }
        expandedDname = new DistinguishedName();
        return expandedDname;
    }
    public void setDname(final String dname) {
        if( null != expandedDname ) {
            throw new BuildException( ""It is not possible to specify dname both "" +
                                      ""as attribute and element."" );
        }
        this.dname = dname;
    } 
    public void setAlias(final String alias) {
        this.alias = alias;
    } 
    public void setKeystore(final String keystore) {
        this.keystore = keystore;
    } 
    public void setStorepass(final String storepass) {
        this.storepass = storepass;
    } 
    public void setStoretype(final String storetype) {
        this.storetype = storetype;
    } 
    public void setKeypass(final String keypass) {
        this.keypass = keypass;
    } 
    public void setSigalg(final String sigalg) {
        this.sigalg = sigalg;
    } 
    public void setKeyalg(final String keyalg) {
        this.keyalg = keyalg;
    } 
    public void setKeysize(final String keysize) throws BuildException {
        try { this.keysize = Integer.parseInt(keysize); }
        catch(final NumberFormatException nfe) 
        {
            throw new BuildException( ""KeySize attribute should be a integer"" );
        }
    } 
    public void setValidity(final String validity) throws BuildException {
        try { this.validity = Integer.parseInt(validity); }
        catch(final NumberFormatException nfe) 
        {
            throw new BuildException( ""Validity attribute should be a integer"" );
        }
    } 
    public void setVerbose(final boolean verbose) {
        this.verbose = verbose;
    } 
    public void execute() throws BuildException {
        if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
            throw new BuildException( ""The genkey task is only available on JDK"" +
                                      "" versions 1.2 or greater"" );
        } 
        if (null == alias) {
            throw new BuildException( ""alias attribute must be set"" );
        } 
        if (null == storepass) {
            throw new BuildException( ""storepass attribute must be set"" );
        } 
        if (null == dname && null == expandedDname) {
            throw new BuildException( ""dname must be set"" );
        } 
        final StringBuffer sb = new StringBuffer();
        sb.append(""keytool -genkey "");
        if (verbose) {
            sb.append(""-v "");
        } 
        sb.append(""-alias \"""");
        sb.append(alias);
        sb.append(""\"" "");
        if (null != dname) {
            sb.append(""-dname \"""");
            sb.append(dname);
            sb.append(""\"" "");
        } 
        if (null != expandedDname) {
            sb.append(""-dname \"""");
            sb.append(expandedDname);
            sb.append(""\"" "");
        } 
        if (null != keystore) {
            sb.append(""-keystore \"""");
            sb.append(keystore);
            sb.append(""\"" "");
        }
        if (null != storepass) {
            sb.append(""-storepass \"""");
            sb.append(storepass);
            sb.append(""\"" "");
        } 
        if (null != storetype) {
            sb.append(""-storetype \"""");
            sb.append(storetype);
            sb.append(""\"" "");
        } 
        sb.append(""-keypass \"""");
        if (null != keypass) {
            sb.append(keypass);
        } 
        else {
            sb.append(storepass);
        }
        sb.append(""\"" "");
        if (null != sigalg) {
            sb.append(""-sigalg \"""");
            sb.append(sigalg);
            sb.append(""\"" "");
        } 
        if (null != keyalg) {
            sb.append(""-keyalg \"""");
            sb.append(keyalg);
            sb.append(""\"" "");
        } 
        if (0 < keysize) {
            sb.append(""-keysize \"""");
            sb.append(keysize);
            sb.append(""\"" "");
        } 
        if (0 < validity) {
            sb.append(""-validity \"""");
            sb.append(validity);
            sb.append(""\"" "");
        } 
        log(""Generating Key for "" + alias );
        final ExecTask cmd = (ExecTask) project.createTask(""exec"");
        cmd.setCommand(new Commandline(sb.toString()));
        cmd.setFailonerror(true);
        cmd.setTaskName( getTaskName() );
        cmd.execute();
    } 
}
"
org.apache.tools.ant.taskdefs.Get,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.net.*;
import java.util.*;
import org.apache.tools.ant.*;
/**
 * Get a particular file from a URL source. 
 * Options include verbose reporting, timestamp based fetches and controlling 
 * actions on failures. NB: access through a firewall only works if the whole 
 * Java runtime is correctly configured.
 *
 * @author costin@dnt.ro
 */
public class Get extends Task {
    private URL source; // required
    private File dest; // required
    private boolean verbose = false;
    private boolean useTimestamp = false; //off by default
    private boolean ignoreErrors = false;
    /**
     * Does the work.
     *
     * @exception BuildException Thrown in unrecoverable error.
     */
    public void execute() throws BuildException {
        if (source == null) {
            throw new BuildException(""src attribute is required"", location);
        }
        if (dest == null) {
            throw new BuildException(""dest attribute is required"", location);
        }
        if (dest.exists() && dest.isDirectory()) { 
            throw new BuildException(""The specified destination is a directory"",
                                     location);
        }
        if (dest.exists() && !dest.canWrite()) { 
            throw new BuildException(""Can't write to "" + dest.getAbsolutePath(),
                                     location);
        }
        try {
            log(""Getting: "" + source);
            //set the timestamp to the file date.
            long timestamp=0;
            boolean hasTimestamp=false;
            if(useTimestamp && dest.exists()) {
                timestamp=dest.lastModified();
                if (verbose)  {
                    Date t=new Date(timestamp);
                    log(""local file date : ""+t.toString());
                }
                hasTimestamp=true;
            }
            //set up the URL connection
            URLConnection connection=source.openConnection();
            //modify the headers
            //NB: things like user authentication could go in here too.
            if(useTimestamp && hasTimestamp) {
                connection.setIfModifiedSince(timestamp);
            }
            //connect to the remote site (may take some time)
            connection.connect();
            //next test for a 304 result (HTTP only)
            if(connection instanceof HttpURLConnection)  {
                HttpURLConnection httpConnection=(HttpURLConnection)connection;
                if(httpConnection.getResponseCode()==HttpURLConnection.HTTP_NOT_MODIFIED)  {
                    //not modified so no file download. just return instead
                    //and trace out something so the user doesn't think that the 
                    //download happened when it didnt
                    log(""Not modified - so not downloaded"");
                    return; 
                }
            }
            //REVISIT: at this point even non HTTP connections may support the if-modified-since
            //behaviour -we just check the date of the content and skip the write if it is not
            //newer. Some protocols (FTP) dont include dates, of course. 
            FileOutputStream fos = new FileOutputStream(dest);
            InputStream is=null;
            for( int i=0; i< 3 ; i++ ) {
                try {
                    is = connection.getInputStream();
                    break;
                } catch( IOException ex ) {
                    log( ""Error opening connection "" + ex );
                }
            }
            if( is==null ) {
                log( ""Can't get "" + source + "" to "" + dest);
                if(ignoreErrors) 
                    return;
                throw new BuildException( ""Can't get "" + source + "" to "" + dest,
                                          location);
            }
            byte[] buffer = new byte[100 * 1024];
            int length;
            while ((length = is.read(buffer)) >= 0) {
                fos.write(buffer, 0, length);
                if (verbose) System.out.print(""."");
            }
            if(verbose) System.out.println();
            fos.close();
            is.close();
            //if (and only if) the use file time option is set, then the 
            //saved file now has its timestamp set to that of the downloaded file
            if(useTimestamp)  {
                long remoteTimestamp=connection.getLastModified();
                if (verbose)  {
                    Date t=new Date(remoteTimestamp);
                    log(""last modified = ""+t.toString()
                        +((remoteTimestamp==0)?"" - using current time instead"":""""));
                }
                if(remoteTimestamp!=0)
                    touchFile(dest,remoteTimestamp);
            }
        } catch (IOException ioe) {
            log(""Error getting "" + source + "" to "" + dest );
            if(ignoreErrors) 
                return;
            throw new BuildException(ioe, location);
        }
    }
    /** 
     * set the timestamp of a named file to a specified time.
     *
     * @param filename
     * @param time in milliseconds since the start of the era
     * @return true if it succeeded. False means that this is a
     * java1.1 system and that file times can not be set
     *@exception BuildException Thrown in unrecoverable error. Likely
     *this comes from file access failures.
     */
    protected boolean touchFile(File file, long timemillis) 
        throws BuildException  {
        if (project.getJavaVersion() != Project.JAVA_1_1) {
            Touch touch = (Touch) project.createTask(""touch"");
            touch.setOwningTarget(target);
            touch.setTaskName(getTaskName());
            touch.setLocation(getLocation());
            touch.setFile(file);
            touch.setMillis(timemillis);
            touch.touch();
            return true;
        } else {
            return false;
        }
    }        
    /**
     * Set the URL.
     *
     * @param u URL for the file.
     */
    public void setSrc(URL u) {
        this.source = u;
    }
    /**
     * Where to copy the source file.
     *
     * @param dest Path to file.
     */
    public void setDest(File dest) {
        this.dest = dest;
    }
    /**
     * Be verbose, if set to ""<CODE>true</CODE>"".
     *
     * @param v if ""true"" then be verbose
     */
    public void setVerbose(boolean v) {
        verbose = v;
    }
    /**
     * Don't stop if get fails if set to ""<CODE>true</CODE>"".
     *
     * @param v if ""true"" then don't report download errors up to ant
     */
    public void setIgnoreErrors(boolean v) {
        ignoreErrors = v;
    }
    /**
     * Use timestamps, if set to ""<CODE>true</CODE>"".
     *
     * <p>In this situation, the if-modified-since header is set so that the file is
     * only fetched if it is newer than the local file (or there is no local file)
     * This flag is only valid on HTTP connections, it is ignored in other cases.
     * When the flag is set, the local copy of the downloaded file will also 
     * have its timestamp set to the remote file time. 
     * <br>
     * Note that remote files of date 1/1/1970 (GMT) are treated as 'no timestamp', and
     * web servers often serve files with a timestamp in the future by replacing their timestamp
     * with that of the current time. Also, inter-computer clock differences can cause no end of 
     * grief. 
     * @param v ""true"" to enable file time fetching
     */
    public void setUseTimestamp(boolean v) {
        if (project.getJavaVersion() != Project.JAVA_1_1) {
            useTimestamp = v;
        }
    }
}
"
org.apache.tools.ant.taskdefs.GUnzip,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.zip.*;
/**
 * Expands a file that has been compressed with the GZIP
 * algorightm. Normally used to compress non-compressed archives such
 * as TAR files.
 *
 * @author Stefan Bodewig <a href=""mailto:stefan.bodewig@megabit.net"">stefan.bodewig@megabit.net</a>
 */
public class GUnzip extends Task {
    private File source;
    private File dest;
    public void setSrc(String src) {
        source = project.resolveFile(src);
    }
    public void setDest(String dest) {
        this.dest = project.resolveFile(dest);
    }
    public void execute() throws BuildException {
        if (source == null) {
            throw new BuildException(""No source for gunzip specified"", location);
        }
        if (!source.exists()) {
            throw new BuildException(""source doesn't exist"", location);
        }
        if (source.isDirectory()) {
            throw new BuildException(""Cannot expand a directory"", location);
        }
        if (dest == null) {
            dest = new File(source.getParent());
        }
        if (dest.isDirectory()) {
            String sourceName = source.getName();
            int len = sourceName.length();
            if (len > 3
                && "".gz"".equalsIgnoreCase(sourceName.substring(len-3))) {
                dest = new File(dest, sourceName.substring(0, len-3));
            } else {
                dest = new File(dest, sourceName);
            }
        }
        if (source.lastModified() > dest.lastModified()) {
            log(""Expanding ""+ source.getAbsolutePath() + "" to ""
                        + dest.getAbsolutePath());
            FileOutputStream out = null;
            GZIPInputStream zIn = null;
            try {
                out = new FileOutputStream(dest);
                zIn = new GZIPInputStream(new FileInputStream(source));
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    out.write(buffer, 0, count);
                    count = zIn.read(buffer, 0, buffer.length);
                } while (count != -1);
            } catch (IOException ioe) {
                String msg = ""Problem expanding gzip "" + ioe.getMessage();
                throw new BuildException(msg, ioe, location);
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (IOException ioex) {}
                }
                if (zIn != null) {
                    try {
                        zIn.close();
                    } catch (IOException ioex) {}
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.GZip,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.zip.*;
/**
 * Compresses a file with the GZIP algorightm. Normally used to compress
 * non-compressed archives such as TAR files.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 */
public class GZip extends Task {
    private File zipFile;
    private File source;
    public void setZipfile(String zipFilename) {
        zipFile = project.resolveFile(zipFilename);
    }
    public void setSrc(String src) {
        source = project.resolveFile(src);
    }
    public void execute() throws BuildException {
        if (zipFile == null) {
            throw new BuildException(""zipfile attribute is required"", location);
        }
        if (source == null) {
            throw new BuildException(""src attribute is required"", location);
        }
        log(""Building gzip: "" + zipFile.getAbsolutePath());
        GZIPOutputStream zOut = null;
        try {
            zOut = new GZIPOutputStream(new FileOutputStream(zipFile));
            if (source.isDirectory()) {
                log (""Cannot Gzip a directory!"", Project.MSG_ERR);
            } else {
                zipFile(source, zOut);
            }
        } catch (IOException ioe) {
            String msg = ""Problem creating gzip "" + ioe.getMessage();
            throw new BuildException(msg, ioe, location);
        } finally {
            if (zOut != null) {
                try {
                    // close up
                    zOut.close();
                }
                catch (IOException e) {}
            }
        }
    }
    private void zipFile(InputStream in, GZIPOutputStream zOut)
        throws IOException
    {        
        byte[] buffer = new byte[8 * 1024];
        int count = 0;
        do {
            zOut.write(buffer, 0, count);
            count = in.read(buffer, 0, buffer.length);
        } while (count != -1);
    }
    private void zipFile(File file, GZIPOutputStream zOut)
        throws IOException
    {
        FileInputStream fIn = new FileInputStream(file);
        try {
            zipFile(fIn, zOut);
        } finally {
            fIn.close();
        }
    }
}
"
org.apache.tools.ant.taskdefs.Jar,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.ZipFileSet;
import java.io.*;
import java.util.zip.*;
/**
 * Creates a JAR archive.
 * 
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 */
public class Jar extends Zip {
    private File manifest;    
    private boolean manifestAdded;    
    public Jar() {
        super();
        archiveType = ""jar"";
        emptyBehavior = ""create"";
    }
    public void setJarfile(File jarFile) {
        super.setZipfile(jarFile);
    }
    public void setManifest(File manifestFile) {
        manifest = manifestFile;
        if (!manifest.exists())
            throw new BuildException(""Manifest file: "" + manifest + "" does not exist."");
        // Create a ZipFileSet for this file, and pass it up.
        ZipFileSet fs = new ZipFileSet();
        fs.setDir(new File(manifest.getParent()));
        fs.setIncludes(manifest.getName());
        fs.setFullpath(""META-INF/MANIFEST.MF"");
        super.addFileset(fs);
    }
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException
    {
        // If no manifest is specified, add the default one.
        if (manifest == null) {
            String s = ""/org/apache/tools/ant/defaultManifest.mf"";
            InputStream in = this.getClass().getResourceAsStream(s);
            if ( in == null )
                throw new BuildException ( ""Could not find: "" + s );
            zipDir(null, zOut, ""META-INF/"");
            zipFile(in, zOut, ""META-INF/MANIFEST.MF"", System.currentTimeMillis());
        }
        super.initZipOutputStream(zOut);
    }
    protected void zipFile(File file, ZipOutputStream zOut, String vPath)
        throws IOException
    {
        // If the file being added is META-INF/MANIFEST.MF, we warn if it's not the
        // one specified in the ""manifest"" attribute - or if it's being added twice, 
        // meaning the same file is specified by the ""manifeset"" attribute and in
        // a <fileset> element.
        if (vPath.equalsIgnoreCase(""META-INF/MANIFEST.MF""))  {
            if (manifest == null || !manifest.equals(file) || manifestAdded) {
                log(""Warning: selected ""+archiveType+"" files include a META-INF/MANIFEST.MF which will be ignored "" +
                    ""(please use manifest attribute to ""+archiveType+"" task)"", Project.MSG_WARN);
            } else {
                super.zipFile(file, zOut, vPath);
                manifestAdded = true;
            }
        } else {
            super.zipFile(file, zOut, vPath);
        }
    }
    /**
     * Make sure we don't think we already have a MANIFEST next time this task
     * gets executed.
     */
    protected void cleanUp() {
        manifestAdded = false;
        super.cleanUp();
    }
}
"
org.apache.tools.ant.taskdefs.Java,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
/**
 * This task acts as a loader for java applications but allows to use the same JVM 
 * for the called application thus resulting in much faster operation.
 *
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Java extends Task {
    private CommandlineJava cmdl = new CommandlineJava();
    private boolean fork = false;
    private File dir = null;
    private File out;
    private boolean failOnError = false;
    /**
     * Do the execution.
     */
    public void execute() throws BuildException {
        int err = -1;
        if ((err = executeJava()) != 0) {
            if (failOnError) {
                throw new BuildException(""Java returned: ""+err, location);
            } else {
                log(""Java Result: "" + err, Project.MSG_ERR);
            }
        }
    }
    /**
     * Do the execution and return a return code.
     *
     * @return the return code from the execute java class if it was executed in 
     * a separate VM (fork = ""yes"").
     */
    public int executeJava() throws BuildException {
        String classname = cmdl.getClassname();
        if (classname == null) {
            throw new BuildException(""Classname must not be null."");
        }
        if (fork) {
            log(""Forking "" + cmdl.toString(), Project.MSG_VERBOSE);
            return run(cmdl.getCommandline());
        } else {
            if (cmdl.getVmCommand().size() > 1) {
                log(""JVM args ignored when same JVM is used."", Project.MSG_WARN);
            }
            if (dir != null) {
                log(""Working directory ignored when same JVM is used."", Project.MSG_WARN);
            }
            log(""Running in same VM "" + cmdl.getJavaCommand().toString(), 
                Project.MSG_VERBOSE);
            run(cmdl);
            return 0;
        }
    }
    /**
     * Set the classpath to be used for this compilation.
     */
    public void setClasspath(Path s) {
        createClasspath().append(s);
    }
    /**
     * Creates a nested classpath element
     */
    public Path createClasspath() {
        return cmdl.createClasspath(project).createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    /**
     * Set the class name.
     */
    public void setClassname(String s) {
        cmdl.setClassname(s);
    }
    /**
     * Set the command line arguments for the class.
     */
    public void setArgs(String s) {
        log(""The args attribute is deprecated. "" +
            ""Please use nested arg elements."",
            Project.MSG_WARN);
        cmdl.createArgument().setLine(s);
    }
    /**
     * Creates a nested arg element.
     */
    public Commandline.Argument createArg() {
        return cmdl.createArgument();
    }
    /**
     * Set the forking flag.
     */
    public void setFork(boolean s) {
        this.fork = s;
    }
    /**
     * Set the command line arguments for the JVM.
     */
    public void setJvmargs(String s) {
        log(""The jvmargs attribute is deprecated. "" +
            ""Please use nested jvmarg elements."",
            Project.MSG_WARN);
        cmdl.createVmArgument().setLine(s);
    }
    /**
     * Creates a nested jvmarg element.
     */
    public Commandline.Argument createJvmarg() {
        return cmdl.createVmArgument();
    }
    /**
     * Set the command used to start the VM (only if fork==false).
     */
    public void setJvm(String s) {
        cmdl.setVm(s);
    }
    /**
     * Add a nested sysproperty element.
     */
    public void addSysproperty(Environment.Variable sysp) {
        cmdl.addSysproperty(sysp);
    }
    /**
     * Throw a BuildException if process returns non 0.
     */
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    /**
     * The working directory of the process
     */
    public void setDir(File d) {
        this.dir = d;
    }
    /**
     * File the output of the process is redirected to.
     */
    public void setOutput(File out) {
        this.out = out;
    }
    /**
     * -mx or -Xmx depending on VM version
     */
    public void setMaxmemory(String max){
        if (Project.getJavaVersion().startsWith(""1.1"")) {
            createJvmarg().setValue(""-mx""+max);
        } else {
            createJvmarg().setValue(""-Xmx""+max);
        }
    }
    /**
     * Executes the given classname with the given arguments as it
     * was a command line application.
     */
    private void run(CommandlineJava command) throws BuildException {
        ExecuteJava exe = new ExecuteJava();
        exe.setJavaCommand(command.getJavaCommand());
        exe.setClasspath(command.getClasspath());
        exe.setSystemProperties(command.getSystemProperties());
        if (out != null) {
            try {
                exe.setOutput(new PrintStream(new FileOutputStream(out)));
            } catch (IOException io) {
                throw new BuildException(io, location);
            }
        }
        exe.execute(project);
    }
    /**
     * Executes the given classname with the given arguments in a separate VM.
     */
    private int run(String[] command) throws BuildException {
        FileOutputStream fos = null;
        try {
            Execute exe = null;
            if (out == null) {
                exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO,
                                                       Project.MSG_WARN), 
                                  null);
            } else {
                fos = new FileOutputStream(out);
                exe = new Execute(new PumpStreamHandler(fos), null);
            }
            exe.setAntRun(project);
            if (dir == null) {
                dir = project.getBaseDir();
            } else if (!dir.exists() || !dir.isDirectory()) {
                throw new BuildException(dir.getAbsolutePath()+"" is not a valid directory"",
                                         location);
            }
            exe.setWorkingDirectory(dir);
            exe.setCommandline(command);
            try {
                return exe.execute();
            } catch (IOException e) {
                throw new BuildException(e, location);
            }
        } catch (IOException io) {
            throw new BuildException(io, location);
        } finally {
            if (fos != null) {
                try {fos.close();} catch (IOException io) {}
            }
        }
    }
    /**
     * Executes the given classname with the given arguments as it
     * was a command line application.
     */
    protected void run(String classname, Vector args) throws BuildException {
        CommandlineJava cmdj = new CommandlineJava();
        cmdj.setClassname(classname);
        for (int i=0; i<args.size(); i++) {
            cmdj.createArgument().setValue((String) args.elementAt(i));
        }
        run(cmdj);
    }
    /**
     * Clear out the arguments to this java task.
     */
    public void clearArgs() {
        cmdl.clearJavaArgs();
    }
}
"
org.apache.tools.ant.taskdefs.Javac,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.util.*;
import org.apache.tools.ant.taskdefs.compilers.*;
import java.io.File;
/**
 * Task to compile Java source files. This task can take the following
 * arguments:
 * <ul>
 * <li>sourcedir
 * <li>destdir
 * <li>deprecation
 * <li>classpath
 * <li>bootclasspath
 * <li>extdirs
 * <li>optimize
 * <li>debug
 * <li>encoding
 * <li>target
 * <li>depend
 * <li>vebose
 * <li>failonerror
 * <li>includeantruntime
 * <li>includejavaruntime
 * </ul>
 * Of these arguments, the <b>sourcedir</b> and <b>destdir</b> are required.
 * <p>
 * When this task executes, it will recursively scan the sourcedir and
 * destdir looking for Java source files to compile. This task makes its
 * compile decision based on timestamp. 
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class Javac extends MatchingTask {
    private static final String FAIL_MSG 
        = ""Compile failed, messages should have been provided."";
    private Path src;
    private File destDir;
    private Path compileClasspath;
    private String encoding;
    private boolean debug = false;
    private boolean optimize = false;
    private boolean deprecation = false;
    private boolean depend = false;
    private boolean verbose = false;
    private String target;
    private Path bootclasspath;
    private Path extdirs;
    private boolean includeAntRuntime = true;
    private boolean includeJavaRuntime = false;
    protected boolean failOnError = true;
    protected File[] compileList = new File[0];
    /**
     * Create a nested <src ...> element for multiple source path
     * support.
     *
     * @return a nexted src element.
     */
    public Path createSrc() {
        if (src == null) {
            src = new Path(project);
        }
        return src.createPath();
    }
    /**
     * Set the source dirs to find the source Java files.
     */
    public void setSrcdir(Path srcDir) {
        if (src == null) {
            src = srcDir;
        } else {
            src.append(srcDir);
        }
    }
    /** Gets the source dirs to find the source java files. */
    public Path getSrcdir() {
        return src;
    }
    /**
     * Set the destination directory into which the Java source
     * files should be compiled.
     */
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }
    /** 
     * Gets the destination directory into which the java source files
     * should be compiled.
     */
    public File getDestdir() {
        return destDir;
    }
    /**
     * Set the classpath to be used for this compilation.
     */
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }
    /** Gets the classpath to be used for this compilation. */
    public Path getClasspath() {
        return compileClasspath;
    }
    /**
     * Maybe creates a nested classpath element.
     */
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(project);
        }
        return compileClasspath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    /**
     * Sets the bootclasspath that will be used to compile the classes
     * against.
     */
    public void setBootclasspath(Path bootclasspath) {
        if (this.bootclasspath == null) {
            this.bootclasspath = bootclasspath;
        } else {
            this.bootclasspath.append(bootclasspath);
        }
    }
    /**
     * Gets the bootclasspath that will be used to compile the classes
     * against.
     */
    public Path getBootclasspath() {
        return bootclasspath;
    }
    /**
     * Maybe creates a nested classpath element.
     */
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(project);
        }
        return bootclasspath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }
    /**
     * Sets the extension directories that will be used during the
     * compilation.
     */
    public void setExtdirs(Path extdirs) {
        if (this.extdirs == null) {
            this.extdirs = extdirs;
        } else {
            this.extdirs.append(extdirs);
        }
    }
    /**
     * Gets the extension directories that will be used during the
     * compilation.
     */
    public Path getExtdirs() {
        return extdirs;
    }
    /**
     * Maybe creates a nested classpath element.
     */
    public Path createExtdirs() {
        if (extdirs == null) {
            extdirs = new Path(project);
        }
        return extdirs.createPath();
    }
    /**
     * Throw a BuildException if compilation fails
     */
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    /**
     * Proceed if compilation fails
     */
    public void setProceed(boolean proceed) {
        failOnError = !proceed;
    }
    /**
     * Gets the failonerror flag.
     */
    public boolean getFailonerror() {
        return failOnError;
    }
    /**
     * Set the deprecation flag.
     */
    public void setDeprecation(boolean deprecation) {
        this.deprecation = deprecation;
    }
    /** Gets the deprecation flag. */
    public boolean getDeprecation() {
        return deprecation;
    }
    /**
     * Set the Java source file encoding name.
     */
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    /** Gets the java source file encoding name. */
    public String getEncoding() {
        return encoding;
    }
    /**
     * Set the debug flag.
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    }
    /** Gets the debug flag. */
    public boolean getDebug() {
        return debug;
    }
    /**
     * Set the optimize flag.
     */
    public void setOptimize(boolean optimize) {
        this.optimize = optimize;
    }
    /** Gets the optimize flag. */
    public boolean getOptimize() {
        return optimize;
    }
    /** 
     * Set the depend flag.
     */ 
    public void setDepend(boolean depend) {
        this.depend = depend;
    }  
    /** Gets the depend flag. */
    public boolean getDepend() {
        return depend;
    }
    /** 
     * Set the verbose flag.
     */ 
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }
    /** Gets the verbose flag. */
    public boolean getVerbose() {
        return verbose;
    }
    /**
     * Sets the target VM that the classes will be compiled for. Valid
     * strings are ""1.1"", ""1.2"", and ""1.3"".
     */
    public void setTarget(String target) {
        this.target = target;
    }
    /** Gets the target VM that the classes will be compiled for. */
    public String getTarget() {
        return target;
    }
    /**
     * Include ant's own classpath in this task's classpath?
     */
    public void setIncludeantruntime( boolean include ) {
        includeAntRuntime = include;
    }
    /**
     * Gets whether or not the ant classpath is to be included in the
     * task's classpath.
     */
    public boolean getIncludeantruntime() {
        return includeAntRuntime;
    }
    /**
     * Sets whether or not to include the java runtime libraries to this
     * task's classpath.
     */
    public void setIncludejavaruntime( boolean include ) {
        includeJavaRuntime = include;
    }
    /**
     * Gets whether or not the java runtime should be included in this
     * task's classpath.
     */
    public boolean getIncludejavaruntime() {
        return includeJavaRuntime;
    }
    /**
     * Executes the task.
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a srcdir
        if (src == null) {
            throw new BuildException(""srcdir attribute must be set!"", location);
        }
        String [] list = src.list();
        if (list.length == 0) {
            throw new BuildException(""srcdir attribute must be set!"", location);
        }
        if (destDir != null && !destDir.isDirectory()) {
            throw new BuildException(""destination directory \"""" + destDir + ""\"" does not exist or is not a directory"", location);
        }
        // scan source directories and dest directory to build up 
        // compile lists
        resetFileLists();
        for (int i=0; i<list.length; i++) {
            File srcDir = (File)project.resolveFile(list[i]);
            if (!srcDir.exists()) {
                throw new BuildException(""srcdir \"""" + srcDir.getPath() + ""\"" does not exist!"", location);
            }
            DirectoryScanner ds = this.getDirectoryScanner(srcDir);
            String[] files = ds.getIncludedFiles();
            scanDir(srcDir, destDir != null ? destDir : srcDir, files);
        }
        // compile the source files
        String compiler = project.getProperty(""build.compiler"");
        if (compiler == null) {
            if (Project.getJavaVersion().startsWith(""1.3"")) {
                compiler = ""modern"";
            } else {
                compiler = ""classic"";
            }
        }
        if (compileList.length > 0) {
            CompilerAdapter adapter = CompilerAdapterFactory.getCompiler(
              compiler, this );
            log(""Compiling "" + compileList.length + 
                "" source file""
                + (compileList.length == 1 ? """" : ""s"")
                + (destDir != null ? "" to "" + destDir : """"));
            // now we need to populate the compiler adapter
            adapter.setJavac( this );
            // finally, lets execute the compiler!!
            if (!adapter.execute()) {
                if (failOnError) {
                    throw new BuildException(FAIL_MSG, location);
                }
                else {
                    log(FAIL_MSG, Project.MSG_ERR);
                }
            }
        }
    }
    /**
     * Clear the list of files to be compiled and copied.. 
     */
    protected void resetFileLists() {
        compileList = new File[0];
    }
    /**
     * Scans the directory looking for source files to be compiled.  
     * The results are returned in the class variable compileList
     */
    protected void scanDir(File srcDir, File destDir, String files[]) {
        GlobPatternMapper m = new GlobPatternMapper();
        m.setFrom(""*.java"");
        m.setTo(""*.class"");
        SourceFileScanner sfs = new SourceFileScanner(this);
        File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);
        if (newFiles.length > 0) {
            File[] newCompileList = new File[compileList.length +
                newFiles.length];
            System.arraycopy(compileList, 0, newCompileList, 0,
                    compileList.length);
            System.arraycopy(newFiles, 0, newCompileList,
                    compileList.length, newFiles.length);
            compileList = newCompileList;
        }
    }
    /** Gets the list of files to be compiled. */
    public File[] getFileList() {
        return compileList;
    }
}
"
org.apache.tools.ant.taskdefs.JavacOutputStream,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 */ 
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
/**
 * Serves as an output stream to Javac. This let's us print messages
 * out to the log and detect whether or not Javac had an error
 * while compiling.
 *
 * @author James Duncan Davidson (duncan@x180.com)
 * @deprecated use returnvalue of compile to detect compilation failure.
 */
class JavacOutputStream extends OutputStream {
    private Task task;
    private StringBuffer line;
    private boolean errorFlag = false;
    /**
     * Constructs a new JavacOutputStream with the given task
     * as the output source for messages.
     */
    JavacOutputStream(Task task) {
        this.task = task;
        line = new StringBuffer();
    }
    /**
     * Write a character to the output stream. This method looks
     * to make sure that there isn't an error being reported and
     * will flush each line of input out to the project's log stream.
     */
    public void write(int c) throws IOException {
        char cc = (char)c;
        if (cc == '\r' || cc == '\n') {
            // line feed
            if (line.length() > 0) {
                processLine();
            }
        } else {
            line.append(cc);
        }
    }
    /**
     * Processes a line of input and determines if an error occured.
     */
    private void processLine() {
        String s = line.toString();
        if (s.indexOf(""error"") > -1) {
            errorFlag = true;
        }
        task.log(s);
        line = new StringBuffer();
    }
    /**
     * Returns the error status of the compile. If no errors occured,
     * this method will return false, else this method will return true.
     */
    boolean getErrorFlag() {
        return errorFlag;
    }
}
"
org.apache.tools.ant.taskdefs.Javadoc,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.*;
/**
 * This task makes it easy to generate Javadoc documentation for a collection
 * of source code.
 *
 * <P>Current known limitations are:
 *
 * <P><UL>
 *    <LI>patterns must be of the form ""xxx.*"", every other pattern doesn't
 *        work.
 *    <LI>the java comment-stripper reader is horribly slow
 *    <LI>there is no control on arguments sanity since they are left
 *        to the javadoc implementation.
 *    <LI>argument J in javadoc1 is not supported (what is that for anyway?)
 * </UL>
 *
 * <P>If no <CODE>doclet</CODE> is set, then the <CODE>version</CODE> and
 * <CODE>author</CODE> are by default <CODE>""yes""</CODE>.
 *
 * <P>Note: This task is run on another VM because the Javadoc code calls
 * <CODE>System.exit()</CODE> which would break Ant functionality.
 *
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Patrick Chanezon <a href=""mailto:chanezon@netscape.com"">chanezon@netscape.com</a>
 * @author Ernst de Haan <a href=""mailto:ernst@jollem.com"">ernst@jollem.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Javadoc extends Task {
    public class DocletParam {
        private String name;
        private String value;
        public void setName(String name) {
            this.name = name;
        }
        public String getName() {
            return name;
        }
        public void setValue(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
    }
    public class DocletInfo {
        private String name;
        private Path path;
        private Vector params = new Vector();
        public void setName(String name) {
            this.name = name;
        }
        public String getName() {
            return name;
        }
        public void setPath(Path path) {
            if (this.path == null) {
                this.path = path;
            } else {
                this.path.append(path);
            }
        }
        public Path getPath() {
            return path;
        }
        public Path createPath() {
            if (path == null) {
                path = new Path(getProject());
            }
            return path.createPath();
        }
        /**
         * Adds a reference to a CLASSPATH defined elsewhere.
         */
        public void setPathRef(Reference r) {
            createPath().setRefid(r);
        }
        public DocletParam createParam() {
            DocletParam param = new DocletParam();
            params.addElement(param);
            return param;
        }
        public Enumeration getParams() {
            return params.elements();
        }
    }
    private Commandline cmd = new Commandline();
    private static boolean javadoc1 = 
        (Project.getJavaVersion() == Project.JAVA_1_1);
    private void addArgIf(boolean b, String arg) {
        if (b) {
            cmd.createArgument().setValue(arg);
        }
    }
    private void add12ArgIfNotEmpty(String key, String value) {
        if (!javadoc1) {
            if (value != null && value.length() != 0) {
                cmd.createArgument().setValue(key);
                cmd.createArgument().setValue(value);
            } else {
                project.log(this, 
                            ""Warning: Leaving out empty argument '"" + key + ""'"", 
                            Project.MSG_WARN);
            }
        } 
    }
    private void add11ArgIf(boolean b, String arg) {
        if (javadoc1 && b) {
            cmd.createArgument().setValue(arg);
        }
    }
    private void add12ArgIf(boolean b, String arg) {
        if (!javadoc1 && b) {
            cmd.createArgument().setValue(arg);
        }
    }
    private boolean foundJavaFile = false;
    private boolean failOnError = false;
    private Path sourcePath = null;
    private File destDir = null;
    private String sourceFiles = null;
    private String packageNames = null;
	private String excludePackageNames = null;
    private boolean author = true;
    private boolean version = true;
    private DocletInfo doclet = null;
    private Path classpath = null;
    private Path bootclasspath = null;
    private String group = null;
    private Vector compileList = new Vector(10);
    private String packageList = null;
    private Vector links = new Vector(2);
    private Vector groups = new Vector(2);
	private boolean useDefaultExcludes = true;
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
       this.useDefaultExcludes = useDefaultExcludes;
    }
    public void setMaxmemory(String max){
        if(javadoc1){
            cmd.createArgument().setValue(""-J-mx"" + max);
        } else{
            cmd.createArgument().setValue(""-J-Xmx"" + max);
        }
    }
    public void setAdditionalparam(String add){
        cmd.createArgument().setLine(add);
    }
    public void setSourcepath(Path src) {
        if (sourcePath == null) {
            sourcePath = src;
        } else {
            sourcePath.append(src);
        }
    }
    public Path createSourcepath() {
        if (sourcePath == null) {
            sourcePath = new Path(project);
        }
        return sourcePath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setSourcepathRef(Reference r) {
        createSourcepath().setRefid(r);
    }
    public void setDestdir(File dir) {
        destDir = dir;
        cmd.createArgument().setValue(""-d"");
        cmd.createArgument().setFile(destDir);
    }
    public void setSourcefiles(String src) {
        sourceFiles = src;
    }
    public void setPackagenames(String src) {
        packageNames = src;
    }
	public void setExcludePackageNames(String src) {
		excludePackageNames = src;
	}
    public void setOverview(File f) {
        if (!javadoc1) {
            cmd.createArgument().setValue(""-overview"");
            cmd.createArgument().setFile(f);
        }
    }
    public void setPublic(boolean b) {
        addArgIf(b, ""-public"");
    }
    public void setProtected(boolean b) {
        addArgIf(b, ""-protected"");
    }
    public void setPackage(boolean b) {
        addArgIf(b, ""-package"");
    }
    public void setPrivate(boolean b) {
        addArgIf(b, ""-private"");
    }
    public void setDoclet(String src) {
        if (doclet == null) {
            doclet = new DocletInfo();
        }
        doclet.setName(src);
    }
    public void setDocletPath(Path src) {
        if (doclet == null) {
            doclet = new DocletInfo();
        }
        doclet.setPath(src);
    }
    public void setDocletPathRef(Reference r) {
        if (doclet == null) {
            doclet = new DocletInfo();
        }
        doclet.createPath().setRefid(r);
    }
    public DocletInfo createDoclet() {
        doclet = new DocletInfo();
        return doclet;
    }
    public void setOld(boolean b) {
        add12ArgIf(b, ""-1.1"");
    }
    public void setClasspath(Path src) {
        if (classpath == null) {
            classpath = src;
        } else {
            classpath.append(src);
        }
    }
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }
        return classpath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    public void setBootclasspath(Path src) {
        if (bootclasspath == null) {
            bootclasspath = src;
        } else {
            bootclasspath.append(src);
        }
    }
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(project);
        }
        return bootclasspath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }
    public void setExtdirs(String src) {
        if (!javadoc1) {
            cmd.createArgument().setValue(""-extdirs"");
            cmd.createArgument().setValue(src);
        }
    }
    public void setVerbose(boolean b) {
        add12ArgIf(b, ""-verbose"");
    }
    public void setLocale(String src) {
        if (!javadoc1) {
            cmd.createArgument().setValue(""-locale"");
            cmd.createArgument().setValue(src);
        }
    }
    public void setEncoding(String enc) {
        cmd.createArgument().setValue(""-encoding"");
        cmd.createArgument().setValue(enc);
    }
    public void setVersion(boolean src) {
        version = src;
    }
    public void setUse(boolean b) {
        add12ArgIf(b, ""-use"");
    }
    public void setAuthor(boolean src) {
        author = src;
    }
    public void setSplitindex(boolean b) {
        add12ArgIf(b, ""-splitindex"");
    }
    public void setWindowtitle(String src) {
        add12ArgIfNotEmpty(""-windowtitle"", src);
    }
    public void setDoctitle(String src) {
        add12ArgIfNotEmpty(""-doctitle"", src);
    }
    public void setHeader(String src) {
        add12ArgIfNotEmpty(""-header"", src);
    }
    public void setFooter(String src) {
        add12ArgIfNotEmpty(""-footer"", src);
    }
    public void setBottom(String src) {
        add12ArgIfNotEmpty(""-bottom"", src);
    }
    public void setLinkoffline(String src) {
        if (!javadoc1) {
            LinkArgument le = createLink();
            le.setOffline(true);
            String linkOfflineError = ""The linkoffline attribute must include a URL and "" + 
                ""a package-list file location separated by a space"";
            if (src.trim().length() == 0) {
                throw new BuildException(linkOfflineError);
            }                
            StringTokenizer tok = new StringTokenizer(src, "" "", false);
            le.setHref(tok.nextToken());
            if (!tok.hasMoreTokens()) {
                throw new BuildException(linkOfflineError);
            }                                        
            le.setPackagelistLoc(tok.nextToken());
        }
    }
    public void setGroup(String src) {
        group = src;
    }
    public void setLink(String src) {
        if (!javadoc1) {
            createLink().setHref(src);
        }
    }
    public void setNodeprecated(boolean b) {
        addArgIf(b, ""-nodeprecated"");
    }
    public void setNodeprecatedlist(boolean b) {
        add12ArgIf(b, ""-nodeprecatedlist"");
    }
    public void setNotree(boolean b) {
        addArgIf(b, ""-notree"");
    }
    public void setNoindex(boolean b) {
        addArgIf(b, ""-noindex"");
    }
    public void setNohelp(boolean b) {
        add12ArgIf(b, ""-nohelp"");
    }
    public void setNonavbar(boolean b) {
        add12ArgIf(b, ""-nonavbar"");
    }
    public void setSerialwarn(boolean b) {
        add12ArgIf(b, ""-serialwarn"");
    }
    public void setStylesheetfile(File f) {
        if (!javadoc1) {
            cmd.createArgument().setValue(""-stylesheetfile"");
            cmd.createArgument().setFile(f);
        }
    }
    public void setHelpfile(File f) {
        if (!javadoc1) {
            cmd.createArgument().setValue(""-helpfile"");
            cmd.createArgument().setFile(f);
        }
    }
    public void setDocencoding(String enc) {
        cmd.createArgument().setValue(""-docencoding"");
        cmd.createArgument().setValue(enc);
    }
    public void setPackageList(String src) {
        packageList = src;
    }
    public LinkArgument createLink() {
        LinkArgument la = new LinkArgument();
        links.addElement(la);
        return la;
    }
    public class LinkArgument {
        private String href;
        private boolean offline = false;
        private String packagelistLoc;
        public LinkArgument() {
        }
        public void setHref(String hr) {
            href = hr;
        }
        public String getHref() {
            return href;
        }
        public void setPackagelistLoc(String src) {
            packagelistLoc = src;
        }
        public String getPackagelistLoc() {
            return packagelistLoc;
        }
        public void setOffline(boolean offline) {
            this.offline = offline;
        }
        public boolean isLinkOffline() {
            return offline;
        }
    }
    public GroupArgument createGroup() {
        GroupArgument ga = new GroupArgument();
        groups.addElement(ga);
        return ga;
    }
    public class GroupArgument {
        private String title;
        private String packages;
        public GroupArgument() {
        }
        public void setTitle(String src) {
            title = src;
        }
        public String getTitle() {
            return title;
        }
        public void setPackages(String src) {
            packages = src;
        }
        public String getPackages() {
            return packages;
        }
    }
    public void setCharset(String src) {
        this.add12ArgIfNotEmpty(""-charset"", src);
    }
    /**
     * Should the build process fail if javadoc fails (as indicated by
     * a non zero return code)?
     *
     * <p>Default is false.</p>
     */
    public void setFailonerror(boolean b) {
        failOnError = b;
    }
    public void execute() throws BuildException {
        if (""javadoc2"".equals(taskType)) {
            log(""!! javadoc2 is deprecated. Use javadoc instead. !!"");
        }
        if (sourcePath == null) {
            String msg = ""sourcePath attribute must be set!"";
            throw new BuildException(msg);
        }
        log(""Generating Javadoc"", Project.MSG_INFO);
        Commandline toExecute = (Commandline)cmd.clone();
        toExecute.setExecutable(""javadoc"");
// ------------------------------------------------ general javadoc arguments
        if (classpath == null)
            classpath = Path.systemClasspath;
        else
            classpath = classpath.concatSystemClasspath(""ignore"");
        if (!javadoc1) {
            toExecute.createArgument().setValue(""-classpath"");
            toExecute.createArgument().setPath(classpath);
            toExecute.createArgument().setValue(""-sourcepath"");
            toExecute.createArgument().setPath(sourcePath);
        } else {
            toExecute.createArgument().setValue(""-classpath"");
            toExecute.createArgument().setValue(sourcePath.toString() +
                                                System.getProperty(""path.separator"") + classpath.toString());
        }
        if (version && doclet == null)
            toExecute.createArgument().setValue(""-version"");
        if (author && doclet == null)
            toExecute.createArgument().setValue(""-author"");
        if (javadoc1 || doclet == null) {
            if (destDir == null) {
                String msg = ""destDir attribute must be set!"";
                throw new BuildException(msg);
            }
        }
// --------------------------------- javadoc2 arguments for default doclet
// XXX: how do we handle a custom doclet?
        if (!javadoc1) {
            if (doclet != null) {
                if (doclet.getName() == null) {
                    throw new BuildException(""The doclet name must be specified."", location);
                }
                else {                
                    toExecute.createArgument().setValue(""-doclet"");
                    toExecute.createArgument().setValue(doclet.getName());
                    if (doclet.getPath() != null) {
                        toExecute.createArgument().setValue(""-docletpath"");
                        toExecute.createArgument().setPath(doclet.getPath());
                    }
                    for (Enumeration e = doclet.getParams(); e.hasMoreElements();) {
                        DocletParam param = (DocletParam)e.nextElement();
                        if (param.getName() == null) {
                            throw new BuildException(""Doclet parameters must have a name"");
                        }
                        toExecute.createArgument().setValue(param.getName());
                        if (param.getValue() != null) {
                            toExecute.createArgument().setValue(param.getValue());
                        }
                    }                        
                }
            } 
            if (bootclasspath != null) {
                toExecute.createArgument().setValue(""-bootclasspath"");
                toExecute.createArgument().setPath(bootclasspath);
            }
            // add the links arguments
            if (links.size() != 0) {
                for (Enumeration e = links.elements(); e.hasMoreElements(); ) {
                    LinkArgument la = (LinkArgument)e.nextElement();
                    if (la.getHref() == null) {
                        throw new BuildException(""Links must provide the URL to the external class documentation."");
                    }
                    if (la.isLinkOffline()) {
                        String packageListLocation = la.getPackagelistLoc();
                        if (packageListLocation == null) {
                            throw new BuildException(""The package list location for link "" + la.getHref() +
                                                     "" must be provided because the link is offline"");
                        }
                        toExecute.createArgument().setValue(""-linkoffline"");
                        toExecute.createArgument().setValue(la.getHref());
                        toExecute.createArgument().setValue(packageListLocation);
                    }
                    else {
                        toExecute.createArgument().setValue(""-link"");
                        toExecute.createArgument().setValue(la.getHref());
                    }
                }
            }                                   
            // add the single group arguments
            // Javadoc 1.2 rules:
            //   Multiple -group args allowed.
            //   Each arg includes 3 strings: -group [name] [packagelist].
            //   Elements in [packagelist] are colon-delimited.
            //   An element in [packagelist] may end with the * wildcard.
            // Ant javadoc task rules for group attribute:
            //   Args are comma-delimited.
            //   Each arg is 2 space-delimited strings.
            //   E.g., group=""XSLT_Packages org.apache.xalan.xslt*,XPath_Packages orgapache.xalan.xpath*""
            if (group != null) {
                StringTokenizer tok = new StringTokenizer(group, "","", false);
                while (tok.hasMoreTokens()) {
                    String grp = tok.nextToken().trim();
                    int space = grp.indexOf("" "");
                    if (space > 0){
                        String name = grp.substring(0, space);
                        String pkgList = grp.substring(space + 1);
                        toExecute.createArgument().setValue(""-group"");
                        toExecute.createArgument().setValue(name);
                        toExecute.createArgument().setValue(pkgList);
                    }
                }
            }
            // add the group arguments
            if (groups.size() != 0) {
                for (Enumeration e = groups.elements(); e.hasMoreElements(); ) {
                    GroupArgument ga = (GroupArgument)e.nextElement();
                    String title = ga.getTitle();
                    String packages = ga.getPackages();
                    if (title == null || packages == null) {
                        throw new BuildException(""The title and packages must be specified for group elements."");
                    }
                    toExecute.createArgument().setValue(""-group"");
                    toExecute.createArgument().setValue(title);
                    toExecute.createArgument().setValue(packages);
                }
            }
        }
        if ((packageNames != null) && (packageNames.length() > 0)) {
            Vector packages = new Vector();
            StringTokenizer tok = new StringTokenizer(packageNames, "","", false);
            while (tok.hasMoreTokens()) {
                String name = tok.nextToken().trim();
                if (name.endsWith("".*"")) {
                    packages.addElement(name);
                } else {
                    toExecute.createArgument().setValue(name);
                }
            }
			Vector excludePackages = new Vector();
			if ((excludePackageNames != null) && (excludePackageNames.length() > 0)) {
				StringTokenizer exTok = new StringTokenizer(excludePackageNames, "","", false);
				while (exTok.hasMoreTokens()) {
					excludePackages.addElement(exTok.nextToken().trim());
				}
			}
            if (packages.size() > 0) {
                evaluatePackages(toExecute, sourcePath, packages, excludePackages);
            }
        }
        if ((sourceFiles != null) && (sourceFiles.length() > 0)) {
            StringTokenizer tok = new StringTokenizer(sourceFiles, "","", false);
            while (tok.hasMoreTokens()) {
                toExecute.createArgument().setValue(tok.nextToken().trim());
            }
        }
        if (packageList != null) {
            toExecute.createArgument().setValue(""@"" + packageList);
        }
        log(""Javadoc args: "" + toExecute, Project.MSG_VERBOSE);
        log(""Javadoc execution"", Project.MSG_INFO);
        JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
        JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
        Execute exe = new Execute(new PumpStreamHandler(out, err));
        exe.setAntRun(project);
        exe.setWorkingDirectory(project.getBaseDir());
        try {
            exe.setCommandline(toExecute.getCommandline());
            int ret = exe.execute();
            if (ret != 0 && failOnError) {
                throw new BuildException(""Javadoc returned ""+ret, location);
            }
        } catch (IOException e) {
            throw new BuildException(""Javadoc failed: "" + e, e, location);
        } finally {
            out.logFlush();
            err.logFlush();
            try {
                out.close();
                err.close();
            } catch (IOException e) {}
        }
    }
    /**
     * Given a source path, a list of package patterns, fill the given list
     * with the packages found in that path subdirs matching one of the given
     * patterns.
     */
    private void evaluatePackages(Commandline toExecute, Path sourcePath, 
                                  Vector packages, Vector excludePackages) {
        log(""Source path = "" + sourcePath.toString(), Project.MSG_VERBOSE);
        log(""Packages = "" + packages, Project.MSG_VERBOSE);
		log(""Exclude Packages = "" + excludePackages, Project.MSG_VERBOSE);
        Vector addedPackages = new Vector();
        String[] list = sourcePath.list();
        if (list == null) list = new String[0];
        FileSet fs = new FileSet();
        fs.setDefaultexcludes(useDefaultExcludes);
        Enumeration e = packages.elements();
        while (e.hasMoreElements()) {
            String pkg = (String)e.nextElement();
            pkg = pkg.replace('.','/');
            if (pkg.endsWith(""*"")) {
                pkg += ""*"";
            }
            fs.createInclude().setName(pkg);
        } // while
		e = excludePackages.elements();
		while (e.hasMoreElements()) {
			String pkg = (String)e.nextElement();
			pkg = pkg.replace('.','/');
			if (pkg.endsWith(""*"")) {
				pkg += ""*"";
			}
			fs.createExclude().setName(pkg);
		}
        for (int j=0; j<list.length; j++) {
            File source = project.resolveFile(list[j]);
            fs.setDir(source);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            String[] packageDirs = ds.getIncludedDirectories();
            for (int i=0; i<packageDirs.length; i++) {
                File pd = new File(source, packageDirs[i]);
                String[] files = pd.list(new FilenameFilter () {
                    public boolean accept(File dir1, String name) {
                        if (name.endsWith("".java"")) {
                            return true;
                        }
                        return false;	// ignore dirs
                    }
                });
                if (files.length > 0) {
                    String pkgDir = packageDirs[i].replace('/','.').replace('\\','.');
                    if (!addedPackages.contains(pkgDir)) {
                        toExecute.createArgument().setValue(pkgDir);
                        addedPackages.addElement(pkgDir);
                    }
                }
            }
        }
    }
    private class JavadocOutputStream extends LogOutputStream {
        JavadocOutputStream(int level) {
            super(Javadoc.this, level);
        }
        //
        // Override the logging of output in order to filter out Generating
        // messages.  Generating messages are set to a priority of VERBOSE
        // unless they appear after what could be an informational message.
        //
        private String queuedLine = null;
        protected void processLine(String line, int messageLevel) {
            if (messageLevel == Project.MSG_INFO && line.startsWith(""Generating "")) {
                if (queuedLine != null) {
                    super.processLine(queuedLine, Project.MSG_VERBOSE);
                }
                queuedLine = line;
            } else {
                if (queuedLine != null) {
                    if (line.startsWith(""Building ""))
                        super.processLine(queuedLine, Project.MSG_VERBOSE);
                    else
                        super.processLine(queuedLine, Project.MSG_INFO);
                    queuedLine = null;
                }
                super.processLine(line, messageLevel);
            }
        }
        protected void logFlush() {
            if (queuedLine != null) {
                super.processLine(queuedLine, Project.MSG_VERBOSE);
                queuedLine = null;
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Jikes,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import org.apache.tools.ant.*;
import java.util.Random;
/**
 * Encapsulates a Jikes compiler, by
 * directly executing an external process.
 * @author skanthak@muehlheim.de
 * @deprecated merged into the class Javac.
 */
public class Jikes {
    protected JikesOutputParser jop;
    protected String command;
    protected Project project;
    /**
     * Constructs a new Jikes obect.
     * @param jop - Parser to send jike's output to
     * @param command - name of jikes executeable
     */
    protected Jikes(JikesOutputParser jop,String command, Project project) {
        super();
        this.jop = jop;
        this.command = command;
        this.project = project;
    }
    /**
     * Do the compile with the specified arguments.
     * @param args - arguments to pass to process on command line
     */
    protected void compile(String[] args) {
        String[] commandArray = null;
        File tmpFile = null;
        try {
            String myos = System.getProperty(""os.name"");
            // Windows has a 32k limit on total arg size, so
            // create a temporary file to store all the arguments
            // There have been reports that 300 files could be compiled
            // so 250 is a conservative approach
            if (myos.toLowerCase().indexOf(""windows"") >= 0 
                && args.length > 250) {
                PrintWriter out = null;
                try {
                    tmpFile = new File(""jikes""+(new Random(System.currentTimeMillis())).nextLong());
                    out = new PrintWriter(new FileWriter(tmpFile));
                    for (int i = 0; i < args.length; i++) {
                        out.println(args[i]);
                    }
                    out.flush();
                    commandArray = new String[] { command, 
                                                  ""@"" + tmpFile.getAbsolutePath()};
                } catch (IOException e) {
                    throw new BuildException(""Error creating temporary file"", e);
                } finally {
                    if (out != null) {
                        try {out.close();} catch (Throwable t) {}
                    }
                }
            } else {
                commandArray = new String[args.length+1];
                commandArray[0] = command;
                System.arraycopy(args,0,commandArray,1,args.length);
            }
            // We assume, that everything jikes writes goes to
            // standard output, not to standard error. The option
            // -Xstdout that is given to Jikes in Javac.doJikesCompile()
            // should guarantee this. At least I hope so. :)
            try {
                Execute exe = new Execute(jop);
                exe.setAntRun(project);
                exe.setWorkingDirectory(project.getBaseDir());
                exe.setCommandline(commandArray);
                exe.execute();
            } catch (IOException e) {
                throw new BuildException(""Error running Jikes compiler"", e);
            }
        } finally {
            if (tmpFile != null) {
                tmpFile.delete();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.JikesOutputParser,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
/**
 * Parses output from jikes and
 * passes errors and warnings
 * into the right logging channels of Project.
 *
 * TODO: 
 * Parsing could be much better
 * @author skanthak@muehlheim.de
 * @deprecated use Jikes' exit value to detect compilation failure.
 */
public class JikesOutputParser implements ExecuteStreamHandler {
    protected Task task;
    protected boolean errorFlag = false; // no errors so far
    protected int errors,warnings;
    protected boolean error = false;
    protected boolean emacsMode;
    protected BufferedReader br;
    /**
     * Ignore.
     */
    public void setProcessInputStream(OutputStream os) {}
    /**
     * Ignore.
     */
    public void setProcessErrorStream(InputStream is) {}
    /**
     * Set the inputstream
     */
    public void setProcessOutputStream(InputStream is) throws IOException {
        br = new BufferedReader(new InputStreamReader(is));
    }
    /**
     * Invokes parseOutput.
     */
    public void start() throws IOException {
        parseOutput(br);
    }
    /**
     * Ignore.
     */
    public void stop() {}
    /**
     * Construct a new Parser object
     * @param task - task in whichs context we are called
     */
    protected JikesOutputParser(Task task, boolean emacsMode) {
        super();
        this.task = task;
        this.emacsMode = emacsMode;
    }
    /**
     * Parse the output of a jikes compiler
     * @param reader - Reader used to read jikes's output
     */
    protected void parseOutput(BufferedReader reader) throws IOException {
       if (emacsMode)
           parseEmacsOutput(reader);
       else
           parseStandardOutput(reader);
    }
    private void parseStandardOutput(BufferedReader reader) throws IOException {
        String line;
        String lower;
        // We assume, that every output, jike does, stands for an error/warning
        // XXX 
        // Is this correct?
        // TODO:
        // A warning line, that shows code, which contains a variable
        // error will cause some trouble. The parser should definitely
        // be much better.
        while ((line = reader.readLine()) != null) {
            lower = line.toLowerCase();
            if (line.trim().equals(""""))
                continue;
            if (lower.indexOf(""error"") != -1)
                setError(true);
            else if (lower.indexOf(""warning"") != -1)
                setError(false);
            else {
                // If we don't know the type of the line
                // and we are in emacs mode, it will be
                // an error, because in this mode, jikes won't
                // always print ""error"", but sometimes other
                // keywords like ""Syntax"". We should look for
                // all those keywords.
                if (emacsMode)
                    setError(true);
            }
            log(line);
        }
    }
    private void parseEmacsOutput(BufferedReader reader) throws IOException {
       // This may change, if we add advanced parsing capabilities.
       parseStandardOutput(reader);
    }
    private void setError(boolean err) {
        error = err;
        if(error)
            errorFlag = true;
    }
    private void log(String line) {
       if (!emacsMode) {
           task.log("""", (error ? Project.MSG_ERR : Project.MSG_WARN));
       }
       task.log(line, (error ? Project.MSG_ERR : Project.MSG_WARN));
    }
    /**
     * Indicate if there were errors during the compile
     * @return if errors ocured
     */
    protected boolean getErrorFlag() {
        return errorFlag;
    }
}
"
org.apache.tools.ant.taskdefs.KeySubst,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.*;
/**
 * Keyword substitution. Input file is written to output file.
 * Do not make input file same as output file.
 * Keywords in input files look like this: @foo@. See the docs for the 
 * setKeys method to understand how to do the substitutions.
 *
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 *
 * @deprecated KeySubst is deprecated. Use Filter + CopyDir instead.
 */
public class KeySubst extends Task {
    private File source = null;
    private File dest = null;
    private String sep = ""*"";
    private Hashtable replacements = new Hashtable();
    /**
        Do the execution.
    */
    public void execute() throws BuildException {
        log(""!! KeySubst is deprecated. Use Filter + CopyDir instead. !!"");
        log(""Performing Substitions"");
        if ( source == null || dest == null ) {
            log(""Source and destinations must not be null"");
            return;            
        }
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            br = new BufferedReader(new FileReader(source));
            dest.delete();
            bw = new BufferedWriter(new FileWriter(dest));
            String line = null;
            String newline = null;
            int length;
            line = br.readLine();
            while (line != null) {
                if ( line.length() == 0 ) {
                    bw.newLine();
                } else {
                    newline = KeySubst.replace ( line, replacements );
                    bw.write ( newline );
                    bw.newLine();
                }
                line = br.readLine();
            }
            bw.flush();
            bw.close();
            br.close();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }       
    }
    /**
        Set the source file.
    */
    public void setSrc(String s) {
        this.source=project.resolveFile(s);
    }
    /**
        Set the destination file.
    */
    public void setDest(String dest) {
        this.dest = project.resolveFile(dest);
    }
    /**
        Sets the seperator between name=value arguments
        in setKeys(). By default it is ""*"".
    */
    public void setSep(String sep) {
        this.sep = sep;
    }
    /**
        Format string is like this:
        <p>
        name=value*name2=value
        <p>
        Names are case sensitive.
        <p>
        Use the setSep() method to change the * to something else
        if you need to use * as a name or value.
    */
    public void setKeys(String keys) {
        if (keys != null && keys.length() > 0) {
            StringTokenizer tok =
            new StringTokenizer(keys, this.sep, false);
            while (tok.hasMoreTokens()) {
                String token = tok.nextToken().trim();
                StringTokenizer itok =
                new StringTokenizer(token, ""="", false);
                String name = itok.nextToken();
                String value = itok.nextToken();
//                log ( ""Name: "" + name );
//                log ( ""Value: "" + value );
                replacements.put ( name, value );
            }
        }
    }
    public static void main(String[] args)
    {
        try{
        Hashtable hash = new Hashtable();
        hash.put ( ""VERSION"", ""1.0.3"" );
        hash.put ( ""b"", ""ffff"" );
        System.out.println ( KeySubst.replace ( ""$f ${VERSION} f ${b} jj $"", hash ) );
        }catch ( Exception e)
        {
            e.printStackTrace();
        }
    }
    /**
        Does replacement on text using the hashtable of keys.
        @returns the string with the replacements in it.
    */
    public static String replace ( String origString, Hashtable keys )
        throws BuildException
    {
        StringBuffer finalString=new StringBuffer();
        int index=0;
        int i = 0;
        String key = null;
        while ((index = origString.indexOf(""${"", i)) > -1) {
            key = origString.substring(index + 2, origString.indexOf(""}"", index+3));
            finalString.append (origString.substring(i, index));
            if ( keys.containsKey ( key ) ) {
                finalString.append (keys.get(key));
            } else {
                finalString.append ( ""${"" );
                finalString.append ( key );
                finalString.append ( ""}"" );
            }
            i = index + 3 + key.length();
        }
        finalString.append (origString.substring(i));
        return finalString.toString();
    }
}
"
org.apache.tools.ant.taskdefs.LogOutputStream,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import java.io.IOException;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
/**
 * Logs each line written to this stream to the log system of ant.
 *
 * Tries to be smart about line separators.<br>
 * TODO: This class can be split to implement other line based processing
 * of data written to the stream.
 *
 * @author thomas.haas@softwired-inc.com
 */
public class LogOutputStream extends OutputStream {
    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    private boolean skip = false;
    private Task task;
    private int level = Project.MSG_INFO;
    /**
     * Creates a new instance of this class.
     *
     * @param task the task for whom to log
     * @param level loglevel used to log data written to this stream.
     */
    public LogOutputStream(Task task, int level) {
        this.task = task;
        this.level = level;
    }
    /**
     * Write the data to the buffer and flush the buffer, if a line
     * separator is detected.
     *
     * @param cc data to log (byte).
     */
    public void write(int cc) throws IOException {
        final byte c = (byte)cc;
        if ((c == '\n') || (c == '\r')) {
            if (!skip) processBuffer();
        } else buffer.write(cc);
        skip = (c == '\r');
    }
    /**
     * Converts the buffer to a string and sends it to <code>processLine</code>
     */
    protected void processBuffer() {
        processLine(buffer.toString());
        buffer.reset();
    }
    /**
     * Logs a line to the log system of ant.
     *
     * @param line the line to log.
     */
    protected void processLine(String line) {
        processLine(line, level);
    }
    /**
     * Logs a line to the log system of ant.
     *
     * @param line the line to log.
     */
    protected void processLine(String line, int level) {
        task.log(line, level);
    }
    /**
     * Writes all remaining
     */
    public void close() throws IOException {
        if (buffer.size() > 0) processBuffer();
        super.close();
    }
    public int getMessageLevel() {
        return level;
    }
}
"
org.apache.tools.ant.taskdefs.LogStreamHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import java.io.OutputStream;
import java.io.InputStream;
/**
 * Logs standard output and error of a subprocess to the log system of ant.
 *
 * @author thomas.haas@softwired-inc.com
 */
public class LogStreamHandler extends PumpStreamHandler {
    /**
     * Creates a new instance of this class.
     *
     * @param task the task for whom to log
     * @param outlevel the loglevel used to log standard output
     * @param errlevel the loglevel used to log standard error
     */
    public LogStreamHandler(Task task, int outlevel, int errlevel) {
        super(new LogOutputStream(task, outlevel),
              new LogOutputStream(task, errlevel));
    }
}
"
org.apache.tools.ant.taskdefs.MatchingTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.*;
/**
 * This is an abstract task that should be used by all those tasks that 
 * require to include or exclude files based on pattern matching.
 *
 * @author Arnout J. Kuiper <a href=""mailto:ajkuiper@wxs.nl"">ajkuiper@wxs.nl</a> 
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public abstract class MatchingTask extends Task {
    protected boolean useDefaultExcludes = true;
    protected FileSet fileset = new FileSet();
    /**
     * add a name entry on the include list
     */
    public PatternSet.NameEntry createInclude() {
        return fileset.createInclude();
    }
    /**
     * add a name entry on the exclude list
     */
    public PatternSet.NameEntry createExclude() {
        return fileset.createExclude();
    }
    /**
     * add a set of patterns
     */
    public PatternSet createPatternSet() {
        return fileset.createPatternSet();
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        fileset.setIncludes(includes);
    }
    /**
     * Set this to be the items in the base directory that you want to be
     * included. You can also specify ""*"" for the items (ie: items=""*"") 
     * and it will include all the items in the base directory.
     *
     * @param itemString the string containing the files to include.
     */
    public void XsetItems(String itemString) {
        log(""The items attribute is deprecated. "" +
            ""Please use the includes attribute."",
            Project.MSG_WARN);
        if (itemString == null || itemString.equals(""*"") 
            || itemString.equals(""."")) {
            createInclude().setName(""**"");
        } else {
            StringTokenizer tok = new StringTokenizer(itemString, "", "");
            while (tok.hasMoreTokens()) {
                String pattern = tok.nextToken().trim();
                if (pattern.length() > 0) {
                    createInclude().setName(pattern+""/**"");
                }
            }
        }
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        fileset.setExcludes(excludes);
    }
    /**
     * List of filenames and directory names to not include. They should be 
     * either , or "" "" (space) separated. The ignored files will be logged.
     *
     * @param ignoreString the string containing the files to ignore.
     */
    public void XsetIgnore(String ignoreString) {
        log(""The ignore attribute is deprecated."" + 
            ""Please use the excludes attribute."",
            Project.MSG_WARN);
        if (ignoreString != null && ignoreString.length() > 0) {
            Vector tmpExcludes = new Vector();
            StringTokenizer tok = new StringTokenizer(ignoreString, "", "", false);
            while (tok.hasMoreTokens()) {
                createExclude().setName(""**/""+tok.nextToken().trim()+""/**"");
            }
        }
    }
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        this.useDefaultExcludes = useDefaultExcludes;
    }
    /**
     * Returns the directory scanner needed to access the files to process.
     */
    protected DirectoryScanner getDirectoryScanner(File baseDir) {
        fileset.setDir(baseDir);
        fileset.setDefaultexcludes(useDefaultExcludes);
        return fileset.getDirectoryScanner(project);
    }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param includesfile A string containing the filename to fetch
     * the include patterns from.  
     */
     public void setIncludesfile(File includesfile) {
         fileset.setIncludesfile(includesfile);
     }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param excludesfile A string containing the filename to fetch
     * the include patterns from.  
     */
     public void setExcludesfile(File excludesfile) {
         fileset.setExcludesfile(excludesfile);
     }
}
"
org.apache.tools.ant.taskdefs.Mkdir,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */ 
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.File;
/**
 * Creates a given directory.
 *
 * @author duncan@x180.com
 */
public class Mkdir extends Task {
    private File dir;
    public void execute() throws BuildException {
        if (dir == null) {
            throw new BuildException(""dir attribute is required"", location);
        }
        if (dir.isFile()) {
            throw new BuildException(""Unable to create directory as a file already exists with that name: "" + dir.getAbsolutePath());
        }
        if (!dir.exists()) {
	    boolean result = dir.mkdirs();
	    if (result == false) {
		String msg = ""Directory "" + dir.getAbsolutePath() + "" creation was not "" +
		    ""succesful for an unknown reason"";
		throw new BuildException(msg, location);
	    }
	    log(""Created dir: "" + dir.getAbsolutePath());
	}
    }
    public void setDir(File dir) {
	this.dir = dir;
    }
}
"
org.apache.tools.ant.taskdefs.Move,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.*;
/**
 * Moves a file or directory to a new file or directory.  By default,
 * the destination is overwriten when existing.  When overwrite is
 * turned off, then files are only moved if the source file is 
 * newer than the destination file, or when the destination file does
 * not exist.</p>
 *
 * <p>Source files and directories are only deleted when the file or 
 * directory has been copied to the destination successfully.  Filtering
 * also works.</p>
 *
 * <p>This implementation is based on Arnout Kuiper's initial design
 * document, the following mailing list discussions, and the 
 * copyfile/copydir tasks.</p>
 *
 * @author Glenn McAllister <a href=""mailto:glennm@ca.ibm.com"">glennm@ca.ibm.com</a>
 */
public class Move extends Copy {
    public Move() {
        super();
        forceOverwrite = true;
    }
//************************************************************************
//  protected and private methods
//************************************************************************
    protected void doFileOperations() {
        if (fileCopyMap.size() > 0) {   // files to move
            log(""Moving "" + fileCopyMap.size() + "" files to "" + 
                destDir.getAbsolutePath() );
            Enumeration e = fileCopyMap.keys();
            while (e.hasMoreElements()) {
                String fromFile = (String) e.nextElement();
                String toFile = (String) fileCopyMap.get(fromFile);
                try {
                    log(""Moving "" + fromFile + "" to "" + toFile, verbosity);
                    project.copyFile(fromFile, toFile, filtering, forceOverwrite);
                    File f = new File(fromFile);
                    if (!f.delete()) {
                        throw new BuildException(""Unable to delete file "" + f.getAbsolutePath());
                    }
                } catch (IOException ioe) {
                    String msg = ""Failed to copy "" + fromFile + "" to "" + toFile
                        + "" due to "" + ioe.getMessage();
                    throw new BuildException(msg, ioe, location);
                }
            }
        }
        if (includeEmpty) {
            Enumeration e = dirCopyMap.elements();
            int count = 0;
            while (e.hasMoreElements()) {
                File d = new File((String)e.nextElement());
                if (!d.exists()) {
                    if (!d.mkdirs()) {
                        log(""Unable to create directory "" + d.getAbsolutePath(), Project.MSG_ERR);
                    } else {
                        count++;
                    }
                }
            }
            if (count > 0) {
                log(""Moved "" + count + "" empty directories to "" + destDir.getAbsolutePath());
            }
        }
        if (filesets.size() > 0) {
            Enumeration e = filesets.elements();
            while (e.hasMoreElements()) {
                FileSet fs = (FileSet)e.nextElement();
                File dir = fs.getDir(project);
                if (okToDelete(dir)) {
                    deleteDir(dir);
                }
            }
        }
    }
    /**
     * Its only ok to delete a directory tree if there are 
     * no files in it.
     */
    protected boolean okToDelete(File d) {
        String[] list = d.list();
        if (list == null) return false;     // maybe io error?
        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                if (!okToDelete(f)) return false;
            } else {
                return false;   // found a file
            }
        }
        return true;
    }
    /**
     * Go and delete the directory tree.
     */
    protected void deleteDir(File d) {
        String[] list = d.list();
        if (list == null) return;      // on an io error list() can return null
        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                deleteDir(f);
            } else {
                throw new BuildException(""UNEXPECTED ERROR - The file "" + f.getAbsolutePath() + "" should not exist!"");
            }
        }
        log(""Deleting directory "" + d.getAbsolutePath(), verbosity);
        if (!d.delete()) {
           throw new BuildException(""Unable to delete directory "" + d.getAbsolutePath());
       }
    }
}
"
org.apache.tools.ant.taskdefs.Patch,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import java.io.File;
import java.io.IOException;
/**
 * Task as a layer on top of patch. Patch applies a diff file to an original.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class Patch extends Task {
    private File originalFile;
    private boolean havePatchfile = false;
    private Commandline cmd = new Commandline();
    /**
     * The file to patch.
     */
    public void setOriginalfile(File file) {
        originalFile = file;
    }
    /**
     * The file containing the diff output.
     */
    public void setPatchfile(File file) {
        if (!file.exists()) {
            throw new BuildException(""patchfile ""+file+"" doesn\'t exist"", 
                                     location);
        }
        cmd.createArgument().setValue(""-i"");
        cmd.createArgument().setFile(file);
        havePatchfile = true;
    }
    /**
     * Shall patch write backups.
     */
    public void setBackups(boolean backups) {
        if (backups) {
            cmd.createArgument().setValue(""-b"");
        }
    }
    /**
     * Ignore whitespace differences.
     */
    public void setIgnorewhitespace(boolean ignore) {
        if (ignore) {
            cmd.createArgument().setValue(""-l"");
        }
    }
    /**
     * Strip the smallest prefix containing <i>num</i> leading slashes
     * from filenames.
     *
     * <p>patch's <i>-p</i> option.
     */
    public void setStrip(int num) throws BuildException {
        if (num < 0) {
            throw new BuildException(""strip has to be >= 0"", location);
        }
        cmd.createArgument().setValue(""-p""+num);
    }
    /**
     * Work silently unless an error occurs.
     */
    public void setQuiet(boolean q) {
        if (q) {
            cmd.createArgument().setValue(""-s"");
        }
    }
    /**
     * Assume patch was created with old and new files swapped.
     */
    public void setReverse(boolean r) {
        if (r) {
            cmd.createArgument().setValue(""-R"");
        }
    }
    public void execute() throws BuildException {
        if (!havePatchfile) {
            throw new BuildException(""patchfile argument is required"", 
                                     location);
        } 
        Commandline toExecute = (Commandline)cmd.clone();
        toExecute.setExecutable(""patch"");
        if (originalFile != null) {
            toExecute.createArgument().setFile(originalFile);
        }
        Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO,
                                                       Project.MSG_WARN), 
                                  null);
        exe.setCommandline(toExecute.getCommandline());
        try {
            exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, location);
        }
    }
}// Patch
"
org.apache.tools.ant.taskdefs.Property,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import java.io.*;
import java.util.*;
/**
 * Will set a Project property. Used to be a hack in ProjectHelper
 * Will not override values set by the command line or parent projects.
 *
 * @author costin@dnt.ro
 * @author Sam Ruby <rubys@us.ibm.com>
 * @author Glenn McAllister <glennm@ca.ibm.com>
 */
public class Property extends Task {
    protected String name;
    protected String value;
    protected File file;
    protected String resource;
    protected Path classpath;
    protected String env;
    protected Reference ref = null;
    protected boolean userProperty=false; // set read-only properties
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setLocation(File location) {
        setValue(location.getAbsolutePath());
    }
    public void setValue(String value) {
        this.value = value;
    }
    public String getValue() {
        return value;
    }
    public void setFile(File file) {
        this.file = file;
    }
    public File getFile() {
        return file;
    }
    public void setRefid(Reference ref) {
        this.ref = ref;
    }
    public Reference getRefid() {
        return ref;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public String getResource() {
        return resource;
    }
    public void setEnvironment(String env) {
        this.env = env;
    }
    public String getEnvironment() {
        return env;
    }
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(project);
        }
        return this.classpath.createPath();
    }
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    public void setUserProperty(boolean userProperty) {
        this.userProperty = userProperty;
    }
    public String toString() {
        return value == null ? """" : value;
    }
    public void execute() throws BuildException {
        try {
            if ((name != null) && (value != null)) {
                addProperty(name, value);
            }
            if (file != null) loadFile(file);
            if (resource != null) loadResource(resource);
            if (env != null) loadEnvironment(env);
            if ((name != null) && (ref != null)) {
                Object obj = ref.getReferencedObject(getProject());
                if (obj != null) {
                    addProperty(name, obj.toString());
                }
            }
        } catch (Exception e) {
            throw new BuildException(e, location);
        }
    }
    protected void loadFile (File file) throws BuildException {
        Properties props = new Properties();
        log(""Loading "" + file.getAbsolutePath(), Project.MSG_VERBOSE);
        try {
            if (file.exists()) { 
                FileInputStream fis = new FileInputStream(file);
                try { 
                    props.load(fis);
                } finally {
                    if (fis != null) { 
                        fis.close();
                    }
                }
                addProperties(props);
            } else {
                log(""Unable to find "" + file.getAbsolutePath(), 
                    Project.MSG_VERBOSE);
            }
        } catch(Exception ex) {
            throw new BuildException(ex.getMessage(), ex, location);
        }
    }
    protected void loadResource( String name ) {
        Properties props = new Properties();
        log(""Resource Loading "" + name, Project.MSG_VERBOSE);
        try {
            ClassLoader cL = null; 
            InputStream is = null;
            if (classpath != null) { 
                cL = new AntClassLoader(project, classpath, false); 
            } else { 
                cL = this.getClass().getClassLoader(); 
            } 
            if (cL == null) {
                is = ClassLoader.getSystemResourceAsStream(name);
            } else {
                is = cL.getResourceAsStream(name);
            }
            if (is != null) {
                props.load(is);
                addProperties(props);
            } else {
                log(""Unable to find resource "" + name, Project.MSG_WARN);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    protected void loadEnvironment( String prefix ) {
        Properties props = new Properties();
        if (!prefix.endsWith(""."")) prefix += ""."";
        log(""Loading Environment "" + prefix, Project.MSG_VERBOSE);
        try {
            Vector osEnv = Execute.getProcEnvironment();
            for (Enumeration e = osEnv.elements(); e.hasMoreElements(); ) {
                String entry = (String)e.nextElement();
                int pos = entry.indexOf('=');
                props.put(prefix + entry.substring(0, pos), 
                          entry.substring(pos + 1));
            }
            addProperties(props);
        } catch (Exception ex) {
            throw new BuildException(ex, location);
        }
    }
    protected void addProperties(Properties props) {
        resolveAllProperties(props);
        Enumeration e = props.keys();
        while (e.hasMoreElements()) {
            String name = (String) e.nextElement();
            String value = (String) props.getProperty(name);
            String v = ProjectHelper.replaceProperties(project, value, project.getProperties());
            addProperty(name, value);
        }
    }
    protected void addProperty(String n, String v) {
        if( userProperty ) {
            if (project.getUserProperty(n) == null) {
                project.setUserProperty(n, v);
            } else {
                log(""Override ignored for "" + n, Project.MSG_VERBOSE);
            } 
        } else {
            if (project.getProperty(n) == null) {
                project.setProperty(n, v);
            } else {
                log(""Override ignored for "" + n, Project.MSG_VERBOSE);
            }
        }
    }
    private void resolveAllProperties(Hashtable props) {
        Hashtable unresolvableProperties = new Hashtable();
        for (Enumeration e = props.keys(); e.hasMoreElements(); ) {
            String name = (String) e.nextElement();
            String value = (String) props.get(name);
            boolean resolved = false;
            while (!resolved) { 
                Vector propsInValue = new Vector();
                // assume it will be resolved
                resolved = true;
                boolean unresolvable = false;
                if (extractProperties(value, propsInValue)) {
                    for (int i=0; i < propsInValue.size(); i++) {
                        String elem = (String) propsInValue.elementAt(i);
                        if (elem.equals(name) || unresolvableProperties.containsKey(elem)) {
                            // we won't try further resolving elements with circular 
                            // property dependencies or dependencies on unresolvable elements
                            unresolvable = true;
                            break;
                        }
                        if (project.getProperties().containsKey(elem) ||
                            props.containsKey(elem)) {
                            resolved = false;
                        }
                    }
                }
                if (unresolvable) {
                    unresolvableProperties.put(name, value);
                    resolved = true;
                }
                if (!resolved) {
                    value = ProjectHelper.replaceProperties(project, value,
                                                               project.getProperties());
                    value = ProjectHelper.replaceProperties(project, value, props);
                    props.put(name, value);
                }    
            }
        }
    }
    private boolean extractProperties(String source, Vector properties) {
        // This is an abreviated version of 
        // ProjectHelper.replaceProperties method
        int i=0;
        int prev=0;
        int pos;
        while( (pos=source.indexOf( ""$"", prev )) >= 0 ) {
            if( pos == (source.length() - 1)) {
                prev = pos + 1;
            } else if (source.charAt( pos + 1 ) != '{' ) {
                prev=pos+2;
            } else {
                int endName=source.indexOf( '}', pos );
                String n=source.substring( pos+2, endName );
                properties.addElement(n);
                prev=endName+1;
            }
        }
        return (properties.size() > 0);
    }
}
"
org.apache.tools.ant.taskdefs.PumpStreamHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
/**
 * Copies standard output and error of subprocesses to standard output and
 * error of the parent process.
 *
 * TODO: standard input of the subprocess is not implemented.
 *
 * @author thomas.haas@softwired-inc.com
 */
public class PumpStreamHandler implements ExecuteStreamHandler {
    private Thread inputThread;
    private Thread errorThread;
    private OutputStream out, err;
    public PumpStreamHandler(OutputStream out, OutputStream err) {
        this.out = out;
        this.err = err;
    }
    public PumpStreamHandler(OutputStream outAndErr) {
        this(outAndErr, outAndErr);
    }
    public PumpStreamHandler() {
        this(System.out, System.err);
    }
    public void setProcessOutputStream(InputStream is) {
        createProcessOutputPump(is, out);
    }
    public void setProcessErrorStream(InputStream is) {
        createProcessErrorPump(is, err);
    }
    public void setProcessInputStream(OutputStream os) {
    }
    public void start() {
        inputThread.start();
        errorThread.start();
    }
    public void stop() {
        try {
            inputThread.join();
        } catch(InterruptedException e) {}
        try {
            errorThread.join();
        } catch(InterruptedException e) {}
    }
    protected void createProcessOutputPump(InputStream is, OutputStream os) {
        inputThread = createPump(is, os);
    }
    protected void createProcessErrorPump(InputStream is, OutputStream os) {
        errorThread = createPump(is, os);
    }
    /**
     * Creates a stream pumper to copy the given input stream to the given output stream.
     */
    protected Thread createPump(InputStream is, OutputStream os) {
        final Thread result = new Thread(new StreamPumper(is, os));
        result.setDaemon(true);
        return result;
    }
}
"
org.apache.tools.ant.taskdefs.Rename,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import java.io.File;
/**
 * Renames a file.
 *
 * @author haas@softwired.ch
 *
 * @deprecated The rename task is deprecated.  Use move instead.
 */
public class Rename extends Task {
    private File src;
    private File dest;
    private boolean replace = true;
    /**
     * Sets the file to be renamed.
     * @param src the file to rename
     */
    public void setSrc(String src) {
        this.src = project.resolveFile(src);
    }
    /**
     * Sets the new name of the file.
     * @param dest the new name of the file.
     */
    public void setDest(String dest) {
        this.dest = project.resolveFile(dest);
    }
    /**
     * Sets wheter an existing file should be replaced.
     * @param replace <code>on</code>, if an existing file should be replaced.
     */
    public void setReplace(String replace) {
        this.replace = project.toBoolean(replace);
    }
    /**
     * Renames the file <code>src</code> to <code>dest</code>
     * @exception org.apache.tools.ant.BuildException The exception is
     * thrown, if the rename operation fails.
     */
    public void execute() throws BuildException {
        log(""DEPRECATED - The rename task is deprecated.  Use move instead."");
        if (dest == null) {
            throw new BuildException(""dest attribute is required"", location);
        }
        if (src == null) {
            throw new BuildException(""src attribute is required"", location);
        }
        if (replace && dest.exists()) {
            if (!dest.delete()) {
                throw new BuildException(""Unable to remove existing file "" +
                      dest);
            }
       }
        if (!src.renameTo(dest)) {
            throw new BuildException(""Unable to rename "" + src + "" to "" +
                  dest);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Replace,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import java.io.*;
import java.util.*;
/**
 * Replaces all occurrences of one or more string tokens with given
 * values in the indicated files. Each value can be either a string 
 * or the value of a property available in a designated property file.
 *
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author <a href=""mailto:erik@desknetinc.com"">Erik Langenbach</a>
 */
public class Replace extends MatchingTask {
    private File src = null;
    private NestedString token = null;
    private NestedString value = new NestedString();
    private File propertyFile = null;
    private Properties properties = null;
    private Vector replacefilters = new Vector();
    private File dir = null;
    //Inner class
    public class NestedString {
        private StringBuffer buf = new StringBuffer();
        public void addText(String val) {
            buf.append(val);
        }
        public String getText() {
            return buf.toString();
        }
    }
    //Inner class
    public class Replacefilter
    {
        private String token;
        private String value;
        private String property;
        public void validate() throws BuildException {
            //Validate mandatory attributes
            if (token == null) {
                String message = ""token is a mandatory attribute "" + ""of replacefilter."";
                throw new BuildException(message);
            }
            if ("""".equals(token)) {
                String message =""The token attribute must not be an empty string."";
                throw new BuildException(message);
            }
            //value and property are mutually exclusive attributes
            if ((value != null) && (property != null)) {
                String message = ""Either value or property "" + ""can be specified, but a replacefilter "" + ""element cannot have both."";
                throw new BuildException(message);
            }
            if ((property != null)) {
                //the property attribute must have access to a property file
                if (propertyFile == null) {
                    String message = ""The replacefilter's property attribute "" + ""can only be used with the replacetask's "" + ""propertyFile attribute."";
                    throw new BuildException(message);
                }
                //Make sure property exists in property file
                if (properties == null ||
                        properties.getProperty(property) == null) {
                    String message = ""property \"""" + property + ""\"" was not found in "" + propertyFile.getPath();
                    throw new BuildException(message);
                }
            }
        }
        public String getReplaceValue()
        {
            if (property != null) {
                return (String)properties.getProperty(property);
            }
            else if (value != null) {
                return value;
            }
            else if (Replace.this.value != null) {
                return Replace.this.value.getText();
            }
            else {
                //Default is empty string
                return new String("""");
            }
        }
        public void setToken(String token) {
            this.token = token;
        }
        public String getToken() {
            return token;
        }
        public void setValue(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
        public void setProperty(String property) {
            this.property = property;
        }
        public String getProperty() {
            return property;
        }
    }
    /**
     * Do the execution.
     */
    public void execute() throws BuildException {
        validateAttributes();
        if (propertyFile != null) {
            properties = getProperties(propertyFile);
        }
        validateReplacefilters();
        if (src != null) {
            processFile(src);
        }
        if (dir != null) {
        DirectoryScanner ds = super.getDirectoryScanner(dir);
            String[] srcs = ds.getIncludedFiles();
            for(int i=0; i<srcs.length; i++) {
                File file = new File(dir,srcs[i]);
                processFile(file);
            }
        }
    }
    /**
     * Validate attributes provided for this task in .xml build file.
     *
     * @exception BuildException if any supplied attribute is invalid or any
     * mandatory attribute is missing
     */
    public void validateAttributes() throws BuildException {
        if (src == null && dir == null) {
            String message = ""Either the file or the dir attribute "" + ""must be specified"";
            throw new BuildException(message, location);
        }
        if (propertyFile != null && !propertyFile.exists()) {
            String message = ""Property file "" + propertyFile.getPath() + "" does not exist."";
            throw new BuildException(message, location);
        }
        if (token == null && replacefilters.size() == 0) {
            String message = ""Either token or a nested replacefilter ""
                + ""must be specified"";
            throw new BuildException(message, location);
        }
        if (token != null && """".equals(token.getText())) {
            String message =""The token attribute must not be an empty string."";
            throw new BuildException(message, location);
        }
    }
    /**
     * Validate nested elements.
     *
     * @exception BuildException if any supplied attribute is invalid or any
     * mandatory attribute is missing
     */
    public void validateReplacefilters()
            throws BuildException {
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter element = (Replacefilter) replacefilters.elementAt(i);
            element.validate();
        }
    }
    public Properties getProperties(File propertyFile) throws BuildException {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(propertyFile));
        }
        catch (FileNotFoundException e) {
            String message = ""Property file ("" + propertyFile.getPath() + "") not found."";
            throw new BuildException(message);
        }
        catch (IOException e) {
            String message = ""Property file ("" + propertyFile.getPath() + "") cannot be loaded."";
            throw new BuildException(message);
        }
        return properties;
    }
    /**
     * Perform the replacement on the given file.
     *
     * The replacement is performed on a temporary file which then
     * replaces the original file.
     *
     * @param src the source file
     */
    private void processFile(File src) throws BuildException {
        if (!src.exists()) {
            throw new BuildException(""Replace: source file "" + src.getPath() + "" doesn't exist"", location);
        }
        File temp = new File(src.getPath() + "".temp"");
        if (temp.exists()) {
            throw new BuildException(""Replace: temporary file "" + temp.getPath() + "" already exists"", location);
        }
        try {
            BufferedReader br = new BufferedReader(new FileReader(src));
            BufferedWriter bw = new BufferedWriter(new FileWriter(temp));
            // read the entire file into a char[]
            int fileLength = (int)(src.length());
            char[] tmpBuf = new char[fileLength];
            int numread = 0;
            int totread = 0;
            while (numread != -1 && totread < fileLength) {
                numread = br.read(tmpBuf,totread,fileLength);
                totread += numread;
            }
            // create a String so we can use indexOf
            String buf = new String(tmpBuf);
            //Preserve original string (buf) so we can compare the result
            String newString = new String(buf);
            if (token != null)
            {
                // line separators in values and tokens are ""\n""
                // in order to compare with the file contents, replace them
                // as needed
                String linesep = System.getProperty(""line.separator"");
                String val = stringReplace(value.getText(), ""\n"", linesep);
                String tok = stringReplace(token.getText(), ""\n"", linesep);
                // for each found token, replace with value
                log(""Replacing in "" + src.getPath() + "": "" + token.getText() + "" --> "" + value.getText(), Project.MSG_VERBOSE);
                newString = stringReplace(newString, tok, val);
            }
            if (replacefilters.size() > 0) {
                newString = processReplacefilters(newString, src.getPath());
            }
            boolean changes = !newString.equals(buf);
            if (changes) {
                bw.write(newString,0,newString.length());
                bw.flush();
            }
            // cleanup
            bw.close();
            br.close();
            // If there were changes, move the new one to the old one;
            // otherwise, delete the new one
            if (changes) {
                src.delete();
                temp.renameTo(src);
            } else {
                temp.delete();
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new BuildException(ioe, location);
        }
    }
    private String processReplacefilters(String buffer, String filename) {
        String newString = new String(buffer);
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);
            //for each found token, replace with value
            log(""Replacing in "" + filename + "": "" + filter.getToken() + "" --> "" + filter.getReplaceValue(), Project.MSG_VERBOSE);
            newString = stringReplace(newString, filter.getToken(), filter.getReplaceValue());
        }
        return newString;
    }
    /**
     * Set the source file.
     */
    public void setFile(File file) {
        this.src = file;
    }
    /**
     * Set the source files path when using matching tasks.
     */
    public void setDir(File dir) {
        this.dir = dir;
    }
    /**
     * Set the string token to replace.
     */
    public void setToken(String token) {
        createReplaceToken().addText(token);
    }
    /**
     * Set the string value to use as token replacement.
     */
    public void setValue(String value) {
        createReplaceValue().addText(value);
    }
    /**
     * Nested <replacetoken> element.
     */
    public NestedString createReplaceToken() {
        if (token == null) {
            token = new NestedString();
        }
        return token;
    }
    /**
     * Nested <replacevalue> element.
     */
    public NestedString createReplaceValue() {
        return value;
    }
    /**
     * Sets a file to be searched for property values.
     */
    public void setPropertyFile(String filename) {
        propertyFile = project.resolveFile(filename);
    }
    /**
     * Add nested <replacefilter> element.
     */
    public Replacefilter createReplacefilter() {
        Replacefilter filter = new Replacefilter();
        replacefilters.addElement(filter);
        return filter;
    }
    /**
     * Replace occurrences of str1 in string str with str2
     */    
    private String stringReplace(String str, String str1, String str2) {
        StringBuffer ret = new StringBuffer();
        int start = 0;
        int found = str.indexOf(str1);
        while (found >= 0) {
            // write everything up to the found str1
            if (found > start) {
                ret.append(str.substring(start, found));
            }
            // write the replacement str2
            if (str2 != null) {
                ret.append(str2);
            }
            // search again
            start = found + str1.length();
            found = str.indexOf(str1,start);
        }
        // write the remaining characters
        if (str.length() > start) {
            ret.append(str.substring(start, str.length()));
        }
        return ret.toString();
    }
}
"
org.apache.tools.ant.taskdefs.Rmic,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.*;
import java.io.*;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Date;
/**
 * Task to compile RMI stubs and skeletons. This task can take the following
 * arguments:
 * <ul>
 * <li>base: The base directory for the compiled stubs and skeletons
 * <li>class: The name of the class to generate the stubs from
 * <li>stubVersion: The version of the stub prototol to use (1.1, 1.2, compat)
 * <li>sourceBase: The base directory for the generated stubs and skeletons
 * <li>classpath: Additional classpath, appended before the system classpath
 * <li>iiop: Generate IIOP compatable output 
 * <li>iiopopts: Include IIOP options 
 * <li>idl: Generate IDL output 
 * <li>idlopts: Include IDL options 
 * </ul>
 * Of these arguments, <b>base</b> is required.
 * <p>
 * If classname is specified then only that classname will be compiled. If it
 * is absent, then <b>base</b> is traversed for classes according to patterns.
 * <p>
 *
 * @author duncan@x180.com
 * @author ludovic.claude@websitewatchers.co.uk
 * @author David Maclean <a href=""mailto:david@cm.co.za"">david@cm.co.za</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class Rmic extends MatchingTask {
    private File baseDir;
    private String classname;
    private File sourceBase;
    private String stubVersion;
    private Path compileClasspath;
    private boolean verify = false;
    private boolean filtering = false;
    private boolean iiop = false;
    private String  iiopopts;
    private boolean idl  = false;
    private String  idlopts;
    private boolean debug  = false;
    private Vector compileList = new Vector();
    private ClassLoader loader = null;
    public void setBase(File base) {
        this.baseDir = base;
    }
    public void setClassname(String classname) {
        this.classname = classname;
    }
    public void setSourceBase(File sourceBase) {
        this.sourceBase = sourceBase;
    }
    public void setStubVersion(String stubVersion) {
        this.stubVersion = stubVersion;
    }
    public void setFiltering(boolean filter) {
        filtering = filter;
    }
    public void setDebug(boolean debug) {
        this.debug = debug;
    }
    /**
     * Set the classpath to be used for this compilation.
     */
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }
    /**
     * Creates a nested classpath element.
     */
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(project);
        }
        return compileClasspath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    /**
     * Indicates that the classes found by the directory match should be
     * checked to see if they implement java.rmi.Remote.
     * This defaults to false if not set.  */
    public void setVerify(boolean verify) {
        this.verify = verify;
    }
    /**
     * Indicates that IIOP compatible stubs should
     * be generated.  This defaults to false 
     * if not set.  
     */
    public void setIiop(boolean iiop) {
        this.iiop = iiop;
    }
    /**
     * pass additional arguments for iiop 
     */
    public void setIiopopts(String iiopopts) {
        this.iiopopts = iiopopts;
    }
    /**
     * Indicates that IDL output should be 
     * generated.  This defaults to false 
     * if not set.  
     */
    public void setIdl(boolean idl) {
        this.idl = idl;
    }
    /**
     * pass additional arguments for idl compile 
     */
    public void setIdlopts(String idlopts) {
        this.idlopts = idlopts;
    }
    public void execute() throws BuildException {
        if (baseDir == null) {
            throw new BuildException(""base attribute must be set!"", location);
        }
        if (!baseDir.exists()) {
            throw new BuildException(""base does not exist!"", location);
        }
        if (verify) {
            log(""Verify has been turned on."", Project.MSG_INFO);
        }
        if (iiop) {
            log(""IIOP has been turned on."", Project.MSG_INFO);
            if( iiopopts != null ) {
                log(""IIOP Options: "" + iiopopts, Project.MSG_INFO );
            }
        }
        if (idl) {
            log(""IDL has been turned on."", Project.MSG_INFO);
            if( idlopts != null ) {
                log(""IDL Options: "" + idlopts, Project.MSG_INFO );
            }
        }
        Path classpath = getCompileClasspath(baseDir);
        loader = new AntClassLoader(project, classpath);
        // scan base dirs to build up compile lists only if a
        // specific classname is not given
        if (classname == null) {
            DirectoryScanner ds = this.getDirectoryScanner(baseDir);
            String[] files = ds.getIncludedFiles();
            scanDir(baseDir, files);
        } else {
            // otherwise perform a timestamp comparison - at least
            scanDir(baseDir, 
                    new String[] {classname.replace('.', File.separatorChar) + "".class""});
        }
        // XXX
        // need to provide an input stream that we read in from!
        OutputStream logstr = new LogOutputStream(this, Project.MSG_WARN);
        sun.rmi.rmic.Main compiler = new sun.rmi.rmic.Main(logstr, ""rmic"");
        Commandline cmd = new Commandline();
        cmd.createArgument().setValue(""-d"");
        cmd.createArgument().setFile(baseDir);
        cmd.createArgument().setValue(""-classpath"");
        cmd.createArgument().setPath(classpath);
        if (null != stubVersion) {
            if (""1.1"".equals(stubVersion))
                cmd.createArgument().setValue(""-v1.1"");
            else if (""1.2"".equals(stubVersion))
                cmd.createArgument().setValue(""-v1.2"");
            else
                cmd.createArgument().setValue(""-vcompat"");
        }
        if (null != sourceBase)
            cmd.createArgument().setValue(""-keepgenerated"");
        if( iiop ) {
            cmd.createArgument().setValue(""-iiop"");
            if( iiopopts != null ) 
                cmd.createArgument().setValue(iiopopts);
        }
        if( idl )  {
            cmd.createArgument().setValue(""-idl"");
            if( idlopts != null ) 
                cmd.createArgument().setValue(idlopts);
        }
        if( debug )  {
            cmd.createArgument().setValue(""-g"");
        }
        int fileCount = compileList.size();
        if (fileCount > 0) {
            log(""RMI Compiling "" + fileCount +
                "" class""+ (fileCount > 1 ? ""es"" : """")+"" to "" + baseDir, 
                Project.MSG_INFO);
            for (int j = 0; j < fileCount; j++) {
                cmd.createArgument().setValue((String) compileList.elementAt(j));
            }
            log(""Compilation args: "" + cmd.toString(), Project.MSG_VERBOSE);
            compiler.compile(cmd.getArguments());
        }
        // Move the generated source file to the base directory
        if (null != sourceBase) {
            for (int j = 0; j < fileCount; j++) {
                moveGeneratedFile(baseDir, sourceBase, (String) compileList.elementAt(j));
            }
        }
        compileList.removeAllElements();
    }
    /**
     * Move the generated source file(s) to the base directory
     *
     * @exception org.apache.tools.ant.BuildException When error copying/removing files.
     */
    private void moveGeneratedFile (File baseDir, File sourceBaseFile, String classname)
            throws BuildException {
        String stubFileName = classname.replace('.', File.separatorChar) + ""_Stub.java"";
        File oldStubFile = new File(baseDir, stubFileName);
        File newStubFile = new File(sourceBaseFile, stubFileName);
        try {
            project.copyFile(oldStubFile, newStubFile, filtering);
            oldStubFile.delete();
        } catch (IOException ioe) {
            String msg = ""Failed to copy "" + oldStubFile + "" to "" +
                newStubFile + "" due to "" + ioe.getMessage();
            throw new BuildException(msg, ioe, location);
        }
        if (!""1.2"".equals(stubVersion)) {
            String skelFileName = classname.replace('.', '/') + ""_Skel.java"";
            File oldSkelFile = new File(baseDir, skelFileName);
            File newSkelFile = new File(sourceBaseFile, skelFileName);
            try {
                project.copyFile(oldSkelFile, newSkelFile, filtering);
                oldSkelFile.delete();
            } catch (IOException ioe) {
                String msg = ""Failed to copy "" + oldSkelFile + "" to "" +
                              newSkelFile + "" due to "" + ioe.getMessage();
                throw new BuildException(msg, ioe, location);
            }
        }
    }
    /**
     * Scans the directory looking for class files to be compiled.
     * The result is returned in the class variable compileList.
     */
    protected void scanDir(File baseDir, String files[]) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        String[] newFiles = sfs.restrict(files, baseDir, baseDir,
                                         new RmicFileNameMapper());
        for (int i = 0; i < newFiles.length; i++) {
            String classname = newFiles[i].replace(File.separatorChar, '.');
            classname = classname.substring(0, classname.indexOf("".class""));
            compileList.addElement(classname);
        }
    }
    /**
     * Builds the compilation classpath.
     */
    // XXX
    // we need a way to not use the current classpath.
    private Path getCompileClasspath(File baseFile) {
        // add dest dir to classpath so that previously compiled and
        // untouched classes are on classpath
        Path classpath = new Path(project, baseFile.getAbsolutePath());
        // Combine the build classpath with the system classpath, in an 
        // order determined by the value of build.classpath
        if (compileClasspath == null) {
            classpath.addExisting(Path.systemClasspath);
        } else {
            classpath.addExisting(compileClasspath.concatSystemClasspath());
        }
        // in jdk 1.2, the system classes are not on the visible classpath.
        if (Project.getJavaVersion().startsWith(""1.2"")) {
            String bootcp = System.getProperty(""sun.boot.class.path"");
            if (bootcp != null) {
                classpath.addExisting(new Path(project, bootcp));
            }
        }
        return classpath;
    }
    /**
     * Mapper that possibly returns two file names, *_Stub and *_Skel.
     */
    private class RmicFileNameMapper implements FileNameMapper {
        private GlobPatternMapper stubMapper;
        private GlobPatternMapper skelMapper;
        RmicFileNameMapper() {
            stubMapper = new GlobPatternMapper();
            stubMapper.setFrom(""*.class"");
            stubMapper.setTo(""*_Stub.class"");
            // no _Skel file in stub version 1.2
            if (!""1.2"".equals(stubVersion)) {
                skelMapper = new GlobPatternMapper();
                skelMapper.setFrom(""*.class"");
                skelMapper.setTo(""*_Skel.class"");
            }
        }
        /**
         * Empty implementation.
         */
        public void setFrom(String s) {}
        /**
         * Empty implementation.
         */
        public void setTo(String s) {}
        public String[] mapFileName(String name) {
            String[] stubName = stubMapper.mapFileName(name);
            if (stubName == null || name.endsWith(""_Stub.class"") 
                || name.endsWith(""_Skel.class"")) {
                // Not a .class file
                return null;
            }
            String classname = name.replace(File.separatorChar, '.');
            classname = classname.substring(0, classname.indexOf("".class""));
            if (verify) {
                try {
                    Class testClass = loader.loadClass(classname);
                    // One cannot RMIC an interface
                    if (testClass.isInterface() || 
                        !isValidRmiRemote(testClass)) {
                        return null;
                    }
                } catch (ClassNotFoundException e) {
                    log(""Unable to verify class "" + classname + 
                        "". It could not be found."", Project.MSG_WARN);
                } catch (NoClassDefFoundError e) {
                    log(""Unable to verify class "" + classname + 
                        "". It is not defined."", Project.MSG_WARN);
                }
            }
            if (skelMapper != null) {
                return new String[] {
                    stubName[0], 
                    skelMapper.mapFileName(name)[0]
                };
            } else {
                return stubName;
            }
        }
        /**
         * Check to see if the class or superclasses/interfaces implement
         * java.rmi.Remote.
         */
        private boolean isValidRmiRemote (Class testClass) {
            Class rmiRemote = java.rmi.Remote.class;
            if (rmiRemote.equals(testClass)) {
                // This class is java.rmi.Remote
                return true;
            }
            Class [] interfaces = testClass.getInterfaces();
            if (interfaces != null) {
                for (int i = 0; i < interfaces.length; i++) {
                    if (rmiRemote.equals(interfaces[i])) {
                        // This class directly implements java.rmi.Remote
                        return true;
                    }
                    if (isValidRmiRemote(interfaces[i])) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
"
org.apache.tools.ant.taskdefs.SendEmail,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.mail.MailMessage;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
/**
 * A task to send SMTP email.
 * <p>
 * <table border=""1"" cellpadding=""3"" cellspacing=""0"">
 * <tr bgcolor=""#CCCCFF"">
 * <th>Attribute</th>
 * <th>Description</th>
 * <th>Required</th>
 * </tr>
 * <tr>
 * <td>from</td>
 * <td>Email address of sender.</td>
 * <td>Yes</td>
 * </tr>
 * <tr>
 * <td>mailhost</td>
 * <td>Host name of the mail server.</td>
 * <td>No, default to &quot;localhost&quot;</td>
 * </tr>
 * <tr>
 * <td>toList</td>
 * <td>Comma-separated list of recipients.</td>
 * <td>Yes</td>
 * </tr>
 * <tr>
 * <td>subject</td>
 * <td>Email subject line.</td>
 * <td>No</td>
 * </tr>
 * <tr>
 * <td>files</td>
 * <td>Filename(s) of text to send in the body of the email. Multiple files are
 *     comma-separated.</td>
 * <td rowspan=""2"">One of these two attributes</td>
 * </tr>
 * <tr>
 * <td>message</td>
 * <td>Message to send inthe body of the email.</td>
 * </tr>
 * </table>
 * <p>
 *
 * @author glenn_twiggs@bmc.com
 */
public class SendEmail extends Task {
    private String from;
    private String mailhost = ""localhost"";
    private String message;
    private String toList;
    private String subject;
    private Vector files = new Vector();
    /** Creates new SendEmail */
    public SendEmail() {
    }
    /**
     * Sets the toList parameter of this build task.
     *
     * @param toList Comma-separated list of email recipient addreses.
     */
    public void setToList(String toList) {
        this.toList = toList;
    }
    /**
     * Sets the from parameter of this build task.
     *
     * @param from Email address of sender.
     */
    public void setFrom(String from) {
        this.from = from;
    }
    /**
     * Sets the mailhost parameter of this build task.
     *
     * @param mailhost Mail host name.
     */
    public void setMailhost(String mailhost) {
        this.mailhost = mailhost;
    }
    /**
     * Sets the message parameter of this build task.
     *
     * @param message Message body of this email.
     */
    public void setMessage(String message) {
        this.message = message;
    }
    /**
     * Sets the subject parameter of this build task.
     *
     * @param subject Subject of this email.
     */
    public void setSubject(String subject) {
        this.subject = subject;
    }
    /**
     * Sets the file parameter of this build task.
     *
     * @param filenames Filenames to include as the message body of this email.
     */
    public void setFiles(String filenames) {
        StringTokenizer t = new StringTokenizer(filenames, "", "");
        while (t.hasMoreTokens()) {
            files.addElement(project.resolveFile(t.nextToken()));
        }
    }
    /**
     * Executes this build task.
     *
     * throws org.apache.tools.ant.BuildException if there is an error during task
     *        execution.
     */
    public void execute() {
        try {
            MailMessage mailMessage = new MailMessage(mailhost);
            if (from != null) {
                mailMessage.from(from);
            } else {
                throw new BuildException(""Attribute \""from\"" is required."");
            }
            if (toList != null) {
                StringTokenizer t = new StringTokenizer(toList, "", "", false);
                while (t.hasMoreTokens()) {
                    mailMessage.to(t.nextToken());
                }
            } else {
                throw new BuildException(""Attribute \""toList\"" is required."");
            }
            if (subject != null) {
                mailMessage.setSubject(subject);
            }
            if (!files.isEmpty()) {
                PrintStream out = mailMessage.getPrintStream();
                for (Enumeration e = files.elements(); e.hasMoreElements(); ) {
                    File file = (File)e.nextElement();
                    if (file.exists() && file.canRead()) {
                        int bufsize = 1024;
                        int length;
                        byte[] buf = new byte[bufsize];
                        BufferedInputStream in = null;
                        try {
                            in = new BufferedInputStream(
                                new FileInputStream(file), bufsize);
                            while ((length = in.read(buf, 0, bufsize)) != -1) {
                                out.write(buf, 0, length);
                            }
                        } finally {
                            if (in != null) {
                                in.close();
                            }
                        }
                    } else {
                        throw new BuildException(""File \"""" + file.getName()
                            + ""\"" does not exist or is not readable."");
                    }
                }
            } else if (message != null) {
                PrintStream out = mailMessage.getPrintStream();
                out.print(message);
            } else {
                throw new BuildException(""Attribute \""file\"" or \""message\"" is required."");
            }
            log(""Sending email"");
            mailMessage.sendAndClose();
        } catch (IOException ioe) {
            throw new BuildException(""IO error sending mail: "" + ioe.getMessage());
        }
    }
}
"
org.apache.tools.ant.taskdefs.SignJar,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.File;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
/**
 * Sign a archive.
 * 
 * @author Peter Donald <a href=""mailto:donaldp@apache.org"">donaldp@apache.org</a>
 */
public class SignJar extends Task {
    /**
     * The name of the jar file.
     */
    protected String jar;
    /**
     * The alias of signer.
     */
    protected String alias;
    /**
     * The name of keystore file.
     */
    protected String keystore;
    protected String storepass;
    protected String storetype;
    protected String keypass;
    protected String sigfile;
    protected String signedjar;
    protected boolean verbose;
    protected boolean internalsf;
    protected boolean sectionsonly;
    public void setJar(final String jar) {
        this.jar = jar;
    } 
    public void setAlias(final String alias) {
        this.alias = alias;
    } 
    public void setKeystore(final String keystore) {
        this.keystore = keystore;
    } 
    public void setStorepass(final String storepass) {
        this.storepass = storepass;
    } 
    public void setStoretype(final String storetype) {
        this.storetype = storetype;
    } 
    public void setKeypass(final String keypass) {
        this.keypass = keypass;
    } 
    public void setSigfile(final String sigfile) {
        this.sigfile = sigfile;
    } 
    public void setSignedjar(final String signedjar) {
        this.signedjar = signedjar;
    } 
    public void setVerbose(final boolean verbose) {
        this.verbose = verbose;
    } 
    public void setInternalsf(final boolean internalsf) {
        this.internalsf = internalsf;
    } 
    public void setSectionsonly(final boolean sectionsonly) {
        this.sectionsonly = sectionsonly;
    } 
    public void execute() throws BuildException {
        if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
            throw new BuildException(""The signjar task is only available on JDK versions 1.2 or greater"");
        } 
        if (null == jar) {
            throw new BuildException(""jar attribute must be set"");
        } 
        if (null == alias) {
            throw new BuildException(""alias attribute must be set"");
        } 
        if (null == storepass) {
            throw new BuildException(""storepass attribute must be set"");
        } 
        if(isUpToDate()) return;
        final StringBuffer sb = new StringBuffer();
        final ExecTask cmd = (ExecTask) project.createTask(""exec"");
        cmd.setExecutable(""jarsigner"");
        if (null != keystore) {
            cmd.createArg().setValue(""-keystore"");
            cmd.createArg().setValue(keystore);
        } 
        if (null != storepass) {
            cmd.createArg().setValue(""-storepass"");
            cmd.createArg().setValue(storepass);
        } 
        if (null != storetype) {
            cmd.createArg().setValue(""-storetype"");
            cmd.createArg().setValue(storetype);
        } 
        if (null != keypass) {
            cmd.createArg().setValue(""-keypass"");
            cmd.createArg().setValue(keypass);
        } 
        if (null != sigfile) {
            cmd.createArg().setValue(""-sigfile"");
            cmd.createArg().setValue(sigfile);
        } 
        if (null != signedjar) {
            cmd.createArg().setValue(""-signedjar"");
            cmd.createArg().setValue(signedjar);
        } 
        if (verbose) {
            cmd.createArg().setValue(""-verbose"");
        } 
        if (internalsf) {
            cmd.createArg().setValue(""-internalsf"");
        } 
        if (sectionsonly) {
            cmd.createArg().setValue(""-sectionsonly"");
        } 
        cmd.createArg().setValue(jar);
        cmd.createArg().setValue(alias);
        log(""Signing Jar : "" + (new File(jar)).getAbsolutePath());
        cmd.setFailonerror(true);
        cmd.setTaskName( getTaskName() );
        cmd.execute();
    }
    protected boolean isUpToDate() {
        if( null != jar && null != signedjar ) {
            final File jarFile = new File(jar);
            final File signedjarFile = new File(signedjar);
            if(!jarFile.exists()) return false;
            if(!signedjarFile.exists()) return false;
            if(jarFile.equals(signedjarFile)) return false;
            if(signedjarFile.lastModified() > jarFile.lastModified())
                return true;
        }
        return false;
    }
}
"
org.apache.tools.ant.taskdefs.SQLExec,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Properties;
import java.util.zip.*;
import java.sql.*;
/**
 * Reads in a text file containing SQL statements seperated with semicolons
 * and executes it in a given db.
 * Both -- and // maybe used as comments.
 * 
 * @author <a href=""mailto:jeff@custommonkey.org"">Jeff Martin</a>
 */
public class SQLExec extends Task {
    private int goodSql = 0, totalSql = 0;
    private Path classpath;
    private AntClassLoader loader;
    /**
     * Database connection
     */
    private Connection conn = null;
    /**
     * Autocommit flag. Default value is false
     */
    private boolean autocommit=false;
    /**
     * SQL statement
     */
    private Statement statement = null;
    /**
     * DB driver.
     */
    private String driver = null;
    /**
     * DB url.
     */
    private String url = null;
    /**
     * User name.
     */
    private String userId = null;
    /**
     * Password
     */
    private String password = null;
    /**
     * SQL input file
     */
    private File srcFile = null;
    /**
     * SQL input command
     */
    private String sqlCommand = """";
    /**
     * SQL transactions to perform
     */
    private Vector transactions = new Vector();
    /**
     * Print SQL results.
     */
    private boolean print = false;
    /**
     * Print header columns.
     */
    private boolean showheaders = true;
    /**
     * Results Output file.
     */
    private File output = null;
    /**
     * RDBMS Product needed for this SQL.
     **/
    private String rdbms = null;
    /**
     * RDBMS Version needed for this SQL.
     **/
    private String version = null;
    /**
     * Action to perform if an error is found
     **/
    private String onError = ""abort"";
    /**
     * Set the classpath for loading the driver.
     */
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }
    /**
     * Create the classpath for loading the driver.
     */
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(project);
        }
        return this.classpath.createPath();
    }
    /**
     * Set the classpath for loading the driver using the classpath reference.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    /**
     * Set the name of the sql file to be run.
     */
    public void setSrc(File srcFile) {
        this.srcFile = srcFile;
    }
    /**
     * Set the sql command to execute
     */
    public void addText(String sql) {
        this.sqlCommand += sql;
    }
    /**
     * Set the sql command to execute
     */
    public Transaction createTransaction() {
      Transaction t = new Transaction();
      transactions.addElement(t);
      return t;
    }
    /**
     * Set the JDBC driver to be used.
     */
    public void setDriver(String driver) {
        this.driver = driver;
    }
    /**
     * Set the DB connection url.
     */
    public void setUrl(String url) {
        this.url = url;
    }
    /**
     * Set the user name for the DB connection.
     */
    public void setUserid(String userId) {
        this.userId = userId;
    }
    /**
     * Set the password for the DB connection.
     */
    public void setPassword(String password) {
        this.password = password;
    }
    /**
     * Set the autocommit flag for the DB connection.
     */
    public void setAutocommit(boolean autocommit) {
        this.autocommit = autocommit;
    }
    /**
     * Set the print flag.
     */
    public void setPrint(boolean print) {
        this.print = print;
    }
    /**
     * Set the showheaders flag.
     */
    public void setShowheaders(boolean showheaders) {
        this.showheaders = showheaders;
    }
    /**
     * Set the output file.
     */
    public void setOutput(File output) {
        this.output = output;
    }
    /**
     * Set the rdbms required
     */
    public void setRdbms(String vendor) {
        this.rdbms = vendor.toLowerCase();
    }
    /**
     * Set the version required
     */
    public void setVersion(String version) {
        this.version = version.toLowerCase();
    }
    /**
     * Set the action to perform onerror
     */
    public void setOnerror(OnError action) {
        this.onError = action.getValue();
    }
    /**
     * Load the sql file and then execute it
     */
    public void execute() throws BuildException {
        sqlCommand = sqlCommand.trim();
        if (srcFile == null && sqlCommand.length() == 0) { 
            if (transactions.size() == 0) {
                throw new BuildException(""Source file, transactions or sql statement must be set!"", location);
            }
        } else {
            // Make a transaction group for the outer command
            Transaction t = createTransaction();
            t.setSrc(srcFile);
            t.addText(sqlCommand);
        }
        if (driver == null) {
            throw new BuildException(""Driver attribute must be set!"", location);
        }
        if (userId == null) {
            throw new BuildException(""User Id attribute must be set!"", location);
        }
        if (password == null) {
            throw new BuildException(""Password attribute must be set!"", location);
        }
        if (url == null) {
            throw new BuildException(""Url attribute must be set!"", location);
        }
        if (srcFile != null && !srcFile.exists()) {
            throw new BuildException(""Source file does not exist!"", location);
        }
        Driver driverInstance = null;
        // Load the driver using the 
        try {
            Class dc;
            if (classpath != null) {
                log( ""Loading "" + driver + "" using AntClassLoader with classpath "" + classpath, 
                     Project.MSG_VERBOSE );
                loader = new AntClassLoader(project, classpath, false);
                dc = loader.loadClass(driver);
            }
            else {
                log(""Loading "" + driver + "" using system loader."", Project.MSG_VERBOSE);
                dc = Class.forName(driver);
            }
            driverInstance = (Driver) dc.newInstance();
        }catch(ClassNotFoundException e){
            throw new BuildException(""Class Not Found: JDBC driver "" + driver + "" could not be loaded"", location);
        }catch(IllegalAccessException e){
            throw new BuildException(""Illegal Access: JDBC driver "" + driver + "" could not be loaded"", location);
        }catch(InstantiationException e) {
            throw new BuildException(""Instantiation Exception: JDBC driver "" + driver + "" could not be loaded"", location);
        }
        try{
            log(""connecting to "" + url, Project.MSG_VERBOSE );
            Properties info = new Properties();
            info.put(""user"", userId);
            info.put(""password"", password);
            conn = driverInstance.connect(url, info);
            if (conn == null) {
                // Driver doesn't understand the URL
                throw new SQLException(""No suitable Driver for ""+url);
            }
            if (!isValidRdbms(conn)) return;
            conn.setAutoCommit(autocommit);
            statement = conn.createStatement();
            PrintStream out = System.out;
            try {
                if (output != null) {
                    log(""Opening PrintStream to output file "" + output, Project.MSG_VERBOSE);
                    out = new PrintStream(new BufferedOutputStream(new FileOutputStream(output)));
                }
                // Process all transactions
                for (Enumeration e = transactions.elements(); 
                     e.hasMoreElements();) {
                    ((Transaction) e.nextElement()).runTransaction(out);
                    if (!autocommit) {
                        log(""Commiting transaction"", Project.MSG_VERBOSE);
                        conn.commit();
                    }
                }
            }
            finally {
                if (out != null && out != System.out) {
                    out.close();
                }
            }
        } catch(IOException e){
            if (!autocommit && conn != null && onError.equals(""abort"")) {
                try {
                    conn.rollback();
                } catch (SQLException ex) {}
            }
            throw new BuildException(e, location);
        } catch(SQLException e){
            if (!autocommit && conn != null && onError.equals(""abort"")) {
                try {
                    conn.rollback();
                } catch (SQLException ex) {}
            }
            throw new BuildException(e, location);
        }
        finally {
            try {
                if (statement != null) {
                    statement.close();
                }
                if (conn != null) {
                    conn.close();
                }
            }
            catch (SQLException e) {}
        }
        log(goodSql + "" of "" + totalSql + 
            "" SQL statements executed successfully"");
    }
    protected void runStatements(Reader reader, PrintStream out) throws SQLException, IOException {
        String sql = """";
        String line = """";
        BufferedReader in = new BufferedReader(reader);
        try{
            while ((line=in.readLine()) != null){
                if (line.trim().startsWith(""//"")) continue;
                if (line.trim().startsWith(""--"")) continue;
                sql += "" "" + line;
                sql = sql.trim();
                // SQL defines ""--"" as a comment to EOL
                // and in Oracle it may contain a hint
                // so we cannot just remove it, instead we must end it
                if (line.indexOf(""--"") >= 0) sql += ""\n"";
                if (sql.endsWith("";"")){
                    log(""SQL: "" + sql, Project.MSG_VERBOSE);
                    execSQL(sql.substring(0, sql.length()-1), out);
                    sql = """";
                }
            }
            // Catch any statements not followed by ;
            if(!sql.equals("""")){
                execSQL(sql, out);
            }
        }catch(SQLException e){
            throw e;
        }
    }
    /**
     * Verify if connected to the correct RDBMS
     **/
    protected boolean isValidRdbms(Connection conn) {
        if (rdbms == null && version == null)
            return true;
        try {
            DatabaseMetaData dmd = conn.getMetaData();
            if (rdbms != null) {
                String theVendor = dmd.getDatabaseProductName().toLowerCase();
                log(""RDBMS = "" + theVendor, Project.MSG_VERBOSE);
                if (theVendor == null || theVendor.indexOf(rdbms) < 0) {
                    log(""Not the required RDBMS: ""+rdbms, Project.MSG_VERBOSE);
                    return false;
                }
            }
            if (version != null) {
                String theVersion = dmd.getDatabaseProductVersion().toLowerCase();
                log(""Version = "" + theVersion, Project.MSG_VERBOSE);
                if (theVersion == null || 
                    !(theVersion.startsWith(version) || 
                      theVersion.indexOf("" "" + version) >= 0)) {
                    log(""Not the required version: \""""+ version +""\"""", Project.MSG_VERBOSE);
                    return false;
                }
            }
        }
        catch (SQLException e) {
            // Could not get the required information
            log(""Failed to obtain required RDBMS information"", Project.MSG_ERR);
            return false;
        }
        return true;
    }
    /**
     * Exec the sql statement.
     */
    protected void execSQL(String sql, PrintStream out) throws SQLException {
        // Check and ignore empty statements
        if ("""".equals(sql.trim())) return;
        try {  
            totalSql++;
            if (!statement.execute(sql)) {
                log(statement.getUpdateCount()+"" rows affected"", 
                    Project.MSG_VERBOSE);
            }
            if (print) {
                printResults(out);
            }
            SQLWarning warning = conn.getWarnings();
            while(warning!=null){
                log(warning + "" sql warning"", Project.MSG_VERBOSE);
                warning=warning.getNextWarning();
            }
            conn.clearWarnings();
            goodSql++;
        }
        catch (SQLException e) {
            log(""Failed to execute: "" + sql, Project.MSG_ERR);
            if (!onError.equals(""continue"")) throw e;
            log(e.toString(), Project.MSG_ERR);
        }
    }
    /**
     * print any results in the statement.
     */
    protected void printResults(PrintStream out) throws java.sql.SQLException {
        ResultSet rs = null;
        do {
            rs = statement.getResultSet();
            if (rs != null) {
      	        log(""Processing new result set."", Project.MSG_VERBOSE);
                ResultSetMetaData md = rs.getMetaData();
                int columnCount = md.getColumnCount();
                StringBuffer line = new StringBuffer();
                if (showheaders) {
                    for (int col = 1; col < columnCount; col++) {
                         line.append(md.getColumnName(col));
                         line.append("","");
                    }
                    line.append(md.getColumnName(columnCount));
                    out.println(line);
                    line.setLength(0);
                }
                while (rs.next()) {
                    boolean first = true;
                    for (int col = 1; col <= columnCount; col++) {
                        String columnValue = rs.getString(col);
                        if (columnValue != null) {
                            columnValue = columnValue.trim();
                        }
                        if (first) {
                            first = false;
                        }
                        else {
                            line.append("","");
                        }
                        line.append(columnValue);
                    }
                    out.println(line);
                    line.setLength(0);
                }
            }
        }
        while (statement.getMoreResults());
        out.println();
    }
    /**
     * Enumerated attribute with the values ""continue"", ""stop"" and ""abort""
     * for the onerror attribute.  
     */
    public static class OnError extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[] {""continue"", ""stop"", ""abort""};
        }
    }
    /**
     * Contains the definition of a new transaction element.
     * Transactions allow several files or blocks of statements
     * to be executed using the same JDBC connection and commit
     * operation in between.
     */
    public class Transaction {
        private File tSrcFile = null;
        private String tSqlCommand = """";
        public void setSrc(File src) {
            this.tSrcFile = src;
        }
        public void addText(String sql) {
            this.tSqlCommand += sql;
        }
        private void runTransaction(PrintStream out) throws IOException, SQLException {
            if (tSqlCommand.length() != 0) {
                log(""Executing commands"", Project.MSG_INFO);
                runStatements(new StringReader(tSqlCommand), out);
            }
            if (tSrcFile != null) {
                log(""Executing file: "" + tSrcFile.getAbsolutePath(), 
                    Project.MSG_INFO);
                FileReader reader = new FileReader(tSrcFile);
                runStatements(reader, out);
                reader.close();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.StreamPumper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
/**
 * Copies all data from an input stream to an output stream.
 *
 * @author thomas.haas@softwired-inc.com
 */
public class StreamPumper implements Runnable {
    // TODO: make SIZE and SLEEP instance variables.
    // TODO: add a status flag to note if an error occured in run.
    private final static int SLEEP = 5;
    private final static int SIZE = 128;
    private InputStream is;
    private OutputStream os;
    /**
     * Create a new stream pumper.
     *
     * @param is input stream to read data from
     * @param os output stream to write data to.
     */
    public StreamPumper(InputStream is, OutputStream os) {
        this.is = is;
        this.os = os;
    }
    /**
     * Copies data from the input stream to the output stream.
     *
     * Terminates as soon as the input stream is closed or an error occurs.
     */
    public void run() {
        final byte[] buf = new byte[SIZE];
        int length;
        try {
            while ((length = is.read(buf)) > 0) {
                os.write(buf, 0, length);
                try {
                    Thread.sleep(SLEEP);
                } catch (InterruptedException e) {}
            }
        } catch(IOException e) {}
    }
}
"
org.apache.tools.ant.taskdefs.Tar,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.util.*;
import org.apache.tools.tar.*;
import org.apache.tools.ant.types.*;
/**
 * Creates a TAR archive.
 *
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Tar extends MatchingTask {
    // permissable values for longfile attribute
    static public final String WARN = ""warn"";
    static public final String FAIL = ""fail"";
    static public final String TRUNCATE = ""truncate"";
    static public final String GNU = ""gnu"";
    static public final String OMIT = ""omit"";
    private String[] validModes = new String[] {WARN, FAIL, TRUNCATE, GNU, OMIT};
    File tarFile;
    File baseDir;
    String longFileMode = WARN;
    Vector filesets = new Vector();
    Vector fileSetFiles = new Vector();
    /**
     * Indicates whether the user has been warned about long files already.
     */
    private boolean longWarningGiven = false;
    public TarFileSet createTarFileSet() {
        TarFileSet fileset = new TarFileSet();
        filesets.addElement(fileset);
        return fileset;
    }
    /**
     * This is the name/location of where to create the tar file.
     */
    public void setTarfile(File tarFile) {
        this.tarFile = tarFile;
    }
    /**
     * This is the base directory to look in for things to tar.
     */
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }
    /**
     * Set how to handle long files.
     *
     * Allowable values are
     *   truncate - paths are truncated to the maximum length
     *   fail - patsh greater than the maximim cause a build exception
     *   warn - paths greater than the maximum cause a warning and GNU is used
     *   gnu - GNU extensions are used for any paths greater than the maximum.
     *   omit - paths greater than the maximum are omitted from the archive
     */
    public void setLongfile(String mode) {
        for (int i = 0; i < validModes.length; ++i) {
            if (mode.equalsIgnoreCase(validModes[i])) {
                this.longFileMode = mode;
                return;
            }
        }
        throw new BuildException(""The longfile value "" + mode + "" is not a valid value"");
    }
    public void execute() throws BuildException {
        if (tarFile == null) {
            throw new BuildException(""tarfile attribute must be set!"", 
                                     location);
        }
        if (tarFile.exists() && tarFile.isDirectory()) {
            throw new BuildException(""tarfile is a directory!"", 
                                     location);
        }
        if (tarFile.exists() && !tarFile.canWrite()) {
            throw new BuildException(""Can not write to the specified tarfile!"", 
                                     location);
        }
        if (baseDir != null) {
            if (!baseDir.exists()) {
                throw new BuildException(""basedir does not exist!"", location);
            }
            // add the main fileset to the list of filesets to process.
            TarFileSet mainFileSet = new TarFileSet(fileset);
            mainFileSet.setDir(baseDir);
            mainFileSet.setDefaultexcludes(useDefaultExcludes);
            filesets.addElement(mainFileSet);
        }
        if (filesets.size() == 0) {
            throw new BuildException(""You must supply either a basdir attribute or some nested filesets."", 
                                     location);
        }
        // check if tr is out of date with respect to each
        // fileset
        boolean upToDate = true;
        for (Enumeration e = filesets.elements(); e.hasMoreElements();) {
            TarFileSet fs = (TarFileSet)e.nextElement();
            String[] files = fs.getFiles(project);
            if (!archiveIsUpToDate(files)) {
                upToDate = false;
            }
            for (int i = 0; i < files.length; ++i) {
                if (tarFile.equals(new File(fs.getDir(project), files[i]))) {
                    throw new BuildException(""A tar file cannot include itself"", location);
                }
            }
        }
        if (upToDate) {
            log(""Nothing to do: ""+tarFile.getAbsolutePath()+"" is up to date."",
                Project.MSG_INFO);
            return;
        }
        log(""Building tar: ""+ tarFile.getAbsolutePath(), Project.MSG_INFO);
        TarOutputStream tOut = null;
        try {
            tOut = new TarOutputStream(new FileOutputStream(tarFile));
            tOut.setDebug(true);
            if (longFileMode.equalsIgnoreCase(TRUNCATE)) {
                tOut.setLongFileMode(TarOutputStream.LONGFILE_TRUNCATE);
            }
            else if (longFileMode.equalsIgnoreCase(FAIL) ||
                     longFileMode.equalsIgnoreCase(OMIT)) {
                tOut.setLongFileMode(TarOutputStream.LONGFILE_ERROR);
            }
            else {
                // warn or GNU
                tOut.setLongFileMode(TarOutputStream.LONGFILE_GNU);
            }
            longWarningGiven = false;
            for (Enumeration e = filesets.elements(); e.hasMoreElements();) {
                TarFileSet fs = (TarFileSet)e.nextElement();
                String[] files = fs.getFiles(project);
                for (int i = 0; i < files.length; i++) {
                    File f = new File(baseDir,files[i]);
                    String name = files[i].replace(File.separatorChar,'/');
                    tarFile(f, tOut, name, fs);
                }
            }
        } catch (IOException ioe) {
            String msg = ""Problem creating TAR: "" + ioe.getMessage();
            throw new BuildException(msg, ioe, location);
        } finally {
            if (tOut != null) {
                try {
                    // close up
                    tOut.close();
                }
                catch (IOException e) {}
            }
        }
    }
    protected void tarFile(File file, TarOutputStream tOut, String vPath,
                           TarFileSet tarFileSet)
        throws IOException
    {
        FileInputStream fIn = new FileInputStream(file);
        try {
            if (vPath.length() >= TarConstants.NAMELEN) {
                if (longFileMode.equalsIgnoreCase(OMIT)) {
                    log(""Omitting: ""+ vPath, Project.MSG_INFO);
                    return;
                } else if (longFileMode.equalsIgnoreCase(WARN)) {
                    log(""Entry: ""+ vPath + "" longer than "" + 
                        TarConstants.NAMELEN + "" characters."", Project.MSG_WARN);
                    if (!longWarningGiven) {                        
                        log(""Resulting tar file can only be processed successfully""
                            + "" by GNU compatible tar commands"", Project.MSG_WARN);
                        longWarningGiven = true;
                    }
                } else if (longFileMode.equalsIgnoreCase(FAIL)) {
                    throw new BuildException(
                        ""Entry: ""+ vPath + "" longer than "" + 
                        TarConstants.NAMELEN + ""characters."", location);
                }
            }
            TarEntry te = new TarEntry(vPath);
            te.setSize(file.length());
            te.setModTime(file.lastModified());
            if (!file.isDirectory()) {
                te.setMode(tarFileSet.getMode());
            }
            te.setUserName(tarFileSet.getUserName());
            te.setGroupName(tarFileSet.getGroup());
            tOut.putNextEntry(te);
            byte[] buffer = new byte[8 * 1024];
            int count = 0;
            do {
                tOut.write(buffer, 0, count);
                count = fIn.read(buffer, 0, buffer.length);
            } while (count != -1);
            tOut.closeEntry();        
        } finally {
            fIn.close();
        }
    }
    protected boolean archiveIsUpToDate(String[] files) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        MergingMapper mm = new MergingMapper();
        mm.setTo(tarFile.getAbsolutePath());
        return sfs.restrict(files, baseDir, null, mm).length == 0;
    }
    static public class TarFileSet extends FileSet {
        private String[] files = null;
        private int mode = 0100644;
        private String userName = """";
        private String groupName = """";
        public TarFileSet(FileSet fileset) {
            super(fileset);
        }
        public TarFileSet() {
            super();
        }
        public String[] getFiles(Project p) {
            if (files == null) {
                DirectoryScanner ds = getDirectoryScanner(p);
                files = ds.getIncludedFiles();
            }
            return files;
        }
        public void setMode(String octalString) {
            this.mode = 0100000 | Integer.parseInt(octalString, 8);
        }
        public int getMode() {
            return mode;
        }
        public void setUserName(String userName) {
            this.userName = userName;
        }
        public String getUserName() {
            return userName;
        }
        public void setGroup(String groupName) {
            this.groupName = groupName;
        }
        public String getGroup() {
            return groupName;
        }
    }
}
"
org.apache.tools.ant.taskdefs.Taskdef,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
/**
 * Define a new task - name and class
 *
 * @author costin@dnt.ro
 */
public class Taskdef extends Task {
    private String name;
    private String value;
    private Path classpath;
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(project);
        }
        return this.classpath.createPath();
    }
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    public void execute() throws BuildException {
        if (name==null || value==null ) {
            String msg = ""name or classname attributes of taskdef element ""
                + ""are undefined"";
            throw new BuildException(msg);
        }
        try {
            ClassLoader loader = null;
            if (classpath != null) {
                AntClassLoader al = new AntClassLoader(project, classpath,
                                                       false);
                // need to load Task via system classloader or the new
                // task we want to define will never be a Task but always
                // be wrapped into a TaskAdapter.
                al.addSystemPackageRoot(""org.apache.tools.ant"");
                loader = al;
            } else {
                loader = this.getClass().getClassLoader();
            }
            Class taskClass = null;
            if (loader != null) {
                taskClass = loader.loadClass(value);
            } else {
                taskClass = Class.forName(value);
            }
            project.addTaskDefinition(name, taskClass);
        } catch (ClassNotFoundException cnfe) {
            String msg = ""taskdef class "" + value +
                "" cannot be found"";
            throw new BuildException(msg, cnfe, location);
        } catch (NoClassDefFoundError ncdfe) {
            String msg = ""taskdef class "" + value +
                "" cannot be found"";
            throw new BuildException(msg, ncdfe, location);
        }
    }
    public void setName( String name) {
        this.name = name;
    }
    public String getClassname() {
        return value;
    }
    public void setClassname(String v) {
        value = v;
    }
}
"
org.apache.tools.ant.taskdefs.TaskOutputStream,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
/**
 * Redirects text written to a stream thru the standard
 * ant logging mechanism. This class is useful for integrating
 * with tools that write to System.out and System.err. For example,
 * the following will cause all text written to System.out to be
 * logged with ""info"" priority:
 * <pre>System.setOut(new PrintStream(new TaskOutputStream(project, Project.MSG_INFO)));</pre>
 *
 * @author James Duncan Davidson (duncan@x180.com)
 * @deprecated use LogOutputStream instead.
 */
public class TaskOutputStream extends OutputStream {
    private Task task;
    private StringBuffer line;
    private int msgOutputLevel;
    /**
     * Constructs a new JavacOutputStream with the given project
     * as the output source for messages.
     */
    TaskOutputStream(Task task, int msgOutputLevel) {
        this.task = task;
        this.msgOutputLevel = msgOutputLevel;
        line = new StringBuffer();
    }
    /**
     * Write a character to the output stream. This method looks
     * to make sure that there isn't an error being reported and
     * will flush each line of input out to the project's log stream.
     */
    public void write(int c) throws IOException {
        char cc = (char)c;
        if (cc == '\r' || cc == '\n') {
            // line feed
            if (line.length() > 0) {
                processLine();
            }
        } else {
            line.append(cc);
        }
    }
    /**
     * Processes a line of input and determines if an error occured.
     */
    private void processLine() {
        String s = line.toString();
        task.log(s, msgOutputLevel);
        line = new StringBuffer();
    }
}
"
org.apache.tools.ant.taskdefs.Touch,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DateFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.Locale;
/**
 * Touch a file - corresponds to the Unix touch command.
 *
 * <p>If the file to touch doesn't exist, an empty one is
 * created. Setting the modification time of files is not supported in
 * JDK 1.1.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class Touch extends Task {
    private File file;              // required
    private long millis = -1;
    private String dateTime;
    private static Method setLastModified = null;
    private static Object lockReflection = new Object();
    /**
     * The name of the file to touch.
     */
    public void setFile(File file) {
        this.file = file;
    }
    /**
     * Milliseconds since 01/01/1970 00:00 am.
     */
    public void setMillis(long millis) {
        this.millis = millis;
    }
    /**
     * Date in the format MM/DD/YYYY HH:MM AM_PM.
     */
    public void setDatetime(String dateTime) {
        this.dateTime = dateTime;
    }
    /**
     * Do the work.
     *
     * @exception BuildException Thrown in unrecoverable error.
     */
    public void execute() throws BuildException {
        if (file.exists() && project.getJavaVersion() == Project.JAVA_1_1) {
            log(""Cannot change the modification time of ""
                + file + "" in JDK 1.1"",
                Project.MSG_WARN);
            return;
        }
        if (dateTime != null) {
            DateFormat df = DateFormat.getDateTimeInstance(DateFormat.SHORT,
                                                           DateFormat.SHORT,
                                                           Locale.US);
            try {
                setMillis(df.parse(dateTime).getTime());
            } catch (ParseException pe) {
                throw new BuildException(pe.getMessage(), pe, location);
            }
        }
        if (millis >= 0 && project.getJavaVersion() == Project.JAVA_1_1) {
            log(file + "" will be created but its modification time cannot be set in JDK 1.1"",
                Project.MSG_WARN);
        }
        touch();
    }
    /**
     * Does the actual work. Entry point for Untar and Expand as well.
     */
    void touch() throws BuildException {
        if (!file.exists()) {
            log(""Creating ""+file, Project.MSG_INFO);
            try {
                FileOutputStream fos = new FileOutputStream(file);
                fos.write(new byte[0]);
                fos.close();
            } catch (IOException ioe) {
                throw new BuildException(""Could not create ""+file, ioe, 
                                         location);
            }
        }
        if (project.getJavaVersion() == Project.JAVA_1_1) {
            return;
        }
        if (setLastModified == null) {
            synchronized (lockReflection) {
                if (setLastModified == null) {
                    try {
                        setLastModified = 
                            java.io.File.class.getMethod(""setLastModified"", 
                                                         new Class[] {Long.TYPE});
                    } catch (NoSuchMethodException nse) {
                        throw new BuildException(""File.setlastModified not in JDK > 1.1?"",
                                                 nse, location);
                    }
                }
            }
        }
        Long[] times = new Long[1];
        if (millis < 0) {
            times[0] = new Long(System.currentTimeMillis());
        } else {
            times[0] = new Long(millis);
        }
        try {
            log(""Setting modification time for ""+file, 
                Project.MSG_VERBOSE);
            setLastModified.invoke(file, times);
        } catch (InvocationTargetException ite) {
            Throwable nested = ite.getTargetException();
            throw new BuildException(""Exception setting the modification time of ""
                                     + file, nested, location);
        } catch (Throwable other) {
            throw new BuildException(""Exception setting the modification time of ""
                                     + file, other, location);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Transform,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.File;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.util.*;
/**
 * Executes a given command, supplying a set of files as arguments. 
 *
 * <p>Only those files that are newer than their corresponding target
 * files will be handeled, the rest will be ignored.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class Transform extends ExecuteOn {
    protected Commandline.Marker targetFilePos = null;
    protected Mapper mapperElement = null;
    protected FileNameMapper mapper = null;
    protected File destDir = null;
    /**
     * Has &lt;srcfile&gt; been specified before &lt;targetfile&gt;
     */
    protected boolean srcIsFirst = true;
    /**
     * Set the destination directory.
     */
    public void setDest(File destDir) {
        this.destDir = destDir;
    }
    /**
     * Marker that indicates where the name of the target file should
     * be put on the command line.
     */
    public Commandline.Marker createTargetfile() {
        if (targetFilePos != null) {
            throw new BuildException(taskType + "" doesn\'t support multiple targetfile elements."",
                                     location);
        }
        targetFilePos = cmdl.createMarker();
        srcIsFirst = (srcFilePos != null);
        return targetFilePos;
    }
    /**
     * Defines the FileNameMapper to use (nested mapper element).
     */
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     location);
        }
        mapperElement = new Mapper(project);
        return mapperElement;
    }
    protected void checkConfiguration() {
        super.checkConfiguration();
        if (mapperElement == null) {
            throw new BuildException(""no mapper specified"", location);
        }
        if (destDir == null) {
            throw new BuildException(""no dest attribute specified"", location);
        }
        mapper = mapperElement.getImplementation();
    }
    /**
     * Return the list of files from this DirectoryScanner that should
     * be included on the command line - i.e. only those that are
     * newer than the corresponding target files.
     */
    protected String[] getFiles(File baseDir, DirectoryScanner ds) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        return sfs.restrict(ds.getIncludedFiles(), baseDir, destDir, mapper);
    }
    /**
     * Return the list of Directories from this DirectoryScanner that
     * should be included on the command line - i.e. only those that
     * are newer than the corresponding target files.
     */
    protected String[] getDirs(File baseDir, DirectoryScanner ds) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        return sfs.restrict(ds.getIncludedDirectories(), baseDir, destDir, 
                            mapper);
    }
    /**
     * Construct the command line for parallel execution.
     *
     * @param srcFiles The filenames to add to the commandline
     * @param baseDir filenames are relative to this dir
     */
    protected String[] getCommandline(String[] srcFiles, File baseDir) {
        if (targetFilePos == null) {
            return super.getCommandline(srcFiles, baseDir);
        }
        Vector targets = new Vector();
        Hashtable addedFiles = new Hashtable();
        for (int i=0; i<srcFiles.length; i++) {
            String[] subTargets = mapper.mapFileName(srcFiles[i]);
            if (subTargets != null) {
                for (int j=0; j<subTargets.length; j++) {
                    String name = (new File(destDir, subTargets[j])).getAbsolutePath();
                    if (!addedFiles.contains(name)) {
                        targets.addElement(name);
                        addedFiles.put(name, name);
                    }
                }
            }
        }
        String[] targetFiles = new String[targets.size()];
        targets.copyInto(targetFiles);
        String[] orig = cmdl.getCommandline();
        String[] result = new String[orig.length+srcFiles.length+targetFiles.length];
        int srcIndex = orig.length;
        if (srcFilePos != null) {
            srcIndex = srcFilePos.getPosition();
        }
        int targetIndex = targetFilePos.getPosition();
        if (srcIndex < targetIndex || (srcIndex == targetIndex && srcIsFirst)) {
            // 0 --> srcIndex
            System.arraycopy(orig, 0, result, 0, srcIndex);
            // srcIndex --> targetIndex
            System.arraycopy(orig, srcIndex, result, 
                             srcIndex + srcFiles.length,
                             targetIndex - srcIndex);
            // targets are already absolute file names
            System.arraycopy(targetFiles, 0, result, 
                             targetIndex + srcFiles.length, 
                             targetFiles.length);
            // targetIndex --> end
            System.arraycopy(orig, targetIndex, result, 
                             targetIndex + srcFiles.length + targetFiles.length,
                             orig.length - targetIndex);
        } else {
            // 0 --> targetIndex
            System.arraycopy(orig, 0, result, 0, targetIndex);
            // targets are already absolute file names
            System.arraycopy(targetFiles, 0, result, 
                             targetIndex,
                             targetFiles.length);
            // targetIndex --> srcIndex
            System.arraycopy(orig, targetIndex, result, 
                             targetIndex + targetFiles.length,
                             srcIndex - targetIndex);
            // srcIndex --> end
            System.arraycopy(orig, srcIndex, result, 
                             srcIndex + srcFiles.length + targetFiles.length,
                             orig.length - srcIndex);
            srcIndex += targetFiles.length;
        }
        for (int i=0; i < srcFiles.length; i++) {
            result[srcIndex+i] = 
                (new File(baseDir, srcFiles[i])).getAbsolutePath();
        }
        return result;
    }
    /**
     * Construct the command line for serial execution.
     *
     * @param srcFile The filename to add to the commandline
     * @param baseDir filename is relative to this dir
     */
    protected String[] getCommandline(String srcFile, File baseDir) {
        return getCommandline(new String[] {srcFile}, baseDir);
    }
}
"
org.apache.tools.ant.taskdefs.Tstamp,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.*;
import java.text.*;
/**
 * Sets TSTAMP, DSTAMP and TODAY
 *
 * @author costin@dnt.ro
 * @author stefano@apache.org
 * @author roxspring@yahoo.com
 * @author conor@cognet.com.au
 */
public class Tstamp extends Task {
    private Vector customFormats = new Vector();
    public void execute() throws BuildException {
        try {
            Date d = new Date();
            SimpleDateFormat dstamp = new SimpleDateFormat (""yyyyMMdd"");
            project.setProperty(""DSTAMP"", dstamp.format(d));
            SimpleDateFormat tstamp = new SimpleDateFormat (""HHmm"");
            project.setProperty(""TSTAMP"", tstamp.format(d));
            SimpleDateFormat today  = new SimpleDateFormat (""MMMM d yyyy"", Locale.US);
            project.setProperty(""TODAY"", today.format(d));
            Enumeration i = customFormats.elements();
            while(i.hasMoreElements())
            {
                CustomFormat cts = (CustomFormat)i.nextElement();
                cts.execute(project,d, location);
            }
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }
    public CustomFormat createFormat()
    {
        CustomFormat cts = new CustomFormat();
        customFormats.addElement(cts);
        return cts;
    }
    public class CustomFormat
    {
        private String propertyName;
        private String pattern;
        private int offset = 0;
        private int field = Calendar.DATE;
        public CustomFormat()
        {
        }
        public void setProperty(String propertyName)
        {
            this.propertyName = propertyName;
        }
        public void setPattern(String pattern)
        {
            this.pattern = pattern;
        }
        public void setOffset(int offset) {
            this.offset = offset;
        }
        public void setUnit(String unit) {
            if (unit.equalsIgnoreCase(""millisecond"")) {
                field = Calendar.MILLISECOND;
            }
            else if (unit.equalsIgnoreCase(""second"")) {
                field = Calendar.SECOND;
            }
            else if (unit.equalsIgnoreCase(""minute"")) {
                field = Calendar.MINUTE;
            }
            else if (unit.equalsIgnoreCase(""hour"")) {
                field = Calendar.HOUR_OF_DAY;
            }
            else if (unit.equalsIgnoreCase(""day"")) {
                field = Calendar.DATE;
            }
            else if (unit.equalsIgnoreCase(""week"")) {
                field = Calendar.WEEK_OF_YEAR;
            }
            else if (unit.equalsIgnoreCase(""month"")) {
                field = Calendar.MONTH;
            }
            else if (unit.equalsIgnoreCase(""year"")) {
                field = Calendar.YEAR;
            }
            else {
                throw new BuildException(unit + "" is not a unit supported by the tstamp task"");
            }
        }            
        public void execute(Project project, Date date, Location location)
        {
            if (propertyName == null) {
                throw new BuildException(""property attribute must be provided"", location);
            }
            if (pattern == null) {
                throw new BuildException(""pattern attribute must be provided"", location);
            }
            SimpleDateFormat sdf = new SimpleDateFormat (pattern);
            if (offset != 0) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(field, offset);
                date = calendar.getTime();
            }
            project.setProperty(propertyName, sdf.format(date));
        }
    }
}
"
org.apache.tools.ant.taskdefs.Untar,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.tar.*;
import java.io.*;
/**
 * Untar a file.
 *
 * Heavily based on the Expand task.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class Untar extends Task {
    private String dest; // req
    private String source; // req
    /**
     * Do the work.
     *
     * @exception BuildException Thrown in unrecoverable error.
     */
    public void execute() throws BuildException {
        Touch touch = (Touch) project.createTask(""touch"");
        touch.setOwningTarget(target);
        touch.setTaskName(getTaskName());
        touch.setLocation(getLocation());
        File srcF=project.resolveFile(source);
        TarInputStream tis = null;
        try {
            if (source == null) {
                throw new BuildException(""No source specified"", location);
            }
            if (!srcF.exists()) {
                throw new BuildException(""source ""+srcF+"" doesn't exist"",
                                         location);
            }
            if (dest == null) {
                throw new BuildException(""No destination specified"", location);
            }
            File dir=project.resolveFile(dest);
            log(""Expanding: "" + srcF + "" into "" + dir, Project.MSG_INFO);
            tis = new TarInputStream(new FileInputStream(srcF));
            TarEntry te = null;
            while ((te = tis.getNextEntry()) != null) {
                try {
                    File f = new File(dir, project.translatePath(te.getName()));
                    log(""expand-file "" + te.getName(), Project.MSG_VERBOSE );
                    // create intermediary directories - sometimes tar don't add them
                    File dirF=new File(f.getParent());
                    dirF.mkdirs();
                    if (te.isDirectory()) {
                        f.mkdirs();
                    } else {
                        byte[] buffer = new byte[1024];
                        int length = 0;
                        FileOutputStream fos = new FileOutputStream(f);
                        while ((length = tis.read(buffer)) >= 0) {
                            fos.write(buffer, 0, length);
                        }
                        fos.close();
                    }
                    if (project.getJavaVersion() != Project.JAVA_1_1) {
                        touch.setFile(f);
                        touch.setMillis(te.getModTime().getTime());
                        touch.touch();
                    }
                } catch(FileNotFoundException ex) {
                    log(""FileNotFoundException: "" + te.getName(),
                        Project.MSG_WARN);
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(""Error while expanding "" + srcF.getPath(),
                                     ioe, location);
	} finally {
	    if (tis != null) {
	        try {
	            tis.close();
	        }
	        catch (IOException e) {}
	    }
	}
    }
    /**
     * Set the destination directory. File will be untared into the
     * destination directory.
     *
     * @param d Path to the directory.
     */
    public void setDest(String d) {
        this.dest=d;
    }
    /**
     * Set the path to tar-file.
     *
     * @param s Path to tar-file.
     */
    public void setSrc(String s) {
        this.source = s;
    }
}
"
org.apache.tools.ant.taskdefs.UpToDate,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.util.*;
import java.io.*;
import java.util.Enumeration;
import java.util.Date;
import java.util.Vector;
/**
 * Will set the given property if the specified target has a timestamp
 * greater than all of the source files.
 *
 * @author William Ferguson <a href=""mailto:williamf@mincom.com"">williamf@mincom.com</a> 
 * @author Hiroaki Nakamura <a href=""mailto:hnakamur@mc.neweb.ne.jp"">hnakamur@mc.neweb.ne.jp</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class UpToDate extends MatchingTask {
    private String _property;
    private File _targetFile;
    private Vector sourceFileSets = new Vector();
    protected Mapper mapperElement = null;
    /**
     * The property to set if the target file is more up to date than each of
     * the source files.
     *
     * @param property the name of the property to set if Target is up to date.
     */
    public void setProperty(String property) {
        _property = property;
    }
    /**
     * The file which must be more up to date than each of the source files
     * if the property is to be set.
     *
     * @param file the file which we are checking against.
     */
    public void setTargetFile(File file) {
        _targetFile = file;
    }
    /**
     * Nested &lt;srcfiles&gt; element.
     */
    public void addSrcfiles(FileSet fs) {
        sourceFileSets.addElement(fs);
    }
    /**
     * Defines the FileNameMapper to use (nested mapper element).
     */
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     location);
        }
        mapperElement = new Mapper(project);
        return mapperElement;
    }
    /**
     * Sets property to true if target files have a more recent timestamp than
     * each of the corresponding source files.
     */
    public void execute() throws BuildException {
        if (sourceFileSets.size() == 0) {
          throw new BuildException(""At least one <srcfiles> element must be set"");
        }
        if (_targetFile == null && mapperElement == null) {
          throw new BuildException(""The targetfile attribute or a nested mapper element must be set"");
        }
        // if not there then it can't be up to date
        if (_targetFile != null && !_targetFile.exists()) return; 
        Enumeration enum = sourceFileSets.elements();
        boolean upToDate = true;
        while (upToDate && enum.hasMoreElements()) {
            FileSet fs = (FileSet) enum.nextElement();
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            upToDate = upToDate && scanDir(fs.getDir(project), 
                                           ds.getIncludedFiles());
        }
        if (upToDate) {
            this.project.setProperty(_property, ""true"");
            if (mapperElement == null) {
                log(""File \"""" + _targetFile.getAbsolutePath() + ""\"" is up to date."",
                    Project.MSG_VERBOSE);
            } else {
                log(""All target files have been up to date."",
                    Project.MSG_VERBOSE);
            }
        }
    }
    protected boolean scanDir(File srcDir, String files[]) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        FileNameMapper mapper = null;
        if (mapperElement == null) {
            MergingMapper mm = new MergingMapper();
            mm.setTo(_targetFile.getAbsolutePath());
            mapper = mm;
        } else {
            mapper = mapperElement.getImplementation();
        }
        return sfs.restrict(files, srcDir, null, mapper).length == 0;
    }
}
"
org.apache.tools.ant.taskdefs.War,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.ZipFileSet;
import java.io.*;
import java.util.Vector;
import java.util.zip.*;
/**
 * Creates a WAR archive.
 * 
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class War extends Jar {
    private File deploymentDescriptor;
    private boolean descriptorAdded;    
    public War() {
        super();
        archiveType = ""war"";
        emptyBehavior = ""create"";
    }
    public void setWarfile(File warFile) {
        super.setZipfile(warFile);
    }
    public void setWebxml(File descr) {
        deploymentDescriptor = descr; 
        if (!deploymentDescriptor.exists())
            throw new BuildException(""Deployment descriptor: "" + deploymentDescriptor + "" does not exist."");
        // Create a ZipFileSet for this file, and pass it up.
        ZipFileSet fs = new ZipFileSet();
        fs.setDir(new File(deploymentDescriptor.getParent()));
        fs.setIncludes(deploymentDescriptor.getName());
        fs.setFullpath(""WEB-INF/web.xml"");
        super.addFileset(fs);
    }
    public void addLib(ZipFileSet fs) {
        // We just set the prefix for this fileset, and pass it up.
        fs.setPrefix(""WEB-INF/lib/"");
        super.addFileset(fs);
    }
    public void addClasses(ZipFileSet fs) {
        // We just set the prefix for this fileset, and pass it up.
        fs.setPrefix(""WEB-INF/classes/"");
        super.addFileset(fs);
    }
    public void addWebinf(ZipFileSet fs) {
        // We just set the prefix for this fileset, and pass it up.
        fs.setPrefix(""WEB-INF/"");
        super.addFileset(fs);
    }
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException
    {
        // If no webxml file is specified, it's an error.
        if (deploymentDescriptor == null) {
            throw new BuildException(""webxml attribute is required"", location);
        }
        super.initZipOutputStream(zOut);
    }
    protected void zipFile(File file, ZipOutputStream zOut, String vPath)
        throws IOException
    {
        // If the file being added is WEB-INF/web.xml, we warn if it's not the
        // one specified in the ""webxml"" attribute - or if it's being added twice, 
        // meaning the same file is specified by the ""webxml"" attribute and in
        // a <fileset> element.
        if (vPath.equalsIgnoreCase(""WEB-INF/web.xml""))  {
            if (deploymentDescriptor == null || !deploymentDescriptor.equals(file) || descriptorAdded) {
                log(""Warning: selected ""+archiveType+"" files include a WEB-INF/web.xml which will be ignored "" +
                    ""(please use webxml attribute to ""+archiveType+"" task)"", Project.MSG_WARN);
            } else {
                super.zipFile(file, zOut, vPath);
                descriptorAdded = true;
            }
        } else {
            super.zipFile(file, zOut, vPath);
        }
    }
    /**
     * Make sure we don't think we already have a web.xml next time this task
     * gets executed.
     */
    protected void cleanUp() {
        descriptorAdded = false;
        super.cleanUp();
    }
}
"
org.apache.tools.ant.taskdefs.XSLTLiaison,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import org.apache.tools.ant.*;
/**
 *
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @version $Revision: 1.3 $ $Date: 2001/01/03 14:18:31 $
 */
public interface XSLTLiaison {
    public void setStylesheet(String fileName) throws Exception;
    public void addParam(String name, String expression) throws Exception;
    public void transform(String infile, String outfile) throws Exception;
} //-- XSLTLiaison
"
org.apache.tools.ant.taskdefs.XSLTProcess,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.*;
/**
 * A Task to process via XSLT a set of XML documents. This is
 * useful for building views of XML based documentation.
 * arguments:
 * <ul>
 * <li>basedir
 * <li>destdir
 * <li>style
 * <li>includes
 * <li>excludes
 * </ul>
 * Of these arguments, the <b>sourcedir</b> and <b>destdir</b> are required.
 * <p>
 * This task will recursively scan the sourcedir and destdir
 * looking for XML documents to process via XSLT. Any other files,
 * such as images, or html files in the source directory will be
 * copied into the destination directory.
 *
 * @author <a href=""mailto:kvisco@exoffice.com"">Keith Visco</a>
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @author <a href=""mailto:russgold@acm.org"">Russell Gold</a>
 * @version $Revision: 1.13 $ $Date: 2001/01/11 09:12:44 $
 */
public class XSLTProcess extends MatchingTask {
    private File destDir = null;
    private File baseDir = null;
    private File xslFile = null;
    private String targetExtension = "".html"";
    private Vector params = new Vector();
    private File inFile = null;
    private File outFile = null;
    private XSLTLiaison liaison;
    /**
     * Creates a new XSLTProcess Task.
     **/
    public XSLTProcess() {
    } //-- XSLTProcess
    /**
     * Executes the task.
     */
    public void execute() throws BuildException {
        DirectoryScanner scanner;
        String[]         list;
        String[]         dirs;
        if (baseDir == null) {
            baseDir = project.resolveFile(""."");
        }
        //-- make sure Source directory exists...
        if (destDir == null ) {
            String msg = ""destdir attributes must be set!"";
            throw new BuildException(msg);
        }
        scanner = getDirectoryScanner(baseDir);
        log(""Transforming into ""+destDir, Project.MSG_INFO);
        // if processor wasn't specified, see if TraX is available.  If not,
        // default it to xslp or xalan, depending on which is in the classpath
        if (liaison == null) {
            try {
                setProcessor(""trax"");
            } catch (Throwable e1) {
                try {
                    setProcessor(""xslp"");
                } catch (Throwable e2) {
                    try {
                        setProcessor(""xalan"");
                    } catch (Throwable e3) {
                        throw new BuildException(e1);
                    }
                }
            }
        }
        log(""Using ""+liaison.getClass().toString(), Project.MSG_VERBOSE);
        long styleSheetLastModified = 0;
        if (xslFile != null) {
            try {
                // Create a new XSL processor with the specified stylesheet
                File file = new File( baseDir, xslFile.toString() );
                styleSheetLastModified = file.lastModified();
                log( ""Loading stylesheet "" + file, Project.MSG_INFO);
                liaison.setStylesheet( file.toString() );
                for(Enumeration e = params.elements();e.hasMoreElements();) {
                    Param p = (Param)e.nextElement();
                    liaison.addParam( p.getName(), p.getExpression() );
                }
            } catch (Exception ex) {
                log(""Failed to read stylesheet "" + xslFile, Project.MSG_INFO);
                throw new BuildException(ex);
            }
        }
        // if we have an in file and out then process them
        if (inFile != null && outFile != null) {
            process(inFile, outFile, styleSheetLastModified);
            return;
        }
        // Process all the files marked for styling
        list = scanner.getIncludedFiles();
        for (int i = 0;i < list.length; ++i) {
            process( baseDir, list[i], destDir, styleSheetLastModified );
        }
        // Process all the directoried marked for styling
        dirs = scanner.getIncludedDirectories();
        for (int j = 0;j < dirs.length;++j){
            list=new File(baseDir,dirs[j]).list();
            for (int i = 0;i < list.length;++i)
                process( baseDir, list[i], destDir, styleSheetLastModified );
        }
    } //-- execute
    /**
     * Set the base directory.
     **/
    public void setBasedir(File dir) {
        baseDir = dir;
    } //-- setSourceDir
    /**
     * Set the destination directory into which the XSL result
     * files should be copied to
     * @param dirName the name of the destination directory
     **/
    public void setDestdir(File dir) {
        destDir = dir;
    } //-- setDestDir
    /**
     * Set the desired file extension to be used for the target
     * @param name the extension to use
     **/
    public void setExtension(String name) {
            targetExtension = name;
    } //-- setDestDir
    /**
     * Sets the file to use for styling relative to the base directory.
     */
    public void setStyle(String xslFile) {
        this.xslFile = new File(xslFile);
    }
    /**
     * Sets the file to use for styling relative to the base directory.
     */
    public void setProcessor(String processor) throws Exception {
        if (processor.equals(""trax"")) {
            final Class clazz = 
                Class.forName(""org.apache.tools.ant.taskdefs.optional.TraXLiaison"");
            liaison = (XSLTLiaison)clazz.newInstance();
        } else if (processor.equals(""xslp"")) {
            final Class clazz = 
                Class.forName(""org.apache.tools.ant.taskdefs.optional.XslpLiaison"");
            liaison = (XSLTLiaison) clazz.newInstance();
        } else if (processor.equals(""xalan"")) {
            final Class clazz = 
                Class.forName(""org.apache.tools.ant.taskdefs.optional.XalanLiaison"");
            liaison = (XSLTLiaison)clazz.newInstance();
        } else {
            liaison = (XSLTLiaison) Class.forName(processor).newInstance();
        }
    }
    /**
     * Sets an out file
     */
    public void setOut(File outFile){
        this.outFile = outFile;
    }
    /**
     * Sets an input xml file to be styled
     */
    public void setIn(File inFile){
        this.inFile = inFile;
    }
    /**
     * Processes the given input XML file and stores the result
     * in the given resultFile.
     **/
    private void process(File baseDir, String xmlFile, File destDir, 
                         long styleSheetLastModified)
        throws BuildException {
        String fileExt=targetExtension;
        File   outFile=null;
        File   inFile=null;
        try {
            inFile = new File(baseDir,xmlFile);
            int dotPos = xmlFile.lastIndexOf('.');
            if(dotPos>0){
                outFile = new File(destDir,xmlFile.substring(0,xmlFile.lastIndexOf('.'))+fileExt);
            }else{
                outFile = new File(destDir,xmlFile+fileExt);
            }
            if (inFile.lastModified() > outFile.lastModified() ||
                styleSheetLastModified > outFile.lastModified()) {
                ensureDirectoryFor( outFile );
                log(""Transforming into ""+destDir);
                liaison.transform(inFile.toString(), outFile.toString());
            }
        }
        catch (Exception ex) {
            // If failed to process document, must delete target document,
            // or it will not attempt to process it the second time
            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if (outFile != null) {
                outFile.delete();
            }
            throw new BuildException(ex);
        }
    } //-- processXML
    private void process(File inFile, File outFile, long styleSheetLastModified) throws BuildException {
        try{
            log(""In file ""+inFile+"" time: "" + inFile.lastModified() , Project.MSG_DEBUG);
            log(""Out file ""+outFile+"" time: "" + outFile.lastModified() , Project.MSG_DEBUG);
            log(""Style file ""+xslFile+"" time: "" + styleSheetLastModified , Project.MSG_DEBUG);
            if (inFile.lastModified() > outFile.lastModified() ||
                styleSheetLastModified > outFile.lastModified()) {
                ensureDirectoryFor( outFile );
                log(""Processing "" + inFile + "" to "" + outFile, Project.MSG_INFO);
                liaison.transform(inFile.toString(), outFile.toString());
            }
        }catch (Exception ex) {
            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if(outFile!=null)outFile.delete();
            throw new BuildException(ex);
        }
    }
    private void ensureDirectoryFor( File targetFile ) throws BuildException {
        File directory = new File( targetFile.getParent() );
        if (!directory.exists()) {
            if (!directory.mkdirs()) {
                throw new BuildException(""Unable to create directory: "" 
                                         + directory.getAbsolutePath() );
            }
        }
    }
    public Param createParam() {
        Param p = new Param();
        params.addElement(p);
        return p;
    }
    public class Param {
        private String name=null;
        private String expression=null;
        public void setName(String name){
            this.name = name;
        }
        public void setExpression(String expression){
            this.expression = expression;
        }
        public String getName() throws BuildException{
            if(name==null)throw new BuildException(""Name attribute is missing."");
            return name;
        }
        public String getExpression() throws BuildException{
            if(expression==null)throw new BuildException(""Expression attribute is missing."");
            return expression;
        }
    }
} //-- XSLTProcess
"
org.apache.tools.ant.taskdefs.Zip,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs;
import java.io.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.zip.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.util.*;
/**
 * Create a ZIP archive.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Zip extends MatchingTask {
    private File zipFile;
    private File baseDir;
    private boolean doCompress = true;
    protected String archiveType = ""zip"";
    // For directories:
    private static long emptyCrc = new CRC32 ().getValue ();
    protected String emptyBehavior = ""skip"";
    private Vector filesets = new Vector ();
    private Hashtable addedDirs = new Hashtable();
    /**
     * This is the name/location of where to 
     * create the .zip file.
     */
    public void setZipfile(File zipFile) {
        this.zipFile = zipFile;
    }
    /**
     * This is the base directory to look in for 
     * things to zip.
     */
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }
    /**
     * Sets whether we want to compress the files or only store them.
     */
    public void setCompress(boolean c) {
        doCompress = c;
    }
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * Adds a set of files (nested zipfileset attribute) that can be
     * read from an archive and be given a prefix/fullpath.
     */
    public void addZipfileset(ZipFileSet set) {
        filesets.addElement(set);
    }
    /**
     * Sets behavior of the task when no files match.
     * Possible values are: <code>fail</code> (throw an exception
     * and halt the build); <code>skip</code> (do not create
     * any archive, but issue a warning); <code>create</code>
     * (make an archive with no entries).
     * Default for zip tasks is <code>skip</code>;
     * for jar tasks, <code>create</code>.
     */
    public void setWhenempty(String we) throws BuildException {
        we = we.toLowerCase();
        // XXX could instead be using EnumeratedAttribute, but this works
        if (!""fail"".equals(we) && !""skip"".equals(we) && !""create"".equals(we))
            throw new BuildException(""Unrecognized whenempty attribute: "" + we);
        emptyBehavior = we;
    }
    public void execute() throws BuildException {
        if (baseDir == null && filesets.size() == 0 && ""zip"".equals(archiveType)) {
            throw new BuildException( ""basedir attribute must be set, or at least "" + 
                                      ""one fileset must be given!"" );
        }
        if (zipFile == null) {
            throw new BuildException(""You must specify the "" + archiveType + "" file to create!"");
        }
        // Create the scanners to pass to isUpToDate().
        Vector dss = new Vector ();
        if (baseDir != null)
            dss.addElement(getDirectoryScanner(baseDir));
        for (int i=0; i<filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            dss.addElement (fs.getDirectoryScanner(project));
        }
        int dssSize = dss.size();
        FileScanner[] scanners = new FileScanner[dssSize];
        dss.copyInto(scanners);
        // quick exit if the target is up to date
        // can also handle empty archives
        if (isUpToDate(scanners, zipFile)) return;
        log(""Building ""+ archiveType +"": ""+ zipFile.getAbsolutePath());
        try {
            boolean success = false;
            ZipOutputStream zOut = 
              new ZipOutputStream(new FileOutputStream(zipFile));
            try {
                if (doCompress) {
                    zOut.setMethod(ZipOutputStream.DEFLATED);
                } else {
                    zOut.setMethod(ZipOutputStream.STORED);
                }
                initZipOutputStream(zOut);
                // Add the implicit fileset to the archive.
                if (baseDir != null)
                    addFiles(getDirectoryScanner(baseDir), zOut, """", """");
                // Add the explicit filesets to the archive.
                addFiles(filesets, zOut);
                success = true;
            } finally {
                // Close the output stream.
                try {
                    if (zOut != null)
                        zOut.close ();
                } catch(IOException ex) {
                    // If we're in this finally clause because of an exception, we don't 
                    // really care if there's an exception when closing the stream. E.g. if it
                    // throws ""ZIP file must have at least one entry"", because an exception happened
                    // before we added any files, then we must swallow this exception. Otherwise,
                    // the error that's reported will be the close() error, which is not the real 
                    // cause of the problem.
                    if (success)
                        throw ex;
                }
            }
        } catch (IOException ioe) {
            String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
            // delete a bogus ZIP file
            if (!zipFile.delete()) {
                msg += "" (and the archive is probably corrupt but I could not delete it)"";
            }
            throw new BuildException(msg, ioe, location);
        } finally {
            cleanUp();
        }
    }
    /**
     * Add all files of the given FileScanner to the ZipOutputStream
     * prependig the given prefix to each filename.
     *
     * <p>Ensure parent directories have been added as well.  
     */
    protected void addFiles(FileScanner scanner, ZipOutputStream zOut, 
                            String prefix, String fullpath) throws IOException {
        if (prefix.length() > 0 && fullpath.length() > 0)
             throw new BuildException(""Both prefix and fullpath attributes may not be set on the same fileset."");
        File thisBaseDir = scanner.getBasedir();
        // directories that matched include patterns
        String[] dirs = scanner.getIncludedDirectories();
        if (dirs.length > 0 && fullpath.length() > 0)
            throw new BuildException(""fullpath attribute may only be specified for filesets that specify a single file."");
        for (int i = 0; i < dirs.length; i++) {
            String name = dirs[i].replace(File.separatorChar,'/');
            if (!name.endsWith(""/"")) {
                name += ""/"";
            }
            addParentDirs(thisBaseDir, name, zOut, prefix);
        }
        // files that matched include patterns
        String[] files = scanner.getIncludedFiles();
         if (files.length > 1 && fullpath.length() > 0)
            throw new BuildException(""fullpath attribute may only be specified for filesets that specify a single file."");
        for (int i = 0; i < files.length; i++) {
            File f = new File(thisBaseDir, files[i]);
            if (fullpath.length() > 0)
            {
                // Add this file at the specified location.
                addParentDirs(null, fullpath, zOut, """");
                zipFile(f, zOut, fullpath);
            }
            else
            {
                // Add this file with the specified prefix.
                String name = files[i].replace(File.separatorChar,'/');
                addParentDirs(thisBaseDir, name, zOut, prefix);
                zipFile(f, zOut, prefix+name);
            }
        }
    }
    protected void addZipEntries(ZipFileSet fs, DirectoryScanner ds,
      ZipOutputStream zOut, String prefix)
        throws IOException
    {
        ZipScanner zipScanner = (ZipScanner) ds;
        File zipSrc = fs.getSrc();
        ZipEntry entry;
        ZipInputStream in = new ZipInputStream(new FileInputStream(zipSrc));
        while ((entry = in.getNextEntry()) != null) {
            String vPath = entry.getName();
            if (zipScanner.match(vPath)) {
                addParentDirs(null, vPath, zOut, prefix);
                if (! entry.isDirectory()) {
                  zipFile(in, zOut, prefix+vPath, entry.getTime());
                }
            }
        }
    }
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException
    {
    }
    /**
     * Check whether the archive is up-to-date; and handle behavior for empty archives.
     * @param scanners list of prepared scanners containing files to archive
     * @param zipFile intended archive file (may or may not exist)
     * @return true if nothing need be done (may have done something already); false if
     *         archive creation should proceed
     * @exception BuildException if it likes
     */
    protected boolean isUpToDate(FileScanner[] scanners, File zipFile) throws BuildException
    {
        String[][] fileNames = grabFileNames(scanners);
        File[] files = grabFiles(scanners, fileNames);
        if (files.length == 0) {
            if (emptyBehavior.equals(""skip"")) {
                log(""Warning: skipping ""+archiveType+"" archive "" + zipFile +
                    "" because no files were included."", Project.MSG_WARN);
                return true;
            } else if (emptyBehavior.equals(""fail"")) {
                throw new BuildException(""Cannot create ""+archiveType+"" archive "" + zipFile +
                                         "": no files were included."", location);
            } else {
                // Create.
                if (zipFile.exists()) return true;
                // In this case using java.util.zip will not work
                // because it does not permit a zero-entry archive.
                // Must create it manually.
                log(""Note: creating empty ""+archiveType+"" archive "" + zipFile, Project.MSG_INFO);
                try {
                    OutputStream os = new FileOutputStream(zipFile);
                    try {
                        // Cf. PKZIP specification.
                        byte[] empty = new byte[22];
                        empty[0] = 80; // P
                        empty[1] = 75; // K
                        empty[2] = 5;
                        empty[3] = 6;
                        // remainder zeros
                        os.write(empty);
                    } finally {
                        os.close();
                    }
                } catch (IOException ioe) {
                    throw new BuildException(""Could not create empty ZIP archive"", ioe, location);
                }
                return true;
            }
        } else {
            for (int i = 0; i < files.length; ++i) {
                if (files[i].equals(zipFile)) {
                    throw new BuildException(""A zip file cannot include itself"", location);
                }
            }
            if (!zipFile.exists()) return false;
            SourceFileScanner sfs = new SourceFileScanner(this);
            MergingMapper mm = new MergingMapper();
            mm.setTo(zipFile.getAbsolutePath());
            for (int i=0; i<scanners.length; i++) {
                if (sfs.restrict(fileNames[i], scanners[i].getBasedir(), null,
                                 mm).length > 0) {
                    return false;
                }
            }
            return true;
        }
    }
    protected static File[] grabFiles(FileScanner[] scanners) {
        return grabFiles(scanners, grabFileNames(scanners));
    }
    protected static File[] grabFiles(FileScanner[] scanners, 
                                      String[][] fileNames) {
        Vector files = new Vector();
        for (int i = 0; i < fileNames.length; i++) {
            File thisBaseDir = scanners[i].getBasedir();
            for (int j = 0; j < fileNames[i].length; j++)
                files.addElement(new File(thisBaseDir, fileNames[i][j]));
        }
        File[] toret = new File[files.size()];
        files.copyInto(toret);
        return toret;
    }
    protected static String[][] grabFileNames(FileScanner[] scanners) {
        String[][] result = new String[scanners.length][];
        for (int i=0; i<scanners.length; i++) {
            String[] files = scanners[i].getIncludedFiles();
            String[] dirs = scanners[i].getIncludedDirectories();
            result[i] = new String[files.length + dirs.length];
            System.arraycopy(files, 0, result[i], 0, files.length);
            System.arraycopy(dirs, 0, result[i], files.length, dirs.length);
        }
        return result;
    }
    protected void zipDir(File dir, ZipOutputStream zOut, String vPath)
        throws IOException
    {
        if (addedDirs.get(vPath) != null) {
            // don't add directories we've already added.
            // no warning if we try, it is harmless in and of itself
            return;
        }
        addedDirs.put(vPath, vPath);
        ZipEntry ze = new ZipEntry (vPath);
        if (dir != null) ze.setTime (dir.lastModified ());
        ze.setSize (0);
        ze.setMethod (ZipEntry.STORED);
        // This is faintly ridiculous:
        ze.setCrc (emptyCrc);
        zOut.putNextEntry (ze);
    }
    protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath,
                           long lastModified)
        throws IOException
    {
        ZipEntry ze = new ZipEntry(vPath);
        ze.setTime(lastModified);
        /*
         * XXX ZipOutputStream.putEntry expects the ZipEntry to know its
         * size and the CRC sum before you start writing the data when using 
         * STORED mode.
         *
         * This forces us to process the data twice.
         *
         * I couldn't find any documentation on this, just found out by try 
         * and error.
         */
        if (!doCompress) {
            long size = 0;
            CRC32 cal = new CRC32();
            if (!in.markSupported()) {
                // Store data into a byte[]
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    size += count;
                    cal.update(buffer, 0, count);
                    bos.write(buffer, 0, count);
                    count = in.read(buffer, 0, buffer.length);
                } while (count != -1);
                in = new ByteArrayInputStream(bos.toByteArray());
            } else {
                in.mark(Integer.MAX_VALUE);
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    size += count;
                    cal.update(buffer, 0, count);
                    count = in.read(buffer, 0, buffer.length);
                } while (count != -1);
                in.reset();
            }
            ze.setSize(size);
            ze.setCrc(cal.getValue());
        }
        zOut.putNextEntry(ze);
        byte[] buffer = new byte[8 * 1024];
        int count = 0;
        do {
            zOut.write(buffer, 0, count);
            count = in.read(buffer, 0, buffer.length);
        } while (count != -1);
    }
    protected void zipFile(File file, ZipOutputStream zOut, String vPath)
        throws IOException
    {
        if (file.equals(zipFile)) {
            throw new BuildException(""A zip file cannot include itself"", location);
        }
        FileInputStream fIn = new FileInputStream(file);
        try {
            zipFile(fIn, zOut, vPath, file.lastModified());
        } finally {
            fIn.close();
        }
    }
    /**
     * Ensure all parent dirs of a given entry have been added.
     */
    protected void addParentDirs(File baseDir, String entry,
                                 ZipOutputStream zOut, String prefix)
        throws IOException {
        Stack directories = new Stack();
        int slashPos = entry.length();
        while ((slashPos = entry.lastIndexOf((int)'/', slashPos-1)) != -1) {
            String dir = entry.substring(0, slashPos+1);
            if (addedDirs.get(prefix+dir) != null) {
                break;
            }
            directories.push(dir);
        }
        while (!directories.isEmpty()) {
            String dir = (String) directories.pop();
            File f = null;
            if (baseDir != null) {
                f = new File(baseDir, dir);
            } else {
                f = new File(dir);
            }
            zipDir(f, zOut, prefix+dir);
        }
    }
    /**
     * Iterate over the given Vector of (zip)filesets and add
     * all files to the ZipOutputStream using the given prefix.
     */
    protected void addFiles(Vector filesets, ZipOutputStream zOut)
        throws IOException {
        // Add each fileset in the Vector.
        for (int i = 0; i<filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            String prefix = """";
            String fullpath = """";
            if (fs instanceof ZipFileSet) {
                ZipFileSet zfs = (ZipFileSet) fs;
                prefix = zfs.getPrefix();
                fullpath = zfs.getFullpath();
            }
            if (prefix.length() > 0 
                && !prefix.endsWith(""/"")
                && !prefix.endsWith(""\\"")) {
                prefix += ""/"";
            }
            // Need to manually add either fullpath's parent directory, or 
            // the prefix directory, to the archive. 
            if (prefix.length() > 0) {
                addParentDirs(null, prefix, zOut, """");
                zipDir(null, zOut, prefix);
            } else if (fullpath.length() > 0) {
                addParentDirs(null, fullpath, zOut, """");
            }
            if (fs instanceof ZipFileSet
                && ((ZipFileSet) fs).getSrc() != null) {
                addZipEntries((ZipFileSet) fs, ds, zOut, prefix);
            } else {
                // Add the fileset.
                addFiles(ds, zOut, prefix, fullpath);
            }
        }
    }
    /**
     * Do any clean up necessary to allow this instance to be used again.
     *
     * <p>When we get here, the Zip file has been closed and all we
     * need to do is to reset some globals.</p>
     */
    protected void cleanUp() {}
}
"
org.apache.tools.ant.taskdefs.compilers.CompilerAdapter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Javac;
/**
 * The interface that all compiler adapters must adher to.  
 *
 * <p>A compiler adapter is an adapter that interprets the javac's
 * parameters in preperation to be passed off to the compier this
 * adapter represents.  As all the necessary values are stored in the
 * Javac task itself, the only thing all adapters need is the javac
 * task, the execute command and a parameterless constructor (for
 * reflection).</p>
 *
 * @author Jay Dickon Glanville <a href=""mailto:jayglanville@home.com"">jayglanville@home.com</a>
 */
public interface CompilerAdapter {
    /**
     * Sets the compiler attributes, which are stored in the Javac task.
     */
    public void setJavac( Javac attributes );
    /**
     * Executes the task.
     *
     * @return has the compilation been successful
     */
    public boolean execute() throws BuildException;
}
"
org.apache.tools.ant.taskdefs.compilers.CompilerAdapterFactory,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
/**
 * Creates the necessary compiler adapter, given basic criteria.
 *
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class CompilerAdapterFactory {
    /** This is a singlton -- can't create instances!! */
    private CompilerAdapterFactory() {
    }
    /**
     * Based on the parameter passed in, this method creates the necessary
     * factory desired.
     *
     * The current mapping for compiler names are as follows:
     * <ul><li>jikes = jikes compiler
     * <li>classic, javac1.1, javac1.2 = the standard compiler from JDK
     * 1.1/1.2
     * <li>modern, javac1.3 = the new compiler of JDK 1.3
     * <li>jvc, microsoft = the command line compiler from Microsoft's SDK
     * for Java / Visual J++
     * <li><i>a fully quallified classname</i> = the name of a compiler
     * adapter
     * </ul>
     *
     * @param compilerType either the name of the desired compiler, or the
     * full classname of the compiler's adapter.
     * @param task a task to log through.
     * @throws BuildException if the compiler type could not be resolved into
     * a compiler adapter.
     */
    public static CompilerAdapter getCompiler( String compilerType, Task task ) 
        throws BuildException {
            /* If I've done things right, this should be the extent of the
             * conditional statements required.
             */
            if ( compilerType.equalsIgnoreCase(""jikes"") ) {
                return new Jikes();
            }
            if ( compilerType.equalsIgnoreCase(""classic"") ||
                    compilerType.equalsIgnoreCase(""javac1.1"") ||
                    compilerType.equalsIgnoreCase(""javac1.2"")) {
                return new Javac12();
            }
            if ( compilerType.equalsIgnoreCase(""modern"") ||
                    compilerType.equalsIgnoreCase(""javac1.3"")) {
                // does the modern compiler exist?
                try {
                    Class.forName(""com.sun.tools.javac.Main"");
                } catch (ClassNotFoundException cnfe) {
                    task.log(""Modern compiler is not available - using ""
                            + ""classic compiler"", Project.MSG_WARN);
                    return new Javac12();
                }
                return new Javac13();
            }
            if ( compilerType.equalsIgnoreCase(""jvc"") ||
                    compilerType.equalsIgnoreCase(""microsoft"")) {
                return new Jvc();
            }
            return resolveClassName( compilerType );
        }
    /**
     * Tries to resolve the given classname into a compiler adapter.
     * Throws a fit if it can't.
     *
     * @param className The fully qualified classname to be created.
     * @throws BuildException This is the fit that is thrown if className
     * isn't an instance of CompilerAdapter.
     */
    private static CompilerAdapter resolveClassName( String className )
        throws BuildException {
        try {
            Class c = Class.forName( className );
            Object o = c.newInstance();
            return (CompilerAdapter) o;
        } catch ( ClassNotFoundException cnfe ) {
            throw new BuildException( className + "" can\'t be found."", cnfe );
        } catch ( ClassCastException cce ) {
            throw new BuildException(className + "" isn\'t the classname of ""
                    + ""a compiler adapter."", cce);
        } catch ( Throwable t ) {
            // for all other possibilities
            throw new BuildException(className + "" caused an interesting ""
                    + ""exception."", t);
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.DefaultCompilerAdapter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.Random;
/**
 * This is the default implementation for the CompilerAdapter interface.
 * Currently, this is a cut-and-paste of the original javac task.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public abstract class DefaultCompilerAdapter implements CompilerAdapter {
    /* jdg - TODO - all these attributes are currently protected, but they
     * should probably be private in the near future.
     */
    protected Path src;
    protected File destDir;
    protected String encoding;
    protected boolean debug = false;
    protected boolean optimize = false;
    protected boolean deprecation = false;
    protected boolean depend = false;
    protected boolean verbose = false;
    protected String target;
    protected Path bootclasspath;
    protected Path extdirs;
    protected Path compileClasspath;
    protected Project project;
    protected Location location;
    protected boolean includeAntRuntime;
    protected boolean includeJavaRuntime;
    protected File[] compileList;
    protected static String lSep = System.getProperty(""line.separator"");
    protected Javac attributes;
    public void setJavac( Javac attributes ) {
        this.attributes = attributes;
        src = attributes.getSrcdir();
        destDir = attributes.getDestdir();
        encoding = attributes.getEncoding();
        debug = attributes.getDebug();
        optimize = attributes.getOptimize();
        deprecation = attributes.getDeprecation();
        depend = attributes.getDepend();
        verbose = attributes.getVerbose();
        target = attributes.getTarget();
        bootclasspath = attributes.getBootclasspath();
        extdirs = attributes.getExtdirs();
        compileList = attributes.getFileList();
        compileClasspath = attributes.getClasspath();
        project = attributes.getProject();
        location = attributes.getLocation();
        includeAntRuntime = attributes.getIncludeantruntime();
        includeJavaRuntime = attributes.getIncludejavaruntime();
    }
    public Javac getJavac() {
        return attributes;
    }
    /**
     * Builds the compilation classpath.
     *
     */
    protected Path getCompileClasspath() {
        Path classpath = new Path(project);
        // add dest dir to classpath so that previously compiled and
        // untouched classes are on classpath
        if (destDir != null) {
            classpath.setLocation(destDir);
        }
        // Combine the build classpath with the system classpath, in an 
        // order determined by the value of build.classpath
        if (compileClasspath == null) {
            if ( includeAntRuntime ) {
                classpath.addExisting(Path.systemClasspath);
            }
        } else {
            if ( includeAntRuntime ) {
                classpath.addExisting(compileClasspath.concatSystemClasspath(""last""));
            } else {
                classpath.addExisting(compileClasspath.concatSystemClasspath(""ignore""));
            }
        }
        if (includeJavaRuntime) {
            if (System.getProperty(""java.vendor"").toLowerCase().indexOf(""microsoft"") >= 0) {
                // Pull in *.zip from packages directory
                FileSet msZipFiles = new FileSet();
                msZipFiles.setDir(new File(System.getProperty(""java.home"") + File.separator + ""Packages""));
                msZipFiles.setIncludes(""*.ZIP"");
                classpath.addFileset(msZipFiles);
            }
            else if (Project.getJavaVersion() == Project.JAVA_1_1) {
                classpath.addExisting(new Path(null,
                                                System.getProperty(""java.home"")
                                                + File.separator + ""lib""
                                                + File.separator 
                                                + ""classes.zip""));
            } else {
                // JDK > 1.1 seems to set java.home to the JRE directory.
                classpath.addExisting(new Path(null,
                                                System.getProperty(""java.home"")
                                                + File.separator + ""lib""
                                                + File.separator + ""rt.jar""));
                // Just keep the old version as well and let addExistingToPath
                // sort it out.
                classpath.addExisting(new Path(null,
                                                System.getProperty(""java.home"")
                                                + File.separator +""jre""
                                                + File.separator + ""lib""
                                                + File.separator + ""rt.jar""));
            }
        }
        return classpath;
    }
    /**
     * Does the command line argument processing common to classic and
     * modern.  
     */
    protected Commandline setupJavacCommand() {
        Commandline cmd = new Commandline();
        Path classpath = getCompileClasspath();
        if (deprecation == true) {
            cmd.createArgument().setValue(""-deprecation"");
        }
        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }
        cmd.createArgument().setValue(""-classpath"");
        // Just add ""sourcepath"" to classpath ( for JDK1.1 )
        if (Project.getJavaVersion().startsWith(""1.1"")) {
            cmd.createArgument().setValue(classpath.toString() 
                                          + File.pathSeparator 
                                          + src.toString());
        } else {
            cmd.createArgument().setPath(classpath);
            cmd.createArgument().setValue(""-sourcepath"");
            cmd.createArgument().setPath(src);
            if (target != null) {
                cmd.createArgument().setValue(""-target"");
                cmd.createArgument().setValue(target);
            }
        }
        if (encoding != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }
        if (debug) {
            cmd.createArgument().setValue(""-g"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""-O"");
        }
        if (bootclasspath != null) {
            cmd.createArgument().setValue(""-bootclasspath"");
            cmd.createArgument().setPath(bootclasspath);
        }
        if (extdirs != null) {
            cmd.createArgument().setValue(""-extdirs"");
            cmd.createArgument().setPath(extdirs);
        }
        if (depend) {
            if (Project.getJavaVersion().startsWith(""1.1"")) {
                cmd.createArgument().setValue(""-depend"");
            } else if (Project.getJavaVersion().startsWith(""1.2"")) {
                cmd.createArgument().setValue(""-Xdepend"");
            } else {
                attributes.log(""depend attribute is not supported by the modern compiler"",
                    Project.MSG_WARN);
            }
        }
        if (verbose) {
            cmd.createArgument().setValue(""-verbose"");
        }
        logAndAddFilesToCompile(cmd);
        return cmd;
    }
    /**
     * Logs the compilation parameters, adds the files to compile and logs the 
     * &qout;niceSourceList&quot;
     */
    protected void logAndAddFilesToCompile(Commandline cmd) {
        attributes.log(""Compilation args: "" + cmd.toString(),
            Project.MSG_VERBOSE);
        StringBuffer niceSourceList = new StringBuffer(""File"");
        if (compileList.length != 1) {
            niceSourceList.append(""s"");
        }
        niceSourceList.append("" to be compiled:"");
        niceSourceList.append(lSep);
        for (int i=0; i < compileList.length; i++) {
            String arg = compileList[i].getAbsolutePath();
            cmd.createArgument().setValue(arg);
            niceSourceList.append(""    "" + arg + lSep);
        }
        attributes.log(niceSourceList.toString(), Project.MSG_VERBOSE);
    }
    /**
     * Do the compile with the specified arguments.
     * @param args - arguments to pass to process on command line
     * @param firstFileName - index of the first source file in args
     */
    protected int executeExternalCompile(String[] args, int firstFileName) {
        String[] commandArray = null;
        File tmpFile = null;
        try {
            /*
             * Many system have been reported to get into trouble with 
             * long command lines - no, not only Windows ;-).
             *
             * POSIX seems to define a lower limit of 4k, so use a temporary 
             * file if the total length of the command line exceeds this limit.
             */
            if (Commandline.toString(args).length() > 4096) {
                PrintWriter out = null;
                try {
                    tmpFile = new File(""jikes""+(new Random(System.currentTimeMillis())).nextLong());
                    out = new PrintWriter(new FileWriter(tmpFile));
                    for (int i = firstFileName; i < args.length; i++) {
                        out.println(args[i]);
                    }
                    out.flush();
                    commandArray = new String[firstFileName+1];
                    System.arraycopy(args, 0, commandArray, 0, firstFileName);
                    commandArray[firstFileName] = ""@"" + tmpFile.getAbsolutePath();
                } catch (IOException e) {
                    throw new BuildException(""Error creating temporary file"", e, location);
                } finally {
                    if (out != null) {
                        try {out.close();} catch (Throwable t) {}
                    }
                }
            } else {
                commandArray = args;
            }
            try {
                Execute exe = new Execute(new LogStreamHandler(attributes, 
                                                               Project.MSG_INFO,
                                                               Project.MSG_WARN));
                exe.setAntRun(project);
                exe.setWorkingDirectory(project.getBaseDir());
                exe.setCommandline(commandArray);
                exe.execute();
                return exe.getExitValue();
            } catch (IOException e) {
                throw new BuildException(""Error running "" + args[0] 
                        + "" compiler"", e, location);
            }
        } finally {
            if (tmpFile != null) {
                tmpFile.delete();
            }
        }
    }
    /**
     * Emulation of extdirs feature in java >= 1.2.
     * This method adds all files in the given
     * directories (but not in sub-directories!) to the classpath,
     * so that you don't have to specify them all one by one.
     * @param classpath - Path to append files to
     */
    protected void addExtdirsToClasspath(Path classpath) {
        if (extdirs == null) {
            String extProp = System.getProperty(""java.ext.dirs"");
            if (extProp != null) {
                extdirs = new Path(project, extProp);
            } else {
                return;
            }
        }
        String[] dirs = extdirs.list();
        for (int i=0; i<dirs.length; i++) {
            if (!dirs[i].endsWith(File.separator)) {
                dirs[i] += File.separator;
            }
            File dir = project.resolveFile(dirs[i]);
            FileSet fs = new FileSet();
            fs.setDir(dir);
            fs.setIncludes(""*"");
            classpath.addFileset(fs);
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Javac12,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.Commandline;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
/**
 * The implementation of the javac compiler for JDK 1.2
 * This is primarily a cut-and-paste from the original javac task before it
 * was refactored.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class Javac12 extends DefaultCompilerAdapter {
    public boolean execute() throws BuildException {
        attributes.log(""Using classic compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupJavacCommand();
        try {
            // Create an instance of the compiler, redirecting output to
            // the project log
            OutputStream logstr = new LogOutputStream(attributes, Project.MSG_WARN);
            Class c = Class.forName(""sun.tools.javac.Main"");
            Constructor cons = c.getConstructor(new Class[] { OutputStream.class, String.class });
            Object compiler = cons.newInstance(new Object[] { logstr, ""javac"" });
            // Call the compile() method
            Method compile = c.getMethod(""compile"", new Class [] { String[].class });
            Boolean ok = (Boolean)compile.invoke(compiler, new Object[] {cmd.getArguments()});
            return ok.booleanValue();
        }
        catch (ClassNotFoundException ex) {
            throw new BuildException(""Cannot use classic compiler, as it is not available""+
                                                         "" A common solution is to set the environment variable""+
                                     "" JAVA_HOME to your jdk directory."", location);
        }
        catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error starting classic compiler: "", ex, location);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Javac13,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.Commandline;
import java.lang.reflect.Method;
import java.io.*;
/**
 * The implementation of the javac compiler for JDK 1.3
 * This is primarily a cut-and-paste from the original javac task before it
 * was refactored.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class Javac13 extends DefaultCompilerAdapter {
    /**
     * Integer returned by the ""Modern"" jdk1.3 compiler to indicate success.
     */
    private static final int MODERN_COMPILER_SUCCESS = 0;
    public boolean execute() throws BuildException {
        attributes.log(""Using modern compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupJavacCommand();
        PrintStream err = System.err;
        PrintStream out = System.out;
        // Use reflection to be able to build on all JDKs >= 1.1:
        try {
            PrintStream logstr = 
                new PrintStream(new LogOutputStream(attributes, Project.MSG_WARN));
            System.setOut(logstr);
            System.setErr(logstr);
            Class c = Class.forName (""com.sun.tools.javac.Main"");
            Object compiler = c.newInstance ();
            Method compile = c.getMethod (""compile"",
                new Class [] {(new String [] {}).getClass ()});
            int result = ((Integer) compile.invoke
                          (compiler, new Object[] {cmd.getArguments()})) .intValue ();
            return (result == MODERN_COMPILER_SUCCESS);
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error starting modern compiler"", ex, location);
            }
        } finally {
            System.setErr(err);
            System.setOut(out);
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Jikes,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.*;
/**
 * The implementation of the jikes compiler.
 * This is primarily a cut-and-paste from the original javac task before it
 * was refactored.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class Jikes extends DefaultCompilerAdapter {
    /**
     * Performs a compile using the Jikes compiler from IBM..
     * Mostly of this code is identical to doClassicCompile()
     * However, it does not support all options like
     * bootclasspath, extdirs, deprecation and so on, because
     * there is no option in jikes and I don't understand
     * what they should do.
     *
     * It has been successfully tested with jikes >1.10
     *
     * @author skanthak@muehlheim.de
     */
    public boolean execute() throws BuildException {
        attributes.log(""Using jikes compiler"", Project.MSG_VERBOSE);
        Path classpath = new Path(project);
        // Jikes doesn't support bootclasspath dir (-bootclasspath)
        // so we'll emulate it for compatibility and convenience.
        if (bootclasspath != null) {
            classpath.append(bootclasspath);
        }
        // Jikes doesn't support an extension dir (-extdir)
        // so we'll emulate it for compatibility and convenience.
        addExtdirsToClasspath(classpath);
        if ( (bootclasspath == null) || (bootclasspath.size() == 0) ) {
            // no bootclasspath, therefore, get one from the java runtime
            includeJavaRuntime = true;
        } else {
            // there is a bootclasspath stated.  By default, the
            // includeJavaRuntime is false.  If the user has stated a
            // bootclasspath and said to include the java runtime, it's on
            // their head!
        }
        classpath.append(getCompileClasspath());
        // Jikes has no option for source-path so we
        // will add it to classpath.
        classpath.append(src);
        // if the user has set JIKESPATH we should add the contents as well
        String jikesPath = System.getProperty(""jikes.class.path"");
        if (jikesPath != null) {
            classpath.append(new Path(project, jikesPath));
        }
        Commandline cmd = new Commandline();
        cmd.setExecutable(""jikes"");
        if (deprecation == true)
            cmd.createArgument().setValue(""-deprecation"");
        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }
        cmd.createArgument().setValue(""-classpath"");
        cmd.createArgument().setPath(classpath);
        if (encoding != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }
        if (debug) {
            cmd.createArgument().setValue(""-g"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""-O"");
        }
        if (verbose) {
            cmd.createArgument().setValue(""-verbose"");
        }
        if (depend) {
            cmd.createArgument().setValue(""-depend"");
        } 
        /**
         * XXX
         * Perhaps we shouldn't use properties for these
         * three options (emacs mode, warnings and pedantic),
         * but include it in the javac directive?
         */
        /**
         * Jikes has the nice feature to print error
         * messages in a form readable by emacs, so
         * that emacs can directly set the cursor
         * to the place, where the error occured.
         */
        String emacsProperty = project.getProperty(""build.compiler.emacs"");
        if (emacsProperty != null && Project.toBoolean(emacsProperty)) {
            cmd.createArgument().setValue(""+E"");
        }
        /**
         * Jikes issues more warnings that javac, for
         * example, when you have files in your classpath
         * that don't exist. As this is often the case, these
         * warning can be pretty annoying.
         */
        String warningsProperty = project.getProperty(""build.compiler.warnings"");
        if (warningsProperty != null && !Project.toBoolean(warningsProperty)) {
            cmd.createArgument().setValue(""-nowarn"");
        }
        /**
         * Jikes can issue pedantic warnings. 
         */
        String pedanticProperty = project.getProperty(""build.compiler.pedantic"");
        if (pedanticProperty != null && Project.toBoolean(pedanticProperty)) {
            cmd.createArgument().setValue(""+P"");
        }
        /**
         * Jikes supports something it calls ""full dependency
         * checking"", see the jikes documentation for differences
         * between -depend and +F.
         */
        String fullDependProperty = project.getProperty(""build.compiler.fulldepend"");
        if (fullDependProperty != null && Project.toBoolean(fullDependProperty)) {
            cmd.createArgument().setValue(""+F"");
        }
        int firstFileName = cmd.size();
        logAndAddFilesToCompile(cmd);
        return executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Jvc,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.compilers;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.*;
/**
 * The implementation of the jvc compiler from microsoft.
 * This is primarily a cut-and-paste from the original javac task before it
 * was refactored.
 *
 * @author James Davidson <a href=""mailto:duncan@x180.com"">duncan@x180.com</a>
 * @author Robin Green <a href=""mailto:greenrd@hotmail.com"">greenrd@hotmail.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:jayglanville@home.com"">J D Glanville</a>
 */
public class Jvc extends DefaultCompilerAdapter {
    public boolean execute() throws BuildException {
        attributes.log(""Using jvc compiler"", Project.MSG_VERBOSE);
        Path classpath = new Path(project);
        // jvc doesn't support bootclasspath dir (-bootclasspath)
        // so we'll emulate it for compatibility and convenience.
        if (bootclasspath != null) {
            classpath.append(bootclasspath);
        }
        // jvc doesn't support an extension dir (-extdir)
        // so we'll emulate it for compatibility and convenience.
        addExtdirsToClasspath(classpath);
        if ( (bootclasspath == null) || (bootclasspath.size() == 0) ) {
            // no bootclasspath, therefore, get one from the java runtime
            includeJavaRuntime = true;
        } else {
            // there is a bootclasspath stated.  By default, the
            // includeJavaRuntime is false.  If the user has stated a
            // bootclasspath and said to include the java runtime, it's on
            // their head!
        }
        classpath.append(getCompileClasspath());
        // jvc has no option for source-path so we
        // will add it to classpath.
        classpath.append(src);
        Commandline cmd = new Commandline();
        cmd.setExecutable(""jvc"");
        if (destDir != null) {
            cmd.createArgument().setValue(""/d"");
            cmd.createArgument().setFile(destDir);
        }
        // Add the Classpath before the ""internal"" one.
        cmd.createArgument().setValue(""/cp:p"");
        cmd.createArgument().setPath(classpath);
        // Enable MS-Extensions and ...
        cmd.createArgument().setValue(""/x-"");
        // ... do not display a Message about this.
        cmd.createArgument().setValue(""/nomessage"");
        // Do not display Logo
        cmd.createArgument().setValue(""/nologo"");
        if (debug) {
            cmd.createArgument().setValue(""/g"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""/O"");
        }
        if (verbose) {
            cmd.createArgument().setValue(""/verbose"");
        }
        int firstFileName = cmd.size();
        logAndAddFilesToCompile(cmd);
        return executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ANTLR,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
/**
 * @author Erik Meade, emeade@geekfarm.org
 */
public class ANTLR extends Task {
    private CommandlineJava commandline = new CommandlineJava();
    private File target;
    private File outputDirectory;
    private boolean fork = false;
    private File dir;
    public ANTLR() {
        commandline.setVm(""java"");
        commandline.setClassname(""antlr.Tool"");
    }
    public void setTarget(File target) {
        log(""Setting target to: "" + target.toString(), Project.MSG_VERBOSE);
        this.target = target;
    }
    public void setOutputdirectory(File outputDirectory) {
        log(""Setting output directory to: "" + outputDirectory.toString(), Project.MSG_VERBOSE);
        this.outputDirectory = outputDirectory;
    }
    public void setFork(boolean s) {
        this.fork = s;
    }
    /**
     * The working directory of the process
     */
    public void setDir(File d) {
        this.dir = d;
    }
    public void execute() throws BuildException {
        validateAttributes();
        //TODO: use ANTLR to parse the grammer file to do this.
        if (target.lastModified() > getGeneratedFile().lastModified()) {
            commandline.createArgument().setValue(""-o"");
            commandline.createArgument().setValue(outputDirectory.toString());
            commandline.createArgument().setValue(target.toString());
            if (fork) {
                log(""Forking "" + commandline.toString(), Project.MSG_VERBOSE);
                int err = run(commandline.getCommandline());
                if (err == 1) {
                    throw new BuildException(""ANTLR returned: ""+err, location);
                }
            }
            else {
                Execute.runCommand(this, commandline.getCommandline());
            }
        }
    }
    private void validateAttributes() throws BuildException{
        if (target == null || !target.isFile()) {
            throw new BuildException(""Invalid target: "" + target);
        }
        // if no output directory is specified, used the target's directory
        if (outputDirectory == null) {
            String fileName = target.toString();
            setOutputdirectory(new File(target.getParent()));
        }
        if (!outputDirectory.isDirectory()) {
            throw new BuildException(""Invalid output directory: "" + outputDirectory);
        }
        if (fork && (dir == null || !dir.isDirectory())) {
            throw new BuildException(""Invalid working directory: "" + dir);
        }
    }
    private File getGeneratedFile() throws BuildException {
        String generatedFileName = null;
        try {
            BufferedReader in = new BufferedReader(new FileReader(target));
            String line;
            while ((line = in.readLine()) != null) {
                int extendsIndex = line.indexOf("" extends "");
                if (line.startsWith(""class "") &&  extendsIndex > -1) {
                    generatedFileName = line.substring(6, extendsIndex).trim();
                    break;
                }
            }
            in.close();
        } catch (Exception e) {
            throw new BuildException(""Unable to determine generated class"");
        }
        if (generatedFileName == null) {
            throw new BuildException(""Unable to determine generated class"");
        }
        return new File(outputDirectory, generatedFileName + "".java"");
    }
    private int run(String[] command) throws BuildException {
        Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO,
                                                       Project.MSG_WARN), null);
        exe.setAntRun(project);
        exe.setWorkingDirectory(dir);
        exe.setCommandline(command);
        try {
            return exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, location);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.Cab,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Random;
import java.text.DecimalFormat;
/**
 * Create a CAB archive.
 *
 * @author Roger Vaughn <a href=""mailto:rvaughn@seaconinc.com"">rvaughn@seaconinc.com</a>
 */
public class Cab extends MatchingTask {
    private File cabFile;
    private File baseDir;
    private Vector filesets = new Vector();
    private boolean doCompress = true;
    private boolean doVerbose = false;
    private String cmdOptions;
    protected String archiveType = ""cab"";
    private static String myos;
    private static boolean isWindows;
    static {
        myos = System.getProperty(""os.name"");
        isWindows = myos.toLowerCase().indexOf(""windows"") >= 0;
    }
    /**
     * This is the name/location of where to 
     * create the .cab file.
     */
    public void setCabfile(File cabFile) {
        this.cabFile = cabFile;
    }
    /**
     * This is the base directory to look in for 
     * things to cab.
     */
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }
    /**
     * Sets whether we want to compress the files or only store them.
     */
    public void setCompress(boolean compress) {
        doCompress = compress;
    }
    /**
     * Sets whether we want to see or suppress cabarc output.
     */
    public void setVerbose(boolean verbose) {
        doVerbose = verbose;
    }
    /**
     * Sets additional cabarc options that aren't supported directly.
     */
    public void setOptions(String options) {
        cmdOptions = options;
    }
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /*
     * I'm not fond of this pattern: ""sub-method expected to throw
     * task-cancelling exceptions"".  It feels too much like programming
     * for side-effects to me...
     */
    protected void checkConfiguration() throws BuildException {
        if (baseDir == null) {
            throw new BuildException(""basedir attribute must be set!"");
        }
        if (!baseDir.exists()) {
            throw new BuildException(""basedir does not exist!"");
        }
        if (cabFile == null) {
            throw new BuildException(""cabfile attribute must be set!"");
        }
    }
    /**
     * Create a new exec delegate.  The delegate task is populated so that
     * it appears in the logs to be the same task as this one.
     */
    protected ExecTask createExec() throws BuildException
    {
        ExecTask exec = (ExecTask)project.createTask(""exec"");
        exec.setOwningTarget(this.getOwningTarget());
        exec.setTaskName(this.getTaskName());
        exec.setDescription(this.getDescription());
        return exec;
    }
    /**
     * Check to see if the target is up to date with respect to input files.
     * @return true if the cab file is newer than its dependents.
     */
    protected boolean isUpToDate(Vector files)
    {
        boolean upToDate = true;
        for (int i=0; i<files.size() && upToDate; i++)
        {
            String file = files.elementAt(i).toString();
            if (new File(baseDir,file).lastModified() > 
                cabFile.lastModified())
                upToDate = false;
        }
        return upToDate;
    }
    /**
     * Create the cabarc command line to use.
     */
    protected Commandline createCommand(File listFile)
    {
        Commandline command = new Commandline();
        command.setExecutable(""cabarc"");
        command.createArgument().setValue(""-r"");
        command.createArgument().setValue(""-p"");
        if (!doCompress)
        {
            command.createArgument().setValue(""-m"");
            command.createArgument().setValue(""none"");
        }
        if (cmdOptions != null)
        {
            command.createArgument().setValue(cmdOptions);
        }
        command.createArgument().setValue(""n"");
        command.createArgument().setFile(cabFile);
        command.createArgument().setValue(""@"" + listFile.getAbsolutePath());
        return command;
    }
    private static int counter = new Random().nextInt() % 100000;
    protected File createTempFile(String prefix, String suffix)
    {
        if (suffix == null)
        {
            suffix = "".tmp"";
        }
        String name = prefix +
            new DecimalFormat(""#####"").format(new Integer(counter++)) +
            suffix;
        String tmpdir = System.getProperty(""java.io.tmpdir"");
        // java.io.tmpdir is not present in 1.1
        if (tmpdir == null)
            return new File(name);
        else
            return new File(tmpdir, name);
    }
    /**
     * Creates a list file.  This temporary file contains a list of all files
     * to be included in the cab, one file per line.
     */
    protected File createListFile(Vector files)
        throws IOException
    {
        File listFile = createTempFile(""ant"", null);
        PrintWriter writer = new PrintWriter(new FileOutputStream(listFile));
        for (int i = 0; i < files.size(); i++)
        {
            writer.println(files.elementAt(i).toString());
        }
        writer.close();
        return listFile;
    }
    /**
     * Append all files found by a directory scanner to a vector.
     */
    protected void appendFiles(Vector files, DirectoryScanner ds)
    {
        String[] dsfiles = ds.getIncludedFiles();
        for (int i = 0; i < dsfiles.length; i++)
        {
            files.addElement(dsfiles[i]);
        }
    }
    /**
     * Get the complete list of files to be included in the cab.  Filenames
     * are gathered from filesets if any have been added, otherwise from the
     * traditional include parameters.
     */
    protected Vector getFileList() throws BuildException
    {
        Vector files = new Vector();
        if (filesets.size() == 0)
        {
            // get files from old methods - includes and nested include
            appendFiles(files, super.getDirectoryScanner(baseDir));
        }
        else
        {
            // get files from filesets
            for (int i = 0; i < filesets.size(); i++)
            {
                FileSet fs = (FileSet) filesets.elementAt(i);
                if (fs != null)
                {
                    appendFiles(files, fs.getDirectoryScanner(project));
                }
            }
        }
        return files;
    }
    public void execute() throws BuildException {
        checkConfiguration();
        Vector files = getFileList();
        // quick exit if the target is up to date
        if (isUpToDate(files)) return;
        log(""Building ""+ archiveType +"": ""+ cabFile.getAbsolutePath());
        // we must be on Windows to continue
        if (!isWindows) {
            log(""Using listcab/libcabinet"", Project.MSG_VERBOSE);
            StringBuffer sb = new StringBuffer();
            Enumeration fileEnum = files.elements();
            while (fileEnum.hasMoreElements()) {
                sb.append(fileEnum.nextElement()).append(""\n"");
            }
            sb.append(""\n"").append(cabFile.getAbsolutePath()).append(""\n"");
            try {
                Process p = Runtime.getRuntime().exec(""listcab"");
                OutputStream out = p.getOutputStream();
                out.write(sb.toString().getBytes());
                out.flush();
                out.close();
            } catch (IOException ex) {
                String msg = ""Problem creating "" + cabFile + "" "" + ex.getMessage();
                throw new BuildException(msg);
            }
        } else {
            try {
                File listFile = createListFile(files);
                ExecTask exec = createExec();
                File outFile = null;
                // die if cabarc fails
                exec.setFailonerror(true);
                exec.setDir(baseDir);
                if (!doVerbose) {
                    outFile = createTempFile(""ant"", null);
                    exec.setOutput(outFile);
                }
                exec.setCommand(createCommand(listFile));
                exec.execute();
                if (outFile != null) {
                    outFile.delete();
                }
                listFile.delete();
            } catch (IOException ioe) {
                String msg = ""Problem creating "" + cabFile + "" "" + ioe.getMessage();
                throw new BuildException(msg);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.Javah,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.*;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.io.*;
import java.util.*;
/**
 * Task to generate JNI header files using javah. This task can take the following
 * arguments:
 * <ul>
 * <li>classname - the fully-qualified name of a class</li>
 * <li>outputFile - Concatenates the resulting header or source files for all
 *     the classes listed into this file</li>
 * <li>destdir - Sets the directory where javah saves the header files or the
 *     stub files</li>
 * <li>classpath</li>
 * <li>bootclasspath</li>
 * <li>force - Specifies that output files should always be written
       (JDK1.2 only)</li>
 * <li>old - Specifies that old JDK1.0-style header files should be generated
 *     (otherwise output file contain JNI-style native method
 *      function prototypes) (JDK1.2 only)</li>
 * <li>stubs - generate C declarations from the Java object file (used with old)</li>
 * <li>verbose - causes javah to print a message to stdout concerning the status
 *     of the generated files</li>
 * <li>extdirs - Override location of installed extensions</li>
 * </ul>
 * Of these arguments, either <b>outputFile</b> or <b>destdir</b> is required,
 * but not both. More than one classname may be specified, using a comma-separated
 * list or by using <code>&lt;class name=""xxx""&gt;</code> elements within the task.
 * <p>
 * When this task executes, it will generate C header and source files that
 * are needed to implement native methods.
 *
 * @author Rick Beton <a href=""mailto:richard.beton@physics.org"">richard.beton@physics.org</a>
 */
public class Javah extends Task {
    private static final String FAIL_MSG = ""Compile failed, messages should have been provided."";
    private Vector classes = new Vector(2);
    private String cls;
    private File destDir;
    private Path classpath = null;
    private String outputFile = null;
    private boolean verbose = false;
    private boolean force   = false;
    private boolean old     = false;
    private boolean stubs   = false;
    private Path bootclasspath;
    //private Path extdirs;
    private static String lSep = System.getProperty(""line.separator"");
    public void setClass(String cls) {
        this.cls = cls;
    }
    public ClassArgument createClass() {
        ClassArgument ga = new ClassArgument();
        classes.addElement(ga);
        return ga;
    }
    public class ClassArgument {
        private String name;
        public ClassArgument() {
        }
        public void setName(String name) {
            this.name = name;
            log(""ClassArgument.name=""+name);
        }
        public String getName() {
            return name;
        }
    }
    /**
     * Set the destination directory into which the Java source
     * files should be compiled.
     */
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }
    public void setClasspath(Path src) {
        if (classpath == null) {
            classpath = src;
        } else {
            classpath.append(src);
        }
    }
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }
        return classpath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }
    public void setBootclasspath(Path src) {
        if (bootclasspath == null) {
            bootclasspath = src;
        } else {
            bootclasspath.append(src);
        }
    }
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(project);
        }
        return bootclasspath.createPath();
    }
    /**
     * Adds a reference to a CLASSPATH defined elsewhere.
     */
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }
    ///**
    // * Sets the extension directories that will be used during the
    // * compilation.
    // */
    //public void setExtdirs(Path extdirs) {
    //    if (this.extdirs == null) {
    //        this.extdirs = extdirs;
    //    } else {
    //        this.extdirs.append(extdirs);
    //    }
    //}
    ///**
    // * Maybe creates a nested classpath element.
    // */
    //public Path createExtdirs() {
    //    if (extdirs == null) {
    //        extdirs = new Path(project);
    //    }
    //    return extdirs.createPath();
    //}
    /**
     * Set the output file name.
     */
    public void setOutputFile(String outputFile) {
        this.outputFile = outputFile;
    }
    /**
     * Set the force-write flag.
     */
    public void setForce(boolean force) {
        this.force = force;
    }
    /**
     * Set the old flag.
     */
    public void setOld(boolean old) {
        this.old = old;
    }
    /**
     * Set the stubs flag.
     */
    public void setStubs(boolean stubs) {
        this.stubs = stubs;
    }
    /**
     * Set the verbose flag.
     */
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }
    /**
     * Executes the task.
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a srcdir
        if ((cls == null) && (classes.size() == 0)) {
            throw new BuildException(""class attribute must be set!"", location);
        }
        if ((cls != null) && (classes.size() > 0)) {
            throw new BuildException(""set class attribute or class element, not both."", location);
        }
        if (destDir != null) {
            if (!destDir.isDirectory()) {
                throw new BuildException(""destination directory \"""" + destDir + ""\"" does not exist or is not a directory"", location);
            }
            if (outputFile != null) {
                throw new BuildException(""destdir and outputFile are mutually exclusive"", location);
            }
        }
        if (classpath == null) {
            classpath = Path.systemClasspath;
        }
        String compiler = project.getProperty(""build.compiler"");
        if (compiler == null) {
            if (Project.getJavaVersion().startsWith(""1.3"")) {
                compiler = ""modern"";
            } else {
                compiler = ""classic"";
            }
        }
        doClassicCompile();
    }
    // XXX
    // we need a way to not use the current classpath.
    /**
     * Peforms a compile using the classic compiler that shipped with
     * JDK 1.1 and 1.2.
     */
    private void doClassicCompile() throws BuildException {
        Commandline cmd = setupJavahCommand();
        // Use reflection to be able to build on all JDKs
        /*
        // provide the compiler a different message sink - namely our own
        sun.tools.javac.Main compiler =
                new sun.tools.javac.Main(new LogOutputStream(this, Project.MSG_WARN), ""javac"");
        if (!compiler.compile(cmd.getArguments())) {
            throw new BuildException(""Compile failed"");
        }
        */
        PrintStream err = System.err;
        PrintStream out = System.out;
        try {
            // Javac uses logstr to change the output stream and calls
            // the constructor's invoke method to create a compiler instance
            // dynamically. However, javah has a different interface and this
            // makes it harder, so here's a simple alternative.
            //------------------------------------------------------------------
            PrintStream logstr = 
                new PrintStream(new LogOutputStream(this, Project.MSG_WARN));
            System.setOut(logstr);
            System.setErr(logstr);
            com.sun.tools.javah.Main main = new com.sun.tools.javah.Main( cmd.getArguments() );
            main.run();
        }
        //catch (ClassNotFoundException ex) {
        //    throw new BuildException(""Cannot use javah because it is not available""+
        //                             "" A common solution is to set the environment variable""+
        //                             "" JAVA_HOME to your jdk directory."", location);
        //}
        catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error starting javah: "", ex, location);
            }
        } finally {
            System.setErr(err);
            System.setOut(out);
        }
    }
    /**
     * Does the command line argument processing common to classic and
     * modern.
     */
    private Commandline setupJavahCommand() {
        Commandline cmd = new Commandline();
        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }
        if (outputFile != null) {
            cmd.createArgument().setValue(""-o"");
            cmd.createArgument().setValue(outputFile);
        }
        if (classpath != null) {
            cmd.createArgument().setValue(""-classpath"");
            cmd.createArgument().setPath(classpath);
        }
        // JDK1.1 is rather simpler than JDK1.2
        if (Project.getJavaVersion().startsWith(""1.1"")) {
            if (verbose) {
                cmd.createArgument().setValue(""-v"");
            }
        } else {
            if (verbose) {
                cmd.createArgument().setValue(""-verbose"");
            }
            if (old) {
                cmd.createArgument().setValue(""-old"");
            }
            if (force) {
                cmd.createArgument().setValue(""-force"");
            }
        }
        if (stubs) {
            if (!old) {
                throw new BuildException(""stubs only available in old mode."", location);
            }
            cmd.createArgument().setValue(""-stubs"");
        }
        if (bootclasspath != null) {
            cmd.createArgument().setValue(""-bootclasspath"");
            cmd.createArgument().setPath(bootclasspath);
        }
        logAndAddFilesToCompile(cmd);
        return cmd;
    }
    /**
     * Logs the compilation parameters, adds the files to compile and logs the
     * &qout;niceSourceList&quot;
     */
    protected void logAndAddFilesToCompile(Commandline cmd) {
        int n = 0;
        log(""Compilation args: "" + cmd.toString(),
            Project.MSG_VERBOSE);
        StringBuffer niceClassList = new StringBuffer();
        if (cls != null) {
            StringTokenizer tok = new StringTokenizer(cls, "","", false);
            while (tok.hasMoreTokens()) {
                String aClass = tok.nextToken().trim();
                cmd.createArgument().setValue(aClass);
                niceClassList.append(""    "" + aClass + lSep);
                n++;
            }
        }
        Enumeration enum = classes.elements();
        while (enum.hasMoreElements()) {
            ClassArgument arg = (ClassArgument)enum.nextElement();
            String aClass = arg.getName();
            cmd.createArgument().setValue(aClass);
            niceClassList.append(""    "" + aClass + lSep);
            n++;
        }
        StringBuffer prefix = new StringBuffer(""Class"");
        if (n > 1) {
            prefix.append(""es"");
        }
        prefix.append("" to be compiled:"");
        prefix.append(lSep);
        log(prefix.toString() + niceClassList.toString(), Project.MSG_VERBOSE);
    }
    ///**
    // * Emulation of extdirs feature in java >= 1.2.
    // * This method adds all files in the given
    // * directories (but not in sub-directories!) to the classpath,
    // * so that you don't have to specify them all one by one.
    // * @param classpath - Path to append files to
    // */
    //protected void addExtdirsToClasspath(Path classpath) {
    //    if (extdirs == null) {
    //        String extProp = System.getProperty(""java.ext.dirs"");
    //        if (extProp != null) {
    //            extdirs = new Path(project, extProp);
    //        } else {
    //            return;
    //        }
    //    }
    //
    //    String[] dirs = extdirs.list();
    //    for (int i=0; i<dirs.length; i++) {
    //        if (!dirs[i].endsWith(File.separator)) {
    //            dirs[i] += File.separator;
    //        }
    //        File dir = project.resolveFile(dirs[i]);
    //        FileSet fs = new FileSet();
    //        fs.setDir(dir);
    //        fs.setIncludes(""*"");
    //        classpath.addFileset(fs);
    //    }
    //}
}
"
org.apache.tools.ant.taskdefs.optional.Native2Ascii,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.util.*;
import java.io.File;
/**
 * Convert files from native encodings to ascii.
 *
 * @author Drew Sudell <asudell@acm.org>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class Native2Ascii extends MatchingTask {
    private boolean reverse = false;  // convert from ascii back to native
    private String encoding = null;   // encoding to convert to/from
    private File srcDir = null;       // Where to find input files
    private File destDir = null;      // Where to put output files
    private String extension = null;  // Extension of output files if different
    private Mapper mapper;
    /**
     * Flag the conversion to run in the reverse sense,
     * that is Ascii to Native encoding.
     * 
     * @param reverse True if the conversion is to be reversed,
     *                otherwise false;
     */
    public void setReverse(boolean reverse){
        this.reverse = reverse;
    }
    /**
     * Set the encoding to translate to/from.
     * If unset, the default encoding for the JVM is used.
     *
     * @param encoding String containing the name of the Native 
     *                 encoding to convert from or to.
     */
    public void setEncoding(String encoding){
        this.encoding = encoding;
    }
    /**
     * Set the source directory in which to find files to convert.
     *
     * @param srcDir Direcrory to find input file in.
     */
    public void setSrc(File srcDir){
        this.srcDir = srcDir;
    }
    /**
     * Set the destination dirctory to place converted files into.
     *
     * @param destDir directory to place output file into.
     */
    public void setDest(File destDir){
        this.destDir = destDir;
    }
    /**
     * Set the extension which converted files should have.
     * If unset, files will not be renamed.
     *
     * @param ext File extension to use for converted files.
     */
    public void setExt(String ext){
        this.extension = ext;
    }
    /**
     * Defines the FileNameMapper to use (nested mapper element).
     */
    public Mapper createMapper() throws BuildException {
        if (mapper != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     location);
        }
        mapper = new Mapper(project);
        return mapper;
    }
    public void execute() throws BuildException {
        Commandline baseCmd = null;      // the common portion of our cmd line
        DirectoryScanner scanner = null; // Scanner to find our inputs
        String[] files;                  // list of files to process
        // default srcDir to basedir
        if (srcDir == null){
            srcDir = project.resolveFile(""."");
        }
        // Require destDir
        if (destDir == null){
            throw new BuildException(""The dest attribute must be set."");
        }
        // if src and dest dirs are the same, require the extension
        // to be set, so we don't stomp every file.  One could still
        // include a file with the same extension, but ....
        if (srcDir.equals(destDir) && extension == null && mapper == null){
            throw new BuildException(""The ext attribute or a mapper must be set if""
                                     + "" src and dest dirs are the same."");
        }
        FileNameMapper m = null;
        if (mapper == null) {
            if (extension == null) {
                m = new IdentityMapper();
            } else {
                m = new ExtMapper();
            }
        } else {
            m = mapper.getImplementation();
        }
        scanner = getDirectoryScanner(srcDir);
        files = scanner.getIncludedFiles();
        SourceFileScanner sfs = new SourceFileScanner(this);
        files = sfs.restrict(files, srcDir, destDir, m);
        int count = files.length;
        if (count == 0) {
            return;
        }
        String message = ""Converting ""+ count + "" file""
            + (count != 1 ? ""s"" : """") + "" from "";
        log(message + srcDir + "" to "" + destDir);
        for (int i = 0; i < files.length; i++){
            convert(files[i], m.mapFileName(files[i])[0]);
        }
    }
    /**
     * Convert a single file.
     *
     * @param fileName Name of the file to convert (relative to srcDir).
     */
    private void convert(String srcName, String destName) throws BuildException {
        Commandline cmd = new Commandline();  // Command line to run
        File srcFile;                         // File to convert
        File destFile;                        // where to put the results
        // Set up the basic args (this could be done once, but
        // it's cleaner here)
        if (reverse){
            cmd.createArgument().setValue(""-reverse"");
        }
        if (encoding != null){
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }
        // Build the full file names
        srcFile = new File(srcDir, srcName);
        destFile = new File(destDir, destName);
        cmd.createArgument().setFile(srcFile);
        cmd.createArgument().setFile(destFile);
        // Make sure we're not about to clobber something
        if (srcFile.equals(destFile)){
            throw new BuildException(""file "" + srcFile 
                                     + "" would overwrite its self"");
        }
        // Make intermediate directories if needed
        // XXX JDK 1.1 dosen't have File.getParentFile,
        String parentName = destFile.getParent();
        if (parentName != null){
            File parentFile = new File(parentName);
            if ((! parentFile.exists()) && ( ! parentFile.mkdirs())){
                throw new BuildException(""cannot create parent directory ""
                                         + parentName);
            }
        }
        log(""converting "" + srcName, Project.MSG_VERBOSE);
        sun.tools.native2ascii.Main n2a
            = new sun.tools.native2ascii.Main();
        if(! n2a.convert(cmd.getArguments())){
            throw new BuildException(""conversion failed"");
        }
    }
    private class ExtMapper implements FileNameMapper {
        public void setFrom(String s) {}
        public void setTo(String s) {}
        public String[] mapFileName(String fileName) {
            int lastDot = fileName.lastIndexOf('.');
            if (lastDot >= 0) {
                return new String[] {fileName.substring(0, lastDot) + extension};
            } else {
                return new String[] {fileName + extension};
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.NetRexxC,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import netrexx.lang.Rexx;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
/**
 * Task to compile NetRexx source files. This task can take the following
 * arguments:
 * <ul>
 * <li>binary</li>
 * <li>classpath</li>
 * <li>comments</li>
 * <li>compile</li>
 * <li>console</li>
 * <li>crossref</li>
 * <li>decimal</li>
 * <li>destdir</li>
 * <li>diag</li>
 * <li>explicit</li>
 * <li>format</li>
 * <li>keep</li>
 * <li>logo</li>
 * <li>replace</li>
 * <li>savelog</li>
 * <li>srcdir</li>
 * <li>sourcedir</li>
 * <li>strictargs</li>
 * <li>strictassign</li>
 * <li>strictcase</li>
 * <li>strictimport</li>
 * <li>symbols</li>
 * <li>time</li>
 * <li>trace</li>
 * <li>utf8</li>
 * <li>verbose</li>
 * </ul>
 * Of these arguments, the <b>srcdir</b> argument is required.
 *
 * <p>When this task executes, it will recursively scan the srcdir
 * looking for NetRexx source files to compile. This task makes its
 * compile decision based on timestamp.
 * <p>Before files are compiled they and any other file in the
 * srcdir will be copied to the destdir allowing support files to be
 * located properly in the classpath. The reason for copying the source files
 * before the compile is that NetRexxC has only two destinations for classfiles:
 * <ol>
 * <li>The current directory, and,</li>
 * <li>The directory the source is in (see sourcedir option)
 * </ol>
 *
 * @author dIon Gillard <a href=""mailto:dion@multitask.com.au"">dion@multitask.com.au</a>
 */
public class NetRexxC extends MatchingTask {
    // variables to hold arguments
    private boolean binary;
    private String classpath;
    private boolean comments;
    private boolean compact;
    private boolean compile = true;
    private boolean console;
    private boolean crossref;
    private boolean decimal = true;
    private File destDir;
    private boolean diag;
    private boolean explicit;
    private boolean format;
    private boolean java;
    private boolean keep;
    private boolean logo = true;
    private boolean replace;
    private boolean savelog;
    private File srcDir;
    private boolean sourcedir = true; // ?? Should this be the default for ant?
    private boolean strictargs;
    private boolean strictassign;
    private boolean strictcase;
    private boolean strictimport;
    private boolean strictprops;
    private boolean strictsignal;
    private boolean symbols;
    private boolean time;
    private String trace = ""trace2"";
    private boolean utf8;
    private String verbose = ""verbose3"";
    // other implementation variables
    private Vector compileList = new Vector();
    private Hashtable filecopyList = new Hashtable();
    private String oldClasspath = System.getProperty(""java.class.path"");
    /**
     * Set whether literals are treated as binary, rather than NetRexx types
     */
    public void setBinary(boolean binary) {
        this.binary = binary;
    }
    /**
     * Set the classpath used for NetRexx compilation
     */
    public void setClasspath(String classpath) {
        this.classpath = classpath;
    }
    /**
     * Set whether comments are passed through to the generated java source.
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false
     */
    public void setComments(boolean comments) {
        this.comments = comments;
    }
    /**
     * Set whether error messages come out in compact or verbose format.
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false
     */
    public void setCompact(boolean compact) {
        this.compact = compact;
    }
    /**
     * Set whether the NetRexx compiler should compile the generated java code
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is true.
     * Setting this flag to false, will automatically set the keep flag to true.
     */
    public void setCompile(boolean compile) {
        this.compile = compile;
        if (!this.compile && !this.keep) this.keep = true;
    }
    /**
     * Set whether or not messages should be displayed on the 'console'
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is true.
     */
    public void setConsole(boolean console) {
        this.console = console;
    }
    /**
     * Whether variable cross references are generated
     */
    public void setCrossref(boolean crossref) {
        this.crossref = crossref;
    }
    /**
     * Set whether decimal arithmetic should be used for the netrexx code.
     * Binary arithmetic is used when this flag is turned off.
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is true.
     */
    public void setDecimal(boolean decimal) {
        this.decimal = decimal;
    }
    /**
     * Set the destination directory into which the NetRexx source
     * files should be copied and then compiled.
     */
    public void setDestDir(String destDirName) {
        destDir = project.resolveFile(destDirName);
    }
    /**
     * Whether diagnostic information about the compile is generated
     */
    public void setDiag(boolean diag) {
        this.diag = diag;
    }
    /**
     * Sets whether variables must be declared explicitly before use.
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setExplicit(boolean explicit) {
        this.explicit = explicit;
    }
    /**
     * Whether the generated java code is formatted nicely or left to match NetRexx
     * line numbers for call stack debugging
     */
    public void setFormat(boolean format) {
        this.format = format;
    }
    /**
     * Whether the generated java code is produced
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setJava(boolean java) {
        this.java = java;
    }
    /**
     * Sets whether the generated java source file should be kept after compilation.
     * The generated files will have an extension of .java.keep, <b>not</b> .java
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setKeep(boolean keep) {
        this.keep = keep;
    }
    /**
     * Whether the compiler text logo is displayed when compiling
     */
    public void setLogo(boolean logo) {
        this.logo = logo;
    }
    /**
     * Whether the generated .java file should be replaced when compiling
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setReplace(boolean replace) {
        this.replace = replace;
    }
    /**
     * Sets whether the compiler messages will be written to NetRexxC.log as
     * well as to the console
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setSavelog(boolean savelog) {
        this.savelog = savelog;
    }
    /**
     * Tells the NetRexx compiler to store the class files in the same directory
     * as the source files. The alternative is the working directory
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is true.
     */
    public void setSourcedir(boolean sourcedir) {
        this.sourcedir = sourcedir;
    }
    /**
     * Set the source dir to find the source Java files.
     */
    public void setSrcDir(String srcDirName) {
        srcDir = project.resolveFile(srcDirName);
    }
    /**
     * Tells the NetRexx compiler that method calls always need parentheses,
     * even if no arguments are needed, e.g. <code>aStringVar.getBytes</code>
     * vs. <code>aStringVar.getBytes()</code>
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setStrictargs(boolean strictargs) {
        this.strictargs = strictargs;
    }
    /**
     * Tells the NetRexx compile that assignments must match exactly on type
     */
    public void setStrictassign(boolean strictassign) {
        this.strictassign = strictassign;
    }
    /**
     * Specifies whether the NetRexx compiler should be case sensitive or not
     */
    public void setStrictcase(boolean strictcase) {
        this.strictcase = strictcase;
    }
    /**
     * Sets whether classes need to be imported explicitly using an
     * <code>import</code> statement. By default the NetRexx compiler will import
     * certain packages automatically
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setStrictimport(boolean strictimport) {
        this.strictimport = strictimport;
    }
    /**
     * Sets whether local properties need to be qualified explicitly using <code>this</code>
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setStrictprops(boolean strictprops) {
        this.strictprops = strictprops;
    }
    /**
     * Whether the compiler should force catching of exceptions by explicitly named types
     */
    public void setStrictsignal(boolean strictsignal) {
        this.strictsignal = strictsignal;
    }
    /**
     * Sets whether debug symbols should be generated into the class file
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setSymbols(boolean symbols) {
        this.symbols = symbols;
    }
    /**
     * Asks the NetRexx compiler to print compilation times to the console
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setTime(boolean time) {
        this.time = time;
    }
    /**
     * Turns on or off tracing and directs the resultant trace output
     * Valid values are: ""trace"", ""trace1"", ""trace2"" and ""notrace"".
     * ""trace"" and ""trace2""
     */
    public void setTrace(String trace) {
        if (trace.equalsIgnoreCase(""trace"")
            || trace.equalsIgnoreCase(""trace1"")
            || trace.equalsIgnoreCase(""trace2"")
            || trace.equalsIgnoreCase(""notrace"")) {
            this.trace = trace;
        } else {
            throw new BuildException(""Unknown trace value specified: '"" + trace + ""'"");
        }
    }
    /**
     * Tells the NetRexx compiler that the source is in UTF8
     * Valid true values are ""on"" or ""true"". Anything else sets the flag to false.
     * The default value is false.
     */
    public void setUtf8(boolean utf8) {
        this.utf8 = utf8;
    }
    /**
     * Whether lots of warnings and error messages should be generated
     */
    public void setVerbose(String verbose) {
        this.verbose = verbose;
    }
    /**
     * Executes the task, i.e. does the actual compiler call
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a srcdir and destdir
        if (srcDir == null || destDir == null ) {
            throw new BuildException(""srcDir and destDir attributes must be set!"");
        }
        // scan source and dest dirs to build up both copy lists and
        // compile lists
        //        scanDir(srcDir, destDir);
        DirectoryScanner ds = getDirectoryScanner(srcDir);
        String[] files = ds.getIncludedFiles();
        scanDir(srcDir, destDir, files);
        // copy the source and support files
        copyFilesToDestination();
        // compile the source files
        if (compileList.size() > 0) {
            log(""Compiling "" + compileList.size() + "" source file""
                + (compileList.size() == 1 ? """" : ""s"")
                + "" to "" + destDir);
            doNetRexxCompile();
        }
    }
    /**
     * Scans the directory looking for source files to be compiled and
     * support files to be copied.
     */
    private void scanDir(File srcDir, File destDir, String[] files) {
        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(srcDir, files[i]);
            File destFile = new File(destDir, files[i]);
            String filename = files[i];
            // if it's a non source file, copy it if a later date than the
            // dest
            // if it's a source file, see if the destination class file
            // needs to be recreated via compilation
            if (filename.toLowerCase().endsWith("".nrx"")) {
                File classFile = 
                    new File(destDir, 
                             filename.substring(0, filename.lastIndexOf('.')) + "".class"");
                if (!compile || srcFile.lastModified() > classFile.lastModified()) {
                    filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                    compileList.addElement(destFile.getAbsolutePath());
                }
            } else {
                if (srcFile.lastModified() > destFile.lastModified()) {
                    filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                }
            }
        }
    }
    /**
     * Copy eligible files from the srcDir to destDir
     */
    private void copyFilesToDestination() {
        if (filecopyList.size() > 0) {
            log(""Copying "" + filecopyList.size() + "" file""
                + (filecopyList.size() == 1 ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());
            Enumeration enum = filecopyList.keys();
            while (enum.hasMoreElements()) {
                String fromFile = (String)enum.nextElement();
                String toFile = (String)filecopyList.get(fromFile);
                try {
                    project.copyFile(fromFile, toFile);
                } catch (IOException ioe) {
                    String msg = ""Failed to copy "" + fromFile + "" to "" + toFile
                        + "" due to "" + ioe.getMessage();
                    throw new BuildException(msg, ioe);
                }
            }
        }
    }
    /**
     * Peforms a copmile using the NetRexx 1.1.x compiler
     */
    private void doNetRexxCompile() throws BuildException {
        log(""Using NetRexx compiler"", Project.MSG_VERBOSE);
        String classpath = getCompileClasspath();
        StringBuffer compileOptions = new StringBuffer();
        StringBuffer fileList = new StringBuffer();
        // create an array of strings for input to the compiler: one array
        // comes from the compile options, the other from the compileList
        String[] compileOptionsArray = getCompileOptionsAsArray();
        String[] fileListArray = new String[compileList.size()];
        Enumeration e = compileList.elements();
        int j = 0;
        while (e.hasMoreElements()) {
            fileListArray[j] = (String)e.nextElement();
            j++;
        }
        // create a single array of arguments for the compiler
        String compileArgs[] = new String[compileOptionsArray.length + fileListArray.length];
        for (int i = 0; i < compileOptionsArray.length; i++) {
            compileArgs[i] = compileOptionsArray[i];
        }
        for (int i = 0; i < fileListArray.length; i++) {
            compileArgs[i+compileOptionsArray.length] = fileListArray[i];
        }
        // print nice output about what we are doing for the log
        compileOptions.append(""Compilation args: "");
        for (int i = 0; i < compileOptionsArray.length; i++) {
            compileOptions.append(compileOptionsArray[i]);
            compileOptions.append("" "");
        }
        log(compileOptions.toString(), Project.MSG_VERBOSE);
        String eol = System.getProperty(""line.separator"");
        StringBuffer niceSourceList = new StringBuffer(""Files to be compiled:"" + eol);
        for (int i = 0; i < compileList.size(); i++) {
            niceSourceList.append(""    "");
            niceSourceList.append(compileList.elementAt(i).toString());
            niceSourceList.append(eol);
        }
        log(niceSourceList.toString(), Project.MSG_VERBOSE);
        // need to set java.class.path property and restore it later
        // since the NetRexx compiler has no option for the classpath
        String currentClassPath = System.getProperty(""java.class.path"");
        Properties currentProperties = System.getProperties();
        currentProperties.put(""java.class.path"", classpath);
        try {
            StringWriter out = new StringWriter(); 
            int rc = COM.ibm.netrexx.process.NetRexxC.
                main(new Rexx(compileArgs), new PrintWriter(out));
            if (rc > 1) { // 1 is warnings from real NetRexxC
                log(out.toString(), Project.MSG_ERR);
                String msg = ""Compile failed, messages should have been provided."";
                throw new BuildException(msg);
            }
            else if (rc == 1) {
                log(out.toString(), Project.MSG_WARN);
            }
            else {
                log(out.toString(), Project.MSG_INFO);
            }        
        } finally {
            // need to reset java.class.path property
            // since the NetRexx compiler has no option for the classpath
            currentProperties = System.getProperties();
            currentProperties.put(""java.class.path"", currentClassPath);
        }
    }
    /**
     * Builds the compilation classpath.
     */
    private String getCompileClasspath() {
        StringBuffer classpath = new StringBuffer();
        // add dest dir to classpath so that previously compiled and
        // untouched classes are on classpath
        classpath.append(destDir.getAbsolutePath());
        // add our classpath to the mix
        if (this.classpath != null) {
            addExistingToClasspath(classpath, this.classpath);
        }
        // add the system classpath
        // addExistingToClasspath(classpath,System.getProperty(""java.class.path""));
        return classpath.toString();
    }
    /**
     * This
     */
    private String[] getCompileOptionsAsArray() {
        Vector options = new Vector();
        options.addElement(binary ? ""-binary"" : ""-nobinary"");
        options.addElement(comments ? ""-comments"" : ""-nocomments"");
        options.addElement(compile ? ""-compile"" : ""-nocompile"");
        options.addElement(compact ? ""-compact"" : ""-nocompact"");
        options.addElement(console ? ""-console"" : ""-noconsole"");
        options.addElement(crossref ? ""-crossref"" : ""-nocrossref"");
        options.addElement(decimal ? ""-decimal"" : ""-nodecimal"");
        options.addElement(diag ? ""-diag"" : ""-nodiag"");
        options.addElement(explicit ? ""-explicit"": ""-noexplicit"");
        options.addElement(format ? ""-format"" : ""-noformat"");
        options.addElement(keep ? ""-keep"" : ""-nokeep"");
        options.addElement(logo ? ""-logo"" : ""-nologo"");
        options.addElement(replace ? ""-replace"" : ""-noreplace"");
        options.addElement(savelog ? ""-savelog"" : ""-nosavelog"");
        options.addElement(sourcedir ? ""-sourcedir"" : ""-nosourcedir"");
        options.addElement(strictargs ? ""-strictargs"" : ""-nostrictargs"");
        options.addElement(strictassign ? ""-strictassign"" : ""-nostrictassign"");
        options.addElement(strictcase ? ""-strictcase"": ""-nostrictcase"");
        options.addElement(strictimport ? ""-strictimport"" : ""-nostrictimport"");
        options.addElement(strictprops ? ""-strictprops"" : ""-nostrictprops"");
        options.addElement(strictsignal ? ""-strictsignal"" : ""-nostrictsignal"");
        options.addElement(symbols ? ""-symbols"" : ""-nosymbols"");
        options.addElement(time ? ""-time"" : ""-notime"");
        options.addElement(""-"" + trace);
        options.addElement(utf8 ? ""-utf8"" : ""-noutf8"");
        options.addElement(""-"" + verbose);
        String[] results = new String[options.size()];
        options.copyInto(results);
        return results;
    }
    /**
     * Takes a classpath-like string, and adds each element of
     * this string to a new classpath, if the components exist.
     * Components that don't exist, aren't added.
     * We do this, because jikes issues warnings for non-existant
     * files/dirs in his classpath, and these warnings are pretty
     * annoying.
     * @param target - target classpath
     * @param source - source classpath
     * to get file objects.
     */
    private void addExistingToClasspath(StringBuffer target,String source) {
        StringTokenizer tok = new StringTokenizer(source,
                                                  System.getProperty(""path.separator""), false);
        while (tok.hasMoreTokens()) {
            File f = project.resolveFile(tok.nextToken());
            if (f.exists()) {
                target.append(File.pathSeparator);
                target.append(f.getAbsolutePath());
            } else {
                log(""Dropping from classpath: ""+
                    f.getAbsolutePath(), Project.MSG_VERBOSE);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.PropertyFile,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.text.*;
/**
 *PropertyFile task uses java.util.Properties to modify integer, String and
 *Date settings in a property file.<p>
 *
 *
 *The following is an example of its usage:
 *    <ul>&lt;target name=""setState""&gt;<br>
 *    <ul>&lt;property<br>
 *        <ul>name=""header""<br>
 *        value=""##Generated file - do not modify!""/&gt;<br>
 *      &lt;propertyfile file=""apropfile.properties"" comment=""${header}""&gt;<br>
 *        &lt;entry key=""product.version.major"" type=""int""  value=""5""/&gt;<br>
 *        &lt;entry key=""product.version.minor"" type=""int""  value=""0""/&gt;<br>
 *        &lt;entry key=""product.build.major""   type=""int""  value=""0"" /&gt;<br>
 *        &lt;entry key=""product.build.minor""   type=""int""  operation=""+"" /&gt;<br>
 *        &lt;entry key=""product.build.date""    type=""date"" operation=""now"" /&gt;<br>
 *        &lt;entry key=""intSet"" type=""int"" operation=""="" value=""681""/&gt;<br>
 *        &lt;entry key=""intDec"" type=""int"" operation=""-""/&gt;<br>
 *        &lt;entry key=""NeverDate"" type=""date"" operation=""never""/&gt;<br>
 *        &lt;entry key=""StringEquals"" type=""string"" value=""testValue""/&gt;<br>
 *        &lt;entry key=""NowDate"" type=""date"" operation=""now""/&gt;<br></ul>
 *     &lt;/propertyfile&gt;<br></ul>
 *   &lt;/target&gt;</ul><p>
 *
 *The &lt;propertyfile&gt; task must have:<br>
 *    <ul><li>file</li></ul>
 *Other parameters are:<br>
 *    <ul><li>comment, key, operation, type and value (the final four being eliminated shortly)</li></ul>
 *
 *The &lt;entry&gt; task must have:<br>
 *    <ul><li>key</li></ul>
 *Other parameters are:<br>
 *    <ul><li>operation</li>
 *        <li>type</li>
 *        <li>value</li>
 *        <li>offset</li></ul>
 *
 *If type is unspecified, it defaults to string
 *
 *Parameter values:<br>
 *    <ul><li>operation:</li>
 *        <ul><li>""="" (set -- default)</li>
 *        <li>""-"" (dec)</li>
 *        <li>""+"" (inc)</li>
 *
 *    <li>type:</li>
 *        <ul><li>""int""</li>
 *        <li>""date""</li>
 *        <li>""string""</li></ul></ul>
 *
 *    <li>value:</li>
 *      <ul><li>holds the default value, if the property
 *              was not found in property file</li>
 *          <li>""now"" In case of type ""date"", the
 *              value ""now"" will be replaced by the current
 *              date/time and used even if a valid date was
 *              found in the property file.</li></ul>
 *
 *    <li>offset:<br>valid for ""-"" or ""+"", the offset (default
 *    set to 1) will be added or subtracted from ""int"" or
 *    ""date"" type value.</li>
 *    </ul>
 *
 *String property types can only use the ""="" operation.
 *Date property types can only use the ""never"" or ""now"" operations.
 *Int property types can only use the ""="", ""-"" or ""+"" operations.<p>
 *
 *The message property is used for the property file header, with ""\\"" being
 *a newline delimiter charater.
 *
 * @author Thomas Christen <a href=""mailto:chr@active.ch"">chr@active.ch</a>
 * @author Jeremy Mawson <a href=""mailto:jem@loftinspace.com.au>jem@loftinspace.com.au</a>
*/
public class PropertyFile extends Task
{
    /* ========================================================================
    *
    * Static variables.
    */
    private static final String NEWLINE = System.getProperty(""line.separator"");
    /* ========================================================================
    *
    * Instance variables.
    */
    // Use this to prepend a message to the properties file
    private String              m_comment;
    private Properties          m_properties;
    private File                m_propertyfile;
    private Vector entries = new Vector();
    /* ========================================================================
    *
    * Constructors
    */
    /* ========================================================================
    *
    * Methods
    */
    public void execute() throws BuildException
    {
        checkParameters();
        readFile();
        executeOperation();
        writeFile();
    }
    public Entry createEntry()
    {
        Entry e = new Entry();
        entries.addElement(e);
        return e;
    }
    private void executeOperation() throws BuildException
    {
        for (Enumeration e = entries.elements(); e.hasMoreElements(); )
        {
            Entry entry = (Entry)e.nextElement();
            entry.executeOn(m_properties);
        }
    }
    private void readFile() throws BuildException
    {
        // Create the PropertyFile
        m_properties = new Properties();
        try
        {
            if (m_propertyfile.exists())
            {
                log(""Updating property file: ""+m_propertyfile.getAbsolutePath());
                m_properties.load(new BufferedInputStream(
                                    new FileInputStream(m_propertyfile)));
            }
            else
            {
                log(""Creating new property file: ""+
                    m_propertyfile.getAbsolutePath());
                FileOutputStream out = new FileOutputStream(m_propertyfile.getAbsolutePath());
                out.flush();
                out.close();
            }
        }
        catch(IOException ioe)
        {
            throw new BuildException(ioe.toString());
        }
    }
    private void checkParameters() throws BuildException
    {
        if (!checkParam(m_propertyfile))
        {
            throw new BuildException(""file token must not be null."", location);
        }
    }
    public void setFile(File file)
    {
        m_propertyfile = file;
    }
    public void setComment(String hdr)
    {
        m_comment = hdr;
    }
    private void writeFile() throws BuildException
    {
        BufferedOutputStream bos = null;
        try
        {
            bos = new BufferedOutputStream(new FileOutputStream(m_propertyfile));
            // Properties.store is not available in JDK 1.1
            Method m =
                Properties.class.getMethod(""store"",
                                           new Class[] {
                                               OutputStream.class,
                                               String.class}
                                           );
            m.invoke(m_properties, new Object[] {bos, m_comment});
        } catch (NoSuchMethodException nsme) {
            m_properties.save(bos, m_comment);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            throw new BuildException(t, location);
        } catch (IllegalAccessException iae) {
            // impossible
            throw new BuildException(iae, location);
        }
        catch (IOException ioe)
        {
            throw new BuildException(ioe, location);
        }
        finally {
            if (bos != null) {
                try {
                    bos.close();
                } catch (IOException ioex) {}
            }
        }
    }
    /*
    * Returns whether the given parameter has been defined.
    */
    private boolean checkParam(String param)
    {
        return !((param == null) || (param.equals(""null"")));
    }
    private boolean checkParam(File param)
    {
        return !(param == null);
    }
    /**
     * Instance of this class represents nested elements of
     * a task propertyfile.
     */
    public static class Entry
    {
        static final String NOW_VALUE_ =        ""now"";
        static final String NULL_VALUE_ =       ""never"";
        private static final int    DEFAULT_INT_VALUE =     1;
        private static final GregorianCalendar
            DEFAULT_DATE_VALUE = new GregorianCalendar();
        private String              m_key = null;
        private int                 m_type = Type.STRING_TYPE;
        private int                 m_operation = Operation.EQUALS_OPER;
        private String              m_value =""1"";
        private String              m_default = null;
        private String              m_pattern = null;
        public void setKey(String value)
        {
            this.m_key = value;
        }
        public void setValue(String value)
        {
            this.m_value = value;
        }
        public void setOperation(Operation value)
        {
            int newOperation = Operation.toOperation(value.getValue());
            if (newOperation == Operation.NOW_VALUE) {
                this.m_operation = Operation.EQUALS_OPER;
                this.setValue(this.NOW_VALUE_);
            }
            else if (newOperation == Operation.NULL_VALUE) {
                this.m_operation = Operation.EQUALS_OPER;
                this.setValue(this.NULL_VALUE_);
            }
            else {
                this.m_operation = newOperation;
            }
        }
        public void setType(Type value)
        {
            this.m_type = Type.toType(value.getValue());
        }
        public void setDefault(String value)
        {
            this.m_default = value;
        }
        public void setPattern(String value)
        {
            this.m_pattern = value;
        }
        protected void executeOn(Properties props) throws BuildException
        {
            checkParameters();
            // m_type may be null because it wasn't set
            try {
                if (m_type == Type.INTEGER_TYPE)
                {
                    executeInteger((String)props.get(m_key));
                }
                else if (m_type == Type.DATE_TYPE)
                {
                    executeDate((String)props.get(m_key));
                }
                else if (m_type == Type.STRING_TYPE)
                {
                    executeString((String)props.get(m_key));
                }
                else
                {
                    throw new BuildException(""Unknown operation type: ""+m_type+"""");
                }
            } catch (NullPointerException npe) {
                // Default to string type
                // which means do nothing
                npe.printStackTrace();
            }
            // Insert as a string by default
            props.put(m_key, m_value);
        }
        /**
        * Handle operations for type <code>date</code>.
        *
        * @param oldValue the current value read from the property file or
        *                 <code>null</code> if the <code>key</code> was
        *                 not contained in the property file.
        */
        private void executeDate(String oldValue) throws BuildException
        {
            GregorianCalendar value = new GregorianCalendar();
            GregorianCalendar newValue = new GregorianCalendar();
            if (m_pattern == null) m_pattern = ""yyyy/MM/dd HH:mm"";
            DateFormat fmt = new SimpleDateFormat(m_pattern);
            if (m_value != null) {
                if (NOW_VALUE_.equals(m_value.toLowerCase())) {
                    value.setTime(new Date());
                }
                else if (NULL_VALUE_.equals(m_value.toLowerCase())) {
                    value = null;
                }
                else {
                    try {
                        value.setTime(fmt.parse(m_value));
                    }
                    catch (Exception ex) {
                        // obviously not a date, try a simple int
                        try {
                            int offset = Integer.parseInt(m_value);
                            value.clear();
                            value.set(Calendar.DAY_OF_YEAR, offset);
                        }
                        catch (Exception ex_) {
                            value.clear();
                            value.set(Calendar.DAY_OF_YEAR, 1);
                        }
                    }
                }
            }
            // special case
            if (m_default != null &&
                NOW_VALUE_.equals(m_default.toLowerCase()) &&
                (m_operation == Operation.INCREMENT_OPER ||
                 m_operation == Operation.DECREMENT_OPER) ) {
                oldValue = null;
            }
            if (oldValue != null) {
                try {
                    newValue.setTime(fmt.parse(oldValue));
                }
                catch (ParseException pe)  { /* swollow */ }
            }
            else {
                if (m_default != null) {
                    if (NOW_VALUE_.equals(m_default.toLowerCase())) {
                        newValue.setTime(new Date());
                    }
                    else if (NULL_VALUE_.equals(m_default.toLowerCase())) {
                        newValue = null;
                    }
                    else {
                        try {
                            newValue.setTime(fmt.parse(m_default));
                        }
                        catch (ParseException pe)  { /* swollow */ }
                    }
                }
            }
            if (m_operation == Operation.EQUALS_OPER) {
                newValue = value;
            }
            else if (m_operation == Operation.INCREMENT_OPER) {
                newValue.add(Calendar.SECOND, value.get(Calendar.SECOND));
                newValue.add(Calendar.MINUTE, value.get(Calendar.MINUTE));
                newValue.add(Calendar.HOUR_OF_DAY, value.get(Calendar.HOUR_OF_DAY));
                newValue.add(Calendar.DAY_OF_YEAR, value.get(Calendar.DAY_OF_YEAR));
            }
            else if (m_operation == Operation.DECREMENT_OPER) {
                newValue.add(Calendar.SECOND, -1 * value.get(Calendar.SECOND));
                newValue.add(Calendar.MINUTE, -1 * value.get(Calendar.MINUTE));
                newValue.add(Calendar.HOUR_OF_DAY, -1 * value.get(Calendar.HOUR_OF_DAY));
                newValue.add(Calendar.DAY_OF_YEAR, -1 * value.get(Calendar.DAY_OF_YEAR));
            }
            if (newValue != null) {
                m_value = fmt.format(newValue.getTime());
            }
            else {
                m_value = """";
            }
        }
        /**
        * Handle operations for type <code>int</code>.
        *
        * @param oldValue the current value read from the property file or
        *                 <code>null</code> if the <code>key</code> was
        *                 not contained in the property file.
        */
        private void executeInteger(String oldValue) throws BuildException
        {
            int value = 0;
            int newValue  = 0;
            DecimalFormat fmt = (m_pattern != null) ? new DecimalFormat(m_pattern)
                                                    : new DecimalFormat();
            if (m_value != null) {
                try {
                    value = fmt.parse(m_value).intValue();
                }
                catch (NumberFormatException nfe) { /* swollow */ }
                catch (ParseException pe)  { /* swollow */ }
            }
            if (oldValue != null) {
                try {
                    newValue = fmt.parse(oldValue).intValue();
                }
                catch (NumberFormatException nfe) { /* swollow */ }
                catch (ParseException pe)  { /* swollow */ }
            }
            else if (m_default != null) {
                try {
                    newValue = fmt.parse(m_default).intValue();
                }
                catch (NumberFormatException nfe) { /* swollow */ }
                catch (ParseException pe)  { /* swollow */ }
            }
            if (m_operation == Operation.EQUALS_OPER) {
                newValue = value;
            }
            else if (m_operation == Operation.INCREMENT_OPER) {
                newValue += value;
            }
            else if (m_operation == Operation.DECREMENT_OPER) {
                newValue -= value;
            }
            m_value = fmt.format(newValue);
        }
        /**
        * Handle operations for type <code>string</code>.
        *
        * @param oldValue the current value read from the property file or
        *                 <code>null</code> if the <code>key</code> was
        *                 not contained in the property file.
        */
        private void executeString(String oldValue) throws BuildException
        {
            String value = """";
            String newValue  = """";
            if (m_value != null) {
                value = m_value;
            }
            if (oldValue != null) {
                newValue = oldValue;
            }
            else if (m_default != null) {
                newValue = m_default;
            }
            if (m_operation == Operation.EQUALS_OPER) {
                newValue = value;
            }
            else if (m_operation == Operation.INCREMENT_OPER) {
                newValue += value;
            }
            m_value = newValue;
        }
        /**
         * Check if parameter combinations can be supported
         */
        private void checkParameters() throws BuildException {
            if (m_type == Type.STRING_TYPE &&
                m_operation == Operation.DECREMENT_OPER) {
                throw new BuildException(""- is not suported for string properties (key:"" + m_key + "")"");
            }
            if (m_value == null) {
                throw new BuildException(""value is mandatory (key:"" + m_key + "")"");
            }
            if (m_key == null) {
                throw new BuildException(""key is mandatory"");
            }
            if (m_type == Type.STRING_TYPE &&
                m_pattern != null) {
                throw new BuildException(""pattern is not suported for string properties (key:"" + m_key + "")"");
            }
        }
        /**
         * Enumerated attribute with the values ""+"", ""-"", ""="", ""now"" and ""never"".
         */
        public static class Operation extends EnumeratedAttribute {
            // Property type operations
            public static final int INCREMENT_OPER =   0;
            public static final int DECREMENT_OPER =   1;
            public static final int EQUALS_OPER =      2;
            // Special values
            public static final int NOW_VALUE =        3;
            public static final int NULL_VALUE =       4;
            public String[] getValues() {
                return new String[] {""+"", ""-"", ""="", NOW_VALUE_, NULL_VALUE_};
            }
            public static int toOperation(String oper) {
                if (""+"".equals(oper)) {
                    return INCREMENT_OPER;
                }
                else if (""-"".equals(oper)) {
                    return DECREMENT_OPER;
                }
                else if (NOW_VALUE_.equals(oper)) {
                    return NOW_VALUE;
                }
                else if (NULL_VALUE_.equals(oper)) {
                    return NULL_VALUE;
                }
                return EQUALS_OPER;
            }
        }
        /**
         * Enumerated attribute with the values ""int"", ""date"" and ""string"".
         */
        public static class Type extends EnumeratedAttribute {
            // Property types
            public static final int INTEGER_TYPE =     0;
            public static final int DATE_TYPE =        1;
            public static final int STRING_TYPE =      2;
            public String[] getValues() {
                return new String[] {""int"", ""date"", ""string""};
            }
            public static int toType(String type) {
                if (""int"".equals(type)) {
                    return INTEGER_TYPE;
                }
                else if (""date"".equals(type)) {
                    return DATE_TYPE;
                }
                return STRING_TYPE;
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.RenameExtensions,"/*
 * The Apache Software License, Version 1.1
 * 
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Task to rename files based on extension. This task has the following
 * properties which can be set:
 * <ul>
 * <li>fromExtension: </li>
 * <li>toExtension: </li>
 * <li>srcDir: </li>
 * <li>replace: </li>
 * </ul>
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.Mapper;
/**
 *
 * @author dIon Gillard <a href=""mailto:dion@multitask.com.au"">dion@multitask.com.au</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 * @version 1.2
 */
public class RenameExtensions extends MatchingTask {
    private String fromExtension = """";
    private String toExtension = """";
    private boolean replace = false;
    private File srcDir;
    private Mapper.MapperType globType;
    /** Creates new RenameExtensions */
    public RenameExtensions() {
        super();
        globType = new Mapper.MapperType();
        globType.setValue(""glob"");
    }
    /** store fromExtension **/
    public void setFromExtension(String from) {
        fromExtension = from;
    }
    /** store toExtension **/
    public void setToExtension(String to) {
        toExtension = to;
    }
    /**
     * store replace attribute - this determines whether the target file
     * should be overwritten if present
     */
    public void setReplace(boolean replace) {
        this.replace = replace;
    }
    /**
     * Set the source dir to find the files to be renamed.
     */
    public void setSrcDir(File srcDir) {
        this.srcDir = srcDir;
    }
    /**
     * Executes the task, i.e. does the actual compiler call
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a from and to extension
        if (fromExtension == null || toExtension == null || srcDir == null) {
            throw new BuildException( ""srcDir, fromExtension and toExtension "" +
                                      ""attributes must be set!"" );
        }
        log(""DEPRECATED - The renameext task is deprecated.  Use move instead."",
            Project.MSG_WARN);
        log(""Replace this with:"", Project.MSG_INFO);
        log(""<move todir=\""""+srcDir+""\"" overwrite=\""""+replace+""\"">"", 
            Project.MSG_INFO);
        log(""  <fileset dir=\""""+srcDir+""\"" />"", Project.MSG_INFO);
        log(""  <mapper type=\""glob\"""", Project.MSG_INFO);
        log(""          from=\""*""+fromExtension+""\"""", Project.MSG_INFO);
        log(""          to=\""*""+toExtension+""\"" />"", Project.MSG_INFO);
        log(""</move>"", Project.MSG_INFO);
        log(""using the same patterns on <fileset> as you\'ve used here"", 
            Project.MSG_INFO);
        Move move = (Move)project.createTask(""move"");
        move.setOwningTarget(target);
        move.setTaskName(getTaskName());
        move.setLocation(getLocation());
        move.setTodir(srcDir);
        move.setOverwrite(replace);
        fileset.setDir(srcDir);
        move.addFileset(fileset);
        Mapper me = move.createMapper();
        me.setType(globType);
        me.setFrom(""*""+fromExtension);
        me.setTo(""*""+toExtension);
        move.execute();
    }
}
"
org.apache.tools.ant.taskdefs.optional.Script,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import com.ibm.bsf.*;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
/**
 * Execute a script
 *
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 */
public class Script extends Task {
    private String language;
    private String script = """";
    private Hashtable beans = new Hashtable();
    /**
     * Add a list of named objects to the list to be exported to the script
     */
    private void addBeans(Hashtable dictionary) {
        for (Enumeration e=dictionary.keys(); e.hasMoreElements(); ) {
            String key = (String)e.nextElement();
            boolean isValid = key.length()>0 &&
                Character.isJavaIdentifierStart(key.charAt(0));
            for (int i=1; isValid && i<key.length(); i++)
                isValid = Character.isJavaIdentifierPart(key.charAt(i));
            if (isValid) beans.put(key, dictionary.get(key));
        }
    }
    /**
     * Do the work.
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        try {
            addBeans(project.getProperties());
            addBeans(project.getUserProperties());
            addBeans(project.getTargets());
            addBeans(project.getReferences());
            BSFManager manager = new BSFManager ();
            for (Enumeration e = beans.keys() ; e.hasMoreElements() ;) {
                String key = (String)e.nextElement();
                Object value = beans.get(key);
                manager.declareBean(key, value, value.getClass());
            }
            // execute the script
            manager.exec(language, ""<ANT>"", 0, 0, script);
        } catch (BSFException be) {
            Throwable t = be;
            Throwable te = be.getTargetException();
            if (te != null) {
                if  (te instanceof BuildException) {
                    throw (BuildException) te;
                } else {
                    t = te;
                }
            }
            throw new BuildException(t);
        }
    }
    /**
     * Defines the language (required).
     *
     * @param msg Sets the value for the script variable.
     */
    public void setLanguage(String language) {
        this.language = language;
    }
    /**
     * Load the script from an external file 
     *
     * @param msg Sets the value for the script variable.
     */
    public void setSrc(String fileName) {
        File file = new File(fileName);
        if (!file.exists()) 
            throw new BuildException(""file "" + fileName + "" not found."");
        int count = (int)file.length();
        byte data[] = new byte[count];
        try {
            FileInputStream inStream = new FileInputStream(file);
            inStream.read(data);
            inStream.close();
        } catch (IOException e) {
            throw new BuildException(e);
        }
        script += new String(data);
    }
    /**
     * Defines the script.
     *
     * @param msg Sets the value for the script variable.
     */
    public void addText(String text) {
        this.script += text;
    }
}
"
org.apache.tools.ant.taskdefs.optional.StyleBook,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.File; 
import org.apache.tools.ant.BuildException; 
import org.apache.tools.ant.types.CommandlineJava; 
import org.apache.tools.ant.types.Path; 
import org.apache.tools.ant.Task; 
import org.apache.tools.ant.taskdefs.Java; 
/** 
 * Basic task for apache stylebook.
 * 
 * @author <a href=""mailto:donaldp@apache.org"">Peter Donald</a> 
 */ 
public class StyleBook 
    extends Java 
{ 
    protected File                   m_targetDirectory;
    protected File                   m_skinDirectory;
    protected File                   m_book;
    public StyleBook() {
        setClassname( ""org.apache.stylebook.StyleBook"" );
        setFork( true );
        setFailonerror( true );
    }
    public void setBook( final File book ) {
        m_book = book;
    } 
    public void setSkinDirectory( final File skinDirectory ) {
        m_skinDirectory = skinDirectory;
    } 
    public void setTargetDirectory( final File targetDirectory ) {
        m_targetDirectory = targetDirectory;
    } 
    public void execute()  
        throws BuildException  { 
        if( null == m_targetDirectory ) {
            throw new BuildException( ""TargetDirectory attribute not set."" );
        }
        if( null == m_skinDirectory ) {
            throw new BuildException( ""SkinDirectory attribute not set."" );
        }
        if( null == m_book ) {
            throw new BuildException( ""book attribute not set."" );
        } 
        createArg().setValue( ""targetDirectory="" + m_targetDirectory );
        createArg().setValue( m_book.toString() );
        createArg().setValue( m_skinDirectory.toString() );
        super.execute();
    } 
} 
"
org.apache.tools.ant.taskdefs.optional.Test,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.BuildException; 
import org.apache.tools.ant.taskdefs.Java; 
import java.util.Vector; 
/** 
 * 
 * @author <a href=""mailto:donaldp@apache.org"">Peter Donald</a> 
 */ 
public class Test 
    extends Java {
    protected Vector                          m_tests            = new Vector();
    protected static final class TestletEntry {
        protected String m_testname = """";
        public void addText( final String testname ) {
            m_testname += testname;
        }
        public String toString() {
            return m_testname;
        }
    }
    public Test() {
        setClassname( ""org.apache.testlet.engine.TextTestEngine"" );
    }
    public TestletEntry createTestlet() {
        final TestletEntry entry = new TestletEntry();
        m_tests.addElement( entry );
        return entry;
    }
    public void setShowSuccess( final boolean showSuccess ) {
        createArg().setValue( ""-s="" + showSuccess );
    } 
    public void setShowBanner( final String showBanner ) { 
        createArg().setValue( ""-b="" + showBanner );
    } 
    public void setShowTrace( final boolean showTrace ) {
         createArg().setValue( ""-t="" + showTrace );
    } 
    public void setForceShowTrace( final boolean forceShowTrace ) { 
        createArg().setValue( ""-f="" + forceShowTrace );
    } 
    public void execute() 
        throws BuildException  { 
        final int size = m_tests.size();
        for( int i = 0; i < size; i ++ ) {
            createArg().setValue( m_tests.elementAt( i ).toString() );
        }
        super.execute();
    } 
} 
"
org.apache.tools.ant.taskdefs.optional.TraXLiaison,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.FileOutputStream;
import org.apache.tools.ant.taskdefs.XSLTLiaison;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.Templates;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
/**
 *
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @author <a href=""mailto:dims@yahoo.com"">Davanum Srinivas</a>
 * @version $Revision: 1.1 $ $Date: 2001/01/03 16:48:39 $
 */
public class TraXLiaison implements XSLTLiaison {
    protected final static String FILEURL = ""file:"";
    /** The trax TransformerFactory */
    private TransformerFactory tfactory = null;
    /** Stylesheet template */
    private Templates templates = null;
    /** The trax Transformer itself */
    private Transformer transformer;
    public TraXLiaison() throws Exception {
        tfactory = TransformerFactory.newInstance();
    }
    public void setStylesheet(String fileName) throws Exception {
        templates = tfactory.newTemplates(new StreamSource(normalize(fileName)));
        transformer = templates.newTransformer();
    };
    public void transform(String infile, String outfile) throws Exception {
        transformer.transform(new StreamSource(normalize(infile)), new StreamResult(new FileOutputStream(outfile)));
    }
    protected String normalize(String fileName) {
        if(fileName != null && !fileName.startsWith(FILEURL)) {
            return FILEURL + fileName;
        }
        return fileName;
    }
    public void addParam(String name, String value){
        transformer.setParameter(name, value);
    }
} //-- TraXLiaison
"
org.apache.tools.ant.taskdefs.optional.XalanLiaison,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import org.apache.tools.ant.taskdefs.XSLTLiaison;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTResultTarget;
/**
 *
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @version $Revision: 1.5 $ $Date: 2001/01/03 14:18:35 $
 */
public class XalanLiaison implements XSLTLiaison {
    protected final static String FILEURL = ""file:"";
    XSLTProcessor processor;
    XSLTInputSource xslSheet;
    public XalanLiaison() throws Exception {
      processor = XSLTProcessorFactory.getProcessor();
    }
    public void setStylesheet(String fileName) throws Exception {
        xslSheet = new XSLTInputSource (normalize(fileName));
    };
    public void transform(String infile, String outfile) throws Exception {
        processor.process(new XSLTInputSource(normalize(infile)), xslSheet,
                        new XSLTResultTarget(outfile));
    }
    protected String normalize(String fileName) {
        if(fileName != null && !fileName.startsWith(FILEURL)) {
            return FILEURL + fileName;
        }
        return fileName;
    }
    public void addParam(String name, String value){
        processor.setStylesheetParam(name, value);
    }
} //-- XalanLiaison
"
org.apache.tools.ant.taskdefs.optional.XslpLiaison,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional;
import java.io.FileWriter;
import org.apache.tools.ant.taskdefs.XSLTLiaison;
import com.kvisco.xsl.XSLProcessor;
import com.kvisco.xsl.XSLReader;
import com.kvisco.xsl.XSLStylesheet;
/**
 *
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @version $Revision: 1.4 $ $Date: 2001/01/03 14:18:36 $
 */
public class XslpLiaison implements XSLTLiaison {
    XSLProcessor processor;
    XSLStylesheet xslSheet;
    public XslpLiaison() {
      processor = new XSLProcessor();
    }
    public void setStylesheet(String fileName) throws Exception {
      XSLReader xslReader = new XSLReader();
      xslSheet = xslReader.read( fileName );
    };
    public void transform(String infile, String outfile) throws Exception {
      processor.process(infile, xslSheet, new FileWriter(outfile));
    }
    public void addParam(String name, String expression){
      processor.setProperty(name, expression);
    }
} //-- XSLPLiaison
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCCheckin,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.clearcase;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Task to perform Checkin command to ClearCase.
 * <p>
 * The following attributes are interpreted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>viewpath</td>
 *      <td>Path to the ClearCase view file or directory that the command will operate on</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>comment</td>
 *      <td>Specify a comment. Only one of comment or cfile may be used.</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>commentfile</td>
 *      <td>Specify a file containing a comment. Only one of comment or cfile may be used.</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>nowarn</td>
 *      <td>Suppress warning messages</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>preservetime</td>
 *      <td>Preserve the modification time</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>keepcopy</td>
 *      <td>Keeps a copy of the file with a .keep extension</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>identical</td>
 *      <td>Allows the file to be checked in even if it is identical to the original</td>
 *      <td>No</td>
 *   <tr>
 * </table>
 *
 * @author Curtis White
 */
public class CCCheckin extends ClearCase {
    private String m_Comment = null;
    private String m_Cfile = null;
    private boolean m_Nwarn = false;
    private boolean m_Ptime = false;
    private boolean m_Keep = false;
    private boolean m_Identical = true;
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute cleartool and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;
        // Default the viewpath to basedir if it is not specified
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }
        // build the command line from what we got. the format is
        // cleartool checkin [options...] [viewpath ...]
        // as specified in the CLEARTOOL.EXE help
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKIN);
        checkOptions(commandLine);
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Check the command line options.
     */
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            // -c
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                // -cfile
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }
        if (getNoWarn()) {
            // -nwarn
            cmd.createArgument().setValue(FLAG_NOWARN);
        }
        if (getPreserveTime()) {
            // -ptime
            cmd.createArgument().setValue(FLAG_PRESERVETIME);
        }
        if (getKeepCopy()) {
            // -keep
            cmd.createArgument().setValue(FLAG_KEEPCOPY);
        }
        if (getIdentical()) {
            // -identical
            cmd.createArgument().setValue(FLAG_IDENTICAL);
        }
        // viewpath
        cmd.createArgument().setValue(getViewPath());
    }
    /**
     * Set comment string
     *
     * @param comment the comment string
     */
    public void setComment(String comment) {
        m_Comment = comment;
    }
    /**
     * Get comment string
     *
     * @return String containing the comment
     */
    public String getComment() {
        return m_Comment;
    }
    /**
     * Set comment file
     *
     * @param cfile the path to the comment file
     */
    public void setCommentFile(String cfile) {
        m_Cfile = cfile;
    }
    /**
     * Get comment file
     *
     * @return String containing the path to the comment file
     */
    public String getCommentFile() {
        return m_Cfile;
    }
    /**
     * Set the nowarn flag
     *
     * @param nwarn the status to set the flag to
     */
    public void setNoWarn(boolean nwarn) {
        m_Nwarn = nwarn;
    }
    /**
     * Get nowarn flag status
     *
     * @return boolean containing status of nwarn flag
     */
    public boolean getNoWarn() {
        return m_Nwarn;
    }
    /**
     * Set preservetime flag
     *
     * @param ptime the status to set the flag to
     */
    public void setPreserveTime(boolean ptime) {
        m_Ptime = ptime;
    }
    /**
     * Get preservetime flag status
     *
     * @return boolean containing status of preservetime flag
     */
    public boolean getPreserveTime() {
        return m_Ptime;
    }
    /**
     * Set the keepcopy flag
     *
     * @param keep the status to set the flag to
     */
    public void setKeepCopy(boolean keep) {
        m_Keep = keep;
    }
    /**
     * Get keepcopy flag status
     *
     * @return boolean containing status of keepcopy flag
     */
    public boolean getKeepCopy() {
        return m_Keep;
    }
    /**
     * Set the identical flag
     *
     * @param identical the status to set the flag to
     */
    public void setIdentical(boolean identical) {
        m_Identical = identical;
    }
    /**
     * Get identical flag status
     *
     * @return boolean containing status of identical flag
     */
    public boolean getIdentical() {
        return m_Identical;
    }
    /**
     * Get the 'comment' command
     *
     * @return the 'comment' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the comment flag and string appended
     */
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }
    /**
     * Get the 'commentfile' command
     *
     * @return the 'commentfile' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the commentfile flag and file appended
     */
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }
        /**
     * -c flag -- comment to attach to the file
     */
    public static final String FLAG_COMMENT = ""-c"";
        /**
     * -cfile flag -- file containing a comment to attach to the file
     */
    public static final String FLAG_COMMENTFILE = ""-cfile"";
        /**
     * -nc flag -- no comment is specified
     */
    public static final String FLAG_NOCOMMENT = ""-nc"";
        /**
     * -nwarn flag -- suppresses warning messages
     */
    public static final String FLAG_NOWARN = ""-nwarn"";
        /**
     * -ptime flag -- preserves the modification time
     */
    public static final String FLAG_PRESERVETIME = ""-ptime"";
        /**
     * -keep flag -- keeps a copy of the file with a .keep extension
     */
    public static final String FLAG_KEEPCOPY = ""-keep"";
        /**
     * -identical flag -- allows the file to be checked in even if it is identical to the original
     */
    public static final String FLAG_IDENTICAL = ""-identical"";
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCCheckout,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.clearcase;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Task to perform Checkout command to ClearCase.
 * <p>
 * The following attributes are interpretted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>viewpath</td>
 *      <td>Path to the ClearCase view file or directory that the command will operate on</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>reserved</td>
 *      <td>Specifies whether to check out the file as reserved or not</td>
 *      <td>Yes</td>
 *   <tr>
 *   <tr>
 *      <td>out</td>
 *      <td>Creates a writable file under a different filename</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>nodata</td>
 *      <td>Checks out the file but does not create an editable file containing its data</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>branch</td>
 *      <td>Specify a branch to check out the file to</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>version</td>
 *      <td>Allows checkout of a version other than main latest</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>nowarn</td>
 *      <td>Suppress warning messages</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>comment</td>
 *      <td>Specify a comment. Only one of comment or cfile may be used.</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>commentfile</td>
 *      <td>Specify a file containing a comment. Only one of comment or cfile may be used.</td>
 *      <td>No</td>
 *   <tr>
 * </table>
 *
 * @author Curtis White
 */
public class CCCheckout extends ClearCase {
    private boolean m_Reserved = true;
    private String m_Out = null;
    private boolean m_Ndata = false;
    private String m_Branch = null;
    private boolean m_Version = false;
    private boolean m_Nwarn = false;
    private String m_Comment = null;
    private String m_Cfile = null;
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute cleartool and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;
        // Default the viewpath to basedir if it is not specified
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }
        // build the command line from what we got the format is
        // cleartool checkout [options...] [viewpath ...]
        // as specified in the CLEARTOOL.EXE help
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKOUT);
        checkOptions(commandLine);
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Check the command line options.
     */
    private void checkOptions(Commandline cmd) {
        // ClearCase items
        if (getReserved()) {
            // -reserved
            cmd.createArgument().setValue(FLAG_RESERVED);
        } else {
            // -unreserved
            cmd.createArgument().setValue(FLAG_UNRESERVED);
        }
        if (getOut() != null) {
            // -out
            getOutCommand(cmd);
        } else {
            if (getNoData()) {
                // -ndata
                cmd.createArgument().setValue(FLAG_NODATA);
            }
        }
        if (getBranch() != null) {
            // -branch
            getBranchCommand(cmd);
        } else {
            if (getVersion()) {
                // -version
                cmd.createArgument().setValue(FLAG_VERSION);
            }
        }
        if (getNoWarn()) {
            // -nwarn
            cmd.createArgument().setValue(FLAG_NOWARN);
        }
        if (getComment() != null) {
            // -c
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                // -cfile
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }
        // viewpath
        cmd.createArgument().setValue(getViewPath());
    }
    /**
     * Set reserved flag status
     *
     * @param reserved the status to set the flag to
     */
    public void setReserved(boolean reserved) {
        m_Reserved = reserved;
    }
    /**
     * Get reserved flag status
     *
     * @return boolean containing status of reserved flag
     */
    public boolean getReserved() {
        return m_Reserved;
    }
    /**
     * Set out file
     *
     * @param outf the path to the out file
     */
    public void setOut(String outf) {
        m_Out = outf;
    }
    /**
     * Get out file
     *
     * @return String containing the path to the out file
     */
    public String getOut() {
        return m_Out;
    }
    /**
     * Set the nodata flag
     *
     * @param ndata the status to set the flag to
     */
    public void setNoData(boolean ndata) {
        m_Ndata = ndata;
    }
    /**
     * Get nodata flag status
     *
     * @return boolean containing status of ndata flag
     */
    public boolean getNoData() {
        return m_Ndata;
    }
    /**
     * Set branch name
     *
     * @param branch the name of the branch
     */
    public void setBranch(String branch) {
        m_Branch = branch;
    }
    /**
     * Get branch name
     *
     * @return String containing the name of the branch
     */
    public String getBranch() {
        return m_Branch;
    }
    /**
     * Set the version flag
     *
     * @param version the status to set the flag to
     */
    public void setVersion(boolean version) {
        m_Version = version;
    }
    /**
     * Get version flag status
     *
     * @return boolean containing status of version flag
     */
    public boolean getVersion() {
        return m_Version;
    }
    /**
     * Set the nowarn flag
     *
     * @param nwarn the status to set the flag to
     */
    public void setNoWarn(boolean nwarn) {
        m_Nwarn = nwarn;
    }
    /**
     * Get nowarn flag status
     *
     * @return boolean containing status of nwarn flag
     */
    public boolean getNoWarn() {
        return m_Nwarn;
    }
    /**
     * Set comment string
     *
     * @param comment the comment string
     */
    public void setComment(String comment) {
        m_Comment = comment;
    }
    /**
     * Get comment string
     *
     * @return String containing the comment
     */
    public String getComment() {
        return m_Comment;
    }
    /**
     * Set comment file
     *
     * @param cfile the path to the comment file
     */
    public void setCommentFile(String cfile) {
        m_Cfile = cfile;
    }
    /**
     * Get comment file
     *
     * @return String containing the path to the comment file
     */
    public String getCommentFile() {
        return m_Cfile;
    }
    /**
     * Get the 'out' command
     *
     * @return the 'out' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the out flag and path appended
     */
    private void getOutCommand(Commandline cmd) {
        if (getOut() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_OUT);
            cmd.createArgument().setValue(getOut());
        }
    }
    /**
     * Get the 'branch' command
     *
     * @return the 'branch' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the branch flag and name appended
     */
    private void getBranchCommand(Commandline cmd) {
        if (getBranch() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_BRANCH);
            cmd.createArgument().setValue(getBranch());
        }
    }
    /**
     * Get the 'comment' command
     *
     * @return the 'comment' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the comment flag and string appended
     */
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }
    /**
     * Get the 'cfile' command
     *
     * @return the 'cfile' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the cfile flag and file appended
     */
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }
        /**
     *  -reserved flag -- check out the file as reserved
     */
    public static final String FLAG_RESERVED = ""-reserved"";
        /**
     *  -reserved flag -- check out the file as unreserved
     */
    public static final String FLAG_UNRESERVED = ""-unreserved"";
        /**
     * -out flag -- create a writable file under a different filename
     */
    public static final String FLAG_OUT = ""-out"";
        /**
     * -ndata flag -- checks out the file but does not create an editable file containing its data
     */
    public static final String FLAG_NODATA = ""-ndata"";
        /**
     * -branch flag -- checks out the file on a specified branch
     */
    public static final String FLAG_BRANCH = ""-branch"";
        /**
     * -version flag -- allows checkout of a version that is not main latest
     */
    public static final String FLAG_VERSION = ""-version"";
        /**
     * -nwarn flag -- suppresses warning messages
     */
    public static final String FLAG_NOWARN = ""-nwarn"";
        /**
     * -c flag -- comment to attach to the file
     */
    public static final String FLAG_COMMENT = ""-c"";
        /**
     * -cfile flag -- file containing a comment to attach to the file
     */
    public static final String FLAG_COMMENTFILE = ""-cfile"";
        /**
     * -nc flag -- no comment is specified
     */
    public static final String FLAG_NOCOMMENT = ""-nc"";
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCUnCheckout,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.clearcase;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Task to perform UnCheckout command to ClearCase.
 * <p>
 * The following attributes are interpretted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>viewpath</td>
 *      <td>Path to the ClearCase view file or directory that the command will operate on</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>keepcopy</td>
 *      <td>Specifies whether to keep a copy of the file with a .keep extension or not</td>
 *      <td>No</td>
 *   <tr>
 * </table>
 *
 * @author Curtis White
 */
public class CCUnCheckout extends ClearCase {
    private boolean m_Keep = false;
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute cleartool and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;
        // Default the viewpath to basedir if it is not specified
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }
        // build the command line from what we got the format is
        // cleartool uncheckout [options...] [viewpath ...]
        // as specified in the CLEARTOOL.EXE help
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_UNCHECKOUT);
        checkOptions(commandLine);
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Check the command line options.
     */
    private void checkOptions(Commandline cmd) {
        // ClearCase items
        if (getKeepCopy()) {
            // -keep
            cmd.createArgument().setValue(FLAG_KEEPCOPY);
        } else {
            // -rm
            cmd.createArgument().setValue(FLAG_RM);
        }
        // viewpath
        cmd.createArgument().setValue(getViewPath());
    }
    /**
     * Set keepcopy flag status
     *
     * @param keep the status to set the flag to
     */
    public void setKeepCopy(boolean keep) {
        m_Keep = keep;
    }
    /**
     * Get keepcopy flag status
     *
     * @return boolean containing status of keep flag
     */
    public boolean getKeepCopy() {
        return m_Keep;
    }
        /**
     *  -keep flag -- keep a copy of the file with .keep extension
     */
    public static final String FLAG_KEEPCOPY = ""-keep"";
        /**
     *  -rm flag -- remove the copy of the file
     */
    public static final String FLAG_RM = ""-rm"";
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCUpdate,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.clearcase;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import java.io.File;
import java.lang.System;
/**
 * Task to perform an Update command to ClearCase.
 * <p>
 * The following attributes are interpretted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>viewpath</td>
 *      <td>Path to the ClearCase view file or directory that the command will operate on</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>graphical</td>
 *      <td>Displays a graphical dialog during the update</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>log</td>
 *      <td>Specifies a log file for ClearCase to write to</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>overwrite</td>
 *      <td>Specifies whether to overwrite hijacked files or not</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>rename</td>
 *      <td>Specifies that hijacked files should be renamed with a .keep extension</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>currenttime</td>
 *      <td>Specifies that modification time should be written as the current time. Either currenttime or preservetime can be specified.</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>preservetime</td>
 *      <td>Specifies that modification time should preserved from the VOB time. Either currenttime or preservetime can be specified.</td>
 *      <td>No</td>
 *   <tr>
 * </table>
 *
 * @author Curtis White
 */
public class CCUpdate extends ClearCase {
    private boolean m_Graphical = false;
    private boolean m_Overwrite = false;
    private boolean m_Rename = false;
    private boolean m_Ctime = false;
    private boolean m_Ptime = false;
    private String m_Log = null;
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute cleartool and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;
        // Default the viewpath to basedir if it is not specified
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }
        // build the command line from what we got the format is
        // cleartool update [options...] [viewpath ...]
        // as specified in the CLEARTOOL.EXE help
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_UPDATE);
        // Check the command line options
        checkOptions(commandLine);
        // For debugging
        System.out.println(commandLine.toString());
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Check the command line options.
     */
    private void checkOptions(Commandline cmd) {
        // ClearCase items
        if (getGraphical()) {
            // -graphical
            cmd.createArgument().setValue(FLAG_GRAPHICAL);
        } else {
            if (getOverwrite()) {
                // -overwrite
                cmd.createArgument().setValue(FLAG_OVERWRITE);
            } else {
                if (getRename()) {
                    // -rename
                    cmd.createArgument().setValue(FLAG_RENAME);
                } else {
                    // -noverwrite
                    cmd.createArgument().setValue(FLAG_NOVERWRITE);
                }
            }
            if (getCurrentTime()) {
                // -ctime
                cmd.createArgument().setValue(FLAG_CURRENTTIME);
            } else {
                if (getPreserveTime()) {
                    // -ptime
                    cmd.createArgument().setValue(FLAG_PRESERVETIME);
                }
            }
            // -log logname
            getLogCommand(cmd);
        }
        // viewpath
        cmd.createArgument().setValue(getViewPath());
    }
    /**
     * Set graphical flag status
     *
     * @param graphical the status to set the flag to
     */
    public void setGraphical(boolean graphical) {
        m_Graphical = graphical;
    }
    /**
     * Get graphical flag status
     *
     * @return boolean containing status of graphical flag
     */
    public boolean getGraphical() {
        return m_Graphical;
    }
    /**
     * Set overwrite hijacked files status
     *
     * @param ow the status to set the flag to
     */
    public void setOverwrite(boolean ow) {
        m_Overwrite = ow;
    }
    /**
     * Get overwrite hijacked files status
     *
     * @return boolean containing status of overwrite flag
     */
    public boolean getOverwrite() {
        return m_Overwrite;
    }
    /**
     * Set rename hijacked files status
     *
     * @param ren the status to set the flag to
     */
    public void setRename(boolean ren) {
        m_Rename = ren;
    }
    /**
     * Get rename hijacked files status
     *
     * @return boolean containing status of rename flag
     */
    public boolean getRename() {
        return m_Rename;
    }
    /**
     * Set modified time based on current time
     *
     * @param ct the status to set the flag to
     */
    public void setCurrentTime(boolean ct) {
        m_Ctime = ct;
    }
    /**
     * Get current time status
     *
     * @return boolean containing status of current time flag
     */
    public boolean getCurrentTime() {
        return m_Ctime;
    }
    /**
     * Preserve modified time from the VOB time
     *
     * @param pt the status to set the flag to
     */
    public void setPreserveTime(boolean pt) {
        m_Ptime = pt;
    }
    /**
     * Get preserve time status
     *
     * @return boolean containing status of preserve time flag
     */
    public boolean getPreserveTime() {
        return m_Ptime;
    }
    /**
     * Set log file where cleartool can record the status of the command
     *
     * @param log the path to the log file
     */
    public void setLog(String log) {
        m_Log = log;
    }
    /**
     * Get log file
     *
     * @return String containing the path to the log file
     */
    public String getLog() {
        return m_Log;
    }
    /**
     * Get the 'log' command
     *
     * @return the 'log' command if the attribute was specified, otherwise an empty string
     *
     * @param CommandLine containing the command line string with or without the log flag and path appended
     */
    private void getLogCommand(Commandline cmd) {
        if (getLog() == null) {
            return;
        } else {
            /* Had to make two separate commands here because if a space is
               inserted between the flag and the value, it is treated as a
               Windows filename with a space and it is enclosed in double
               quotes (""). This breaks clearcase.
            */
            cmd.createArgument().setValue(FLAG_LOG);
            cmd.createArgument().setValue(getLog());
        }
    }
        /**
     *  -graphical flag -- display graphical dialog during update operation
     */
    public static final String FLAG_GRAPHICAL = ""-graphical"";
        /**
     * -log flag -- file to log status to
     */
    public static final String FLAG_LOG = ""-log"";
        /**
     * -overwrite flag -- overwrite hijacked files
     */
    public static final String FLAG_OVERWRITE = ""-overwrite"";
        /**
     * -noverwrite flag -- do not overwrite hijacked files
     */
    public static final String FLAG_NOVERWRITE = ""-noverwrite"";
        /**
     * -rename flag -- rename hijacked files with .keep extension
     */
    public static final String FLAG_RENAME = ""-rename"";
        /**
     * -ctime flag -- modified time is written as the current time
     */
    public static final String FLAG_CURRENTTIME = ""-ctime"";
        /**
     * -ptime flag -- modified time is written as the VOB time
     */
    public static final String FLAG_PRESERVETIME = ""-ptime"";
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.ClearCase,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.clearcase;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import java.io.File;
/**
 * A base class for creating tasks for executing commands on ClearCase.
 * <p>
 * The class extends the 'exec' task as it operates by executing the cleartool program
 * supplied with ClearCase. By default the task expects the cleartool executable to be
 * in the path, * you can override this be specifying the cleartooldir attribute.
 * </p>
 * <p>
 * This class provides set and get methods for the 'viewpath' attribute. It
 * also contains constants for the flags that can be passed to cleartool.
 * </p>
 *
 * @author Curtis White
 */
public abstract class ClearCase extends Task {
    private String m_ClearToolDir = """";
    private String m_viewPath = null;
    /**
     * Set the directory where the cleartool executable is located
     *
     * @param dir the directory containing the cleartool executable
     */
    public final void setClearToolDir(String dir) {
        m_ClearToolDir = project.translatePath(dir);
    }
    /**
     * Builds and returns the command string to execute cleartool
     *
     * @return String containing path to the executable
     */
    protected final String getClearToolCommand() {
        String toReturn = m_ClearToolDir;
        if ( !toReturn.equals("""") && !toReturn.endsWith(""/"") ) {
            toReturn += ""/"";
        }
        toReturn += CLEARTOOL_EXE;
        return toReturn;
    }
    /**
     * Set the path to the item in a clearcase view to operate on
     *
     * @param viewPath Path to the view directory or file
     */
    public final void setViewPath(String viewPath) {
        m_viewPath = viewPath;
    }
    /**
     * Get the path to the item in a clearcase view
     *
     * @return m_viewPath
     */
    public String getViewPath() {
        return m_viewPath;
    }
    protected int run(Commandline cmd) {
        try {
            Project aProj = getProject();
            Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
            exe.setAntRun(aProj);
            exe.setWorkingDirectory(aProj.getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            return exe.execute();
        }
        catch (java.io.IOException e) {
            throw new BuildException(e, location);
        }
    }
    /**
     * Constant for the thing to execute
     */
    private static final String CLEARTOOL_EXE = ""cleartool"";
    /**
     * The 'Update' command
     */
    public static final String COMMAND_UPDATE = ""update"";
    /**
     * The 'Checkout' command
     */
    public static final String COMMAND_CHECKOUT = ""checkout"";
    /**
     * The 'Checkin' command
     */
    public static final String COMMAND_CHECKIN = ""checkin"";
    /**
     * The 'UndoCheckout' command
     */
    public static final String COMMAND_UNCHECKOUT = ""uncheckout"";
}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFile,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
import java.io.*;
import java.lang.reflect.Modifier;
import java.util.*;
import org.apache.tools.ant.taskdefs.optional.depend.constantpool.*;
/**
 * A ClassFile object stores information about a Java class.
 * 
 * The class may be read from a DataInputStream.and written
 * to a DataOutputStream. These are usually streams from a Java
 * class file or a class file component of a Jar file.
 * 
 * @author Conor MacNeill
 */
public class ClassFile {
    /**
     * The Magic Value that marks the start of a Java class file
     */
    static private final int CLASS_MAGIC = 0xCAFEBABE;
    /**
     * This class' constant pool.
     */
    private ConstantPool constantPool;
    /**
     * The class name for this class.
     */
    private String className;
    /**
     * Read the class from a data stream.
     * 
     * This method takes an InputStream as input and
     * parses the class from the stream.
     * <p>
     * 
     * @param stream an InputStream from which the class will be read
     * 
     * @throws IOException if there is a problem reading from the given stream.
     * @throws ClassFormatError if the class cannot be parsed correctly
     * 
     */
    public void read(InputStream stream) throws IOException, ClassFormatError {
        DataInputStream classStream = new DataInputStream(stream);
        if (classStream.readInt() != CLASS_MAGIC) {
            throw new ClassFormatError(""No Magic Code Found - probably not a Java class file."");
        } 
        // right we have a good looking class file.
        int minorVersion = classStream.readUnsignedShort();
        int majorVersion = classStream.readUnsignedShort();
        // read the constant pool in and resolve it
        constantPool = new ConstantPool();
        constantPool.read(classStream);
        constantPool.resolve();
        int accessFlags = classStream.readUnsignedShort();
        int thisClassIndex = classStream.readUnsignedShort();
        int superClassIndex = classStream.readUnsignedShort();
        className = ((ClassCPInfo) constantPool.getEntry(thisClassIndex)).getClassName();
    } 
    /**
     * Get the classes which this class references.
     */
    public Vector getClassRefs() {
        Vector classRefs = new Vector();
        for (int i = 0; i < constantPool.size(); ++i) {
            ConstantPoolEntry entry = constantPool.getEntry(i);
            if (entry != null && entry.getTag() == ConstantPoolEntry.CONSTANT_Class) {
                ClassCPInfo classEntry = (ClassCPInfo) entry;
                if (!classEntry.getClassName().equals(className)) {
                    classRefs.addElement(ClassFileUtils.convertSlashName(classEntry.getClassName()));
                } 
            } 
        } 
        return classRefs;
    } 
    /**
     * Get the class' fully qualified name in dot format.
     * 
     * @return the class name in dot format (eg. java.lang.Object)
     */
    public String getFullClassName() {
        return ClassFileUtils.convertSlashName(className);
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFileIterator,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
public interface ClassFileIterator {
    public ClassFile getNextClassFile();
}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFileUtils,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
/**
 * Utility class file routines.
 * 
 * This class porovides a number of static utility methods to convert between the
 * formats used in the Java class file format and those commonly used in Java
 * programming.
 * 
 * @author Conor MacNeill
 */
public class ClassFileUtils {
    /**
     * Convert a class name from class file slash notation to java source
     * file dot notation.
     * 
     * @param slashName the class name in slash notation (eg. java/lang/Object)
     * 
     * @return the class name in dot notation (eg. java.lang.Object).
     */
    static public String convertSlashName(String name) {
        return name.replace('\\', '.').replace( '/', '.' );
    } 
    /**
     * Convert a class name from java source file dot notation to class file slash notation..
     * 
     * @param dotName the class name in dot notation (eg. java.lang.Object).
     * 
     * @return the class name in slash notation (eg. java/lang/Object).
     */
    static public String convertDotName(String dotName) {
        return dotName.replace( '.', '/');
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.Depend,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.taskdefs.MatchingTask;
import java.util.*;
import java.io.*;
import org.apache.tools.ant.taskdefs.optional.depend.*;
/**
 * Generate a dependency file for a given set of classes 
 *
 * @author Conor MacNeill
 */
public class Depend extends MatchingTask {
    static private class ClassFileInfo {
        public File absoluteFile;
        public String relativeName;
        public String className;
    };
    /**
     * The path where source files exist
     */    
    private Path srcPath;
    /**
     * The path where compiled class files exist.
     */
    private Path destPath;
    /**
     * The directory which contains the dependency cache.
     */
    private File cache;
    /**
     * A map which gives for every class a list of te class which it affects.
     */
    private Hashtable affectedClassMap;
    /**
     * A map which gives information about a class
     */
    private Hashtable classFileInfoMap;
    /**
     * The list of classes which are out of date.
     */
    private Vector outOfDateClasses;
    /**
     * indicates that the dependency relationships should be extended
     * beyond direct dependencies to include all classes. So if A directly
     * affects B abd B directly affects C, then A indirectly affects C.
     */
    private boolean closure = false;
    private void writeDependencyList(File depFile, Vector dependencyList) throws IOException {
        // new dependencies so need to write them out to the cache
        PrintWriter pw = null;
        try {
            String parent = depFile.getParent();
            if (parent != null) {
                new File(parent).mkdirs(); 
            }
            pw = new PrintWriter(new FileWriter(depFile));
            for (Enumeration deps = dependencyList.elements(); deps.hasMoreElements();) {
                pw.println(deps.nextElement());
            }
        }
        finally {
            if (pw != null) { 
                pw.close();
            }
        }
    }
    private Vector readDependencyList(File depFile) throws IOException {
        Vector dependencyList = null;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(depFile));
            String line = null;
            dependencyList = new Vector();
            while ((line = in.readLine()) != null) {
                dependencyList.addElement(line);
            }
        }
        finally {
            if (in != null) { 
                in.close();
            }
        }
        return dependencyList;
    }
    private void determineDependencies() throws IOException {
        affectedClassMap = new Hashtable();
        classFileInfoMap = new Hashtable();
        for (Enumeration e = getClassFiles(destPath).elements(); e.hasMoreElements(); ) {
            ClassFileInfo info = (ClassFileInfo)e.nextElement();
            log(""Adding class info for "" + info.className, Project.MSG_DEBUG);
            classFileInfoMap.put(info.className, info);
            Vector dependencyList = null;
            if (cache != null) {
                // try to read the dependency info from the cache if it is not out of date
                File depFile = new File(cache, info.relativeName + "".dep"");
                if (depFile.exists() && depFile.lastModified() > info.absoluteFile.lastModified()) {
                    // depFile exists and is newer than the class file
                    // need to read dependency list from the file.
                    dependencyList = readDependencyList(depFile);
                }
            }
            if (dependencyList == null) {
                // not cached - so need to read directly from the class file
                FileInputStream inFileStream = null;
                try {
                    inFileStream = new FileInputStream(info.absoluteFile);
                    ClassFile classFile = new ClassFile();
                    classFile.read(inFileStream);
                    dependencyList = classFile.getClassRefs();
                    if (cache != null) {
                        // new dependencies so need to write them out to the cache
                        File depFile = new File(cache, info.relativeName + "".dep"");
                        writeDependencyList(depFile, dependencyList);
                    }
                }
                finally {
                    if (inFileStream != null) {
                        inFileStream.close();
                    }
                }
            }
            // This class depends on each class in the dependency list. For each
            // one of those, add this class into their affected classes list 
            for (Enumeration depEnum = dependencyList.elements(); depEnum.hasMoreElements(); ) {
                String dependentClass = (String)depEnum.nextElement();
                Hashtable affectedClasses = (Hashtable)affectedClassMap.get(dependentClass);
                if (affectedClasses == null) {
                    affectedClasses = new Hashtable();
                    affectedClassMap.put(dependentClass, affectedClasses);
                }
                affectedClasses.put(info.className, info);
            }
        }
    }
    private void deleteAllAffectedFiles() {
        for (Enumeration e = outOfDateClasses.elements(); e.hasMoreElements();) {
            String className = (String)e.nextElement();
            deleteAffectedFiles(className);
        }            
    }
    private void deleteAffectedFiles(String className) {
        Hashtable affectedClasses = (Hashtable)affectedClassMap.get(className);
        if (affectedClasses != null) {
            for (Enumeration e = affectedClasses.keys(); e.hasMoreElements(); ) {
                String affectedClassName = (String)e.nextElement();
                ClassFileInfo affectedClassInfo = (ClassFileInfo)affectedClasses.get(affectedClassName);
                if (affectedClassInfo.absoluteFile.exists()) {
                    log(""Deleting file "" + affectedClassInfo.absoluteFile.getPath() + "" since "" + 
                        className + "" out of date"", Project.MSG_VERBOSE);
                    affectedClassInfo.absoluteFile.delete();
                    if (closure) {
                        deleteAffectedFiles(affectedClassName);
                    }
                    else {
                        // without closure we may delete an inner class but not the
                        // top level class which would not trigger a recompile.
                        if (affectedClassName.indexOf(""$"") != -1) {
                            // need to delete the main class
                            String topLevelClassName 
                                = affectedClassName.substring(0, affectedClassName.indexOf(""$""));
                            log(""Top level class = "" + topLevelClassName, Project.MSG_VERBOSE);
                            ClassFileInfo topLevelClassInfo 
                                = (ClassFileInfo)classFileInfoMap.get(topLevelClassName);
                            if (topLevelClassInfo != null &&
                                topLevelClassInfo.absoluteFile.exists()) {
                                log(""Deleting file "" + topLevelClassInfo.absoluteFile.getPath() + "" since "" + 
                                    ""one of its inner classes was removed"", Project.MSG_VERBOSE);
                                topLevelClassInfo.absoluteFile.delete();
                                if (closure) {
                                    deleteAffectedFiles(topLevelClassName);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Does the work.
     *
     * @exception BuildException Thrown in unrecovrable error.
     */
    public void execute() throws BuildException {
        try {
            long start = System.currentTimeMillis();
            String [] srcPathList = srcPath.list();
            if (srcPathList.length == 0) {
                throw new BuildException(""srcdir attribute must be set!"", location);
            }
            if (destPath == null) {
                destPath = srcPath;
            }
            if (cache != null && cache.exists() && !cache.isDirectory()) {
                throw new BuildException(""The cache, if specified, must point to a directory"");
            }
            if (cache != null && !cache.exists()) {
                cache.mkdirs();
            }
            determineDependencies();
/*            
            for (Enumeration e = affectedClassMap.keys(); e.hasMoreElements(); ) {
                String className = (String)e.nextElement();
                log(""Class "" + className + "" affects:"", Project.MSG_DEBUG);
                Hashtable affectedClasses = (Hashtable)affectedClassMap.get(className);
                for (Enumeration e2 = affectedClasses.keys(); e2.hasMoreElements(); ) {
                    String affectedClass = (String)e2.nextElement();
                    ClassFileInfo info = (ClassFileInfo)affectedClasses.get(affectedClass);
                    log(""   "" + affectedClass + "" in "" + info.absoluteFile.getPath(), Project.MSG_DEBUG);
                }
            }
*/            
            // we now need to scan for out of date files. When we have the list
            // we go through and delete all class files which are affected by these files.
            outOfDateClasses = new Vector();
            for (int i=0; i<srcPathList.length; i++) {
                File srcDir = (File)project.resolveFile(srcPathList[i]);
                if (srcDir.exists()) {
                    DirectoryScanner ds = this.getDirectoryScanner(srcDir);
                    String[] files = ds.getIncludedFiles();
                    scanDir(srcDir, files);
                }
            }
            // we now have a complete list of classes which are out of date
            // We scan through the affected classes, deleting any affected classes.
            deleteAllAffectedFiles();
            log(""Duration = "" + (System.currentTimeMillis() - start));
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }
    /**
     * Scans the directory looking for source files that are newer than their class files.
     * The results are returned in the class variable compileList
     */
    protected void scanDir(File srcDir, String files[]) {
        long now = System.currentTimeMillis();
        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(srcDir, files[i]);
            if (files[i].endsWith("".java"")) {
                String filePath = srcFile.getPath();
                String className = filePath.substring(srcDir.getPath().length() + 1,
                                                      filePath.length() - "".java"".length());
                className = ClassFileUtils.convertSlashName(className);                                                      
                ClassFileInfo info = (ClassFileInfo)classFileInfoMap.get(className);
                if (info == null) {
                    // there was no class file. add this class to the list
                    outOfDateClasses.addElement(className);
                }
                else {
                    if (srcFile.lastModified() > info.absoluteFile.lastModified()) {
                        outOfDateClasses.addElement(className);
                    }
                }
            }
        }
    }
    /** 
     * Get the list of class files we are going to analyse.
     *
     * @param classLocations a path structure containing all the directories
     *                       where classes can be found.
     * @return a vector containing the classes to analyse.
     */
    private Vector getClassFiles(Path classLocations) {
        // break the classLocations into its components.        
        String[] classLocationsList = classLocations.list();            
        Vector classFileList = new Vector();
        for (int i = 0; i < classLocationsList.length; ++i) {
            File dir = new File(classLocationsList[i]);
            if (dir.isDirectory()) {
                addClassFiles(classFileList, dir, dir);
            }
        }
        return classFileList;
    }
    /** 
     * Add the list of class files from the given directory to the 
     * class file vector, including any subdirectories.
     *
     * @param classLocations a path structure containing all the directories
     *                       where classes can be found.
     * @return a vector containing the classes to analyse.
     */
    private void addClassFiles(Vector classFileList, File dir, File root) {
        String[] filesInDir = dir.list();
        if (filesInDir != null) {
            int length = filesInDir.length;
            for (int i = 0; i < length; ++i) {
                File file = new File(dir, filesInDir[i]);
                if (file.isDirectory()) {
                    addClassFiles(classFileList, file, root);
                }
                else if (file.getName().endsWith("".class"")) {
                    ClassFileInfo info = new ClassFileInfo();
                    info.absoluteFile = file;
                    info.relativeName = file.getPath().substring(root.getPath().length() + 1,
                                                                 file.getPath().length() - 6);
                    info.className = ClassFileUtils.convertSlashName(info.relativeName);                                                                 
                    classFileList.addElement(info);
                }
            } 
        } 
    }
    /**
     * Set the source dirs to find the source Java files.
     */
    public void setSrcdir(Path srcPath) {
        this.srcPath = srcPath;
    }
    /**
     * Set the destination directory where the compiled java files exist.
     */
    public void setDestDir(Path destPath) {
        this.destPath = destPath;
    }
    public void setCache(File cache) {
        this.cache = cache;
    }
    public void setClosure(boolean closure) {
        this.closure = closure;
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.DirectoryIterator,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
import java.util.*;
import java.io.*;
/**
 * An iterator which iterates through the contents of a java directory.
 * 
 * The iterator should be created with the directory at the root of the
 * Java namespace.
 * 
 * @author Conor MacNeill
 */
public class DirectoryIterator implements ClassFileIterator {
    /**
     * This is a stack of current iterators supporting the depth first
     * traversal of the directory tree.
     */
    private Stack enumStack;
    /**
     * The current directory iterator. As directories encounter lower level
     * directories, the current iterator is pushed onto the iterator
     * stack and a new iterator over the sub directory becomes the current
     * directory. This implements a depth first traversal of the directory namespace.
     */
    private Enumeration currentEnum;
    /**
     * The length of the root directory. This is used to remove the root directory
     * from full paths.
     */
    int rootLength;
    /**
     * Creates a directory iterator.
     * 
     * The directory iterator is created to scan the root directory. If the
     * changeInto flag is given, then the entries returned will be relative to this
     * directory and not the current directory.
     * 
     * @param rootDirectory the root if the directory namespace which is to be iterated over
     * @param changeInto if true then the returned entries will be relative to the rootDirectory
     * and not the current directory.
     * 
     * @throws IOException if there is a problem reading the directory information.
     */
    public DirectoryIterator(File rootDirectory, boolean changeInto) throws IOException {
        super();
        enumStack = new Stack();
        if (rootDirectory.isAbsolute() || changeInto) {
            rootLength = rootDirectory.getPath().length() + 1;
        } else {
            rootLength = 0;
        } 
        Vector filesInRoot = getDirectoryEntries(rootDirectory);
        currentEnum = filesInRoot.elements();
    }
    /**
     * Get a vector covering all the entries (files and subdirectories in a directory).
     * 
     * @param directory the directory to be scanned.
     * 
     * @return a vector containing File objects for each entry in the directory.
     */
    private Vector getDirectoryEntries(File directory) {
        Vector files = new Vector();
        // File[] filesInDir = directory.listFiles();
        String[] filesInDir = directory.list();
        if (filesInDir != null) {
            int length = filesInDir.length;
            for (int i = 0; i < length; ++i) {
                files.addElement(new File(directory, filesInDir[i]));
            } 
        } 
        return files;
    } 
    /**
     * Template method to allow subclasses to supply elements for the iteration.
     * 
     * The directory iterator maintains a stack of iterators covering each level
     * in the directory hierarchy. The current iterator covers the current directory
     * being scanned. If the next entry in that directory is a subdirectory, the current
     * iterator is pushed onto the stack and a new iterator is created for the
     * subdirectory. If the entry is a file, it is returned as the next element and the
     * iterator remains valid. If there are no more entries in the current directory,
     * the topmost iterator on the statck is popped off to become the current iterator.
     * 
     * @return the next ClassFile in the iteration.
     */
    public ClassFile getNextClassFile() {
        ClassFile nextElement = null;
        try {
            while (nextElement == null) {
                if (currentEnum.hasMoreElements()) {
                    File element = (File) currentEnum.nextElement();
                    if (element.isDirectory()) {
                        // push the current iterator onto the stack and then
                        // iterate through this directory.
                        enumStack.push(currentEnum);
                        Vector files = getDirectoryEntries(element);
                        currentEnum = files.elements();
                    } else {
                        // we have a file. create a stream for it
                        FileInputStream inFileStream = new FileInputStream(element);
                        if (element.getName().endsWith("".class"")) {
                            // create a data input stream from the jar input stream
                            ClassFile javaClass = new ClassFile();
                            javaClass.read(inFileStream);
                            nextElement = javaClass;
                        } 
                    } 
                } else {
                    // this iterator is exhausted. Can we pop one off the stack
                    if (enumStack.empty()) {
                        break;
                    } else {
                        currentEnum = (Enumeration) enumStack.pop();
                    } 
                } 
            } 
        } catch (IOException e) {
            nextElement = null;
        } 
        return nextElement;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.JarFileIterator,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend;
import java.util.zip.*;
import java.io.*;
/**
 * A class file iterator which iterates through the contents of a Java jar file.
 * 
 * @author Conor MacNeill
 */
public class JarFileIterator implements ClassFileIterator {
    private ZipInputStream jarStream;
    public JarFileIterator(InputStream stream) throws IOException {
        super();
        jarStream = new ZipInputStream(stream);
    }
    private byte[] getEntryBytes(InputStream stream) throws IOException {
        byte[]                buffer = new byte[8192];
        ByteArrayOutputStream baos = new ByteArrayOutputStream(2048);
        int                   n;
        while ((n = stream.read(buffer, 0, buffer.length)) != -1) {
            baos.write(buffer, 0, n);
        } 
        return baos.toByteArray();
    } 
    public ClassFile getNextClassFile() {
        ZipEntry         jarEntry;
        ClassFile nextElement = null;
        try {
            jarEntry = jarStream.getNextEntry();
            while (nextElement == null && jarEntry != null) {
                String entryName = jarEntry.getName();
                if (!jarEntry.isDirectory() && entryName.endsWith("".class"")) {
                        // create a data input stream from the jar input stream
                        ClassFile javaClass = new ClassFile();
                        javaClass.read(jarStream);
                        nextElement = javaClass;
                } else {
                    jarEntry = jarStream.getNextEntry();
                } 
            } 
        } catch (IOException e) {
            String message = e.getMessage();
            String text = e.getClass().getName();
            if (message != null) {
                text += "": "" + message;
            } 
            throw new RuntimeException(""Problem reading JAR file: "" + text);
        } 
        return nextElement;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ClassCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * The constant pool entry which stores class information.
 * 
 * @author Conor MacNeill
 */
public class ClassCPInfo extends ConstantPoolEntry {
    /**
     * The class' name. This will be only valid if the entry has been resolved
     * against the constant pool.
     */
    private String className;
    /**
     * The index into the constant pool where this class' name is stored. If the class
     * name is changed, this entry is invalid until this entry is connected to a constant
     * pool.
     */
    private int    index;
    /**
     * Constructor.
     * 
     * Sets the tag value for this entry to type Class
     */
    public ClassCPInfo() {
        super(CONSTANT_Class, 1);
    }
    /**
     * Read the entry from a stream.
     * 
     * @param cpStream the stream containing the constant pool entry to be read.
     * 
     * @exception IOException thrown if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        index = cpStream.readUnsignedShort();
        className = ""unresolved"";
    } 
    /**
     * Generate a string readable version of this entry
     */
    public String toString() {
        return ""Class Constant Pool Entry for "" + className + ""["" + index + ""]"";
    } 
    /**
     * Resolve this class info against the given constant pool.
     * 
     * @param constantPool the constant pool with which to resolve the class.
     */
    public void resolve(ConstantPool constantPool) {
        className = ((Utf8CPInfo) constantPool.getEntry(index)).getValue();
        super.resolve(constantPool);
    } 
    /**
     * Get the class name of this entry.
     * 
     * @return the class' name.
     */
    public String getClassName() {
        return className;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
/**
 * A Constant Pool entry which represents a constant value.
 * 
 * 
 * @author Conor MacNeill
 */
abstract public class ConstantCPInfo extends ConstantPoolEntry {
    /**
     * The entry's untyped value.
     * 
     * Each subclass interprets the constant value based on the subclass's type.
     * The value here must be compatible.
     */
    private Object value;
    /**
     * Initialise the constant entry.
     * 
     * @param tagValue the constant pool entry type to be used.
     * @param entries the number of constant pool entry slots occupied by this entry.
     */
    protected ConstantCPInfo(int tagValue, int entries) {
        super(tagValue, entries);
    }
    /**
     * Get the value of the constant.
     * 
     * @return the value of the constant (untyped).
     */
    public Object getValue() {
        return value;
    } 
    /**
     * Set the constant value.
     * 
     * @param newValue the new untyped value of this constant.
     */
    public void setValue(Object newValue) {
        value = newValue;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPool,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * The constant pool of a Java class.
 * 
 * The constant pool is a collection of constants used in a Java class file. It stores
 * strings, constant values, class names, method names, field names etc.
 * 
 * @see <a href=""http://java.sun.com/docs/books/vmspec/"">The Java Virtual Machine Specification</a>
 * 
 * @author Conor MacNeill
 */
public class ConstantPool {
    /**
     * The entries in the constant pool.
     */
    private Vector entries;
    /**
     * A Hashtable of UTF8 entries - used to get constant pool indexes of the UTF8 values quickly
     */
    private Hashtable utf8Indexes;
    /**
     * Initialise the constant pool.
     */
    public ConstantPool() {
        entries = new Vector();
        // The zero index is never present in the constant pool itself so
        // we add a null entry for it
        entries.addElement(null);
        utf8Indexes = new Hashtable();
    }
    /**
     * Read the constant pool from a class input stream.
     * 
     * @param classStream the DataInputStream of a class file.
     * 
     * @throws IOException if there is a problem reading the constant pool
     * from the stream
     */
    public void read(DataInputStream classStream) throws IOException {
        int numEntries = classStream.readUnsignedShort();
        for (int i = 1; i < numEntries; ) {
            ConstantPoolEntry nextEntry = ConstantPoolEntry.readEntry(classStream);
            i += nextEntry.getNumEntries();
            addEntry(nextEntry);
        } 
    } 
    /**
     * Get the size of the constant pool.
     */
    public int size() {
        return entries.size();
    }
    /**
     * Add an entry to the constant pool.
     * 
     * @param entry the new entry to be added to the constant pool.
     * 
     * @return the index into the constant pool at which the entry is stored.
     */
    public int addEntry(ConstantPoolEntry entry) {
        int index = entries.size();
        entries.addElement(entry);
        int numSlots = entry.getNumEntries();
        // add null entries for any additional slots required.
        for (int j = 0; j < numSlots - 1; ++j) {
            entries.addElement(null);
        } 
        if (entry instanceof Utf8CPInfo) {
            Utf8CPInfo utf8Info = (Utf8CPInfo) entry;
            utf8Indexes.put(utf8Info.getValue(), new Integer(index));
        } 
        return index;
    } 
    /**
     * Resolve the entries in the constant pool.
     * 
     * Resolution of the constant pool involves transforming indexes to
     * other constant pool entries into the actual data for that entry.
     */
    public void resolve() {
        for (Enumeration i = entries.elements(); i.hasMoreElements(); ) {
            ConstantPoolEntry poolInfo = (ConstantPoolEntry) i.nextElement();
            if (poolInfo != null &&!poolInfo.isResolved()) {
                poolInfo.resolve(this);
            } 
        } 
    } 
    /**
     * Get an constant pool entry at a particular index.
     * 
     * @param index the index into the constant pool.
     * 
     * @return the constant pool entry at that index.
     */
    public ConstantPoolEntry getEntry(int index) {
        return (ConstantPoolEntry) entries.elementAt(index);
    } 
    /**
     * Get the index of a given UTF8 constant pool entry.
     * 
     * @param value the string value of the UTF8 entry.
     * 
     * @return the index at which the given string occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getUTF8Entry(String value) {
        int     index = -1;
        Integer indexInteger = (Integer) utf8Indexes.get(value);
        if (indexInteger != null) {
            index = indexInteger.intValue();
        } 
        return index;
    } 
    /**
     * Get the index of a given CONSTANT_Class entry in the constant pool.
     * 
     * @param className the name of the class for which the class entry index is required.
     * 
     * @return the index at which the given class entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getClassEntry(String className) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof ClassCPInfo) {
                ClassCPInfo classinfo = (ClassCPInfo) element;
                if (classinfo.getClassName().equals(className)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Get the index of a given constant value entry in the constant pool.
     * 
     * @param constantValue the constant value for which the index is required.
     * 
     * @return the index at which the given value entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getConstantEntry(Object constantValue) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof ConstantCPInfo) {
                ConstantCPInfo constantEntry = (ConstantCPInfo) element;
                if (constantEntry.getValue().equals(constantValue)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Get the index of a given CONSTANT_MethodRef entry in the constant pool.
     * 
     * @param methodClassName the name of the class which contains the method
     * being referenced.
     * @param methodName the name of the method being referenced.
     * @param methodType the type descriptor of the metho dbeing referenced.
     * 
     * @return the index at which the given method ref entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getMethodRefEntry(String methodClassName, String methodName, String methodType) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof MethodRefCPInfo) {
                MethodRefCPInfo methodRefEntry = (MethodRefCPInfo) element;
                if (methodRefEntry.getMethodClassName().equals(methodClassName) 
                        && methodRefEntry.getMethodName().equals(methodName) && methodRefEntry.getMethodType().equals(methodType)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Get the index of a given CONSTANT_InterfaceMethodRef entry in the constant pool.
     * 
     * @param interfaceMethodClassName the name of the interface which contains the method
     * being referenced.
     * @param interfaceMethodName the name of the method being referenced.
     * @param interfaceMethodType the type descriptor of the metho dbeing referenced.
     * 
     * @return the index at which the given method ref entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getInterfaceMethodRefEntry(String interfaceMethodClassName, String interfaceMethodName, String interfaceMethodType) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof InterfaceMethodRefCPInfo) {
                InterfaceMethodRefCPInfo interfaceMethodRefEntry = (InterfaceMethodRefCPInfo) element;
                if (interfaceMethodRefEntry.getInterfaceMethodClassName().equals(interfaceMethodClassName) 
                        && interfaceMethodRefEntry.getInterfaceMethodName().equals(interfaceMethodName) 
                        && interfaceMethodRefEntry.getInterfaceMethodType().equals(interfaceMethodType)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Get the index of a given CONSTANT_FieldRef entry in the constant pool.
     * 
     * @param fieldClassName the name of the class which contains the field
     * being referenced.
     * @param fieldName the name of the field being referenced.
     * @param fieldType the type descriptor of the field being referenced.
     * 
     * @return the index at which the given field ref entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getFieldRefEntry(String fieldClassName, String fieldName, String fieldType) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof FieldRefCPInfo) {
                FieldRefCPInfo fieldRefEntry = (FieldRefCPInfo) element;
                if (fieldRefEntry.getFieldClassName().equals(fieldClassName) && fieldRefEntry.getFieldName().equals(fieldName) 
                        && fieldRefEntry.getFieldType().equals(fieldType)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Get the index of a given CONSTANT_NameAndType entry in the constant pool.
     * 
     * @param name the name
     * @param type the type
     * 
     * @return the index at which the given NameAndType entry occurs in the
     * constant pool or -1 if the value does not occur.
     */
    public int getNameAndTypeEntry(String name, String type) {
        int index = -1;
        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);
            if (element instanceof NameAndTypeCPInfo) {
                NameAndTypeCPInfo nameAndTypeEntry = (NameAndTypeCPInfo) element;
                if (nameAndTypeEntry.getName().equals(name) && nameAndTypeEntry.getType().equals(type)) {
                    index = i;
                } 
            } 
        } 
        return index;
    } 
    /**
     * Dump the constant pool to a string.
     * 
     * @return the constant pool entries as strings
     */
    public String toString() {
        StringBuffer sb = new StringBuffer(""\n"");
        int          size = entries.size();
        for (int i = 0; i < size; ++i) {
            sb.append(""["" + i + ""] = "" + getEntry(i) + ""\n"");
        } 
        return sb.toString();
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPoolEntry,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * An entry in the constant pool.
 * 
 * This class contains a represenation of the constant pool entries. It is
 * an abstract base class for all the different forms of constant pool entry.
 * 
 * @author Conor MacNeill
 * @see ConstantPool
 */
public abstract class ConstantPoolEntry {
    /**
     * Tag value for UTF8 entries.
     */
    static public final int CONSTANT_Utf8 = 1;
    /**
     * Tag value for Integer entries.
     */
    static public final int CONSTANT_Integer = 3;
    /**
     * Tag value for Float entries.
     */
    static public final int CONSTANT_Float = 4;
    /**
     * Tag value for Long entries.
     */
    static public final int CONSTANT_Long = 5;
    /**
     * Tag value for Double entries.
     */
    static public final int CONSTANT_Double = 6;
    /**
     * Tag value for Class entries.
     */
    static public final int CONSTANT_Class = 7;
    /**
     * Tag value for String entries.
     */
    static public final int CONSTANT_String = 8;
    /**
     * Tag value for Field Reference entries.
     */
    static public final int CONSTANT_FieldRef = 9;
    /**
     * Tag value for Method Reference entries.
     */
    static public final int CONSTANT_MethodRef = 10;
    /**
     * Tag value for Interface Method Reference entries.
     */
    static public final int CONSTANT_InterfaceMethodRef = 11;
    /**
     * Tag value for Name and Type entries.
     */
    static public final int CONSTANT_NameAndType = 12;
    /**
     * This entry's tag which identifies the type of this constant pool entry.
     */
    private int             tag;
    /**
     * The number of slots in the constant pool, occupied by this entry.
     */
    private int             numEntries;
    /**
     * A flag which indiciates if this entry has been resolved or not.
     */
    private boolean         resolved;
    /**
     * Initialse the constant pool entry.
     * 
     * @param tagValue the tag value which identifies which type of constant pool entry this is.
     * @param entries the number of constant pool entry slots this entry occupies.
     */
    public ConstantPoolEntry(int tagValue, int entries) {
        tag = tagValue;
        numEntries = entries;
        resolved = false;
    }
    /**
     * Read a constant pool entry from a stream.
     * 
     * This is a factory method which reads a constant pool entry
     * form a stream and returns the appropriate subclass for the
     * entry.
     * 
     * @param cpStream the stream from which the constant pool entry is to be read.
     * 
     * @returns the appropriate ConstantPoolEntry subclass representing the
     * constant pool entry from the stream.
     * 
     * @throws IOExcception if there is a problem reading the entry from the stream.
     */
    static public ConstantPoolEntry readEntry(DataInputStream cpStream) throws IOException {
        ConstantPoolEntry cpInfo = null;
        int               cpTag = cpStream.readUnsignedByte();
        switch (cpTag) {
        case CONSTANT_Utf8:
            cpInfo = new Utf8CPInfo();
            break;
        case CONSTANT_Integer:
            cpInfo = new IntegerCPInfo();
            break;
        case CONSTANT_Float:
            cpInfo = new FloatCPInfo();
            break;
        case CONSTANT_Long:
            cpInfo = new LongCPInfo();
            break;
        case CONSTANT_Double:
            cpInfo = new DoubleCPInfo();
            break;
        case CONSTANT_Class:
            cpInfo = new ClassCPInfo();
            break;
        case CONSTANT_String:
            cpInfo = new StringCPInfo();
            break;
        case CONSTANT_FieldRef:
            cpInfo = new FieldRefCPInfo();
            break;
        case CONSTANT_MethodRef:
            cpInfo = new MethodRefCPInfo();
            break;
        case CONSTANT_InterfaceMethodRef:
            cpInfo = new InterfaceMethodRefCPInfo();
            break;
        case CONSTANT_NameAndType:
            cpInfo = new NameAndTypeCPInfo();
            break;
        default:
            throw new ClassFormatError(""Invalid Constant Pool entry Type "" + cpTag);
        }
        cpInfo.read(cpStream);
        return cpInfo;
    } 
    /**
     * Indicates whether this entry has been resolved.
     * 
     * In general a constant pool entry can reference another constant
     * pool entry by its index value. Resolution involves replacing this
     * index value with the constant pool entry at that index.
     * 
     * @return true if this entry has been resolved.
     */
    public boolean isResolved() {
        return resolved;
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        resolved = true;
    } 
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public abstract void read(DataInputStream cpStream) throws IOException;
    /**
     * Get the Entry's type tag.
     * 
     * @return The Tag value of this entry
     */
    public int getTag() {
        return tag;
    } 
    /**
     * Get the number of Constant Pool Entry slots within the constant pool occupied by this entry.
     * 
     * @return the number of slots used.
     * 
     */
    public final int getNumEntries() {
        return numEntries;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.DoubleCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
/**
 * The constant pool entry subclass used to represent double constant values.
 * 
 * @author Conor MacNeill
 */
public class DoubleCPInfo extends ConstantCPInfo {
    public DoubleCPInfo() {
        super(CONSTANT_Double, 2);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Double(cpStream.readDouble()));
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""Double Constant Pool Entry: "" + getValue();
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.FieldRefCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A FieldRef CP Info
 * 
 * @author Conor MacNeill
 */
public class FieldRefCPInfo extends ConstantPoolEntry {
    private String fieldClassName;
    private String fieldName;
    private String fieldType;
    private int    classIndex;
    private int    nameAndTypeIndex;
    /**
     * Constructor.
     * 
     */
    public FieldRefCPInfo() {
        super(CONSTANT_FieldRef, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo fieldClass = (ClassCPInfo) constantPool.getEntry(classIndex);
        fieldClass.resolve(constantPool);
        fieldClassName = fieldClass.getClassName();
        NameAndTypeCPInfo nt = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);
        nt.resolve(constantPool);
        fieldName = nt.getName();
        fieldType = nt.getType();
        super.resolve(constantPool);
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        String value;
        if (isResolved()) {
            value = ""Field : Class = "" + fieldClassName + "", name = "" + fieldName + "", type = "" + fieldType;
        } else {
            value = ""Field : Class index = "" + classIndex + "", name and type index = "" + nameAndTypeIndex;
        } 
        return value;
    } 
    public String getFieldClassName() {
        return fieldClassName;
    } 
    public String getFieldName() {
        return fieldName;
    } 
    public String getFieldType() {
        return fieldType;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.FloatCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
/**
 * A Float CP Info
 * 
 * @author Conor MacNeill
 */
public class FloatCPInfo extends ConstantCPInfo {
    /**
     * Constructor.
     * 
     */
    public FloatCPInfo() {
        super(CONSTANT_Float, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Float(cpStream.readFloat()));
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""Float Constant Pool Entry: "" + getValue();
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.IntegerCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
/**
 * An Integer CP Info
 * 
 * @author Conor MacNeill
 */
public class IntegerCPInfo extends ConstantCPInfo {
    /**
     * Constructor.
     * 
     */
    public IntegerCPInfo() {
        super(CONSTANT_Integer, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Integer(cpStream.readInt()));
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""Integer Constant Pool Entry: "" + getValue();
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.InterfaceMethodRefCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A InterfaceMethodRef CP Info
 * 
 * 
 * @author Conor MacNeill
 */
public class InterfaceMethodRefCPInfo extends ConstantPoolEntry {
    private String interfaceMethodClassName;
    private String interfaceMethodName;
    private String interfaceMethodType;
    private int    classIndex;
    private int    nameAndTypeIndex;
    /**
     * Constructor.
     * 
     */
    public InterfaceMethodRefCPInfo() {
        super(CONSTANT_InterfaceMethodRef, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo interfaceMethodClass = (ClassCPInfo) constantPool.getEntry(classIndex);
        interfaceMethodClass.resolve(constantPool);
        interfaceMethodClassName = interfaceMethodClass.getClassName();
        NameAndTypeCPInfo nt = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);
        nt.resolve(constantPool);
        interfaceMethodName = nt.getName();
        interfaceMethodType = nt.getType();
        super.resolve(constantPool);
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        String value;
        if (isResolved()) {
            value = ""InterfaceMethod : Class = "" + interfaceMethodClassName + "", name = "" + interfaceMethodName + "", type = "" 
                    + interfaceMethodType;
        } else {
            value = ""InterfaceMethod : Class index = "" + classIndex + "", name and type index = "" + nameAndTypeIndex;
        } 
        return value;
    } 
    public String getInterfaceMethodClassName() {
        return interfaceMethodClassName;
    } 
    public String getInterfaceMethodName() {
        return interfaceMethodName;
    } 
    public String getInterfaceMethodType() {
        return interfaceMethodType;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.LongCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
/**
 * A Long CP Info
 * 
 * @author Conor MacNeill
 */
public class LongCPInfo extends ConstantCPInfo {
    /**
     * Constructor.
     * 
     */
    public LongCPInfo() {
        super(CONSTANT_Long, 2);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Long(cpStream.readLong()));
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""Long Constant Pool Entry: "" + getValue();
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.MethodRefCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A MethodRef CP Info
 * 
 * @author Conor MacNeill
 */
public class MethodRefCPInfo extends ConstantPoolEntry {
    private String methodClassName;
    private String methodName;
    private String methodType;
    private int    classIndex;
    private int    nameAndTypeIndex;
    /**
     * Constructor.
     * 
     */
    public MethodRefCPInfo() {
        super(CONSTANT_MethodRef, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        String value;
        if (isResolved()) {
            value = ""Method : Class = "" + methodClassName + "", name = "" + methodName + "", type = "" + methodType;
        } else {
            value = ""Method : Class index = "" + classIndex + "", name and type index = "" + nameAndTypeIndex;
        } 
        return value;
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo methodClass = (ClassCPInfo) constantPool.getEntry(classIndex);
        methodClass.resolve(constantPool);
        methodClassName = methodClass.getClassName();
        NameAndTypeCPInfo nt = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);
        nt.resolve(constantPool);
        methodName = nt.getName();
        methodType = nt.getType();
        super.resolve(constantPool);
    } 
    public String getMethodClassName() {
        return methodClassName;
    } 
    public String getMethodName() {
        return methodName;
    } 
    public String getMethodType() {
        return methodType;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.NameAndTypeCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A NameAndType CP Info
 * 
 * @author Conor MacNeill
 */
public class NameAndTypeCPInfo extends ConstantPoolEntry {
    /**
     * Constructor.
     * 
     */
    public NameAndTypeCPInfo() {
        super(CONSTANT_NameAndType, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        nameIndex = cpStream.readUnsignedShort();
        descriptorIndex = cpStream.readUnsignedShort();
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        String value;
        if (isResolved()) {
            value = ""Name = "" + name + "", type = "" + type;
        } else {
            value = ""Name index = "" + nameIndex + "", descriptor index = "" + descriptorIndex;
        } 
        return value;
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        name = ((Utf8CPInfo) constantPool.getEntry(nameIndex)).getValue();
        type = ((Utf8CPInfo) constantPool.getEntry(descriptorIndex)).getValue();
        super.resolve(constantPool);
    } 
    public String getName() {
        return name;
    } 
    public String getType() {
        return type;
    } 
    private String name;
    private String type;
    private int    nameIndex;
    private int    descriptorIndex;
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.StringCPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A String Constant Pool Entry.
 * 
 * The String info contains an index into the constant pool where
 * a UTF8 string is stored.
 * 
 * @author Conor MacNeill
 */
public class StringCPInfo extends ConstantCPInfo {
    /**
     * Constructor.
     * 
     */
    public StringCPInfo() {
        super(CONSTANT_String, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        index = cpStream.readUnsignedShort();
        setValue(""unresolved"");
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""String Constant Pool Entry for "" + getValue() + ""["" + index + ""]"";
    } 
    /**
     * Resolve this constant pool entry with respect to its dependents in
     * the constant pool.
     * 
     * @param constantPool the constant pool of which this entry is a member
     * and against which this entry is to be resolved.
     */
    public void resolve(ConstantPool constantPool) {
        setValue(((Utf8CPInfo) constantPool.getEntry(index)).getValue());
        super.resolve(constantPool);
    } 
    private int index;
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.Utf8CPInfo,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
import java.io.*;
import java.util.*;
/**
 * A UTF8 Constant Pool Entry.
 * 
 * @author Conor MacNeill
 */
public class Utf8CPInfo extends ConstantPoolEntry {
    private String value;
    /**
     * Constructor.
     * 
     */
    public Utf8CPInfo() {
        super(CONSTANT_Utf8, 1);
    }
    /**
     * read a constant pool entry from a class stream.
     * 
     * @param cpStream the DataInputStream which contains the constant pool entry to be read.
     * 
     * @throws IOException if there is a problem reading the entry from the stream.
     */
    public void read(DataInputStream cpStream) throws IOException {
        value = cpStream.readUTF();
    } 
    /**
     * Print a readable version of the constant pool entry.
     * 
     * @return the string representation of this constant pool entry.
     */
    public String toString() {
        return ""UTF8 Value = "" + value;
    } 
    public String getValue() {
        return value;
    } 
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.CSharp,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/* build notes
    -The reference CD to listen to while editing this file is 
        nap: Underworld  - Everything, Everything
    -variable naming policy from Fowler's refactoring book.
    -tested against the PDC pre-beta of csc.exe; future versions will 
     inevitably change things
*/
// ====================================================================
// place in the optional ant tasks package
// but in its own dotnet group
// ====================================================================
package org.apache.tools.ant.taskdefs.optional.dotnet;
// ====================================================================
// imports
// ====================================================================
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import java.io.*;
// ====================================================================
/**
This task compiles CSharp source into executables or modules.
The task will only work on win2K until other platforms support csc.exe or 
an equivalent. CSC.exe must be on the execute path too.
<p>
All parameters are optional: &lt;csc/&gt; should suffice to produce a debug
build of all *.cs files. References to external files do require explicit 
enumeration, so are one of the first attributes to consider adding. 
<p>
The task is a directory based task, so attributes like <b>includes=""*.cs""</b> and 
<b>excludes=""broken.cs""</b> can be used to control the files pulled in. By default, 
all *.cs files from the project folder down are included in the command. 
When this happens the output file -if not specified-
is taken as the first file in the list, which may be somewhat hard to control.
Specifying the output file with <b>'outfile'</b> seems prudent. 
<p>
<p>
TODO
<ol>
    <li>is incremental build still broken in beta-1?
    <li>is Win32Icon broken?
    <li>all the missing options
</ol>
<p>
History
    <Table>
    <tr><td>0.3</td>
        <td> Beta 1 edition </td>
        <td> To avoid having to remember which assemblies to include, 
        the task automatically refers to the main dotnet libraries in Beta1.
    </tr>    <tr><td>0.2</td>
        <td> Slightly different</td>
        <td> Split command execution to a separate class; 
    </tr>
    <tr><td>0.1</td>
        <td> ""I can't believe it's so rudimentary""</td>
        <td>  First pass; minimal builds only support; 
    </tr>
    </table>
@version 0.3
@author Steve Loughran steve_l@iseran.com
 */
public class CSharp 
    extends org.apache.tools.ant.taskdefs.MatchingTask {
    /** constructor inits everything and set up the search pattern
    */
    public CSharp () {
        Clear();
        setIncludes(csc_file_pattern);
    }
    /** name of the executable. the .exe suffix is deliberately not included 
     * in anticipation of the unix version
     */
    protected static final String csc_exe_name=""csc"";
    /** what is the file extension we search on?
     */
    protected static final String csc_file_ext=""cs"";
    /** derive the search pattern from the extension 
     */
    protected static final String csc_file_pattern=""**/*.""+csc_file_ext;
    /** list of reference classes. (pretty much a classpath equivalent)
     */
    protected  String _references;
    /**
     *  Set the reference list to be used for this compilation. 
     *
     * @param  s  The new References value 
     */
    public void setReferences(String s) {
        _references=s;
    }
    /**
     *  get the reference string or null for no argument needed 
     *
     * @return    The References Parameter to CSC 
     */
    protected String getReferencesParameter() {
        //bail on no references
        if (notEmpty(_references)) 
            return ""/reference:""+_references;
        else
            return null;
    }
    /**
     using the path approach didnt work as it could not handle the implicit
     execution path. Perhaps that could be extracted from the runtime and then
     the path approach would be viable
    */
    protected  Path _referenceFiles;
    /**
     * add another path to the reference file path list
     * @param path another path to append
     */
    public void setReferenceFiles(Path path) {
        //demand create pathlist
        if(_referenceFiles==null)
                _referenceFiles=new Path(this.project);
        _referenceFiles.append(path);
    }
    /**
     turn the path list into a list of files and a /references argument
     @return null or a string of references.
    */ 
    protected String getReferenceFilesParameter() {
        //bail on no references
        if (_references==null)
            return null;
        //iterate through the ref list & generate an entry for each
        //or just rely on the fact that the toString operator does this, but
        //noting that the separator is ';' on windows, ':' on unix
        String refpath=_references.toString();
        //bail on no references listed
        if (refpath.length()==0)
            return null;
        StringBuffer s=new StringBuffer(""/reference:"");
        s.append(refpath);
        return new String(s);
    }   
    /** 
     * C# is really dumb in how it handles inclusion. You have to list
     * every 'assembly' -read DLL that is imported. So already you are
     * making a platform assumption -shared libraries have a .dll extension
     * and the poor developer has to know every library which is included
     * why the compiler cant find classes on the path or in a directory,
     * is a mystery.
     *
     * To reduce the need to be explicit, here is a long list of 
     * the core libraries used in Beta-1 of .NET
     * ommitting the blatantly non portable (MS.win32.interop)
     * and the .designer libraries. (ripping out Com was tempting)
     * Casing is chosen to match that of the file system <i>exactly</i>
     * so may work on a unix box too. 
     */
    protected static final String DEFAULT_REFERENCE_LIST
        =""System.dll;System.Drawing.dll;System.Data.dll;""+
         ""System.Diagnostics.dll;""+
         ""System.DirectoryServices.dll;""+
         ""System.IO.dll;""+
         ""System.Management.dll;""+
         ""System.Messaging.dll;""+
         ""System.Net.dll;""+
         ""System.Runtime.Remoting.dll;""+
         ""System.Runtime.Serialization.Formatters.Soap.dll;""+
         ""System.Security.dll;""+
         ""System.ServiceProcess.dll;""+
         ""System.Text.RegularExpressions.dll;""+
         ""System.Timers.dll;""+
         ""System.Web.dll;""+
         ""System.Web.Services.dll;""+
         ""System.WinForms.dll;""+
         ""System.XML.dll;""+
         ""System.XML.Serialization.dll;""+
         ""Microsoft.ComServices.dll;"";
    /** 
     * get default reference list
     * @return null or a string of references.
    */ 
    protected String getDefaultReferenceParameter() {
        if(_includeDefaultReferences) {
            StringBuffer s=new StringBuffer(""/reference:"");
            s.append(DEFAULT_REFERENCE_LIST);
            return new String(s);
        }
        else
            return null;            
    }
     /** flag to enable automatic reference inclusion
      *
     */
     protected boolean _includeDefaultReferences;
    /** set the automatic reference inclusion flag on or off
     *  this flag controls the string of references and the 
     *  /nostdlib option in CSC
    @param f on/off flag
    */
    public void setIncludeDefaultReferences(boolean f) {
        _includeDefaultReferences=f;
    }
    /** query the optimise flag
    @return true if optimise is turned on
     */
    public boolean getIncludeDefaultReferences() {
        return _includeDefaultReferences;
    }
    /**
     *  get the include default references flag or null for no argument needed 
     *
     * @return    The Parameter to CSC 
     */
    protected String getIncludeDefaultReferencesParameter() {
        return ""/nostdlib""+(_includeDefaultReferences?""-"":""+"");
    }    
    /** optimise flag
     */
    protected boolean _optimize;
    /** set the optimise flag on or off
    @param f on/off flag
    */
    public void setOptimize(boolean f) {
        _optimize=f;
    }
    /** query the optimise flag
    @return true if optimise is turned on
     */
    public boolean getOptimize() {
        return _optimize;
    }
    /**
     *  get the optimise flag or null for no argument needed 
     *
     * @return    The Optimize Parameter to CSC 
     */
    protected String getOptimizeParameter() {
        return ""/optimize""+(_optimize?""+"":""-"");
    }   
    /** incremental build flag */
    protected boolean _incremental;
    /** set the incremental compilation flag on or off
     * @param f on/off flag
     */
    public void setIncremental(boolean f){
        _incremental=f;
    }
    /** query the incrementalflag
     * @return true iff incremental compilation is turned on
     */
    public boolean getIncremental() {
        return _incremental;
    }
    /**
     *  get the incremental build argument
     *
     * @return    The Incremental Parameter to CSC 
     */
    protected String getIncrementalParameter() {
        return ""/incremental""+(_incremental?""+"":""-"");
    }   
    /** debug flag. Controls generation of debug information. 
     */
    protected boolean _debug;
    /** set the debug flag on or off
     * @param f on/off flag
     */
    public void setDebug(boolean f) {
        _debug=f;
    }
    /** query the debug flag
     * @return true if debug is turned on
     */
    public boolean getDebug() {
        return _debug;
    }
    /**
     *  get the debug switch argument  
     *
     * @return    The Debug Parameter to CSC 
     */
    protected String getDebugParameter() {
        return ""/debug""+(_debug?""+"":""-"");
    }   
    /** output XML documentation flag
    */  
    protected File _docFile;
    /** file for generated XML documentation
     * @param f output file
     */
    public void setDocFile(String f) {
        _docFile=project.resolveFile(f);
    }
    /** get the argument or null for no argument needed
     * @return    The DocFile Parameter to CSC 
     */
    protected String getDocFileParameter() {
        if (_docFile!=null)
            return ""/doc:""+_docFile.toString();
        else
            return null;
    }   
    /** warning level: 0-4, with 4 being most verbose
    */
    private int _warnLevel;
    /** set warn level (no range checking)
     * @param warnLevel warn level -see .net docs for valid range (probably 0-4)
    */
    public void setWarnLevel(int warnLevel)
        {this._warnLevel=warnLevel;}
    /** query warn level
     * @return current value
    */
    public int getWarnLevel()
        {return _warnLevel;}
    /**
     *  get the warn level switch 
     *
     * @return    The WarnLevel Parameter to CSC 
     */
    protected String getWarnLevelParameter() {
        return ""/warn:""+_warnLevel;
    }   
    /** enable unsafe code flag. Clearly set to false by default
     */
    protected boolean _unsafe;
    /**
     *  Sets the Unsafe attribute 
     *
     * @param  unsafe  The new Unsafe value 
     */
    public void setUnsafe(boolean unsafe)
        {this._unsafe=unsafe;}
    /**
     *  query the Unsafe attribute 
     *
     * @return    The Unsafe value 
     */
    public boolean getUnsafe()
        {return this._unsafe;}
    /** get the argument or null for no argument needed
     * @return    The Unsafe Parameter to CSC 
    */
    protected String getUnsafeParameter(){
        return _unsafe?""/unsafe"":null;
    }   
    /** main class (or null for automatic choice)
     */
    protected String _mainClass;
    /**
     *  Sets the MainClass attribute
     *
     * @param  mainClass  The new MainClass value 
     */
    public void setMainClass(String mainClass)
        {this._mainClass=mainClass;}
    /**
     *  Gets the MainClass attribute 
     *
     * @return    The MainClass value 
     */
    public String getMainClass()
        {return this._mainClass;}
    /**
     *  get the /main argument or null for no argument needed 
     *
     * @return    The MainClass Parameter to CSC 
     */
    protected String getMainClassParameter(){
        if (_mainClass!=null && _mainClass.length()!=0)
            return ""/main:""+_mainClass;
        else
            return null;
    } 
    /** any extra command options?
     */
    protected String _extraOptions;
    /**
     *  Sets the ExtraOptions attribute
     *
     * @param  extraOptions  The new ExtraOptions value 
     */
    public void setExtraOptions(String extraOptions)
        {this._extraOptions=extraOptions;}
    /**
     *  Gets the ExtraOptions attribute 
     *
     * @return    The ExtraOptions value 
     */
    public String getExtraOptions()
        {return this._extraOptions;}
    /**
     *  get any extra options or null for no argument needed 
     *
     * @return    The ExtraOptions Parameter to CSC 
     */
    protected String getExtraOptionsParameter() {
        if (_extraOptions!=null && _extraOptions.length()!=0)
            return _extraOptions;
        else
            return null;
    } 
    /** source directory upon which the search pattern is applied
     */
    private File _srcDir;
    /**
     * Set the source dir to find the files to be compiled
     * @param  srcDirName  The new SrcDir value 
     */
    public void setSrcDir(String srcDirName){
        _srcDir = project.resolveFile(srcDirName);
    }
    /** destination directory (null means use the source directory)
    * NB: this is currently not used 
    */
    private File _destDir;
    /**
     * Set the destination dir to find the files to be compiled
     * @param  dirName  The new DestDir value 
     */
    public void setDestDir(String dirName) {
        _destDir = project.resolveFile(dirName);
    }
    /** type of target. Should be one of exe|library|module|winexe|(null)
    default is exe; the actual value (if not null) is fed to the command line.
    <br>See /target
     */
    protected String _targetType;
    /** define the target
     * @param  targetType          The new TargetType value 
     * @exception  BuildException  if target is not one of exe|library|module|winexe 
     */
    public void setTargetType(String targetType)
        throws  BuildException {
        targetType=targetType.toLowerCase();
        if(targetType.equals(""exe"") || targetType.equals(""library"") ||
            targetType.equals(""module"") ||targetType.equals(""winexe"") ) {
            _targetType=targetType; 
        }
        else 
            throw new BuildException(""targetType "" +targetType+"" is not a valid type"");
    }
    /**
     *  Gets the TargetType attribute  
     *
     * @return    The TargetType value 
     */
    public String getTargetType() { 
            return _targetType;
    }   
    /**
     *  get the argument or null for no argument needed 
     *
     * @return    The TargetType Parameter to CSC 
     */
    protected String getTargetTypeParameter() {
        if (notEmpty(_targetType)) 
            return ""/target:""+_targetType;
        else
            return null;
    }   
    /** icon for incorporation into apps
     */     
    protected File _win32icon;  
    /**
     * Set the win32 icon 
     * @param fileName path to the file. Can be relative, absolute, whatever.
     */
    public void setWin32Icon(String fileName) {
        _win32icon = project.resolveFile(fileName);
    }
    /**
     *  get the argument or null for no argument needed 
     *
     * @return    The Win32Icon Parameter to CSC 
     */
    protected String getWin32IconParameter() {
        if (_win32icon!=null)
            return ""/win32icon:""+_win32icon.toString();
        else
            return null;
    }
    /** defines list
    * something like 'RELEASE;WIN32;NO_SANITY_CHECKS;;SOMETHING_ELSE'
    */
    String _definitions;
    /**
     * Set the definitions
     * @param list of definitions split by ; or , or even :
     */
    public void setDefinitions(String params) {
        _definitions=params;
    }
    /**
    *  get the argument or null for no argument needed 
    *
    * @return    The Definitions Parameter to CSC 
    */
    protected String getDefinitionsParameter() {
        if (notEmpty(_definitions))
            return ""/define:"" + _definitions;
        else
            return null;
    }
    /** list of extra modules to refer to 
     *
    */    
    String _additionalModules;
    /**
     * Set the definitions
     * @param list of definitions split by ; or , or even :
     */
    public void setAdditionalModules(String params) {
        _additionalModules=params;
    }
    /** get the argument or null for no argument needed
    * @return    The AdditionalModules Parameter to CSC 
     */
    protected String getAdditionalModulesParameter() {
        if (notEmpty(_additionalModules)) 
            return ""/addmodule:"" + _additionalModules;
        else 
            return null;
    }
    /** output file. If not supplied this is derived from the
     *  source file
     */    
    protected String _outputFile;
    /**
     * Set the definitions
     * @param list of definitions split by ; or , or even :
     */
    public void setOutputFile(String params) {
        _outputFile=params;
    }
    /** get the argument or null for no argument needed
    * @return    The OutputFile Parameter to CSC 
    */
    protected String getOutputFileParameter() {
        if (notEmpty(_outputFile)) {
            File f=project.resolveFile(_outputFile);
            return ""/out:""+f.toString();
        }
        else            
            return null;
    }
    /** flag to control action on execution trouble
    */
    protected boolean _failOnError;
    /**set fail on error flag
    * @param  b  The new FailOnError value 
    */
    public void setFailOnError(boolean b){
        _failOnError=b;
    }
    /** query fail on error flag
     * @return    The FailFailOnError value 
    */
    public boolean getFailFailOnError() {
            return _failOnError;
    }
    /** reset all contents. 
    */
    public void Clear() {
        _targetType=null;
        _win32icon=null;
        _srcDir=null;
        _destDir=null;
        _mainClass=null;
        _unsafe=false;
        _warnLevel=3;
        _docFile = null;
        _incremental=false;
        _optimize=false;
        _debug=true;
        _references=null;
        _failOnError=true;
        _definitions=null;
        _additionalModules=null;
        _includeDefaultReferences=true;
        _extraOptions=null;
    }
    /**
     *  test for a string containing something useful 
     *
     * @param  s  string in 
     * @return    true if the argument is not null or empty 
     */
    protected boolean notEmpty(String s) {
        return s != null && s.length() != 0;
    }
    /** do the work by building the command line and then calling it
    */
    public void execute() 
        throws BuildException {
        if (_srcDir == null)
            _srcDir=project.resolveFile(""."");
        NetCommand command=new NetCommand(this,""CSC"",csc_exe_name);
        command.setFailOnError(getFailFailOnError());
        //DEBUG helper
        command.setTraceCommandLine(true);
        //fill in args
        command.addArgument(""/nologo"");
        command.addArgument(getAdditionalModulesParameter());
        command.addArgument(getDefinitionsParameter());
        command.addArgument(getDebugParameter());
        command.addArgument(getDocFileParameter());
        command.addArgument(getIncrementalParameter());
        command.addArgument(getMainClassParameter());
        command.addArgument(getOptimizeParameter());
        command.addArgument(getReferencesParameter());
        command.addArgument(getTargetTypeParameter());
        command.addArgument(getUnsafeParameter());
        command.addArgument(getWarnLevelParameter());
        command.addArgument(getWin32IconParameter());
        command.addArgument(getOutputFileParameter());   
        command.addArgument(getIncludeDefaultReferencesParameter());
        command.addArgument(getDefaultReferenceParameter());
        command.addArgument(getExtraOptionsParameter());
        //get dependencies list. 
        DirectoryScanner scanner = super.getDirectoryScanner(_srcDir);
        String[] dependencies = scanner.getIncludedFiles();
        log(""compiling ""+dependencies.length+"" file""+((dependencies.length==1)?"""":""s""));
        String baseDir=scanner.getBasedir().toString();
        //add to the command
        for (int i = 0; i < dependencies.length; i++) {
            String targetFile=dependencies[i];
            targetFile=baseDir+File.separator+targetFile;
            command.addArgument(targetFile);
        }
        //now run the command of exe + settings + files
        command.runCommand();
    } // end execute
} //end class
"
org.apache.tools.ant.taskdefs.optional.dotnet.Ilasm,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/* build notes
   -The reference CD to listen to while editing this file is 
       nap: Underworld  - Everything, Everything
   -variable naming policy from Fowler's refactoring book.
   -tested against the PDC pre-beta of csc.exe; future versions will 
    inevitably change things
*/
// ====================================================================
// place in the optional ant tasks package
// but in its own dotnet group
// ====================================================================
package org.apache.tools.ant.taskdefs.optional.dotnet;
// ====================================================================
// imports
// ====================================================================
import java.io.*;
import java.text.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
/**
Task to assemble .net 'Intermediate Language' files.
The task will only work on win2K until other platforms support csc.exe or 
an equivalent. ilasm.exe must be on the execute path too.
<p>
<p>
All parameters are optional: &lt;il/&gt; should suffice to produce a debug
build of all *.il files.
The option set is roughly compatible with the CSharp class;
even though the command line options are only vaguely
equivalent. [The low level commands take things like /OUT=file,
csc wants /out:file ... /verbose is used some places; /quiet here in
ildasm... etc.] It would be nice if someone made all the command line
tools consistent (and not as brittle as the java cmdline tools) 
<p>
The task is a directory based task, so attributes like <b>includes=""*.il""</b> and 
<b>excludes=""broken.il""</b> can be used to control the files pulled in. 
Each file is built on its own, producing an appropriately named output file unless
manually specified with <b>outfile</b>
@author Steve Loughran steve_l@iseran.com
@version 0.2
 */
public class Ilasm
    extends org.apache.tools.ant.taskdefs.MatchingTask {
    /** constructor inits everything and set up the search pattern
    */
    public Ilasm () {
        Clear();
        setIncludes(file_pattern);
    }
    /** name of the executable. the .exe suffix is deliberately not included 
     * in anticipation of the unix version
     */
    protected static final String exe_name=""ilasm"";
    /** what is the file extension we search on?
     */
    protected static final String file_ext=""il"";
    /** and now derive the search pattern from the extension 
     */
    protected static final String file_pattern=""**/*.""+file_ext;
    /** title of task for external presentation
     */
    protected static final String exe_title=""ilasm"";
    /** reset all contents. 
    */
    public void Clear() {
        _targetType=null;
        _srcDir=null;
        _listing = false;
        _verbose=false;
        _debug=true;
        _owner=null;
        _outputFile=null;
        _failOnError=true;
        _resourceFile=null;
        _owner=null;
        _extraOptions=null;     
    }
    /** source directory upon which the search pattern is applied
     */
    private File _srcDir;
    /**
     * Set the source dir to find the files to be compiled
     * @param  srcDirName  The new SrcDir value 
     */
    public void setSrcDir(String srcDirName){
        _srcDir = project.resolveFile(srcDirName);
    }
    /** type of target. Should be one of exe|library|module|winexe|(null)
    default is exe; the actual value (if not null) is fed to the command line.
    <br>See /target
     */
    protected String _targetType;
    /** define the target
     * @param  targetType          one of exe|library|
     * @exception BuildException if target is not one of exe|library|module|winexe 
     */
    public void setTargetType(String targetType)
        throws  BuildException {
        targetType=targetType.toLowerCase();
        if(targetType.equals(""exe"") || targetType.equals(""library"")) {
            _targetType=targetType; 
        }
        else 
            throw new BuildException(""targetType "" +targetType+"" is not a valid type"");
    }
    /**
     * accessor method for target type
     * @return the current target option
     */
    public String getTargetType() { 
        return _targetType;
    }   
    /** g
     *  get the target type or null for no argument needed 
     *
     * @return    The TargetTypeParameter value 
    */
    protected String getTargetTypeParameter() {
        if(!notEmpty(_targetType))
            return null;
        if (_targetType.equals(""exe""))
            return ""/exe"";
        else 
        if (_targetType.equals(""library""))
            return ""/dll"";
        else
            return null;
    }   
    /** owner string is a slightly trivial barrier to disassembly
    */
    protected String _owner;
    /**
     *  Sets the Owner attribute 
     *
     * @param  s  The new Owner value 
     */
    public void setOwner(String s) {
        _owner=s;
        }
    /**
     *  Gets the Owner switch for ilasm
     *
     * @return    The Owner string
     */    
    protected String getOwnerParameter() {
        if(notEmpty(_owner))
            return ""/owner=""+_owner;
        else 
            return null;
    }
    /** test for a string containing something useful
     * @param string to test
     * @returns true if the argument is not null or empty
    */
    protected boolean notEmpty(String s)
        {return s!=null && s.length()!=0;}
    /** verbose flag
     */
    protected boolean _verbose;
    /** 
     * enable/disable verbose ILASM output
     * @param b flag set to true for verbose on
     */
    public void setVerbose(boolean b) {
        _verbose=b;
    }
    /** 
     * turn the verbose flag into a parameter for ILASM
     * @return null or the appropriate command line string
     */
    protected String getVerboseParameter() {
        return _verbose?null:""/quiet"";
    }   
    /** listing flag
     */
    protected boolean _listing;
    /** 
     * enable/disable listing
     * @param b flag set to true for listing on
     */
    public void setListing(boolean b) {
        _listing=b;
    }
    /** 
     * turn the listing flag into a parameter for ILASM
     * @return the appropriate string from the state of the listing flag
     */
    protected String getListingParameter() {
        return _listing?""/listing"":""/nolisting"";
    }
    /**
     * output file. If not supplied this is derived from the
     *  source file
     */
    protected String _outputFile;
    /**
     * Set the definitions
     * @param list of definitions split by ; or , or even :
     */
    public void setOutputFile(String params) {
        _outputFile=params;
    }
    /**
     * get the output file 
     * @return the argument string or null for no argument
    */
    protected String getOutputFileParameter() {
        if (_outputFile==null || _outputFile.length()==0)
            return null;
        File f=project.resolveFile(_outputFile);
        return ""/output=""+f.toString();
    }
    /** resource file (.res format) to include in the app. 
     */
    protected File _resourceFile;
    /**
     * Set the resource file 
     * @param fileName path to the file. Can be relative, absolute, whatever.
     */public void setResourceFile(String fileName) {
        _resourceFile = project.resolveFile(fileName);
    }
    protected String getResourceFileParameter() {
        if(_resourceFile!=null) {
            return ""/resource=""+_resourceFile.toString();
        }
        else {
            return null;
        }
    }
    /** flag to control action on execution trouble
    */
    protected boolean _failOnError;
    /**set fail on error flag
    */
    public void setFailOnError(boolean b){
        _failOnError=b;
    }
    /** query fail on error flag
    */
    public boolean getFailFailOnError() {
        return _failOnError;
    }
    /** debug flag. Controls generation of debug information. 
     */
    protected boolean _debug;
    /** set the debug flag on or off
     * @param f on/off flag
     */
    public void setDebug(boolean f)
        {_debug=f;}
    /** query the debug flag
     * @return true if debug is turned on
     */
    public boolean getDebug() {
        return _debug;
    }
    /** get the argument or null for no argument needed
    */
    protected String getDebugParameter() {
        return _debug?""/debug"":null;
    }   
    /** any extra command options?
     */
    protected String _extraOptions;
    /**
     *  Sets the ExtraOptions attribute
     *
     * @param  extraOptions  The new ExtraOptions value 
     */
    public void setExtraOptions(String extraOptions)
        {this._extraOptions=extraOptions;}
    /**
     *  Gets the ExtraOptions attribute 
     *
     * @return    The ExtraOptions value 
     */
    public String getExtraOptions()
        {return this._extraOptions;}
    /**
     *  get any extra options or null for no argument needed 
     *
     * @return    The ExtraOptions Parameter to CSC 
     */
    protected String getExtraOptionsParameter() {
        if (_extraOptions!=null && _extraOptions.length()!=0)
            return _extraOptions;
        else
            return null;
    } 
    /** This is the execution entry point. Build a list of files and
     *  call ilasm on each of them.
     * @throws BuildException if the assembly failed and FailOnError is true
     */
    public void execute() 
        throws BuildException {
        if (_srcDir == null)
                _srcDir=project.resolveFile(""."");
        //get dependencies list. 
        DirectoryScanner scanner = super.getDirectoryScanner(_srcDir);
        String[] dependencies = scanner.getIncludedFiles();
        log(""assembling ""+dependencies.length+"" file""+((dependencies.length==1)?"""":""s""));
        String baseDir=scanner.getBasedir().toString();
        //add to the command
        for (int i = 0; i < dependencies.length; i++) {
            String targetFile=dependencies[i];
            targetFile=baseDir+File.separator+targetFile;
            executeOneFile(targetFile);
        }
    } // end execute
    /**
     * do the work for one file by building the command line then calling it
     * @param targetFile name of the the file to assemble
     * @throws BuildException if the assembly failed and FailOnError is true
     */
    public void executeOneFile(String targetFile) 
        throws BuildException {
        NetCommand command=new NetCommand(this,exe_title,exe_name);
        command.setFailOnError(getFailFailOnError());
        //DEBUG helper
        command.setTraceCommandLine(true);
        //fill in args
        command.addArgument(getDebugParameter());
        command.addArgument(getTargetTypeParameter());
        command.addArgument(getListingParameter());
        command.addArgument(getOutputFileParameter());   
        command.addArgument(getOwnerParameter());
        command.addArgument(getResourceFileParameter());
        command.addArgument(getVerboseParameter());
        command.addArgument(getExtraOptionsParameter());
        /* space for more argumentativeness
           command.addArgument();
           command.addArgument();
        */
        command.addArgument(targetFile);
        //now run the command of exe + settings + file
        command.runCommand();
    } // end executeOneFile
} //class
"
org.apache.tools.ant.taskdefs.optional.dotnet.NetCommand,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/* build notes
The reference CD to listen to while editing this file is
Underworld Everything, Everything
variable naming policy from Fowler's refactoring book.
 */
// place below the optional ant tasks package
package org.apache.tools.ant.taskdefs.optional.dotnet;
// imports
import java.io.*;
import java.text.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
/**
This is a helper class to spawn net commands out. 
In its initial form it contains no .net specifics, just contains
all the command line/exe construction stuff. However, it may be handy in future
to have a means of setting the path to point to the dotnet bin directory; in which
case the shared code should go in here.
@author Steve Loughran steve_l@iseran.com
@created 2000-11-01
@version 0.3
 */
public class NetCommand {
    /** constructor
    @param owning task
    @param title (for logging/errors)
    @param executable. Leave off the '.exe. for future portability
    */
    public NetCommand(Task owner, String title, String program) {
        _owner=owner;
        _title=title;
        _program=program;
        _commandLine=new Commandline();
        _commandLine.setExecutable(_program);
        prepareExecutor();
        }
    /** owner project
     */
    protected Task _owner;
    /** executabe
     */
    protected Execute _exe;
    /** what is the command line
     */
    protected Commandline _commandLine;
    /** title of the command
     */
    protected String _title;
    /** actual program to invoke
     */
    protected String _program;
    /** trace flag
     */
    protected boolean _traceCommandLine=false;
    /**
     * turn tracing on or off
     * @param b trace flag
     */
    public void setTraceCommandLine(boolean b){
        _traceCommandLine=b;
    }
    /** flag to control action on execution trouble
    */
    protected boolean _failOnError;
    /**
     * set fail on error flag
     * @param b fail flag -set to true to cause an exception to be raised if
     * the return value != 0
     */
    public void setFailOnError(boolean b){
        _failOnError=b;
    }
    /** query fail on error flag
    */
    public boolean getFailFailOnError() {
        return _failOnError;
    }
    /** 
     * verbose text log
     * @param msg string to add to log iff verbose is defined for the build
     */
    protected void logVerbose(String msg){
        _owner.getProject().log(msg,Project.MSG_VERBOSE);
        }
    /**
     * error text log
     * @param  msg  message to display as an error
     */
    protected void logError(String msg) {
        _owner.getProject().log(msg,Project.MSG_ERR);
    }
    /**
     * add an argument to a command line; do nothing if the arg is null or empty string
     * @param  argument  The feature to be added to the Argument attribute 
     */
    public void addArgument(String argument){
        if(argument!=null && argument.length()!=0) {
            _commandLine.createArgument().setValue(argument);
        }
    }
    /**
     * set up the command sequence..
     */
    protected void prepareExecutor() {
        // default directory to the project's base directory
        File dir = _owner.getProject().getBaseDir();
        ExecuteStreamHandler handler=new LogStreamHandler(_owner,
                   Project.MSG_INFO, Project.MSG_WARN);
        _exe = new Execute(handler, null);
        _exe.setAntRun(_owner.getProject());
        _exe.setWorkingDirectory(dir);
    }
    /**
     * Run the command using the given Execute instance.
     * @throws an exception of something goes wrong and the failOnError flag is true
     */
    public void runCommand()
        throws BuildException {
        int err = -1; // assume the worst
        try {
            if(_traceCommandLine) {
                _owner.log(_commandLine.toString());
            }
            else {
                //in verbose mode we always log stuff
                logVerbose(_commandLine.toString());
            }
            _exe.setCommandline(_commandLine.getCommandline());
            err = _exe.execute();
            if (err != 0) {
                if (_failOnError) {
                    throw new BuildException(_title+"" returned: ""+err, _owner.getLocation());
                } else {
                    _owner.log(_title+""  Result: "" + err, Project.MSG_ERR);
                }
            }
        } catch (IOException e) {
            throw new BuildException(_title+"" failed: "" + e, e, _owner.getLocation());
        }
    }
} //class
"
org.apache.tools.ant.taskdefs.optional.ejb.DDCreator,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import java.io.File;
/**
 * Build a serialised deployment descriptor given a text file description of the 
 * descriptor in the format supported by WebLogic.
 *
 * This ant task is a front end for the weblogic DDCreator tool.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class DDCreator extends MatchingTask {
    /**
     * The root directory of the tree containing the textual deployment desciptors. The actual
     * deployment descriptor files are selected using include and exclude constructs
     * on the EJBC task, as supported by the MatchingTask superclass.
     */
    private File descriptorDirectory;
    /**
     * The directory where generated serialised deployment descriptors are placed.
     */
    private File generatedFilesDirectory;
    /**
     * The classpath to be used in the weblogic ejbc calls. It must contain the weblogic
     * classes necessary fro DDCreator <b>and</b> the implementation classes of the 
     * home and remote interfaces.
     */
    private String classpath;
    /**
     * Do the work.
     *
     * The work is actually done by creating a helper task. This approach allows
     * the classpath of the helper task to be set. Since the weblogic tools require
     * the class files of the project's home and remote interfaces to be available in
     * the classpath, this also avoids having to start ant with the class path of the
     * project it is building.
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        if (descriptorDirectory == null ||
            !descriptorDirectory.isDirectory()) {
            throw new BuildException(""descriptors directory "" + descriptorDirectory.getPath() + 
                                     "" is not valid"");
        }
        if (generatedFilesDirectory == null ||
            !generatedFilesDirectory.isDirectory()) {
            throw new BuildException(""dest directory "" + generatedFilesDirectory.getPath() + 
                                     "" is not valid"");
        }
        String args = descriptorDirectory + "" "" + generatedFilesDirectory;
        // get all the files in the descriptor directory
        DirectoryScanner ds = super.getDirectoryScanner(descriptorDirectory);
        String[] files = ds.getIncludedFiles();
        for (int i = 0; i < files.length; ++i) {
            args += "" "" + files[i];
        }
        String systemClassPath = System.getProperty(""java.class.path"");
        String execClassPath = project.translatePath(systemClassPath + "":"" + classpath);
        Java ddCreatorTask = (Java)project.createTask(""java"");
        ddCreatorTask.setTaskName(getTaskName());
        ddCreatorTask.setFork(true);
        ddCreatorTask.setClassname(""org.apache.tools.ant.taskdefs.optional.ejb.DDCreatorHelper"");
        Commandline.Argument arguments = ddCreatorTask.createArg();
        arguments.setLine(args);
        ddCreatorTask.setClasspath(new Path(project, execClassPath));                         
        if (ddCreatorTask.executeJava() != 0) {                         
            throw new BuildException(""Execution of ddcreator helper failed"");
        }
    }
    /**
     * Set the directory from where the text descriptions of the deployment descriptors are
     * to be read.
     *
     * @param dirName the name of the directory containing the text deployment descriptor files.
     */
    public void setDescriptors(String dirName) {
        descriptorDirectory = new File(dirName);
    }
    /**
     * Set the directory into which the serialised deployment descriptors are to 
     * be written.
     *
     * @param dirName the name of the directory into which the serialised deployment
     *                descriptors are written.
     */
    public void setDest(String dirName) {
        generatedFilesDirectory = new File(dirName);
    }
    /**
     * Set the classpath to be used for this compilation.
     *
     * @param s the classpath to use for the ddcreator tool.
     */
    public void setClasspath(String s) {
        this.classpath = project.translatePath(s);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.DDCreatorHelper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.File;
/**
 * A helper class which performs the actual work of the ddcreator task.
 *
 * This class is run with a classpath which includes the weblogic tools and the home and remote
 * interface class files referenced in the deployment descriptors being built.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class DDCreatorHelper {
    /**
     * The root directory of the tree containing the textual deployment desciptors. 
     */
    private File descriptorDirectory;
    /**
     * The directory where generated serialised desployment descriptors are written.
     */
    private File generatedFilesDirectory;
    /**
     * The descriptor text files for which a serialised descriptor is to be created.
     */
    String[] descriptors; 
    /**
     * The main method.
     *
     * The main method creates an instance of the DDCreatorHelper, passing it the 
     * args which it then processes.
     */    
    public static void main(String[] args) throws Exception {
        DDCreatorHelper helper = new DDCreatorHelper(args);
        helper.process();
    }
    /**
     * Initialise the helper with the command arguments.
     *
     */
    private DDCreatorHelper(String[] args) {
        int index = 0;
        descriptorDirectory = new File(args[index++]);
        generatedFilesDirectory = new File(args[index++]);
        descriptors = new String[args.length - index];
        for (int i = 0; index < args.length; ++i) {
            descriptors[i] = args[index++];
        }
    }
    /**
     * Do the actual work.
     *
     * The work proceeds by examining each descriptor given. If the serialised
     * file does not exist or is older than the text description, the weblogic
     * DDCreator tool is invoked directly to build the serialised descriptor.
     */    
    private void process() throws Exception {
        for (int i = 0; i < descriptors.length; ++i) {
            String descriptorName = descriptors[i];
            File descriptorFile = new File(descriptorDirectory, descriptorName);
            int extIndex = descriptorName.lastIndexOf(""."");
            String serName = null;
            if (extIndex != -1) {
                serName = descriptorName.substring(0, extIndex) + "".ser"";
            }
            else {
                serName = descriptorName + "".ser"";
            }
            File serFile = new File(generatedFilesDirectory, serName);
            // do we need to regenerate the file
            if (!serFile.exists() || serFile.lastModified() < descriptorFile.lastModified()) {
                String[] args = {""-noexit"", 
                                 ""-d"", serFile.getParent(),
                                 ""-outputfile"", serFile.getName(),
                                 descriptorFile.getPath()};
                try {
                    weblogic.ejb.utils.DDCreator.main(args);
                }
                catch (Exception e) {
                    // there was an exception - run with no exit to get proper error
                    String[] newArgs = {""-d"", generatedFilesDirectory.getPath(),
                                 ""-outputfile"", serFile.getName(),
                                 descriptorFile.getPath()};
                    weblogic.ejb.utils.DDCreator.main(newArgs);
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.DescriptorHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.util.*;
import java.io.*;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.AttributeList;
/**
 * Inner class used by EjbJar to facilitate the parsing of deployment
 * descriptors and the capture of appropriate information. Extends
 * HandlerBase so it only implements the methods needed. During parsing
 * creates a hashtable consisting of entries mapping the name it should be
 * inserted into an EJB jar as to a File representing the file on disk. This
 * list can then be accessed through the getFiles() method.
 */
public class DescriptorHandler extends org.xml.sax.HandlerBase {
    /**
     * Bunch of constants used for storing entries in a hashtable, and for
     * constructing the filenames of various parts of the ejb jar.
     */
    private static final String EJB_REF   = ""ejb-ref"";
    private static final String HOME_INTERFACE   = ""home"";
    private static final String REMOTE_INTERFACE = ""remote"";
    private static final String BEAN_CLASS       = ""ejb-class"";
    private static final String PK_CLASS         = ""prim-key-class"";
    /**
     * Instance variable used to store the name of the current element being
     * processed by the SAX parser.  Accessed by the SAX parser call-back methods
     * startElement() and endElement().
     */
    protected String currentElement = null;
    /**
     * The text of the current element
     */
    protected String currentText = null;
    /**
     * Instance variable that stores the names of the files as they will be
     * put into the jar file, mapped to File objects  Accessed by the SAX
     * parser call-back method characters().
     */
    protected Hashtable ejbFiles = null;
    private Hashtable fileDTDs = new Hashtable();
    private Hashtable resourceDTDs = new Hashtable();
    private boolean inEJBRef = false;
    /**
     * The directory containing the bean classes and interfaces. This is 
     * used for performing dependency file lookups.
     */
    private File srcDir;
    public DescriptorHandler(File srcDir) {
        this.srcDir = srcDir;
    }
    public void registerDTD(String publicId, String location) {
        if (location == null) {
            return;
        }
        File fileDTD = new File(location);
        if (fileDTD.exists()) {
            fileDTDs.put(publicId, fileDTD);
            return;
        }
        if (getClass().getResource(location) != null) {
            resourceDTDs.put(publicId, location);
        }
    }
    public InputSource resolveEntity(String publicId, String systemId)
        throws SAXException
    {
        File dtdFile = (File) fileDTDs.get(publicId);
        if (dtdFile != null) {
            try {
                return new InputSource(new FileInputStream(dtdFile));
            } catch( FileNotFoundException ex ) {
                // ignore
            }
        }
        String dtdResourceName = (String)resourceDTDs.get(publicId); 
        if (dtdResourceName != null) {
            InputStream is = this.getClass().getResourceAsStream(dtdResourceName);
            if( is != null ) {
                return new InputSource(is);
            }
        }
        return null;
    }
    /**
     * Getter method that returns the set of files to include in the EJB jar.
     */
    public Hashtable getFiles() {
        return (ejbFiles == null) ? new Hashtable() : ejbFiles;
    }
    /**
     * SAX parser call-back method that is used to initialize the values of some
     * instance variables to ensure safe operation.
     */
    public void startDocument() throws SAXException {
        this.ejbFiles = new Hashtable(10, 1);
        this.currentElement = null;
        inEJBRef = false;
    }
    /**
     * SAX parser call-back method that is invoked when a new element is entered
     * into.  Used to store the context (attribute name) in the currentAttribute
     * instance variable.
     * @param name The name of the element being entered.
     * @param attrs Attributes associated to the element.
     */
    public void startElement(String name, AttributeList attrs) 
        throws SAXException {
        this.currentElement = name;
        currentText = """";
        if (name.equals(EJB_REF)) {
            inEJBRef = true;
        }
    }
    /**
     * SAX parser call-back method that is invoked when an element is exited.
     * Used to blank out (set to the empty string, not nullify) the name of
     * the currentAttribute.  A better method would be to use a stack as an
     * instance variable, however since we are only interested in leaf-node
     * data this is a simpler and workable solution.
     * @param name The name of the attribute being exited. Ignored
     *        in this implementation.
     */
    public void endElement(String name) throws SAXException {
        processElement();
        currentText = """";
        this.currentElement = """";
        if (name.equals(EJB_REF)) {
            inEJBRef = false;
        }
    }
    /**
     * SAX parser call-back method invoked whenever characters are located within
     * an element.  currentAttribute (modified by startElement and endElement)
     * tells us whether we are in an interesting element (one of the up to four
     * classes of an EJB).  If so then converts the classname from the format
     * org.apache.tools.ant.Parser to the convention for storing such a class,
     * org/apache/tools/ant/Parser.class.  This is then resolved into a file
     * object under the srcdir which is stored in a Hashtable.
     * @param ch A character array containing all the characters in
     *        the element, and maybe others that should be ignored.
     * @param start An integer marking the position in the char
     *        array to start reading from.
     * @param length An integer representing an offset into the
     *        char array where the current data terminates.
     */
    public void characters(char[] ch, int start, int length)
        throws SAXException {
        currentText += new String(ch, start, length);
    }
    protected void processElement() {
        if (inEJBRef) {
            return;
        }
        if (currentElement.equals(HOME_INTERFACE)   ||
            currentElement.equals(REMOTE_INTERFACE) ||
            currentElement.equals(BEAN_CLASS)       ||
            currentElement.equals(PK_CLASS)) {
            // Get the filename into a String object
            File classFile = null;
            String className = currentText.trim();
            // If it's a primitive wrapper then we shouldn't try and put
            // it into the jar, so ignore it.
            if (!className.startsWith(""java.lang"")) {
                // Translate periods into path separators, add .class to the
                // name, create the File object and add it to the Hashtable.
                className = className.replace('.', File.separatorChar);
                className += "".class"";
                classFile = new File(srcDir, className);
                ejbFiles.put(className, classFile);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.Ejbc,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import java.io.File;
/**
 * Build EJB support classes using Weblogic's ejbc tool from a directory containing
 * a set of deployment descriptors.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class Ejbc extends MatchingTask {
    /**
     * The root directory of the tree containing the serialised deployment desciptors. The actual
     * deployment descriptor files are selected using include and exclude constructs
     * on the ejbc task provided by the MatchingTask superclass.
     */
    private File descriptorDirectory;
    /**
     * The directory where generated files are placed.
     */
    private File generatedFilesDirectory;
    /**
     * The name of the manifest file generated for the EJB jar.
     */
    private File generatedManifestFile;
    /**
     * The classpath to be used in the weblogic ejbc calls. It must contain the weblogic
     * classes <b>and</b> the implementation classes of the home and remote interfaces.
     */
    private String classpath;
    /**
     * The source directory for the home and remote interfaces. This is used to determine if
     * the generated deployment classes are out of date.
     */
    private File sourceDirectory;
    public boolean keepgenerated;
    /**
     * Do the work.
     *
     * The work is actually done by creating a separate JVM to run a helper task. 
     * This approach allows the classpath of the helper task to be set. Since the 
     * weblogic tools require the class files of the project's home and remote 
     * interfaces to be available in the classpath, this also avoids having to 
     * start ant with the class path of the project it is building.
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        if (descriptorDirectory == null ||
            !descriptorDirectory.isDirectory()) {
            throw new BuildException(""descriptors directory "" + descriptorDirectory.getPath() + 
                                     "" is not valid"");
        }
        if (generatedFilesDirectory == null ||
            !generatedFilesDirectory.isDirectory()) {
            throw new BuildException(""dest directory "" + generatedFilesDirectory.getPath() + 
                                     "" is not valid"");
        }
        if (sourceDirectory == null ||
            !sourceDirectory.isDirectory()) {
            throw new BuildException(""src directory "" + sourceDirectory.getPath() + 
                                     "" is not valid"");
        }
        String systemClassPath = System.getProperty(""java.class.path"");
        String execClassPath = project.translatePath(systemClassPath + "":"" + classpath +
                                                         "":"" + generatedFilesDirectory);
        // get all the files in the descriptor directory
        DirectoryScanner ds = super.getDirectoryScanner(descriptorDirectory);
        String[] files = ds.getIncludedFiles();
        Java helperTask = (Java)project.createTask(""java"");
        helperTask.setTaskName(getTaskName());
        helperTask.setFork(true);
        helperTask.setClassname(""org.apache.tools.ant.taskdefs.optional.ejb.EjbcHelper"");
        String args = """";
        args += "" "" + descriptorDirectory;
        args += "" "" + generatedFilesDirectory;
        args += "" "" + sourceDirectory;
        args += "" "" + generatedManifestFile;
        args += "" "" + keepgenerated;
        for (int i = 0; i < files.length; ++i) {
            args += "" "" + files[i];
        }
        Commandline.Argument arguments = helperTask.createArg();
        arguments.setLine(args);
        helperTask.setClasspath(new Path(project, execClassPath));
        if (helperTask.executeJava() != 0) {                         
            throw new BuildException(""Execution of ejbc helper failed"");
        }
    }
    public boolean getKeepgenerated() {
        return keepgenerated;
    }
    /**
     * Set the directory from where the serialised deployment descriptors are
     * to be read.
     *
     * @param dirName the name of the directory containing the serialised deployment descriptors.
     */
    public void setDescriptors(String dirName) {
        descriptorDirectory = new File(dirName);
    }
    /**
     * Set the directory into which the support classes, RMI stubs, etc are to be written
     *
     * @param dirName the name of the directory into which code is generated
     */
    public void setDest(String dirName) {
        generatedFilesDirectory = new File(dirName);
    }
    public void setKeepgenerated(String newKeepgenerated) {
        keepgenerated = Boolean.valueOf(newKeepgenerated.trim()).booleanValue();
    }
    /**
     * Set the generated manifest file. 
     *
     * For each EJB that is processed an entry is created in this file. This can then be used
     * to create a jar file for dploying the beans.
     *
     * @param manfestFilename the name of the manifest file to be generated.
     */
    public void setManifest(String manifestFilename) {
        generatedManifestFile = new File(manifestFilename);
    }
    /**
     * Set the classpath to be used for this compilation.
     */
    public void setClasspath(String s) {
        this.classpath = project.translatePath(s);
    }
    /**
     * Set the directory containing the source code for the home interface, remote interface
     * and public key class definitions.
     *
     * @param dirName the directory containg the source tree for the EJB's interface classes.
     */
    public void setSrc(String dirName) {
        sourceDirectory = new File(dirName);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.EjbcHelper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
import java.util.*;
import javax.ejb.deployment.EntityDescriptor;
import javax.ejb.deployment.DeploymentDescriptor;
/**
 * A helper class which performs the actual work of the ejbc task.
 *
 * This class is run with a classpath which includes the weblogic tools and the home and remote
 * interface class files referenced in the deployment descriptors being processed.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class EjbcHelper {
    /**
     * The root directory of the tree containing the serialised deployment desciptors. 
     */
    private File descriptorDirectory;
    /**
     * The directory where generated files are placed.
     */
    private File generatedFilesDirectory;
    /**
     * The name of the manifest file generated for the EJB jar.
     */
    private File manifestFile;
    /**
     * The classpath to be used in the weblogic ejbc calls. It must contain the weblogic
     * classes <b>and</b> the implementation classes of the home and remote interfaces.
     */
    private String classpath;
    /**
     * The source directory for the home and remote interfaces. This is used to determine if
     * the generated deployment classes are out of date.
     */
    private File sourceDirectory;
    /**
     * The names of the serialised deployment descriptors
     */
    String[] descriptors;
    private boolean keepGenerated;
    /**
     * Command line interface for the ejbc helper task.
     */    
    public static void main(String[] args) throws Exception {
        EjbcHelper helper = new EjbcHelper(args);
        helper.process();
    }
    /**
     * Initialise the EjbcHelper by reading the command arguments.
     */    
    private EjbcHelper(String[] args) {
        int index = 0;
        descriptorDirectory = new File(args[index++]);
        generatedFilesDirectory = new File(args[index++]);
        sourceDirectory = new File(args[index++]);
        manifestFile = new File(args[index++]);
        keepGenerated = Boolean.valueOf(args[index++]).booleanValue();
        descriptors = new String[args.length - index];
        for (int i = 0; index < args.length; ++i) {
            descriptors[i] = args[index++];
        }
    }
    private String[] getCommandLine(boolean debug, File descriptorFile) {
        Vector v = new Vector();
        if (!debug) {
            v.add(""-noexit"");
        }
        if (keepGenerated) {
            v.add(""-keepgenerated"");        
        }
        v.add(""-d"");
        v.add(generatedFilesDirectory.getPath());
        v.add(descriptorFile.getPath());
        String[] args = new String[v.size()];
        v.copyInto(args);
        return args;
    }
    /**
     * Determine if the weblogic EJB support classes need to be regenerated
     * for a given deployment descriptor.
     *
     * This process attempts to determine if the support classes need to be
     * rebuilt. It does this by examining only some of the support classes 
     * which are typically generated. If the ejbc task is interrupted generating
     * the support classes for a bean, all of the support classes should be removed
     * to force regeneration of the support classes.
     *
     * @param descriptorFile the serialised deployment descriptor
     *
     * @return true if the support classes need to be regenerated.
     *
     * @throws IOException if the descriptor file cannot be closed.
     */
    private boolean isRegenRequired(File descriptorFile) throws IOException {
        // read in the descriptor. Under weblogic, the descriptor is a weblogic
        // specific subclass which has references to the implementation classes.
        // These classes must, therefore, be in the classpath when the deployment
        // descriptor is loaded from the .ser file
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(descriptorFile);
            ObjectInputStream ois = new ObjectInputStream(fis);
            DeploymentDescriptor dd = (DeploymentDescriptor)ois.readObject();
            fis.close();
            String homeInterfacePath = dd.getHomeInterfaceClassName().replace('.', '/') + "".java"";
            String remoteInterfacePath = dd.getRemoteInterfaceClassName().replace('.', '/') + "".java"";
            String primaryKeyClassPath = null;
            if (dd instanceof EntityDescriptor) {
                primaryKeyClassPath = ((EntityDescriptor)dd).getPrimaryKeyClassName().replace('.', '/') + "".java"";;
            }
            File homeInterfaceSource = new File(sourceDirectory, homeInterfacePath);
            File remoteInterfaceSource = new File(sourceDirectory, remoteInterfacePath);
            File primaryKeyClassSource = null;
            if (primaryKeyClassPath != null) {
                primaryKeyClassSource = new File(sourceDirectory, remoteInterfacePath);
            }
            // are any of the above out of date. 
            // we find the implementation classes and see if they are older than any
            // of the above or the .ser file itself.
            String beanClassBase = dd.getEnterpriseBeanClassName().replace('.', '/');
            File ejbImplentationClass 
                = new File(generatedFilesDirectory, beanClassBase + ""EOImpl.class"");
            File homeImplementationClass 
                = new File(generatedFilesDirectory, beanClassBase + ""HomeImpl.class"");
            File beanStubClass 
                = new File(generatedFilesDirectory, beanClassBase + ""EOImpl_WLStub.class"");
            // if the implementation classes don;t exist regenerate                
            if (!ejbImplentationClass.exists() || !homeImplementationClass.exists() ||
                    !beanStubClass.exists()) {
                return true;
            }
            // Is the ser file or any of the source files newer then the class files.
            // firstly find the oldest of the two class files.
            long classModificationTime = ejbImplentationClass.lastModified();
            if (homeImplementationClass.lastModified() < classModificationTime) {
                classModificationTime = homeImplementationClass.lastModified();
            }
            if (beanStubClass.lastModified() < classModificationTime) {
                classModificationTime = beanStubClass.lastModified();
            }
            if (descriptorFile.lastModified() > classModificationTime ||
                    homeInterfaceSource.lastModified() > classModificationTime ||
                    remoteInterfaceSource.lastModified() > classModificationTime) {
                return true;
            }
            if (primaryKeyClassSource != null && 
                    primaryKeyClassSource.lastModified() > classModificationTime) {
                return true;
            }
        }
        catch (Throwable descriptorLoadException) {
            System.out.println(""Exception occurred reading "" + descriptorFile.getName() + "" - continuing"");
            // any problems - just regenerate
            return true;
        }
        finally {
            if (fis != null) {
                fis.close();
            }
        }
        return false;
    }
    /**
     * Process the descriptors in turn generating support classes for each and a manifest
     * file for all of the beans.
     */            
    private void process() throws Exception {
        String manifest = ""Manifest-Version: 1.0\n\n"";
        for (int i = 0; i < descriptors.length; ++i) {
            String descriptorName = descriptors[i];
            File descriptorFile = new File(descriptorDirectory, descriptorName);
            if (isRegenRequired(descriptorFile)) {
                System.out.println(""Running ejbc for "" + descriptorFile.getName());
                regenerateSupportClasses(descriptorFile);
            }
            else {
                System.out.println(descriptorFile.getName() + "" is up to date"");
            }
            manifest += ""Name: "" + descriptorName.replace('\\', '/') + ""\nEnterprise-Bean: True\n\n"";
        }
        FileWriter fw = new FileWriter(manifestFile);
        PrintWriter pw = new PrintWriter(fw);
        pw.print(manifest);
        fw.flush();
        fw.close();
    }
    /**
     * Perform the weblogic.ejbc call to regenerate the support classes.
     *
     * Note that this method relies on an undocumented -noexit option to the 
     * ejbc tool to stop the ejbc tool exiting the VM altogether.
     */
    private void regenerateSupportClasses(File descriptorFile) throws Exception {
        // create a Java task to do the rebuild
        String[] args = getCommandLine(false,descriptorFile);
        try {
            weblogic.ejbc.main(args);
        }
        catch (Exception e) {
            // run with no exit for better reporting
            String[] newArgs = getCommandLine(true, descriptorFile);
            weblogic.ejbc.main(newArgs);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.EJBDeploymentTool,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
import javax.xml.parsers.SAXParser;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.*;
public interface EJBDeploymentTool {
    /**
     * Process a deployment descriptor, generating the necessary vendor specific
     * deployment files.
     *
     * @param descriptorFilename the name of the deployment descriptor
     * @param saxParser a SAX parser which can be used to parse the deployment descriptor. 
     */
    public void processDescriptor(String descriptorFilename, SAXParser saxParser) 
        throws BuildException;
    /**
     * Called to validate that the tool parameters have been configured.
     *
     */
    public void validateConfigured() throws BuildException;
    /**
     * Set the task which owns this tool
     */
    public void setTask(Task task);
    /**
     * Configure this tool for use in the ejbjar task.
     */
    public void configure(EjbJar.Config config);     
}"
org.apache.tools.ant.taskdefs.optional.ejb.EjbJar,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
// Standard java imports
import java.io.*;
import java.util.*;
// XML imports
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
// Apache/Ant imports
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.*;
/**
 * <p>Provides automated ejb jar file creation for ant.  Extends the MatchingTask
 * class provided in the default ant distribution to provide a directory scanning
 * EJB jarfile generator.</p>
 *
 * <p>The task works by taking the deployment descriptors one at a time and
 * parsing them to locate the names of the classes which should be placed in
 * the jar.  The classnames are translated to java.io.Files by replacing periods
 * with File.separatorChar and resolving the generated filename as a relative
 * path under the srcDir attribute.  All necessary files are then assembled into
 * a jarfile.  One jarfile is constructed for each deployment descriptor found.
 * </p>
 *
 * <p>Functionality is currently provided for standard EJB1.1 jars and Weblogic
 * 5.1 jars. The weblogic deployment descriptors, used in constructing the 
 * Weblogic jar, are located based on a simple naming convention. The name of the
 * standard deployment descriptor is taken upto the first instance of a String,
 * specified by the attribute baseNameTerminator, and then the regular Weblogic
 * descriptor name is appended. For example if baseNameTerminator is set to '-',
 * its default value, and a standard descriptor is called Foo-ejb-jar.xml then
 * the files Foo-weblogic-ejb-jar.xml and Foo-weblogic-cmp-rdbms-jar.xml will be
 * looked for, and if found, included in the jarfile.</p>
 *
 * <p>Attributes and setter methods are provided to support optional generation
 * of Weblogic5.1 jars, optional deletion of generic jar files, setting alternate
 * values for baseNameTerminator, and setting the strings to append to the names
 * of the generated jarfiles.</p>
 *
 * @author <a href=""mailto:tfennell@sapient.com"">Tim Fennell</a>
 */
public class EjbJar extends MatchingTask {
    public static class DTDLocation {
        private String publicId;
        private String location;
        public void setPublicId(String publicId) {
            this.publicId = publicId;
        }
        public void setLocation(String location) {
            this.location = location;
        }
        public String getPublicId() {
            return publicId;
        }
        public String getLocation() {
            return location;
        }
    }
    /**
     * A class which contains the configuration state of the ejbjar task.
     * This state is passed to the deployment tools for configuration
     */
    static class Config {
        /** Stores a handle to the directory under which to search for class files */
        public File srcDir;
        /** Stores a handle to the directory under which to search for deployment descriptors */
        public File descriptorDir;
        /** Instance variable that marks the end of the 'basename' */
        public String baseNameTerminator = ""-"";
        /** Stores a handle to the destination EJB Jar file */
        public String baseJarName;
        /**
         * Instance variable that determines whether to use a package structure
         * of a flat directory as the destination for the jar files.
         */
        public boolean flatDestDir = false;
        /**
         * The classpath to use when loading classes
         */
        public Path classpath;
        /**
         * A Fileset of support classes
         */
        public List supportFileSets = new ArrayList();
        /**
         * The list of configured DTD locations
         */
        public ArrayList dtdLocations = new ArrayList();
    };
    private Config config = new Config();
    /** Stores a handle to the directory to put the Jar files in. This is only used
        by the generic deployment descriptor tool which is created if no other
        deployment descriptor tools are provided. Normally each deployment tool
        will specify the desitination dir itself. */
    private File destDir;
    /** Instance variable that stores the suffix for the generated jarfile. */
    private String genericJarSuffix = ""-generic.jar"";
    /**
     * The list of deployment tools we are going to run.
     */
    private ArrayList deploymentTools = new ArrayList();
    /**
     * Create a weblogic nested element used to configure a
     * deployment tool for Weblogic server.
     *
     * @return the deployment tool instance to be configured.
     */
    public WeblogicDeploymentTool createWeblogic() {
        WeblogicDeploymentTool tool = new WeblogicDeploymentTool();
        tool.setTask(this);
        deploymentTools.add(tool);
        return tool;
    }
    /**
     * Create a nested element for weblogic when using the Toplink
     * Object- Relational mapping.
     *
     * @return the deployment tool instance to be configured.
     */
    public WeblogicTOPLinkDeploymentTool createWeblogictoplink() {
        WeblogicTOPLinkDeploymentTool tool = new WeblogicTOPLinkDeploymentTool();
        tool.setTask(this);
        deploymentTools.add(tool);
        return tool;
    }
    /**
     * creates a nested classpath element.
     *
     * This classpath is used to locate the super classes and interfaces
     * of the classes that will make up the EJB jar.
     * 
     * @return the path to be configured.
     */
    public Path createClasspath() {
        if (config.classpath == null) {
            config.classpath = new Path(project);
        }
        return config.classpath.createPath();
    }
    /**
     * Create a DTD location record. This stores the location of a DTD. The DTD is identified
     * by its public Id. The location may either be a file location or a resource location.
     */
    public DTDLocation createDTD() {
        DTDLocation dtdLocation = new DTDLocation();
        config.dtdLocations.add(dtdLocation);
        return dtdLocation;
    }
    /**
     * Create a file set for support elements
     *
     * @return a fileset which can be populated with support files.
     */
    public FileSet createSupport() {
        FileSet supportFileSet = new FileSet();
        config.supportFileSets.add(supportFileSet);
        return supportFileSet;
    }
    /**
     * Set the srcdir attribute. The source directory is the directory that contains
     * the classes that will be added to the EJB jar. Typically this will include the 
     * home and remote interfaces and the bean class.
     *
     * @param inDir the source directory.
     */
    public void setSrcdir(File inDir) {
        config.srcDir = inDir;
    }
    /**
     * Set the descriptor directory.
     *
     * The descriptor directory contains the EJB deployment descriptors. These are XML
     * files that declare the properties of a bean in a particular deployment scenario. Such
     * properties include, for example, the transactional nature of the bean and the security
     * access control to the bean's methods.  
     *
     * @param inDir the directory containing the deployment descriptors.
     */
    public void setDescriptordir(File inDir) {
        config.descriptorDir = inDir;
    }
    /**
     * Set the base name of the EJB jar that is to be created if it is not to be
     * determined from the name of the deployment descriptor files. 
     * 
     * @param inValue the basename that will be used when writing the jar file containing
     * the EJB
     */
    public void setBasejarname(String inValue) {
        config.baseJarName = inValue;
    }
    /**
     * Set the destination directory.
     * 
     * The EJB jar files will be written into this directory. The jar files that exist in
     * this directory are also used when determining if the contents of the jar file 
     * have changed.
     *
     * Note that this parameter is only used if no deployment tools are specified. Typically
     * each deployment tool will specify its own destination directory.
     * 
     * @param inFile the destination directory.
     */
    public void setDestdir(File inDir) {
        this.destDir = inDir;
    }
    /**
     * Set the classpath to use when resolving classes for inclusion in the jar. 
     *
     * @param classpath the classpath to use.
     */
    public void setClasspath(Path classpath) {
        config.classpath = classpath;
    }
    /**
     * Set the flat dest dir flag.
     *
     * This flag controls whether the destination jars are written out in the 
     * destination directory with the same hierarchal structure from which 
     * the deployment descriptors have been read. If this is set to true the 
     * generated EJB jars are written into the root of the destination directory,
     * otherwise they are written out in the same relative position as the deployment
     * descriptors in the descriptor directory.
     * 
     * @param inValue the new value of the flatdestdir flag.
     */
    public void setFlatdestdir(boolean inValue) {
        config.flatDestDir = inValue;
    }
    /**
     * Set the suffix for the generated jar file.
     * When generic jars are generated, they have a suffix which is appended to the
     * the bean name to create the name of the jar file. Note that this suffix includes
     * the extension fo te jar file and should therefore end with an appropriate 
     * extension such as .jar or .ear
     * 
     * @param inString the string to use as the suffix.
     */
    public void setGenericjarsuffix(String inString) {
        this.genericJarSuffix = inString;
    }
    /**
     * Set the baseNameTerminator.
     *
     * The basename terminator is the string which terminates the bean name. The convention
     * used by this task is that bean descriptors are named as the BeanName with some suffix. 
     * The baseNameTerminator string separates the bean name and the suffix and is used to
     * determine the bean name.
     *
     * @param inValue a string which marks the end of the basename.
     */
    public void setBasenameterminator(String inValue) {
        config.baseNameTerminator = inValue;
    }
    private void validateConfig() {
        if (config.srcDir == null) {
            throw new BuildException(""The srcDir attribute must be specified"");
        }
        if (config.descriptorDir == null) {
            config.descriptorDir = config.srcDir;
        }
    }        
    /**
     * Invoked by Ant after the task is prepared, when it is ready to execute
     * this task.  
     *
     * This will configure all of the nested deployment tools to allow them to 
     * process the jar. If no deployment tools have been configured a generic 
     * tool is created to handle the jar.
     * 
     * A parser is configured and then each descriptor found is passed to all
     * the deployment tool elements for processing.
     *
     * @exception BuildException thrown whenever a problem is
     *            encountered that cannot be recovered from, to signal to ant
     *            that a major problem occurred within this task.
     */
    public void execute() throws BuildException {
        validateConfig();
        if (deploymentTools.size() == 0) {
            GenericDeploymentTool genericTool = new GenericDeploymentTool();
            genericTool.setTask(this);
            genericTool.setDestdir(destDir);
            genericTool.setGenericJarSuffix(genericJarSuffix);
            deploymentTools.add(genericTool);
        }
        for (Iterator i = deploymentTools.iterator(); i.hasNext(); ) {
            EJBDeploymentTool tool = (EJBDeploymentTool)i.next();
            tool.configure(config);
            tool.validateConfigured();
        }
        try {
            // Create the parser using whatever parser the system dictates
            SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
            saxParserFactory.setValidating(true);
            SAXParser saxParser = saxParserFactory.newSAXParser();
            DirectoryScanner ds = getDirectoryScanner(config.descriptorDir);
            ds.scan();
            String[] files = ds.getIncludedFiles();
            log(files.length + "" deployment descriptors located."",
                Project.MSG_VERBOSE);
            // Loop through the files. Each file represents one deployment
            // descriptor, and hence one bean in our model.
            for (int index = 0; index < files.length; ++index) {
                // process the deployment descriptor in each tool
                for (Iterator i = deploymentTools.iterator(); i.hasNext(); ) {
                    EJBDeploymentTool tool = (EJBDeploymentTool)i.next();
                    tool.processDescriptor(files[index], saxParser);
                }
            }    
        }
        catch (SAXException se) {
            String msg = ""SAXException while creating parser.""
                + ""  Details: ""
                + se.getMessage();
            throw new BuildException(msg, se);
        }
        catch (ParserConfigurationException pce) {
            String msg = ""ParserConfigurationException while creating parser. ""
                       + ""Details: "" + pce.getMessage();
            throw new BuildException(msg, pce);
        }
    } // end of execute()
}
"
org.apache.tools.ant.taskdefs.optional.ejb.GenericDeploymentTool,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
import java.util.*;
import java.util.jar.*;
import java.util.zip.*;
import java.net.*;
import javax.xml.parsers.SAXParser;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
/**
 * A deployment tool which creates generic EJB jars. Generic jars contains
 * only those classes and META-INF entries specified in the EJB 1.1 standard
 *
 * This class is also used as a framework for the creation of vendor specific
 * deployment tools. A number of template methods are provided through which the
 * vendor specific tool can hook into the EJB creation process.
 */
public class GenericDeploymentTool implements EJBDeploymentTool {
    /** Private constants that are used when constructing the standard jarfile */
    protected static final String META_DIR  = ""META-INF/"";
    protected static final String EJB_DD    = ""ejb-jar.xml"";
    /**
     * The configuration from the containing task. This config combined with the 
     * settings of the individual attributes here constitues the complete config for
     * this deployment tool.
     */
    private EjbJar.Config config;
    /** Stores a handle to the directory to put the Jar files in */
    private File destDir;
    /** The classpath to use with this deployment tool. This is appended to 
        any paths from the ejbjar task itself.*/
    private Path classpath;
    /** Instance variable that stores the suffix for the generated jarfile. */
    private String genericJarSuffix = ""-generic.jar"";
    /**
     * The task to which this tool belongs. This is used to access services provided
     * by the ant core, such as logging.
     */
    private Task task;
    /**
     * The classloader generated from the given classpath to load
     * the super classes and super interfaces.
     */
    private ClassLoader classpathLoader = null;
     /**
     * List of files have been loaded into the EJB jar
     */
    private List addedfiles;
    /**
     * Setter used to store the value of destination directory prior to execute()
     * being called.
     * @param inDir the destination directory.
     */
    public void setDestdir(File inDir) {
        this.destDir = inDir;
    }
    /**
     * Get the desitination directory.
     */
    protected File getDestDir() {
        return destDir;
    }
    /**
     * Set the task which owns this tool
     */
    public void setTask(Task task) {
        this.task = task;
    }
    /**
     * Get the task for this tool.
     */
    protected Task getTask() {
        return task;
    }
    /**
     * Get the basename terminator.
     */
    protected EjbJar.Config getConfig() {
        return config;
    }
    /**
     * Returns true, if the meta-inf dir is being explicitly set, false otherwise.
     */
    protected boolean usingBaseJarName() {
        return config.baseJarName != null;
    }
    /**
     * Setter used to store the suffix for the generated jar file.
     * @param inString the string to use as the suffix.
     */
    public void setGenericJarSuffix(String inString) {
        this.genericJarSuffix = inString;
    }
    /**
     * Add the classpath for the user classes
     */
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(task.getProject());
        }
        return classpath.createPath();
    }
    /**
     * Set the classpath to be used for this compilation.
     */
    public void setClasspath(Path classpath) {
        this.classpath = classpath;
    }
    /**
     * Get the classpath by combining the one from the surrounding task, if any
     * and the one from tis tool.
     */
    protected Path getCombinedClasspath() {
        Path combinedPath = classpath;
        if (config.classpath != null) {
            if (combinedPath == null) {
                combinedPath = config.classpath;
            }
            else {
                combinedPath.append(config.classpath);
            }
        }
        return combinedPath;
    }
    protected void log(String message, int level) {
        getTask().log(message, level);
    }
    /**
     * Configure this tool for use in the ejbjar task.
     */
    public void configure(EjbJar.Config config) {
        this.config = config;
        classpathLoader = null;
    }
    /**
     * Utility method that encapsulates the logic of adding a file entry to
     * a .jar file.  Used by execute() to add entries to the jar file as it is
     * constructed.
     * @param jStream A JarOutputStream into which to write the
     *        jar entry.
     * @param inputFile A File from which to read the
     *        contents the file being added.
     * @param logicalFilename A String representing the name, including
     *        all relevant path information, that should be stored for the entry
     *        being added.
     */
    protected void addFileToJar(JarOutputStream jStream,
                                File inputFile,
                                String logicalFilename)
        throws BuildException {
        FileInputStream iStream = null;
        try {
            if (!addedfiles.contains(logicalFilename)) {
                iStream = new FileInputStream(inputFile);
                // Create the zip entry and add it to the jar file
                ZipEntry zipEntry = new ZipEntry(logicalFilename.replace('\\','/'));
                jStream.putNextEntry(zipEntry);
                // Create the file input stream, and buffer everything over
                // to the jar output stream
                byte[] byteBuffer = new byte[2 * 1024];
                int count = 0;
                do {
                    jStream.write(byteBuffer, 0, count);
                    count = iStream.read(byteBuffer, 0, byteBuffer.length);
                } while (count != -1);
                //add it to list of files in jar
                addedfiles.add(logicalFilename);
           }       
        }
        catch (IOException ioe) {
            String msg = ""IOException while adding entry ""
                         + logicalFilename + "" to jarfile from "" + inputFile.getPath() + "".""
                         + ioe.getMessage();
            throw new BuildException(msg, ioe);
        }
        finally {
            // Close up the file input stream for the class file
            if (iStream != null) {
                try {
                    iStream.close();
                }
                catch (IOException closeException) {}
            }
        }
    }
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        return new DescriptorHandler(srcDir);
    }
    public void processDescriptor(String descriptorFileName, SAXParser saxParser) {
        FileInputStream descriptorStream = null;
        try {
            DescriptorHandler handler = getDescriptorHandler(config.srcDir);
            /* Parse the ejb deployment descriptor.  While it may not
             * look like much, we use a SAXParser and an inner class to
             * get hold of all the classfile names for the descriptor.
             */
            descriptorStream = new FileInputStream(new File(config.descriptorDir, descriptorFileName));
            saxParser.parse(new InputSource(descriptorStream), handler);
            Hashtable ejbFiles = handler.getFiles();
            // add in support classes if any
            Project project = task.getProject();
            for (Iterator i = config.supportFileSets.iterator(); i.hasNext();) {
                FileSet supportFileSet = (FileSet)i.next();
                File supportBaseDir = supportFileSet.getDir(project);
                DirectoryScanner supportScanner = supportFileSet.getDirectoryScanner(project);
                supportScanner.scan();
                String[] supportFiles = supportScanner.getIncludedFiles();
                for (int j = 0; j < supportFiles.length; ++j) {
                    ejbFiles.put(supportFiles[j], new File(supportBaseDir, supportFiles[j]));
                }
            }            
            String baseName = """";
            // Work out what the base name is
            if (config.baseJarName != null) {
                baseName = config.baseJarName;
            } else {
                int lastSeparatorIndex = descriptorFileName.lastIndexOf(File.separator);
                int endBaseName = -1;
                if (lastSeparatorIndex != -1) {
                    endBaseName = descriptorFileName.indexOf(config.baseNameTerminator, 
                                                             lastSeparatorIndex);
                }
                else {
                    endBaseName = descriptorFileName.indexOf(config.baseNameTerminator);
                }
                if (endBaseName != -1) {
                    baseName = descriptorFileName.substring(0, endBaseName);
                }
                baseName = descriptorFileName.substring(0, endBaseName);
            }
            // First the regular deployment descriptor
            ejbFiles.put(META_DIR + EJB_DD,
                         new File(config.descriptorDir, descriptorFileName));
            // now the vendor specific files, if any             
            addVendorFiles(ejbFiles, baseName);
            // add any inherited files
            checkAndAddInherited(ejbFiles);
            // Lastly create File object for the Jar files. If we are using
            // a flat destination dir, then we need to redefine baseName!
            if (config.flatDestDir && baseName.length() != 0) {
                int startName = baseName.lastIndexOf(File.separator);
                if (startName == -1) {
                    startName = 0;
                }
                int endName   = baseName.length();
                baseName = baseName.substring(startName, endName);
            }
            File jarFile = getVendorOutputJarFile(baseName);
            // By default we assume we need to build.
            boolean needBuild = true;
            if (jarFile.exists()) {
                long    lastBuild = jarFile.lastModified();
                Iterator fileIter = ejbFiles.values().iterator();
                // Set the need build to false until we find out otherwise.
                needBuild = false;
                // Loop through the files seeing if any has been touched
                // more recently than the destination jar.
                while( (needBuild == false) && (fileIter.hasNext()) ) {
                    File currentFile = (File) fileIter.next();
                    needBuild = ( lastBuild < currentFile.lastModified() );
                    if (needBuild) {
                        log(""Build needed because "" + currentFile.getPath() + "" is out of date"",
                            Project.MSG_VERBOSE);
                    }
                }
            }
            // Check to see if we need a build and start
            // doing the work!
            if (needBuild) {
                // Log that we are going to build...
                log( ""building ""
                              + jarFile.getName()
                              + "" with ""
                              + String.valueOf(ejbFiles.size())
                              + "" files"",
                              Project.MSG_INFO);
                // Use helper method to write the jarfile
                writeJar(baseName, jarFile, ejbFiles);
            }
            else {
                // Log that the file is up to date...
                log(jarFile.toString() + "" is up to date."",
                              Project.MSG_VERBOSE);
            }
        }
        catch (SAXException se) {
            String msg = ""SAXException while parsing '""
                + descriptorFileName.toString()
                + ""'. This probably indicates badly-formed XML.""
                + ""  Details: ""
                + se.getMessage();
            throw new BuildException(msg, se);
        }
        catch (IOException ioe) {
            String msg = ""IOException while parsing'""
                + descriptorFileName.toString()
                + ""'.  This probably indicates that the descriptor""
                + "" doesn't exist. Details: ""
                + ioe.getMessage();
            throw new BuildException(msg, ioe);
        }
        finally {
            if (descriptorStream != null) {
                try {
                    descriptorStream.close();
                }
                catch (IOException closeException) {}
            }
        }
    }
    /**
     * Add any vendor specific files which should be included in the 
     * EJB Jar.
     */
    protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
        // nothing to add for generic tool.
    }
    /**
     * Get the vendor specific name of the Jar that will be output. The modification date
     * of this jar will be checked against the dependent bean classes.
     */
    File getVendorOutputJarFile(String baseName) {
        return new File(destDir, baseName + genericJarSuffix);
    }
    /**
     * Method used to encapsulate the writing of the JAR file. Iterates over the
     * filenames/java.io.Files in the Hashtable stored on the instance variable
     * ejbFiles.
     */
    protected void writeJar(String baseName, File jarfile, Hashtable files) throws BuildException{
        JarOutputStream jarStream = null;
        try {
            // clean the addedfiles Vector 
            addedfiles = new ArrayList();
            /* If the jarfile already exists then whack it and recreate it.
             * Should probably think of a more elegant way to handle this
             * so that in case of errors we don't leave people worse off
             * than when we started =)
             */
            if (jarfile.exists()) {
                jarfile.delete();
            }
            jarfile.getParentFile().mkdirs();
            jarfile.createNewFile();
            String defaultManifest = ""/org/apache/tools/ant/defaultManifest.mf"";
            InputStream in = this.getClass().getResourceAsStream(defaultManifest);
            if ( in == null ) {
                throw new BuildException ( ""Could not find: "" + defaultManifest );
            }
            Manifest manifest = new Manifest(in);
            // Create the streams necessary to write the jarfile
            jarStream = new JarOutputStream(new FileOutputStream(jarfile), manifest);
            jarStream.setMethod(JarOutputStream.DEFLATED);
            // Loop through all the class files found and add them to the jar
            for (Iterator entryIterator = files.keySet().iterator(); entryIterator.hasNext(); ) {
                String entryName = (String) entryIterator.next();
                File entryFile = (File) files.get(entryName);
                log(""adding file '"" + entryName + ""'"",
                              Project.MSG_VERBOSE);
                addFileToJar(jarStream, entryFile, entryName);
                // See if there are any inner classes for this class and add them in if there are
                InnerClassFilenameFilter flt = new InnerClassFilenameFilter(entryFile.getName());
                File entryDir = entryFile.getParentFile();
                String[] innerfiles = entryDir.list(flt);
                for (int i=0, n=innerfiles.length; i < n; i++) {
                    //get and clean up innerclass name
                    entryName = entryName.substring(0, entryName.lastIndexOf(entryFile.getName())-1) + File.separatorChar + innerfiles[i];
                    // link the file
                    entryFile = new File(config.srcDir, entryName);
                    log(""adding innerclass file '"" + entryName + ""'"", 
                            Project.MSG_VERBOSE);
                    addFileToJar(jarStream, entryFile, entryName);
                }
            }
        }
        catch(IOException ioe) {
            String msg = ""IOException while processing ejb-jar file '""
                + jarfile.toString()
                + ""'. Details: ""
                + ioe.getMessage();
            throw new BuildException(msg, ioe);
        }
        finally {
            if (jarStream != null) {
                try {
                    jarStream.close();
                }
                catch (IOException closeException) {}
            }
        }
    } // end of writeJar
    /**
     * Check if a EJB Class Inherits from a Superclass, and if a Remote Interface
     * extends an interface other then javax.ejb.EJBObject directly.  Then add those 
     * classes to the generic-jar so they dont have to added elsewhere.
     *
     */
    protected void checkAndAddInherited(Hashtable checkEntries) throws BuildException
    {
        //Copy hashtable so were not changing the one we iterate through
        Hashtable copiedHash = (Hashtable)checkEntries.clone();
        // Walk base level EJBs and see if they have superclasses or extend extra interfaces which extend EJBObject
        for (Iterator entryIterator = copiedHash.keySet().iterator(); entryIterator.hasNext(); ) 
        {
            String entryName = (String)entryIterator.next();
            File entryFile = (File)copiedHash.get(entryName);
            // only want class files, xml doesnt reflect very well =)
            if (entryName.endsWith("".class""))
            {
                String classname = entryName.substring(0,entryName.lastIndexOf("".class"")).replace(File.separatorChar,'.');
                ClassLoader loader = getClassLoaderForBuild();
                try {
                    Class c = loader.loadClass(classname);
                    // No primatives!!  sanity check, probably not nessesary
                    if (!c.isPrimitive())
                    {
                        if (c.isInterface()) //get as an interface
                        {
                            log(""looking at interface "" + c.getName(),  Project.MSG_VERBOSE);
                            Class[] interfaces = c.getInterfaces();
                            for (int i = 0; i < interfaces.length; i++){
                                log(""     implements "" + interfaces[i].getName(),  Project.MSG_VERBOSE);
                                addInterface(interfaces[i], checkEntries);
                            }
                        }
                        else  // get as a class
                        {
                            log(""looking at class "" + c.getName(),  Project.MSG_VERBOSE);
                            Class s = c.getSuperclass();
                            addSuperClass(c.getSuperclass(), checkEntries);
                        }
                    } //if primative
                }
                catch (ClassNotFoundException cnfe) {
                    log(""Could not load class "" + classname + "" for super class check"", 
                                  Project.MSG_WARN);
                }                            
                catch (NoClassDefFoundError ncdfe) {
                    log(""Could not fully load class "" + classname + "" for super class check"", 
                                  Project.MSG_WARN);
                }                            
            } //if 
        } // while 
    }
    private void addInterface(Class theInterface, Hashtable checkEntries) {
        if (!theInterface.getName().startsWith(""java"")) // do not add system interfaces
        { 
            File interfaceFile = new File(config.srcDir.getAbsolutePath() 
                                        + File.separatorChar 
                                        + theInterface.getName().replace('.',File.separatorChar)
                                        + "".class""
                                        );
            if (interfaceFile.exists() && interfaceFile.isFile())
            {
                checkEntries.put(theInterface.getName().replace('.',File.separatorChar)+"".class"",
                                 interfaceFile);
                Class[] superInterfaces = theInterface.getInterfaces();
                for (int i = 0; i < superInterfaces.length; i++) {
                    addInterface(superInterfaces[i], checkEntries);
                }
            }
        }
    }
    private void addSuperClass(Class superClass, Hashtable checkEntries) {
        if (!superClass.getName().startsWith(""java""))
        {
            File superClassFile = new File(config.srcDir.getAbsolutePath() 
                                            + File.separatorChar 
                                            + superClass.getName().replace('.',File.separatorChar)
                                            + "".class"");
            if (superClassFile.exists() && superClassFile.isFile())
            {
                checkEntries.put(superClass.getName().replace('.',File.separatorChar) + "".class"", 
                                 superClassFile);
                // now need to get super classes and interfaces for this class
                Class[] superInterfaces = superClass.getInterfaces();
                for (int i = 0; i < superInterfaces.length; i++) {
                    addInterface(superInterfaces[i], checkEntries);
                }
                addSuperClass(superClass.getSuperclass(), checkEntries);
            }               
        }
    }
    /**
     * Returns a Classloader object which parses the passed in generic EjbJar classpath.
     * The loader is used to dynamically load classes from javax.ejb.* and the classes 
     * being added to the jar.
     *
     */ 
    protected ClassLoader getClassLoaderForBuild()
    {
        if (classpathLoader != null) {
            return classpathLoader;
        }
        Path combinedClasspath = getCombinedClasspath();
        // only generate a new ClassLoader if we have a classpath
        if (combinedClasspath == null) {
            classpathLoader = getClass().getClassLoader();
        }
        else {
            classpathLoader = new AntClassLoader(getTask().getProject(), combinedClasspath);
        }
        return classpathLoader;
    }
    /**
     * Called to validate that the tool parameters have been configured.
     *
     */
    public void validateConfigured() throws BuildException {
        if (destDir == null) {
            throw new BuildException(""The destdir attribute must be specified"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.InnerClassFilenameFilter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
public class InnerClassFilenameFilter implements FilenameFilter {
    private String baseClassName;
    InnerClassFilenameFilter(String baseclass){
        int extidx = baseclass.lastIndexOf("".class"");
        if (extidx == -1) {
            extidx = baseclass.length()-1;
        }
        baseClassName = baseclass.substring(0,extidx);
    }
    public boolean accept (File Dir, String filename){
        if ((filename.lastIndexOf(""."") != filename.lastIndexOf("".class"")) 
            || (filename.indexOf(baseClassName + ""$"") != 0)) {
            return false;
        }
        return true;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WeblogicDeploymentTool,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
import java.util.jar.*;
import java.util.*;
import java.net.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
import org.apache.tools.ant.taskdefs.Java;
public class WeblogicDeploymentTool extends GenericDeploymentTool {
    public static final String PUBLICID_EJB11
        = ""-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN"";
    public static final String PUBLICID_EJB20
        = ""-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN"";
    public static final String PUBLICID_WEBLOGIC_EJB
        = ""-//BEA Systems, Inc.//DTD WebLogic 5.1.0 EJB//EN"";
    protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION 
        = ""/weblogic/ejb/deployment/xml/ejb-jar.dtd"";
    protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION 
        = ""/weblogic/ejb20/dd/xml/ejb11-jar.dtd"";
    protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION 
        = ""/weblogic/ejb20/dd/xml/ejb20-jar.dtd"";
    protected static final String DEFAULT_WL_DTD_LOCATION 
        = ""/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd"";
    protected static final String WL_DD = ""weblogic-ejb-jar.xml"";
    protected static final String WL_CMP_DD = ""weblogic-cmp-rdbms-jar.xml"";
    /** Instance variable that stores the suffix for the weblogic jarfile. */
    private String jarSuffix = "".jar"";
    /** Instance variable that stores the location of the weblogic DTD file. */
    private String weblogicDTD;
    /** Instance variable that stores the location of the ejb 1.1 DTD file. */
    private String ejb11DTD;
    /** Instance variable that determines whether generic ejb jars are kept. */
    private boolean keepgenerated = false;
    private String additionalArgs = """";
    private boolean keepGeneric = false;
    private String compiler = null;
    private boolean alwaysRebuild = true;
    /**
     * Indicates if the old CMP location convention is to be used.
     */
    private boolean newCMP = false;
    /** The classpath to the weblogic classes. */
    private Path wlClasspath = null;
    /**
     * Get the classpath to the weblogic classpaths
     */
    public Path createWLClasspath() {
        if (wlClasspath == null) {
            wlClasspath = new Path(getTask().getProject());
        }
        return wlClasspath.createPath();
    }
    public void setWLClasspath(Path wlClasspath) {
        this.wlClasspath = wlClasspath;
    }
    /**
     * The compiler (switch <code>-compiler</code>) to use
     */
    public void setCompiler(String compiler) {
        this.compiler = compiler;
    }
    /**
     * Set the rebuild flag to false to only update changes in the
     * jar rather than rerunning ejbc
     */
    public void setRebuild(boolean rebuild) {
        this.alwaysRebuild = rebuild;
    }
    /**
     * Setter used to store the suffix for the generated weblogic jar file.
     * @param inString the string to use as the suffix.
     */
    public void setSuffix(String inString) {
        this.jarSuffix = inString;
    }
    /**
     * Setter used to store the value of keepGeneric
     * @param inValue a string, either 'true' or 'false'.
     */
    public void setKeepgeneric(boolean inValue) {
        this.keepGeneric = inValue;
    }
    /**
     * Sets whether -keepgenerated is passed to ejbc (that is,
     * the .java source files are kept).
     * @param inValue either 'true' or 'false'
     */
    public void setKeepgenerated(String inValue) {
        this.keepgenerated = Boolean.valueOf(inValue).booleanValue();
    }
    /**
     * sets some additional args to send to ejbc.
     */
    public void setArgs(String args) {
        this.additionalArgs = args;
    }
    /**
     * Setter used to store the location of the ejb-jar DTD. This can be a file on the system 
     * or a resource on the classpath. 
     * @param inString the string to use as the DTD location.
     */
    public void setWeblogicdtd(String inString) {
        setEJBdtd(inString);
    }
    /**
     * Setter used to store the location of the weblogic DTD. This can be a file on the system 
     * or a resource on the classpath. 
     * @param inString the string to use as the DTD location.
     */
    public void setWLdtd(String inString) {
        this.weblogicDTD = inString;
    }
    /**
     * Setter used to store the location of the Sun's Generic EJB DTD. 
     * This can be a file on the system or a resource on the classpath. 
     * @param inString the string to use as the DTD location.
     */
    public void setEJBdtd(String inString) {
        this.ejb11DTD = inString;
    }
    /**
     * Set the value of the oldCMP scheme. This is an antonym for
     * newCMP
     */
    public void setOldCMP(boolean oldCMP) {
        this.newCMP = !oldCMP;
    }
    /**
     * Set the value of the newCMP scheme. The old CMP scheme locates the 
     * weblogic CMP descriptor based on the naming convention where the 
     * weblogic CMP file is expected to be named with the bean name as the prefix.
     * 
     * Under this scheme the name of the CMP descriptor does not match the name
     * actually used in the main weblogic EJB descriptor. Also, descriptors which 
     * contain multiple CMP references could not be used.
     *
     */
    public void setNewCMP(boolean newCMP) {
        this.newCMP = newCMP;
    }
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        DescriptorHandler handler = new DescriptorHandler(srcDir);
        // register all the DTDs, both the ones that are known and
        // any supplied by the user
        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL51_EJB11_DTD_LOCATION);
        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL60_EJB11_DTD_LOCATION);
        handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
        handler.registerDTD(PUBLICID_EJB20, DEFAULT_WL60_EJB20_DTD_LOCATION);
        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation)i.next();
            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return handler;                                    
    }
    protected DescriptorHandler getWeblogicDescriptorHandler(final File srcDir) {
        DescriptorHandler handler = 
            new DescriptorHandler(srcDir) {        
                protected void processElement() {
                    if (currentElement.equals(""type-storage"")) {
                        // Get the filename of vendor specific descriptor
                        String fileNameWithMETA = currentText;
                        //trim the META_INF\ off of the file name
                        String fileName = fileNameWithMETA.substring(META_DIR.length(), 
                                                                     fileNameWithMETA.length() );
                        File descriptorFile = new File(srcDir, fileName);
                        ejbFiles.put(fileNameWithMETA, descriptorFile);
                    }
                }
            };
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB, 
                            weblogicDTD == null ? DEFAULT_WL_DTD_LOCATION : weblogicDTD);
        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation)i.next();
            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return handler;                                    
    }
    /**
     * Add any vendor specific files which should be included in the 
     * EJB Jar.
     */
    protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
        String ddPrefix = (usingBaseJarName() ? """" : baseName + getConfig().baseNameTerminator);
        File weblogicDD = new File(getConfig().descriptorDir, ddPrefix + WL_DD);
        if (weblogicDD.exists()) {
            ejbFiles.put(META_DIR + WL_DD,
                         weblogicDD);
        }
        else {
            log(""Unable to locate weblogic deployment descriptor. It was expected to be in "" + 
                weblogicDD.getPath(), Project.MSG_WARN);
            return;
        }
        if (!newCMP) {
            log(""The old method for locating CMP files has been DEPRECATED."", Project.MSG_VERBOSE);
            log(""Please adjust your weblogic descriptor and set newCMP=\""true\"" "" +
                ""to use the new CMP descriptor inclusion mechanism. "", Project.MSG_VERBOSE);
            // The the weblogic cmp deployment descriptor
            File weblogicCMPDD = new File(getConfig().descriptorDir, ddPrefix + WL_CMP_DD);
            if (weblogicCMPDD.exists()) {
                ejbFiles.put(META_DIR + WL_CMP_DD,
                             weblogicCMPDD);
            }
        }
        else {
            // now that we have the weblogic descriptor, we parse the file
            // to find other descriptors needed to deploy the bean.
            // this could be the weblogic-cmp-rdbms.xml or any other O/R
            // mapping tool descriptors.
            try
            {
                File ejbDescriptor = (File)ejbFiles.get(META_DIR + EJB_DD);
                SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
                saxParserFactory.setValidating(true);
                SAXParser saxParser = saxParserFactory.newSAXParser();
                DescriptorHandler handler = getWeblogicDescriptorHandler(ejbDescriptor.getParentFile());
                saxParser.parse(new InputSource
                                (new FileInputStream
                                (weblogicDD)),
                                handler);
                Hashtable ht = handler.getFiles();
                Enumeration e = ht.keys();
                while(e.hasMoreElements()){
                    String key = (String)e.nextElement();
                    ejbFiles.put(key, ht.get(key));
                }
            }
            catch(Exception e)
            { 
                String msg = ""Exception while adding Vendor specific files: "" + e.toString();
                throw new BuildException(msg, e);
            }
        }
    }
    /**
     * Get the vendor specific name of the Jar that will be output. The modification date
     * of this jar will be checked against the dependent bean classes.
     */
    File getVendorOutputJarFile(String baseName) {
        return new File(getDestDir(), baseName + jarSuffix);
    }
    /**
     * Helper method invoked by execute() for each WebLogic jar to be built.
     * Encapsulates the logic of constructing a java task for calling
     * weblogic.ejbc and executing it.
     * @param sourceJar java.io.File representing the source (EJB1.1) jarfile.
     * @param destJar java.io.File representing the destination, WebLogic
     *        jarfile.
     */
    private void buildWeblogicJar(File sourceJar, File destJar) {
        org.apache.tools.ant.taskdefs.Java javaTask = null;
        try {
            String args = additionalArgs;
            if (keepgenerated) {
                args += "" -keepgenerated"";
            }
            if (compiler != null) {
                args += "" -compiler "" + compiler;
            }
            args += "" "" + sourceJar.getPath() + "" "" + destJar.getPath();
            javaTask = (Java) getTask().getProject().createTask(""java"");
            javaTask.setTaskName(""ejbc"");
            javaTask.setClassname(""weblogic.ejbc"");
            Commandline.Argument arguments = javaTask.createArg();
            arguments.setLine(args);
            Path classpath = wlClasspath;
            if (classpath == null) {
                classpath = getCombinedClasspath();
            }
            if (classpath != null) {
                javaTask.setClasspath(classpath);
                javaTask.setFork(true);
            }
            else {
                javaTask.setFork(true);
            }
            log(""Calling weblogic.ejbc for "" + sourceJar.toString(),
                          Project.MSG_VERBOSE);
            javaTask.execute();
        }
        catch (Exception e) {
            // Have to catch this because of the semantics of calling main()
            String msg = ""Exception while calling ejbc. Details: "" + e.toString();
            throw new BuildException(msg, e);
        }
    }
    /**
     * Method used to encapsulate the writing of the JAR file. Iterates over the
     * filenames/java.io.Files in the Hashtable stored on the instance variable
     * ejbFiles.
     */
    protected void writeJar(String baseName, File jarFile, Hashtable files) throws BuildException {
        // need to create a generic jar first.
        File genericJarFile = super.getVendorOutputJarFile(baseName);
        super.writeJar(baseName, genericJarFile, files);
        if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile))
        {
            buildWeblogicJar(genericJarFile, jarFile);
        }
        if (!keepGeneric) {
             log(""deleting generic jar "" + genericJarFile.toString(),
                           Project.MSG_VERBOSE);
             genericJarFile.delete();
        }
    }
    /**
     * Called to validate that the tool parameters have been configured.
     *
     */
    public void validateConfigured() throws BuildException {
        super.validateConfigured();
    }
    /**
     * Helper method to check to see if a weblogic EBJ1.1 jar needs to be rebuilt using 
     * ejbc.  Called from writeJar it sees if the ""Bean"" classes  are the only thing that needs
     * to be updated and either updates the Jar with the Bean classfile or returns true,
     * saying that the whole weblogic jar needs to be regened with ejbc.  This allows faster 
     * build times for working developers.
     * <p>
     * The way weblogic ejbc works is it creates wrappers for the publicly defined methods as 
     * they are exposed in the remote interface.  If the actual bean changes without changing the 
     * the method signatures then only the bean classfile needs to be updated and the rest of the 
     * weblogic jar file can remain the same.  If the Interfaces, ie. the method signatures change 
     * or if the xml deployment dicriptors changed, the whole jar needs to be rebuilt with ejbc.  
     * This is not strictly true for the xml files.  If the JNDI name changes then the jar doesnt
     * have to be rebuild, but if the resources references change then it does.  At this point the
     * weblogic jar gets rebuilt if the xml files change at all.
     *
     * @param genericJarFile java.io.File The generic jar file.
     * @param weblogicJarFile java.io.File The weblogic jar file to check to see if it needs to be rebuilt.
     */
    protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile)
    {
        boolean rebuild = false;
        JarFile genericJar = null;
        JarFile wlJar = null;
        File newWLJarFile = null;
        JarOutputStream newJarStream = null;
        try 
        {
            log(""Checking if weblogic Jar needs to be rebuilt for jar "" + weblogicJarFile.getName(),
                Project.MSG_VERBOSE);
            // Only go forward if the generic and the weblogic file both exist
            if (genericJarFile.exists() && genericJarFile.isFile() 
                && weblogicJarFile.exists() && weblogicJarFile.isFile())
            {
                //open jar files
                genericJar = new JarFile(genericJarFile);
                wlJar = new JarFile(weblogicJarFile);
                Hashtable genericEntries = new Hashtable();
                Hashtable wlEntries = new Hashtable();
                Hashtable replaceEntries = new Hashtable();
                //get the list of generic jar entries
                for (Enumeration e = genericJar.entries(); e.hasMoreElements();)
                {
                    JarEntry je = (JarEntry)e.nextElement();
                    genericEntries.put(je.getName().replace('\\', '/'), je);
                }
                //get the list of weblogic jar entries
                for (Enumeration e = wlJar.entries() ; e.hasMoreElements();)
                {
                    JarEntry je = (JarEntry)e.nextElement();
                    wlEntries.put(je.getName(), je);
                }
                //Cycle Through generic and make sure its in weblogic
                ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);
                for (Enumeration e = genericEntries.keys(); e.hasMoreElements();)
                {
                    String filepath = (String)e.nextElement();
                    if (wlEntries.containsKey(filepath))    // File name/path match
                    {
                        // Check files see if same
                        JarEntry genericEntry = (JarEntry)genericEntries.get(filepath);
                        JarEntry wlEntry = (JarEntry)wlEntries.get(filepath);
                        if ((genericEntry.getCrc() !=  wlEntry.getCrc())  || // Crc's Match
                            (genericEntry.getSize() != wlEntry.getSize()) ) // Size Match
                        {
                            if (genericEntry.getName().endsWith("".class""))
                            {
                                //File are different see if its an object or an interface
                                String classname = genericEntry.getName().replace(File.separatorChar,'.');
                                classname = classname.substring(0,classname.lastIndexOf("".class""));
                                Class genclass = genericLoader.loadClass(classname);
                                if (genclass.isInterface())
                                {
                                    //Interface changed   rebuild jar.
                                    log(""Interface "" + genclass.getName() + "" has changed"",Project.MSG_VERBOSE);
                                    rebuild = true;
                                    break;
                                }
                                else
                                {
                                    //Object class Changed   update it.
                                    replaceEntries.put(filepath, genericEntry);
                                }
                            }
                            else
                            {
                                // is it the manifest. If so ignore it
                                if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
                                    //File other then class changed   rebuild
                                    log(""Non class file "" + genericEntry.getName() + "" has changed"",Project.MSG_VERBOSE);
                                    rebuild = true;
                                }
                                break;
                            }
                        }
                    }
                    else // a file doesnt exist rebuild
                    {
                        log(""File "" + filepath + "" not present in weblogic jar"",Project.MSG_VERBOSE);
                        rebuild =  true;
                        break;
                    }
                }
                if (!rebuild)
                {
                    log(""No rebuild needed - updating jar"",Project.MSG_VERBOSE);
                    newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + "".temp"");
                    if (newWLJarFile.exists()) {
                        newWLJarFile.delete();
                    }
                    newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile));
                    newJarStream.setLevel(0);
                    //Copy files from old weblogic jar
                    for (Enumeration e = wlEntries.elements() ; e.hasMoreElements();)
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        InputStream is;
                        JarEntry je = (JarEntry)e.nextElement();
                        if (je.getCompressedSize() == -1 ||
                                je.getCompressedSize() == je.getSize()) {
                            newJarStream.setLevel(0);
                        }
                        else {
                            newJarStream.setLevel(9);
                        }
                        // Update with changed Bean class
                        if (replaceEntries.containsKey(je.getName()))
                        {
                            log(""Updating Bean class from generic Jar "" + je.getName(),Project.MSG_VERBOSE);
                            // Use the entry from the generic jar
                            je = (JarEntry)replaceEntries.get(je.getName());
                            is = genericJar.getInputStream(je);
                        }   
                        else  //use fle from original weblogic jar
                        {
                            is = wlJar.getInputStream(je);
                        }
                        newJarStream.putNextEntry(new JarEntry(je.getName()));
                        while ((bytesRead = is.read(buffer)) != -1)
                        {
                            newJarStream.write(buffer,0,bytesRead);
                        }
                        is.close();
                    }
                }
                else
                {
                    log(""Weblogic Jar rebuild needed due to changed interface or XML"",Project.MSG_VERBOSE);
                }       
            }
            else
            {
                rebuild = true;
            }
        }
        catch(ClassNotFoundException cnfe)
        {
            String cnfmsg = ""ClassNotFoundException while processing ejb-jar file""
                + "". Details: ""
                + cnfe.getMessage();
            throw new BuildException(cnfmsg, cnfe);
        }
        catch(IOException ioe) {
            String msg = ""IOException while processing ejb-jar file ""
                + "". Details: ""
                + ioe.getMessage();
            throw new BuildException(msg, ioe);
        }
        finally {
            // need to close files and perhaps rename output
            if (genericJar != null) {
                try {
                    genericJar.close();
                }
                catch (IOException closeException) {}
            }
            if (wlJar != null) {
                try {
                    wlJar.close();
                }
                catch (IOException closeException) {}
            }
            if (newJarStream != null) {
                try {
                    newJarStream.close();
                }
                catch (IOException closeException) {}
                weblogicJarFile.delete();
                newWLJarFile.renameTo(weblogicJarFile);
                if (!weblogicJarFile.exists()) {
                    rebuild = true;
                }
            }
        }
        return rebuild;
    }
    /**
    * Helper method invoked by isRebuildRequired to get a ClassLoader for 
    * a Jar File passed to it.
    *
    * @param classjar java.io.File representing jar file to get classes from.
    */
    protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException
    {
        Path lookupPath = new Path(getTask().getProject());
        lookupPath.setLocation(classjar);
        Path classpath = getCombinedClasspath();
        if (classpath != null) {
            lookupPath.append(classpath);
        }
        return new AntClassLoader(getTask().getProject(), lookupPath);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WeblogicTOPLinkDeploymentTool,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
public class WeblogicTOPLinkDeploymentTool extends WeblogicDeploymentTool {
    private static final String TL_DTD_LOC = ""http://www.objectpeople.com/tlwl/dtd/toplink-cmp_2_5_1.dtd"";
    private String toplinkDescriptor;
    private String toplinkDTD;
    /**
     * Setter used to store the name of the toplink descriptor.
     * @param inString the string to use as the descriptor name.
     */
    public void setToplinkdescriptor(String inString) {
        this.toplinkDescriptor = inString;
    }
    /**
     * Setter used to store the location of the toplink DTD file.
     * This is expected to be an URL (file or otherwise). If running this on NT using a file URL, the safest 
     * thing would be to not use a drive spec in the URL and make sure the file resides on the drive that 
     * ANT is running from.  This will keep the setting in the build XML platform independent.
     * @param inString the string to use as the DTD location.
     */
    public void setToplinkdtd(String inString) {
        this.toplinkDTD = inString;
    }
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        DescriptorHandler handler = super.getDescriptorHandler(srcDir);
        if (toplinkDTD != null) {
            handler.registerDTD(""-//The Object People, Inc.//DTD TOPLink for WebLogic CMP 2.5.1//EN"",
                                toplinkDTD);
        } else {
            handler.registerDTD(""-//The Object People, Inc.//DTD TOPLink for WebLogic CMP 2.5.1//EN"",
                                TL_DTD_LOC);
        }
        return handler;                                    
    }
    /**
     * Add any vendor specific files which should be included in the 
     * EJB Jar.
     */
    protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
        super.addVendorFiles(ejbFiles, baseName);
        // Then the toplink deployment descriptor
        // Setup a naming standard here?.
        File toplinkDD = null;
        if (usingBaseJarName()) {
            toplinkDD = new File(getConfig().descriptorDir, toplinkDescriptor);
        }
        else {
            String ddPrefix = baseName + getConfig().baseNameTerminator;
            File actualDir = (new File(getConfig().descriptorDir, ddPrefix)).getParentFile();
            toplinkDD = new File(actualDir, toplinkDescriptor);
        }
        if (toplinkDD.exists()) {
            ejbFiles.put(META_DIR + toplinkDescriptor,
                         toplinkDD);
        }
        else {
            log(""Unable to locate toplink deployment descriptor. It was expected to be in "" + 
                toplinkDD.getPath(), Project.MSG_WARN);
        }                
    }
    /**
     * Called to validate that the tool parameters have been configured.
     *
     */
    public void validateConfigured() throws BuildException {
        super.validateConfigured();
        if (toplinkDescriptor == null) {
            throw new BuildException( ""The toplinkdescriptor attribute must be specified"" );
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WLRun,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000, 2001 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Execute a Weblogic server.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class WLRun extends Task {
    static protected final String DEFAULT_WL51_POLICY_FILE = ""weblogic.policy"";
    static protected final String DEFAULT_WL60_POLICY_FILE = ""lib/weblogic.policy"";
    static protected final String DEFAULT_PROPERTIES_FILE = ""weblogic.properties"";
    /**
     * The classpath to be used when running the Java VM. It must contain the weblogic
     * classes <b>and</b> the implementation classes of the home and remote interfaces.
     */
    private Path classpath;
    /**
     * The weblogic classpath to the be used when running weblogic.
     */
    private Path weblogicClasspath;
    private String weblogicMainClass = ""weblogic.Server"";
    /**
     * Addional arguments to pass to the JVM used to run weblogic
     */
    private String additionalArgs = """";
    /**
     * The security policy to use when running the weblogic server
     */
    private String securityPolicy;
    /**
     * The weblogic system home directory
     */
    private File weblogicSystemHome;
    /**
     * The weblogic domain
     */
    private String weblogicDomainName;
    /**
     * The name of the weblogic server - used to select the server's directory in the 
     * weblogic home directory.
     */
    private String weblogicSystemName = ""myserver"";
    /**
     * The file containing the weblogic properties for this server.
     */
    private String weblogicPropertiesFile = null;
    /**
     * additional args to pass to the spawned jvm
     */
    private String additionalJvmArgs = """";
    /**
     * The location of the BEA Home under which this server is run.
     * WL6 only
     */
    private File beaHome = null;
    /**
     * The management username
     */
    private String managementUsername = ""system"";
    /**
     * The management password
     */
    private String managementPassword = null;
    /**
     * The provate key password - used for SSL
     */
    private String pkPassword = null;
    /**
     * Add the classpath for the user classes
     */
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }
        return classpath.createPath();
    }
    /**
     * Get the classpath to the weblogic classpaths
     */
    public Path createWLClasspath() {
        if (weblogicClasspath == null) {
            weblogicClasspath = new Path(project);
        }
        return weblogicClasspath.createPath();
    }
    /**
     * Do the work.
     *
     * The work is actually done by creating a separate JVM to run a helper task. 
     * This approach allows the classpath of the helper task to be set. Since the 
     * weblogic tools require the class files of the project's home and remote 
     * interfaces to be available in the classpath, this also avoids having to 
     * start ant with the class path of the project it is building.
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        if (weblogicSystemHome == null) {
            throw new BuildException(""weblogic home must be set"");
        }
        if (!weblogicSystemHome.isDirectory()) {
            throw new BuildException(""weblogic home directory "" + weblogicSystemHome.getPath() + 
                                     "" is not valid"");
        }
        if (beaHome != null) {
            executeWLS6();
        }
        else {
            executeWLS();
        }
    }
    private void executeWLS6() {
        if (!beaHome.isDirectory()) {
            throw new BuildException(""BEA home "" + beaHome.getPath() + 
                                     "" is not valid"");
        }
        File securityPolicyFile = null;
        if (securityPolicy == null) {
            securityPolicyFile = new File(weblogicSystemHome, DEFAULT_WL60_POLICY_FILE);
        }
        else {
            securityPolicyFile = new File(weblogicSystemHome, securityPolicy);
        }
        File configFile = new File(weblogicSystemHome, ""config/"" + weblogicDomainName + ""/config.xml"");
        if (!configFile.exists()) {
            throw new BuildException(""Server config file "" + configFile + "" not found."");
        }
        if (managementPassword == null) {
            throw new BuildException(""You must supply a management password to start the server"");
        }
        Java weblogicServer = (Java)project.createTask(""java"");
        weblogicServer.setTaskName(getTaskName());
        weblogicServer.setFork(true);
        weblogicServer.setDir(weblogicSystemHome);
        weblogicServer.setClassname(weblogicMainClass);
        String jvmArgs = additionalJvmArgs;
        jvmArgs += "" -Dweblogic.Domain="" + weblogicDomainName;
        jvmArgs += "" -Dweblogic.Name="" + weblogicSystemName;
        jvmArgs += "" -Dweblogic.system.home="" + weblogicSystemHome;
        jvmArgs += "" -Dbea.home="" + beaHome;
        jvmArgs += "" -Djava.security.policy=="" + securityPolicyFile;
        jvmArgs += "" -Dweblogic.management.username="" + managementUsername;
        jvmArgs += "" -Dweblogic.management.password="" + managementPassword;
        if (pkPassword != null) {
            jvmArgs += "" -Dweblogic.pkpassword="" + pkPassword;
        }
        weblogicServer.createJvmarg().setLine(jvmArgs);
        weblogicServer.createArg().setLine(additionalArgs);
        if (classpath != null) {
            weblogicServer.setClasspath(classpath);                         
        }
        if (weblogicServer.executeJava() != 0) {                         
            throw new BuildException(""Execution of weblogic server failed"");
        }
     }
    private void executeWLS() {
        File propertiesFile = null;
        if (weblogicPropertiesFile == null) {
            propertiesFile = new File(weblogicSystemHome, DEFAULT_PROPERTIES_FILE);
        }
        else {
            propertiesFile = new File(weblogicSystemHome, weblogicPropertiesFile);
        }
        if (!propertiesFile.exists()) {
            throw new BuildException(""Properties file "" + weblogicPropertiesFile +
                                     "" not found in weblogic home "" + weblogicSystemHome);
        }
        File securityPolicyFile = null;
        if (securityPolicy == null) {
            securityPolicyFile = new File(weblogicSystemHome, DEFAULT_WL51_POLICY_FILE);
        }
        else {
            securityPolicyFile = new File(weblogicSystemHome, securityPolicy);
        }
        if (!securityPolicyFile.exists()) {
            throw new BuildException(""Security policy "" + securityPolicyFile +
                                     "" was not found."");
        }
        Java weblogicServer = (Java)project.createTask(""java"");
        weblogicServer.setTaskName(getTaskName());
        weblogicServer.setFork(true);
        weblogicServer.setClassname(weblogicMainClass);
        String jvmArgs = additionalJvmArgs;
        if (weblogicClasspath != null) {
            jvmArgs += "" -Dweblogic.class.path="" + weblogicClasspath;
        }
        jvmArgs += "" -Djava.security.manager -Djava.security.policy=="" + securityPolicyFile;
        jvmArgs += "" -Dweblogic.system.home="" + weblogicSystemHome;
        jvmArgs += "" -Dweblogic.system.name="" + weblogicSystemName;
        jvmArgs += "" -Dweblogic.system.propertiesFile="" + weblogicPropertiesFile;
        weblogicServer.createJvmarg().setLine(jvmArgs);
        weblogicServer.createArg().setLine(additionalArgs);
        if (classpath != null) {
            weblogicServer.setClasspath(classpath);                         
        }
        if (weblogicServer.executeJava() != 0) {                         
            throw new BuildException(""Execution of weblogic server failed"");
        }
    }
    /**
     * Set the classpath to be used for this execution.
     *
     * @param s the classpath to use when executing the weblogic server.
     */
    public void setClasspath(Path classpath) {
        this.classpath = classpath;
    }
    /**
     * Set the weblogic classpath.
     *
     * The weblogic classpath is used by weblogic to support dynamic class loading.
     *
     * @param weblogicClasspath the weblogic classpath
     */
    public void setWlclasspath(Path weblogicClasspath) {
        this.weblogicClasspath = weblogicClasspath;
    }
    /**
     * Set the security policy for this invocation of weblogic.
     *
     * @param securityPolicy the security policy to use.
     */
    public void setPolicy(String securityPolicy) {
        this.securityPolicy = securityPolicy;
    }
    /**
     * The location where weblogic lives.
     *
     * @param weblogicHome the home directory of weblogic.
     *
     */
    public void setHome(File weblogicHome) {
        weblogicSystemHome = weblogicHome;
    }
    /**
     * The location of the BEA Home.
     *
     * @param beaHome the BEA Home directory.
     *
     */
    public void setBEAHome(File beaHome) {
        this.beaHome = beaHome;
    }
    /**
     * Set the name of the server to run
     *
     * @param systemName the name of the server.
     */
    public void setName(String serverName) {
        this.weblogicSystemName = serverName;
    }
    /**
     * Set the Domain to run in
     *
     * @param domain the domain
     */
    public void setDomain(String domain) {
        this.weblogicDomainName = domain;
    }
    /**
     * Set the properties file to use.
     *
     * The location of the properties file is relative to the weblogi system home
     *
     * @param propertiesFilename the properties file name
     */
    public void setProperties(String propertiesFilename) {
        this.weblogicPropertiesFile = propertiesFilename;
    }
    /**
     * Set the additional arguments to pass to the weblogic JVM
     * @param args the arguments to be passed to the JVM
     */
    public void setJvmargs(String args) {
        this.additionalJvmArgs = args;
    }
    /**
     * Set the management username to run the server
     *
     * @param username the management username of the server.
     */
    public void setUsername(String username) {
        this.managementUsername = username;
    }
    /**
     * Set the management password of the server
     *
     * @param password the management pasword of the server.
     */
    public void setPassword(String password) {
        this.managementPassword = password;
    }
    /**
     * Set the private key password so the server can decrypt the SSL private key file.
     *
     * @param pkpassword the private key password,
     */
    public void setPKPassword(String pkpassword) {
        this.pkPassword = pkpassword;
    }
    public void setArgs(String args) {
        additionalArgs = args;
    }
    public void setWeblogicMainClass(String c) {
        weblogicMainClass = c;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WLStop,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ejb;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Shutdown a Weblogic server.
 *
 * @author <a href=""mailto:conor@cortexebusiness.com.au"">Conor MacNeill</a>, Cortex ebusiness Pty Limited
 */
public class WLStop extends Task {
    /**
     * The classpath to be used. It must contains the weblogic.Admin class.
     */
    private Path classpath;
    /**
     * The weblogic username to use to request the shutdown.
     */
    private String username;
    /**
     * The password to use to shutdown the weblogic server.
     */
    private String password;
    /**
     * The URL which the weblogic server is listening on.
     */
    private String serverURL;
    /**
     * The delay (in seconds) to wait before shutting down.
     */
    private int delay = 0;
    /**
     * The location of the BEA Home under which this server is run.
     * WL6 only
     */
    private File beaHome = null;
    /**
     * Do the work.
     *
     * The work is actually done by creating a separate JVM to run the weblogic admin task
     * This approach allows the classpath of the helper task to be set. 
     *
     * @exception BuildException if someting goes wrong with the build
     */
    public void execute() throws BuildException {
        if (username == null || password == null) {
            throw new BuildException(""weblogic username and password must both be set"");
        }
        if (serverURL == null) {
            throw new BuildException(""The url of the weblogic server must be provided."");
        }
        Java weblogicAdmin = (Java)project.createTask(""java"");
        weblogicAdmin.setFork(true);
        weblogicAdmin.setClassname(""weblogic.Admin"");
        String args;
        if (beaHome == null) {
            args = serverURL + "" SHUTDOWN "" + username + "" "" + password + "" "" + delay;
        }
        else {
            args = "" -url "" + serverURL + 
                   "" -username "" + username +
                   "" -password "" + password +
                   "" SHUTDOWN "" + "" "" + delay;
        }            
        weblogicAdmin.setArgs(args);
        weblogicAdmin.setClasspath(classpath);                         
        weblogicAdmin.execute();
    }
    /**
     * Set the classpath to be used for this compilation.
     *
     * @param s the classpath to use when executing the weblogic admin task.
     */
    public void setClasspath(Path path) {
        this.classpath = path;
    }
    /**
     * Add the classpath for the user classes
     */
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }
        return classpath.createPath();
    }
    /**
     * Set the username to use to request shutdown of the server.
     *
     * @param s the username.
     */
    public void setUser(String s) {
        this.username = s;
    }
    /**
     * Set the password to use to request shutdown of the server.
     *
     * @param s the password.
     */
    public void setPassword(String s) {
        this.password = s;
    }
    /**
     * Set the URL to which the weblogic server is listening.
     *
     * @param s the url.
     */
    public void setUrl(String s) {
        this.serverURL = s;
    }
    /**
     * Set the delay (in seconds) before shutting down the server.
     *
     * @param s the selay.
     */
    public void setDelay(String s) {
        delay = Integer.parseInt(s);
    }
    /**
     * The location of the BEA Home.
     *
     * @param beaHome the BEA Home directory.
     *
     */
    public void setBEAHome(File beaHome) {
        this.beaHome = beaHome;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJAntTool,"package org.apache.tools.ant.taskdefs.optional.ide;
/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Tomcat"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
import com.ibm.ivj.util.base.Project;
import com.ibm.ivj.util.base.ToolData;
import com.ibm.ivj.util.base.IvjException;
import org.apache.tools.ant.BuildException;
/**
 * This class is the equivalent to org.apache.tools.ant.Main for the
 * VAJ tool environment. It's main is called when the user selects
 * Tools->Ant Build from the VAJ project menu.
 * Additionally this class provides methods to save build info for
 * a project in the repository and load it from the repository
 *
 * @author: Wolf Siberski
 */
public class VAJAntTool {
	private static final String TOOL_DATA_KEY = ""AntTool"";
/**
 * Loads the BuildInfo for the specified VAJ project from the
 * tool data for this project.
 * If there is no build info stored for that project, a new
 * default BuildInfo is returned
 * 
 * @return BuildInfo buildInfo build info for the specified project
 * @param projectName String project name
 */
public static VAJBuildInfo loadBuildData(String projectName) {
	VAJBuildInfo result = null;
	try {
		Project project = VAJUtil.getWorkspace().loadedProjectNamed( projectName );
		if ( project.testToolRepositoryData(TOOL_DATA_KEY) ) {
			ToolData td = project.getToolRepositoryData(TOOL_DATA_KEY);
			String data = (String)td.getData();
			result = VAJBuildInfo.parse( data );
		} else {
			result = new VAJBuildInfo();
		}
		result.setVAJProjectName( projectName );
	} catch (Throwable t) {
		System.out.println(""BuildInfo for Project "" + projectName + 
			"" could not be loaded"" + t);
		throw new BuildException(t);
	}
	return result;
}
/**
 * Starts the application.
 * @param args an array of command-line arguments
 */
public static void main(java.lang.String[] args) {
	VAJBuildInfo info;
	if ( args.length >= 2 && args[1] instanceof String ) {
		String projectName = (String)args[1];
		info = loadBuildData( projectName );
	} 
	else {
		info = new VAJBuildInfo();
	}
	VAJAntToolGUI mainFrame = new VAJAntToolGUI( info );
	mainFrame.show();
}
/**
 * Saves the BuildInfo for a project in the VAJ repository.
 * @param info BuildInfo build info to save
 */
public static void saveBuildData(VAJBuildInfo info) {
	String data = info.asDataString();
	try {
		ToolData td = new ToolData( TOOL_DATA_KEY, data );
		VAJUtil.getWorkspace().loadedProjectNamed( info.getVAJProjectName() ).setToolRepositoryData( td );
	} catch (Throwable t) {
		throw new BuildException(""BuildInfo for Project "" + info.getVAJProjectName() + 
			"" could not be saved"", t);
	}
}
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJAntToolGUI,"package org.apache.tools.ant.taskdefs.optional.ide;
/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Tomcat"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
import java.util.Vector;
import java.awt.Frame;
import java.awt.Dialog;
import java.awt.Panel;
import java.awt.MenuBar;
import java.awt.Menu;
import java.awt.MenuItem;
import java.awt.Label;
import java.awt.TextField;
import java.awt.TextArea;
import java.awt.List;
import java.awt.Choice;
import java.awt.Button;
import java.awt.FileDialog;
import java.awt.FlowLayout;
import java.awt.BorderLayout;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.Font;
import java.awt.SystemColor;
import java.awt.event.ActionListener;
import java.awt.event.ItemListener;
import java.awt.event.TextListener;
import java.awt.event.WindowListener;
import java.awt.event.ActionEvent;
import java.awt.event.ItemEvent;
import java.awt.event.TextEvent;
import java.awt.event.WindowEvent;
import java.beans.PropertyChangeListener;
import org.apache.tools.ant.Main;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.Project;
/**
 * This is a simple grafical user interface to provide the information needed by ANT and
 * to start the build-process within IBM VisualAge for Java.
 * <p>
 * I was using AWT to make it independent from the JDK-version. Please don't ask me for a Swing-version:
 * I am very familiar with Swing and I really think that it's not necessary for such a simple gui!
 * <p>
 * It is completely developed in VAJ using the visual composition editor. About 90% of the code is generated by VAJ,
 * but in fact I did a lot of <i>code-beautification</i> ;-).
 * <p>
 * @version 1.0 h
 * @author: Christoph Wilhelms, TUI Infotec GmbH
 */
public class VAJAntToolGUI extends Frame {
	/**
	 * Members 
	 */
	private VAJBuildLogger logger = new VAJBuildLogger();
	private String lineSeparator = ""\r\n"";
	private PrivateEventHandler iEventHandler = new PrivateEventHandler();
	/**
	 * Members of the main-window
	 */
	// main model
	private VAJBuildInfo iBuildInfo = null;
	// Menue
	private MenuBar iAntMakeMenuBar = null;
	private Menu iFileMenu = null;
	private MenuItem iSaveMenuItem = null;
	private MenuItem iMenuSeparator = null;
	private MenuItem iShowLogMenuItem = null;
	private Menu iHelpMenu = null;
	private MenuItem iAboutMenuItem = null;
	// Container
	private Panel iContentsPane = null;
	private Panel iOptionenPanel = null;
	private Panel iCommandButtonPanel = null;
	private FlowLayout iCommandButtonPanelFlowLayout = null;
	// Project name
	private Label iProjectLabel = null;
	private Label iProjectText = null;
	// XML-file 
	private Label iBuildFileLabel = null;
	private TextField iBuildFileTextField = null;
	private boolean iConnPtoP2Aligning = false;
	private Button iBrowseButton = null;
	private FileDialog iFileDialog = null;
	// Options
	private Choice iMessageOutputLevelChoice = null;
	private Label iMessageOutputLevelLabel = null;
	private Label iTargetLabel = null;
	private List iTargetList = null;
	// Command-buttons
	private Button iBuildButton = null;
	private Button iReloadButton = null;	
	private Button iCloseButton = null;
	/**
	 * log-Window
	 */
	// Container
	private Frame iMessageFrame = null;
	private Panel iMessageCommandPanel = null;
	private Panel iMessageContentPanel = null;
	// Components
	private TextArea iMessageTextArea = null;
	private Button iMessageOkButton = null;
	private Button iMessageClearLogButton = null;
	/**
	 * About-dialog
	 */
	// Container
	private Dialog iAboutDialog = null;
	private Panel iAboutDialogContentPanel = null;
	private Panel iAboutInfoPanel = null;
	private Panel iAboutCommandPanel = null;
	// Labels
	private Label iAboutTitleLabel = null;
	private Label iAboutDevLabel = null;
	private Label iAboutContactLabel = null;
	// Buttons
	private Button iAboutOkButton = null;
	/**
	 * This internal BuildLogger, to be honest, is just a BuildListener. 
	 * It does nearly the same as the DefaultLogger, but uses the Loggin-Window for output.
	 */
	private class VAJBuildLogger implements BuildListener {
		private long startTime = System.currentTimeMillis();
		/**
		 * VAJBuildLogger constructor comment.
		 */
		public VAJBuildLogger() {
			super();
		}
		/**
		 *  Fired after the last target has finished. This event
		 *  will still be thrown if an error occured during the build.
		 *
		 *  @see BuildEvent#getException()
		 */
		public void buildFinished(BuildEvent event) {
			Throwable error = event.getException();
			if (error == null) {
				getMessageTextArea().append(lineSeparator + ""BUILD SUCCESSFUL"");
			}
			else {
				getMessageTextArea().append(lineSeparator + ""BUILD FAILED"" + lineSeparator);
				if (error instanceof BuildException) {
					getMessageTextArea().append(error.toString());
					Throwable nested = ((BuildException)error).getException();
					if (nested != null) {
						nested.printStackTrace(System.err);
					}
				}
				else {
					error.printStackTrace(System.err);
				}
			}
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
		/**
		 *  Fired before any targets are started.
		 */
		public void buildStarted(BuildEvent event) {
			startTime = System.currentTimeMillis();
			getMessageTextArea().append(lineSeparator);
		}
		/**
		 *  Fired whenever a message is logged.
		 *
		 *  @see BuildEvent#getMessage()
		 *  @see BuildEvent#getPriority()
		 */
		public void messageLogged(BuildEvent event) {
			if (event.getPriority() <= getBuildInfo().getOutputMessageLevel()) {
				String msg = """";
				if (event.getTask() != null)
					msg = ""["" + event.getTask().getTaskName() + ""] "";
				getMessageTextArea().append(lineSeparator + msg + event.getMessage());
			}
		}
		/**
		 *  Fired when a target has finished. This event will
		 *  still be thrown if an error occured during the build.
		 *
		 *  @see BuildEvent#getException()
		 */
		public void targetFinished(BuildEvent event) {
		}
		/**
		 *  Fired when a target is started.
		 *
		 *  @see BuildEvent#getTarget()
		 */
		public void targetStarted(BuildEvent event) {
			if (getBuildInfo().getOutputMessageLevel() <= Project.MSG_INFO) {
				getMessageTextArea().append(lineSeparator + event.getTarget().getName() + "":"");
			}
		}
		/**
		 *  Fired when a task has finished. This event will still
		 *  be throw if an error occured during the build.
		 *
		 *  @see BuildEvent#getException()
		 */
		public void taskFinished(BuildEvent event) {
		}
		/**
		 *  Fired when a task is started.
		 *
		 *  @see BuildEvent#getTask()
		 */
		public void taskStarted(BuildEvent event) {
		}
		/**
		 * Chris: HACK: remove when Ant-Refactoring is finished!
		 */
		public void buildSuccessful() {
			getMessageTextArea().append(lineSeparator + ""BUILD SUCCESSFUL"");
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
		/**
		 * Chris: HACK: remove when Ant-Refactoring is finished!
		 */
		public void buildFailed(Throwable exc) {
			getMessageTextArea().append(lineSeparator + ""BUILD FAILED"" + lineSeparator);
			if (exc instanceof BuildException) {
				getMessageTextArea().append(exc.toString());
				Throwable nested = ((BuildException)exc).getException();
				if (nested != null) {
					nested.printStackTrace(System.err);
				}
			}
			else {
				exc.printStackTrace(System.err);
			}
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
	}
	/**
	 * Eventhandler to handle all AWT-events
	 */
	private class PrivateEventHandler implements ActionListener, ItemListener, TextListener, WindowListener, PropertyChangeListener {
		/**
		 * ActionListener method
		 */
		public void actionPerformed(ActionEvent e) {
			try {
				/* #### Main App-Frame #### */
				// browse XML-File with filechooser
				if (e.getSource() == VAJAntToolGUI.this.getBrowseButton()) {
					getFileDialog().setDirectory(getBuildFileTextField().getText().substring(0, getBuildFileTextField().getText().lastIndexOf('\\') + 1));
					getFileDialog().setFile(""*.xml"");
					getFileDialog().show();
					if (!getFileDialog().getFile().equals("""") ) {
						getBuildFileTextField().setText(getFileDialog().getDirectory() + getFileDialog().getFile());
					}
				}
				// dispose and exit application 
				if (e.getSource() == VAJAntToolGUI.this.getCloseButton()) {
					dispose();
					System.exit(0);
				}
				// start build-process
				if (e.getSource() == VAJAntToolGUI.this.getBuildButton()) 
					executeTarget();
				if (e.getSource() == VAJAntToolGUI.this.getReloadButton()) {
					try {
						getBuildInfo().updateTargetList();
						fillList();
					}
					catch (Throwable fileNotFound) {
						handleException(fileNotFound);
						getTargetList().removeAll();
						getBuildButton().setEnabled(false);
					}
				}
				// MenuItems
				if (e.getSource() == VAJAntToolGUI.this.getSaveMenuItem()) 
					saveBuildInfo();
				if (e.getSource() == VAJAntToolGUI.this.getAboutMenuItem()) 
					getAboutDialog().show();
				if (e.getSource() == VAJAntToolGUI.this.getShowLogMenuItem()) 
					getMessageFrame().show();
				/* #### About dialog #### */
				if (e.getSource() == VAJAntToolGUI.this.getAboutOkButton()) 
					getAboutDialog().dispose();
				/* #### Log frame #### */
				if (e.getSource() == VAJAntToolGUI.this.getMessageOkButton())
					getMessageFrame().dispose();
				if (e.getSource() == VAJAntToolGUI.this.getMessageClearLogButton()) 
					getMessageTextArea().setText("""");
				if (e.getSource() == VAJAntToolGUI.this.getMessageOkButton()) 
					getMessageFrame().dispose();
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		/**
		 * ItemListener method
		 */
		public void itemStateChanged(ItemEvent e) {
			try {
				if (e.getSource() == VAJAntToolGUI.this.getTargetList()) 
					getBuildButton().setEnabled(true);
				if (e.getSource() == VAJAntToolGUI.this.getMessageOutputLevelChoice()) 
					getBuildInfo().setOutputMessageLevel(getMessageOutputLevelChoice().getSelectedIndex());
				if (e.getSource() == VAJAntToolGUI.this.getTargetList()) 
					getBuildInfo().setTarget(getTargetList().getSelectedItem());
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		/**
		 * PropertyChangeListener method
		 */
		public void propertyChange(java.beans.PropertyChangeEvent evt) {
			if (evt.getSource() == VAJAntToolGUI.this.getBuildInfo() && (evt.getPropertyName().equals(""projectName""))) 
				connectProjectNameToLabel();
			if (evt.getSource() == VAJAntToolGUI.this.getBuildInfo() && (evt.getPropertyName().equals(""buildFileName""))) 
				connectBuildFileNameToTextField();
		}
		/**
		 * TextListener method
		 */
		public void textValueChanged(TextEvent e) {
			if (e.getSource() == VAJAntToolGUI.this.getBuildFileTextField()) 
				connectTextFieldToBuildFileName();
		}
		/**
		 * WindowListener methods
		 */
		public void windowClosing(WindowEvent e) {
			try {
				if (e.getSource() == VAJAntToolGUI.this) {
					dispose();
					System.exit(0);
				}
				if (e.getSource() == VAJAntToolGUI.this.getAboutDialog()) 
					getAboutDialog().dispose();
				if (e.getSource() == VAJAntToolGUI.this.getMessageFrame()) 
					getMessageFrame().dispose();
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		public void windowActivated(WindowEvent e) {};
		public void windowClosed(WindowEvent e) {};
		public void windowDeactivated(WindowEvent e) {};
		public void windowDeiconified(WindowEvent e) {};
		public void windowIconified(WindowEvent e) {};
		public void windowOpened(WindowEvent e) {};
	}
	/**
	 * AntMake default-constructor.
	 */
	private VAJAntToolGUI() {
		super();
		initialize();
	}
	/**
	 * AntMake constructor called by VAJAntTool integration.
	 * @param buildInfo VAJBuildInfo
	 */
	public VAJAntToolGUI(VAJBuildInfo newBuildInfo) {
		super();
		setBuildInfo(newBuildInfo);
		initialize();
	}
	/**
	 * This method is used to center dialogs.
	 */
	public static void centerDialog(Dialog dialog) {
		dialog.setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (dialog.getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2) - (dialog.getSize().height / 2));
	}
	/**
	 * connectBuildFileNameToTextField:  (BuildInfo.buildFileName <--> BuildFileTextField.text)
	 */
	private void connectBuildFileNameToTextField() {
		/* Set the target from the source */
		try {
			if (iConnPtoP2Aligning == false) {
				iConnPtoP2Aligning = true;
				if ((getBuildInfo() != null)) {
					getBuildFileTextField().setText(getBuildInfo().getBuildFileName());
				}
				iConnPtoP2Aligning = false;
			}
		} catch (Throwable iExc) {
			iConnPtoP2Aligning = false;
			handleException(iExc);
		}
	}
	/**
	 * connectProjectNameToLabel:  (BuildInfo.vajProjectName <--> ProjectText.text)
	 */
	private void connectProjectNameToLabel() {
		/* Set the target from the source */
		try {
			if ((getBuildInfo() != null)) {
				getProjectText().setText(getBuildInfo().getVAJProjectName());
			}
		} catch (Throwable iExc) {
			handleException(iExc);
		}
	}
	/**
	 * connectTextFieldToBuildFileName:  (BuildInfo.buildFileName <--> BuildFileTextField.text)
	 */
	private void connectTextFieldToBuildFileName() {
		/* Set the source from the target */
		try {
			if (iConnPtoP2Aligning == false) {
				iConnPtoP2Aligning = true;
				if ((getBuildInfo() != null)) {
					getBuildInfo().setBuildFileName(getBuildFileTextField().getText());
				}
				iConnPtoP2Aligning = false;
			}
		} catch (Throwable iExc) {
			iConnPtoP2Aligning = false;
			handleException(iExc);
		}
	}
	/**
	 * external build of a .jar-file
	 */
	private void executeTarget() {
		try	{
			getMessageFrame().show();
			// Chris: HACK: remove when Ant-Refactoring is finished!
			logger.buildStarted(null);
			getBuildInfo().executeProject(logger);
			// Chris: HACK: remove when Ant-Refactoring is finished!
			logger.buildSuccessful();			
		}
		catch (Throwable exc) {
			// We aren't interested in exceptions! All necessary information has been written to the logging-window!
			// Unfortunately ANT-Refactoring isn't done yet!
			// Chris: HACK: remove when Ant-Refactoring is finished!
			logger.buildFailed( exc );			
		}
		return;
	}
	/**
	 * Fills the taget-list with project-targets
	 */
	private void fillList() {
		getTargetList().removeAll();
		Vector targets = getBuildInfo().getProjectTargets();
		for (int i = 0;i < targets.size(); i++) {
			getTargetList().add(targets.elementAt(i).toString());
		}
		getTargetList().select(iBuildInfo.getProjectTargets().indexOf(iBuildInfo.getTarget()));
		if (getTargetList().getSelectedIndex() >= 0) {
			getBuildButton().setEnabled(true);
		}
	}
	/**
	 * Copied from DefaultLogger to provide the same time-format.
	 */
	public static String formatTime(long millis) {
		long seconds = millis / 1000;
		long minutes = seconds / 60;
		if (minutes > 0) {
			return Long.toString(minutes) + "" minute""
				+ (minutes == 1 ? "" "" : ""s "")
				+ Long.toString(seconds%60) + "" second""
				+ (seconds%60 == 1 ? """" : ""s"");
		}
		else {
			return Long.toString(seconds) + "" second""
				+ (seconds%60 == 1 ? """" : ""s"");
		}
	}
	/**
	 * Return the AboutCommandPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getAboutCommandPanel() {
		if (iAboutCommandPanel == null) {
			try {
				iAboutCommandPanel = new Panel();
				iAboutCommandPanel.setName(""AboutCommandPanel"");
				iAboutCommandPanel.setLayout(new java.awt.FlowLayout());
				getAboutCommandPanel().add(getAboutOkButton(), getAboutOkButton().getName());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutCommandPanel;
	}
	/**
	 * Return the AboutContactLabel property value.
	 * @return java.awt.Label
	 */
	private Label getAboutContactLabel() {
		if (iAboutContactLabel == null) {
			try {
				iAboutContactLabel = new Label();
				iAboutContactLabel.setName(""AboutContactLabel"");
				iAboutContactLabel.setAlignment(java.awt.Label.CENTER);
				iAboutContactLabel.setText(""contact: wolf.siberski@tui.de or christoph.wilhelms@tui.de"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutContactLabel;
	}
	/**
	 * Return the AboutDevLabel property value.
	 * @return java.awt.Label
	 */
	private Label getAboutDevLabel() {
		if (iAboutDevLabel == null) {
			try {
				iAboutDevLabel = new Label();
				iAboutDevLabel.setName(""AboutDevLabel"");
				iAboutDevLabel.setAlignment(java.awt.Label.CENTER);
				iAboutDevLabel.setText(""developed by Wolf Siberski & Christoph Wilhelms"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDevLabel;
	}
	/**
	 * Return the AboutDialog property value.
	 * @return java.awt.Dialog
	 */
	private Dialog getAboutDialog() {
		if (iAboutDialog == null) {
			try {
				iAboutDialog = new Dialog(this);
				iAboutDialog.setName(""AboutDialog"");
				iAboutDialog.setResizable(false);
				iAboutDialog.setLayout(new java.awt.BorderLayout());
				iAboutDialog.setBounds(550, 14, 383, 142);
				iAboutDialog.setModal(true);
				iAboutDialog.setTitle(""About..."");
				getAboutDialog().add(getAboutDialogContentPanel(), ""Center"");
				iAboutDialog.pack();
				centerDialog(iAboutDialog);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDialog;
	}
	/**
	 * Return the AboutDialogContentPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getAboutDialogContentPanel() {
		if (iAboutDialogContentPanel == null) {
			try {
				iAboutDialogContentPanel = new Panel();
				iAboutDialogContentPanel.setName(""AboutDialogContentPanel"");
				iAboutDialogContentPanel.setLayout(new java.awt.BorderLayout());
				getAboutDialogContentPanel().add(getAboutCommandPanel(), ""South"");
				getAboutDialogContentPanel().add(getAboutInfoPanel(), ""Center"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDialogContentPanel;
	}
	/**
	 * Return the AboutInfoPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getAboutInfoPanel() {
		if (iAboutInfoPanel == null) {
			try {
				iAboutInfoPanel = new Panel();
				iAboutInfoPanel.setName(""AboutInfoPanel"");
				iAboutInfoPanel.setLayout(new GridBagLayout());
				GridBagConstraints constraintsAboutTitleLabel = new GridBagConstraints();
				constraintsAboutTitleLabel.gridx = 0; constraintsAboutTitleLabel.gridy = 0;
				constraintsAboutTitleLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutTitleLabel.weightx = 1.0;
				constraintsAboutTitleLabel.weighty = 1.0;
				constraintsAboutTitleLabel.insets = new Insets(4, 0, 4, 0);
				getAboutInfoPanel().add(getAboutTitleLabel(), constraintsAboutTitleLabel);
				GridBagConstraints constraintsAboutDevLabel = new GridBagConstraints();
				constraintsAboutDevLabel.gridx = 0; constraintsAboutDevLabel.gridy = 1;
				constraintsAboutDevLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutDevLabel.weightx = 1.0;
				constraintsAboutDevLabel.insets = new Insets(4, 0, 0, 0);
				getAboutInfoPanel().add(getAboutDevLabel(), constraintsAboutDevLabel);
				GridBagConstraints constraintsAboutContactLabel = new GridBagConstraints();
				constraintsAboutContactLabel.gridx = 0; constraintsAboutContactLabel.gridy = 2;
				constraintsAboutContactLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutContactLabel.weightx = 1.0;
				constraintsAboutContactLabel.insets = new Insets(2, 0, 4, 0);
				getAboutInfoPanel().add(getAboutContactLabel(), constraintsAboutContactLabel);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutInfoPanel;
	}
	/**
	 * Return the AboutMenuItem property value.
	 * @return java.awt.MenuItem
	 */
	private MenuItem getAboutMenuItem() {
		if (iAboutMenuItem == null) {
			try {
				iAboutMenuItem = new MenuItem();
				iAboutMenuItem.setLabel(""About..."");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutMenuItem;
	}
	/**
	 * Return the AboutOkButton property value.
	 * @return java.awt.Button
	 */
	private Button getAboutOkButton() {
		if (iAboutOkButton == null) {
			try {
				iAboutOkButton = new Button();
				iAboutOkButton.setName(""AboutOkButton"");
				iAboutOkButton.setLabel(""OK"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutOkButton;
	}
	/**
	 * Return the AboutTitleLabel property value.
	 * @return java.awt.Label
	 */
	private Label getAboutTitleLabel() {
		if (iAboutTitleLabel == null) {
			try {
				iAboutTitleLabel = new Label();
				iAboutTitleLabel.setName(""AboutTitleLabel"");
				iAboutTitleLabel.setFont(new Font(""Arial"", 1, 12));
				iAboutTitleLabel.setAlignment(Label.CENTER);
				iAboutTitleLabel.setText(""Ant VisualAge for Java Tool-Integration"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutTitleLabel;
	}
	/**
	 * Return the AntMakeMenuBar property value.
	 * @return java.awt.MenuBar
	 */
	private MenuBar getAntMakeMenuBar() {
		if (iAntMakeMenuBar == null) {
			try {
				iAntMakeMenuBar = new MenuBar();
				iAntMakeMenuBar.add(getFileMenu());
				iAntMakeMenuBar.add(getHelpMenu());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAntMakeMenuBar;
	}
	/**
	 * Return the BrowseButton property value.
	 * @return Button
	 */
	private Button getBrowseButton() {
		if (iBrowseButton == null) {
			try {
				iBrowseButton = new Button();
				iBrowseButton.setName(""BrowseButton"");
				iBrowseButton.setLabel(""..."");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBrowseButton;
	}
	/**
	 * Return the BuildButton property value.
	 * @return java.awt.Button
	 */
	private Button getBuildButton() {
		if (iBuildButton == null) {
			try {
				iBuildButton = new Button();
				iBuildButton.setName(""BuildButton"");
				iBuildButton.setLabel(""Build"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildButton;
	}
	/**
	 * Return the BuildFileLabel property value.
	 * @return java.awt.Label
	 */
	private Label getBuildFileLabel() {
		if (iBuildFileLabel == null) {
			try {
				iBuildFileLabel = new Label();
				iBuildFileLabel.setName(""BuildFileLabel"");
				iBuildFileLabel.setText(""Ant-Buildfile:"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildFileLabel;
	}
	/**
	 * Return the BuildFileTextField property value.
	 * @return java.awt.TextField
	 */
	private TextField getBuildFileTextField() {
		if (iBuildFileTextField == null) {
			try {
				iBuildFileTextField = new TextField();
				iBuildFileTextField.setName(""BuildFileTextField"");
				iBuildFileTextField.setBackground(SystemColor.textHighlightText);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildFileTextField;
	}
	/**
	 * Return the BuildInfo property value.
	 * @return org.apache.tools.ant.taskdefs.optional.ide.VAJBuildInfo
	 */
	private VAJBuildInfo getBuildInfo() {
		return iBuildInfo;
	}
	/**
	 * Return the CloseButton property value.
	 * @return java.awt.Button
	 */
	private Button getCloseButton() {
		if (iCloseButton == null) {
			try {
				iCloseButton = new Button();
				iCloseButton.setName(""CloseButton"");
				iCloseButton.setLabel(""Close"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iCloseButton;
	}
	/**
	 * Return the CommandButtonPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getCommandButtonPanel() {
		if (iCommandButtonPanel == null) {
			try {
				iCommandButtonPanel = new Panel();
				iCommandButtonPanel.setName(""CommandButtonPanel"");
				iCommandButtonPanel.setLayout(getCommandButtonPanelFlowLayout());
				iCommandButtonPanel.setBackground(SystemColor.control);
				iCommandButtonPanel.add(getReloadButton());
				getCommandButtonPanel().add(getBuildButton(), getBuildButton().getName());
				getCommandButtonPanel().add(getCloseButton(), getCloseButton().getName());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iCommandButtonPanel;
	}
	/**
	 * Return the CommandButtonPanelFlowLayout property value.
	 * @return java.awt.FlowLayout
	 */
	private FlowLayout getCommandButtonPanelFlowLayout() {
		FlowLayout iCommandButtonPanelFlowLayout = null;
		try {
			/* Create part */
			iCommandButtonPanelFlowLayout = new FlowLayout();
			iCommandButtonPanelFlowLayout.setAlignment(FlowLayout.RIGHT);
		} catch (Throwable iExc) {
			handleException(iExc);
		};
		return iCommandButtonPanelFlowLayout;
	}
	/**
	 * Return the ContentsPane property value.
	 * @return java.awt.Panel
	 */
	private Panel getContentsPane() {
		if (iContentsPane == null) {
			try {
				iContentsPane = new Panel();
				iContentsPane.setName(""ContentsPane"");
				iContentsPane.setLayout(new BorderLayout());
				getContentsPane().add(getCommandButtonPanel(), ""South"");
				getContentsPane().add(getOptionenPanel(), ""Center"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iContentsPane;
	}
	/**
	 * Return the FileDialog property value.
	 * @return java.awt.FileDialog
	 */
	private FileDialog getFileDialog() {
		if (iFileDialog == null) {
			try {
				iFileDialog = new FileDialog(this);
				iFileDialog.setName(""FileDialog"");
				iFileDialog.setLayout(null);
				centerDialog(iFileDialog);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iFileDialog;
	}
	/**
	 * Return the FileMenu property value.
	 * @return java.awt.Menu
	 */
	private Menu getFileMenu() {
		if (iFileMenu == null) {
			try {
				iFileMenu = new Menu();
				iFileMenu.setLabel(""File"");
				iFileMenu.add(getSaveMenuItem());
				iFileMenu.add(getMenuSeparator());
				iFileMenu.add(getShowLogMenuItem());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iFileMenu;
	}
	/**
	 * Return the HelpMenu property value.
	 * @return java.awt.Menu
	 */
	private Menu getHelpMenu() {
		if (iHelpMenu == null) {
			try {
				iHelpMenu = new Menu();
				iHelpMenu.setLabel(""Help"");
				iHelpMenu.add(getAboutMenuItem());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iHelpMenu;
	}
	/**
	 * Return the MenuSeparator1 property value.
	 * @return java.awt.MenuItem
	 */
	private MenuItem getMenuSeparator() {
		if (iMenuSeparator == null) {
			try {
				iMenuSeparator = new MenuItem();
				iMenuSeparator.setLabel(""-"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMenuSeparator;
	}
	/**
	 * Return the MessageClearLogButton property value.
	 * @return java.awt.Button
	 */
	private Button getMessageClearLogButton() {
		if (iMessageClearLogButton == null) {
			try {
				iMessageClearLogButton = new Button();
				iMessageClearLogButton.setName(""MessageClearLogButton"");
				iMessageClearLogButton.setLabel(""Clear Log"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageClearLogButton;
	}
	/**
	 * Return the MessageCommandPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getMessageCommandPanel() {
		if (iMessageCommandPanel == null) {
			try {
				iMessageCommandPanel = new Panel();
				iMessageCommandPanel.setName(""MessageCommandPanel"");
				iMessageCommandPanel.setLayout(new FlowLayout());
				getMessageCommandPanel().add(getMessageClearLogButton(), getMessageClearLogButton().getName());
				getMessageCommandPanel().add(getMessageOkButton(), getMessageOkButton().getName());
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageCommandPanel;
	}
	/**
	 * Return the MessageContentPanel property value.
	 * @return java.awt.Panel
	 */
	private Panel getMessageContentPanel() {
		if (iMessageContentPanel == null) {
			try {
				iMessageContentPanel = new Panel();
				iMessageContentPanel.setName(""MessageContentPanel"");
				iMessageContentPanel.setLayout(new BorderLayout());
				iMessageContentPanel.setBackground(SystemColor.control);
				getMessageContentPanel().add(getMessageTextArea(), ""Center"");
				getMessageContentPanel().add(getMessageCommandPanel(), ""South"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageContentPanel;
	}
	/**
	 * Return the MessageFrame property value.
	 * @return java.awt.Frame
	 */
	private Frame getMessageFrame() {
		if (iMessageFrame == null) {
			try {
				iMessageFrame = new Frame();
				iMessageFrame.setName(""MessageFrame"");
				iMessageFrame.setLayout(new BorderLayout());
				iMessageFrame.setBounds(0, 0, 750, 250);
				iMessageFrame.setTitle(""Message Log"");
				iMessageFrame.add(getMessageContentPanel(), ""Center"");
				iMessageFrame.setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (iMessageFrame.getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2));
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageFrame;
	}
	/**
	 * Return the MessageOkButton property value.
	 * @return java.awt.Button
	 */
	private Button getMessageOkButton() {
		if (iMessageOkButton == null) {
			try {
				iMessageOkButton = new Button();
				iMessageOkButton.setName(""MessageOkButton"");
				iMessageOkButton.setLabel(""Close"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOkButton;
	}
	/**
	 * Return the MessageOutputLevelChoice property value.
	 * @return java.awt.Choice
	 */
	private Choice getMessageOutputLevelChoice() {
		if (iMessageOutputLevelChoice == null) {
			try {
				iMessageOutputLevelChoice = new Choice();
				iMessageOutputLevelChoice.setName(""MessageOutputLevelChoice"");
				iMessageOutputLevelChoice.add(""Error"");
				iMessageOutputLevelChoice.add(""Warning"");
				iMessageOutputLevelChoice.add(""Info"");
				iMessageOutputLevelChoice.add(""Verbose"");
				iMessageOutputLevelChoice.add(""Debug"");
				iMessageOutputLevelChoice.select(2);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOutputLevelChoice;
	}
	/**
	 * Return the MessageOutputLevelLabel property value.
	 * @return java.awt.Label
	 */
	private Label getMessageOutputLevelLabel() {
		if (iMessageOutputLevelLabel == null) {
			try {
				iMessageOutputLevelLabel = new Label();
				iMessageOutputLevelLabel.setName(""MessageOutputLevelLabel"");
				iMessageOutputLevelLabel.setText(""Message Level:"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOutputLevelLabel;
	}
	/**
	 * Return the MessageTextArea property value.
	 * @return java.awt.TextArea
	 */
	private TextArea getMessageTextArea() {
		if (iMessageTextArea == null) {
			try {
				iMessageTextArea = new TextArea();
				iMessageTextArea.setName(""MessageTextArea"");
				iMessageTextArea.setFont(new Font(""monospaced"", 0, 12));
				iMessageTextArea.setText("""");
				iMessageTextArea.setEditable(false);
				iMessageTextArea.setEnabled(true);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageTextArea;
	}
	/**
	 * Return the Panel1 property value.
	 * @return java.awt.Panel
	 */
	private Panel getOptionenPanel() {
		if (iOptionenPanel == null) {
			try {
				iOptionenPanel = new Panel();
				iOptionenPanel.setName(""OptionenPanel"");
				iOptionenPanel.setLayout(new GridBagLayout());
				iOptionenPanel.setBackground(SystemColor.control);
				GridBagConstraints constraintsProjectLabel = new GridBagConstraints();
				constraintsProjectLabel.gridx = 0; constraintsProjectLabel.gridy = 0;
				constraintsProjectLabel.anchor = GridBagConstraints.WEST;
				constraintsProjectLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getProjectLabel(), constraintsProjectLabel);
				GridBagConstraints constraintsBuildFileLabel = new GridBagConstraints();
				constraintsBuildFileLabel.gridx = 0; constraintsBuildFileLabel.gridy = 1;
				constraintsBuildFileLabel.anchor = GridBagConstraints.WEST;
				constraintsBuildFileLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBuildFileLabel(), constraintsBuildFileLabel);
				GridBagConstraints constraintsTargetLabel = new GridBagConstraints();
				constraintsTargetLabel.gridx = 0; constraintsTargetLabel.gridy = 2;
				constraintsTargetLabel.anchor = GridBagConstraints.NORTHWEST;
				constraintsTargetLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getTargetLabel(), constraintsTargetLabel);
				GridBagConstraints constraintsProjectText = new GridBagConstraints();
				constraintsProjectText.gridx = 1; constraintsProjectText.gridy = 0;
				constraintsProjectText.gridwidth = 2;
				constraintsProjectText.fill = GridBagConstraints.HORIZONTAL;
				constraintsProjectText.anchor = GridBagConstraints.WEST;
				constraintsProjectText.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getProjectText(), constraintsProjectText);
				GridBagConstraints constraintsBuildFileTextField = new GridBagConstraints();
				constraintsBuildFileTextField.gridx = 1; constraintsBuildFileTextField.gridy = 1;
				constraintsBuildFileTextField.fill = GridBagConstraints.HORIZONTAL;
				constraintsBuildFileTextField.anchor = GridBagConstraints.WEST;
				constraintsBuildFileTextField.weightx = 1.0;
				constraintsBuildFileTextField.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBuildFileTextField(), constraintsBuildFileTextField);
				GridBagConstraints constraintsBrowseButton = new GridBagConstraints();
				constraintsBrowseButton.gridx = 2; constraintsBrowseButton.gridy = 1;
				constraintsBrowseButton.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBrowseButton(), constraintsBrowseButton);
				GridBagConstraints constraintsTargetList = new GridBagConstraints();
				constraintsTargetList.gridx = 1; constraintsTargetList.gridy = 2;
				constraintsTargetList.gridheight = 2;
				constraintsTargetList.fill = GridBagConstraints.BOTH;
				constraintsTargetList.weightx = 1.0;
				constraintsTargetList.weighty = 1.0;
				constraintsTargetList.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getTargetList(), constraintsTargetList);
				GridBagConstraints constraintsMessageOutputLevelLabel = new GridBagConstraints();
				constraintsMessageOutputLevelLabel.gridx = 0; constraintsMessageOutputLevelLabel.gridy = 4;
				constraintsMessageOutputLevelLabel.anchor = GridBagConstraints.WEST;
				constraintsMessageOutputLevelLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getMessageOutputLevelLabel(), constraintsMessageOutputLevelLabel);
				GridBagConstraints constraintsMessageOutputLevelChoice = new GridBagConstraints();
				constraintsMessageOutputLevelChoice.gridx = 1; constraintsMessageOutputLevelChoice.gridy = 4;
				constraintsMessageOutputLevelChoice.fill = GridBagConstraints.HORIZONTAL;
				constraintsMessageOutputLevelChoice.anchor = GridBagConstraints.WEST;
				constraintsMessageOutputLevelChoice.weightx = 1.0;
				constraintsMessageOutputLevelChoice.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getMessageOutputLevelChoice(), constraintsMessageOutputLevelChoice);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iOptionenPanel;
	}
	/**
	 * Return the ProjectLabel property value.
	 * @return java.awt.Label
	 */
	private Label getProjectLabel() {
		if (iProjectLabel == null) {
			try {
				iProjectLabel = new Label();
				iProjectLabel.setName(""ProjectLabel"");
				iProjectLabel.setText(""Projectname:"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iProjectLabel;
	}
	/**
	 * Return the ProjectText property value.
	 * @return java.awt.Label
	 */
	private Label getProjectText() {
		if (iProjectText == null) {
			try {
				iProjectText = new Label();
				iProjectText.setName(""ProjectText"");
				iProjectText.setText("" "");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iProjectText;
	}
	/**
	 * Return the ReloadButton property value.
	 * @return java.awt.Button
	 */
	private Button getReloadButton() {
		if (iReloadButton == null) {
			try {
				iReloadButton = new Button();
				iReloadButton.setName(""ReloadButton"");
				iReloadButton.setLabel(""(Re)Load"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iReloadButton;
	}
	/**
	 * Return the SaveMenuItem property value.
	 * @return java.awt.MenuItem
	 */
	private MenuItem getSaveMenuItem() {
		if (iSaveMenuItem == null) {
			try {
				iSaveMenuItem = new MenuItem();
				iSaveMenuItem.setLabel(""Save BuildInfo To Repository"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iSaveMenuItem;
	}
	/**
	 * Return the ShowLogMenuItem property value.
	 * @return java.awt.MenuItem
	 */
	private MenuItem getShowLogMenuItem() {
		if (iShowLogMenuItem == null) {
			try {
				iShowLogMenuItem = new MenuItem();
				iShowLogMenuItem.setLabel(""Log"");
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iShowLogMenuItem;
	}
	/**
	 * Return the TargetLabel property value.
	 * @return java.awt.Label
	 */
	private Label getTargetLabel() {
		if (iTargetLabel == null) {
			try {
				iTargetLabel = new Label();
				iTargetLabel.setName(""TargetLabel"");
				iTargetLabel.setText(""Target:"");
				iTargetLabel.setEnabled(true);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iTargetLabel;
	}
	/**
	 * Return the TargetList property value.
	 * @return java.awt.List
	 */
	private List getTargetList() {
		if (iTargetList == null) {
			try {
				iTargetList = new List();
				iTargetList.setName(""TargetList"");
				iTargetList.setEnabled(true);
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iTargetList;
	}
	/**
	 * Called whenever the part throws an exception.
	 * @param exception Throwable
	 */
	private void handleException(Throwable exception) {
		// Write exceptions to the log-window
		getMessageTextArea().append(lineSeparator + lineSeparator + exception.getMessage());
		getMessageFrame().show();
	}
	/**
	 * Initializes connections
	 * @exception Exception The exception description.
	 */
	private void initConnections() throws Exception {
		this.addWindowListener(iEventHandler);
		getBrowseButton().addActionListener(iEventHandler);
		getCloseButton().addActionListener(iEventHandler);
		getBuildButton().addActionListener(iEventHandler);
		getSaveMenuItem().addActionListener(iEventHandler);
		getAboutOkButton().addActionListener(iEventHandler);
		getAboutMenuItem().addActionListener(iEventHandler);
		getMessageOkButton().addActionListener(iEventHandler);
		getMessageClearLogButton().addActionListener(iEventHandler);
		getMessageOkButton().addActionListener(iEventHandler);
		getShowLogMenuItem().addActionListener(iEventHandler);
		getAboutDialog().addWindowListener(iEventHandler);
		getMessageFrame().addWindowListener(iEventHandler);
		getReloadButton().addActionListener(iEventHandler);
		getTargetList().addItemListener(iEventHandler);
		getMessageOutputLevelChoice().addItemListener(iEventHandler);
		getBuildFileTextField().addTextListener(iEventHandler);
		connectProjectNameToLabel();
		connectBuildFileNameToTextField();
	}
	/**
	 * Initialize the class.
	 */
	private void initialize() {
		try {
			setName(""AntMake"");
			setMenuBar(getAntMakeMenuBar());
			setLayout(new java.awt.BorderLayout());
			setSize(389, 222);
			setTitle(""Ant VisualAge for Java Tool-Integration"");
			add(getContentsPane(), ""Center"");
			initConnections();
		} catch (Throwable iExc) {
			handleException(iExc);
		}
		setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2) - (getSize().height));
		if ((getTargetList().getItemCount() == 0) || (getTargetList().getSelectedIndex() < 0)) {
			getBuildButton().setEnabled(false);
		}
	}
	/**
	 * Saves the build-informations to repository
	 */
	private void saveBuildInfo() {
		try {
			VAJAntTool.saveBuildData(getBuildInfo());
		}
		catch (Throwable exc) {
			// This Exception occurs when you try to write into a versioned project
			handleException( exc );
		}
		return;
	}
	/**
	 * Set the BuildInfo to a new value.
	 * @param newValue org.apache.tools.ant.taskdefs.optional.vaj.VAJBuildInfo
	 */
	private void setBuildInfo(VAJBuildInfo newValue) {
		if (iBuildInfo != newValue) {
			try {
				/* Stop listening for events from the current object */
				if (iBuildInfo != null) {
					iBuildInfo.removePropertyChangeListener(iEventHandler);
				}
				iBuildInfo = newValue;
				/* Listen for events from the new object */
				if (iBuildInfo != null) {
					iBuildInfo.addPropertyChangeListener(iEventHandler);
				}
				connectProjectNameToLabel();
				connectBuildFileNameToTextField();
				// Select the log-level given by BuildInfo
				getMessageOutputLevelChoice().select(iBuildInfo.getOutputMessageLevel());
				fillList();
				// BuildInfo can conly be saved to a VAJ project if tool API is called via the projects context-menu
				if ((iBuildInfo.getVAJProjectName() == null) || (iBuildInfo.getVAJProjectName().equals(""""))) {
					getSaveMenuItem().setEnabled(false);
				}
			} catch (Throwable iExc) {
				handleException(iExc);
			}
		}
	}
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJBuildInfo,"package org.apache.tools.ant.taskdefs.optional.ide;
/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Tomcat"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import org.apache.tools.ant.*;
import java.io.File;
/**
 * This class wraps the Ant project information needed to
 * start Ant from Visual Age.
 * It serves the following purposes:
 * - acts as model for AntMakeFrame
 * - converts itself to/from String (to store the information
 *   as ToolData in the VA repository)
 * - wraps Project functions for the GUI (get target list,
 *   execute target)
 *    
 * @author Wolf Siberski, TUI Infotec GmbH
 */
public class VAJBuildInfo {
	// name of the VA project this BuildInfo belongs to
	private String vajProjectName = """";
		// name of the Ant build file
	private String buildFileName = """";
		// main targets found in the build file
	private Vector projectTargets = new Vector();
		// target selected for execution
	private java.lang.String target = """";
		// log level
	private int outputMessageLevel = Project.MSG_INFO;
		// Ant Project created from build file
	private transient Project project;
		// is true if Project initialization was successful
	private transient boolean projectInitialized = false;
		// Support for bound properties
	protected transient java.beans.PropertyChangeSupport propertyChange;
/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(listener);
}
/**
 * Returns the BuildInfo information as String. The BuildInfo can
 * be rebuilt from that String by calling parse().
 * @return java.lang.String
 */
public String asDataString() {
	String result = getOutputMessageLevel() + ""|"" + getBuildFileName() + ""|"" + getTarget();
	for ( Enumeration e = getProjectTargets().elements(); e.hasMoreElements(); ) {
		result = result + ""|"" + e.nextElement();
	}
	return result;
}
/**
 * Executes the target set by setTarget().
 * @param listener  BuildListener for the output of the build
 */
public void executeProject( BuildListener listener ) {
	Throwable error = null;
	try {
		if (!isProjectInitialized()) {
			project = new Project();
		}
		project.addBuildListener( listener );
		// Chris: HACK: replace when Ant-Refactoring is finished!
//		project.fireBuildStarted();
		if (!isProjectInitialized()) {
			initProject();
		}
		project.executeTarget(target);
	} catch (RuntimeException exc) {
		error = exc;
		throw exc;
	} catch (Error err) {
		error = err;
		throw err;
	} finally {
		// Chris: HACK: replace when Ant-Refactoring is finished!
//		project.fireBuildFinished(error);
		project.removeBuildListener( listener );
	}
}
	/**
	 * Search for the insert position to keep names a sorted list of Strings
	 * This method has been copied from org.apache.tools.ant.Main
	 */
	private static int findTargetPosition(Vector names, String name) {
		int res = names.size();
		for (int i=0; i<names.size() && res == names.size(); i++) {
			if (name.compareTo((String)names.elementAt(i)) < 0) {
				res = i;
			}
		}
		return res;
	}
/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}
/**
 * Returns the build file name.
 * @return build file name.
 */
public String getBuildFileName() {
	return buildFileName;
}
/**
 * Returns the log level
 * @return log level.
 */
public int getOutputMessageLevel() {
	return outputMessageLevel;
}
/**
 * Returns the Ant project
 * @return org.apache.tools.ant.Project
 */
private Project getProject() {
	return project;
}
/**
 * return a list of all targets in the current buildfile
 */
public Vector getProjectTargets() {
	return projectTargets;
}
/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}
/**
 * Insert the method's description here.
 * Creation date: (07.11.2000 10:34:18)
 * @return java.lang.String
 */
public java.lang.String getTarget() {
	return target;
}
/**
 * returns the VA project name
 * @return The projectName property value.
 */
public String getVAJProjectName() {
	return vajProjectName;
}
/**
 * Initializes the Ant project. Assumes that the
 * project attribute is already set.
 */
private void initProject() {
	try {
		project.init();
		File buildFile = new File(getBuildFileName());
		project.setUserProperty(""ant.file"", buildFile.getAbsolutePath());
		ProjectHelper.configureProject(project, buildFile);
		setProjectInitialized(true);
	} catch (RuntimeException exc) {
		setProjectInitialized(false);
		throw exc;
	} catch (Error err) {
		setProjectInitialized(false);
		throw err;
	}
}
/**
 * Returns true, if the Ant project is initialized
 * (i.e. buildfile loaded)
 */
public boolean isProjectInitialized() {
	return projectInitialized;
}
/**
 * Creates a BuildInfo object from a String
 * The String must be in the format
 * outputMessageLevel'|'buildFileName'|'defaultTarget'|'(project target'|')*
 *
 * @return org.apache.tools.ant.taskdefs.optional.vaj.BuildInfo
 * @param data java.lang.String
 */
public static VAJBuildInfo parse(String data) {
	VAJBuildInfo result = new VAJBuildInfo();
	try {
		java.util.StringTokenizer tok = new java.util.StringTokenizer( data, ""|"" );
		result.setOutputMessageLevel( tok.nextToken() );
		result.setBuildFileName( tok.nextToken() );
		result.setTarget( tok.nextToken() );
		while( tok.hasMoreTokens() ) {
			result.projectTargets.addElement( tok.nextToken() );
		}
	} catch ( Throwable t ) {
	}
	return result;
}
/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(listener);
}
/**
 * Sets the build file name
 * @param buildFileName build file name
 */
public void setBuildFileName(String newBuildFileName) {
	String oldValue = buildFileName;
	buildFileName = newBuildFileName;
	setProjectInitialized(false);
	firePropertyChange(""buildFileName"", oldValue, buildFileName);
}
/**
 * Sets the log level (value must be one of the constants in Project)
 * @param outputMessageLevel log level.
 */
public void setOutputMessageLevel(int newOutputMessageLevel) {
	int oldValue = outputMessageLevel;
	outputMessageLevel = newOutputMessageLevel;
	firePropertyChange(""outputMessageLevel"", new Integer(oldValue), new Integer(outputMessageLevel));
}
/**
 * Sets the log level (value must be one of the constants in Project)
 * @param outputMessageLevel log level as String.
 */
private void setOutputMessageLevel(String outputMessageLevel) {
	int level = Integer.parseInt( outputMessageLevel );
	setOutputMessageLevel( level );
}
/**
  */
private void setProjectInitialized(boolean initialized) {
	Boolean oldValue = new Boolean(projectInitialized);
	projectInitialized = initialized;
	firePropertyChange(""projectInitialized"", oldValue, new Boolean(projectInitialized));
}
/**
 * Sets the target to execute when executeBuild is called
 * @param newTarget build target
 */
public void setTarget(String newTarget) {
	String oldValue = target;
	target = newTarget;
	firePropertyChange(""target"", oldValue, target);
}
/**
 * Sets the name of the Visual Age for Java project where
 * this BuildInfo belongs to
 * @param newProjectName VAJ project
 */
public void setVAJProjectName(String newVAJProjectName) {
	String oldValue = vajProjectName;
	vajProjectName = newVAJProjectName;
	firePropertyChange(""VAJProjectName"", oldValue, vajProjectName);
}
/**
 * reloads the build file and updates the target list
 */
public void updateTargetList() {
	project = new Project();
	initProject();
	projectTargets.removeAllElements();
	Enumeration ptargets = project.getTargets().elements();
	while (ptargets.hasMoreElements()) {
		Target currentTarget = (Target) ptargets.nextElement();
		if ( currentTarget.getDescription() != null ) {
			String targetName = currentTarget.getName();
			int pos = findTargetPosition( projectTargets, targetName );
			projectTargets.insertElementAt(targetName, pos);
		}
	}
}
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJExport,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ide;
import com.ibm.ivj.util.base.ExportCodeSpec;
import com.ibm.ivj.util.base.IvjException;
import com.ibm.ivj.util.base.Package;
import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.PatternSet;
/**
 * Export packages from the Visual Age for Java workspace. 
 * The packages are specified similar to all other MatchingTasks. 
 * Since the VA Workspace is not file based, this task is simulating 
 * a directory hierarchy for the workspace:
 * The 'root' contains all project 'dir's, and the projects contain 
 * their respective package 'dir's.
 * Example:  
 * <blockquote> 
 * &lt;vajexport destdir=""C:/builddir/source"">
 * &nbsp;&lt;include name=""/MyVAProject/org/foo/subsystem1/**"" />
 * &nbsp;&lt;exclude name=""/MyVAProject/org/foo/subsystem1/test/**""/>
 * &lt;/vajexport>
 * </blockquote>
 * exports all packages in the project MyVAProject which start with
 * 'org.foo.subsystem1' except of these starting with 
 * 'org.foo.subsystem1.test'.
 *
 * There are flags to choose which items to export:
 * exportSources:   export Java sources
 * exportResources: export project resources
 * exportClasses:   export class files
 * exportDebugInfo: export class files with debug info (use with exportClasses)
 * default is exporting Java files and resources.
 *
 * @author Wolf Siberski, TUI Infotec GmbH
 */
public class VAJExport extends Task {
    protected File destDir;
    protected boolean exportSources = true;
    protected boolean exportResources = true;
    protected boolean exportClasses = false;
    protected boolean exportDebugInfo = false;
    protected boolean useDefaultExcludes = true;
    protected PatternSet patternSet = new PatternSet();
    /**
     * add a name entry on the exclude list
     */
    public PatternSet.NameEntry createExclude() {
        return patternSet.createExclude();
    }
    /**
     * add a name entry on the include list
     */
    public PatternSet.NameEntry createInclude() {
        return patternSet.createInclude();
    }
    /**
     * do the export
     */
    public void execute() throws BuildException {
        // first off, make sure that we've got a destdir
        if (destDir == null) {
            throw new BuildException(""destdir attribute must be set!"");
        }
        VAJWorkspaceScanner ds = this.getWorkspaceScanner();
        Package[] packages = ds.getIncludedPackages();
        export(packages);
    }
    /**
     * export the array of Packages
     */
    public void export(Package[] packages) {
        try {
            String dest = destDir.getAbsolutePath();
            log(""Exporting "" + packages.length + "" package(s) to "" + dest);
            for (int i = 0; i < packages.length; i++) {
                log(""    "" + packages[i].getName(), Project.MSG_VERBOSE);
            }
            ExportCodeSpec exportSpec = new ExportCodeSpec();
            exportSpec.setPackages(packages);
            exportSpec.includeJava(exportSources);
            exportSpec.includeClass(exportClasses);
            exportSpec.includeResources(exportResources);
            exportSpec.includeClassDebugInfo(exportDebugInfo);
            exportSpec.useSubdirectories(true);
            exportSpec.overwriteFiles(true);
            exportSpec.setExportDirectory(dest);
            VAJUtil.getWorkspace().exportData(exportSpec);
        } catch (IvjException ex) {
            throw VAJUtil.createBuildException(""Exporting failed!"", ex);
        }
    }
    /**
     * Returns the directory scanner needed to access the files to process.
     */
    protected VAJWorkspaceScanner getWorkspaceScanner() {
        VAJWorkspaceScanner scanner = new VAJWorkspaceScanner();
        scanner.setIncludes(patternSet.getIncludePatterns(getProject()));
        scanner.setExcludes(patternSet.getExcludePatterns(getProject()));
        if (useDefaultExcludes)
            scanner.addDefaultExcludes();
        scanner.scan();
        return scanner;
    }
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        this.useDefaultExcludes = useDefaultExcludes;
    }
    /**
     * Set the destination directory into which the Java source
     * files should be compiled.
     */
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        patternSet.setExcludes(excludes);
    }
    /**
     */
    public void setExportClasses(boolean doExport) {
        exportClasses = doExport;
    }
    /**
     */
    public void setExportDebugInfo(boolean doExport) {
        exportDebugInfo = doExport;
    }
    /**
     */
    public void setExportResources(boolean doExport) {
        exportResources = doExport;
    }
    /**
     */
    public void setExportSources(boolean doExport) {
        exportSources = doExport;
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        patternSet.setIncludes(includes);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJImport,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ide;
import com.ibm.ivj.util.base.ImportCodeSpec;
import com.ibm.ivj.util.base.IvjException;
import com.ibm.ivj.util.base.Project;
import com.ibm.ivj.util.base.ProjectEdition;
import com.ibm.ivj.util.base.Type;
import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
/**
 * Import source, class files, and resources to the Visual Age for Java 
 * workspace using FileSets.
 * <p>
 * Example:  
 * <pre> 
 * &lt;vajimport project=""MyVAProject""&gt;
 *   &lt;fileset dir=""src""&gt;
 *     &lt;include name=""org/foo/subsystem1/**"" /&gt;
 *     &lt;exclude name=""/org/foo/subsystem1/test/**"" /&gt;
 *  &lt;/fileset&gt;
 * &lt;/vajexport&gt;
 * </pre>
 * import all source and resource files from the ""src"" directory
 * which start with 'org.foo.subsystem1', except of these starting with 
 * 'org.foo.subsystem1.test' into the project MyVAProject.
 * </p>
 * <p>If MyVAProject isn't loaded into the Workspace, a new edition is
 * created in the repository and automatically loaded into the Workspace.
 * There has to be at least one nested FileSet element.
 * </p>
 * <p>There are attributes to choose which items to export:
 * <table border=""1"" cellpadding=""2"" cellspacing=""0"">
 * <tr>
 *   <td valign=""top""><b>Attribute</b></td>
 *   <td valign=""top""><b>Description</b></td>
 *   <td align=""center"" valign=""top""><b>Required</b></td>
 * </tr>
 * <tr>
 *   <td valign=""top"">vajproject</td>
 *   <td valign=""top"">the name of the Project to import to</td>
 *   <td align=""center"" valign=""top"">Yes</td>
 * </tr>
 * <tr>
 *   <td valign=""top"">importSources</td>
 *   <td valign=""top"">import Java sources, defaults to ""yes""</td>
 *   <td align=""center"" valign=""top"">No</td>
 * </tr>
 * <tr>
 *   <td valign=""top"">importResources</td>
 *   <td valign=""top"">import resource files (anything that doesn't
 *                    end with .java or .class), defaults to ""yes""</td>
 *   <td align=""center"" valign=""top"">No</td>
 * </tr>
 * <tr>
 *   <td valign=""top"">importClasses</td>
 *   <td valign=""top"">import class files, defaults to ""no""</td>
 *   <td align=""center"" valign=""top"">No</td>
 * </tr>
 * </table>
 *
 * @author: Glenn McAllister, inspired by a similar task written by Peter Kelley
 */
public class VAJImport extends Task {
    protected Vector filesets = new Vector();
    protected boolean importSources = true;
    protected boolean importResources = true;
    protected boolean importClasses = false;
    protected String importProject = null;
    protected Project vajproject = null;
    /**
     * The VisualAge for Java Project name to import into.
     */
    public void setVajproject(String projectName) {
        this.importProject = projectName;
    }
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * Import .class files.
     */
    public void setImportClasses(boolean importClasses) {
        this.importClasses = importClasses;
    }
    /**
     * Import resource files (anything that doesn't end in
     * .class or .java)
     */
    public void setImportResources(boolean importResources) {
        this.importResources = importResources;
    }
    /**
     * Import .java files
     */
    public void setImportSources(boolean importSources) {
        this.importSources = importSources;
    }
    /**
     * Do the import.
     */
    public void execute() throws BuildException {
        if (filesets.size() == 0) {
            throw new BuildException(""At least one fileset is required!"");
        }
        if (importProject == null || """".equals(importProject)) {
            throw new BuildException(""The VisualAge for Java Project name is required!"");
        }
        vajproject = getVAJProject();
        if (vajproject == null) {
            try {
                vajproject = VAJUtil.getWorkspace().createProject(this.importProject, true);
            } catch (IvjException e) {
                throw VAJUtil.createBuildException( ""Error while creating Project "" + 
                                                    importProject + "": "", 
                                                    e ); 
            }
        }
        for (Enumeration e = filesets.elements(); e.hasMoreElements();) {
            importFileset((FileSet) e.nextElement());
        }
    }
    /**
     * Try to get the project we want from the Workspace.
     */
    protected Project getVAJProject() {
        Project found = null;
        Project[] currentProjects = VAJUtil.getWorkspace().getProjects();
        for (int i = 0; i < currentProjects.length; i++) {
            Project p = currentProjects[i];
            if (p.getName().equals(this.importProject)) {
                found = p;
                break;
            }
        }
        return found;
    }
    /**
     * Import all files from the fileset into the Project in the
     * Workspace.
     */
    protected void importFileset(FileSet fileset) {
        DirectoryScanner ds = fileset.getDirectoryScanner(this.project);
        if (ds.getIncludedFiles().length == 0) {
            return;
        }
        Vector classes = new Vector();
        Vector sources = new Vector();
        Vector resources = new Vector();
        String[] classesArr = null;
        String[] sourcesArr = null;
        String[] resourcesArr = null;
        StringBuffer msg = new StringBuffer();
        msg.append(""Importing "");
        String connector = """";
        ImportCodeSpec importSpec = new ImportCodeSpec();
        importSpec.setDefaultProject(vajproject);
        scan(
             fileset.getDir(this.project), 
             ds.getIncludedFiles(), 
             classes, 
             sources, 
             resources); 
        if (importClasses) {
            classesArr = new String[classes.size()];
            classes.copyInto(classesArr);
            importSpec.setClassFiles(classesArr);
            if (classesArr.length > 0) {
                logFiles(classes, ""class"");
                msg.append( classesArr.length );
                msg.append( "" class "" );
                msg.append( classesArr.length > 1 ? ""files"" : ""file"" );
                connector = "", "";
            }
        }
        if (importSources) {
            sourcesArr = new String[sources.size()];
            sources.copyInto(sourcesArr);
            importSpec.setJavaFiles(sourcesArr);
            if (sourcesArr.length > 0) {
                logFiles(sources, ""source"");
                msg.append( connector );
                msg.append( sourcesArr.length );
                msg.append( "" source "" );
                msg.append( sourcesArr.length > 1 ? ""files"" : ""file"" );
                connector = "", "";
            }
        }
        if (importResources) {
            String resourcePath = fileset.getDir(this.project).getAbsolutePath();
            resourcesArr = new String[resources.size()];
            resources.copyInto(resourcesArr);
            importSpec.setResourcePath(resourcePath);
            importSpec.setResourceFiles(resourcesArr);
            if (resourcesArr.length > 0) {
                logFiles(resources, ""resource"");
                log( ""  (relative to resource path '"" + resourcePath + ""')"", 
                     org.apache.tools.ant.Project.MSG_VERBOSE );
                msg.append( connector );
                msg.append( resourcesArr.length );
                msg.append( "" resource "" );
                msg.append( resourcesArr.length > 1 ? ""files"" : ""file"" );
            }
        }
        msg.append( "" into the "" );
        msg.append( importProject );
        msg.append( "" project."" );
        log(msg.toString());
        try {
            Type[] importedTypes = VAJUtil.getWorkspace().importData(importSpec);
            if (importedTypes == null) {
                throw new BuildException(""Unable to import into Workspace!"");
            }
        } catch (IvjException ivje) {
            VAJUtil.createBuildException(""Error while importing into Workspace: "", ivje);
        }
    }
    /**
     * Sort the files into classes, sources, and resources.
     */
    protected void scan(
                        File dir, 
                        String[] files, 
                        Vector classes, 
                        Vector sources, 
                        Vector resources) {
        for (int i = 0; i < files.length; i++) {
            String file = (new File(dir, files[i])).getAbsolutePath();
            if (file.endsWith("".java"") || file.endsWith("".JAVA"")) {
                sources.addElement(file);
            } else
                if (file.endsWith("".class"") || file.endsWith("".CLASS"")) {
                    classes.addElement(file);
                } else {
                    // for resources VA expects the path relative to the resource path
                    resources.addElement(files[i]);
                }
        }
    }
    /**
     * Logs a list of file names to the message log
     * @param fileNames java.util.Vector file names to be logged
     * @param type java.lang.String file type
     */
    protected void logFiles(Vector fileNames, String fileType) {
        log(  fileType + "" files found for import:"", org.apache.tools.ant.Project.MSG_VERBOSE);
        for ( Enumeration e = fileNames.elements(); e.hasMoreElements(); ) {
            log( ""    "" + e.nextElement(), org.apache.tools.ant.Project.MSG_VERBOSE );
        }
    } 
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJLoadProjects,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ide;
import com.ibm.ivj.util.base.IvjException;
import com.ibm.ivj.util.base.ProjectEdition;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
/**
 * Load specific project versions into the Visual Age for Java workspace.
 * Each project and version name has to be specified completely.
 * Example:  
 * <blockquote> 
 * &lt;vajload>
 * &nbsp;&lt;project name=""MyVAProject"" version=""2.1""/>
 * &nbsp;&lt;project name=""Apache Xerces"" version=""1.2.0""/>
 * &lt;/vajload>
 * </blockquote>
 *
 * @author Wolf Siberski, TUI Infotec GmbH
 */
public class VAJLoadProjects extends Task {
    Vector projectDescriptions = new Vector();
    Vector expandedProjectDescriptions = new Vector();
    /**
     * Class to maintain VisualAge for Java Workspace Project descriptions.
     */
    public class VAJProjectDescription {
        private String name;
        private String version;
        private boolean projectFound;
        public VAJProjectDescription() {
        }
        public VAJProjectDescription(String n, String v) {
            name = n;
            version = v;
        }
        public String getName() {
            return name;
        }
        public String getVersion() {
            return version;
        }
        public boolean projectFound() {
            return projectFound;
        }
        public void setName(String newName) {
            if (newName == null || newName.equals("""")) {
                throw new BuildException(""name attribute must be set"");
            }
            name = newName;
        }
        public void setVersion(String newVersion) {
            if (newVersion == null || newVersion.equals("""")) {
                throw new BuildException(""version attribute must be set"");
            }
            version = newVersion;
        }
        public void setProjectFound() {
            projectFound = true;
        }
    }
    /**
     * Add a project description entry on the project list.
     */
    public VAJProjectDescription createVAJProject() {
        VAJProjectDescription d = new VAJProjectDescription();
        projectDescriptions.addElement(d);
        return d;
    }
    /**
     * Load specified projects.
     */
    public void execute() {
        expandDescriptions();
        log(
            ""Loading "" + expandedProjectDescriptions.size() + "" project(s) into workspace""); 
        for (Enumeration e = expandedProjectDescriptions.elements(); 
             e.hasMoreElements(); 
             ) {
            VAJProjectDescription d = (VAJProjectDescription) e.nextElement();
            ProjectEdition pe = findProjectEdition(d.getName(), d.getVersion());
            try {
                log( ""Loading "" + d.getName() + "", Version "" + d.getVersion() + 
                     "", into Workspace"", 
                     Project.MSG_VERBOSE ); 
                pe.loadIntoWorkspace();
            } catch (IvjException ex) {
                throw VAJUtil.createBuildException( ""Project "" + d.getName() + 
                                                    "" could not be loaded."", 
                                                    ex ); 
            }
        }
    }
    /**
     */
    public void expandDescriptions() {
        String[] projectNames;
        try {
            projectNames = VAJUtil.getWorkspace().getRepository().getProjectNames();
        } catch (IvjException e) {
            throw VAJUtil.createBuildException(""VA Exception occured: "", e);
        }
        for (int i = 0; i < projectNames.length; i++) {
            for (Enumeration e = projectDescriptions.elements(); e.hasMoreElements();) {
                VAJProjectDescription d = (VAJProjectDescription) e.nextElement();
                String pattern = d.getName();
                if (VAJWorkspaceScanner.match(pattern, projectNames[i])) {
                    d.setProjectFound();
                    expandedProjectDescriptions.
                        addElement(new VAJProjectDescription(projectNames[i], d.getVersion())); 
                    break;
                }
            }
        }
        for (Enumeration e = projectDescriptions.elements(); e.hasMoreElements();) {
            VAJProjectDescription d = (VAJProjectDescription) e.nextElement();
            if (!d.projectFound()) {
                log(""No Projects match the name "" + d.getName(), Project.MSG_WARN);
            }
        }
    }
    /**
     */
    public static Vector findMatchingProjects(String pattern) {
        String[] projectNames;
        try {
            projectNames = VAJUtil.getWorkspace().getRepository().getProjectNames();
        } catch (IvjException e) {
            throw VAJUtil.createBuildException(""VA Exception occured: "", e);
        }
        Vector matchingProjects = new Vector();
        for (int i = 0; i < projectNames.length; i++) {
            if (VAJWorkspaceScanner.match(pattern, projectNames[i])) {
                matchingProjects.addElement(projectNames[i]);
            }
        }
        return matchingProjects;
    }
    /**
     * Finds a specific project edition in the repository.
     *
     * @param name project name
     * @param versionName project version name
     * @return com.ibm.ivj.util.base.ProjectEdition
     */
    public static ProjectEdition findProjectEdition(
                                                    String name, 
                                                    String versionName) {
        try {
            ProjectEdition[] editions = null;
            editions = VAJUtil.getWorkspace().getRepository().getProjectEditions(name);
            if (editions == null) {
                throw new BuildException(""Project "" + name + "" doesn't exist"");
            }
            ProjectEdition pe = null;
            for (int i = 0; i < editions.length && pe == null; i++) {
                if (versionName.equals(editions[i].getVersionName())) {
                    pe = editions[i];
                }
            }
            if (pe == null) {
                throw new BuildException( ""Version "" + versionName + "" of Project "" + 
                                          name + "" doesn't exist"" ); 
            }
            return pe;
        } catch (IvjException e) {
            throw VAJUtil.createBuildException(""VA Exception occured: "", e);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJUtil,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ide;
import com.ibm.ivj.util.base.IvjException;
import com.ibm.ivj.util.base.ToolEnv;
import com.ibm.ivj.util.base.Workspace;
import org.apache.tools.ant.BuildException;
/**
 * Helper class for VAJ tasks. Holds Workspace singleton and
 * wraps IvjExceptions into BuildExceptions
 *
 * @author Wolf Siberski, TUI Infotec GmbH
 */
class VAJUtil {
    static private Workspace workspace;
    /**
     * Wraps IvjException into a BuildException
     *
     * @return org.apache.tools.ant.BuildException
     * @param errMsg Additional error message
     * @param e IvjException which is wrapped
     */
    public static BuildException createBuildException(
                                                      String errMsg, 
                                                      IvjException e) {
        errMsg = errMsg + ""\n"" + e.getMessage();
        String[] errors = e.getErrors();
        if (errors != null) {
            for (int i = 0; i < errors.length; i++) {
                errMsg = errMsg + ""\n"" + errors[i];
            }
        }
        return new BuildException(errMsg);
    }
    /**
     * Insert the method's description here.
     * Creation date: (19.09.2000 13:41:21)
     * @return com.ibm.ivj.util.base.Workspace
     */
    public static Workspace getWorkspace() {
        if (workspace == null) {
            workspace = ToolEnv.connectToWorkspace();
            if (workspace == null) {
                throw new BuildException(
                                         ""Unable to connect to Workspace! ""
                                         + ""Make sure you are running in VisualAge for Java.""); 
            }
        }
        return workspace;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ide.VAJWorkspaceScanner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.ide;
import com.ibm.ivj.util.base.IvjException;
import com.ibm.ivj.util.base.Package;
import com.ibm.ivj.util.base.Project;
import java.io.File;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.DirectoryScanner;
/**
 * Class for scanning a Visual Age for Java workspace for packages matching
 * a certain criteria.
 * <p>
 * These criteria consist of a set of include and exclude patterns. With these
 * patterns, you can select which packages you want to have included, and which
 * packages you want to have excluded.  You can add patterns to be excluded by
 * default with the addDefaultExcludes method.  The patters that are excluded
 * by default include
 * <ul>
 *   <li>IBM*\**</li>
 *   <li>Java class libraries\**</li>
 *   <li>Sun class libraries*\**</li>
 *   <li>JSP Page Compile Generated Code\**</li>
 *   <li>VisualAge*\**</li>
 * </ul>
 * <p>
 * This class works like DirectoryScanner. 
 *
 * @see org.apache.tools.ant.DirectoryScanner
 *
 * @author Wolf Siberski, TUI Infotec (based on Arnout J. Kuipers DirectoryScanner)
 */
public class VAJWorkspaceScanner extends DirectoryScanner {
    /**
     * Patterns that should be excluded by default.
     *
     * @see #addDefaultExcludes()
     */
    private final static String[] DEFAULTEXCLUDES = 
    {
        ""IBM*/**"", 
        ""Java class libraries/**"", 
        ""Sun class libraries*/**"", 
        ""JSP Page Compile Generated Code/**"", 
        ""VisualAge*/**"", 
    }; 
    /**
     * The packages that where found and matched at least one includes, and
     * matched no excludes.
     */
    private Vector packagesIncluded = new Vector();
    /**
     * Adds the array with default exclusions to the current exclusions set.
     */
    public void addDefaultExcludes() {
        int excludesLength = excludes == null ? 0 : excludes.length;
        String[] newExcludes;
        newExcludes = new String[excludesLength + DEFAULTEXCLUDES.length];
        if (excludesLength > 0) {
            System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);
        }
        for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {
            newExcludes[i + excludesLength] = DEFAULTEXCLUDES[i].
                replace( '/', File.separatorChar ).replace( '\\', File.separatorChar ); 
        }
        excludes = newExcludes;
    }
    /**
     * Finds all Projects specified in include patterns.
     *
     * @return the projects
     */
    public Vector findMatchingProjects() {
        Project[] projects = VAJUtil.getWorkspace().getProjects();
        Vector matchingProjects = new Vector();
        boolean allProjectsMatch = false;
        for (int i = 0; i < projects.length; i++) {
            Project project = projects[i];
            for (int j = 0; j < includes.length && !allProjectsMatch; j++) {
                StringTokenizer tok = new StringTokenizer(includes[j], File.separator);
                String projectNamePattern = tok.nextToken();
                if (projectNamePattern.equals(""**"")) {
                    // if an include pattern starts with '**', 
                    // all projects match
                    allProjectsMatch = true;
                } else
                    if (match(projectNamePattern, project.getName())) {
                        matchingProjects.addElement(project);
                        break;
                    }
            }
        }
        if (allProjectsMatch) {
            matchingProjects = new Vector();
            for (int i = 0; i < projects.length; i++) {
                matchingProjects.addElement(projects[i]);
            }
        }
        return matchingProjects;
    }
    /**
     * Get the names of the packages that matched at least one of the include
     * patterns, and didn't match one of the exclude patterns.
     *
     * @return the matching packages
     */
    public Package[] getIncludedPackages() {
        int count = packagesIncluded.size();
        Package[] packages = new Package[count];
        for (int i = 0; i < count; i++) {
            packages[i] = (Package) packagesIncluded.elementAt(i);
        }
        return packages;
    }
    /**
     * Matches a string against a pattern. The pattern contains two special
     * characters:
     * '*' which means zero or more characters,
     * '?' which means one and only one character.
     *
     * @param pattern the (non-null) pattern to match against
     * @param str     the (non-null) string that must be matched against the
     *                pattern
     *
     * @return <code>true</code> when the string matches against the pattern,
     *         <code>false</code> otherwise.
     */
    protected static boolean match(String pattern, String str) {
        return DirectoryScanner.match(pattern, str);
    }
    /**
     * Scans the workspace for packages that match at least one include
     * pattern, and don't match any exclude patterns.
     *
     */
    public void scan() {
        if (includes == null) {
            // No includes supplied, so set it to 'matches all'
            includes = new String[1];
            includes[0] = ""**"";
        }
        if (excludes == null) {
            excludes = new String[0];
        }
        // only scan projects which are included in at least one include pattern
        Vector matchingProjects = findMatchingProjects();
        for (Enumeration e = matchingProjects.elements(); e.hasMoreElements();) {
            Project project = (Project) e.nextElement();
            scanProject(project);
        }
    }
    /**
     * Scans a project for packages that match at least one include
     * pattern, and don't match any exclude patterns.
     *
     */
    public void scanProject(Project project) {
        try {
            Package[] packages = project.getPackages();
            if (packages != null) {
                for (int i = 0; i < packages.length; i++) {
                    Package item = packages[i];
                    // replace '.' by file seperator because the patterns are
                    // using file seperator syntax (and we can use the match
                    // methods this way).
                    String name = 
                        project.getName()
                        + File.separator
                        + item.getName().replace('.', File.separatorChar); 
                    if (isIncluded(name) && !isExcluded(name)) {
                        packagesIncluded.addElement(item);
                    }
                }
            }
        } catch (IvjException e) {
            throw VAJUtil.createBuildException(""VA Exception occured: "", e);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.javacc.JavaCC,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.javacc;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Enumeration;
/**
 * Taskdef for the JavaCC compiler compiler.
 *
 * @author thomas.haas@softwired-inc.com
 * @author Michael Saunders <a href=""mailto:michael@amtec.com"">michael@amtec.com</a>
 */
public class JavaCC extends Task {
    // keys to optional attributes
    private static final String LOOKAHEAD              = ""LOOKAHEAD"";
    private static final String CHOICE_AMBIGUITY_CHECK = ""CHOICE_AMBIGUITY_CHECK"";
    private static final String OTHER_AMBIGUITY_CHECK  = ""OTHER_AMBIGUITY_CHECK"";
    private static final String STATIC                 = ""STATIC"";
    private static final String DEBUG_PARSER           = ""DEBUG_PARSER"";
    private static final String DEBUG_LOOKAHEAD        = ""DEBUG_LOOKAHEAD"";
    private static final String DEBUG_TOKEN_MANAGER    = ""DEBUG_TOKEN_MANAGER"";
    private static final String OPTIMIZE_TOKEN_MANAGER = ""OPTIMIZE_TOKEN_MANAGER"";
    private static final String ERROR_REPORTING        = ""ERROR_REPORTING"";
    private static final String JAVA_UNICODE_ESCAPE    = ""JAVA_UNICODE_ESCAPE"";
    private static final String UNICODE_INPUT          = ""UNICODE_INPUT"";
    private static final String IGNORE_CASE            = ""IGNORE_CASE"";
    private static final String COMMON_TOKEN_ACTION    = ""COMMON_TOKEN_ACTION"";
    private static final String USER_TOKEN_MANAGER     = ""USER_TOKEN_MANAGER"";
    private static final String USER_CHAR_STREAM       = ""USER_CHAR_STREAM"";
    private static final String BUILD_PARSER           = ""BUILD_PARSER"";
    private static final String BUILD_TOKEN_MANAGER    = ""BUILD_TOKEN_MANAGER"";
    private static final String SANITY_CHECK           = ""SANITY_CHECK"";
    private static final String FORCE_LA_CHECK         = ""FORCE_LA_CHECK"";
    private static final String CACHE_TOKENS           = ""CACHE_TOKENS"";
    private final Hashtable optionalAttrs = new Hashtable();
    // required attributes
    private File outputDirectory = null;
    private File target          = null;
    private File javaccHome      = null;
    private CommandlineJava cmdl = new CommandlineJava();
    public void setLookahead(int lookahead) {
        optionalAttrs.put(LOOKAHEAD, new Integer(lookahead));
    }
    public void setChoiceambiguitycheck(int choiceAmbiguityCheck) {
        optionalAttrs.put(CHOICE_AMBIGUITY_CHECK, new Integer(choiceAmbiguityCheck));
    }
    public void setOtherambiguityCheck(int otherAmbiguityCheck) {
        optionalAttrs.put(OTHER_AMBIGUITY_CHECK, new Integer(otherAmbiguityCheck));
    }
    public void setStatic(boolean staticParser) {
        optionalAttrs.put(STATIC, new Boolean(staticParser));
    }
    public void setDebugparser(boolean debugParser) {
        optionalAttrs.put(DEBUG_PARSER, new Boolean(debugParser));
    }
    public void setDebuglookahead(boolean debugLookahead) {
        optionalAttrs.put(DEBUG_LOOKAHEAD, new Boolean(debugLookahead));
    }
    public void setDebugtokenmanager(boolean debugTokenManager) {
        optionalAttrs.put(DEBUG_TOKEN_MANAGER, new Boolean(debugTokenManager));
    }
    public void setOptimizetokenmanager(boolean optimizeTokenManager) {
        optionalAttrs.put(OPTIMIZE_TOKEN_MANAGER, new Boolean(optimizeTokenManager));
    }
    public void setErrorreporting(boolean errorReporting) {
        optionalAttrs.put(ERROR_REPORTING, new Boolean(errorReporting));
    }
    public void setJavaunicodeescape(boolean javaUnicodeEscape) {
        optionalAttrs.put(JAVA_UNICODE_ESCAPE, new Boolean(javaUnicodeEscape));
    }
    public void setUnicodeinput(boolean unicodeInput) {
        optionalAttrs.put(UNICODE_INPUT, new Boolean(unicodeInput));
    }
    public void setIgnorecase(boolean ignoreCase) {
        optionalAttrs.put(IGNORE_CASE, new Boolean(ignoreCase));
    }
    public void setCommontokenaction(boolean commonTokenAction) {
        optionalAttrs.put(COMMON_TOKEN_ACTION, new Boolean(commonTokenAction));
    }
    public void setUsertokenmanager(boolean userTokenManager) {
        optionalAttrs.put(USER_TOKEN_MANAGER, new Boolean(userTokenManager));
    }
    public void setUsercharstream(boolean userCharStream) {
        optionalAttrs.put(USER_CHAR_STREAM, new Boolean(userCharStream));
    }
    public void setBuildparser(boolean buildParser) {
        optionalAttrs.put(BUILD_PARSER, new Boolean(buildParser));
    }
    public void setBuildtokenmanager(boolean buildTokenManager) {
        optionalAttrs.put(BUILD_TOKEN_MANAGER, new Boolean(buildTokenManager));
    }
    public void setSanitycheck(boolean sanityCheck) {
        optionalAttrs.put(SANITY_CHECK, new Boolean(sanityCheck));
    }
    public void setForcelacheck(boolean forceLACheck) {
        optionalAttrs.put(FORCE_LA_CHECK, new Boolean(forceLACheck));
    }
    public void setCachetokens(boolean cacheTokens) {
        optionalAttrs.put(CACHE_TOKENS, new Boolean(cacheTokens));
    }
    public void setOutputdirectory(File outputDirectory) {
        this.outputDirectory = outputDirectory;
    }
    public void setTarget(File target) {
        this.target = target;
    }
    public void setJavacchome(File javaccHome) {
        this.javaccHome = javaccHome;
    }
    public JavaCC() {
        cmdl.setVm(""java"");
        cmdl.setClassname(""COM.sun.labs.javacc.Main"");
    }
    public void execute() throws BuildException {
        // load command line with optional attributes
        Enumeration iter = optionalAttrs.keys();
        while (iter.hasMoreElements()) {
            String name  = (String)iter.nextElement();
            Object value = optionalAttrs.get(name);
            cmdl.createArgument().setValue(""-""+name+"":""+value.toString());
        }
        // check the target is a file
        if (target == null || !target.isFile()) {
            throw new BuildException(""Invalid target: "" + target);
        }
        // use the directory containing the target as the output directory
        if (outputDirectory == null) {
            outputDirectory = new File(target.getParent());
        }
        else if (!outputDirectory.isDirectory()) {
            throw new BuildException(""Outputdir not a directory."");
        }
        cmdl.createArgument().setValue(
            ""-OUTPUT_DIRECTORY:""+outputDirectory.getAbsolutePath());
        // determine if the generated java file is up-to-date
        final File javaFile = getOutputJavaFile(outputDirectory, target);
        if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) {
            log(""Target is already built - skipping ("" + target + "")"", Project.MSG_VERBOSE);
            return;
        }
        cmdl.createArgument().setValue(target.getAbsolutePath());
        if (javaccHome == null || !javaccHome.isDirectory()) {
            throw new BuildException(""Javacchome not set."");
        }
        final Path classpath = cmdl.createClasspath(project);
        classpath.createPathElement().setPath(javaccHome.getAbsolutePath() +
                                                  ""/JavaCC.zip"");
        final Commandline.Argument arg = cmdl.createVmArgument();
        arg.setValue(""-mx140M"");
        arg.setValue(""-Dinstall.root=""+javaccHome.getAbsolutePath());
        Execute.runCommand(this, cmdl.getCommandline());
    }
    /**
     * Determines the output Java file to be generated by the given grammar
     * file.
     * 
     */
    private File getOutputJavaFile(File outputdir, File srcfile)
    {
        String path = srcfile.getPath();
        // Extract file's base-name
        int startBasename = path.lastIndexOf(File.separator);
        if ( startBasename != -1 ) {
            path = path.substring(startBasename+1);
        }
        // Replace the file's extension with '.java'
        int startExtn = path.lastIndexOf('.');
        if (startExtn != -1) {
            path = path.substring(0, startExtn) + "".java"";
        }
        else {
            path += "".java"";
        }
        // Change the directory
        if (outputdir != null) {
            path = outputdir + File.separator + path;
        }
        return new File(path);
    }
}
"
org.apache.tools.ant.taskdefs.optional.javacc.JJTree,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.javacc;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Enumeration;
/**
 * Taskdef for the JJTree compiler compiler.
 *
 * @author thomas.haas@softwired-inc.com
 * @author Michael Saunders <a href=""mailto:michael@amtec.com"">michael@amtec.com</a>
 */
public class JJTree extends Task {
    // keys to optional attributes
    private static final String BUILD_NODE_FILES  = ""BUILD_NODE_FILES"";
    private static final String MULTI             = ""MULTI"";
    private static final String NODE_DEFAULT_VOID = ""NODE_DEFAULT_VOID"";
    private static final String NODE_FACTORY      = ""NODE_FACTORY"";
    private static final String NODE_SCOPE_HOOK   = ""NODE_SCOPE_HOOK"";
    private static final String NODE_USES_PARSER  = ""NODE_USES_PARSER"";
    private static final String STATIC            = ""STATIC"";
    private static final String VISITOR           = ""VISITOR"";
    private static final String NODE_PACKAGE      = ""NODE_PACKAGE"";
    private static final String VISITOR_EXCEPTION = ""VISITOR_EXCEPTION"";
    private static final String NODE_PREFIX       = ""NODE_PREFIX"";
    private final Hashtable optionalAttrs = new Hashtable();
    // required attributes
    private File outputDirectory = null;
    private File target          = null;
    private File javaccHome      = null;
    private CommandlineJava cmdl = new CommandlineJava();
    public void setBuildnodefiles(boolean buildNodeFiles) {
        optionalAttrs.put(BUILD_NODE_FILES, new Boolean(buildNodeFiles));
    }
    public void setMulti(boolean multi) {
        optionalAttrs.put(MULTI, new Boolean(multi));
    }
    public void setNodedefaultvoid(boolean nodeDefaultVoid) {
        optionalAttrs.put(NODE_DEFAULT_VOID, new Boolean(nodeDefaultVoid));
    }
    public void setNodefactory(boolean nodeFactory) {
        optionalAttrs.put(NODE_FACTORY, new Boolean(nodeFactory));
    }
    public void setNodescopehook(boolean nodeScopeHook) {
        optionalAttrs.put(NODE_SCOPE_HOOK, new Boolean(nodeScopeHook));
    }
    public void setNodeusesparser(boolean nodeUsesParser) {
        optionalAttrs.put(NODE_USES_PARSER, new Boolean(nodeUsesParser));
    }
    public void setStatic(boolean staticParser) {
        optionalAttrs.put(STATIC, new Boolean(staticParser));
    }
    public void setVisitor(boolean visitor) {
        optionalAttrs.put(VISITOR, new Boolean(visitor));
    }
    public void setNodepackage(String nodePackage) {
        optionalAttrs.put(NODE_PACKAGE, new String(nodePackage));
    }
    public void setVisitorException(String visitorException) {
        optionalAttrs.put(VISITOR_EXCEPTION, new String(visitorException));
    }
    public void setNodeprefix(String nodePrefix) {
        optionalAttrs.put(NODE_PREFIX, new String(nodePrefix));
    }
    public void setOutputdirectory(File outputDirectory) {
        this.outputDirectory = outputDirectory;
    }
    public void setTarget(File target) {
        this.target = target;
    }
    public void setJavacchome(File javaccHome) {
        this.javaccHome = javaccHome;
    }
    public JJTree() {
        cmdl.setVm(""java"");
        cmdl.setClassname(""COM.sun.labs.jjtree.Main"");
    }
    public void execute() throws BuildException {
        // load command line with optional attributes
        Enumeration iter = optionalAttrs.keys();
        while (iter.hasMoreElements()) {
            String name  = (String)iter.nextElement();
            Object value = optionalAttrs.get(name);
            cmdl.createArgument().setValue(""-""+name+"":""+value.toString());
        }
        if (target == null || !target.isFile()) {
            throw new BuildException(""Invalid target: "" + target);
        }
        // use the directory containing the target as the output directory
        if (outputDirectory == null) {
            outputDirectory = new File(target.getParent());
        }        
        if (!outputDirectory.isDirectory() ) {
            throw new BuildException(""'outputdirectory' "" + outputDirectory + "" is not a directory."");
        }
        // convert backslashes to slashes, otherwise jjtree will put this as
        // comments and this seems to confuse javacc
        cmdl.createArgument().setValue(
            ""-OUTPUT_DIRECTORY:""+outputDirectory.getAbsolutePath().replace('\\', '/'));
        final File javaFile = new File(
            target.toString().substring(0, target.toString().indexOf("".jjt"")) + "".jj"");
        if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) {
            project.log(""Target is already built - skipping ("" + target + "")"");
            return;
        }
        cmdl.createArgument().setValue(target.getAbsolutePath());
        if (javaccHome == null || !javaccHome.isDirectory()) {
            throw new BuildException(""Javacchome not set."");
        }
        final Path classpath = cmdl.createClasspath(project);
        classpath.createPathElement().setPath(javaccHome.getAbsolutePath() +
                                                  ""/JavaCC.zip"");
        final Commandline.Argument arg = cmdl.createVmArgument();
        arg.setValue(""-mx140M"");
        arg.setValue(""-Dinstall.root=""+javaccHome.getAbsolutePath());
        final Execute process =
            new Execute(new LogStreamHandler(this,
                                             Project.MSG_INFO,
                                             Project.MSG_INFO),
                        null);
        log(cmdl.toString(), Project.MSG_VERBOSE);
        process.setCommandline(cmdl.getCommandline());
        try {
            if (process.execute() != 0) {
                throw new BuildException(""JJTree failed."");
            }
        }
        catch (IOException e) {
            throw new BuildException(""Failed to launch JJTree: "" + e);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.jlink.ClassNameReader,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.jlink;
import java.io .*;
/**
 * Reads just enough of a class file to determine the class' full name.
 *
 * <p>Extremely minimal constant pool implementation, mainly to support extracting
 * strings from a class file.
 * @author <a href=""mailto:beard@netscape.com"">Patrick C. Beard</a>.
 */
class ConstantPool extends Object{
    static final 
        byte UTF8 = 1, UNUSED = 2, INTEGER = 3, FLOAT = 4, LONG = 5, DOUBLE = 6,
        CLASS = 7, STRING = 8, FIELDREF = 9, METHODREF = 10,
        INTERFACEMETHODREF = 11, NAMEANDTYPE = 12;
    byte[] types;
    Object[] values;
    ConstantPool( DataInput data ) throws IOException {
        super();
        int count = data .readUnsignedShort();
        types = new byte [ count ];
        values = new Object [ count ];
        // read in all constant pool entries.
        for ( int i = 1; i < count; i++ ) {
            byte type = data .readByte();
            types[i] = type;
            switch (type)
            {
            case UTF8 :
                values[i] = data .readUTF();
                break;
            case UNUSED :
                break;
            case INTEGER :
                values[i] = new Integer( data .readInt() );
                break;
            case FLOAT :
                values[i] = new Float( data .readFloat() );
                break;
            case LONG :
                values[i] = new Long( data .readLong() );
                ++i;
                break;
            case DOUBLE :
                values[i] = new Double( data .readDouble() );
                ++i;
                break;
            case CLASS :
            case STRING :
                values[i] = new Integer( data .readUnsignedShort() );
                break;
            case FIELDREF :
            case METHODREF :
            case INTERFACEMETHODREF :
            case NAMEANDTYPE :
                values[i] = new Integer( data .readInt() );
                break;
            }
        }
    }
}
/**
 * Provides a quick and dirty way to determine the true name of a class
 * given just an InputStream. Reads in just enough to perform this
 * minimal task only.
 */
public class ClassNameReader extends Object{
    public static 
        String getClassName( InputStream input ) throws IOException {
        DataInputStream data = new DataInputStream( input );
        // verify this is a valid class file.
        int cookie = data .readInt();
        if ( cookie != 0xCAFEBABE ) {
            return null;
        }
        int version = data .readInt();
        // read the constant pool.
        ConstantPool constants = new ConstantPool( data );
        Object[] values = constants .values;
        // read access flags and class index.
        int accessFlags = data .readUnsignedShort();
        int classIndex = data .readUnsignedShort();
        Integer stringIndex = (Integer) values[classIndex];
        String className = (String) values[stringIndex .intValue()];
        return className;
    }
}
"
org.apache.tools.ant.taskdefs.optional.jlink.jlink,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/**
 * jlink.java
 * links together multiple .jar files
 * 
 * Original code by Patrick Beard. Modifications to work
 * with ANT by Matthew Kuperus Heun.
 *
 * @author <a href=""mailto:beard@netscape.com>Patrick C. Beard</a>.
 * @author <a href=""mailto:matthew.k.heun@gaerospace.com>Matthew Kuperus Heun</a>
 */
package org.apache.tools.ant.taskdefs.optional.jlink;
import java.io .*;
import java.util .Enumeration;
import java.util .Vector;
import java.util.zip .*;
public class jlink extends Object{
    /**
     * The file that will be created by this instance of jlink.
     */
    public  void setOutfile( String outfile ) {
        if ( outfile == null ) {
            return ;
        }
        this .outfile = outfile;
    }
    /**
     * Adds a file to be merged into the output.
     */
    public  void addMergeFile( String mergefile ) {
        if ( mergefile == null ) {
            return ;
        }
        mergefiles .addElement( mergefile );
    }
    /**
     * Adds a file to be added into the output.
     */
    public  void addAddFile( String addfile ) {
        if ( addfile == null ) {
            return ;
        }
        addfiles .addElement( addfile );
    }
    /**
     * Adds several files to be merged into the output.
     */
    public  void addMergeFiles( String[] mergefiles ) {
        if ( mergefiles == null ) {
            return ;
        }
        for ( int i = 0; i < mergefiles .length; i++ ) {
            addMergeFile( mergefiles[i] );
        }
    }
    /**
     * Adds several file to be added into the output.
     */
    public  void addAddFiles( String[] addfiles ) {
        if ( addfiles == null ) {
            return ;
        }
        for ( int i = 0; i < addfiles .length; i++ ) {
            addAddFile( addfiles[i] );
        }
    }
    /**
     * Determines whether output will be compressed.
     */
    public  void setCompression( boolean compress ) {
        this .compression = compress;
    }
    /**
     * Performs the linking of files.
     * Addfiles are added to the output as-is. For example, a 
     * jar file is added to the output as a jar file.
     * However, mergefiles are first examined for their type.
     * If it is a jar or zip file, the contents will be extracted
     * from the mergefile and entered into the output.
     * If a zip or jar file is encountered in a subdirectory
     * it will be added, not merged.
     * If a directory is encountered, it becomes the root
     * entry of all the files below it.  Thus, you can
     * provide multiple, disjoint directories, as
     * addfiles: they will all be added in a rational 
     * manner to outfile.
     */
    public  void link() throws Exception {
        ZipOutputStream output = new ZipOutputStream( new FileOutputStream( outfile ) );
        if ( compression ) {
            output .setMethod( ZipOutputStream .DEFLATED );
            output .setLevel( Deflater .DEFAULT_COMPRESSION );
        } else {
            output .setMethod( ZipOutputStream .STORED );
        }
        Enumeration merges = mergefiles .elements();
        while ( merges .hasMoreElements() ) {
            String path = (String) merges .nextElement();
            File f = new File( path );
            if ( f.getName().endsWith( "".jar"" ) || f.getName().endsWith( "".zip"" ) ) {
                                //Do the merge
                mergeZipJarContents( output, f );
            }
            else {
                //Add this file to the addfiles Vector and add it 
                //later at the top level of the output file.
                addAddFile( path );
            }
        }
        Enumeration adds = addfiles .elements();
        while ( adds .hasMoreElements() ) {
            String name = (String) adds .nextElement();
            File f = new File( name );
            if ( f .isDirectory() ) {
                //System.out.println(""in jlink: adding directory contents of "" + f.getPath());
                addDirContents( output, f, f.getName() + '/', compression );
            }
            else {
                addFile( output, f, """", compression );
            }
        }
        if ( output != null ) {
            try  {
                output .close();
            } catch( IOException ioe ) {}
        }
    }
    public static  void main( String[] args ) {
        // jlink output input1 ... inputN
        if ( args .length < 2 ) {
            System .out .println( ""usage: jlink output input1 ... inputN"" );
            System .exit( 1 );
        }
        jlink linker = new jlink();
        linker .setOutfile( args[0] );
        //To maintain compatibility with the command-line version, we will only add files to be merged.
        for ( int i = 1; i < args .length; i++ ) {
            linker .addMergeFile( args[i] );
        }
        try  {
            linker .link();
        } catch( Exception ex ) {
            System .err .print( ex .getMessage() );
        }
    }
    /*
     * Actually performs the merging of f into the output.
     * f should be a zip or jar file.
     */
    private void mergeZipJarContents( ZipOutputStream output, File f ) throws IOException {
        //Check to see that the file with name ""name"" exists.
        if ( ! f .exists() ) {
            return ;
        }
        ZipFile zipf = new ZipFile( f );
        Enumeration entries = zipf.entries();
        while (entries.hasMoreElements()){
            ZipEntry inputEntry = (ZipEntry) entries.nextElement();
            //Ignore manifest entries.  They're bound to cause conflicts between
            //files that are being merged.  User should supply their own
            //manifest file when doing the merge.
            String inputEntryName = inputEntry.getName();
            int index = inputEntryName.indexOf(""META-INF"");
            if (index < 0){
                //META-INF not found in the name of the entry. Go ahead and process it.
                try {
                    output.putNextEntry(processEntry(zipf, inputEntry));
                } catch (ZipException ex){
                    //If we get here, it could be because we are trying to put a
                    //directory entry that already exists.
                    //For example, we're trying to write ""com"", but a previous
                    //entry from another mergefile was called ""com"".
                    //In that case, just ignore the error and go on to the
                    //next entry.
                    String mess = ex.getMessage();
                    if (mess.indexOf(""duplicate"") >= 0){
                                //It was the duplicate entry.
                        continue;
                    } else {
                                //I hate to admit it, but we don't know what happened here.  Throw the Exception.
                        throw ex;
                    }
                }
                InputStream in = zipf.getInputStream(inputEntry);
                int len = buffer.length;
                int count = -1;
                while ((count = in.read(buffer, 0, len)) > 0){
                    output.write(buffer, 0, count);
                }
                in.close();
                output.closeEntry();
            }
        }
        zipf .close();
    }
    /*
     * Adds contents of a directory to the output.
     */
    private void addDirContents( ZipOutputStream output, File dir, String prefix, boolean compress ) throws IOException {
        String[] contents = dir .list();
        for ( int i = 0; i < contents .length; ++i ) {
            String name = contents[i];
            File file = new File( dir, name );
            if ( file .isDirectory() ) {
                addDirContents( output, file, prefix + name + '/', compress );
            }
            else {
                addFile( output, file, prefix, compress );
            }
        }
    }
    /*
     * Gets the name of an entry in the file.  This is the real name
     * which for a class is the name of the package with the class
     * name appended.
     */
    private String getEntryName( File file, String prefix ) {
        String name = file .getName();
        if ( ! name .endsWith( "".class"" ) ) {
            // see if the file is in fact a .class file, and determine its actual name.
            try  {
                InputStream input = new FileInputStream( file );
                String className = ClassNameReader .getClassName( input );
                input .close();
                if ( className != null ) {
                    return className .replace( '.', '/' ) + "".class"";
                }
            } catch( IOException ioe ) {}
        }
        System.out.println(""From "" + file.getPath() + "" and prefix "" + prefix + "", creating entry "" + prefix+name);
        return (prefix + name);
    }
    /*
     * Adds a file to the output stream.
     */
    private void addFile( ZipOutputStream output, File file, String prefix, boolean compress) throws IOException {
        //Make sure file exists
        long checksum = 0;
        if ( ! file .exists() ) {
            return ;
        }
        ZipEntry entry = new ZipEntry( getEntryName( file, prefix ) );
        entry .setTime( file .lastModified() );
        entry .setSize( file .length() );
        if (! compress){
            entry.setCrc(calcChecksum(file));
        }
        FileInputStream input = new FileInputStream( file );
        addToOutputStream(output, input, entry);
    }
    /*
     * A convenience method that several other methods might call.
     */
    private void addToOutputStream(ZipOutputStream output, InputStream input, ZipEntry ze) throws IOException{
        try {
            output.putNextEntry(ze);            
        } catch (ZipException zipEx) {
            //This entry already exists. So, go with the first one.
            input.close();
            return;
        }
        int numBytes = -1;
        while((numBytes = input.read(buffer)) > 0){
            output.write(buffer, 0, numBytes);
        }
        output.closeEntry();
        input.close();
    }
    /*
     * A method that does the work on a given entry in a mergefile.
     * The big deal is to set the right parameters in the ZipEntry 
     * on the output stream.
     */
    private ZipEntry processEntry( ZipFile zip, ZipEntry inputEntry ) throws IOException{
        /*
          First, some notes.
          On MRJ 2.2.2, getting the size, compressed size, and CRC32 from the
          ZipInputStream does not work for compressed (deflated) files.  Those calls return -1.
          For uncompressed (stored) files, those calls do work.
          However, using ZipFile.getEntries() works for both compressed and 
          uncompressed files.
          Now, from some simple testing I did, it seems that the value of CRC-32 is
          independent of the compression setting. So, it should be easy to pass this 
          information on to the output entry.
        */
        String name = inputEntry .getName();
        if ( ! (inputEntry .isDirectory() || name .endsWith( "".class"" )) ) {
            try  {
                InputStream input = zip.getInputStream( zip .getEntry( name ) );
                String className = ClassNameReader .getClassName( input );
                input .close();
                if ( className != null ) {
                    name = className .replace( '.', '/' ) + "".class"";
                }
            } catch( IOException ioe ) {}
        }
        ZipEntry outputEntry = new ZipEntry( name );
        outputEntry.setTime(inputEntry .getTime() );
        outputEntry.setExtra(inputEntry.getExtra());
        outputEntry.setComment(inputEntry.getComment());
        outputEntry.setTime(inputEntry.getTime());
        if (compression){
            outputEntry.setMethod(ZipEntry.DEFLATED);
            //Note, don't need to specify size or crc for compressed files.
        } else {
            outputEntry.setMethod(ZipEntry.STORED);
            outputEntry.setCrc(inputEntry.getCrc());
            outputEntry.setSize(inputEntry.getSize());
        }
        return outputEntry;
    }
    /*
     * Necessary in the case where you add a entry that
     * is not compressed.
     */
    private long calcChecksum(File f) throws IOException {
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));
        return calcChecksum(in, f.length());
    }
    /*
     * Necessary in the case where you add a entry that
     * is not compressed.
     */
    private long calcChecksum(InputStream in, long size) throws IOException{
        CRC32 crc = new CRC32();
        int len = buffer.length;
        int count = -1;
        int haveRead = 0; 
        while((count=in.read(buffer, 0, len)) > 0){
            haveRead += count;
            crc.update(buffer, 0, count);
        }
        in.close();
        return crc.getValue();
    }
    private  String outfile = null;
    private  Vector mergefiles = new Vector( 10 );
    private  Vector addfiles = new Vector( 10 );
    private  boolean compression = false;
    byte[] buffer = new byte[8192];
}
"
org.apache.tools.ant.taskdefs.optional.jlink.JlinkTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.jlink;
import org.apache.tools.ant .*;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types .*;
import java.io.File;
/**
 * This class defines objects that can link together various jar and
 * zip files. 
 *
 * <p>It is basically a wrapper for the jlink code written originally
 * by <a href=""mailto:beard@netscape.com"">Patrick Beard</a>.  The
 * classes org.apache.tools.ant.taskdefs.optional.jlink.Jlink and
 * org.apache.tools.ant.taskdefs.optional.jlink.ClassNameReader
 * support this class.</p>
 *
 * <p>For example:
 * <code>
 * <pre>
 * &lt;jlink compress=&quot;false&quot; outfile=&quot;out.jar&quot;/&gt;
 *   &lt;mergefiles&gt;
 *     &lt;pathelement path=&quot;${build.dir}/mergefoo.jar&quot;/&gt;
 *     &lt;pathelement path=&quot;${build.dir}/mergebar.jar&quot;/&gt;
 *   &lt;/mergefiles&gt;
 *   &lt;addfiles&gt;
 *     &lt;pathelement path=&quot;${build.dir}/mac.jar&quot;/&gt;
 *     &lt;pathelement path=&quot;${build.dir}/pc.zip&quot;/&gt;
 *   &lt;/addfiles&gt;
 * &lt;/jlink&gt;
 * </pre>
 * </code>
 *
 * @author <a href=""mailto:matthew.k.heun@gaerospace.com"">Matthew Kuperus Heun</a> */
public class JlinkTask extends MatchingTask {
    /**
     * The output file for this run of jlink. Usually a jar or zip file.
     */
    public  void setOutfile( File outfile ) {
        this.outfile = outfile;
    }
    /**
     * Establishes the object that contains the files to
     * be merged into the output.
     */
    public  Path createMergefiles() {
        if ( this .mergefiles == null ) {
            this .mergefiles = new Path(getProject());
        }
        return this .mergefiles.createPath();
    }
    /**
     * Sets the files to be merged into the output.
     */
    public  void setMergefiles( Path mergefiles ) {
        if ( this .mergefiles == null ) {
            this .mergefiles = mergefiles;
        }
        else {
            this .mergefiles .append( mergefiles );
        }
    }
    /**
     * Establishes the object that contains the files to
     * be added to the output.
     */
    public  Path createAddfiles() {
        if ( this .addfiles == null ) {
            this .addfiles = new Path(getProject());
        }
        return this .addfiles .createPath();
    }
    /**
     * Sets the files to be added into the output.
     */
    public  void setAddfiles( Path addfiles ) {
        if ( this .addfiles == null ) {
            this .addfiles = addfiles;
        }
        else {
            this .addfiles .append( addfiles );
        }
    }
    /**
     * Defines whether or not the output should be compacted.
     */
    public  void setCompress( boolean compress ) {
        this .compress = compress;
    }
    /**
     * Does the adding and merging.
     */
    public  void execute() throws BuildException {
        //Be sure everything has been set.
        if ( outfile == null ) {
            throw new BuildException( ""outfile attribute is required! Please set."" );
        }
        if (!haveAddFiles() && !haveMergeFiles()) {
            throw new BuildException( ""addfiles or mergefiles required! Please set."" );
        }
        log( ""linking:     "" + outfile.getPath() );
        log( ""compression: "" + compress, Project.MSG_VERBOSE );
        jlink linker = new jlink();
        linker .setOutfile( outfile.getPath() );
        linker .setCompression( compress );
        if (haveMergeFiles()){
            log( ""merge files: "" + mergefiles .toString(), Project .MSG_VERBOSE );
            linker .addMergeFiles( mergefiles .list() );
        }
        if (haveAddFiles()){
            log( ""add files: "" + addfiles .toString(), Project .MSG_VERBOSE );
            linker .addAddFiles( addfiles .list() );
        }
        try  {
            linker .link();
        } catch( Exception ex ) {
            throw new BuildException( ex, location );
        }
    }
    private boolean haveAddFiles(){
        return haveEntries(addfiles);
    }
    private boolean haveMergeFiles(){
        return haveEntries(mergefiles);
    }
    private boolean haveEntries(Path p){
        if (p == null){
            return false;
        }
        if (p.size() > 0){
            return true;
        }
        return false;
    }
    private  File outfile = null;
    private  Path mergefiles = null;
    private  Path addfiles = null;
    private  boolean compress = false;
    private  String ps = System .getProperty( ""path.separator"" );
}
"
org.apache.tools.ant.taskdefs.optional.jsp.WLJspc,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.jsp;
//apache/ant imports
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.Project;
//java imports
import java.io.File;
import java.util.Vector;
import java.util.Date;
import java.util.StringTokenizer;
/**
 * Class to precompile JSP's using weblogic's jsp compiler (weblogic.jspc)
 * 
 * @author <a href=""mailto:avik@aviksengupta.com"">Avik Sengupta</a> http://www.webteksoftware.com
 * 
 * Tested only on Weblogic 4.5.1 - NT4.0 and Solaris 5.7
 * 
 * required attributes
 *      src : root of source tree for JSP, ie, the document root for your weblogic server
 *      dest : root of destination directory, what you have set as WorkingDir in the weblogic properties
 *      package : start package name under which your JSP's would be compiled
 * 
 * other attributes
 *     classpath
 * 
 * A classpath should be set which contains the weblogic classes as well as all application classes
 * referenced by the JSP. The system classpath is also appended when the jspc is called, so you may 
 * choose to put everything in the classpath while calling Ant. However, since presumably the JSP's will reference
 * classes being build by Ant, it would be better to explicitly add the classpath in the task
 * 
 * The task checks timestamps on the JSP's and the generated classes, and compiles
 * only those files that have changed. 
 * 
 * It follows the weblogic naming convention of putting classes in 
 *  <b> _dirName/_fileName.class for dirname/fileName.jsp   </b>
 * 
 * Limitation: It compiles the files thru the Classic compiler only. 
 * Limitation: Since it is my experience that weblogic jspc throws out of memory error on being given too
 *             many files at one go, it is called multiple times with one jsp file each. 
 * 
 * <pre>
 * example
 * <target name=""jspcompile"" depends=""compile"">
 *   <wljspc src=""c:\\weblogic\\myserver\\public_html"" dest=""c:\\weblogic\\myserver\\serverclasses"" package=""myapp.jsp"" >
 *   <classpath>
 *          <pathelement location=""${weblogic.classpath}"" />
 *           <pathelement path=""${compile.dest}"" />
 *      </classpath>
 * 
 *   </wljspc>
 * </target>
 * </pre>
 * 
 */
public class WLJspc extends MatchingTask
{
    //TODO Test on other versions of weblogic
    //TODO add more attributes to the task, to take care of all jspc options
    //TODO Test on Unix
    private File destinationDirectory; //root of compiled files tree
    private File sourceDirectory; // root of source files tree
    private String destinationPackage; //package under which resultant classes will reside
    private Path compileClasspath; //classpath used to compile the jsp files. 
    //private String compilerPath; //fully qualified name for the compiler executable
    private String pathToPackage = """";
    private Vector filesToDo = new Vector();
    public void execute() throws BuildException {
        if (!destinationDirectory.isDirectory()) {
            throw new BuildException(""destination directory "" + destinationDirectory.getPath() + 
                                     "" is not valid"");
        }
        if (!sourceDirectory.isDirectory()) {
            throw new BuildException(""src directory "" + sourceDirectory.getPath() + 
                                     "" is not valid"");
        }
        if (destinationPackage == null) {
            throw new BuildException(""package attribute must be present."", location);
        }
        String systemClassPath = System.getProperty(""java.class.path"");
        pathToPackage = this.destinationPackage.replace('.',File.separatorChar);
        // get all the files in the sourceDirectory
        DirectoryScanner ds = super.getDirectoryScanner(sourceDirectory);
        //use the systemclasspath as well, to include the ant jar
        if (compileClasspath == null) {
            compileClasspath = new Path(project);
        }
        compileClasspath.append(Path.systemClasspath);
        String[] files = ds.getIncludedFiles();
        //Weblogic.jspc calls System.exit() ... have to fork
        // Therefore, takes loads of time 
        // Can pass directories at a time (*.jsp) but easily runs out of memory on hefty dirs 
        // (even on  a Sun)
        Java helperTask = (Java)project.createTask(""java"");
        helperTask.setFork(true);
        helperTask.setClassname(""weblogic.jspc"");
        helperTask.setTaskName(getTaskName());
        String[] args = new String[12];
        File jspFile = null;
        String parents = """";
        String arg = """";
        int j=0;
        //XXX  this array stuff is a remnant of prev trials.. gotta remove. 
        args[j++] = ""-d"";
        args[j++] = destinationDirectory.getAbsolutePath().trim(); 
        args[j++] = ""-docroot"";
        args[j++] = sourceDirectory.getAbsolutePath().trim();
        args[j++] = ""-keepgenerated"";  //TODO: Parameterise ??
        //Call compiler as class... dont want to fork again 
        //Use classic compiler -- can be parameterised?
        args[j++] =  ""-compilerclass"";
        args[j++] = ""sun.tools.javac.Main"";
        //Weblogic jspc does not seem to work unless u explicitly set this...
        // Does not take the classpath from the env....
        // Am i missing something about the Java task??
        args[j++] = ""-classpath"";
        args[j++] = compileClasspath.toString();
        this.scanDir(files);
        log(""Compiling ""+filesToDo.size() + "" JSP files"");
        for (int i=0;i<filesToDo.size();i++) {
            //XXX
            // All this to get package according to weblogic standards
            // Can be written better... this is too hacky! 
            // Careful.. similar code in scanDir , but slightly different!!
            jspFile = new File((String) filesToDo.elementAt(i));
            args[j] = ""-package"";
            parents = jspFile.getParent();
            if ((parents != null)  && (!("""").equals(parents))) {
                parents =  this.replaceString(parents,File.separator,""_."");
                args[j+1] = destinationPackage +"".""+ ""_""+parents;   
            }else {
                args[j+1] = destinationPackage;
            }
            args[j+2] =  sourceDirectory+File.separator+(String) filesToDo.elementAt(i);
            arg="""";
            for (int x=0;x<12;x++) {
                arg += "" ""+ args[x];
            }
            System.out.println(""arg = "" + arg);
            helperTask.clearArgs();
            helperTask.setArgs(arg);
            helperTask.setClasspath(compileClasspath);
            if (helperTask.executeJava() != 0) {                         
                log(files[i] + "" failed to compile"",Project.MSG_WARN) ;
            }
        }
    }
    /**
     * Set the classpath to be used for this compilation.
     * 
     */
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }
    /**
     * Maybe creates a nested classpath element.
     */
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(project);
        }
        return compileClasspath;
    }
    /**
     * Set the directory containing the source jsp's
     * 
     *
     * @param dirName the directory containg the source jsp's
     */
    public void setSrc(File dirName) {
        sourceDirectory = dirName;
    }
     /**
     * Set the directory containing the source jsp's
     * 
     *
     * @param dirName the directory containg the source jsp's
     */
    public void setDest(File dirName) {
        destinationDirectory = dirName;
    }
    /**
     * Set the package under which the compiled classes go
     * 
     * @param packageName the package name for the clases
     */
    public void setPackage(String packageName) {
        destinationPackage=packageName; 
    }
    protected void scanDir(String files[]) {
        long now = (new Date()).getTime();
        File jspFile = null;
        String parents = null;
        String pack = """";
        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(this.sourceDirectory, files[i]);
            //XXX
            // All this to convert source to destination directory according to weblogic standards
            // Can be written better... this is too hacky!
            jspFile = new File(files[i]);
            parents = jspFile.getParent();
            int loc=0;
            if ((parents != null)  && (!("""").equals(parents))) {
                parents =  this.replaceString(parents,File.separator,""_/"");
                pack = pathToPackage +File.separator+ ""_""+parents;  
            }else {
                pack = pathToPackage;
            }
            String filePath = pack + File.separator + ""_"";
            int startingIndex 
                = files[i].lastIndexOf(File.separator) != -1 ? files[i].lastIndexOf(File.separator) + 1 : 0;
            int endingIndex = files[i].indexOf("".jsp"");
            if (endingIndex == -1) {
                break;
            }
            filePath += files[i].substring(startingIndex, endingIndex);
            filePath += "".class"";
            File classFile = new File(this.destinationDirectory, filePath);
            if (srcFile.lastModified() > now) {
                log(""Warning: file modified in the future: "" +
                    files[i], Project.MSG_WARN);
            }
            if (srcFile.lastModified() > classFile.lastModified()) {
               //log(""Files are"" + srcFile.getAbsolutePath()+"" "" +classFile.getAbsolutePath());
                filesToDo.addElement(files[i]);
                log(""Recompiling File ""+files[i],Project.MSG_VERBOSE);
            }
        }
    }
    protected String replaceString(String inpString,String escapeChars,String replaceChars) {
        String localString="""";
        int numTokens=0;
        StringTokenizer st=new StringTokenizer(inpString,escapeChars,true);
        numTokens=st.countTokens();
        for(int i=0;i<numTokens;i++)
        {
            String test=st.nextToken();
            test=(test.equals(escapeChars)?replaceChars:test);
            localString+=test;
        }
        return localString;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.AggregateTransformer,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTResultTarget;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;
import org.xml.sax.SAXException;
/**
 * Transform a JUnit xml report.
 * The default transformation generates an html report in either framed or non-framed
 * style. The non-framed style is convenient to have a concise report via mail, the
 * framed report is much more convenient if you want to browse into different
 * packages or testcases since it is a Javadoc like report.
 * In the framed report, there are 3 frames:
 * <ul>
 *  <li>packageListFrame - list of all packages.
 *  <li>classListFrame - summary of all testsuites belonging to a package or tests list.
 *  <li>classFrame - details of all tests made for a package or for a testsuite.
 * </ul>
 * As a default, the transformer will use its default stylesheets, they may not be
 * be appropriate for users who wants to customize their reports, so you can indicates
 * your own stylesheets by using <tt>setStyleDir()</tt>.
 * Stylesheets must be as follows:
 * <ul>
 *   <li><b>all-packages.xsl</b> create the package list. It creates
 *   all-packages.html file in the html folder and it is load in the packageListFrame</li>
 *   <li><b>all-classes.xsl</b> creates the class list. It creates the all-classes.html
 * file in the html folder is loaded by the 'classListFrame' frame</li>
 *   <li><b>overview-packages.xsl</b> allows to get summary on all tests made
 *   for each packages and each class that not include in a package. The filename
 *   is overview-packages.html</li>
 *   <li><b>class-detail.xsl</b> is the style for the detail of the tests made on a class.
 *   the Html resulting page in write in the directory of the package and the name
 *   of this page is the name of the class with ""-detail"" element. For instance,
 *   the style is applied on the MyClass testsuite, the resulting filename is
 *   <u>MyClass-detail.html</u>. This file is load in the ""classFrame"" frame.</li>
 *   <li><b>package-summary.xsl</b> allows to create a summary on the package.
 *   The resulting html file is write in the package directory. The name of this
 *   file is <u>package-summary.html</u> This file is load in the ""classFrame"" frame.</li>
 *   <li><b>classes-list.xsl</b> create the list of the class in this package.
 *   The resulting html file is write in the package directory and it is load in
 *   the 'classListFrame' frame. The name of the resulting file is <u>class-list.html</u></li>
 * <li>
 *
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 * @author <a href=""mailto:ndelahaye@imediation.com"">Nicolas Delahaye</a>
 */
public class AggregateTransformer {     
    public final static String ALLPACKAGES = ""all-packages"";
    public final static String ALLCLASSES = ""all-classes"";
    public final static String OVERVIEW_PACKAGES = ""overview-packages"";
    public final static String CLASS_DETAILS = ""class-details"";
    public final static String CLASSES_LIST = ""classes-list"";
    public final static String PACKAGE_SUMMARY = ""package-summary"";
    public final static String OVERVIEW_SUMMARY = ""overview-summary"";
    public final static String FRAMES = ""frames"";
    public final static String NOFRAMES = ""noframes"";
    /** Task */
    protected Task task;
    /** the xml document to process */
    protected Document document;
    /** the style directory. XSLs should be read from here if necessary */
    protected File styleDir;
    /** the destination directory, this is the root from where html should be generated */
    protected File toDir;
    /** the format to use for the report. Must be <tt>FRAMES</tt> or <tt>NOFRAMES</tt> */
    protected String format;
    /** the file extension of the generated files. As a default it will be <tt>.html</tt> */
    protected String extension;
    /** XML Parser factory */
    protected static final DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
    public AggregateTransformer(Task task){
        this.task = task;
    }
    public void setFormat(String format){
        this.format = format;
    }
    public void setXmlDocument(Document doc){
        this.document = doc;
    }
    /**
     * Set the xml file to be processed. This is a helper if you want
     * to set the file directly. Much more for testing purposes.
     * @param xmlfile xml file to be processed
     */
    void setXmlfile(File xmlfile) throws BuildException {
        try {
            setXmlDocument(readDocument(xmlfile));
        } catch (Exception e){
            throw new BuildException(""Error while parsing document: "" + xmlfile, e);
        }
    }
    /**
     * set the style directory. It is optional and will override the
     * default xsl used.
     * @param styledir  the directory containing the xsl files if the user
     * would like to override with its own style.
     */
    public void setStyledir(File styledir){
        this.styleDir = styledir;
    }
    /** set the destination directory */
    public void setTodir(File todir){
        this.toDir = todir;
    }
    /** set the extension of the output files */
    public void setExtension(String ext){
        this.extension = ext;
    }
    /** get the extension, if it is null, it will use .html as the default */
    protected String getExtension(){
        if (extension == null) {
            extension = "".html"";
        }
        return extension;
    }
    public void transform() throws BuildException {
        checkOptions();
        try {
            Element root = document.getDocumentElement();
            if (NOFRAMES.equals(format)) {
                //createCascadingStyleSheet();
                createSinglePageSummary(root);
            } else {
                createFrameStructure();
                createCascadingStyleSheet();
                createPackageList(root);
                createClassList(root);
                createPackageOverview(root);
                createAllTestSuiteDetails(root);
                createAllPackageDetails(root);
            }
        } catch (Exception e){
            e.printStackTrace();
            throw new BuildException(""Errors while applying transformations"", e);
        }
    }
    /** check for invalid options */
    protected void checkOptions() throws BuildException {
        if ( !FRAMES.equals(format) && !NOFRAMES.equals(format)) {
            throw new BuildException(""Invalid format. Must be 'frames' or 'noframes' but was: '"" + format + ""'"");
        }
        // set the destination directory relative from the project if needed.
        if (toDir == null) {
            toDir = task.getProject().resolveFile(""."");
        } else if ( !toDir.isAbsolute() ) {
            toDir = task.getProject().resolveFile(toDir.getPath());
        }
        // create the directories if needed
        if (!toDir.exists()) {
            if (!toDir.mkdirs()){
                throw new BuildException(""Could not create directory "" + toDir);
            }
        }
    }
    /** create a single page summary */
    protected void createSinglePageSummary(Element root) throws IOException, SAXException {
        transform(root, OVERVIEW_SUMMARY + "".xsl"", OVERVIEW_SUMMARY + getExtension());
    }
    /**
     * read the xml file that should be the resuiting file of the testcase.
     * @param filename name of the xml resulting file of the testcase.
     */
    protected Document readDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder builder = dbfactory.newDocumentBuilder();
        InputStream in = new FileInputStream(file);
        try {
            return builder.parse(in);
        } finally {
            in.close();
        }
    }
    protected void createCascadingStyleSheet() throws IOException, SAXException {
        InputStream in = null;
        if (styleDir == null) {
            in = getResourceAsStream(""html/stylesheet.css"");
        } else {
            in = new FileInputStream(new File(styleDir, ""stylesheet.css""));
        }
        OutputStream out = new FileOutputStream( new File(toDir, ""stylesheet.css""));
        copy(in, out);
    }
    protected void createFrameStructure() throws IOException, SAXException{
        InputStream in = null;
        if (styleDir == null) {
            in = getResourceAsStream(""html/index.html"");
        } else {
            in = new FileInputStream(new File(styleDir, ""index.html""));
        }
        OutputStream out = new FileOutputStream( new File(toDir, ""index.html"") );
        copy(in, out);
    }
    /**
     * Create the list of all packages.
     * @param root root of the xml document.
     */
    protected void createPackageList(Node root) throws SAXException {
        transform(root, ALLPACKAGES + "".xsl"", ALLPACKAGES + getExtension());
    }
    /**
     * Create the list of all classes.
     * @param root root of the xml document.
     */
    protected void createClassList(Node root) throws SAXException {
        transform(root, ALLCLASSES + "".xsl"", ALLCLASSES + getExtension());
    }
    /**
     * Create the summary used in the overview.
     * @param root root of the xml document.
     */
    protected void createPackageOverview(Node root) throws SAXException {
        transform(root,  OVERVIEW_PACKAGES + "".xsl"", OVERVIEW_PACKAGES + getExtension());
    }
    /**
     *  @return the list of all packages that exists defined in testsuite nodes
     */
    protected Enumeration getPackages(Element root){
        Hashtable map = new Hashtable();
        NodeList testsuites = root.getElementsByTagName(XMLConstants.TESTSUITE);
        final int size = testsuites.getLength();
        for (int i = 0; i < size; i++){
            Element testsuite = (Element) testsuites.item(i);
            String packageName = testsuite.getAttribute(XMLConstants.ATTR_PACKAGE);
            if (packageName == null){
                //@todo replace the exception by something else
                throw new IllegalStateException(""Invalid 'testsuite' node: should contains 'package' attribute"");
            }
            map.put(packageName, packageName);
        }
        return map.keys();
    }
    /**
     * create all resulting html pages for all testsuites.
     * @param root should be 'testsuites' node.
     */
    protected void createAllTestSuiteDetails(Element root) throws SAXException {
        NodeList testsuites = root.getElementsByTagName(XMLConstants.TESTSUITE);
        final int size = testsuites.getLength();
        for (int i = 0; i < size; i++){
            Element testsuite = (Element) testsuites.item(i);
            createTestSuiteDetails(testsuite);
        }
    }
    /**
     * create the html resulting page of one testsuite.
     * @param root should be 'testsuite' node.
     */
    protected void createTestSuiteDetails(Element testsuite) throws SAXException {
        String packageName = testsuite.getAttribute(XMLConstants.ATTR_PACKAGE);         
        String pkgPath = packageToPath(packageName);
        // get the class name
        String name = testsuite.getAttribute(XMLConstants.ATTR_NAME);
        // get the name of the testsuite and create the filename of the ouput html page
        String filename = name + ""-details"" + getExtension();
        String fullpathname = pkgPath + filename; // there's already end path separator to pkgPath
        // apply the style on the document.
        transform(testsuite, CLASS_DETAILS + "".xsl"", fullpathname);
    }
    /**
     * create the html resulting page of the summary of each package of the root element.
     * @param root should be 'testsuites' node.
     */
    protected void createAllPackageDetails(Element root) throws SAXException, ParserConfigurationException {
        Enumeration packages = getPackages(root);
        while ( packages.hasMoreElements() ){
            String pkgname = (String)packages.nextElement();
            // for each package get the list of its testsuite.
            DOMUtil.NodeFilter pkgFilter = new PackageFilter(pkgname);
            NodeList testsuites = DOMUtil.listChildNodes(root, pkgFilter, false);
            Element doc = buildDocument(testsuites);
            // skip package details if the package does not exist (root package)
            if( !pkgname.equals("""") ){
                createPackageDetails(doc, pkgname);
            }
        }
    }
    protected String packageToPath(String pkgname){
        if (!pkgname.equals("""")) {
            return pkgname.replace('.', File.separatorChar) + File.separatorChar;
        }
        return ""."" + File.separatorChar;
    }
    /**
     * create the html resulting page of the summary of a package .
     * @param root should be 'testsuites' node.
     * @param pkgname Name of the package that we want a summary.
     */
    protected void createPackageDetails(Node root, String pkgname) throws SAXException {
        String path = packageToPath(pkgname);
        // apply style to get the list of the classes of this package and
        // display it in the classListFrame.
        transform(root, CLASSES_LIST + "".xsl"", path + CLASSES_LIST + getExtension());
        // apply style to get a summary on this package.
        transform(root, PACKAGE_SUMMARY + "".xsl"", path + PACKAGE_SUMMARY + getExtension());
    }
    /**
     * Create an element root (""testsuites"")
     * and import all nodes as children of this element.
     *
     */
    protected Element buildDocument(NodeList list) throws ParserConfigurationException {
        DocumentBuilder builder = dbfactory.newDocumentBuilder();
        Document doc = builder.newDocument();
        Element elem = doc.createElement(XMLConstants.TESTSUITES);
        final int len = list.getLength();
        for(int i=0 ; i < len ; i++) {
            DOMUtil.importNode(elem, list.item(i));
        }
        return elem;
    }
    /**
     * Apply a template on a part of the xml document.
     *
     * @param root root of the document fragment
     * @param xslfile style file
     * @param outfilename filename of the result of the style applied on the Node
     *
     * @throws SAXException SAX Parsing Error on the style Sheet.
     */
    protected void transform(Node root, String xslname, String htmlname) throws SAXException {
        try{
            final long t0 = System.currentTimeMillis();
            XSLTInputSource xsl_source = getXSLStreamSource(xslname);
            XSLTProcessor processor = XSLTProcessorFactory.getProcessor();
            File htmlfile = new File(toDir, htmlname);
            // create the directory if it does not exist
            File dir = new File(htmlfile.getParent()); // getParentFile is in JDK1.2+
            if (!dir.exists()) {
                dir.mkdirs();
            }
            task.log(""Applying '"" + xslname + ""'. Generating '"" + htmlfile + ""'"", Project.MSG_VERBOSE);
            processor.process( new XSLTInputSource(root), xsl_source, new XSLTResultTarget(htmlfile.getAbsolutePath()) );
            final long dt = System.currentTimeMillis() - t0;
            task.log(""Transform time for "" + xslname + "": "" + dt + ""ms"");
        } catch (IOException e){
            task.log(e.getMessage(), Project.MSG_ERR);
            e.printStackTrace(); //@todo bad, change this
            throw new SAXException(e.getMessage());
        }
    }
    /**
     * default xsls are embedded in the distribution jar. As a default we will use
     * them, otherwise we will get the one supplied by the client in a given
     * directory. It must have the same name.
     */
    protected XSLTInputSource getXSLStreamSource(String name) throws IOException {
        InputStream in;
        String systemId; //we need this because there are references in xsls
        if (styleDir == null){
            in = getResourceAsStream(""xsl/"" + name);
            systemId = getClass().getResource(""xsl/"" + name).toString();
        } else {
            File f = new File(styleDir, name);
            in= new FileInputStream(f);
            systemId = f.getAbsolutePath();
        }
        XSLTInputSource ss = new XSLTInputSource(in);
        ss.setSystemId(systemId);
        return ss;
    }
    private InputStream getResourceAsStream(String name) throws FileNotFoundException {
        InputStream in = getClass().getResourceAsStream(name);
        if (in == null) {
            throw new FileNotFoundException(""Could not find resource '"" + name + ""'"");
        }
        return in;
    }
    /** Do some raw stream copying */
    private static void copy(InputStream in, OutputStream out) throws IOException {
        int size = -1;
        byte[] buffer =  new byte[1024];
        // Make the copy
        while( (size = in.read(buffer)) != -1){
            out.write(buffer,0,size);
        }
    }
    /**
     * allow us to check if the node is a object of a specific package.
     */
    protected static class PackageFilter implements DOMUtil.NodeFilter {
        private final String pkgName;
        PackageFilter(String pkgname) {
            this.pkgName = pkgname;
        }
        /**
         * if the node receive is not a element then return false
         * check if the node is a class of this package.
         */
        public boolean accept(Node node) {
            String pkgname = DOMUtil.getNodeAttribute(node, XMLConstants.ATTR_PACKAGE);
            return pkgName.equals(pkgname);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.BaseTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import java.io.File;
import java.util.Vector;
/**
 * Baseclass for BatchTest and JUnitTest.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public abstract class BaseTest {
    protected boolean haltOnError = false;
    protected boolean haltOnFail = false;
    protected boolean fork = false;
    protected String ifProperty = null;
    protected String unlessProperty = null;
    protected Vector formatters = new Vector();
    /** destination directory */
    protected File destDir = null;
    public void setFork(boolean value) {
        fork = value;
    }
    public boolean getFork() {
        return fork;
    }
    public void setHaltonerror(boolean value) {
        haltOnError = value;
    }
    public void setHaltonfailure(boolean value) {
        haltOnFail = value;
    }
    public boolean getHaltonerror() {
        return haltOnError;
    }
    public boolean getHaltonfailure() {
        return haltOnFail;
    }
    public void setIf(String propertyName) {
        ifProperty = propertyName;
    }
    public void setUnless(String propertyName) {
        unlessProperty = propertyName;
    }
    public void addFormatter(FormatterElement elem) {
        formatters.addElement(elem);
    }
    /**
     * Sets the destination directory.
     */
    public void setTodir(File destDir) {
        this.destDir = destDir; 
    }
    /**
     * @return the destination directory as an absolute path if it exists
     *			otherwise return <tt>null</tt>
     */
    public String getTodir(){
        if (destDir != null){
            return destDir.getAbsolutePath();
        }
        return null;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.BatchTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Reference;
import java.util.*;
import java.io.File;
/**
 * Create JUnitTests from a list of files.
 *
 * @author <a href=""mailto:jeff.martin@synamic.co.uk"">Jeff Martin</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 *
 * @see JUnitTest
 */
public final class BatchTest extends BaseTest {
    /** the reference to the project */
    private Project project;
    /** the list of filesets containing the testcase filename rules */
    private Vector filesets = new Vector();
    /**
     * create a new batchtest instance
     * @param project     the project it depends on.
     */
    public BatchTest(Project project){
        this.project = project;
    }
    /**
     * Add a new fileset instance to this batchtest. Whatever the fileset is,
     * only filename that are <tt>.java</tt> or <tt>.class</tt> will be
     * considered as 'candidates'.
     * @param     fs the new fileset containing the rules to get the testcases.
     */
    public void addFileSet(FileSet fs) {
        filesets.addElement(fs);
    }
    /**
     * return all <tt>JUnitTest</tt> instances obtain by applying the fileset rules.
     * @return  an enumeration of all elements of this batchtest that are
     * a <tt>JUnitTest</tt> instance.
     * @see addTestsTo(Vector)
     */
    public final Enumeration elements(){
        JUnitTest[] tests = createAllJUnitTest();
        return Enumerations.fromArray(tests);
    }
    /**
     * Convenient method to merge the <tt>JUnitTest</tt>s of this batchtest
     * to a <tt>Vector</tt>.
     * @param v the vector to which should be added all individual tests of this
     * batch test.
     */
    final void addTestsTo(Vector v){
        JUnitTest[] tests = createAllJUnitTest();
        v.ensureCapacity( v.size() + tests.length);
        for (int i = 0; i < tests.length; i++) {
            v.addElement(tests[i]);
        }
    }
    /**
     * Create all <tt>JUnitTest</tt>s based on the filesets. Each instance
     * is configured to match this instance properties.
     * @return the array of all <tt>JUnitTest</tt>s that belongs to this batch.
     */
    private JUnitTest[] createAllJUnitTest(){
        String[] filenames = getFilenames();
        JUnitTest[] tests = new JUnitTest[filenames.length];
        for (int i = 0; i < tests.length; i++) {
            String classname = javaToClass(filenames[i]);
            tests[i] = createJUnitTest(classname);
        }
        return tests;
    }
    /**
     * Iterate over all filesets and return the filename of all files
     * that end with <tt>.java</tt> or <tt>.class</tt>. This is to avoid
     * wrapping a <tt>JUnitTest</tt> over an xml file for example. A Testcase
     * is obviouslly a java file (compiled or not).
     * @return an array of filenames without their extension. As they should
     * normally be taken from their root, filenames should match their fully
     * qualified class name (If it is not the case it will fail when running the test).
     * For the class <tt>org/apache/Whatever.class</tt> it will return <tt>org/apache/Whatever</tt>.
     */
    private String[] getFilenames(){
        Vector v = new Vector();
        final int size = this.filesets.size();
        for (int j=0; j<size; j++) {
            FileSet fs = (FileSet) filesets.elementAt(j);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            ds.scan();
            String[] f = ds.getIncludedFiles();
            for (int k = 0; k < f.length; k++) {
                String pathname = f[k];
                if (pathname.endsWith("".java"")) {
                    v.addElement(pathname.substring(0, pathname.length()-"".java"".length()));
                } else if (pathname.endsWith("".class"")) {
                    v.addElement(pathname.substring(0, pathname.length()-"".class"".length()));
                }
            }
        }
        String[] files = new String[v.size()];
        v.copyInto(files);
        return files;
    }
    /**
     * convenient method to convert a pathname without extension to a
     * fully qualified classname. For example <tt>org/apache/Whatever</tt> will
     * be converted to <tt>org.apache.Whatever</tt>
     * @param filename the filename to ""convert"" to a classname.
     * @return the classname matching the filename.
     */
    public final static String javaToClass(String filename){
        return filename.replace(File.separatorChar, '.');
    }
    /**
     * Create a <tt>JUnitTest</tt> that has the same property as this
     * <tt>BatchTest</tt> instance.
     * @param classname the name of the class that should be run as a
     * <tt>JUnitTest</tt>. It must be a fully qualified name.
     * @return the <tt>JUnitTest</tt> over the given classname.
     */
    private JUnitTest createJUnitTest(String classname){
        JUnitTest test = new JUnitTest();
        test.setName(classname);
        test.setHaltonerror(this.haltOnError);
        test.setHaltonfailure(this.haltOnFail);
        test.setFork(this.fork);
        test.setIf(this.ifProperty);
        test.setUnless(this.unlessProperty);
        test.setTodir(this.destDir);
        Enumeration list = this.formatters.elements();
        while (list.hasMoreElements()) {
            test.addFormatter((FormatterElement)list.nextElement());
        }
        return test;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.DOMUtil,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Attr;
import org.w3c.dom.EntityReference;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;
import org.w3c.dom.DOMException;
import java.util.Vector;
/**
 * Some utilities that might be useful when manipulating DOM trees.
 *
 * @author <a href=""bailliez@noos.fr"">Stephane Bailliez</a>
 */
public final class DOMUtil {
    /** unused constructor */
    private DOMUtil(){
    }
    /**
     * Filter interface to be applied when iterating over a DOM tree.
     * Just think of it like a <tt>FileFilter</tt> clone.
     */
    public interface NodeFilter {
        /**
         * @param       node    the node to check for acceptance.
         * @return      <tt>true</tt> if the node is accepted by this filter,
         *                      otherwise <tt>false</tt>
         */
        public boolean accept(Node node);
    }
    /**
     * list a set of node that match a specific filter. The list can be made
     * recursively or not.
     * @param   parent  the parent node to search from
     * @param   filter  the filter that children should match.
     * @param   recurse <tt>true</tt> if you want the list to be made recursively
     *                  otherwise <tt>false</tt>.
     */
    public static NodeList listChildNodes(Node parent, NodeFilter filter, boolean recurse){
        NodeListImpl matches = new NodeListImpl();
        NodeList children = parent.getChildNodes();
        if (children != null) {
            final int len = children.getLength();
            for (int i = 0; i < len; i++) {
                Node child = children.item(i);
                if (filter.accept(child)) {
                    matches.addElement(child);
                }
                if (recurse) {
                    NodeList recmatches = listChildNodes(child, filter, recurse);
                    final int reclength = matches.getLength();
                    for (int j = 0; j < reclength; j++) {
                        matches.addElement( recmatches.item(i) );
                    }
                }
            }
        }
        return matches;
    }
    /** custom implementation of a nodelist */
    public static class NodeListImpl extends Vector implements NodeList {
        public int getLength(){
            return size();
        }
        public Node item(int i){
            try {
                return (Node)elementAt(i);
            } catch (ArrayIndexOutOfBoundsException e){
                return null; // conforming to NodeList interface
            }
        }
    }
    /**
     * return the attribute value of an element.
     * @param node the node to get the attribute from.
     * @param name the name of the attribute we are looking for the value.
     * @return the value of the requested attribute or <tt>null</tt> if the
     *         attribute was not found or if <tt>node</tt> is not an <tt>Element</tt>.
     */
    public static String getNodeAttribute(Node node, String name) {
        if (node instanceof Element) {
            Element element = (Element)node;
            return element.getAttribute(name);
        }
        return null;
    }
    /**
     * Iterate over the children of a given node and return the first node
     * that has a specific name.
     * @param   parent  the node to search child from. Can be <tt>null</tt>.
     * @param   tagname the child name we are looking for. Cannot be <tt>null</tt>.
     * @return  the first child that matches the given name or <tt>null</tt> if
     *                  the parent is <tt>null</tt> or if a child does not match the
     *                  given name.
     */
    public static Element getChildByTagName (Node parent, String tagname) {
        if (parent == null){
            return null;
        }
        NodeList childList = parent.getChildNodes();
        final int len = childList.getLength();
        for (int i = 0; i < len; i++) {
            Node child = childList.item(i);
            if ( child != null && child.getNodeType() == Node.ELEMENT_NODE &&
                 child.getNodeName().equals(tagname)) {
                return (Element)child;
            }
        }
        return null;
    }
    /**
     * Simple tree walker that will clone recursively a node. This is to
     * avoid using parser-specific API such as Sun's <tt>changeNodeOwner</tt>
     * when we are dealing with DOM L1 implementations since <tt>cloneNode(boolean)</tt>
     * will not change the owner document.
     * <tt>changeNodeOwner</tt> is much faster and avoid the costly cloning process.
     * <tt>importNode</tt> is in the DOM L2 interface.
     * @param   parent  the node parent to which we should do the import to.
     * @param   child   the node to clone recursively. Its clone will be
     *              appended to <tt>parent</tt>.
     * @return  the cloned node that is appended to <tt>parent</tt>
     */
    public static final Node importNode(Node parent, Node child){
        Node copy = null;
        final Document doc = parent.getOwnerDocument();
        switch (child.getNodeType()) {
        case Node.CDATA_SECTION_NODE:
            copy = doc.createCDATASection(((CDATASection) child).getData());
            break;
        case Node.COMMENT_NODE:
            copy = doc.createComment(((Comment) child).getData());
            break;
        case Node.DOCUMENT_FRAGMENT_NODE:
            copy = doc.createDocumentFragment();
            break;
        case Node.ELEMENT_NODE:
            final Element elem = doc.createElement(((Element)child).getTagName());
            copy = elem;
            final NamedNodeMap attributes = child.getAttributes();
            if ( attributes != null) {
                final int size = attributes.getLength();
                for (int i = 0; i < size; i++) {
                    final Attr attr = (Attr) attributes.item(i);
                    elem.setAttribute(attr.getName(), attr.getValue());
                }
            }
            break;
        case Node.ENTITY_REFERENCE_NODE:
            copy = doc.createEntityReference(child.getNodeName());
            break;
        case Node.PROCESSING_INSTRUCTION_NODE:
            final ProcessingInstruction pi = (ProcessingInstruction)child;
            copy = doc.createProcessingInstruction(pi.getTarget(), pi.getData());
            break;
        case Node.TEXT_NODE:
            copy = doc.createTextNode(((Text) child).getData());
            break;
        default:
            // this should never happen
            throw new IllegalStateException(""Invalid node type: "" + child.getNodeType());
        }
        // okay we have a copy of the child, now the child becomes the parent
        // and we are iterating recursively over its children.
        try {
            final NodeList children = child.getChildNodes();
            if (children != null) {
                final int size = children.getLength();
                for (int i = 0; i < size; i++) {
                    final Node newChild = children.item(i);
                    if (newChild != null) {
                        importNode(copy, newChild);
                    }
                }
            }
        } catch (DOMException ignored) {
        }
        // bingo append it. (this should normally not be done here)
        parent.appendChild(copy);
        return copy;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.Enumerations,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
 * A couple of methods related to enumerations that might be useful.
 * This class should probably disappear once the required JDK is set to 1.2
 * instead of 1.1.
 *
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public final class Enumerations {
        private Enumerations(){
        }
        /**
         * creates an enumeration from an array of objects.
         * @param       array   the array of object to enumerate.
         * @return the enumeration over the array of objects.
         */
        public static Enumeration fromArray(Object[] array){
                return new ArrayEnumeration(array);
        }
        /**
        * creates an enumeration from an array of enumeration. The created enumeration
        * will sequentially enumerate over all elements of each enumeration and skip
        * <tt>null</tt> enumeration elements in the array.
        * @param        enums   the array of enumerations.
        * @return the enumeration over the array of enumerations.
         */
        public static Enumeration fromCompound(Enumeration[] enums){
                return new CompoundEnumeration(enums);
        }
}
/**
 * Convenient enumeration over an array of objects.
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
class ArrayEnumeration implements Enumeration {
        /** object array */
        private Object[] array;
        /** current index */
        private int pos;
        /**
         * Initialize a new enumeration that wraps an array.
         * @param       array   the array of object to enumerate.
         */
        public ArrayEnumeration(Object[] array){
                this.array = array;
                this.pos = 0;
        }
        /**
         * Tests if this enumeration contains more elements.
         *
         * @return  <code>true</code> if and only if this enumeration object
         *           contains at least one more element to provide;
         *          <code>false</code> otherwise.
         */
        public boolean hasMoreElements() {
                return (pos < array.length);
        }
        /**
         * Returns the next element of this enumeration if this enumeration
         * object has at least one more element to provide.
         *
         * @return     the next element of this enumeration.
         * @throws  NoSuchElementException  if no more elements exist.
         */
        public Object nextElement() throws NoSuchElementException {
                if (hasMoreElements()) {
                        Object o = array[pos];
                        pos++;
                        return o;
                }
                throw new NoSuchElementException();
        }
}
/**
 * Convenient enumeration over an array of enumeration. For example:
 * <pre>
 * Enumeration e1 = v1.elements();
 * while (e1.hasMoreElements()){
 *    // do something
 * }
 * Enumeration e2 = v2.elements();
 * while (e2.hasMoreElements()){
 *    // do the same thing
 * }
 * </pre>
 * can be written as:
 * <pre>
 * Enumeration[] enums = { v1.elements(), v2.elements() };
 * Enumeration e = Enumerations.fromCompound(enums);
 * while (e.hasMoreElements()){
 *    // do something
 * }
 * </pre>
 * Note that the enumeration will skip null elements in the array. The following is
 * thus possible:
 * <pre>
 * Enumeration[] enums = { v1.elements(), null, v2.elements() }; // a null enumeration in the array
 * Enumeration e = Enumerations.fromCompound(enums);
 * while (e.hasMoreElements()){
 *    // do something
 * }
 * </pre>
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
 class CompoundEnumeration implements Enumeration {
        /** enumeration array */
        private Enumeration[] enumArray;
        /** index in the enums array */
        private int index = 0;
    public CompoundEnumeration(Enumeration[] enumarray) {
                this.enumArray = enumarray;
    }
        /**
         * Tests if this enumeration contains more elements.
         *
         * @return  <code>true</code> if and only if this enumeration object
         *           contains at least one more element to provide;
         *          <code>false</code> otherwise.
         */
    public boolean hasMoreElements() {
                while (index < enumArray.length) {
                        if (enumArray[index] != null && enumArray[index].hasMoreElements()) {
                                return true;
                        }
                        index++;
                }
                return false;
    }
        /**
         * Returns the next element of this enumeration if this enumeration
         * object has at least one more element to provide.
         *
         * @return     the next element of this enumeration.
         * @throws  NoSuchElementException  if no more elements exist.
         */
    public Object nextElement() throws NoSuchElementException {
                if ( hasMoreElements() ) {
                        return enumArray[index].nextElement();
                }
                throw new NoSuchElementException();
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.FormatterElement,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.EnumeratedAttribute;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
/**
 * Serves as a wrapper the implementations of JUnitResultFormatter,
 * for example as a nested <formatter> element in <junit>.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class FormatterElement {
    private String classname;
    private String extension;
    private OutputStream out = System.out;
    private File outFile;
    private boolean useFile = true;
    public void setType(TypeAttribute type) {
        if (""xml"".equals(type.getValue())) {
            setClassname(""org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter"");
            setExtension("".xml"");
        } else { // must be plain, ensured by TypeAttribute
            setClassname(""org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter"");
            setExtension("".txt"");
        }
    }
    public void setClassname(String classname) {
        this.classname = classname;
    }
    public String getClassname() {
        return classname;
    }
    public void setExtension(String ext) {
        this.extension = ext;
    }
    public String getExtension() {
        return extension;
    }
    void setOutfile(File out) {
        this.outFile = out;
    }
    public void setOutput(OutputStream out) {
        this.out = out;
    }
    public void setUseFile(boolean useFile) {
        this.useFile = useFile;
    }
    boolean getUseFile() {
        return useFile;
    }
    JUnitResultFormatter createFormatter() throws BuildException {
        if (classname == null) {
            throw new BuildException(""you must specify type or classname"");
        }
        Class f = null;
        try {
            f = Class.forName(classname);
        } catch (ClassNotFoundException e) {
            throw new BuildException(e);
        }
        Object o = null;
        try {
            o = f.newInstance();
        } catch (InstantiationException e) {
            throw new BuildException(e);
        } catch (IllegalAccessException e) {
            throw new BuildException(e);
        }
        if (!(o instanceof JUnitResultFormatter)) {
            throw new BuildException(classname+"" is not a JUnitResultFormatter"");
        }
        JUnitResultFormatter r = (JUnitResultFormatter) o;
        if (useFile && outFile != null) {
            try {
                out = new FileOutputStream(outFile);
            } catch (java.io.IOException e) {
                throw new BuildException(e);
            }
        }
        r.setOutput(out);
        return r;
    }
    /**
     * Enumerated attribute with the values ""plain"" and ""xml"".
     */
    public static class TypeAttribute extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[] {""plain"", ""xml""};
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitResultFormatter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.BuildException;
import junit.framework.TestListener;
/**
 * This Interface describes classes that format the results of a JUnit
 * testrun.
 * 
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public interface JUnitResultFormatter extends TestListener {
    /**
     * The whole testsuite started.
     */
    public void startTestSuite(JUnitTest suite) throws BuildException;
    /**
     * The whole testsuite ended.
     */
    public void endTestSuite(JUnitTest suite) throws BuildException;
    /**
     * Sets the stream the formatter is supposed to write its results to.
     */
    public void setOutput(java.io.OutputStream out);
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.taskdefs.ExecuteWatchdog;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.Vector;
/**
 * Ant task to run JUnit tests.
 *
 * <p>JUnit is a framework to create unit test. It has been initially
 * created by Erich Gamma and Kent Beck.  JUnit can be found at <a
 * href=""http://www.junit.org"">http://www.junit.org</a>.
 *
 * <p> To spawn a new Java VM to prevent interferences between
 * different testcases, you need to enable <code>fork</code>.
 *
 * @author Thomas Haas
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public class JUnitTask extends Task {
    private CommandlineJava commandline = new CommandlineJava();
    private Vector tests = new Vector();
    private Vector batchTests = new Vector();
    private Vector formatters = new Vector();
    private File dir = null;
    private Integer timeout = null;
    private boolean summary = false;
    /**
     * Tells this task to halt when there is an error in a test.
     * this property is applied on all BatchTest (batchtest) and JUnitTest (test)
     * however it can possibly be overridden by their own properties.
     * @param   value   <tt>true</tt> if it should halt, otherwise <tt>false<tt>
     */
    public void setHaltonerror(boolean value) {
        Enumeration enum = allTests();
        while (enum.hasMoreElements()) {
            BaseTest test = (BaseTest) enum.nextElement();
            test.setHaltonerror(value);
        }
    }
    /**
     * Tells this task to halt when there is a failure in a test.
     * this property is applied on all BatchTest (batchtest) and JUnitTest (test)
     * however it can possibly be overridden by their own properties.
     * @param   value   <tt>true</tt> if it should halt, otherwise <tt>false<tt>
     */
    public void setHaltonfailure(boolean value) {
        Enumeration enum = allTests();
        while (enum.hasMoreElements()) {
            BaseTest test = (BaseTest) enum.nextElement();
            test.setHaltonfailure(value);
        }
    }
    /**
     * Tells whether a JVM should be forked for each testcase. It avoids interference
     * between testcases and possibly avoids hanging the build.
     * this property is applied on all BatchTest (batchtest) and JUnitTest (test)
     * however it can possibly be overridden by their own properties.
     * @param   value   <tt>true</tt> if a JVM should be forked, otherwise <tt>false<tt>
     * @see #setTimeout(Integer)
     * @see #haltOntimeout(boolean)
     */
    public void setFork(boolean value) {
        Enumeration enum = allTests();
        while (enum.hasMoreElements()) {
            BaseTest test = (BaseTest) enum.nextElement();
            test.setFork(value);
        }
    }
    /**
     * Tells whether the task should print a short summary of the task.
     * @param   value   <tt>true</tt> to print a summary, <tt>false</tt> otherwise.
     * @see SummaryJUnitResultFormatter
     */
    public void setPrintsummary(boolean value) {
        summary = value;
    }
    /**
     * Set the timeout value (in milliseconds). If the test is running for more than this
     * value, the test will be canceled. (works only when in 'fork' mode).
     * @param   value   the maximum time (in milliseconds) allowed before declaring the test
     *                  as 'timed-out'
     * @see #setFork(boolean)
     * @see #haltOnTimeout(boolean)
     */
    public void setTimeout(Integer value) {
        timeout = value;
    }
    /**
     * Set the maximum memory to be used by all forked JVMs.
     * @param   max     the value as defined by <tt>-mx</tt> or <tt>-Xmx</tt>
     *                  in the java command line options.
     */
    public void setMaxmemory(String max) {
        if (Project.getJavaVersion().startsWith(""1.1"")) {
            createJvmarg().setValue(""-mx""+max);
        } else {
            createJvmarg().setValue(""-Xmx""+max);
        }
    }
    /**
     * Set a new VM to execute the testcase. Default is <tt>java</tt>. Ignored if no JVM is forked.
     * @param   value   the new VM to use instead of <tt>java</tt>
     * @see #setFork(boolean)
     */
    public void setJvm(String value) {
        commandline.setVm(value);
    }
    /**
     * Create a new JVM argument. Ignored if no JVM is forked.
     * @return  create a new JVM argument so that any argument can be passed to the JVM.
     * @see #setFork(boolean)
     */
    public Commandline.Argument createJvmarg() {
        return commandline.createVmArgument();
    }
    /**
     * The directory to invoke the VM in. Ignored if no JVM is forked.
     * @param   dir     the directory to invoke the JVM from.
     * @see #setFork(boolean)
     */
    public void setDir(File dir) {
        this.dir = dir;
    }
    /**
     * Add a nested sysproperty element. This might be useful to tranfer
     * Ant properties to the testcases when JVM forking is not enabled.
     */
    public void addSysproperty(Environment.Variable sysp) {
        commandline.addSysproperty(sysp);
    }
    public Path createClasspath() {
        return commandline.createClasspath(project).createPath();
    }
    /**
     * Add a new single testcase.
     * @param   test    a new single testcase
     * @see JUnitTest
     */
    public void addTest(JUnitTest test) {
        tests.addElement(test);
    }
    /**
     * Create a new set of testcases (also called ..batchtest) and add it to the list.
     * @return  a new instance of a batch test.
     * @see BatchTest
     */
    public BatchTest createBatchTest() {
        BatchTest test = new BatchTest(project);
        batchTests.addElement(test);
        return test;
    }
    /**
     * Add a new formatter to all tests of this task.
     */
    public void addFormatter(FormatterElement fe) {
        formatters.addElement(fe);
    }
    /**
     * Creates a new JUnitRunner and enables fork of a new Java VM.
     */
    public JUnitTask() throws Exception {
        commandline.setClassname(""org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner"");
    }
    /**
     * Runs the testcase.
     */
    public void execute() throws BuildException {
        Enumeration list = getIndividualTests();
        while (list.hasMoreElements()) {
            JUnitTest test = (JUnitTest)list.nextElement();
            if ( test.shouldRun(project)) {
                execute(test);
            }
        }
    }
    protected void execute(JUnitTest test) throws BuildException {
        // set the default values if not specified
        //@todo should be moved to the test class instead.
        if (test.getTodir() == null) {
            test.setTodir(project.resolveFile("".""));
        }
        if (test.getOutfile() == null) {
            test.setOutfile( ""TEST-"" + test.getName() );
        }
        // execute the test and get the return code
        int exitValue = JUnitTestRunner.ERRORS;
        boolean wasKilled = false;
        if (!test.getFork()) {
            exitValue = executeInVM(test);
        } else {
            ExecuteWatchdog watchdog = createWatchdog();
            exitValue = executeAsForked(test, watchdog);
            // null watchdog means no timeout, you'd better not check with null
            if (watchdog != null) {
                //info will be used in later version do nothing for now
                //wasKilled = watchdog.killedProcess();
            }
        }
        // if there is an error/failure and that it should halt, stop everything otherwise
        // just log a statement
        boolean errorOccurredHere = exitValue == JUnitTestRunner.ERRORS;
        boolean failureOccurredHere = exitValue != JUnitTestRunner.SUCCESS;
        if (errorOccurredHere && test.getHaltonerror()
            || failureOccurredHere && test.getHaltonfailure()) {
            throw new BuildException(""Test ""+test.getName()+"" failed"",
                                     location);
        } else if (errorOccurredHere || failureOccurredHere) {
            log(""TEST ""+test.getName()+"" FAILED"", Project.MSG_ERR);
        }
    }
    /**
     * Execute a testcase by forking a new JVM. The command will block until
     * it finishes. To know if the process was destroyed or not, use the
     * <tt>killedProcess()</tt> method of the watchdog class.
     * @param  test       the testcase to execute.
     * @param  watchdog   the watchdog in charge of cancelling the test if it
     * exceeds a certain amount of time. Can be <tt>null</tt>, in this case
     * the test could probably hang forever.
     */
    private int executeAsForked(JUnitTest test, ExecuteWatchdog watchdog) throws BuildException {
        CommandlineJava cmd = (CommandlineJava) commandline.clone();
        cmd.setClassname(""org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner"");
        cmd.createArgument().setValue(test.getName());
        cmd.createArgument().setValue(""haltOnError="" + test.getHaltonerror());
        cmd.createArgument().setValue(""haltOnFailure="" + test.getHaltonfailure());
        if (summary) {
            log(""Running "" + test.getName(), Project.MSG_INFO);
            cmd.createArgument().setValue(""formatter=org.apache.tools.ant.taskdefs.optional.junit.SummaryJUnitResultFormatter"");
        }
        StringBuffer formatterArg = new StringBuffer(128);
        final FormatterElement[] feArray = mergeFormatters(test);
        for (int i = 0; i < feArray.length; i++) {
            FormatterElement fe = feArray[i];
            formatterArg.append(""formatter="");
            formatterArg.append(fe.getClassname());
            File outFile = getOutput(fe,test);
            if (outFile != null) {
                formatterArg.append("","");
                formatterArg.append( outFile );
            }
            cmd.createArgument().setValue(formatterArg.toString());
            formatterArg.setLength(0);
        }
        Execute execute = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN), watchdog);
        execute.setCommandline(cmd.getCommandline());
        if (dir != null) {
            execute.setWorkingDirectory(dir);
            execute.setAntRun(project);
        }
        log(""Executing: ""+cmd.toString(), Project.MSG_VERBOSE);
        try {
            return execute.execute();
        } catch (IOException e) {
            throw new BuildException(""Process fork failed."", e, location);
        }
    }
    // in VM is not very nice since it could probably hang the
    // whole build. IMHO this method should be avoided and it would be best
    // to remove it in future versions. TBD. (SBa)
    /**
     * Execute inside VM.
     */
    private int executeInVM(JUnitTest test) throws BuildException {
        if (dir != null) {
            log(""dir attribute ignored if running in the same VM"", Project.MSG_WARN);
        }
        CommandlineJava.SysProperties sysProperties = commandline.getSystemProperties();
        if (sysProperties != null) {
            sysProperties.setSystem();
        }
        try {
            log(""Using System properties "" + System.getProperties(), Project.MSG_VERBOSE);
            AntClassLoader cl = null;
            Path classpath = commandline.getClasspath();
            if (classpath != null) {
                log(""Using CLASSPATH "" + classpath, Project.MSG_VERBOSE);
                cl = new AntClassLoader(project, classpath, false);
                // make sure the test will be accepted as a TestCase
                cl.addSystemPackageRoot(""junit"");
                // will cause trouble in JDK 1.1 if omitted
                cl.addSystemPackageRoot(""org.apache.tools.ant"");
            }
            JUnitTestRunner runner = new JUnitTestRunner(test, test.getHaltonerror(), test.getHaltonfailure(), cl);
            if (summary) {
                log(""Running "" + test.getName(), Project.MSG_INFO);
                SummaryJUnitResultFormatter f = new SummaryJUnitResultFormatter();
                f.setOutput( getDefaultOutput() );
                runner.addFormatter(f);
            }
            final FormatterElement[] feArray = mergeFormatters(test);
            for (int i = 0; i < feArray.length; i++) {
                FormatterElement fe = feArray[i];
                File outFile = getOutput(fe,test);
                if (outFile != null) {
                    fe.setOutfile(outFile);
                } else {
                    fe.setOutput( getDefaultOutput() );
                }
                runner.addFormatter(fe.createFormatter());
            }
            runner.run();
            return runner.getRetCode();
        } finally{
            if (sysProperties != null) {
                sysProperties.restoreSystem();
            }
        }
    }
    /**
     * @return <tt>null</tt> if there is a timeout value, otherwise the
     * watchdog instance.
     */
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        if (timeout == null){
            return null;
        }
        return new ExecuteWatchdog(timeout.intValue());
    }
    /**
     * get the default output for a formatter.
     */
    protected OutputStream getDefaultOutput(){
        return new LogOutputStream(this, Project.MSG_INFO);
    }
    /**
     * Merge all individual tests from the batchtest with all individual tests
     * and return an enumeration over all <tt>JUnitTest</tt>.
     */
    protected Enumeration getIndividualTests(){
        Enumeration[] enums = new Enumeration[ batchTests.size() + 1];
        for (int i = 0; i < batchTests.size(); i++) {
            BatchTest batchtest = (BatchTest)batchTests.elementAt(i);
            enums[i] = batchtest.elements();
        }
        enums[enums.length - 1] = tests.elements();
        return Enumerations.fromCompound(enums);
    }
    protected Enumeration allTests() {
        Enumeration[] enums = { tests.elements(), batchTests.elements() };
        return Enumerations.fromCompound(enums);
    }
    private FormatterElement[] mergeFormatters(JUnitTest test){
        Vector feVector = (Vector)formatters.clone();
        test.addFormattersTo(feVector);
        FormatterElement[] feArray = new FormatterElement[feVector.size()];
        feVector.copyInto(feArray);
        return feArray;
    }
    /** return the file or null if does not use a file */
    protected File getOutput(FormatterElement fe, JUnitTest test){
        if (fe.getUseFile()) {
            String filename = test.getOutfile() + fe.getExtension();
            File destFile = new File( test.getTodir(), filename );
            String absFilename = destFile.getAbsolutePath();
            return project.resolveFile(absFilename);
        }
        return null;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTest,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import java.io.File;
import java.util.Vector;
/**
 *
 * @author Thomas Haas
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>,
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public class JUnitTest extends BaseTest {
    /** the name of the test case */
    private String name = null;
    /** the name of the result file */
    private String outfile = null;
    // @todo this is duplicating TestResult information. Only the time is not
    // part of the result. So we'd better derive a new class from TestResult
    // and deal with it. (SB)
    private long runs, failures, errors;
    private long runTime;
    public JUnitTest() {
    }
    public JUnitTest(String name) {
        this.name  = name;
    }
    public JUnitTest(String name, boolean haltOnError, boolean haltOnFailure) {
        this.name  = name;
        this.haltOnError = haltOnError;
        this.haltOnFail = haltOnFail;
    }
    public void setName(String value) {
        name = value;
    }
    public void setOutfile(String value) {
        outfile = value;
    }
    public String getName() {
        return name;
    }
    /**
     * @return the name of the output file.
     */
    public String getOutfile() {
        return outfile;
    }
    public void setCounts(long runs, long failures, long errors) {
        this.runs = runs;
        this.failures = failures;
        this.errors = errors;
    }
    public void setRunTime(long runTime) {
        this.runTime = runTime;
    }
    public long runCount() {return runs;}
    public long failureCount() {return failures;}
    public long errorCount() {return errors;}
    public long getRunTime() {return runTime;}
    public boolean shouldRun(Project p) {
        if (ifProperty != null && p.getProperty(ifProperty) == null) {
            return false;
        } else if (unlessProperty != null && 
                   p.getProperty(unlessProperty) != null) {
            return false;
        }
        return true;
    }
    public FormatterElement[] getFormatters() {
        FormatterElement[] fes = new FormatterElement[formatters.size()];
        formatters.copyInto(fes);
        return fes;
    }
    /**
     * Convenient method to add formatters to a vector
     */
    void addFormattersTo(Vector v){
        final int count = formatters.size();
        for (int i = 0; i < count; i++){
            v.addElement( formatters.elementAt(i) );
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import junit.framework.*;
import java.lang.reflect.*;
import java.io.*;
import java.util.StringTokenizer;
import java.util.Vector;
/**
 * Simple Testrunner for JUnit that runs all tests of a testsuite.
 *
 * <p>This TestRunner expects a name of a TestCase class as its
 * argument. If this class provides a static suite() method it will be
 * called and the resulting Test will be run.
 *
 * <p>Otherwise all public methods starting with ""test"" and taking no
 * argument will be run.
 *
 * <p>Summary output is generated at the end.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class JUnitTestRunner implements TestListener {
    /**
     * No problems with this test.
     */
    public static final int SUCCESS = 0;
    /**
     * Some tests failed.
     */
    public static final int FAILURES = 1;
    /**
     * An error occured.
     */
    public static final int ERRORS = 2;
    /**
     * Holds the registered formatters.
     */
    private Vector formatters = new Vector();
    /**
     * Collects TestResults.
     */
    private TestResult res;
    /**
     * Do we stop on errors.
     */
    private boolean haltOnError = false;
    /**
     * Do we stop on test failures.
     */
    private boolean haltOnFailure = false;
    /**
     * The corresponding testsuite.
     */
    private Test suite = null;
    /**
     * Exception caught in constructor.
     */
    private Exception exception;
    /**
     * Returncode
     */
    private int retCode = SUCCESS;
    /**
     * The TestSuite we are currently running.
     */
    private JUnitTest junitTest;
    /**
     * Constructor for fork=true or when the user hasn't specified a
     * classpath.  
     */
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean haltOnFailure) {
        this(test, haltOnError, haltOnFailure, null);
    }
    /**
     * Constructor to use when the user has specified a classpath.
     */
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean haltOnFailure, ClassLoader loader) {
        this.junitTest = test;
        this.haltOnError = haltOnError;
        this.haltOnFailure = haltOnFailure;
        try {
            Class testClass = null;
            if (loader == null) {
                testClass = Class.forName(test.getName());
            } else {
                testClass = loader.loadClass(test.getName());
            }
            Method suiteMethod = null;
            try {
                // check if there is a suite method
                suiteMethod= testClass.getMethod(""suite"", new Class[0]);
            } catch(Exception e) {
                // no appropriate suite method found. We don't report any
                // error here since it might be perfectly normal. We don't
                // know exactly what is the cause, but we're doing exactly
                // the same as JUnit TestRunner do. We swallow the exceptions.
            }
            if (suiteMethod != null){
                // if there is a suite method available, then try
                // to extract the suite from it. If there is an error
                // here it will be caught below and reported.
                suite = (Test)suiteMethod.invoke(null, new Class[0]);
            } else {
                // try to extract a test suite automatically
                // this will generate warnings if the class is no suitable Test
                suite= new TestSuite(testClass);
            }
        } catch(Exception e) {
            retCode = ERRORS;
            exception = e;
        }
    }
    public void run() {
        res = new TestResult();
        res.addListener(this);
        for (int i=0; i < formatters.size(); i++) {
            res.addListener((TestListener)formatters.elementAt(i));
        }
        long start = System.currentTimeMillis();
        fireStartTestSuite();
        if (exception != null) { // had an exception in the constructor
            for (int i=0; i < formatters.size(); i++) {
                ((TestListener)formatters.elementAt(i)).addError(null, 
                                                                 exception);
            }
            junitTest.setCounts(1, 0, 1);
            junitTest.setRunTime(0);
        } else {
            suite.run(res);
            junitTest.setCounts(res.runCount(), res.failureCount(), 
                                res.errorCount());
            junitTest.setRunTime(System.currentTimeMillis() - start);
        }
        fireEndTestSuite();
        if (retCode != SUCCESS || res.errorCount() != 0) {
            retCode = ERRORS;
        } else if (res.failureCount() != 0) {
            retCode = FAILURES;
        }
    }
    /**
     * Returns what System.exit() would return in the standalone version.
     *
     * @return 2 if errors occurred, 1 if tests failed else 0.
     */
    public int getRetCode() {
        return retCode;
    }
    /**
     * Interface TestListener.
     *
     * <p>A new Test is started.
     */
    public void startTest(Test t) {}
    /**
     * Interface TestListener.
     *
     * <p>A Test is finished.
     */
    public void endTest(Test test) {}
    /**
     * Interface TestListener for JUnit &lt;= 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, Throwable t) {
        if (haltOnFailure) {
            res.stop();
        }
    }
    /**
     * Interface TestListener for JUnit &gt; 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }
    /**
     * Interface TestListener.
     *
     * <p>An error occured while running the test.
     */
    public void addError(Test test, Throwable t) {
        if (haltOnError) {
            res.stop();
        }
    }
    private void fireStartTestSuite() {
        for (int i=0; i<formatters.size(); i++) {
            ((JUnitResultFormatter)formatters.elementAt(i)).startTestSuite(junitTest);
        }
    }
    private void fireEndTestSuite() {
        for (int i=0; i<formatters.size(); i++) {
            ((JUnitResultFormatter)formatters.elementAt(i)).endTestSuite(junitTest);
        }
    }
    public void addFormatter(JUnitResultFormatter f) {
        formatters.addElement(f);
    }
    /**
     * Entry point for standalone (forked) mode.
     *
     * Parameters: testcaseclassname plus parameters in the format
     * key=value, none of which is required.
     *
     * <table cols=""4"" border=""1"">
     * <tr><th>key</th><th>description</th><th>default value</th></tr>
     *
     * <tr><td>haltOnError</td><td>halt test on
     * errors?</td><td>false</td></tr>
     *
     * <tr><td>haltOnFailure</td><td>halt test on
     * failures?</td><td>false</td></tr>
     *
     * <tr><td>formatter</td><td>A JUnitResultFormatter given as
     * classname,filename. If filename is ommitted, System.out is
     * assumed.</td><td>none</td></tr>
     *
     * </table> 
     */
    public static void main(String[] args) throws IOException {
        boolean exitAtEnd = true;
        boolean haltError = false;
        boolean haltFail = false;
        if (args.length == 0) {
            System.err.println(""required argument TestClassName missing"");
            System.exit(ERRORS);
        }
        for (int i=1; i<args.length; i++) {
            if (args[i].startsWith(""haltOnError="")) {
                haltError = Project.toBoolean(args[i].substring(12));
            } else if (args[i].startsWith(""haltOnFailure="")) {
                haltFail = Project.toBoolean(args[i].substring(14));
            } else if (args[i].startsWith(""formatter="")) {
                try {
                    createAndStoreFormatter(args[i].substring(10));
                } catch (BuildException be) {
                    System.err.println(be.getMessage());
                    System.exit(ERRORS);
                }
            }
        }
        JUnitTest t = new JUnitTest(args[0]);
        JUnitTestRunner runner = new JUnitTestRunner(t, haltError, haltFail);
        transferFormatters(runner);
        runner.run();
        System.exit(runner.getRetCode());
    }
    private static Vector fromCmdLine = new Vector();
    private static void transferFormatters(JUnitTestRunner runner) {
        for (int i=0; i<fromCmdLine.size(); i++) {
            runner.addFormatter((JUnitResultFormatter) fromCmdLine.elementAt(i));
        }
    }
    /**
     * Line format is: formatter=<classname>(,<pathname>)?
     */
    private static void createAndStoreFormatter(String line)
        throws BuildException {
        FormatterElement fe = new FormatterElement();
        int pos = line.indexOf(',');
        if (pos == -1) {
            fe.setClassname(line);
        } else {
            fe.setClassname(line.substring(0, pos));
            fe.setOutfile( new File(line.substring(pos + 1)) );
        }
        fromCmdLine.addElement(fe.createFormatter());
    }
} // JUnitTestRunner
"
org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import org.apache.tools.ant.BuildException;
import java.io.*;
import java.text.NumberFormat;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestCase;
/**
 * Prints plain text output of the test to a specified Writer.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class PlainJUnitResultFormatter implements JUnitResultFormatter {
    /**
     * Formatter for timings.
     */
    private NumberFormat nf = NumberFormat.getInstance();
    /**
     * Timing helper.
     */
    private long lastTestStart = 0;
    /**
     * Where to write the log to.
     */
    private OutputStream out;
    /**
     * Helper to store intermediate output.
     */
    private StringWriter inner;
    /**
     * Convenience layer on top of {@link #inner inner}.
     */
    private PrintWriter wri;
    /**
     * Suppress endTest if testcase failed.
     */
    private boolean failed = true;
    public PlainJUnitResultFormatter() {
        inner = new StringWriter();
        wri = new PrintWriter(inner);
    }
    public void setOutput(OutputStream out) {
        this.out = out;
    }
    /**
     * Empty.
     */
    public void startTestSuite(JUnitTest suite) {
    }
    /**
     * The whole testsuite ended.
     */
    public void endTestSuite(JUnitTest suite) throws BuildException {
        StringBuffer sb = new StringBuffer(""Testsuite: "");
        sb.append(suite.getName());
        sb.append(System.getProperty(""line.separator""));
        sb.append(""Tests run: "");
        sb.append(suite.runCount());
        sb.append("", Failures: "");
        sb.append(suite.failureCount());
        sb.append("", Errors: "");
        sb.append(suite.errorCount());
        sb.append("", Time elapsed: "");
        sb.append(nf.format(suite.getRunTime()/1000.0));
        sb.append("" sec"");
        sb.append(System.getProperty(""line.separator""));
        sb.append(System.getProperty(""line.separator""));
        if (out != null) {
            try {
                out.write(sb.toString().getBytes());
                wri.close();
                out.write(inner.toString().getBytes());
                out.flush();
            } catch (IOException ioex) {
                throw new BuildException(""Unable to write output"", ioex);
            } finally {
                if (out != System.out && out != System.err) {
                    try {
                        out.close();
                    } catch (IOException e) {}
                }
            }
        }
    }
    /**
     * Interface TestListener.
     *
     * <p>A new Test is started.
     */
    public void startTest(Test t) {
        lastTestStart = System.currentTimeMillis();
        wri.print(""Testcase: "" + ((TestCase) t).name());
        failed = false;
    }
    /**
     * Interface TestListener.
     *
     * <p>A Test is finished.
     */
    public void endTest(Test test) {
        if (failed) return;
        wri.println("" took "" 
                    + nf.format((System.currentTimeMillis()-lastTestStart)
                                / 1000.0)
                    + "" sec"");
    }
    /**
     * Interface TestListener for JUnit &lt;= 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, Throwable t) {
        formatError(""\tFAILED"", test, t);
    }
    /**
     * Interface TestListener for JUnit &gt; 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }
    /**
     * Interface TestListener.
     *
     * <p>An error occured while running the test.
     */
    public void addError(Test test, Throwable t) {
        formatError(""\tCaused an ERROR"", test, t);
    }
    private void formatError(String type, Test test, Throwable t) {
        if (test != null) {
            endTest(test);
        }
        failed = true;
        wri.println(type);
        wri.println(t.getMessage());
        t.printStackTrace(wri);
        wri.println("""");
    }
} // PlainJUnitResultFormatter
"
org.apache.tools.ant.taskdefs.optional.junit.SummaryJUnitResultFormatter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import java.text.NumberFormat;
import java.io.IOException;
import java.io.OutputStream;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import org.apache.tools.ant.BuildException;
/**
 * Prints short summary output of the test to Ant's logging system.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class SummaryJUnitResultFormatter implements JUnitResultFormatter {
    /**
     * Formatter for timings.
     */
    private NumberFormat nf = NumberFormat.getInstance();
    /**
     * OutputStream to write to.
     */
    private OutputStream out;
    /**
     * Empty
     */
    public SummaryJUnitResultFormatter() {}
    /**
     * Empty
     */
    public void startTestSuite(JUnitTest suite) {}
    /**
     * Empty
     */
    public void startTest(Test t) {}
    /**
     * Empty
     */
    public void endTest(Test test) {}
    /**
     * Empty
     */
    public void addFailure(Test test, Throwable t) {}
    /**
     * Interface TestListener for JUnit &gt; 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }
    /**
     * Empty
     */
    public void addError(Test test, Throwable t) {}
    public void setOutput(OutputStream out) {
        this.out = out;
    }
    /**
     * The whole testsuite ended.
     */
    public void endTestSuite(JUnitTest suite) throws BuildException {
        StringBuffer sb = new StringBuffer(""Tests run: "");
        sb.append(suite.runCount());
        sb.append("", Failures: "");
        sb.append(suite.failureCount());
        sb.append("", Errors: "");
        sb.append(suite.errorCount());
        sb.append("", Time elapsed: "");
        sb.append(nf.format(suite.getRunTime()/1000.0));
        sb.append("" sec"");
        sb.append(System.getProperty(""line.separator""));
        try {
            out.write(sb.toString().getBytes());
            out.flush();
        } catch (IOException ioex) {
            throw new BuildException(""Unable to write summary output"", ioex);
        } finally {
            if (out != System.out && out != System.err) {
                try {
                    out.close();
                } catch (IOException e) {}
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.XMLConstants,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
/**
 * Interface that groups all constants used throughout the <tt>XML<tt>
 * documents that are generated by the <tt>XMLJUnitResultFormatter</tt>
 * As of now the DTD is:
 *
 * <----------------- @todo describe DTDs ---------------------->
 *
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 * @see XMLJUnitResultFormatter
 * @see XMLResultAggregator
 */
public interface XMLConstants {
    /** the testsuites element for the aggregate document */
    public final static String TESTSUITES = ""testsuites"";
    /** the testsuite element */
    public final static String TESTSUITE = ""testsuite"";
    /** the testcase element */
    public final static String TESTCASE = ""testcase"";
    /** the error element */
    public final static String ERROR = ""error"";
    /** the failure element */
    public final static String FAILURE = ""failure"";
    /** package attribute for the aggregate document */
    public final static String ATTR_PACKAGE = ""package"";
    /** name attribute for testcase and testsuite elements */
    public final static String ATTR_NAME = ""name"";
    /** time attribute for testcase and testsuite elements */
    public final static String ATTR_TIME = ""time"";
    /** errors attribute for testsuite elements */
    public final static String ATTR_ERRORS = ""errors"";
    /** failures attribute for testsuite elements */
    public final static String ATTR_FAILURES = ""failures"";
    /** tests attribute for testsuite elements */
    public final static String ATTR_TESTS = ""tests"";
    /** type attribute for failure and error elements */
    public final static String ATTR_TYPE = ""type"";
    /** message attribute for failure elements */
    public final static String ATTR_MESSAGE = ""message"";
}
"
org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import java.io.*;
import java.text.NumberFormat;
import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
import java.util.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.DOMElementWriter;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestCase;
/**
 * Prints XML output of the test to a specified Writer.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class XMLJUnitResultFormatter implements JUnitResultFormatter, XMLConstants {
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        }
        catch(Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }
    /**
     * Formatter for timings.
     */
    private NumberFormat nf = NumberFormat.getInstance(Locale.US);
    /**
     * The XML document.
     */
    private Document doc;
    /**
     * The wrapper for the whole testsuite.
     */
    private Element rootElement;
    /**
     * Element for the current test.
     */
    private Element currentTest;
    /**
     * Timing helper.
     */
    private long lastTestStart = 0;
    /**
     * Where to write the log to.
     */
    private OutputStream out;
    public XMLJUnitResultFormatter() {}
    public void setOutput(OutputStream out) {
        this.out = out;
    }
    /**
     * The whole testsuite started.
     */
    public void startTestSuite(JUnitTest suite) {
        doc = getDocumentBuilder().newDocument();
        rootElement = doc.createElement(TESTSUITE);
        rootElement.setAttribute(ATTR_NAME, suite.getName());
    }
    /**
     * The whole testsuite ended.
     */
    public void endTestSuite(JUnitTest suite) throws BuildException {
        rootElement.setAttribute(ATTR_TESTS, """"+suite.runCount());
        rootElement.setAttribute(ATTR_FAILURES, """"+suite.failureCount());
        rootElement.setAttribute(ATTR_ERRORS, """"+suite.errorCount());
        rootElement.setAttribute(ATTR_TIME,
                                 nf.format(suite.getRunTime()/1000.0));
        if (out != null) {
            Writer wri = null;
            try {
                wri = new OutputStreamWriter(out);
                wri.write(""<?xml version=\""1.0\""?>\n"");
                (new DOMElementWriter()).write(rootElement, wri, 0, ""  "");
                wri.flush();
            } catch(IOException exc) {
                throw new BuildException(""Unable to write log file"", exc);
            } finally {
                if (out != System.out && out != System.err) {
                    if (wri != null) {
                        try {
                            wri.close();
                        } catch (IOException e) {}
                    }
                }
            }
        }
    }
    /**
     * Interface TestListener.
     *
     * <p>A new Test is started.
     */
    public void startTest(Test t) {
        lastTestStart = System.currentTimeMillis();
        currentTest = doc.createElement(TESTCASE);
        currentTest.setAttribute(ATTR_NAME, ((TestCase) t).name());
        rootElement.appendChild(currentTest);
    }
    /**
     * Interface TestListener.
     *
     * <p>A Test is finished.
     */
    public void endTest(Test test) {
        currentTest.setAttribute(ATTR_TIME,
                                 nf.format((System.currentTimeMillis()-lastTestStart)
                                           / 1000.0));
    }
    /**
     * Interface TestListener for JUnit &lt;= 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, Throwable t) {
        formatError(FAILURE, test, t);
    }
    /**
     * Interface TestListener for JUnit &gt; 3.4.
     *
     * <p>A Test failed.
     */
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }
    /**
     * Interface TestListener.
     *
     * <p>An error occured while running the test.
     */
    public void addError(Test test, Throwable t) {
        formatError(ERROR, test, t);
    }
    private void formatError(String type, Test test, Throwable t) {
        if (test != null) {
            endTest(test);
        }
        Element nested = doc.createElement(type);
        if (test != null) {
            currentTest.appendChild(nested);
        } else {
            rootElement.appendChild(nested);
        }
        String message = t.getMessage();
        if (message != null && message.length() > 0) {
            nested.setAttribute(ATTR_MESSAGE, t.getMessage());
        }
        nested.setAttribute(ATTR_TYPE, t.getClass().getName());
        StringWriter swr = new StringWriter();
        t.printStackTrace(new PrintWriter(swr, true));
        Text trace = doc.createTextNode(swr.toString());
        nested.appendChild(trace);
    }
} // XMLJUnitResultFormatter
"
org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.junit;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.FileOutputStream;
import java.util.Enumeration;
import java.util.Vector;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.*;
import org.xml.sax.SAXException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.util.DOMElementWriter;
/**
 * This is an helper class that will aggregate all testsuites under a specific
 * directory and create a new single document. It is not particulary clean but
 * should be helpful while I am thinking about another technique.
 *
 * The main problem is due to the fact that a JVM can be forked for a testcase
 * thus making it impossible to aggregate all testcases since the listener is
 * (obviously) in the forked JVM. A solution could be to write a
 * TestListener that will receive events from the TestRunner via sockets. This
 * is IMHO the simplest way to do it to avoid this file hacking thing.
 *
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public class XMLResultAggregator extends Task implements XMLConstants {
    /** the list of all filesets, that should contains the xml to aggregate */
    protected Vector filesets = new Vector();
    /** the name of the result file */
    protected String toFile;
    /** the directory to write the file to */
    protected File toDir;
    protected Vector transformers = new Vector();
    /** the default directory: <tt>.</tt>. It is resolved from the project directory */
    public final static String DEFAULT_DIR = ""."";
    /** the default file name: <tt>TESTS-TestSuites.xml</tt> */
    public final static String DEFAULT_FILENAME = ""TESTS-TestSuites.xml"";
    public AggregateTransformer createReport(){
        AggregateTransformer transformer = new AggregateTransformer(this);
        transformers.add(transformer);
        return transformer;
    }
    /**
     * Set the name of the file aggregating the results. It must be relative
     * from the <tt>todir</tt> attribute. If not set it will use {@link DEFAULT_FILENAME}
     * @param  value   the name of the file.
     * @see #setTodir(File)
     */
    public void setTofile(String value){
        toFile = value;
    }
    /**
     * Set the destination directory where the results should be written. If not
     * set if will use {@link DEFAULT_DIR}. When given a relative directory
     * it will resolve it from the project directory.
     * @param value    the directory where to write the results, absolute or
     * relative.
     */
    public void setTodir(File value){
        toDir = value;
    }
    /**
     * Add a new fileset containing the xml results to aggregate
     * @param    fs      the new fileset of xml results.
     */
    public void addFileSet(FileSet fs) {
        filesets.addElement(fs);
    }
    /**
     * Aggregate all testsuites into a single document and write it to the
     * specified directory and file.
     * @throws	BuildException	thrown if there is a serious error while writing
     *			the document.
     */
    public void execute() throws BuildException {
        Element rootElement = createDocument();
        File destFile = getDestinationFile();
        // write the document
        try {
            writeDOMTree(rootElement.getOwnerDocument(),  destFile );
        } catch (IOException e){
            throw new BuildException(""Unable to write test aggregate to '"" + destFile + ""'"", e);
        }
        // apply transformation
        Enumeration enum = transformers.elements();
        while (enum.hasMoreElements()) {
            AggregateTransformer transformer =
                (AggregateTransformer) enum.nextElement();
            transformer.setXmlDocument(rootElement.getOwnerDocument());
            transformer.transform();
        }
    }
    /**
     * get the full destination file where to write the result. It is made of
     * the <tt>todir</tt> and <tt>tofile</tt> attributes.
     * @return the destination file where should be written the result file.
     */
    protected File getDestinationFile(){
        if (toFile == null){
            toFile = DEFAULT_FILENAME;
        }
        if (toDir == null){
            toDir = project.resolveFile(DEFAULT_DIR);
        }
        return new File(toDir, toFile);
    }
    /**
     * @return all files in the fileset that end with a '.xml'.
     */
    protected File[] getFiles() {
        Vector v = new Vector();
        final int size = filesets.size();
        for (int i = 0; i < size; i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(project);
            ds.scan();
            String[] f = ds.getIncludedFiles();
            for (int j = 0; j < f.length; j++) {
                String pathname = f[j];
                if ( pathname.endsWith("".xml"") ) {
                    File file = new File(ds.getBasedir(), pathname);
                    file = project.resolveFile(file.getPath());
                    v.addElement( file );
                }
            }
        }
        File[] files = new File[v.size()];
        v.copyInto(files);
        return files;
    }
    //----- from now, the methods are all related to DOM tree manipulation
    /**
     * Write the DOM tree to a file.
     * @param doc the XML document to dump to disk.
     * @param file the filename to write the document to. Should obviouslly be a .xml file.
     * @throws IOException thrown if there is an error while writing the content.
     */
    protected void writeDOMTree(Document doc, File file) throws IOException {
        OutputStream out = new FileOutputStream( file );
        PrintWriter wri = new PrintWriter(out);
        wri.write(""<?xml version=\""1.0\""?>\n"");
        (new DOMElementWriter()).write(doc.getDocumentElement(), wri, 0, ""  "");
        wri.flush();
        wri.close();
        // writers do not throw exceptions, so check for them.
        if (wri.checkError()){
            throw new IOException(""Error while writing DOM content"");
        }
    }
    /**
     * Create a DOM tree with firstchild as 'testsuites' and aggregates all
     * testsuite results that exists in the base directory.
     * @return	the root element of DOM tree that aggregates all testsuites.
     */
    protected Element createDocument() {
        // create the dom tree
        DocumentBuilder builder = getDocumentBuilder();
        Document doc = builder.newDocument();
        Element rootElement = doc.createElement(TESTSUITES);
        doc.appendChild(rootElement);
        // get all files and add them to the document
        File[] files = getFiles();
        for (int i = 0; i < files.length; i++) {
            try {
                log(""Parsing file: '"" + files[i] + ""'"", Project.MSG_VERBOSE);
                //XXX there seems to be a bug in xerces 1.3.0 that doesn't like file object
                // will investigate later. It does not use the given directory but
                // the vm dir instead ? Works fine with crimson.
                Document testsuiteDoc = builder.parse( ""file:///"" + files[i].getAbsolutePath() );
                Element elem = testsuiteDoc.getDocumentElement();
                // make sure that this is REALLY a testsuite.
                if ( TESTSUITE.equals(elem.getNodeName()) ) {
                    addTestSuite(rootElement, elem);
                } else {
                    // issue a warning.
                    log(""the file "" + files[i] + "" is not a valid testsuite XML document"", Project.MSG_WARN);
                }
            } catch (SAXException e){
                // a testcase might have failed and write a zero-length document,
                // It has already failed, but hey.... mm. just put a warning
                log(""The file "" + files[i] + "" is not a valid XML document. It is possibly corrupted."", Project.MSG_WARN);
                StringWriter sw = new StringWriter();
                e.printStackTrace(new PrintWriter(sw));
                log(sw.toString(), Project.MSG_DEBUG);
            } catch (IOException e){
                log(""Error while accessing file "" + files[i] + "": "" + e.getMessage(), Project.MSG_ERR);
            }
        }
        return rootElement;
    }
    /**
     * Add a new testsuite node to the document, the main difference is that it
     * split the previous fully qualified name into a package and a name.
     * For example: <tt>org.apache.Whatever</tt> will be splitted in
     * <tt>org.apache</tt> and <tt>Whatever</tt>.
     * @param root the root element to which the <tt>testsuite</tt> node should
     *        be appended.
     * @param testsuite the element to append to the given root. It will slightly
     *        modify the original node to change the name attribute and add
     *        a package one.
     */
    protected void addTestSuite(Element root, Element testsuite){
        String fullclassname = testsuite.getAttribute(ATTR_NAME);
        int pos = fullclassname.lastIndexOf('.');
        // a missing . might imply no package at all. Don't get fooled.
        String pkgName = (pos == -1) ? """" : fullclassname.substring(0, pos);
        String classname = (pos == -1) ? fullclassname : fullclassname.substring(pos + 1);
        Element copy = (Element)DOMUtil.importNode(root, testsuite);
        // modify the name attribute and set the package
        copy.setAttribute(ATTR_NAME, classname);
        copy.setAttribute(ATTR_PACKAGE, pkgName);
    }
    /**
     * Create a new document builder. Will issue an <tt>ExceptionInitializerError</tt>
     * if something is going wrong. It is fatal anyway.
     * @return a new document builder to create a DOM
     * @todo factorize this somewhere else. It is duplicated code.
     */
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch(Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.metamata.MParse,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.metamata;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import java.io.*;
import java.util.*;
/**
 * Simple Metamata MParse task based on the original written by
 * <a href=""mailto:thomas.haas@softwired-inc.com"">Thomas Haas</a>
 * 
 * This version was written for Metamata 2.0 available at
 * <a href=""http://www.metamata.com"">http://www.metamata.com</a>
 *
 * @author <a href=""mailto:sbailliez@imediation.com"">Stephane Bailliez</a>
 */
public class MParse extends Task {
    private Path classpath = null;
    private Path sourcepath = null;
    private File metahome = null;
    private File target = null;
    private boolean verbose = false;
    private boolean debugparser = false;
    private boolean debugscanner = false;    
    private boolean cleanup = false;
    private CommandlineJava cmdl = new CommandlineJava();
    private File optionsFile = null;
    /** location of metamata dev environment */
    public void setMetamatahome(File metamatahome) {
        this.metahome = metamatahome;
    }
    /** the .jj file to process */
    public void setTarget(File target) {
        this.target = target;
    }
    /** create a classpath entry */
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }        
        return classpath;
    }
    /** creates a sourcepath entry */
    public Path createSourcepath() {
        if (sourcepath == null) {
            sourcepath = new Path(project);
        }        
        return sourcepath;
    }
    /** set verbose mode */
    public void setVerbose(boolean flag){
        verbose = flag;
    }
    /** set scanner debug mode */
    public void setDebugscanner(boolean flag){
        debugscanner = flag;
    }
    /** set parser debug mode */
    public void setDebugparser(boolean flag){
        debugparser = flag;
    }
    /** set the hack to cleanup the temp file */
    public void setCleanup(boolean value) {
        cleanup = value;
    }
    /** Creates a nested jvmarg element. */
    public Commandline.Argument createJvmarg() {
        return cmdl.createVmArgument();
    }
    /**  -mx or -Xmx depending on VM version */
    public void setMaxmemory(String max){
        if (Project.getJavaVersion().startsWith(""1.1"")) {
            createJvmarg().setValue(""-mx"" + max);
        } else {
            createJvmarg().setValue(""-Xmx"" + max);
        }
    }
    public MParse() {
        cmdl.setVm(""java"");
        cmdl.setClassname(""com.metamata.jj.MParse"");
    }
    /** execute the command line */
    public void execute() throws BuildException {
        try {
            setUp();
            ExecuteStreamHandler handler = createStreamHandler();
            _execute(handler);
        } finally {
            cleanUp();
        }
    }
    /** return the default stream handler for this task */
    protected ExecuteStreamHandler createStreamHandler(){
        return new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_INFO);
    }
    /**
     * check the options and build the command line
     */
    protected void setUp() throws BuildException {
        checkOptions();
        // set the classpath as the jar files
        File[] jars = getMetamataLibs();
        final Path classPath = cmdl.createClasspath(project);
        for (int i = 0; i < jars.length; i++){
            classPath.createPathElement().setLocation(jars[i]);
        }
        // set the metamata.home property
        final Commandline.Argument vmArgs = cmdl.createVmArgument();
        vmArgs.setValue(""-Dmetamata.home="" + metahome.getAbsolutePath() );
        // write all the options to a temp file and use it ro run the process
        String[] options = getOptions();
        optionsFile = createTmpFile();
        generateOptionsFile(optionsFile, options);
        Commandline.Argument args = cmdl.createArgument();
        args.setLine(""-arguments "" + optionsFile.getAbsolutePath());
    }    
    /** execute the process with a specific handler */
    protected void _execute(ExecuteStreamHandler handler) throws BuildException {
        // target has been checked as a .jj, see if there is a matching
        // java file and if it is needed to run to process the grammar
        String pathname = target.getAbsolutePath();
        int pos = pathname.length() - "".jj"".length();
        pathname = pathname.substring(0, pos) + "".java"";
        File javaFile = new File(pathname);
        if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) {
            project.log(""Target is already build - skipping ("" + target + "")"");
            return;
        }
        final Execute process = new Execute(handler);
        log(cmdl.toString(), Project.MSG_VERBOSE);
        process.setCommandline(cmdl.getCommandline());
        try {
            if (process.execute() != 0) {
                throw new BuildException(""Metamata task failed."");
            }
        } catch (IOException e){
            throw new BuildException(""Failed to launch Metamata task: "" + e);
        }
    }    
    /** clean up all the mess that we did with temporary objects */
    protected void cleanUp(){
        if (optionsFile != null){
            optionsFile.delete();
            optionsFile = null;
        }
        if (cleanup) {
            String name = target.getName();
            int pos = name.length() - "".jj"".length();
            name = ""__jj"" + name.substring(0, pos) + "".sunjj"";
            final File sunjj = new File(target.getParent(), name);
            if (sunjj.exists()) {
                project.log(""Removing stale file: "" + sunjj.getName());
                sunjj.delete();
            }
        }
    }
    /**
     * return an array of files containing the path to the needed
     * libraries to run metamata. The file are not checked for
     * existence. You should do this yourself if needed or simply let the
     * forked process do it for you.
     * @return array of jars/zips needed to run metamata.
     */
    protected File[] getMetamataLibs(){
        Vector files = new Vector();
        files.addElement( new File(metahome, ""lib/metamata.jar"") );
        files.addElement( new File(metahome, ""bin/lib/JavaCC.zip"") );
        File[] array = new File[ files.size() ];
        files.copyInto(array);
        return array;
    }
    /**
     * validate options set and resolve files and paths
     * @throws BuildException thrown if an option has an incorrect state.
     */
    protected void checkOptions() throws BuildException {       
        // check that the home is ok.
        if (metahome == null || !metahome.exists()){
            throw new BuildException(""'metamatahome' must point to Metamata home directory."");
        }
        metahome = project.resolveFile(metahome.getPath());
        // check that the needed jar exists.
        File[] jars = getMetamataLibs();
        for (int i = 0; i < jars.length; i++){
            if (!jars[i].exists()){
                throw new BuildException( jars[i] + "" does not exist. Check your metamata installation."");
            }           
        }
        // check that the target is ok and resolve it.
        if (target == null || !target.isFile() || !target.getName().endsWith("".jj"") ) {
            throw new BuildException(""Invalid target: "" + target);
        }
        target = project.resolveFile(target.getPath());
    }    
    /**
     * return all options of the command line as string elements
     * @param an array of options corresponding to the setted options.
     */
    protected String[] getOptions(){
        Vector options = new Vector();
        if (verbose){
            options.addElement(""-verbose"");
        }
        if (debugscanner){
            options.addElement(""-ds"");
        }
        if (debugparser){
            options.addElement(""-dp"");
        }
        if (classpath != null){
            options.addElement(""-classpath"");
            options.addElement(classpath.toString());
        }
        if (sourcepath != null){
            options.addElement(""-sourcepath"");
            options.addElement(sourcepath.toString());
        }
        options.addElement(target.getAbsolutePath());
        String[] array = new String[options.size()];
        options.copyInto(array);
        return array;
    }
    /**
     * write all options to a file with one option / line
     * @param tofile the file to write the options to.
     * @param options the array of options element to write to the file.
     * @throws BuildException thrown if there is a problem while writing
     * to the file.
     */
    protected void generateOptionsFile(File tofile, String[] options) throws BuildException {
        FileWriter fw = null;
        try {
            fw = new FileWriter(tofile);
            PrintWriter pw = new PrintWriter(fw);
            for (int i = 0; i < options.length; i++){
                pw.println( options[i] );
            }
            pw.flush();
        } catch (IOException e){
            throw new BuildException(""Error while writing options file "" + tofile, e);
        } finally {
            if (fw != null){
                try {
                    fw.close();
                } catch (IOException ignored){}
            }
        }
    }
    /** create a temporary file in the current directory */
    protected final static File createTmpFile(){
        // must be compatible with JDK 1.1 !!!!
        final long rand = (new Random(System.currentTimeMillis())).nextLong();
        File file = new File(""metamata"" + rand + "".tmp"");
        return file;
    }
}
"
org.apache.tools.ant.taskdefs.optional.net.FTP,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.net;
import com.oroinc.net.ftp.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;
/**
 * Basic FTP client that performs the following actions:
 * <ul>
 *   <li><strong>send</strong> - send files to a remote server.  This is the
 *              default action.</li>
 *   <li><strong>get</strong> - retrive files from a remote server.</li>
 *   <li><strong>del</strong> - delete files from a remote server.</li>
 *   <li><strong>list</strong> - create a file listing.</li>
 * </ul>
 *
 * @author Roger Vaughn <a href=""mailto:rvaughn@seaconinc.com"">rvaughn@seaconinc.com</a>
 * @author Glenn McAllister <a href=""mailto:glennm@ca.ibm.com"">glennm@ca.ibm.com</a>
 */
public class FTP
    extends Task
{
    protected final static int SEND_FILES   = 0;
    protected final static int GET_FILES    = 1;
    protected final static int DEL_FILES    = 2;        
    protected final static int LIST_FILES   = 3;
    private String remotedir;
    private String server;
    private String userid;
    private String password;
    private File listing;
    private boolean binary = true;
    private boolean passive = false;
    private boolean verbose = false;
    private boolean newerOnly = false;
    private int action = SEND_FILES;
    private Vector filesets = new Vector();
    private Vector dirCache = new Vector();
    private int transferred = 0;
    private String remoteFileSep = ""/"";
    private int port = 21;
    protected final static String[] ACTION_STRS = {
        ""sending"",
        ""getting"",
        ""deleting"",
        ""listing""
    };
    protected final static String[] COMPLETED_ACTION_STRS = {
        ""sent"",
        ""retrieved"",
        ""deleted"",
        ""listed""
    };                
    protected class FTPDirectoryScanner extends DirectoryScanner {
        protected FTPClient ftp = null;
        public FTPDirectoryScanner(FTPClient ftp) {
            super();
            this.ftp = ftp;
        }
        public void scan() {
            if (includes == null) {
                // No includes supplied, so set it to 'matches all'
                includes = new String[1];
                includes[0] = ""**"";
            }
            if (excludes == null) {
                excludes = new String[0];
            }
            filesIncluded = new Vector();
            filesNotIncluded = new Vector();
            filesExcluded = new Vector();
            dirsIncluded = new Vector();
            dirsNotIncluded = new Vector();
            dirsExcluded = new Vector();
            try {
                String cwd = ftp.printWorkingDirectory();
                scandir(""."", """", true); // always start from the current ftp working dir
                ftp.changeWorkingDirectory(cwd);
            } catch (IOException e) {
                throw new BuildException(""Unable to scan FTP server: "", e);
            }
        }
        protected void scandir(String dir, String vpath, boolean fast) {
            try {
                if (!ftp.changeWorkingDirectory(dir)) {
                    return;
                }
                FTPFile[] newfiles = ftp.listFiles();
                if (newfiles == null) {
                    return;    // no files in directory.
                }
                for (int i = 0; i < newfiles.length; i++) {
                    FTPFile file = newfiles[i];
                    String name = vpath + file.getName();
                    if (file.isDirectory()) {
                        if (isIncluded(name)) {
                            if (!isExcluded(name)) {
                                dirsIncluded.addElement(name);
                                if (fast) {
                                    scandir(name, name + File.separator, fast);
                                }
                            } else {
                                dirsExcluded.addElement(name);
                            }
                        } else {
                            dirsNotIncluded.addElement(name);
                            if (fast && couldHoldIncluded(name)) {
                                scandir(name, name + File.separator, fast);
                            }
                        }
                        if (!fast) {
                            scandir(name, name + File.separator, fast);
                        }
                    } else {
                        if (file.isFile()) {
                            if (isIncluded(name)) {
                                if (!isExcluded(name)) {
                                    filesIncluded.addElement(name);
                                } else {
                                    filesExcluded.addElement(name);
                                }
                            } else {
                                filesNotIncluded.addElement(name);
                            }
                        }
                    }
                }
            } catch (IOException e) {
                throw new BuildException(""Error while communicating with FTP server: "", e);
            }
        }
    }        
    /**
     * Sets the remote directory where files will be placed.  This may
     * be a relative or absolute path, and must be in the path syntax
     * expected by the remote server.  No correction of path syntax will
     * be performed.
     */
    public void setRemotedir(String dir)
    {
        this.remotedir = dir;
    }
    /**
     * Sets the FTP server to send files to.
     */
    public void setServer(String server)
    {
        this.server = server;
    }
    /**
     * Sets the FTP port used by the remote server.
     */
    public void setPort(int port)
    {
        this.port = port;
    }
    /**
     * Sets the login user id to use on the specified server.
     */
    public void setUserid(String userid)
    {
        this.userid = userid;
    }
    /**
     * Sets the login password for the given user id.
     */
    public void setPassword(String password)
    {
        this.password = password;
    }
    /**
     * Specifies whether to use binary-mode or text-mode transfers.  Set
     * to true to send binary mode.  Binary mode is enabled by default.
     */
    public void setBinary(boolean binary)
    {
        this.binary = binary;
    }
    /**
     * Specifies whether to use passive mode.  Set to true if you
     * are behind a firewall and cannot connect without it.  Passive mode
     * is disabled by default.
     */
    public void setPassive(boolean passive)
    {
        this.passive = passive;
    }
    /**
     * Set to true to receive notification about each file as it is
     * transferred.
     */
    public void setVerbose(boolean verbose)
    {
        this.verbose = verbose;
    }
    /**
     * Set to true to transmit only files that are new or changed from their
     * remote counterparts.  The default is to transmit all files.
     */
    public void setNewer(boolean newer)
    {
        this.newerOnly = newer;
    }
    /**
     * A synonym for setNewer.  Set to true to transmit only new or changed
     * files.
     */
    public void setDepends(boolean depends)
    {
        this.newerOnly = depends;
    }
    /**
     * Sets the remote file separator character.  This normally defaults to
     * the Unix standard forward slash, but can be manually overridden using
     * this call if the remote server requires some other separator.  Only
     * the first character of the string is used.
     */
    public void setSeparator(String separator)
    {
        remoteFileSep = separator;
    }
    /**
     * Adds a set of files (nested fileset attribute).
     */
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }
    /**
     * Sets the FTP action to be taken.  Currently accepts ""put"", ""get"",
     * ""del"", and ""list"".
     */
    public void setAction(String action) throws BuildException
    {
        if (action.toLowerCase().equals(""send"") ||
            action.toLowerCase().equals(""put""))
        {
            this.action = SEND_FILES;
        }
        else if (action.toLowerCase().equals(""recv"") ||
                 action.toLowerCase().equals(""get""))
        {
            this.action = GET_FILES;
        }
        else if (action.toLowerCase().equals(""del"") ||
                 action.toLowerCase().equals(""delete"" ))
        {
            this.action = DEL_FILES;
        }
        else if (action.toLowerCase().equals(""list""))
        {
            this.action = LIST_FILES;
        }
        else
        {
            throw new BuildException(""action "" + action + "" is not supported"");
        }
    }
    /**
     * The output file for the ""list"" action.  This attribute is ignored for
     * any other actions.
     */
    public void setListing(File listing) throws BuildException {
        this.listing = listing;
    }        
    /**
     * Checks to see that all required parameters are set.
     */
    protected void checkConfiguration() throws BuildException
    {
        if (server == null)
        {
            throw new BuildException(""server attribute must be set!"");
        }
        if (userid == null)
        {
            throw new BuildException(""userid attribute must be set!"");
        }
        if (password == null)
        {
            throw new BuildException(""password attribute must be set!"");
        }
        if ((action == LIST_FILES) && (listing == null))
        {
            throw new BuildException(""listing attribute must be set for list action!"");
        }
    }
    /**
     * For each file in the fileset, do the appropriate action: send, get, delete,
     * or list.
     */
    protected int transferFiles(FTPClient ftp, FileSet fs)
        throws IOException, BuildException
    {
        FileScanner ds;
        if (action == SEND_FILES) {
            ds = fs.getDirectoryScanner(project);
        } else {
            ds = new FTPDirectoryScanner(ftp);
            fs.setupDirectoryScanner(ds, project);
            ds.scan();
        }                        
        String[] dsfiles = ds.getIncludedFiles();
        String dir = null;
        if ((ds.getBasedir() == null) && ((action == SEND_FILES) || (action == GET_FILES))) {
            throw new BuildException( ""the dir attribute must be set for send and get actions"" );
        } else {
            if ((action == SEND_FILES) || (action == GET_FILES)) {
                dir = ds.getBasedir().getAbsolutePath();
            }
        }
        // If we are doing a listing, we need the output stream created now.
        BufferedWriter bw = null;
        if (action == LIST_FILES) {
            File pd = new File(listing.getParent());
            if (!pd.exists()) {
                pd.mkdirs();
            }
            bw = new BufferedWriter(new FileWriter(listing));
        }
        for (int i = 0; i < dsfiles.length; i++)
        {
            switch (action) {
            case SEND_FILES: {
                sendFile(ftp, dir, dsfiles[i]);
                break;
            }
            case GET_FILES: {
                getFile(ftp, dir, dsfiles[i]);
                break;
            }
            case DEL_FILES: {
                delFile(ftp, dsfiles[i]);
                break;
            }
            case LIST_FILES: {
                listFile(ftp, bw, dsfiles[i]);
                break;
            }
            default: {
                throw new BuildException(""unknown ftp action "" + action );
            }
            }
        }
        if (action == LIST_FILES) {
            bw.close();
        }
        return dsfiles.length;
    }
    /**
     * Sends all files specified by the configured filesets to the remote
     * server.
     */
    protected void transferFiles(FTPClient ftp)
        throws IOException, BuildException
    {
        transferred = 0;
        if (filesets.size() == 0)
        {
            throw new BuildException(""at least one fileset must be specified."");
        }
        else
        {
            // get files from filesets
            for (int i = 0; i < filesets.size(); i++)
            {
                FileSet fs = (FileSet) filesets.elementAt(i);
                if (fs != null)
                {
                    transferFiles(ftp, fs);
                }
            }
        }
        log(transferred + "" files "" + COMPLETED_ACTION_STRS[action]);
    }
    /**
     * Correct a file path to correspond to the remote host requirements.
     * This implementation currently assumes that the remote end can
     * handle Unix-style paths with forward-slash separators.  This can
     * be overridden with the <code>separator</code> task parameter.  No
     * attempt is made to determine what syntax is appropriate for the
     * remote host.
     */
    protected String resolveFile(String file)
    {
        return file.replace(System.getProperty(""file.separator"").charAt(0),
                            remoteFileSep.charAt(0));
    }
    /**
     * Creates all parent directories specified in a complete relative
     * pathname.  Attempts to create existing directories will not cause
     * errors.
     */
    protected void createParents(FTPClient ftp, String filename)
        throws IOException, BuildException
    {
        Vector parents = new Vector();
        File dir = new File(filename);
        String dirname;
        while ((dirname = dir.getParent()) != null)
        {
            dir = new File(dirname);
            parents.addElement(dir);
        }
        for (int i = parents.size() - 1; i >= 0; i--)
        {
            dir = (File)parents.elementAt(i);
            if (!dirCache.contains(dir))
            {
                log(""creating remote directory "" + resolveFile(dir.getPath()),
                    Project.MSG_VERBOSE);
                ftp.makeDirectory(resolveFile(dir.getPath()));
                // Both codes 550 and 553 can be produced by FTP Servers
                //  to indicate that an attempt to create a directory has
                //  failed because the directory already exists.
                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()) &&
                    (ftp.getReplyCode() != 550) && (ftp.getReplyCode() != 553))
                {
                    throw new BuildException(
                                             ""could not create directory: "" +
                                             ftp.getReplyString());
                }
                dirCache.addElement(dir);
            }
        }
    }
    /**
     * Checks to see if the remote file is current as compared with the
     * local file.  Returns true if the remote file is up to date.
     */
    protected boolean isUpToDate(FTPClient ftp, File localFile, String remoteFile)
        throws IOException, BuildException
    {
        log(""checking date for "" + remoteFile, Project.MSG_VERBOSE);
        FTPFile[] files = ftp.listFiles(remoteFile);
        if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
        {
            throw new BuildException(
                                     ""could not date test remote file: "" +
                                     ftp.getReplyString());
        }
        if (files == null)
        {
            return false;
        }
        long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
        long localTimestamp = localFile.lastModified();
        if (this.action == SEND_FILES) {
            return remoteTimestamp > localTimestamp;
        } else {
            return localTimestamp > remoteTimestamp;
        }
    }
    /**
     * Sends a single file to the remote host.
     * <code>filename</code> may contain a relative path specification.
     * When this is the case, <code>sendFile</code> will attempt to create
     * any necessary parent directories before sending the file.  The file
     * will then be sent using the entire relative path spec - no attempt
     * is made to change directories.  It is anticipated that this may
     * eventually cause problems with some FTP servers, but it simplifies
     * the coding.
     */
    protected void sendFile(FTPClient ftp, String dir, String filename)
        throws IOException, BuildException
    {
        InputStream instream = null;
        try
        {
            File file = project.resolveFile(new File(dir, filename).getPath());
            if (newerOnly && isUpToDate(ftp, file, resolveFile(filename)))
                return;
            if (verbose)
            {
                log(""transferring "" + file.getAbsolutePath());
            }
            instream = new BufferedInputStream(new FileInputStream(file));
            createParents(ftp, filename);
            ftp.storeFile(resolveFile(filename), instream);
            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
            {
                throw new BuildException(
                                         ""could not transfer file: "" +
                                         ftp.getReplyString());
            }
            log(""File "" + file.getAbsolutePath() + "" copied to "" + server,
                Project.MSG_VERBOSE);
            transferred++;
        }
        finally
        {            
            if (instream != null)
            {
                try
                {
                    instream.close();
                }
                catch(IOException ex)
                {
                    // ignore it
                }
            }
        }
    }
    /**
     * Delete a file from the remote host.
     */
    protected void delFile(FTPClient ftp, String filename)
        throws IOException, BuildException {
        if (verbose) {
            log(""deleting "" + filename);
        }
        if (!ftp.deleteFile(resolveFile(filename))) {
            throw new BuildException(""could not delete file: "" + ftp.getReplyString());
        }
        log(""File "" + filename + "" deleted from "" + server, Project.MSG_VERBOSE); 
        transferred++;
    }
    /**
     * Retrieve a single file to the remote host.
     * <code>filename</code> may contain a relative path specification.
     * The file will then be retreived using the entire relative path spec - 
     * no attempt is made to change directories.  It is anticipated that this may
     * eventually cause problems with some FTP servers, but it simplifies
     * the coding.
     */
    protected void getFile(FTPClient ftp, String dir, String filename)
        throws IOException, BuildException
    {
        OutputStream outstream = null;
        try
        {
            File file = project.resolveFile(new File(dir, filename).getPath());
            if (newerOnly && isUpToDate(ftp, file, resolveFile(filename)))
                return;
            if (verbose)
            {
                log(""transferring "" + filename + "" to "" + file.getAbsolutePath());
            }
            File pdir = new File(file.getParent());        // stay 1.1 compatible
            if (!pdir.exists()) {
                pdir.mkdirs();
            }                
            outstream = new BufferedOutputStream(new FileOutputStream(file));
            ftp.retrieveFile(resolveFile(filename), outstream);
            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
            {
                throw new BuildException(
                                         ""could not transfer file: "" +
                                         ftp.getReplyString());
            }
            log(""File "" + file.getAbsolutePath() + "" copied from "" + server,
                Project.MSG_VERBOSE);
            transferred++;
        }
        finally
        {            
            if (outstream != null)
            {
                try
                {
                    outstream.close();
                }
                catch(IOException ex)
                {
                    // ignore it
                }
            }
        }
    }
    /**
     * List information about a single file from the remote host.
     * <code>filename</code> may contain a relative path specification.
     * The file listing will then be retrieved using the entire relative path spec 
     * - no attempt is made to change directories.  It is anticipated that this may
     * eventually cause problems with some FTP servers, but it simplifies
     * the coding.
     */
    protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
        throws IOException, BuildException 
    {
        if (verbose) {
            log(""listing "" + filename);
        }
        FTPFile ftpfile = ftp.listFiles(resolveFile(filename))[0];
        bw.write(ftpfile.toString());
        bw.newLine();
        transferred++;
    }
    /**
     * Runs the task.
     */
    public void execute()
        throws BuildException
    {
        checkConfiguration();
        FTPClient ftp = null;
        try
        {
            log(""Opening FTP connection to "" + server, Project.MSG_VERBOSE);
            ftp = new FTPClient();
            ftp.connect(server, port);
            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
            {
                throw new BuildException(""FTP connection failed: "" + ftp.getReplyString());
            }
            log(""connected"", Project.MSG_VERBOSE);
            log(""logging in to FTP server"", Project.MSG_VERBOSE);
            if (!ftp.login(userid, password))
            {
                throw new BuildException(""Could not login to FTP server"");
            }
            log(""login succeeded"", Project.MSG_VERBOSE);
            if (binary)
            {
                ftp.setFileType(com.oroinc.net.ftp.FTP.IMAGE_FILE_TYPE);
                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
                {
                    throw new BuildException(
                                             ""could not set transfer type: "" +
                                             ftp.getReplyString());
                }
            }
            if (passive)
            {
                log(""entering passive mode"", Project.MSG_VERBOSE);
                ftp.enterLocalPassiveMode();
                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
                {
                    throw new BuildException(
                                             ""could not enter into passive mode: "" +
                                             ftp.getReplyString());
                }
            }
            if (remotedir != null)
            {
                log(""changing the remote directory"", Project.MSG_VERBOSE);
                ftp.changeWorkingDirectory(remotedir);
                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode()))
                {
                    throw new BuildException(
                                             ""could not change remote directory: "" +
                                             ftp.getReplyString());
                }
            }
            log(ACTION_STRS[action] + "" files"");
            transferFiles(ftp);
        }
        catch(IOException ex)
        {
            throw new BuildException(""error during FTP transfer: "" + ex);
        }
        finally
        {
            /*
              if (ftp != null && ftp.isConnected())
              {
              try
              {
              // this hangs - I don't know why.
              ftp.disconnect();
              }
              catch(IOException ex)
              {
              // ignore it
              }
              }
            */
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.net.TelnetTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.net;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.taskdefs.MatchingTask;
import com.oroinc.net.telnet.*;
import org.apache.tools.ant.BuildException;
import java.io.*;
import java.lang.*;
import java.util.*;
/**
 * Class to provide automated telnet protocol support for the Ant build tool
 *
 * @author Scott Carlson<a href=""mailto:ScottCarlson@email.com"">ScottCarlson@email.com</a>
 * @version $Revision: 1.2 $
 */
public class TelnetTask extends Task {
    /**
     *  The userid to login with, if automated login is used
     */
    private String userid  = null;
    /**
     *  The password to login with, if automated login is used
     */
    private String password= null;
    /**
     *  The server to connect to. 
     */
    private String server  = null;
    /**
     *  The tcp port to connect to. 
     */
    private int port = 23;
    /**
     *  The Object which handles the telnet session.
     */
    private AntTelnetClient telnet = null;
    /**
     *  The list of read/write commands for this session
     */
    private Vector telnetTasks = new Vector();
    /** 
     *  If true, adds a CR to beginning of login script
     */
    private boolean addCarriageReturn = false;
    /**
     *  Default time allowed for waiting for a valid response
     *  for all child reads.  A value of 0 means no limit.
     */
    private Integer defaultTimeout = null;
    /** 
     *  Verify that all parameters are included. 
     *  Connect and possibly login
     *  Iterate through the list of Reads and writes 
     */
    public void execute() throws BuildException 
    {
       /**  A server name is required to continue */
       if (server== null)
           throw new BuildException(""No Server Specified"");
       /**  A userid and password must appear together 
        *   if they appear.  They are not required.
        */
       if (userid == null && password != null)
           throw new BuildException(""No Userid Specified"");
       if (password == null && userid != null)
           throw new BuildException(""No Password Specified"");
       /**  Create the telnet client object */
       telnet = new AntTelnetClient();
       try {
           telnet.connect(server, port);
       } catch(IOException e) {
           throw new BuildException(""Can't connect to ""+server);
       }
       /**  Login if userid and password were specified */
       if (userid != null && password != null)
          login();
       /**  Process each sub command */
       Enumeration tasksToRun = telnetTasks.elements();
       while (tasksToRun!=null && tasksToRun.hasMoreElements())
       {
           TelnetSubTask task = (TelnetSubTask) tasksToRun.nextElement();
           if (task instanceof TelnetRead && defaultTimeout != null)
               ((TelnetRead)task).setDefaultTimeout(defaultTimeout);
           task.execute(telnet);
       }
    }
    /**  
     *  Process a 'typical' login.  If it differs, use the read 
     *  and write tasks explicitely
     */
    private void login()
    {
       if (addCarriageReturn)
          telnet.sendString(""\n"", true);
       telnet.waitForString(""ogin:"");
       telnet.sendString(userid, true);
       telnet.waitForString(""assword:"");
       telnet.sendString(password, false);
    }
    /**
     *  Set the userid attribute 
     */
    public void setUserid(String u) { this.userid = u; }
    /**
     *  Set the password attribute 
     */
    public void setPassword(String p) { this.password = p; }
    /**
     *  Set the server address attribute 
     */
    public void setServer(String m) { this.server = m; }
    /**
     *  Set the tcp port to connect to attribute 
     */
    public void setPort(int p) { this.port = p; }
    /**
     *  Set the tcp port to connect to attribute 
     */
    public void setInitialCR(boolean b)
    {
       this.addCarriageReturn = b;
    }
    /**
     *  Change the default timeout to wait for 
     *  valid responses
     */
    public void setTimeout(Integer i)
    {
       this.defaultTimeout = i;
    }
    /**
     *  A subTask <read> tag was found.  Create the object, 
     *  Save it in our list, and return it.
     */
    public TelnetSubTask createRead()
    {
        TelnetSubTask task = (TelnetSubTask)new TelnetRead();
        telnetTasks.addElement(task);
        return task;
    }
    /**
     *  A subTask <write> tag was found.  Create the object, 
     *  Save it in our list, and return it.
     */
    public TelnetSubTask createWrite()
    {
        TelnetSubTask task = (TelnetSubTask)new TelnetWrite();
        telnetTasks.addElement(task);
        return task;
    }
    /**  
     *  This class is the parent of the Read and Write tasks.
     *  It handles the common attributes for both.
     */
    public class TelnetSubTask
    {
        protected String taskString= """";
        public void execute(AntTelnetClient telnet) 
                throws BuildException
        {
            throw new BuildException(""Shouldn't be able instantiate a SubTask directly"");
        }
        public void addText(String s) { setString(s);}
        public void setString(String s)
        {
           taskString += s; 
        }
    }
    /**
     *  This class sends text to the connected server 
     */
    public class TelnetWrite extends TelnetSubTask
    {
        private boolean echoString = true;
        public void execute(AntTelnetClient telnet) 
               throws BuildException
        {
           telnet.sendString(taskString, echoString);
        }
        public void setEcho(boolean b)
        {
           echoString = b;
        }
    }
    /**
     *  This class reads the output from the connected server
     *  until the required string is found. 
     */
    public class TelnetRead extends TelnetSubTask
    {
        private Integer timeout = null;
        public void execute(AntTelnetClient telnet) 
               throws BuildException
        {
            telnet.waitForString(taskString, timeout);
        }
        /**
         *  Override any default timeouts
         */
        public void setTimeout(Integer i)
        {
           this.timeout = i;
        }
        /**
         *  Sets the default timeout if none has been set already
         */
        public void setDefaultTimeout(Integer defaultTimeout)
        {
           if (timeout == null)
              timeout = defaultTimeout;
    }
    }
    /**
     *  This class handles the abstraction of the telnet protocol.
     *  Currently it is a wrapper around <a href=""www.oroinc.com"">ORO</a>'s 
     *  NetComponents
     */
    public class AntTelnetClient extends TelnetClient
    {
      /**
       * Read from the telnet session until the string we are 
       * waiting for is found 
       * @parm s The string to wait on 
       */
      public void waitForString(String s)
      {
           waitForString(s, null);
      }
      /**
       * Read from the telnet session until the string we are 
       * waiting for is found or the timeout has been reached
       * @parm s The string to wait on 
       * @parm timeout The maximum number of seconds to wait
       */
      public void waitForString(String s, Integer timeout)
      {
        InputStream is =this.getInputStream();
        try {
          StringBuffer sb = new StringBuffer();
          if (timeout == null || timeout.intValue() == 0)
          {
              while (sb.toString().indexOf(s) == -1)
                  {
                      sb.append((char) is.read());
                  }
          }
          else
          {
              Calendar endTime = Calendar.getInstance(); 
              endTime.add(Calendar.SECOND,timeout.intValue());
              while ( sb.toString().indexOf(s) == -1)
              {
                  while (Calendar.getInstance().before(endTime) &&
                         is.available() == 0) {
                      Thread.sleep(250);
                  }
                  if (is.available() == 0)
                      throw new BuildException(""Response Timed-Out"", getLocation());
                  sb.append((char) is.read());
              }
          }
          log(sb.toString(), Project.MSG_INFO);
        } catch (BuildException be)
        { 
            throw be;
        } catch (Exception e)
        { 
            throw new BuildException(e, getLocation());
        }
      }
      /**
       * Write this string to the telnet session.
       * @parm echoString  Logs string sent
       */
      public void sendString(String s, boolean echoString)
      {
        OutputStream os =this.getOutputStream();
        try {
          os.write((s + ""\n"").getBytes());
          if (echoString)
              log(s, Project.MSG_INFO);
          os.flush();
        } catch (Exception e)
        { 
          throw new BuildException(e, getLocation());
        }
      }
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Base,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import java.io.*;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.*;
import org.apache.tools.ant.types.*;
import org.apache.oro.text.perl.*;
/** Base class for Perforce (P4) ANT tasks. See individual task for example usage.
 *
 * @see P4Sync
 * @see P4Have
 * @see P4Change
 * @see P4Edit
 * @see P4Submit
 * @see P4Label
 * @see org.apache.tools.ant.taskdefs.Exec
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public abstract class P4Base extends org.apache.tools.ant.Task {
    /**Perl5 regexp in Java - cool eh? */
    protected Perl5Util util = null;
    /** The OS shell to use (cmd.exe or /bin/sh) */
    protected String shell;
    //P4 runtime directives
    /** Perforce Server Port (eg KM01:1666) */
    protected String P4Port     = """";
    /** Perforce Client (eg myclientspec) */
    protected String P4Client   = """";
    /** Perforce User (eg fbloggs) */
    protected String P4User     = """";
    /** Perforce view for commands (eg //projects/foobar/main/source/... )*/
    protected String P4View     = """";
    //P4 g-opts and cmd opts (rtfm)
    /** Perforce 'global' opts.
      * Forms half of low level API */
    protected String P4Opts     = """";
    /** Perforce command opts.
      * Forms half of low level API */
    protected String P4CmdOpts  = """";
    //Setters called by Ant
    public void setPort(String P4Port)        { this.P4Port       =   ""-p""+P4Port;    }
    public void setClient(String P4Client)    { this.P4Client     =   ""-c""+P4Client;  }
    public void setUser(String P4User)        { this.P4User       =   ""-u""+P4User;    }
    public void setView(String P4View)        { this.P4View       =   P4View;         }
    public void setCmdopts(String P4CmdOpts)  { this.P4CmdOpts    =   P4CmdOpts;      }
    public void init() {
        util = new Perl5Util();
    	//Get default P4 settings from environment - Mark would have done something cool with
	    //introspection here.....:-)
	    String tmpprop;
        if((tmpprop = project.getProperty(""p4.port"")) != null) setPort(tmpprop);
        if((tmpprop = project.getProperty(""p4.client"")) != null) setClient(tmpprop);
        if((tmpprop = project.getProperty(""p4.user"")) != null) setUser(tmpprop);	
    }
    protected void execP4Command(String command) throws BuildException {
        execP4Command(command, null);
    }
    /** Execute P4 command assembled by subclasses.
	@param command The command to run
	@param p4input Input to be fed to command on stdin
	@param handler A P4Handler to process any input and output
    */
    protected void execP4Command(String command, P4Handler handler) throws BuildException {
        try{
            Commandline commandline = new Commandline();
            commandline.setExecutable(""p4"");
            //Check API for these - it's how CVS does it...
            commandline.createArgument().setValue(P4Port);
            commandline.createArgument().setValue(P4User);
            commandline.createArgument().setValue(P4Client);
            commandline.createArgument().setLine(command);
	        log(""Execing ""+commandline.getCommandline(), Project.MSG_VERBOSE);
            if(handler == null ) handler = new SimpleP4OutputHandler(this);
            Execute exe = new Execute(handler, null);
            exe.setAntRun(project);
            exe.setCommandline(commandline.getCommandline());
            try{
             exe.execute();
            }catch(IOException e) {
                throw new BuildException(e);
            } finally {
                try{
                    handler.stop();
                }catch(Exception e) {}
            }
	    }catch(Exception e) {
	        throw new BuildException(""Problem exec'ing P4 command: ""+e.getMessage());
	    }
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Change,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import java.io.*;
import org.apache.tools.ant.*;
/** P4Change - grab a new changelist from Perforce.
 *
 * P4Change creates a new changelist in perforce. P4Change sets the property
 * ${p4.change} with the new changelist number. This should then be passed into
 * p4edit and p4submit.
 *
 * @see P4Edit
 * @see P4Submit
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 *
 */
public class P4Change extends P4Base {
	protected String emptyChangeList = null;
    public void execute() throws BuildException {
        if(emptyChangeList == null) emptyChangeList = getEmptyChangeList();
        final Project myProj = project;
        P4Handler handler = new P4HandlerAdapter() {
            public void process(String line) {
                if (util.match(""/Change/"", line)) {
                    //Remove any non-numerical chars - should leave the change number
   	        		line = util.substitute(""s/[^0-9]//g"", line);
   			       	int changenumber = Integer.parseInt(line);
   			        log(""Change Number is ""+changenumber, Project.MSG_INFO);
				    myProj.setProperty(""p4.change"", """"+changenumber);
       			} else if(util.match(""/error/"", line)) {
   	    		    throw new BuildException(""Perforce Error, check client settings and/or server"");
       			}
   	        }};
        handler.setOutput(emptyChangeList);
        execP4Command(""change -i"", handler);
    }
    public String getEmptyChangeList() throws BuildException {
        final StringBuffer stringbuf = new StringBuffer();
        execP4Command(""change -o"", new P4HandlerAdapter() {
            public void process(String line) {
        	    if(!util.match(""/^#/"",line)){
                    if(util.match(""/error/"", line)) {
   			            log(""Client Error"", Project.MSG_VERBOSE);
   			            throw new BuildException(""Perforce Error, check client settings and/or server"");
           			} else if(util.match(""/<enter description here>/"",line)) {
                        line = util.substitute(""s/<enter description here>/AutoSubmit By Ant/"", line);
			        } else if(util.match(""/\\/\\//"", line)) {
			            //Match ""//"" for begining of depot filespec
			    	    return;
				    }
    				stringbuf.append(line);
	    			stringbuf.append(""\n"");
		    	}
    		}});
    	   	return stringbuf.toString();
    }
} //EoF
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Edit,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
/** P4Edit - checkout file(s) for edit.
 *
 * Example Usage:<br>
 * &lt;p4edit change=""${p4.change}"" view=""//depot/project/foo.txt"" /&gt;
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 *
 * ToDo: Should call reopen if file is already open in one of our changelists perhaps?
 */
 public class P4Edit extends P4Base {
     public String change = null;
     public void setChange(String change) {
             this.change = change;
	 }
     public void execute() throws BuildException {
         if(change != null ) P4CmdOpts = ""-c ""+change;
	     if(P4View == null) throw new BuildException(""No view specified to edit"");
         execP4Command(""-s edit ""+P4CmdOpts+"" ""+P4View, new SimpleP4OutputHandler(this));
	 }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Handler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
/** Interface for p4 job output stream handler. Classes implementing this interface
 * can be called back by P4Base.execP4Command();
 *
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public interface P4Handler extends ExecuteStreamHandler {
    public void process(String line) throws BuildException;
    public void setOutput(String line) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4HandlerAdapter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import java.io.*;
import org.apache.tools.ant.*;
public abstract class P4HandlerAdapter implements P4Handler {
    public abstract void process(String line);
    String p4input = """";
    //set any data to be written to P4's stdin - messy, needs work
    public void setOutput(String p4Input) {
        this.p4input = p4Input;
    }
    public void start() throws BuildException {
    try{
        //First write any output to P4 
        if(p4input != null && p4input.length() >0 && os != null) {
                    os.write(p4input.getBytes());
                    os.flush();
                    os.close();
            }
        //Now read any input and process
        BufferedReader input = new BufferedReader(
                                     new InputStreamReader(
                                       new SequenceInputStream(is,es)));
            String line;
	    	while((line = input.readLine()) != null) {
	    	   process(line);
	    	}
	    	input.close();
        }catch(Exception e) {
            throw new BuildException(e);
        }
    }
    OutputStream os;    //OUtput
    InputStream is;     //Input
    InputStream es;     //Error
    public void setProcessInputStream(OutputStream os) throws IOException {
        this.os = os;
    }
    public void setProcessErrorStream(InputStream is) throws IOException {
        this.es = is;
    }
    public void setProcessOutputStream(InputStream is) throws IOException {
        this.is = is;
    }
    public void stop(){}
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Have,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
/** P4Have - lists files currently on client.
 * 
 * P4Have simply dumps the current file version info into
 * the Ant log (or stdout).
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public class P4Have extends P4Base {
    public void execute() throws BuildException {
        execP4Command(""have ""+P4CmdOpts+"" ""+P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Label,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
import java.util.Date;
import java.text.SimpleDateFormat;
/** P4Label - create a Perforce Label.
 *
 *  P4Label inserts a label into perforce reflecting the
 *  current client contents.
 *
 *  Label name defaults to AntLabel if none set.
 *
 * Example Usage: <P4Label name=""MyLabel-${TSTAMP}-${DSTAMP}"" desc=""Auto Build Label"" />
 *
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public class P4Label extends P4Base {
    protected String name;
    protected String desc;
    public void setName(String name) {
        this.name = name;
    }
    public void setDesc(String desc) {
        this.desc = desc;
    }
    public void execute() throws BuildException {
        log(""P4Label exec:"",Project.MSG_INFO);
        if(P4View == null || P4View.length() < 1) {
            log(""View not set, assuming //depot/..."", Project.MSG_WARN);
            P4View = ""//depot/..."";
        }
        if(desc == null || desc.length() < 1) {
            log(""Label Description not set, assuming 'AntLabel'"", Project.MSG_WARN);
            desc = ""AntLabel"";
        }
        if(name == null || name.length() < 1) {
            SimpleDateFormat formatter = new SimpleDateFormat (""yyyy.MM.dd-hh:mm"");
            Date now = new Date();
            name = ""AntLabel-""+formatter.format(now);
            log(""name not set, assuming '""+name+""'"", Project.MSG_WARN);
        }
        String newLabel = 
            ""Label: ""+name+""\n""+
            ""Description: ""+desc+""\n""+
            ""Options: unlocked\n""+
            ""View: ""+P4View+""\n"";
        P4Handler handler = new P4HandlerAdapter() {
            public void process(String line) {
                log(line, Project.MSG_VERBOSE);
            }
        };
        handler.setOutput(newLabel);
        execP4Command(""label -i"", handler);
        execP4Command(""labelsync -l ""+name, new P4HandlerAdapter() {
            public void process(String line) {
                log(line, Project.MSG_VERBOSE);
            }
        });
        log(""Created Label ""+name+"" (""+desc+"")"", Project.MSG_INFO);
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4OutputHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.BuildException;
/** Interface for p4 job output stream handler. Classes implementing this interface
 * can be called back by P4Base.execP4Command();
 *
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public interface P4OutputHandler {
    public void process(String line) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Submit,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
/** P4Submit - submit a numbered changelist to Perforce.
 *
 * <B>Note:</B> P4Submit cannot (yet) submit the default changelist. 
 * This shouldn't be a problem with the ANT API as the usual flow is 
 * P4Change to create a new numbered change followed by P4Edit then P4Submit.
 *
 * Example Usage:-<br>
 * &lt;p4submit change=""${p4.change}"" /&gt;
 *
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 *
 */
public class P4Submit extends P4Base {
    //ToDo: If dealing with default cl need to parse out <enter description here>    
    public String change;
    public void setChange(String change) {
        this.change = change;
	}
    public void execute() throws BuildException {
        if(change != null) {
	        execP4Command(""submit -c ""+change, new P4HandlerAdapter(){
		            public void process(String line) {
			            log(line, Project.MSG_VERBOSE);
				    }
		    });
	    } else {
	    //here we'd parse the output from change -o into submit -i 
	    //in order to support default change.
	    throw new BuildException(""No change specified (no support for default change yet...."");
    	}
	}
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Sync,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
/** P4Sync  - synchronise client space to a perforce depot view.
 *  The API allows additional functionality of the ""p4 sync"" command 
 * (such as ""p4 sync -f //...#have"" or other exotic invocations).</P>
 *
 * <b>Example Usage:</b>
 * <table border=""1"">
 * <th>Function</th><th>Command</th>
 * <tr><td>Sync to head using P4USER, P4PORT and P4CLIENT settings specified</td><td>&lt;P4Sync <br>P4view=""//projects/foo/main/source/..."" <br>P4User=""fbloggs"" <br>P4Port=""km01:1666"" <br>P4Client=""fbloggsclient"" /&gt;</td></tr>
 * <tr><td>Sync to head using P4USER, P4PORT and P4CLIENT settings defined in environment</td><td>&lt;P4Sync P4view=""//projects/foo/main/source/..."" /&gt;</td></tr>
 * <tr><td>Force a re-sync to head, refreshing all files</td><td>&lt;P4Sync force=""yes"" P4view=""//projects/foo/main/source/..."" /&gt;</td></tr>
 * <tr><td>Sync to a label</td><td>&lt;P4Sync label=""myPerforceLabel"" /&gt;</td></tr>
 * </table>
 *
 * ToDo:  Add decent label error handling for non-exsitant labels
 *
 * @author <A HREF=""mailto:leslie.hughes@rubus.com"">Les Hughes</A>
 */
public class P4Sync extends P4Base {
    String label;
    private String syncCmd = """";
    public void setLabel(String label) throws BuildException { 
        if(label == null && !label.equals(""""))
                throw new BuildException(""P4Sync: Labels cannot be Null or Empty"");
        this.label = label;
    }
    public void setForce(String force) throws BuildException {
        if(force == null && !label.equals(""""))
                throw new BuildException(""P4Sync: If you want to force, set force to non-null string!"");
            P4CmdOpts = ""-f"";
        }
    public void execute() throws BuildException {
        if (P4View != null) {
                syncCmd = P4View;
        }
        if(label != null && !label.equals("""")) {
                syncCmd = syncCmd + ""@"" + label;
        } 
        log(""Execing sync ""+P4CmdOpts+"" ""+syncCmd, Project.MSG_VERBOSE);
        execP4Command(""-s sync ""+P4CmdOpts+"" ""+syncCmd, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.SimpleP4OutputHandler,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.*;
public class SimpleP4OutputHandler extends P4HandlerAdapter {
	P4Base parent;
	public SimpleP4OutputHandler(P4Base parent) {
		this.parent = parent;
	}
	public void process(String line) throws BuildException {
		if(parent.util.match(""/^exit/"",line)) return;
		//Throw exception on errors (except up-to-date)
		//p4 -s is unpredicatable. For example a server down
		//does not return error: markup
		//
		//Some forms producing commands (p4 -s change -o) do tag the output
		//others don't.....
		//Others mark errors as info, for example edit a file
		//which is already open for edit.....
		//Just look for error: - catches most things....
		if(parent.util.match(""/error:/"", line) && !parent.util.match(""/up-to-date/"", line)) {
			throw new BuildException(line);
		} 
		parent.log(parent.util.substitute(""s/^.*: //"",line), Project.MSG_INFO);
	}
}
"
org.apache.tools.ant.taskdefs.optional.scm.AntStarTeamCheckOut,"/* 
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 */
package org.apache.tools.ant.taskdefs.optional.scm; 
import com.starbase.starteam.*;
import com.starbase.util.Platform;
import java.io.*;
import java.util.*;
import org.apache.tools.ant.*;
/**
 * Checks out files from a specific StarTeam server, project, view, and
 * folder.
 * <BR><BR>
 * This program logs in to a StarTeam server and opens up the specified
 * project and view.  Then, it searches through that view for the given
 * folder (or, if you prefer, it uses the root folder).  Beginning with
 * that folder and optionally continuing recursivesly, AntStarTeamCheckOut
 * compares each file with your include and exclude filters and checks it
 * out only if appropriate.
 * <BR><BR>
 * Checked out files go to a directory you specify under the subfolder
 * named for the default StarTeam path to the view.  That is, if you
 * entered /home/cpovirk/work as the target folder, your project was named
 * ""OurProject,"" the given view was named ""TestView,"" and that view is
 * stored by default at ""C:\projects\Test,"" your files would be checked
 * out to /home/cpovirk/work/Test.""  I avoided using the project name in
 * the path because you may want to keep several versions of the same
 * project on your computer, and I didn't want to use the view name, as
 * there may be many ""Test"" or ""Version 1.0"" views, for example.  This
 * system's success, of course, depends on what you set the default path
 * to in StarTeam.
 * <BR><BR>
 * You can set AntStarTeamCheckOut to verbose or quiet mode.  Also, it has
 * a safeguard against overwriting the files on your computer:  If the
 * target directory you specify already exists, the program will throw a
 * BuildException.  To override the exception, set <CODE>force</CODE> to
 * true.
 * <BR><BR>
 * <B>This program makes use of functions from the StarTeam API.  As a result
 * AntStarTeamCheckOut is available only to licensed users of StarTeam and
 * requires the StarTeam SDK to function.  You must have
 * <CODE>starteam-sdk.jar</CODE> in your classpath to run this program.
 * For more information about the StarTeam API and how to license it, see
 * the link below.</B>
 *
 * @author <A HREF=""mailto:chris.povirk@paytec.com"">Chris Povirk</A>
 * @author <A HREF=""mailto:jc.mann@paytec.com"">JC Mann</A>
 * @author <A HREF=""mailto:jeff.gettle@paytec.com"">Jeff Gettle</A>
 * @version 1.0
 * @see <A HREF=""http://www.starbase.com/"">StarBase Web Site</A>
 */
public class AntStarTeamCheckOut extends org.apache.tools.ant.Task 
{
    /**
     * By default, <CODE>force</CODE> is set to ""false"" through this field.
     * If you set <CODE>force</CODE> to ""true,"" AntStarTeamCheckOut will
     * overwrite files in the target directory. If the target directory does
     * not exist, the <CODE>force</CODE> setting does nothing. Note that
     * <CODE>DEFAULT_FORCESETTING</CODE> and <CODE>force</CODE> are strings,
     * not boolean values. See the links below for more information.
     * 
     * @see #getForce()
     * @see #getForceAsBoolean()
     * @see #setForce(String force)
     */
    static public final String DEFAULT_FORCESETTING = ""false"";
    /**
     * This field is used in setting <CODE>verbose</CODE> to ""false"", the
     * default. If <CODE>verbose</CODE> is true, AntStarTeamCheckOut will
     * display file and directory names as it checks files out. The default
     * setting displays only a total. Note that
     * <CODE>DEFAULT_VERBOSESETTING</CODE> and <CODE>verbose</CODE> are
     * strings, not boolean values. See the links below for more
     * information.
     * 
     * @see #getVerbose()
     * @see #getVerboseAsBoolean()
     * @see #setVerbose(String verbose)
     */
    static public final String DEFAULT_VERBOSESETTING = ""false"";
    /**
     * <CODE>DEFAULT_RECURSIONSETTING</CODE> contains the normal setting --
     * true -- for recursion.  Thus, if you do not
     * <CODE>setRecursion(""false"")</CODE> somewhere in your program,
     * AntStarTeamCheckOut will check files out from all subfolders as well
     * as from the given folder.
     * 
     * @see #getRecursion()
     * @see #setRecursion(String recursion)
     */
    static public final String DEFAULT_RECURSIONSETTING = ""true"";
    /**
     * This constant sets the filter to include all files. This default has
     * the same result as <CODE>setIncludes(""*"")</CODE>.
     * 
     * @see #getIncludes()
     * @see #setIncludes(String includes)
     */
    static public final String DEFAULT_INCLUDESETTING = ""*"";
    /**
     * This disables the exclude filter by default. In other words, no files
     * are excluded. This setting is equivalent to
     * <CODE>setExcludes(null)</CODE>.
     * 
     * @see #getExcludes()
     * @see #setExcludes(String excludes)
     */
    static public final String DEFAULT_EXCLUDESETTING = null;
    /**
     * The default folder to search; the root folder.  Since
     * AntStarTeamCheckOut searches subfolders, by default it processes an
     * entire view.
     * 
     * @see #getFolderName()
     * @see #setFolderName(String folderName)
     */
    static public final String DEFAULT_FOLDERSETTING = null;
    /**
     * This is used when formatting the output. The directory name is
     * displayed only when it changes.
     */
    private Folder prevFolder = null;
    /**
     * This field keeps count of the number of files checked out.
     */
    private int checkedOut;
    // Change these through their GET and SET methods.
    /**
     * The name of the server you wish to connect to.
     */
    private String serverName = null;
    /**
     * The port on the server used for StarTeam.
     */
    private String serverPort = null;
    /**
     * The name of your project.
     */
    private String projectName = null;
    /**
     * The name of the folder you want to check out files from. All
     * subfolders will be searched, as well.
     */
    private String folderName = DEFAULT_FOLDERSETTING;
    /**
     * The view that the files you want are in.
     */
    private String viewName = null;
    /**
     * Your username on the StarTeam server.
     */
    private String username = null;
    /**
     * Your StarTeam password.
     */
    private String password = null;
    /**
     * The path to the root folder you want to check out to. This is a local
     * directory.
     */
    private String targetFolder = null;
    /**
     * If force set to true, AntStarTeamCheckOut will overwrite files in the
     * target directory.
     */
    private String force = DEFAULT_FORCESETTING;
    /**
     * When verbose is true, the program will display all files and
     * directories as they are checked out.
     */
    private String verbose = DEFAULT_VERBOSESETTING;
    /**
     * Set recursion to false to check out files in only the given folder
     * and not in its subfolders.
     */
    private String recursion = DEFAULT_RECURSIONSETTING;
    // These fields deal with includes and excludes
    /**
     * All files that fit this pattern are checked out.
     */
    private String includes = DEFAULT_INCLUDESETTING;
    /**
     * All files fitting this pattern are ignored.
     */
    private String excludes = DEFAULT_EXCLUDESETTING;
    /**
     * The file delimitor on the user's system.
     */
    private String delim = Platform.getFilePathDelim();
    /**
     * Do the execution.
     * 
     * @exception BuildException
     */
    public void execute() throws BuildException
    {
        // Check all of the properties that are required.
        if ( getServerName() == null )
        {
            project.log(""ServerName must not be null."");
            return;
        }
        if ( getServerPort() == null )
        {
            project.log(""ServerPort must not be null."");
            return;
        }
        if ( getProjectName() == null )
        {
            project.log(""ProjectName must not be null."");
            return;
        }
        if ( getViewName() == null )
        {
            project.log(""ViewName must not be null."");
            return;
        }
        if ( getUsername() == null )
        {
            project.log(""Username must not be null."");
            return;
        }
        if ( getPassword() == null )
        {
            project.log(""Password must not be null."");
            return;
        }
        if ( getTargetFolder() == null )
        {
            project.log(""TargetFolder must not be null."");
            return;
        }
        // Because of the way I create the full target path, there
        // must be NO slash at the end of targetFolder and folderName
        // However, if the slash or backslash is the only character, leave it alone
        if (null != getTargetFolder())
        {
            if ((getTargetFolder().endsWith(""/"") || 
                 getTargetFolder().endsWith(""\\"")) && getTargetFolder().length() > 1)
            {
                setTargetFolder(getTargetFolder().substring(0, getTargetFolder().length() - 1));
            }
        }
        if ( null != getFolderName() )
        {
            if ((getFolderName().endsWith(""/"") || 
                 getFolderName().endsWith(""\\"")) && getFolderName().length() > 1)
            {
                setFolderName(getFolderName().substring(0, getFolderName().length() - 1));
            }
        }
        // Check to see if the target directory exists.
        java.io.File dirExist = new java.io.File(getTargetFolder());
        if (dirExist.isDirectory() && !getForceAsBoolean())
        {
            project.log( ""Target directory exists. Set \""force\"" to \""true\"" "" +
                         ""to continue anyway."" );
            return;
        }
        try
        {
            // Connect to the StarTeam server, and log on.
            Server s = getServer();
            // Search the items on this server.
            runServer(s);
            // Disconnect from the server.
            s.disconnect();
            // after you are all of the properties are ok, do your thing
            // with StarTeam.  If there are any kind of exceptions then
            // send the message to the project log.
            // Tell how many files were checked out.
            project.log(checkedOut + "" files checked out."");
        }
        catch (Throwable e)
        {
            project.log(""    "" + e.getMessage());
        }
    }
    /**
     * Creates and logs in to a StarTeam server.
     * 
     * @return A StarTeam server.
     */
    protected Server getServer()
    {
        // Simplest constructor, uses default encryption algorithm and compression level.
        Server s = new Server(getServerName(), getServerPortAsInt());
        // Optional; logOn() connects if necessary.
        s.connect();
        // Logon using specified user name and password.
        s.logOn(getUsername(), getPassword());
        return s;
    }
    /**
     * Searches for the specified project on the server.
     * 
     * @param s      A StarTeam server.
     */
    protected void runServer(Server s)
    {
        com.starbase.starteam.Project[] projects = s.getProjects();
        for (int i = 0; i < projects.length; i++)
        {
            com.starbase.starteam.Project p = projects[i];
            if (p.getName().equals(getProjectName()))
            {
                if (getVerboseAsBoolean())
                {
                    project.log(""Found "" + getProjectName() + delim);
                }
                runProject(s, p);
                break;
            }
        }
    }
    /**
     * Searches for the given view in the project.
     * 
     * @param s      A StarTeam server.
     * @param p      A valid project on the given server.
     */
    protected void runProject(Server s, com.starbase.starteam.Project p)
    {
        View[] views = p.getViews();
        for (int i = 0; i < views.length; i++)
        {
            View v = views[i];
            if (v.getName().equals(getViewName()))
            {
                if (getVerboseAsBoolean())
                {
                    project.log(""Found "" + getProjectName() + delim + getViewName() + delim);
                }
                runType(s, p, v, s.typeForName((String)s.getTypeNames().FILE));
                break;
            }
        }
    }
    /**
     * Searches for folders in the given view.
     * 
     * @param s      A StarTeam server.
     * @param p      A valid project on the server.
     * @param v      A view name from the specified project.
     * @param t      An item type which is currently always ""file"".
     */
    protected void runType(Server s, com.starbase.starteam.Project p, View v, Type t)
    {
        // This is ugly; checking for the root folder.
        Folder f = v.getRootFolder();
        if (!(getFolderName()==null))
        {
            if (getFolderName().equals(""\\"") || getFolderName().equals(""/""))
            {
                setFolderName(null);
            }
            else
            {
                f = StarTeamFinder.findFolder(v.getRootFolder(), getFolderName());
            }
        }
        if (getVerboseAsBoolean() && !(getFolderName()==null))
        {
            project.log( ""Found "" + getProjectName() + delim + getViewName() + 
                         delim + getFolderName() + delim + ""\n"" );
        }
        // For performance reasons, it is important to pre-fetch all the
        // properties we'll need for all the items we'll be searching.
        // We always display the ItemID (OBJECT_ID) and primary descriptor.
        int nProperties = 2;
        // We'll need this item type's primary descriptor.
        Property p1 = getPrimaryDescriptor(t);
        // Does this item type have a secondary descriptor?
        // If so, we'll need it.
        Property p2 = getSecondaryDescriptor(t);
        if (p2 != null)
        {
            nProperties++;
        }
        // Now, build an array of the property names.
        String[] strNames = new String[nProperties];
        int iProperty = 0;
        strNames[iProperty++] = s.getPropertyNames().OBJECT_ID;
        strNames[iProperty++] = p1.getName();
        if (p2 != null)
        {
            strNames[iProperty++] = p2.getName();
        }
        // Pre-fetch the item properties and cache them.
        f.populateNow(t.getName(), strNames, -1);
        // Now, search for items in the selected folder.
        runFolder(s, p, v, t, f);
        // Free up the memory used by the cached items.
        f.discardItems(t.getName(), -1);
    }
    /**
     * Searches for files in the given folder.  This method is recursive and
     * thus searches all subfolders.
     * 
     * @param s      A StarTeam server.
     * @param p      A valid project on the server.
     * @param v      A view name from the specified project.
     * @param t      An item type which is currently always ""file"".
     * @param f      The folder to search.
     */
    protected void runFolder( Server s, 
                              com.starbase.starteam.Project p, 
                              View v, 
                              Type t, 
                              Folder f )
    {
        // Process all items in this folder.
        Item[] items = f.getItems(t.getName());
        for (int i = 0; i < items.length; i++)
        {
            runItem(s, p, v, t, f, items[i]);
        }
        // Process all subfolders recursively if recursion is on.
        if (getRecursionAsBoolean())
        {
            Folder[] subfolders = f.getSubFolders();
            for (int i = 0; i < subfolders.length; i++)
            {
                runFolder(s, p, v, t, subfolders[i]);
            }
        }
    }
    /**
     * Check out one file if it matches the include filter but not the
     * exclude filter.
     * 
     * @param s      A StarTeam server.
     * @param p      A valid project on the server.
     * @param v      A view name from the specified project.
     * @param t      An item type which is currently always ""file"".
     * @param f      The folder the file is localed in.
     * @param item   The file to check out.
     */
    protected void runItem( Server s, 
                            com.starbase.starteam.Project p, 
                            View v, 
                            Type t, 
                            Folder f, 
                            Item item )
    {
        // Get descriptors for this item type.
        Property p1 = getPrimaryDescriptor(t);
        Property p2 = getSecondaryDescriptor(t);
        // Time to filter...
        String pName = (String)item.get(p1.getName());
        boolean includeIt = false;
        boolean excludeIt = false;
        // See if it fits any includes.
        if (getIncludes()!=null)
        {
            StringTokenizer inStr = new StringTokenizer(getIncludes(), "" "");
            while (inStr.hasMoreTokens())
            {
                if (match(inStr.nextToken(), pName))
                {
                    includeIt = true;
                }
            }
        }
        // See if it fits any excludes.
        if (getExcludes()!=null)
        {
            StringTokenizer exStr = new StringTokenizer(getExcludes(), "" "");
            while (exStr.hasMoreTokens())
            {
                if (match(exStr.nextToken(), pName))
                {
                    excludeIt = true;
                }
            }
        }
        // Don't check it out if
        // (a) It fits no include filters
        // (b) It fits an exclude filter
        if (!includeIt | excludeIt)
        {
            return;
        }
        // VERBOSE MODE ONLY
        if (getVerboseAsBoolean())
        {
            // Show folder only if changed.
            boolean bShowHeader = true;
            if (f != prevFolder)
            {
                // We want to display the folder the same way you would
                // enter it on the command line ... so we remove the 
                // View name (which is also the name of the root folder,
                // and therefore shows up at the start of the path).
                String strFolder = f.getFolderHierarchy();
                int i = strFolder.indexOf(delim);
                if (i >= 0)
                {
                    strFolder = strFolder.substring(i+1);
                }
                System.out.println(""            Folder: \"""" + strFolder + ""\"""");
                prevFolder = f;
            }
            else
                bShowHeader        = false;
            // If we displayed the project, view, item type, or folder,
            // then show the list of relevant item properties.
            if (bShowHeader)
            {
                System.out.print(""                Item"");
                System.out.print("",\t"" + p1.getDisplayName());
                if (p2 != null)
                {
                    System.out.print("",\t"" + p2.getDisplayName());
                }
                System.out.println("""");
            }
            // Finally, show the Item properties ...
            // Always show the ItemID.
            System.out.print(""                "" + item.getItemID());
            // Show the primary descriptor.
            // There should always be one.
            System.out.print("",\t"" + formatForDisplay(p1, item.get(p1.getName())));
            // Show the secondary descriptor, if there is one.
            // Some item types have one, some don't.
            if (p2 != null)
            {
                System.out.print("",\t"" + formatForDisplay(p2, item.get(p2.getName())));
            }
            // Show if the file is locked.
            int locker = item.getLocker();
            if (locker>-1)
            {
                System.out.println("",\tLocked by "" + locker);
            }
            else
            {
                System.out.println("",\tNot locked"");
            }
        }
        // END VERBOSE ONLY
        // Check it out; also ugly.
        // Change the item to be checked out to a StarTeam File.
        com.starbase.starteam.File remote = (com.starbase.starteam.File)item;
        // Create a variable dirName that contains the name of 
        //the StarTeam folder that is the root folder in this view.
        // Get the default path to the current view.
        String dirName = v.getDefaultPath();
        // Settle on ""/"" as the default path separator for this purpose only.
        dirName = dirName.replace('\\', '/');
        // Take the StarTeam folder name furthest down in the hierarchy.
        int endDirIndex = dirName.length();
        // If it ends with separator then strip it off
        if (dirName.endsWith(""/""))
        {
            // This should be the SunOS and Linux case
            endDirIndex--;
        }
        dirName = 
            dirName.substring(dirName.lastIndexOf(""/"", dirName.length() - 2) + 1, endDirIndex);
        // Replace the projectName in the file's absolute path to the viewName.
        // This eventually makes the target of a checkout operation equal to:
        // targetFolder + dirName + [subfolders] + itemName
        StringTokenizer pathTokenizer = 
            new StringTokenizer(item.getParentFolder().getFolderHierarchy(), delim);
        String localName = delim;
        String currentToken = null;
        while (pathTokenizer.hasMoreTokens())
        {
            currentToken = pathTokenizer.nextToken();
            if (currentToken.equals(getProjectName()))
            {
                currentToken = dirName;
            }
            localName += currentToken + delim;
        }
        // Create a reference to the local target file using the format listed above.
        java.io.File local = new java.io.File( getTargetFolder() + localName + 
                                               item.get(p1.getName()) );
        try
        {
            remote.checkoutTo(local, Item.LockType.UNCHANGED, false, true, true);
        }
        catch (Throwable e)
        {
            project.log(""    "" + e.getMessage());
        }
        checkedOut++;
    }
    /**
     * Get the primary descriptor of the given item type.
     *  Returns null if there isn't one.
     *  In practice, all item types have a primary descriptor.
     * 
     * @param t      An item type. At this point it will always be ""file"".
     * @return The specified item's primary descriptor.
     */
    protected Property getPrimaryDescriptor(Type t)
    {
        Property[] properties = t.getProperties();
        for (int i = 0; i < properties.length; i++)
        {
            Property p = properties[i];
            if (p.isPrimaryDescriptor())
            {
                return p;
            }
        }
        return null;
    }
    /**
     * Get the secondary descriptor of the given item type.
     * Returns null if there isn't one.
     * 
     * @param t      An item type. At this point it will always be ""file"".
     * @return The specified item's secondary descriptor. There may not be
     *         one for every file.
     */
    protected Property getSecondaryDescriptor(Type t)
    {
        Property[] properties = t.getProperties();
        for (int i = 0; i < properties.length; i++)
        {
            Property p = properties[i];
            if (p.isDescriptor() && !p.isPrimaryDescriptor())
            {
                return p;
            }
        }
        return null;
    }
    /**
     * Formats a property value for display to the user.
     * 
     * @param p      An item property to format.
     * @param value
     * @return A string containing the property, which is truncated to 35
     *         characters for display.
     */
    protected String formatForDisplay(Property p, Object value)
    {
        if (p.getTypeCode() == Property.Types.TEXT)
        {
            String str = value.toString();
            if (str.length() > 35)
            {
                str = str.substring(0, 32) + ""..."";
            }
            return ""\"""" + str + ""\"""";
        }
        else
        {
            if (p.getTypeCode() == Property.Types.ENUMERATED)
            {
                return ""\"""" + p.getEnumDisplayName(((Integer)value).intValue()) + ""\"""";
            }
            else
            {
                return value.toString();
            }
        }
    }
    // TORN STRAIGHT FROM ANT.DIRECTORYSCANNER
    /**
     * <B>TORN STRAIGHT FROM ANT.DIRECTORYSCANNER</B>
     * 
     * Matches a string against a pattern. The pattern contains two special
     * characters:<BR>
     * '*' which means zero or more characters,<BR>
     * '?' which means one and only one character.
     * 
     * @param pattern the (non-null) pattern to match against
     * @param str     the (non-null) string that must be matched against the
     *                pattern
     * @return <code>true</code> when the string matches against the
     *         pattern, <code>false</code> otherwise.
     */
    private static boolean match(String pattern, String str)
    {
        char[] patArr = pattern.toCharArray();
        char[] strArr = str.toCharArray();
        int patIdxStart = 0;
        int patIdxEnd   = patArr.length-1;
        int strIdxStart = 0;
        int strIdxEnd   = strArr.length-1;
        char ch;
        boolean containsStar = false;
        for (int i = 0; i < patArr.length; i++)
        {
            if (patArr[i] == '*')
            {
                containsStar = true;
                break;
            }
        }
        if (!containsStar)
        {
            // No '*'s, so we make a shortcut
            if (patIdxEnd != strIdxEnd)
            {
                return false;        // Pattern and string do not have the same size
            }
            for (int i = 0; i <= patIdxEnd; i++)
            {
                ch = patArr[i];
                if (ch != '?' && ch != strArr[i])
                {
                    return false;        // Character mismatch
                }
            }
            return true; // String matches against pattern
        }
        if (patIdxEnd == 0)
        {
            return true; // Pattern contains only '*', which matches anything
        }
        // Process characters before first star
        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd)
        {
            if (ch != '?' && ch != strArr[strIdxStart])
            {
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd)
        {
            // All characters in the string are used. Check if only '*'s are
            // left in the pattern. If so, we succeeded. Otherwise failure.
            for (int i = patIdxStart; i <= patIdxEnd; i++)
            {
                if (patArr[i] != '*')
                {
                    return false;
                }
            }
            return true;
        }
        // Process characters after last star
        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd)
        {
            if (ch != '?' && ch != strArr[strIdxEnd])
            {
                return false;
            }
            patIdxEnd--;
            strIdxEnd--;
        }
        if (strIdxStart > strIdxEnd)
        {
            // All characters in the string are used. Check if only '*'s are
            // left in the pattern. If so, we succeeded. Otherwise failure.
            for (int i = patIdxStart; i <= patIdxEnd; i++)
            {
                if (patArr[i] != '*')
                {
                    return false;
                }
            }
            return true;
        }
        // process pattern between stars. padIdxStart and patIdxEnd point
        // always to a '*'.
        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd)
        {
            int patIdxTmp = -1;
            for (int i = patIdxStart+1; i <= patIdxEnd; i++)
            {
                if (patArr[i] == '*')
                {
                    patIdxTmp = i;
                    break;
                }
            }
            if (patIdxTmp == patIdxStart+1)
            {
                                // Two stars next to each other, skip the first one.
                patIdxStart++;
                continue;
            }
            // Find the pattern between padIdxStart & padIdxTmp in str between
            // strIdxStart & strIdxEnd
            int patLength = (patIdxTmp-patIdxStart-1);
            int strLength = (strIdxEnd-strIdxStart+1);
            int foundIdx  = -1;
        strLoop:
            for (int i = 0; i <= strLength - patLength; i++)
            {
                for (int j = 0; j < patLength; j++)
                {
                    ch = patArr[patIdxStart+j+1];
                    if (ch != '?' && ch != strArr[strIdxStart+i+j])
                    {
                        continue strLoop;
                    }
                }
                foundIdx = strIdxStart+i;
                break;
            }
            if (foundIdx == -1)
            {
                return false;
            }
            patIdxStart = patIdxTmp;
            strIdxStart = foundIdx+patLength;
        }
        // All characters in the string are used. Check if only '*'s are left
        // in the pattern. If so, we succeeded. Otherwise failure.
        for (int i = patIdxStart; i <= patIdxEnd; i++)
        {
            if (patArr[i] != '*')
            {
                return false;
            }
        }
        return true;
    }
    // Begin SET and GET methods        
    /**
     * Sets the <CODE>serverName</CODE> attribute to the given value.
     * 
     * @param serverName The name of the server you wish to connect to.
     * @see #getServerName()
     */
    public void setServerName(String serverName)
    {
        this.serverName = serverName;
    }
    /**
     * Gets the <CODE>serverName</CODE> attribute.
     * 
     * @return The StarTeam server to log in to.
     * @see #setServerName(String serverName)
     */
    public String getServerName()
    {
        return serverName;
    }
    /**
     * Sets the <CODE>serverPort</CODE> attribute to the given value. The
     * given value must be a valid integer, but it must be a string object.
     * 
     * @param serverPort A string containing the port on the StarTeam server
     *                   to use.
     * @see #getServerPort()
     */
    public void setServerPort(String serverPort)
    {
        this.serverPort = serverPort;
    }
    /**
     * Gets the <CODE>serverPort</CODE> attribute.
     * 
     * @return A string containing the port on the StarTeam server to use.
     * @see #getServerPortAsInt()
     * @see #setServerPort(String serverPort)
     */
    public String getServerPort()
    {
        return serverPort;
    }
    /**
     * Gets the <CODE>serverPort</CODE> attribute as an integer.
     * 
     * @return An integer value for the port on the StarTeam server to use.
     * @see #getServerPort()
     * @see #setServerPort(String serverPort)
     */
    public int getServerPortAsInt()
    {
        return Integer.parseInt(serverPort);
    }
    /**
     * Sets the <CODE>projectName</CODE> attribute to the given value.
     * 
     * @param projectName
     *               The StarTeam project to search.
     * @see #getProjectName()
     */
    public void setProjectName(String projectName)
    {
        this.projectName = projectName;
    }
    /**
     * Gets the <CODE>projectName</CODE> attribute.
     * 
     * @return The StarTeam project to search.
     * @see #setProjectName(String projectName)
     */
    public String getProjectName()
    {
        return projectName;
    }
    /**
     * Sets the <CODE>viewName</CODE> attribute to the given value.
     * 
     * @param viewName The view to find the specified folder in.
     * @see #getViewName()
     */
    public void setViewName(String viewName)
    {
        this.viewName = viewName;
    }
    /**
     * Gets the <CODE>viewName</CODE> attribute.
     * 
     * @return The view to find the specified folder in.
     * @see #setViewName(String viewName)
     */
    public String getViewName()
    {
        return viewName;
    }
    /**
     * Sets the <CODE>folderName</CODE> attribute to the given value. To
     * search the root folder, use a slash or backslash, or simply don't set
     * a folder at all.
     * 
     * @param folderName The subfolder from which to check out files.
     * @see #getFolderName()
     */
    public void setFolderName(String folderName)
    {
        this.folderName = folderName;
    }
    /**
     * Gets the <CODE>folderName</CODE> attribute.
     *
     * @return The subfolder from which to check out files. All subfolders
     * will be searched, as well.
     * @see #setFolderName(String folderName)
     */
    public String getFolderName()
    {
        return folderName;
    }
    /**
     * Sets the <CODE>username</CODE> attribute to the given value.
     * 
     * @param username Your username for the specified StarTeam server.
     * @see #getUsername()
     */
    public void setUsername(String username)
    {
        this.username = username;
    }
    /**
     * Gets the <CODE>username</CODE> attribute.
     * 
     * @return The username given by the user.
     * @see #setUsername(String username)
     */
    public String getUsername()
    {
        return username;
    }
    /**
     * Sets the <CODE>password</CODE> attribute to the given value.
     * 
     * @param password Your password for the specified StarTeam server.
     * @see #getPassword()
     */
    public void setPassword(String password)
    {
        this.password = password;
    }
    /**
     * Gets the <CODE>password</CODE> attribute.
     * 
     * @return The password given by the user.
     * @see #setPassword(String password)
     */
    public String getPassword()
    {
        return password;
    }
    /**
     * Sets the <CODE>targetFolder</CODE> attribute to the given value.
     * 
     * @param target The target path on the local machine to check out to.
     * @see #getTargetFolder()
     */
    public void setTargetFolder(String targetFolder)
    {
        this.targetFolder = targetFolder;
    }
    /**
     * Gets the <CODE>targetFolder</CODE> attribute.
     * 
     * @return The target path on the local machine to check out to.
     *
     * @see #setTargetFolder(String targetFolder)
     */
    public String getTargetFolder()
    {
        return targetFolder;
    }
    /**
     * Sets the <CODE>force</CODE> attribute to the given value.
     * 
     * @param force  A string containing ""true"" or ""false"" that tells the
     *               application whether to continue if the target directory
     *               exists.  If <CODE>force</CODE> is true,
     *               AntStarTeamCheckOut will overwrite files in the target
     *               directory.  By default it set to false as a safeguard.
     *               Note that if the target directory does not exist, this
     *               setting has no effect.
     * @see #DEFAULT_FORCESETTING
     * @see #getForce()
     * @see #getForceAsBoolean()
     */
    public void setForce(String force)
    {
        this.force = force;
    }
    /**
     * Gets the <CODE>force</CODE> attribute.
     * 
     * @return A string containing ""true"" or ""false"" telling the application
     *         whether to continue if the target directory exists.  If
     *         <CODE>force</CODE> is true, AntStarTeamCheckOut will
     *         overwrite files in the target directory. If it is false and
     *         the target directory exists, AntStarTeamCheckOut will exit
     *         with a warning.  If the target directory does not exist, this
     *         setting has no effect. The default setting is false.
     * @see #DEFAULT_FORCESETTING
     * @see #getForceAsBoolean()
     * @see #setForce(String force)
     */
    public String getForce()
    {
        return force;
    }
    /**
     * Gets the <CODE>force</CODE> attribute as a boolean value.
     * 
     * @return A boolean value telling whether to continue if the target
     *         directory exists.
     * @see #DEFAULT_FORCESETTING
     * @see #getForce()
     * @see #setForce(String force)
     */
    public boolean getForceAsBoolean()
    {
        return project.toBoolean(force);
    }
    /**
     * Turns recursion on or off.
     *
     * @param verbose A string containing ""true"" or ""false.""  If it is true,
     *                the default, subfolders are searched recursively for
     *                files to check out.  Otherwise, only files specified
     *                by <CODE>folderName</CODE> are scanned.
     * @see #DEFAULT_RECURSIONSETTING
     * @see #getRecursion()
     * @see #getRecursionAsBoolean()
     */
    public void setRecursion(String recursion)
    {
        this.recursion = recursion;
    }
    /**
     * Gets the <CODE>recursion</CODE> attribute, which tells
     * AntStarTeamCheckOut whether to search subfolders when checking out
     * files.
     *
     * @return A string telling whether <CODE>recursion</CODE> is ""true"" or
     * ""false.""
     *
     * @see #DEFAULT_RECURSIONSETTING
     * @see #getRecursionAsBoolean()
     * @see #setRecursion(String recursion)
     */
    public String getRecursion()
    {
        return recursion;
    }
    /**
     * Gets the <CODE>recursion</CODE> attribute as a boolean value.
     *
     * @return A boolean value telling whether subfolders of
     * <CODE>folderName</CODE> will be scanned for files to check out.
     *
     * @see #DEFAULT_RECURSIONSETTING
     * @see #getRecursion()
     * @see #setRecursion(String recursion)
     */
    public boolean getRecursionAsBoolean()
    {
        return project.toBoolean(recursion);
    }
    /**
     * Sets the <CODE>verbose</CODE> attribute to the given value.
     * 
     * @param verbose A string containing ""true"" or ""false"" to tell
     *                AntStarTeamCheckOut whether to display files as they
     *                are checked out.  By default it is false, so the
     *                program only displays the total number of files unless
     *                you override this default.
     * @see #DEFAULT_FORCESETTING
     * @see #getForce()
     * @see #getForceAsBoolean()
     */
    public void setVerbose(String verbose)
    {
        this.verbose = verbose;
    }
    /**
     * Gets the <CODE>verbose</CODE> attribute.
     * 
     * @return A string containing ""true"" or ""false"" telling the application
     *         to display all files as it checks them out.  By default it is
     *         false, so the program only displays the total number of
     *         files.
     * @see #DEFAULT_VERBOSESETTING
     * @see #getVerboseAsBoolean()
     * @see #setVerbose(String verbose)
     */
    public String getVerbose()
    {
        return verbose;
    }
    /**
     * Gets the <CODE>verbose</CODE> attribute as a boolean value.
     * 
     * @return A boolean value telling whether to display all files as they
     *         are checked out.
     * @see #DEFAULT_VERBOSESETTING
     * @see #getVerbose()
     * @see #setVerbose(String verbose)
     */
    public boolean getVerboseAsBoolean()
    {
        return project.toBoolean(verbose);
    }
    // Begin filter getters and setters
    /**
     * Sets the include filter. When filtering files, AntStarTeamCheckOut
     * uses an unmodified version of <CODE>DirectoryScanner</CODE>'s
     * <CODE>match</CODE> method, so here are the patterns straight from the
     * Ant source code:
     * <BR><BR>
     * Matches a string against a pattern. The pattern contains two special
     * characters:
     * <BR>'*' which means zero or more characters,
     * <BR>'?' which means one and only one character.
     * <BR><BR>
     * I would have used the Ant method directly from its class, but
     * <CODE>match</CODE> is a private member, so I cannot access it from
     * this program.
     * <BR><BR>
     * Separate multiple inlcude filters by <I>spaces</I>, not commas as Ant
     * uses. For example, if you want to check out all .java and .class\
     * files, you would put the following line in your program:
     * <CODE>setIncludes(""*.java *.class"");</CODE>
     * Finally, note that filters have no effect on the <B>directories</B>
     * that are scanned; you could not check out files from directories with
     * names beginning only with ""build,"" for instance. Of course, you
     * could limit AntStarTeamCheckOut to a particular folder and its
     * subfolders with the <CODE>setFolderName(String folderName)</CODE>
     * command.
     * <BR><BR>
     * Treatment of overlapping inlcudes and excludes: To give a simplistic
     * example suppose that you set your include filter to ""*.htm *.html""
     * and your exclude filter to ""index.*"". What happens to index.html?
     * AntStarTeamCheckOut will not check out index.html, as it matches an
     * exclude filter (""index.*""), even though it matches the include
     * filter, as well.
     * <BR><BR>
     * Please also read the following sections before using filters:
     * 
     * @param includes A string of filter patterns to include. Separate the
     *                 patterns by spaces.
     * @see #getIncludes()
     * @see #setExcludes(String excludes)
     * @see #getExcludes()
     */
    public void setIncludes(String includes)
    {
        this.includes = includes;
    }
    /**
     * Gets the patterns from the include filter. Rather that duplicate the
     * details of AntStarTeanCheckOut's filtering here, refer to these
     * links:
     * 
     * @return A string of filter patterns separated by spaces.
     * @see #setIncludes(String includes)
     * @see #setExcludes(String excludes)
     * @see #getExcludes()
     */
    public String getIncludes()
    {
        return includes;
    }
    /**
     * Sets the exclude filter. When filtering files, AntStarTeamCheckOut
     * uses an unmodified version of <CODE>DirectoryScanner</CODE>'s
     * <CODE>match</CODE> method, so here are the patterns straight from the
     * Ant source code:
     * <BR><BR>
     * Matches a string against a pattern. The pattern contains two special
     * characters:
     * <BR>'*' which means zero or more characters,
     * <BR>'?' which means one and only one character.
     * <BR><BR>
     * I would have used the Ant method directly from its class, but
     * <CODE>match</CODE> is a private member, so I cannot access it from
     * this program.
     * <BR><BR>
     * Separate multiple exlcude filters by <I>spaces</I>, not commas as Ant
     * uses. For example, if you want to check out all files except .XML and
     * .HTML files, you would put the following line in your program:
     * <CODE>setExcludes(""*.XML *.HTML"");</CODE>
     * Finally, note that filters have no effect on the <B>directories</B>
     * that are scanned; you could not skip over all files in directories
     * whose names begin with ""project,"" for instance.
     * <BR><BR>
     * Treatment of overlapping inlcudes and excludes: To give a simplistic
     * example suppose that you set your include filter to ""*.htm *.html""
     * and your exclude filter to ""index.*"". What happens to index.html?
     * AntStarTeamCheckOut will not check out index.html, as it matches an
     * exclude filter (""index.*""), even though it matches the include
     * filter, as well.
     * <BR><BR>
     * Please also read the following sections before using filters:
     * 
     * @param excludes A string of filter patterns to exclude. Separate the
     *                 patterns by spaces.
     * @see #setIncludes(String includes)
     * @see #getIncludes()
     * @see #getExcludes()
     */
    public void setExcludes(String excludes)
    {
        this.excludes = excludes;
    }
    /**
     * Gets the patterns from the exclude filter. Rather that duplicate the
     * details of AntStarTeanCheckOut's filtering here, refer to these
     * links:
     * 
     * @return A string of filter patterns separated by spaces.
     * @see #setExcludes(String excludes)
     * @see #setIncludes(String includes)
     * @see #getIncludes()
     */
    public String getExcludes()
    {
        return excludes;
    }
}
"
org.apache.tools.ant.taskdefs.optional.sound.AntSoundPlayer,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.sound;
// ant includes
import org.apache.tools.ant.*;
// imports for all the sound classes required
// note: comes with jmf or jdk1.3 +
// these can be obtained from http://java.sun.com/products/java-media/sound/
import javax.sound.sampled.*;
import java.io.*;
import java.util.*;
/**
 * This class is designed to be used by any AntTask that requires audio output.
 *
 * It implements the BuildListener interface to listen for BuildEvents and could
 * be easily extended to provide audio output upon any specific build events occuring.
 *
 * I have only tested this with .WAV and .AIFF sound file formats. Both seem to work fine.
 *
 * @author Nick Pellow
 * @version $Revision: 1.3 $, $Date: 2001/02/04 10:51:00 $
 */
public class AntSoundPlayer implements LineListener, BuildListener {
    private File fileSuccess = null;
    private int loopsSuccess = 0;
    private Long durationSuccess = null;
    private File fileFail = null;
    private int loopsFail = 0;
    private Long durationFail = null;
    public AntSoundPlayer() {
    }
    /**
     * @param source the location of the audio file to be played when the build is successful
     * @param loops the number of times the file should be played when the build is successful
     * @param duration the number of milliseconds the file should be played when the build is successful
     */
    public void addBuildSuccessfulSound(File file, int loops, Long duration) {
        this.fileSuccess = file;
        this.loopsSuccess = loops;
        this.durationSuccess = duration;
    }
    /**
     * @param fileName the location of the audio file to be played when the build fails
     * @param loops the number of times the file should be played when the build is fails
     * @param duration the number of milliseconds the file should be played when the build fails
     */
    public void addBuildFailedSound(File fileFail, int loopsFail, Long durationFail) {
        this.fileFail = fileFail;
        this.loopsFail = loopsFail;
        this.durationFail = durationFail;
    }
    /**
     * Plays the file for duration milliseconds or loops.
     */
    private void play(Project project, File file, int loops, Long duration) {
        Clip audioClip = null;
        AudioInputStream audioInputStream = null;
		try {
			audioInputStream = AudioSystem.getAudioInputStream(file);
		}
		catch (UnsupportedAudioFileException uafe) {
			project.log(""Audio format is not yet supported: ""+uafe.getMessage());
		}
        catch (IOException ioe) {
            ioe.printStackTrace();
        }
		if (audioInputStream != null) {
			AudioFormat	format = audioInputStream.getFormat();
			DataLine.Info	info = new DataLine.Info(Clip.class, format,
                                             AudioSystem.NOT_SPECIFIED);
			try {
				audioClip = (Clip) AudioSystem.getLine(info);
				audioClip.addLineListener(this);
                audioClip.open(audioInputStream);
			}
			catch (LineUnavailableException e) {
                project.log(""The sound device is currently unavailable"");
                return;
			}
			catch (IOException e) {
				e.printStackTrace();
			}
            if (duration != null) {
                playClip(audioClip, duration.longValue());
            } else {
                playClip(audioClip, loops);
            }
            audioClip.drain();
            audioClip.close();
		}
		else {
			project.log(""Can't get data from file "" + file.getName());
		}
    }
    private void playClip(Clip clip, int loops) {
        clip.loop(loops);
        while (clip.isRunning()) {
        }
    }
    private void playClip(Clip clip, long duration) {
        long currentTime = System.currentTimeMillis();
        clip.loop(Clip.LOOP_CONTINUOUSLY);
        try {
            Thread.sleep(duration);
        }
        catch (InterruptedException e) {
        }
    }
    /**
     * This is implemented to listen for any line events and closes the
     * clip if required.
     */
    public void update(LineEvent event) {
        if (event.getType().equals(LineEvent.Type.STOP)) {
            Line line = event.getLine();
            line.close();
		}
		else if (event.getType().equals(LineEvent.Type.CLOSE)) {
			/*
			 *	There is a bug in JavaSound 0.90 (jdk1.3beta).
			 *	It prevents correct termination of the VM.
			 *	So we have to exit ourselves.
			 */
			//System.exit(0);
		}
	}
    /**
     *  Fired before any targets are started.
     */
    public void buildStarted(BuildEvent event){
    }
    /**
     *  Fired after the last target has finished. This event
     *  will still be thrown if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void buildFinished(BuildEvent event){
        if (event.getException() == null && fileSuccess != null) {
            // build successfull!
            play(event.getProject(), fileSuccess, loopsSuccess, durationSuccess);
        } else if ( event.getException() != null && fileFail != null) {
            play(event.getProject(), fileFail, loopsFail, durationFail);
        }
    }
    /**
     *  Fired when a target is started.
     *
     *  @see BuildEvent#getTarget()
     */
    public void targetStarted(BuildEvent event){
    }
    /**
     *  Fired when a target has finished. This event will
     *  still be thrown if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void targetFinished(BuildEvent event){
    }
    /**
     *  Fired when a task is started.
     *
     *  @see BuildEvent#getTask()
     */
    public void taskStarted(BuildEvent event){
    }
    /**
     *  Fired when a task has finished. This event will still
     *  be throw if an error occured during the build.
     *
     *  @see BuildEvent#getException()
     */
    public void taskFinished(BuildEvent event){
    }
    /**
     *  Fired whenever a message is logged.
     *
     *  @see BuildEvent#getMessage()
     *  @see BuildEvent#getPriority()
     */
    public void messageLogged(BuildEvent event){
    }
}
"
org.apache.tools.ant.taskdefs.optional.sound.SoundTask,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.sound;
import org.apache.tools.ant.*;
import java.io.*;
import java.util.*;
/**
 * This is an example of an AntTask that makes of use of the AntSoundPlayer.
 *
 * There are three attributes to be set:
 *
 * <code>source</code>: the location of the audio file to be played
 * <code>duration</code>: play the sound file continuously until ""duration"" milliseconds has expired
 * <code>loops</code>: the number of times the sound file should be played until stopped
 *
 * I have only tested this with .WAV and .AIFF sound file formats. Both seem
 * to work fine.
 *
 * plans for the future:
 * - use the midi api to define sounds (or drum beat etc) in xml and have
 *   Ant play them back
 *
 * @author Nick Pellow
 * @version $Revision: 1.3 $, $Date: 2001/02/04 10:51:01 $
 */
public class SoundTask extends Task {
    private BuildAlert success = null;
    private BuildAlert fail = null;
    public BuildAlert createSuccess() {
        success = new BuildAlert();
        return success;
    }
    public BuildAlert createFail() {
        fail = new BuildAlert();
        return fail;
     }
    public SoundTask() {
    }
    public void init(){
    }
    public void execute() {
        AntSoundPlayer soundPlayer = new AntSoundPlayer();
        if ( success == null ) {
            log(""No nested success element found."", Project.MSG_WARN);
        } else {
            soundPlayer.addBuildSuccessfulSound(success.getSource(),
              success.getLoops(), success.getDuration());
        }
        if (fail == null) {
            log(""No nested failure element found."", Project.MSG_WARN);
        } else {
            soundPlayer.addBuildFailedSound(fail.getSource(),
              fail.getLoops(), fail.getDuration());
        }
        getProject().addBuildListener(soundPlayer);
    }
    /**
     * A class to be extended by any BuildAlert's that require the output
     * of sound.
     */
    public class BuildAlert {
        private File source = null;
        private int loops = 0;
        private Long duration = null;
        /**
         * Sets the duration in milliseconds the file should be played.
         */
        public void setDuration(Long duration) {
            this.duration = duration;
        }
        /**
         * Sets the location of the file to get the audio.
         *
         * @param source the name a sound-file directory or of the audio file
         */
        public void setSource(File source) {
            this.source = source;
        }
        /**
         * Sets the number of times the source file should be played.
         *
         * @param loops the number of loops to play the source file
         */
        public void setLoops(int loops) {
            this.loops = loops;
        }
        /**
         * Gets the location of the file to get the audio.
         */
        public File getSource() {
            File nofile = null ;
            // Check if source is a directory
            if( source.exists() ) {
                if( source.isDirectory() ) {
                    // get the list of files in the dir
                    File[] files = source.listFiles() ; 
                    int numfiles = files.length ;
                    // get a random number between 0 and the number of files
                    Random rn = new Random() ;
                    int i = rn.nextInt(numfiles) ;
                    // set the source to the file at that location
                    this.source = files[i] ;
                }
            } else {
                log(source + "": invalid path."", Project.MSG_WARN) ;
                this.source = nofile ;
            }
            return this.source ;
        }
        /**
         * Sets the number of times the source file should be played.
         *
         * @return the number of loops to play the source file
         */
        public int getLoops() {
            return this.loops;
        }
        /**
         * Gets the duration in milliseconds the file should be played.
         */
        public Long getDuration() {
            return this.duration;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSS,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.vss;
import java.io.File;
import org.apache.tools.ant.*;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
/**
 * A base class for creating tasks for executing commands on Visual SourceSafe.
 * <p>
 * The class extends the 'exec' task as it operates by executing the ss.exe program
 * supplied with SourceSafe. By default the task expects ss.exe to be in the path,
 * you can override this be specifying the ssdir attribute.
 * </p>
 * <p>
 * This class provides set and get methods for 'login' and 'vsspath' attributes. It
 * also contains constants for the flags that can be passed to SS.
 * </p>
 *
 * @author Craig Cottingham
 * @author Andrew Everitt
 */
public abstract class MSVSS extends Task {
    private String m_SSDir = """";
    private String m_vssLogin = null;
    private String m_vssPath = null;
    /**
     * Set the directory where ss.exe is located
     *
     * @param dir the directory containing ss.exe
     */
    public final void setSsdir(String dir) {
        m_SSDir = project.translatePath(dir);
    }
    /**
     * Builds and returns the command string to execute ss.exe
     */
    public final String getSSCommand() {
        String toReturn = m_SSDir;
        if ( !toReturn.equals("""") && !toReturn.endsWith(""\\"") ) {
            toReturn += ""\\"";
        }
        toReturn += SS_EXE;
        return toReturn;
    }
    /**
     * Set the login to use when accessing vss.
     * <p>
     * Should be formatted as username,password
     *
     * @param login the login string to use
     */
    public final void setLogin(String login) {
        m_vssLogin = login;
    }
    /**
     * @return the appropriate login command if the 'login' attribute was specified, otherwise an empty string
     */
    public void getLoginCommand(Commandline cmd) {
        if ( m_vssLogin == null ) {
            return;
        } else {
            cmd.createArgument().setValue(FLAG_LOGIN + m_vssLogin);
        }
    }
    /**
     * Set the path to the item in vss to operate on
     * <p>
     * Ant can't cope with a '$' sign in an attribute so we have to add it here.
     * Also we strip off any 'vss://' prefix which is an XMS special and should probably be removed!
     *
     * @param vssPath
     */
    public final void setVsspath(String vssPath) {
        if ( vssPath.startsWith(""vss://"") ) {
            m_vssPath= PROJECT_PREFIX + vssPath.substring(5);
        } else {
            m_vssPath = PROJECT_PREFIX + vssPath;
        }
    }
    /**
     * @return m_vssPath
     */
    public String getVsspath() {
        return m_vssPath;
    }
    protected int run(Commandline cmd) {
        try {
            Execute exe = new Execute(new LogStreamHandler(this, 
                                                           Project.MSG_INFO,
                                                           Project.MSG_WARN));
            exe.setAntRun(project);
            exe.setWorkingDirectory(project.getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            return exe.execute();
        } catch (java.io.IOException e) {
            throw new BuildException(e, location);
        }
    }
    /**
     * Constant for the thing to execute
     */
    private static final String SS_EXE = ""ss"";
    /** */
    public static final String PROJECT_PREFIX = ""$"";
    /**
     * The 'Get' command
     */
    public static final String COMMAND_GET = ""Get"";
    /**
     * The 'Checkout' command
     */
    public static final String COMMAND_CHECKOUT = ""Checkout"";
    /**
     * The 'Label' command
     */
    public static final String COMMAND_LABEL = ""Label"";
    /**
     * The 'History' command
     */
    public static final String COMMAND_HISTORY = ""History"";
    /** */
    public static final String FLAG_LOGIN = ""-Y"";
    /** */
    public static final String FLAG_OVERRIDE_WORKING_DIR = ""-GL"";
    /** */
    public static final String FLAG_AUTORESPONSE_DEF = ""-I-"";
    /** */
    public static final String FLAG_AUTORESPONSE_YES = ""-I-Y"";
    /** */
    public static final String FLAG_AUTORESPONSE_NO = ""-I-N"";
    /** */
    public static final String FLAG_RECURSION = ""-R"";
    /** */
    public static final String FLAG_VERSION = ""-V"";
    /** */
    public static final String FLAG_VERSION_DATE = ""-Vd"";
    /** */
    public static final String FLAG_VERSION_LABEL = ""-VL"";
    /** */
    public static final String FLAG_WRITABLE = ""-W"";
    /** */
    public static final String VALUE_NO = ""-N"";
    /** */
    public static final String VALUE_YES = ""-Y"";
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSGET,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.vss;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import java.io.File;
/**
 * Task to perform GET commands to Microsoft Visual Source Safe.
 * <p>
 * The following attributes are interpretted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>login</td>
 *      <td>username,password</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>vsspath</td>
 *      <td>SourceSafe path</td>
 *      <td>Yes</td>
 *   <tr>
 *   <tr>
 *      <td>localpath</td>
 *      <td>Override the working directory and get to the specified path</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>writable</td>
 *      <td>true or false</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>recursive</td>
 *      <td>true or false</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>version</td>
 *      <td>a version number to get</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>date</td>
 *      <td>a date stamp to get at</td>
 *      <td>No</td>
 *   <tr>
 *   <tr>
 *      <td>label</td>
 *      <td>a label to get for</td>
 *      <td>No</td>
 *   <tr>
 * </table>
 * <p>Note that only one of version, date or label should be specified</p>
 *
 * @author Craig Cottingham
 * @author Andrew Everitt
 */
public class MSVSSGET extends MSVSS {
    private String m_LocalPath = null;
    private boolean m_Recursive = false;
    private boolean m_Writable = false;
    private String m_Version = null;
    private String m_Date = null;
    private String m_Label = null;
    private String m_AutoResponse = null;
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute ss and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;
        // first off, make sure that we've got a command and a vssdir ...
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, location);
        }
        // now look for illegal combinations of things ...
        // build the command line from what we got the format is
        // ss Get VSS items [-G] [-H] [-I-] [-N] [-O] [-R] [-V] [-W] [-Y] [-?]
        // as specified in the SS.EXE help
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_GET);
        // VSS items
        commandLine.createArgument().setValue(getVsspath());
        // -GL
        getLocalpathCommand(commandLine);
        // -I- or -I-Y or -I-N
        getAutoresponse(commandLine);
        // -R
        getRecursiveCommand(commandLine);
        // -V
        getVersionCommand(commandLine);
        // -W
        getWritableCommand(commandLine);
        // -Y
        getLoginCommand(commandLine);
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Set the local path.
     */
    public void setLocalpath(Path localPath) {
        m_LocalPath = localPath.toString();
    }
    /**
     * Builds and returns the -GL flag command if required
     * <p>
     * The localpath is created if it didn't exist
     */
    public void getLocalpathCommand(Commandline cmd) {
        if (m_LocalPath == null) {
            return;
        } else {
            // make sure m_LocalDir exists, create it if it doesn't
            File dir = project.resolveFile(m_LocalPath);
            if (!dir.exists()) {
                boolean done = dir.mkdirs();
                if (done == false) {
                    String msg = ""Directory "" + m_LocalPath + "" creation was not "" +
                        ""succesful for an unknown reason"";
                    throw new BuildException(msg, location);
                }
                project.log(""Created dir: "" + dir.getAbsolutePath());
            }
            cmd.createArgument().setValue(FLAG_OVERRIDE_WORKING_DIR + m_LocalPath);
        }
    }
    /**
     * Set behaviour recursive or non-recursive
     */
    public void setRecursive(boolean recursive) {
        m_Recursive = recursive;
    }
    /**
     * @return the 'recursive' command if the attribute was 'true', otherwise an empty string
     */
    public void getRecursiveCommand(Commandline cmd) {
        if ( !m_Recursive ) {
            return;
        } else {
            cmd.createArgument().setValue(FLAG_RECURSION);
        }
    }
    /**
     * Set behaviour, used in get command to make files that are 'got' writable
     */
    public final void setWritable(boolean argWritable) {
        m_Writable = argWritable;
    }
    /**
     * @return the 'make writable' command if the attribute was 'true', otherwise an empty string
     */
    public void getWritableCommand(Commandline cmd) {
        if ( !m_Writable ) {
            return;
        } else {
            cmd.createArgument().setValue(FLAG_WRITABLE);
        }
    }
    /**
     * Set the stored version string
     * <p>
     * Note we assume that if the supplied string has the value ""null"" that something
     * went wrong and that the string value got populated from a null object. This
     * happens if a ant variable is used e.g. version=""${ver_server}"" when ver_server
     * has not been defined to ant!
     */
    public void setVersion(String version) {
        if (version.equals("""") || version.equals(""null"") ) {
            m_Version = null;
        } else {
            m_Version = version;
        }
    }
    /**
     * Set the stored date string
     * <p>
     * Note we assume that if the supplied string has the value ""null"" that something
     * went wrong and that the string value got populated from a null object. This
     * happens if a ant variable is used e.g. date=""${date}"" when date
     * has not been defined to ant!
     */
    public void setDate(String date) {
        if (date.equals("""") || date.equals(""null"") ) {
            m_Date = null;
        } else {
            m_Date = date;
        }
    }
    /**
     * Set the labeled version to operate on in SourceSafe
     * <p>
     * Note we assume that if the supplied string has the value ""null"" that something
     * went wrong and that the string value got populated from a null object. This
     * happens if a ant variable is used e.g. label=""${label_server}"" when label_server
     * has not been defined to ant!
     */
    public void setLabel(String label) {
        if ( label.equals("""") || label.equals(""null"") ) {
            m_Label = null;
        } else {
            m_Label = label;
        }
    }
    /**
     * Simple order of priority. Returns the first specified of version, date, label
     * If none of these was specified returns """"
     */
    public void getVersionCommand(Commandline cmd) {
        if ( m_Version != null) {
            cmd.createArgument().setValue(FLAG_VERSION + m_Version);
        } else if ( m_Date != null) {
            cmd.createArgument().setValue(FLAG_VERSION_DATE + m_Date);
        } else if (m_Label != null) {
            cmd.createArgument().setValue(FLAG_VERSION_LABEL + m_Label);
        }
    }
    public void setAutoresponse(String response){
        if ( response.equals("""") || response.equals(""null"") ) {
            m_AutoResponse = null;
        } else {
            m_AutoResponse = response;
        }
    }
    /**
     * Checks the value set for the autoResponse.
     * if it equals ""Y"" then we return -I-Y
     * if it equals ""N"" then we return -I-N
     * otherwise we return -I
     */
    public void getAutoresponse(Commandline cmd) {
        if ( m_AutoResponse == null) {
            cmd.createArgument().setValue(FLAG_AUTORESPONSE_DEF);
        } else if ( m_AutoResponse.equalsIgnoreCase(""Y"")) {
            cmd.createArgument().setValue(FLAG_AUTORESPONSE_YES);
        } else if ( m_AutoResponse.equalsIgnoreCase(""N"")) {
            cmd.createArgument().setValue(FLAG_AUTORESPONSE_NO);
        }else {
            cmd.createArgument().setValue(FLAG_AUTORESPONSE_DEF);
        } // end of else
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSLABEL,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.taskdefs.optional.vss;
import org.apache.tools.ant.*;
import org.apache.tools.ant.types.Commandline;
/**
 * Task to perform LABEL commands to Microsoft Visual Source Safe.
 * <p>
 * The following attributes are interpreted:
 * <table border=""1"">
 *   <tr>
 *     <th>Attribute</th>
 *     <th>Values</th>
 *     <th>Required</th>
 *   </tr>
 *   <tr>
 *      <td>login</td>
 *      <td>username,password</td>
 *      <td>No</td>
 *   </tr>
 *   <tr>
 *      <td>vsspath</td>
 *      <td>SourceSafe path</td>
 *      <td>Yes</td>
 *   </tr>
 *   <tr>
 *      <td>ssdir</td>
 *      <td>directory where <code>ss.exe</code> resides. By default the task
 *      expects it to be in the PATH.</td>
 *      <td>No</td>
 *   </tr>
 *   <tr>
 *      <td>label</td>
 *      <td>A label to apply to the hierarchy</td>
 *      <td>Yes</td>
 *   </tr>
 *   <tr>
 *      <td>version</td>
 *      <td>An existing file or project version to label</td>
 *      <td>No</td>
 *   </tr>
 * </table>
 *
 * @author Phillip Wells
 */
public class MSVSSLABEL extends MSVSS
{
    private String m_Label = null;
    private String m_Version = null;
    public static final String FLAG_LABEL = ""-L"";
    /**
     * Executes the task.
     * <p>
     * Builds a command line to execute ss and then calls Exec's run method
     * to execute the command line.
     */
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;
        // first off, make sure that we've got a command and a vssdir and a label ...
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, location);
        }
        if (getLabel() == null) {
            String msg = ""label attribute must be set!"";
            throw new BuildException(msg, location);
        }
        // now look for illegal combinations of things ...
        // build the command line from what we got the format is
        // ss Label VSS items [-C]      [-H] [-I-] [-Llabel] [-N] [-O]      [-V]      [-Y] [-?]
        // as specified in the SS.EXE help
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_LABEL);
        // VSS items
        commandLine.createArgument().setValue(getVsspath());
        // -C
        // Use the same comment for all labels
        // Not required
        // -I-
        commandLine.createArgument().setValue(""-I-"");  // ignore all errors
        // -L
        // Specify the new label on the command line (instead of being prompted)
        getLabelCommand(commandLine);
        // -V
        // Label an existing file or project version
        getVersionCommand(commandLine);
        // -Y
        getLoginCommand(commandLine);
        result = run(commandLine);
        if ( result != 0 ) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, location);
        }
    }
    /**
     * Set the label to apply in SourceSafe
     * <p>
     * Note we assume that if the supplied string has the value ""null"" that something
     * went wrong and that the string value got populated from a null object. This
     * happens if a ant variable is used e.g. label=""${label_server}"" when label_server
     * has not been defined to ant!
     */
    public void setLabel(String label) {
        if ( label.equals("""") || label.equals(""null"") ) {
            m_Label = null;
        } else {
            m_Label = label;
        }
    }
    /**
     * Builds the version command.
     * @param cmd the commandline the command is to be added to
     */
    public void getVersionCommand(Commandline cmd) {
        if ( m_Version != null) {
            cmd.createArgument().setValue(FLAG_VERSION + m_Version);
        }
    }
    /**
     * Builds the label command.
     * @param cmd the commandline the command is to be added to
     */
    public void getLabelCommand(Commandline cmd) {
        if ( m_Label != null) {
            cmd.createArgument().setValue(FLAG_LABEL + m_Label);
        }
    }
    /**
     * Set the stored version string
     * <p>
     * Note we assume that if the supplied string has the value ""null"" that something
     * went wrong and that the string value got populated from a null object. This
     * happens if a ant variable is used e.g. version=""${ver_server}"" when ver_server
     * has not been defined to ant!
     */
    public void setVersion(String version) {
        if (version.equals("""") || version.equals(""null"") ) {
            m_Version = null;
        } else {
            m_Version = version;
        }
    }
    /**
     * Gets the label to be applied.
     * @return the label to be applied.
     */
    public String getLabel() {
        return m_Label;
    }
}
"
org.apache.tools.ant.types.Commandline,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.BuildException;
import java.io.File;
import java.util.Vector;
import java.util.StringTokenizer;
/**
 * Commandline objects help handling command lines specifying processes to
 * execute.
 *
 * The class can be used to define a command line as nested elements or as a
 * helper to define a command line by an application.
 * <p>
 * <code>
 * &lt;someelement&gt;<br>
 * &nbsp;&nbsp;&lt;acommandline executable=""/executable/to/run""&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=""argument 1"" /&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=""argument_1 argument_2 argument_3"" /&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=""argument 4"" /&gt;<br>
 * &nbsp;&nbsp;&lt;/acommandline&gt;<br>
 * &lt;/someelement&gt;<br>
 * </code>
 * The element <code>someelement</code> must provide a method
 * <code>createAcommandline</code> which returns an instance of this class.
 *
 * @author thomas.haas@softwired-inc.com
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class Commandline implements Cloneable {
    private Vector arguments = new Vector();
    private String executable = null;
    public Commandline(String to_process) {
        super();
        String[] tmp = translateCommandline(to_process);
        if (tmp != null && tmp.length > 0) {
            setExecutable(tmp[0]);
            for (int i=1; i<tmp.length; i++) {
                createArgument().setValue(tmp[i]);
            }
        }
    }
    public Commandline() {
        super();
    }
    /**
     * Used for nested xml command line definitions.
     */
    public class Argument {
        private String[] parts;
        /**
         * Sets a single commandline argument.
         *
         * @param value a single commandline argument.
         */
        public void setValue(String value) {
            parts = new String[] {value};
        }
        /**
         * Line to split into several commandline arguments.
         *
         * @param line line to split into several commandline arguments
         */
        public void setLine(String line) {
            parts = translateCommandline(line);
        }
        /**
         * Sets a single commandline argument and treats it like a
         * PATH - ensures the right separator for the local platform
         * is used.
         *
         * @param value a single commandline argument.  
         */
        public void setPath(Path value) {
            parts = new String[] {value.toString()};
        }
        /**
         * Sets a single commandline argument to the absolute filename
         * of the given file.  
         *
         * @param value a single commandline argument.  
         */
        public void setFile(File value) {
            parts = new String[] {value.getAbsolutePath()};
        }
        /**
         * Returns the parts this Argument consists of.
         */
        public String[] getParts() {
            return parts;
        }
    }
    /**
     * Class to keep track of the position of an Argument.
     */
    // <p>This class is there to support the srcfile and targetfile
    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know
    // whether there might be additional use cases.</p> --SB
    public class Marker {
        private int position;
        private int realPos = -1;
        Marker(int position) {
            this.position = position;
        }
        /**
         * Return the number of arguments that preceeded this marker.
         *
         * <p>The name of the executable - if set - is counted as the
         * very first argument.</p>
         */
        public int getPosition() {
            if (realPos == -1) {
                realPos = (executable == null ? 0 : 1);
                for (int i=0; i<position; i++) {
                    Argument arg = (Argument) arguments.elementAt(i);
                    realPos += arg.getParts().length;
                }
            }
            return realPos;
        }
    }
    /**
     * Creates an argument object.
     * Each commandline object has at most one instance of the argument class.
     * @return the argument object.
     */
    public Argument createArgument() {
        Argument argument = new Argument();
        arguments.addElement(argument);
        return argument;
    }
    /**
     * Sets the executable to run.
     */
    public void setExecutable(String executable) {
        if (executable == null || executable.length() == 0) return;
        this.executable = executable.replace('/', File.separatorChar)
            .replace('\\', File.separatorChar);
    }
    public String getExecutable() {
        return executable;
    }
    public void addArguments(String[] line) {
        for (int i=0; i < line.length; i++) {
            createArgument().setValue(line[i]);
        }
    }
    /**
     * Returns the executable and all defined arguments.
     */
    public String[] getCommandline() {
        final String[] args = getArguments();
        if (executable == null) return args;
        final String[] result = new String[args.length+1];
        result[0] = executable;
        System.arraycopy(args, 0, result, 1, args.length);
        return result;
    }
    /**
     * Returns all arguments defined by <code>addLine</code>,
     * <code>addValue</code> or the argument object.
     */
    public String[] getArguments() {
        Vector result = new Vector(arguments.size()*2);
        for (int i=0; i<arguments.size(); i++) {
            Argument arg = (Argument) arguments.elementAt(i);
            String[] s = arg.getParts();
            for (int j=0; j<s.length; j++) {
                result.addElement(s[j]);
            }
        }
        String [] res = new String[result.size()];
        result.copyInto(res);
        return res;
    }
    public String toString() {
        return toString(getCommandline());
    }
    /**
     * Put quotes around the given String if necessary.
     *
     * <p>If the argument doesn't include spaces or quotes, return it
     * as is. If it contains double quotes, use single quotes - else
     * surround the argument by double quotes.</p>
     *
     * @exception BuildException if the argument contains both, single
     *                           and double quotes.  
     */
    public static String quoteArgument(String argument) {
        if (argument.indexOf(""\"""") > -1) {
            if (argument.indexOf(""\'"") > -1) {
                throw new BuildException(""Can\'t handle single and double quotes in same argument"");
            } else {
                return '\''+argument+'\'';
            }
        } else if (argument.indexOf(""\'"") > -1 || argument.indexOf("" "") > -1) {
            return '\""'+argument+'\""';
        } else {
            return argument;
        }
    }
    public static String toString(String [] line) {
        // empty path return empty string
        if (line == null || line.length == 0) return """";
        // path containing one or more elements
        final StringBuffer result = new StringBuffer();
        for (int i=0; i < line.length; i++) {
            if (i > 0) {
                result.append(' ');
            }
            result.append(quoteArgument(line[i]));
        }
        return result.toString();
    }
    public static String[] translateCommandline(String to_process) {
        if (to_process == null || to_process.length() == 0) {
            return new String[0];
        }
        // parse with a simple finite state machine
        final int normal = 0;
        final int inQuote = 1;
        final int inDoubleQuote = 2;
        int state = normal;
        StringTokenizer tok = new StringTokenizer(to_process, ""\""\' "", true);
        Vector v = new Vector();
        StringBuffer current = new StringBuffer();
        while (tok.hasMoreTokens()) {
            String nextTok = tok.nextToken();
            switch (state) {
            case inQuote:
                if (""\'"".equals(nextTok)) {
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            case inDoubleQuote:
                if (""\"""".equals(nextTok)) {
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            default:
                if (""\'"".equals(nextTok)) {
                    state = inQuote;
                } else if (""\"""".equals(nextTok)) {
                    state = inDoubleQuote;
                } else if ("" "".equals(nextTok)) {
                    if (current.length() != 0) {
                        v.addElement(current.toString());
                        current.setLength(0);
                    }
                } else {
                    current.append(nextTok);
                }
                break;
            }
        }
        if (current.length() != 0) {
            v.addElement(current.toString());
        }
        if (state == inQuote || state == inDoubleQuote) {
            throw new BuildException(""unbalanced quotes in "" + to_process);
        }
        String[] args = new String[v.size()];
        v.copyInto(args);
        return args;
    }
    public int size() {
        return getCommandline().length;
    }
    public Object clone() {
        Commandline c = new Commandline();
        c.setExecutable(executable);
        c.addArguments(getArguments());
        return c;
    }
    /**
     * Clear out the whole command line.  */
    public void clear() {
        executable = null;
        arguments.removeAllElements();
    }
    /**
     * Clear out the arguments but leave the executable in place for another operation.
     */
    public void clearArgs() {
        arguments.removeAllElements();
    }
    /**
     * Return a marker.
     *
     * <p>This marker can be used to locate a position on the
     * commandline - to insert something for example - when all
     * parameters have been set.</p>
     */
    public Marker createMarker() {
        return new Marker(arguments.size());
    }
}
"
org.apache.tools.ant.types.CommandlineJava,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import java.util.*;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
/*
 *
 * @author thomas.haas@softwired-inc.com
 */
public class CommandlineJava implements Cloneable {
    private Commandline vmCommand = new Commandline();
    private Commandline javaCommand = new Commandline();
    private SysProperties sysProperties = new SysProperties();
    private Path classpath = null;
    private String vmVersion;
    /**
     * Specialized Environment class for System properties
     */
    public static class SysProperties extends Environment implements Cloneable {
        Properties sys = null;
        public String[] getVariables() throws BuildException {
            String props[] = super.getVariables();
            if (props == null) return null;
            for (int i = 0; i < props.length; i++) {
                props[i] = ""-D"" + props[i];
            }
            return props;
        }
        public int size() {
            return variables.size();
        }
        public void setSystem() throws BuildException {
            try {
                Properties p = new Properties(sys = System.getProperties());
                for (Enumeration e = variables.elements(); e.hasMoreElements(); ) {
                    Environment.Variable v = (Environment.Variable) e.nextElement();
                    p.put(v.getKey(), v.getValue());
                }
                System.setProperties(p);
            } catch (SecurityException e) {
                throw new BuildException(""Cannot modify system properties"", e);
            }
        }
        public void restoreSystem() throws BuildException {
            if (sys == null)
                throw new BuildException(""Unbalanced nesting of SysProperties"");
            try {
                System.setProperties(sys);
                sys = null;
            } catch (SecurityException e) {
                throw new BuildException(""Cannot modify system properties"", e);
            }
        }
        public Object clone() {
            try {
                SysProperties c = (SysProperties) super.clone();
                c.variables = (Vector) variables.clone();
                return c;
            } catch(CloneNotSupportedException e){return null;}
        }
    }
    public CommandlineJava() {
        setVm(""java"");
        setVmversion(org.apache.tools.ant.Project.getJavaVersion());
    }
    public Commandline.Argument createArgument() {
        return javaCommand.createArgument();
    }
    public Commandline.Argument createVmArgument() {
        return vmCommand.createArgument();
    }
    public void addSysproperty(Environment.Variable sysp) {
        sysProperties.addVariable(sysp);
    }
    public void setVm(String vm) {
        vmCommand.setExecutable(vm);
    }
    public void setVmversion(String value) {
        vmVersion = value;
    }
    public void setClassname(String classname) {
        javaCommand.setExecutable(classname);
    }
    public String getClassname() {
        return javaCommand.getExecutable();
    }
    public Path createClasspath(Project p) {
        if (classpath == null) {
            classpath = new Path(p);
        }
        return classpath;
    }
    public String getVmversion() {
        return vmVersion;
    }
    public String[] getCommandline() {
        Path fullClasspath = classpath != null ? classpath.concatSystemClasspath(""ignore"") : null;
        int size = 
            vmCommand.size() + javaCommand.size() + sysProperties.size();
        if (fullClasspath != null && fullClasspath.size() > 0) {
            size += 2;
        }
        String[] result = new String[size];
        System.arraycopy(vmCommand.getCommandline(), 0, 
                         result, 0, vmCommand.size());
        int pos = vmCommand.size();
        if (sysProperties.size() > 0) {
            System.arraycopy(sysProperties.getVariables(), 0,
                             result, pos, sysProperties.size());
            pos += sysProperties.size();
        }
        if (fullClasspath != null && fullClasspath.toString().trim().length() > 0) {
            result[pos++] = ""-classpath"";
            result[pos++] = fullClasspath.toString();
        }
        System.arraycopy(javaCommand.getCommandline(), 0, 
                         result, pos, javaCommand.size());
        return result;
    }
    public String toString() {
        return Commandline.toString(getCommandline());
    }
    public int size() {
        int size = vmCommand.size() + javaCommand.size();
        if (classpath != null && classpath.size() > 0) {
            size += 2;
        }
        return size;
    }
    public Commandline getJavaCommand() {
        return javaCommand;
    }
    public Commandline getVmCommand() {
        return vmCommand;
    }
    public Path getClasspath() {
        return classpath;
    }
    public void setSystemProperties() throws BuildException {
        sysProperties.setSystem();
    }
    public void restoreSystemProperties() throws BuildException {
        sysProperties.restoreSystem();
    }
    public SysProperties getSystemProperties() {
        return sysProperties;
    }
    public Object clone() {
        CommandlineJava c = new CommandlineJava();
        c.vmCommand = (Commandline) vmCommand.clone();
        c.javaCommand = (Commandline) javaCommand.clone();
        c.sysProperties = (SysProperties) sysProperties.clone();
        if (classpath != null) {
            c.classpath = (Path) classpath.clone();
        }
        c.vmVersion = vmVersion;
        return c;
    }
    /**
     * Clear out the java arguments.
     */
    public void clearJavaArgs() {
        javaCommand.clearArgs();
    }
}
"
org.apache.tools.ant.types.DataType,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import java.util.Stack;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
/**
 * Base class for those classes that can appear inside the build file
 * as stand alone data types.  
 *
 * <p>This class handles the common description attribute and provides
 * a default implementation for reference handling and checking for
 * circular references that is appropriate for types that can not be
 * nested inside elements of the same type (i.e. &lt;patternset&gt;
 * but not &lt;path&gt;).</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public abstract class DataType {
    /**
     * The descriptin the user has set.
     */
    protected String description = null;
    /**
     * Value to the refid attribute.
     */
    protected Reference ref = null;
    /**
     * Are we sure we don't hold circular references?
     *
     * <p>Subclasses are responsible for setting this value to false
     * if we'd need to investigate this condition (usually because a
     * child element has been added that is a subclass of
     * DataType).</p> 
     */
    protected boolean checked = true;
    /** 
     * Sets a description of the current data type. It will be useful
     * in commenting what we are doing.  
     */
    public void setDescription( String desc ) {
        description=desc;
    }
    /**
     * Return the description for the current data type.
     */
    public String getDescription() {
        return description;
    }
    /**
     * Has the refid attribute of this element been set?
     */
    public boolean isReference() {
        return ref != null;
    }
    /**
     * Set the value of the refid attribute.
     *
     * <p>Subclasses may need to check whether any other attributes
     * have been set as well or child elements have been created and
     * thus override this method. if they do the must call
     * <code>super.setRefid</code>.</p> 
     */
    public void setRefid(Reference ref) {
        this.ref = ref;
        checked = false;
    }
    /**
     * Check to see whether any DataType we hold references to is
     * included in the Stack (which holds all DataType instances that
     * directly or indirectly reference this instance, including this
     * instance itself).
     *
     * <p>If one is included, throw a BuildException created by {@link
     * #circularReference circularReference}.</p>
     *
     * <p>This implementation is appropriate only for a DataType that
     * cannot hold other DataTypes as children.</p> 
     *
     * <p>The general contract of this method is that it shouldn't do
     * anything if {@link #checked <code>checked</code>} is true and
     * set it to true on exit.</p> 
     */
    protected void dieOnCircularReference(Stack stk, Project p) 
        throws BuildException {
        if (checked || !isReference()) {
            return;
        }
        Object o = ref.getReferencedObject(p);
        if (o instanceof DataType) {
            if (stk.contains(o)) {
                throw circularReference();
            } else {
                stk.push(o);
                ((DataType) o).dieOnCircularReference(stk, p);
                stk.pop();
            }
        }
        checked = true;
    }
    /**
     * Creates an exception that indicates that refid has to be the
     * only attribute if it is set.  
     */
    protected BuildException tooManyAttributes() {
        return new BuildException( ""You must not specify more than one attribute"" +
                                   "" when using refid"" );
    }
    /**
     * Creates an exception that indicates that this XML element must
     * not have child elements if the refid attribute is set.  
     */
    protected BuildException noChildrenAllowed() {
        return new BuildException(""You must not specify nested elements when using refid"");
    }
    /**
     * Creates an exception that indicates the user has generated a
     * loop of data types referencing each other.  
     */
    protected BuildException circularReference() {
        return new BuildException(""This data type contains a circular reference."");
    }
}
"
org.apache.tools.ant.types.EnumeratedAttribute,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.BuildException;
/**
 * Helper class for attributes that can only take one of a fixed list
 * of values.
 *
 * <p>See {@link org.apache.tools.ant.taskdefs.FixCRLF FixCRLF} for an
 * example.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public abstract class EnumeratedAttribute {
    protected String value;
    /**
     * This is the only method a subclass needs to implement.
     *
     * @return an array holding all possible values of the enumeration.
     */
    public abstract String[] getValues();
    public EnumeratedAttribute() {}
    /**
     * Invoked by {@link org.apache.tools.ant.IntrospectionHelper IntrospectionHelper}.
     */
    public final void setValue(String value) throws BuildException {
        if (!containsValue(value)) {
            throw new BuildException(value+"" is not a legal value for this attribute"");
        }
        this.value = value;
    }
    /**
     * Is this value included in the enumeration?
     */
    public final boolean containsValue(String value) {
        String[] values = getValues();
        if (values == null || value == null) {
            return false;
        }
        for (int i=0; i<values.length; i++) {
            if (value.equals(values[i])) {
                return true;
            }
        }
        return false;
    }
    /**
     * Retrieves the value.
     */
    public final String getValue() {
        return value;
    }
}
"
org.apache.tools.ant.types.Environment,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.BuildException;
import java.util.Vector;
/**
 * Wrapper for environment variables.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a>
 */
public class Environment {
    protected Vector variables;
    public static class Variable {
        private String key, value;
        public Variable() {
            super();
        }
        public void setKey(String key) {
            this.key = key;
        }
        public void setValue(String value) {
            this.value = value;
        }
        public String getKey() {
            return this.key;
        }
        public String getValue() {
            return this.value;
        }
        public void setPath(Path path) {
            this.value = path.toString();
        }
        public void setFile(java.io.File file) {
            this.value = file.getAbsolutePath();
        }
        public String getContent() throws BuildException {
            if (key == null || value == null) {
                throw new BuildException(""key and value must be specified for environment variables."");
            }
            StringBuffer sb = new StringBuffer(key.trim());
            sb.append(""="").append(value.trim());
            return sb.toString();
        }
    }
    public Environment() {
        variables = new Vector();
    }
    public void addVariable(Variable var) {
        variables.addElement(var);
    }
    public String[] getVariables() throws BuildException {
        if (variables.size() == 0) {
            return null;
        }
        String[] result = new String[variables.size()];
        for (int i=0; i<result.length; i++) {
            result[i] = ((Variable) variables.elementAt(i)).getContent();
        }
        return result;
    }
}
"
org.apache.tools.ant.types.FileSet,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.FileScanner;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import java.io.File;
import java.util.Stack;
import java.util.Vector;
/**
 * Moved out of MatchingTask to make it a standalone object that could
 * be referenced (by scripts for example).
 *
 * @author Arnout J. Kuiper <a href=""mailto:ajkuiper@wxs.nl"">ajkuiper@wxs.nl</a> 
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class FileSet extends DataType {
    private PatternSet defaultPatterns = new PatternSet();
    private Vector additionalPatterns = new Vector();
    private File dir;
    private boolean useDefaultExcludes = true;
    public FileSet() {
        super();
    }
    protected FileSet(FileSet fileset) {
        this.dir = fileset.dir;
        this.defaultPatterns = fileset.defaultPatterns;
        this.additionalPatterns = fileset.additionalPatterns;
        this.useDefaultExcludes = fileset.useDefaultExcludes;
    }
    /**
     * Makes this instance in effect a reference to another PatternSet
     * instance.
     *
     * <p>You must not set another attribute or nest elements inside
     * this element if you make it a reference.</p> 
     */
    public void setRefid(Reference r) throws BuildException {
        if (dir != null || defaultPatterns.hasPatterns()) {
            throw tooManyAttributes();
        }
        if (!additionalPatterns.isEmpty()) {
            throw noChildrenAllowed();
        }
        super.setRefid(r);
    }
    public void setDir(File dir) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (!dir.exists()) {
            throw new BuildException(dir.getAbsolutePath()+"" not found."");
        }
        if (!dir.isDirectory()) {
            throw new BuildException(dir.getAbsolutePath()+"" is not a directory."");
        }
        this.dir = dir;
    }
    public File getDir(Project p) {
        if (isReference()) {
            return getRef(p).getDir(p);
        }
        return dir;
    }
    public PatternSet createPatternSet() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        PatternSet patterns = new PatternSet();
        additionalPatterns.addElement(patterns);
        return patterns;
    }
    /**
     * add a name entry on the include list
     */
    public PatternSet.NameEntry createInclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return defaultPatterns.createInclude();
    }
    /**
     * add a name entry on the exclude list
     */
    public PatternSet.NameEntry createExclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return defaultPatterns.createExclude();
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setIncludes(includes);
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setExcludes(excludes);
    }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param incl The file to fetch the include patterns from.  
     */
     public void setIncludesfile(File incl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setIncludesfile(incl);
     }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param excl The file to fetch the exclude patterns from.  
     */
     public void setExcludesfile(File excl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setExcludesfile(excl);
     }
    /**
     * Sets whether default exclusions should be used or not.
     *
     * @param useDefaultExcludes ""true""|""on""|""yes"" when default exclusions 
     *                           should be used, ""false""|""off""|""no"" when they
     *                           shouldn't be used.
     */
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.useDefaultExcludes = useDefaultExcludes;
    }
    /**
     * Returns the directory scanner needed to access the files to process.
     */
    public DirectoryScanner getDirectoryScanner(Project p) {
        if (isReference()) {
            return getRef(p).getDirectoryScanner(p);
        }
        if (dir == null) {
            throw new BuildException(""No directory specified for fileset."");
        }
        DirectoryScanner ds = new DirectoryScanner();
        setupDirectoryScanner(ds, p);
        ds.scan();
        return ds;
    }
    public void setupDirectoryScanner(FileScanner ds, Project p) {
        if (ds == null) {
            throw new IllegalArgumentException(""ds cannot be null"");
        }
        ds.setBasedir(dir);
        for (int i=0; i<additionalPatterns.size(); i++) {
            Object o = additionalPatterns.elementAt(i);
            defaultPatterns.append((PatternSet) o, p);
        }
        ds.setIncludes(defaultPatterns.getIncludePatterns(p));
        ds.setExcludes(defaultPatterns.getExcludePatterns(p));
        if (useDefaultExcludes) ds.addDefaultExcludes();
    }
    /**
     * Performs the check for circular references and returns the
     * referenced FileSet.  
     */
    protected FileSet getRef(Project p) {
        if (!checked) {
            Stack stk = new Stack();
            stk.push(this);
            dieOnCircularReference(stk, p);
        }
        Object o = ref.getReferencedObject(p);
        if (!(o instanceof FileSet)) {
            String msg = ref.getRefId()+"" doesn\'t denote a fileset"";
            throw new BuildException(msg);
        } else {
            return (FileSet) o;
        }
    }
}
"
org.apache.tools.ant.types.Mapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.*;
import java.util.Properties;
import java.util.Stack;
/**
 * Element to define a FileNameMapper.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class Mapper extends DataType {
    protected Project p;
    protected MapperType type = null;
    public Mapper(Project p) {
        this.p = p;
    }
    /**
     * Set the type of FileNameMapper to use.
     */
    public void setType(MapperType type) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.type = type;
    }
    protected String classname = null;
    /**
     * Set the class name of the FileNameMapper to use.
     */
    public void setClassname(String classname) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.classname = classname;
    }
    protected Path classpath = null;
    /**
     * Set the classpath to load the FileNameMapper through (attribute).
     */
    public void setClasspath(Path classpath) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }
    /**
     * Set the classpath to load the FileNameMapper through (nested element).
     */
    public Path createClasspath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.classpath == null) {
            this.classpath = new Path(p);
        }
        return this.classpath.createPath();
    }
    /**
     * Set the classpath to load the FileNameMapper through via
     * reference (attribute).
     */
    public void setClasspathRef(Reference r) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createClasspath().setRefid(r);
    }
    protected String from = null;
    /**
     * Set the argument to FileNameMapper.setFrom
     */
    public void setFrom(String from) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.from = from;
    }
    protected String to = null;
    /**
     * Set the argument to FileNameMapper.setTo
     */
    public void setTo(String to) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.to = to;
    }
    /**
     * Make this Mapper instance a reference to another Mapper.
     *
     * <p>You must not set any other attribute if you make it a
     * reference.</p>
     */
    public void setRefid(Reference r) throws BuildException {
        if (type != null || from != null || to != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }
    /**
     * Returns a fully configured FileNameMapper implementation.
     */
    public FileNameMapper getImplementation() throws BuildException {
        if (isReference()) {
            return getRef().getImplementation();
        }
        if (type == null && classname == null) {
            throw new BuildException(""one of the attributes type or classname is required"");
        }
        if (type != null && classname != null) {
            throw new BuildException(""must not specify both type and classname attribute"");
        }
        try {
            if (type != null) {
                classname = type.getImplementation();
            }
            Class c = null;
            if (classpath == null) {
                c = Class.forName(classname);
            } else {
                AntClassLoader al = new AntClassLoader(p, classpath);
                c = al.loadClass(classname);
            }
            FileNameMapper m = (FileNameMapper) c.newInstance();
            m.setFrom(from);
            m.setTo(to);
            return m;
        } catch (BuildException be) {
            throw be;
        } catch (Throwable t) {
            throw new BuildException(t);
        } finally {
            if (type != null) {
                classname = null;
            }
        }
    }
    /**
     * Performs the check for circular references and returns the
     * referenced Mapper.  
     */
    protected Mapper getRef() {
        if (!checked) {
            Stack stk = new Stack();
            stk.push(this);
            dieOnCircularReference(stk, p);
        }
        Object o = ref.getReferencedObject(p);
        if (!(o instanceof Mapper)) {
            String msg = ref.getRefId()+"" doesn\'t denote a mapper"";
            throw new BuildException(msg);
        } else {
            return (Mapper) o;
        }
    }
    /**
     * Class as Argument to FileNameMapper.setType.
     */
    public static class MapperType extends EnumeratedAttribute {
        private Properties implementations;
        public MapperType() {
            implementations = new Properties();
            implementations.put(""identity"", 
                                ""org.apache.tools.ant.util.IdentityMapper"");
            implementations.put(""flatten"", 
                                ""org.apache.tools.ant.util.FlatFileNameMapper"");
            implementations.put(""glob"", 
                                ""org.apache.tools.ant.util.GlobPatternMapper"");
            implementations.put(""merge"", 
                                ""org.apache.tools.ant.util.MergingMapper"");
            implementations.put(""regexp"", 
                                ""org.apache.tools.ant.util.RegexpPatternMapper"");
        }
        public String[] getValues() {
            return new String[] {""identity"", ""flatten"", ""glob"", ""merge"", ""regexp""};
        }
        public String getImplementation() {
            return implementations.getProperty(getValue());
        }
    }
}
"
org.apache.tools.ant.types.Path,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.PathTokenizer;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Stack;
import java.util.Vector;
import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
/**
 * This object represents a path as used by CLASSPATH or PATH
 * environment variable.
 * <p>
 * <code>
 * &lt;sometask&gt;<br>
 * &nbsp;&nbsp;&lt;somepath&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location=""/path/to/file.jar"" /&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement path=""/path/to/file2.jar:/path/to/class2;/path/to/class3"" /&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location=""/path/to/file3.jar"" /&gt;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location=""/path/to/file4.jar"" /&gt;<br>
 * &nbsp;&nbsp;&lt;/somepath&gt;<br>
 * &lt;/sometask&gt;<br>
 * </code>
 * <p>
 * The object implemention <code>sometask</code> must provide a method called
 * <code>createSomepath</code> which returns an instance of <code>Path</code>.
 * Nested path definitions are handled by the Path object and must be labeled
 * <code>pathelement</code>.<p>
 *
 * The path element takes a parameter <code>path</code> which will be parsed
 * and split into single elements. It will usually be used
 * to define a path from an environment variable.
 *
 * @author Thomas.Haas@softwired-inc.com
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class Path extends DataType implements Cloneable {
    private Vector elements;
    private Project project;
    public static Path systemClasspath = 
        new Path(null, System.getProperty(""java.class.path""));
    /**
     * Helper class, holds the nested <pathelement> values.
     */
    public class PathElement {
        private String[] parts;
        public void setLocation(File loc) {
            try {
                parts = new String[] {translateFile(loc.getCanonicalPath())};
            } catch(IOException e) {
                // XXX I'd like to log something here but if I don't
                //     have a Project I can't
                if (project != null) {
                    project.log(e.getMessage(), Project.MSG_WARN);
                }
                parts = new String[] {translateFile(loc.getAbsolutePath())};
            }
        }
        public void setPath(String path) {
            parts = Path.translatePath(project, path);
        }
        public String[] getParts() {
            return parts;
        }
    }
    /**
     * Invoked by IntrospectionHelper for <code>setXXX(Path p)</code>
     * attribute setters.  
     */
    public Path(Project p, String path) {
        this(p);
        createPathElement().setPath(path);
    }
    public Path(Project project) {
        this.project = project;
        elements = new Vector();
    }
    /**
     * Adds a element definition to the path.
     * @param location the location of the element to add (must not be
     * <code>null</code> nor empty.
     */
    public void setLocation(File location) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createPathElement().setLocation(location);
    }
    /**
     * Parses a path definition and creates single PathElements.
     * @param path the path definition.
     */
    public void setPath(String path) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createPathElement().setPath(path);
    }
    /**
     * Makes this instance in effect a reference to another Path instance.
     *
     * <p>You must not set another attribute or nest elements inside
     * this element if you make it a reference.</p>
     */
    public void setRefid(Reference r) throws BuildException {
        if (!elements.isEmpty()) {
            throw tooManyAttributes();
        }
        elements.addElement(r);
        super.setRefid(r);
    }
    /**
     * Creates the nested <pathelement> element.
     */
    public PathElement createPathElement() throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        PathElement pe = new PathElement();
        elements.addElement(pe);
        return pe;
    }
    /**
     * Adds a nested <fileset> element.
     */
    public void addFileset(FileSet fs) throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        elements.addElement(fs);
        checked = false;
    }
    /**
     * Creates a nested <path> element.
     */
    public Path createPath() throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        Path p = new Path(project);
        elements.addElement(p);
        checked = false;
        return p;
    }
    /**
     * Append the contents of the other Path instance to this.
     */
    public void append(Path other) {
        if (other == null) return;
        String[] l = other.list();
        for (int i=0; i<l.length; i++) {
            if (elements.indexOf(l[i]) == -1) {
                elements.addElement(l[i]);
            }
        }
    }
     /**
     * Adds the components on the given path which exist to this
     * Path. Components that don't exist, aren't added.
     *
     * @param source - source path whose components are examined for existence
     */
    public void addExisting(Path source) {
        String[] list = source.list();
        for (int i=0; i<list.length; i++) {
            File f = null;
            if (project != null) {
                f = project.resolveFile(list[i]);
            }
            else {
                f = new File(list[i]);
            }
            if (f.exists()) {
                setLocation(f);
            } 
        }
    }
    /**
     * Returns all path elements defined by this and nested path objects.
     * @return list of path elements.
     */
    public String[] list() {
        if (!checked) {
            // make sure we don't have a circular reference here
            Stack stk = new Stack();
            stk.push(this);
            dieOnCircularReference(stk, project);
        }
        Vector result = new Vector(2*elements.size());
        for (int i=0; i<elements.size(); i++) {
            Object o = elements.elementAt(i);
            if (o instanceof Reference) {
                Reference r = (Reference) o;
                o = r.getReferencedObject(project);
                // we only support references to paths right now
                if (!(o instanceof Path)) {
                    String msg = r.getRefId()+"" doesn\'t denote a path"";
                    throw new BuildException(msg);
                }
            }
            if (o instanceof String) {
                // obtained via append
                addUnlessPresent(result, (String) o);
            } else if (o instanceof PathElement) {
                String[] parts = ((PathElement) o).getParts();
                if (parts == null) {
                    throw new BuildException(""You must either set location or path on <pathelement>"");
                }
                for (int j=0; j<parts.length; j++) {
                    addUnlessPresent(result, parts[j]);
                }
            } else if (o instanceof Path) {
                String[] parts = ((Path) o).list();
                for (int j=0; j<parts.length; j++) {
                    addUnlessPresent(result, parts[j]);
                }
            } else if (o instanceof FileSet) {
                FileSet fs = (FileSet) o;
                DirectoryScanner ds = fs.getDirectoryScanner(project);
                String[] s = ds.getIncludedFiles();
                File dir = fs.getDir(project);
                for (int j=0; j<s.length; j++) {
                    String canonicalPath;
                    File f = new File(dir, s[j]);
                    try {
                        canonicalPath = f.getCanonicalPath();
                    } catch(IOException e) {
                        canonicalPath = f.getAbsolutePath();
                    }
                    addUnlessPresent(result, translateFile(canonicalPath));
                } 
            }
        }
        String[] res = new String[result.size()];
        result.copyInto(res);
        return res;
    }
    /**
     * Returns a textual representation of the path, which can be used as
     * CLASSPATH or PATH environment variable definition.
     * @return a textual representation of the path.
     */
    public String toString() {
        final String[] list = list();
        // empty path return empty string
        if (list.length == 0) return """";
        // path containing one or more elements
        final StringBuffer result = new StringBuffer(list[0].toString());
        for (int i=1; i < list.length; i++) {
            result.append(File.pathSeparatorChar);
            result.append(list[i]);
        }
        return result.toString();
    }
    /**
     * Splits a PATH (with : or ; as separators) into its parts.
     */
    public static String[] translatePath(Project project, String source) {
        final Vector result = new Vector();
        if (source == null) return new String[0];
        PathTokenizer tok = new PathTokenizer(source);
        StringBuffer element = new StringBuffer();
        while (tok.hasMoreTokens()) {
            element.setLength(0);
            element.append(resolveFile(project, tok.nextToken()));
            for (int i=0; i<element.length(); i++) {
                translateFileSep(element, i);
            }
            result.addElement(element.toString());
        }
        String[] res = new String[result.size()];
        result.copyInto(res);
        return res;
    }
    /**
     * Returns its argument with all file separator characters
     * replaced so that they match the local OS conventions.  
     */
    public static String translateFile(String source) {
        if (source == null) return """";
        final StringBuffer result = new StringBuffer(source);
        for (int i=0; i < result.length(); i++) {
            translateFileSep(result, i);
        }
        return result.toString();
    }
    /**
     * Translates all occurrences of / or \ to correct separator of the
     * current platform and returns whether it had to do any
     * replacements.  
     */
    protected static boolean translateFileSep(StringBuffer buffer, int pos) {
        if (buffer.charAt(pos) == '/' || buffer.charAt(pos) == '\\') {
            buffer.setCharAt(pos, File.separatorChar);
            return true;
        }
        return false;
    }
    /**
     * How many parts does this Path instance consist of.
     */
    public int size() {
        return list().length;
    }
    /**
     * Return a Path that holds the same elements as this instance.
     */
    public Object clone() {
        Path p = new Path(project);
        p.append(this);
        return p;
    }
    /**
     * Overrides the version of DataType to recurse on all DataType
     * child elements that may have been added.  
     */
    protected void dieOnCircularReference(Stack stk, Project p) 
        throws BuildException {
        if (checked) {
            return;
        }
        Enumeration enum = elements.elements();
        while (enum.hasMoreElements()) {
            Object o = enum.nextElement();
            if (o instanceof Reference) {
                o = ((Reference) o).getReferencedObject(p);
            }
            if (o instanceof DataType) {
                if (stk.contains(o)) {
                    throw circularReference();
                } else {
                    stk.push(o);
                    ((DataType) o).dieOnCircularReference(stk, p);
                    stk.pop();
                }
            }
        }
        checked = true;
    }
    /**
     * Resolve a filename with Project's help - if we know one that is.
     *
     * <p>Assume the filename is absolute if project is null.</p>
     */
    private static String resolveFile(Project project, String relativeName) {
        if (project != null) {
            File f = project.resolveFile(relativeName);
            try {
                return f.getCanonicalPath();
            } catch(IOException e) {
                project.log(e.getMessage(), Project.MSG_WARN);
                return f.getAbsolutePath();
            }
        }
        return relativeName;
    }
    /**
     * Adds a String to the Vector if it isn't already included.
     */
    private static void addUnlessPresent(Vector v, String s) {
        if (v.indexOf(s) == -1) {
            v.addElement(s);
        }
    }
    /**
     * Concatenates the system class path in the order specified by
     * the ${build.sysclasspath} property - using &quot;last&quot; as
     * default value.
     */
    public Path concatSystemClasspath() {
        return concatSystemClasspath(""last"");
    }
    /**
     * Concatenates the system class path in the order specified by
     * the ${build.sysclasspath} property - using the supplied value
     * if ${build.sysclasspath} has not been set.
     */
    public Path concatSystemClasspath(String defValue) {
        Path result = new Path(project);
        String order = project.getProperty(""build.sysclasspath"");
        if (order == null) order=defValue;
        if (order.equals(""only"")) {
            // only: the developer knows what (s)he is doing
            result.addExisting(Path.systemClasspath);
        } else if (order.equals(""first"")) {
            // first: developer could use a little help
            result.addExisting(Path.systemClasspath);
            result.addExisting(this);
        } else if (order.equals(""ignore"")) {
            // ignore: don't trust anyone
            result.addExisting(this);
        } else {
            // last: don't trust the developer
            if (!order.equals(""last"")) {
                project.log(""invalid value for build.sysclasspath: "" + order, 
                            Project.MSG_WARN);
            }
            result.addExisting(this);
            result.addExisting(Path.systemClasspath);
        }
        return result;
    }
}
"
org.apache.tools.ant.types.PatternSet,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.BuildException;
import java.io.*;
import java.util.Enumeration;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;
/**
 * Named collection of include/exclude tags.
 *
 * <p>Moved out of MatchingTask to make it a standalone object that
 * could be referenced (by scripts for example).
 *
 * @author Arnout J. Kuiper <a href=""mailto:ajkuiper@wxs.nl"">ajkuiper@wxs.nl</a> 
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 * @author Sam Ruby <a href=""mailto:rubys@us.ibm.com"">rubys@us.ibm.com</a>
 * @author Jon S. Stevens <a href=""mailto:jon@clearink.com"">jon@clearink.com</a>
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class PatternSet extends DataType {
    private Vector includeList = new Vector();
    private Vector excludeList = new Vector();
    private File incl = null;
    private File excl = null;
    /**
     * inner class to hold a name on list.  ""If"" and ""Unless"" attributes
     * may be used to invalidate the entry based on the existence of a 
     * property (typically set thru the use of the Available task).
     */
    public class NameEntry {
        private String name;
        private String ifCond;
        private String unlessCond;
        public void setName(String name) { 
            this.name = name; 
        }
        public void setIf(String cond) {
            ifCond = cond;
        }
        public void setUnless(String cond) {
            unlessCond = cond;
        }
        public String getName() {
            return name;
        }
        public String evalName(Project p) { 
            return valid(p) ? name : null; 
        }
        private boolean valid(Project p) {
            if (ifCond != null && p.getProperty(ifCond) == null) {
                return false;
            } else if (unlessCond != null && p.getProperty(unlessCond) != null) {
                return false;
            }
            return true;
        }
    }
    public PatternSet() {
        super();
    }
    /**
     * Makes this instance in effect a reference to another PatternSet
     * instance.
     *
     * <p>You must not set another attribute or nest elements inside
     * this element if you make it a reference.</p> 
     */
    public void setRefid(Reference r) throws BuildException {
        if (!includeList.isEmpty() || !excludeList.isEmpty()) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }
    /**
     * add a name entry on the include list
     */
    public NameEntry createInclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(includeList);
    }
    /**
     * add a name entry on the exclude list
     */
    public NameEntry createExclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(excludeList);
    }
    /**
     * Sets the set of include patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param includes the string containing the include patterns
     */
    public void setIncludes(String includes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (includes != null && includes.length() > 0) {
            StringTokenizer tok = new StringTokenizer(includes, "", "", false);
            while (tok.hasMoreTokens()) {
                createInclude().setName(tok.nextToken());
            }
        }
    }
    /**
     * Sets the set of exclude patterns. Patterns may be separated by a comma
     * or a space.
     *
     * @param excludes the string containing the exclude patterns
     */
    public void setExcludes(String excludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (excludes != null && excludes.length() > 0) {
            StringTokenizer tok = new StringTokenizer(excludes, "", "", false);
            while (tok.hasMoreTokens()) {
                createExclude().setName(tok.nextToken());
            }
        }
    }
    /**
     * add a name entry to the given list
     */
    private NameEntry addPatternToList(Vector list) {
        NameEntry result = new NameEntry();
        list.addElement(result);
        return result;
    }
    /**
     * Sets the name of the file containing the includes patterns.
     *
     * @param incl The file to fetch the include patterns from.  
     */
     public void setIncludesfile(File incl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (!incl.exists()) {
             throw new BuildException(""Includesfile ""+incl.getAbsolutePath()
                                      +"" not found."");
         }
         this.incl = incl;
     }
    /**
     * Sets the name of the file containing the excludes patterns.
     *
     * @param excl The file to fetch the exclude patterns from.  
     */
     public void setExcludesfile(File excl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (!excl.exists()) {
             throw new BuildException(""Excludesfile ""+excl.getAbsolutePath()
                                      +"" not found."");
         }
         this.excl = excl;
     }
    /**
     *  Reads path matching patterns from a file and adds them to the
     *  includes or excludes list (as appropriate).  
     */
    private void readPatterns(File patternfile, Vector patternlist, Project p)
        throws BuildException {
        try {
            // Get a FileReader
            BufferedReader patternReader = 
                new BufferedReader(new FileReader(patternfile)); 
            // Create one NameEntry in the appropriate pattern list for each 
            // line in the file.
            String line = patternReader.readLine();
            while (line != null) {
                if (line.length() > 0) {
                    line = ProjectHelper.replaceProperties(p, line,
                                                           p.getProperties());
                    addPatternToList(patternlist).setName(line);
                }
                line = patternReader.readLine();
            }
        } catch(IOException ioe)  {
            String msg = ""An error occured while reading from pattern file: "" 
                + patternfile;
            throw new BuildException(msg, ioe);
        }
    }
    /**
     * Adds the patterns of the other instance to this set.
     */
    public void append(PatternSet other, Project p) {
        if (isReference()) {
            throw new BuildException(""Cannot append to a reference"");
        }
        String[] incl = other.getIncludePatterns(p);
        if (incl != null) {
            for (int i=0; i<incl.length; i++) {
                createInclude().setName(incl[i]);
            }
        }
        String[] excl = other.getExcludePatterns(p);
        if (excl != null) {
            for (int i=0; i<excl.length; i++) {
                createExclude().setName(excl[i]);
            }
        }
    }
    /**
     * Returns the filtered include patterns.
     */
    public String[] getIncludePatterns(Project p) {
        if (isReference()) {
            return getRef(p).getIncludePatterns(p);
        } else {
            readFiles(p);
            return makeArray(includeList, p);
        }
    }
    /**
     * Returns the filtered include patterns.
     */
    public String[] getExcludePatterns(Project p) {
        if (isReference()) {
            return getRef(p).getExcludePatterns(p);
        } else {
            readFiles(p);
            return makeArray(excludeList, p);
        }
    }
    /**
     * helper for FileSet.
     */
    boolean hasPatterns() {
        return incl != null || excl != null
            || includeList.size() > 0 || excludeList.size() > 0;
    }
    /**
     * Performs the check for circular references and returns the
     * referenced PatternSet.  
     */
    private PatternSet getRef(Project p) {
        if (!checked) {
            Stack stk = new Stack();
            stk.push(this);
            dieOnCircularReference(stk, p);
        }
        Object o = ref.getReferencedObject(p);
        if (!(o instanceof PatternSet)) {
            String msg = ref.getRefId()+"" doesn\'t denote a patternset"";
            throw new BuildException(msg);
        } else {
            return (PatternSet) o;
        }
    }
    /**
     * Convert a vector of NameEntry elements into an array of Strings.
     */
    private String[] makeArray(Vector list, Project p) {
        if (list.size() == 0) return null;
        Vector tmpNames = new Vector();
        for (Enumeration e = list.elements() ; e.hasMoreElements() ;) {
            NameEntry ne = (NameEntry)e.nextElement();
            String pattern = ne.evalName(p);
            if (pattern != null && pattern.length() > 0) {
                tmpNames.addElement(pattern);
            }
        }
        String result[] = new String[tmpNames.size()];
        tmpNames.copyInto(result);
        return result;
    }
    /**
     * Read includefile ot excludefile if not already done so.
     */
    private void readFiles(Project p) {
        if (incl != null) {
            readPatterns(incl, includeList, p);
            incl = null;
        }
        if (excl != null) {
            readPatterns(excl, excludeList, p);
            excl = null;
        }
    }
}
"
org.apache.tools.ant.types.Reference,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
/**
 * Class to hold a reference to another object in the project.
 *
 * @author <a href=""mailto:stefan.bodewig@megabit.net"">Stefan Bodewig</a> 
 */
public class Reference {
    private String refid;
    public Reference() {
        super();
    }
    public Reference(String id) {
        this();
        setRefId(id);
    }
    public void setRefId(String id) {
        refid = id;
    }
    public String getRefId() {
        return refid;
    }
    public Object getReferencedObject(Project project) throws BuildException {
        if (refid == null) {
            throw new BuildException(""No reference specified"");
        }
        Object o = project.getReferences().get(refid);
        if (o == null) {
            throw new BuildException(""Reference ""+refid+"" not found."");
        }
        return o;
    }
}
"
org.apache.tools.ant.types.ZipFileSet,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import java.io.File;
import java.util.Stack;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
/**
 * A ZipFileSet is a FileSet with extra attributes useful in the context of 
 * Zip/Jar tasks.
 *
 * A ZipFileSet extends FileSets with the ability to extract a subset of the
 * entries of a Zip file for inclusion in another Zip file.  It also includes
 * a prefix attribute which is prepended to each entry in the output Zip file.
 *
 * At present, ZipFileSets are not surfaced in the public API.  FileSets
 * nested in a Zip task are instantiated as ZipFileSets, and their attributes
 * are only recognized in the context of the the Zip task.
 * It is not possible to define a ZipFileSet outside of the Zip task and
 * refer to it via a refid.  However a standard FileSet may be included by
 * reference in the Zip task, and attributes in the refering ZipFileSet
 * can augment FileSet definition.
 *
 * @author Don Ferguson <a href=""mailto:don@bea.com"">don@bea.com</a>
 */
public class ZipFileSet extends FileSet {
    private File srcFile          = null;
    private String prefix         = """";
    private String fullpath       = """";
    private boolean hasDir        = false;
    /**
     * Set the directory for the fileset.  Prevents both ""dir"" and ""src""
     * from being specified.
     */
    public void setDir(File dir) throws BuildException {
        if (srcFile != null) {
            throw new BuildException(""Cannot set both dir and src attributes"");
        } else {
            super.setDir(dir);
            hasDir = true;
        }
    }
    /**
     * Set the source Zip file for the zipfileset.  Prevents both
     * ""dir"" and ""src"" from being specified.
     *
     * @param srcFile The zip file from which to extract entries.
     */
    public void setSrc(File srcFile) {
        if (hasDir) {
            throw new BuildException(""Cannot set both dir and src attributes"");
        }
        this.srcFile = srcFile;
    }
    /**
     * Get the zip file from which entries will be extracted.
     * References are not followed, since it is not possible
     * to have a reference to a ZipFileSet, only to a FileSet.
     */
    public File getSrc() {
        return srcFile;
    }
    /**
     * Prepend this prefix to the path for each zip entry.
     * Does not perform reference test; the referenced file set
     * can be augmented with a prefix.
     *
     * @param prefix The prefix to prepend to entries in the zip file.
     */
    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }
    /**
     * Return the prefix prepended to entries in the zip file.
     */
    public String getPrefix() {
        return prefix;
    }
    /**
     * Set the full pathname of the single entry in this fileset.
     *
     * @param prefix The prefix to prepend to entries in the zip file.
     */
    public void setFullpath(String fullpath) {
        this.fullpath = fullpath;
    }
    /**
     * Return the full pathname of the single entry in this fileset.
     */
    public String getFullpath() {
        return fullpath;
    }
    /**
     * Return the DirectoryScanner associated with this FileSet.
     * If the ZipFileSet defines a source Zip file, then a ZipScanner
     * is returned instead.
     */
    public DirectoryScanner getDirectoryScanner(Project p) {
        if (isReference()) {
            return getRef(p).getDirectoryScanner(p);
        }
        if (srcFile != null) {
            ZipScanner zs = new ZipScanner();
            zs.setSrc(srcFile);
            super.setDir(new File("".""));
            setupDirectoryScanner(zs, p);
            zs.init();
            return zs;
        } else {
            return super.getDirectoryScanner(p);
        }
    }    
}
"
org.apache.tools.ant.types.ZipScanner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.types;
import org.apache.tools.ant.DirectoryScanner;
import java.io.File;
/**
 * ZipScanner accesses the pattern matching algorithm in DirectoryScanner,
 * which are protected methods that can only be accessed by subclassing.
 *
 * This implementation of FileScanner defines getIncludedFiles to return
 * only the Zip File which is being scanned, not the matching Zip entries.
 * Arguably, it should return the matching entries, however this would
 * complicate existing code which assumes that FileScanners return a
 * set of file system files that can be accessed directly.
 * 
 * @author Don Ferguson <a href=""mailto:don@bea.com"">don@bea.com</a>
 */
public class ZipScanner extends DirectoryScanner {
    /**
     * The zip file which should be scanned.
     */
    protected File srcFile;
    /**
     * Sets the srcFile for scanning. This is the jar or zip file that is scanned
     * for matching entries.
     *
     * @param srcFile the (non-null) zip file name for scanning
     */
    public void setSrc(File srcFile) {
        this.srcFile = srcFile;
    }
    /**
     * Returns the zip file itself, not the matching entries within the zip file.
     * This keeps the uptodate test in the Zip task simple; otherwise we'd need
     * to treat zip filesets specially.
     *
     * @return the source file from which entries will be extracted.
     */
    public String[] getIncludedFiles() {
        String[] result = new String[1];
        result[0] = srcFile.getAbsolutePath();
        return result;
    }
    /**
     * Returns an empty list of directories to create.
     */
    public String[] getIncludedDirectories() {
        return new String[0];
    }
    /**
     * Initialize DirectoryScanner data structures.
     */
    public void init() {
        if (includes == null) {
            // No includes supplied, so set it to 'matches all'
            includes = new String[1];
            includes[0] = ""**"";
        }
        if (excludes == null) {
            excludes = new String[0];
        }
    }
    /**
     * Matches a jar entry against the includes/excludes list,
     * normalizing the path separator.
     *
     * @param path the (non-null) path name to test for inclusion
     *
     * @return <code>true</code> if the path should be included
     *         <code>false</code> otherwise.
     */
    public boolean match(String path) {
        String vpath = path.replace('/', File.separatorChar).
            replace('\\', File.separatorChar);
        return isIncluded(vpath) && !isExcluded(vpath);
    }
}
"
org.apache.tools.ant.util.DOMElementWriter,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
import java.io.*;
import org.w3c.dom.*;
/**
 * Writes a DOM tree to a given Writer.
 *
 * <p>Utility class used by {@link org.apache.tools.ant.XmlLogger
 * XmlLogger} and
 * org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter
 * XMLJUnitResultFormatter}.</p>
 *
 * @author The original author of XmlLogger
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 * @author <a href=""mailto:bailliez@noos.fr"">Stephane Bailliez</tt>
 */
public class DOMElementWriter {
    private static String lSep = System.getProperty(""line.separator"");
    private StringBuffer sb = new StringBuffer();
    /**
     * Don't try to be too smart but at least recognize the predefined
     * entities.
     */
    protected String[] knownEntities = {""gt"", ""amp"", ""lt"", ""apos"", ""quot""};
    /**
     * Writes a DOM tree to a stream.
     *
     * @param element the Root DOM element of the tree
     * @param out where to send the output
     * @param indent number of 
     * @param indentWith strings, 
     *       that should be used to indent the corresponding tag.
     */
    public void write(Element element, Writer out, int indent, 
                      String indentWith)
        throws IOException {
        // Write indent characters
        for (int i = 0; i < indent; i++) {
            out.write(indentWith);
        }
        // Write element
        out.write(""<"");
        out.write(element.getTagName());
        // Write attributes
        NamedNodeMap attrs = element.getAttributes();
        for (int i = 0; i < attrs.getLength(); i++) {
            Attr attr = (Attr) attrs.item(i);
            out.write("" "");
            out.write(attr.getName());
            out.write(""=\"""");
            out.write(encode(attr.getValue()));
            out.write(""\"""");
        }
        out.write("">"");
        // Write child elements and text
        boolean hasChildren = false;
        NodeList children = element.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            switch (child.getNodeType()) {
            case Node.ELEMENT_NODE:
                if (!hasChildren) {
                    out.write(lSep);
                    hasChildren = true;
                }
                write((Element)child, out, indent + 1, indentWith);
                break;
            case Node.TEXT_NODE:
            case Node.CDATA_SECTION_NODE:
                out.write(""<![CDATA["");
                out.write(((Text)child).getData());
                out.write(""]]>"");
                break;
            case Node.ENTITY_REFERENCE_NODE:
                out.write('&');
                out.write(child.getNodeName());
                out.write(';');
                break;
            case Node.PROCESSING_INSTRUCTION_NODE:
                out.write(""<?"");
                out.write(child.getNodeName());
                String data = child.getNodeValue();
                if ( data != null && data.length() > 0 ) {
                    out.write(' ');
                    out.write(data);
                }
                out.write(""?>"");
                break;
            }
        }
        // If we had child elements, we need to indent before we close
        // the element, otherwise we're on the same line and don't need
        // to indent
        if (hasChildren) {
            for (int i = 0; i < indent; i++) {
                out.write(indentWith);
            }
        }
        // Write element close
        out.write(""</"");
        out.write(element.getTagName());
        out.write("">"");
        out.write(lSep);
    }
    /**
     * Escape &lt;, &amp; and &quot; as their entities.
     */
    public String encode(String value) {
        sb.setLength(0);
        for (int i=0; i<value.length(); i++) {
            char c = value.charAt(i);
            switch (c) {
            case '<':
                sb.append(""&lt;"");
                break;
            case '\""':
                sb.append(""&quot;"");
                break;
            case '&':
                int nextSemi = value.indexOf("";"", i);
                if (nextSemi < 0
                    || !isReference(value.substring(i, nextSemi+1))) {
                    sb.append(""&amp;"");
                } else {
                    sb.append('&');
                }
                break;
            default:
                sb.append(c);
                break;
            }
        }
        return sb.toString();
    }
    /**
     * Is the given argument a character or entity reference?
     */
    public boolean isReference(String ent) {
        if (!(ent.charAt(0) == '&') || !ent.endsWith("";"")) {
            return false;
        }
        if (ent.charAt(1) == '#') {
            if (ent.charAt(2) == 'x') {
                try {
                    Integer.parseInt(ent.substring(3, ent.length()-1), 16);
                    return true;
                } catch (NumberFormatException nfe) {
                    return false;
                }
            } else {
                try {
                    Integer.parseInt(ent.substring(2, ent.length()-1));
                    return true;
                } catch (NumberFormatException nfe) {
                    return false;
                }
            }
        }
        String name = ent.substring(1, ent.length() - 1);
        for (int i=0; i<knownEntities.length; i++) {
            if (name.equals(knownEntities[i])) {
                return true;
            }
        }
        return false;
    }
}
"
org.apache.tools.ant.util.FileNameMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
/**
 * Interface to be used by SourceFileScanner.
 *
 * <p>Used to find the name of the target file(s) corresponding to a
 * source file.</p>
 *
 * <p>The rule by which the file names are transformed is specified
 * via the setFrom and setTo methods. The exact meaning of these is
 * implementation dependent.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public interface FileNameMapper {
    /**
     * Sets the from part of the transformation rule.
     */
    public void setFrom(String from);
    /**
     * Sets the to part of the transformation rule.
     */
    public void setTo(String to);
    /**
     * Returns an array containing the target filename(s) for the
     * given source file.
     *
     * <p>if the given rule doesn't apply to the source file,
     * implementation must return null. SourceFileScanner will then
     * omit the source file in question.</p> 
     *
     * @param sourceFileName the name of the source file relative to
     *                       some given basedirectory.
     */
    public String[] mapFileName(String sourceFileName);
}
"
org.apache.tools.ant.util.FlatFileNameMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
/**
 * Implementation of FileNameMapper that always returns the source
 * file name without any leading directory information.
 *
 * <p>This is the default FileNameMapper for the copy and move
 * tasks if the flatten attribute has been set.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class FlatFileNameMapper implements FileNameMapper {
    /**
     * Ignored.
     */
    public void setFrom(String from) {}
    /**
     * Ignored.
     */
    public void setTo(String to) {}
    /**
     * Returns an one-element array containing the source file name
     * without any leading directory information.
     */
    public String[] mapFileName(String sourceFileName) {
        return new String[] {new java.io.File(sourceFileName).getName()};
    }
}
"
org.apache.tools.ant.util.GlobPatternMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
/**
 * Implementation of FileNameMapper that does simple wildcard pattern
 * replacements.
 *
 * <p>This does simple translations like *.foo -> *.bar where the
 * prefix to .foo will be left unchanged. It only handles a single *
 * character, use regular expressions for more complicated
 * situations.</p>
 *
 * <p>This is one of the more useful Mappers, it is used by javac for
 * example.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class GlobPatternMapper implements FileNameMapper {
    /**
     * Part of &quot;from&quot; pattern before the *.
     */
    protected String fromPrefix = null;
    /**
     * Part of &quot;from&quot; pattern after the *.
     */
    protected String fromPostfix = null;
    /**
     * Length of the prefix (&quot;from&quot; pattern).
     */
    protected int prefixLength;
    /**
     * Length of the postfix (&quot;from&quot; pattern).
     */
    protected int postfixLength;
    /**
     * Part of &quot;to&quot; pattern before the *.
     */
    protected String toPrefix = null;
    /**
     * Part of &quot;to&quot; pattern after the *.
     */
    protected String toPostfix = null;
    /**
     * Sets the &quot;from&quot; pattern. Required.
     */
    public void setFrom(String from) {
        int index = from.lastIndexOf(""*"");
        if (index == -1) {
            fromPrefix = from;
            fromPostfix = """";
        } else {
            fromPrefix = from.substring(0, index);
            fromPostfix = from.substring(index+1);
        }
        prefixLength = fromPrefix.length();
        postfixLength = fromPostfix.length();
    }
    /**
     * Sets the &quot;to&quot; pattern. Required.
     */
    public void setTo(String to) {
        int index = to.lastIndexOf(""*"");
        if (index == -1) {
            toPrefix = to;
            toPostfix = """";
        } else {
            toPrefix = to.substring(0, index);
            toPostfix = to.substring(index+1);
        }
    }
    /**
     * Returns null if the source file name doesn't match the
     * &quot;from&quot; pattern, an one-element array containing the
     * translated file otherwise.
     */
    public String[] mapFileName(String sourceFileName) {
        if (fromPrefix == null 
            || !sourceFileName.startsWith(fromPrefix) 
            || !sourceFileName.endsWith(fromPostfix)) {
            return null;
        }
        return new String[] {toPrefix 
                                 + extractVariablePart(sourceFileName)
                                 + toPostfix};
    }
    /**
     * Returns the part of the given string that matches the * in the
     * &quot;from&quot; pattern.
     */
    protected String extractVariablePart(String name) {
        return name.substring(prefixLength,
                              name.length() - postfixLength);
    }
}
"
org.apache.tools.ant.util.IdentityMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
/**
 * Implementation of FileNameMapper that always returns the source file name.
 *
 * <p>This is the default FileNameMapper for the copy and move
 * tasks.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class IdentityMapper implements FileNameMapper {
    /**
     * Ignored.
     */
    public void setFrom(String from) {}
    /**
     * Ignored.
     */
    public void setTo(String to) {}
    /**
     * Returns an one-element array containing the source file name.
     */
    public String[] mapFileName(String sourceFileName) {
        return new String[] {sourceFileName};
    }
}
"
org.apache.tools.ant.util.MergingMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
/**
 * Implementation of FileNameMapper that always returns the same
 * target file name.
 *
 * <p>This is the default FileNameMapper for the archiving tasks and
 * uptodate.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class MergingMapper implements FileNameMapper {
    protected String[] mergedFile = null;
    /**
     * Ignored.
     */
    public void setFrom(String from) {}
    /**
     * Sets the name of the merged file.
     */
    public void setTo(String to) {
        mergedFile = new String[] {to};
    }
    /**
     * Returns an one-element array containing the file name set via setTo.
     */
    public String[] mapFileName(String sourceFileName) {
        return mergedFile;
    }
}
"
org.apache.tools.ant.util.RegexpPatternMapper,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.regexp.RegexpMatcher;
import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;
import java.util.Enumeration;
import java.util.Vector;
/**
 * Implementation of FileNameMapper that does regular expression
 * replacements.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class RegexpPatternMapper implements FileNameMapper {
    protected RegexpMatcher reg = null;
    protected char[] to = null;
    protected StringBuffer result = new StringBuffer();
    public RegexpPatternMapper() throws BuildException {
        reg = (new RegexpMatcherFactory()).newRegexpMatcher();
    }
    /**
     * Sets the &quot;from&quot; pattern. Required.
     */
    public void setFrom(String from) throws BuildException {
        try {
            reg.setPattern(from);
        } catch (NoClassDefFoundError e) {
            // depending on the implementation the actual RE won't
            // get instantiated in the constructor.
            throw new BuildException(""Cannot load regular expression matcher"",
                                     e);
        }
    }
    /**
     * Sets the &quot;to&quot; pattern. Required.
     */
    public void setTo(String to) {
        this.to = to.toCharArray();
    }
    /**
     * Returns null if the source file name doesn't match the
     * &quot;from&quot; pattern, an one-element array containing the
     * translated file otherwise.
     */
    public String[] mapFileName(String sourceFileName) {
        if (reg == null  || to == null
            || !reg.matches(sourceFileName)) {
            return null;
        }
        return new String[] {replaceReferences(sourceFileName)};
    }
    /**
     * Replace all backreferences in the to pattern with the matched
     * groups of the source.
     */
    protected String replaceReferences(String source) {
        Vector v = reg.getGroups(source);
        result.setLength(0);
        for (int i=0; i<to.length; i++) {
            if (to[i] == '\\') {
                if (++i < to.length) {
                    int value = Character.digit(to[i], 10);
                    if (value > -1) {
                        result.append((String) v.elementAt(value));
                    } else {
                        result.append(to[i]);
                    }
                } else {
                    // XXX - should throw an exception instead?
                    result.append('\\');
                }
            } else {
                result.append(to[i]);
            }
        }
        return result.toString();
    }
}
"
org.apache.tools.ant.util.SourceFileScanner,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import java.io.File;
import java.util.Vector;
/**
 * Utility class that collects the functionality of the various
 * scanDir methods that have been scattered in several tasks before.
 *
 * <p>The only method returns an array of source files. The array is a
 * subset of the files given as a parameter and holds only those that
 * are newer than their corresponding target files.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a>
 */
public class SourceFileScanner {
    protected Task task;
    /**
     * @param task The task we should log messages through
     */
    public SourceFileScanner(Task task) {
        this.task = task;
    }
    /**
     * Restrict the given set of files to those that are newer than
     * their corresponding target files.
     *
     * @param files   the original set of files
     * @param srcDir  all files are relative to this directory
     * @param destDir target files live here. if null file names
     *                returned by the mapper are assumed to be absolute.
     * @param mapper  knows how to construct a target file names from
     *                source file names.
     */
    public String[] restrict(String[] files, File srcDir, File destDir,
                             FileNameMapper mapper) {
        long now = (new java.util.Date()).getTime();
        StringBuffer targetList = new StringBuffer();
        /*
          If we're on Windows, we have to munge the time up to 2 secs to
          be able to check file modification times.
          (Windows has a max resolution of two secs for modification times)
        */
        String osname = System.getProperty(""os.name"").toLowerCase();
        if ( osname.indexOf(""windows"") >= 0 ) {
            now += 2000;
        }
        Vector v = new Vector();
        for (int i=0; i< files.length; i++) {
            String[] targets = mapper.mapFileName(files[i]);
            if (targets == null || targets.length == 0) {
                task.log(files[i]+"" skipped - don\'t know how to handle it"",
                         Project.MSG_VERBOSE);
                continue;
            }
            File src = new File(srcDir, files[i]);
            if (src.lastModified() > now) {
                task.log(""Warning: ""+files[i]+"" modified in the future."", 
                         Project.MSG_WARN);
            }
            boolean added = false;
            targetList.setLength(0);
            for (int j=0; !added && j<targets.length; j++) {
                File dest = null;
                if (destDir == null) {
                    dest = new File(targets[j]);
                } else {
                    dest = new File(destDir, targets[j]);
                }
                if (!dest.exists()) {
                    task.log(files[i]+"" added as ""+dest.getAbsolutePath()+"" doesn\'t exist."",
                             Project.MSG_VERBOSE);
                    v.addElement(files[i]);
                    added = true;
                } else if (src.lastModified() > dest.lastModified()) {
                    task.log(files[i]+"" added as ""+dest.getAbsolutePath()+"" is outdated."",
                             Project.MSG_VERBOSE);
                    v.addElement(files[i]);
                    added = true;
                } else {
                    if (targetList.length() > 0) {
                        targetList.append("", "");
                    }
                    targetList.append(dest.getAbsolutePath());
                }
            }
            if (!added) {
                task.log(files[i]+"" omitted as ""+targetList.toString()
                         + (targets.length == 1 ? "" is"" : "" are "")
                         + "" up to date."", Project.MSG_VERBOSE);
            }
        }
        String[] result = new String[v.size()];
        v.copyInto(result);
        return result;
    }
    /**
     * Convinience layer on top of restrict that returns the source
     * files as File objects (containing absolute paths if srcDir is
     * absolute).
     */
    public File[] restrictAsFiles(String[] files, File srcDir, File destDir,
                                  FileNameMapper mapper) {
        String[] res = restrict(files, srcDir, destDir, mapper);
        File[] result = new File[res.length];
        for (int i=0; i<res.length; i++) {
            result[i] = new File(srcDir, res[i]);
        }
        return result;
    }
}
"
org.apache.tools.ant.util.regexp.JakartaOroMatcher,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util.regexp;
import org.apache.oro.text.regex.*;
import org.apache.tools.ant.BuildException;
import java.util.Vector;
/**
 * Implementation of RegexpMatcher for Jakarta-ORO.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class JakartaOroMatcher implements RegexpMatcher {
    protected Perl5Matcher reg = new Perl5Matcher();
    protected Perl5Compiler comp = new Perl5Compiler();
    private Pattern pattern;
    /**
     * Set the regexp pattern from the String description.
     */
    public void setPattern(String pattern) throws BuildException {
        try {
            this.pattern = comp.compile(pattern);
        } catch (MalformedPatternException e) {
            throw new BuildException(e);
        }
    }
    /**
     * Get a String representation of the regexp pattern
     */
    public String getPattern() {
        return pattern.getPattern();
    }
    /**
     * Does the given argument match the pattern?
     */
    public boolean matches(String argument) {
        return reg.contains(argument, pattern);
    }
    /**
     * Returns a Vector of matched groups found in the argument.
     *
     * <p>Group 0 will be the full match, the rest are the
     * parenthesized subexpressions</p>.
     */
    public Vector getGroups(String argument) {
        if (!matches(argument)) {
            return null;
        }
        Vector v = new Vector();
        MatchResult mr = reg.getMatch();
        for (int i=0; i<mr.groups(); i++) {
            v.addElement(mr.group(i));
        }
        return v;
    }
}
"
org.apache.tools.ant.util.regexp.JakartaRegexpMatcher,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util.regexp;
import org.apache.regexp.*;
import org.apache.tools.ant.BuildException;
import java.util.Vector;
/**
 * Implementation of RegexpMatcher for Jakarta-Regexp.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class JakartaRegexpMatcher implements RegexpMatcher {
    protected RE reg = null;
    private String pattern;
    /**
     * Set the regexp pattern from the String description.
     */
    public void setPattern(String pattern) throws BuildException {
        try {
            this.pattern = pattern;
            reg = new RE(pattern);
        } catch (RESyntaxException e) {
            throw new BuildException(e);
        }
    }
    /**
     * Get a String representation of the regexp pattern
     */
    public String getPattern() {
        return pattern;
    }
    /**
     * Does the given argument match the pattern?
     */
    public boolean matches(String argument) {
        return reg.match(argument);
    }
    /**
     * Returns a Vector of matched groups found in the argument.
     *
     * <p>Group 0 will be the full match, the rest are the
     * parenthesized subexpressions</p>.
     */
    public Vector getGroups(String argument) {
        if (!matches(argument)) {
            return null;
        }
        Vector v = new Vector();
        for (int i=0; i<reg.getParenCount(); i++) {
            v.addElement(reg.getParen(i));
        }
        return v;
    }
}
"
org.apache.tools.ant.util.regexp.RegexpMatcher,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util.regexp;
import org.apache.tools.ant.BuildException;
import java.util.Vector;
/**
 * Interface describing a regular expression matcher.
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public interface RegexpMatcher {
    /**
     * Set the regexp pattern from the String description.
     */
    public void setPattern(String pattern) throws BuildException;
    /**
     * Get a String representation of the regexp pattern
     */
    public String getPattern();
    /**
     * Does the given argument match the pattern?
     */
    public boolean matches(String argument);
    /**
     * Returns a Vector of matched groups found in the argument.
     *
     * <p>Group 0 will be the full match, the rest are the
     * parenthesized subexpressions</p>.
     */
    public Vector getGroups(String argument);
}
"
org.apache.tools.ant.util.regexp.RegexpMatcherFactory,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.tools.ant.util.regexp;
import org.apache.tools.ant.BuildException;
/**
 * Simple Factory Class that produces an implementation of
 * RegexpMatcher based on the system property
 * <code>ant.regexp.matcherimpl</code> and the classes
 * available.
 * 
 * <p>In a more general framework this class would be abstract and
 * have a static newInstance method.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class RegexpMatcherFactory {
    public RegexpMatcherFactory() {}
    public RegexpMatcher newRegexpMatcher() throws BuildException {
        String systemDefault = System.getProperty(""ant.regexp.matcherimpl"");
        if (systemDefault != null) {
            return createInstance(systemDefault);
            // XXX     should we silently possible exceptions and try to 
            //         load a different implementation?
        }
        try {
            return createInstance(""org.apache.tools.ant.util.regexp.JakartaOroMatcher"");
        } catch (BuildException be) {}
        try {
            return createInstance(""org.apache.tools.ant.util.regexp.JakartaRegexpMatcher"");
        } catch (BuildException be) {}
        throw new BuildException(""No supported regular expression matcher found"");
   }
    protected RegexpMatcher createInstance(String className) 
        throws BuildException {
        try {
            Class implClass = Class.forName(className);
            return (RegexpMatcher) implClass.newInstance();
        } catch (Throwable t) {
            throw new BuildException(t);
        }
    }
}
"
org.apache.tools.mail.MailMessage,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 */
/*
 * The original version of this class was donated by Jason Hunter,
 * who wrote the class as part of the com.oreilly.servlet
 * package for his book ""Java Servlet Programming"" (O'Reilly).
 * See http://www.servlets.com.
 * 
 */
package org.apache.tools.mail;
import java.io.*;
import java.net.*;
import java.util.*;
/** 
 * A class to help send SMTP email.
 * This class is an improvement on the sun.net.smtp.SmtpClient class 
 * found in the JDK.  This version has extra functionality, and can be used
 * with JVMs that did not extend from the JDK.  It's not as robust as
 * the JavaMail Standard Extension classes, but it's easier to use and 
 * easier to install, and has an Open Source license.
 * <p>
 * It can be used like this:
 * <blockquote><pre>
 * String mailhost = ""localhost"";  // or another mail host
 * String from = ""Mail Message Servlet &lt;MailMessage@server.com&gt;"";
 * String to = ""to@you.com"";
 * String cc1 = ""cc1@you.com"";
 * String cc2 = ""cc2@you.com"";
 * String bcc = ""bcc@you.com"";
 * &nbsp;
 * MailMessage msg = new MailMessage(mailhost);
 * msg.from(from);
 * msg.to(to);
 * msg.cc(cc1);
 * msg.cc(cc2);
 * msg.bcc(bcc);
 * msg.setSubject(""Test subject"");
 * PrintStream out = msg.getPrintStream();
 * &nbsp;
 * Enumeration enum = req.getParameterNames();
 * while (enum.hasMoreElements()) {
 *   String name = (String)enum.nextElement();
 *   String value = req.getParameter(name);
 *   out.println(name + "" = "" + value);
 * }
 * &nbsp;
 * msg.sendAndClose();
 * </pre></blockquote>
 * <p>
 * Be sure to set the from address, then set the recepient 
 * addresses, then set the subject and other headers, then get the 
 * PrintStream, then write the message, and finally send and close.
 * The class does minimal error checking internally; it counts on the mail
 * host to complain if there's any malformatted input or out of order 
 * execution.  
 * <p>
 * An attachment mechanism based on RFC 1521 could be implemented on top of
 * this class.  In the meanwhile, JavaMail is the best solution for sending
 * email with attachments.
 * <p>
 * Still to do:
 * <ul>
 * <li>Figure out how to close the connection in case of error
 * </ul>
 *
 * @author Jason Hunter
 * @version 1.1, 2000/03/19, added angle brackets to address, helps some servers
 * version 1.0, 1999/12/29
 */
public class MailMessage {
  String host;
  String from;
  Vector to, cc;
  Hashtable headers;
  MailPrintStream out;
  SmtpResponseReader in;
  Socket socket;
  /**
   * Constructs a new MailMessage to send an email.
   * Use localhost as the mail server.
   *
   * @exception IOException if there's any problem contacting the mail server
   */
  public MailMessage() throws IOException {
    this(""localhost"");
  }
  /**
   * Constructs a new MailMessage to send an email.
   * Use the given host as the mail server.
   *
   * @param host the mail server to use
   * @exception IOException if there's any problem contacting the mail server
   */
  public MailMessage(String host) throws IOException {
    this.host = host;
    to = new Vector();
    cc = new Vector();
    headers = new Hashtable();
    setHeader(""X-Mailer"", ""org.apache.tools.mail.MailMessage (jakarta.apache.org)"");
    connect();
    sendHelo();
  }
  /**
   * Sets the from address.  Also sets the ""From"" header.  This method should
   * be called only once.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public void from(String from) throws IOException {
    sendFrom(from);
    this.from = from;
  }
  /**
   * Sets the to address.  Also sets the ""To"" header.  This method may be
   * called multiple times.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public void to(String to) throws IOException {
    sendRcpt(to);
    this.to.addElement(to);
  }
  /**
   * Sets the cc address.  Also sets the ""Cc"" header.  This method may be
   * called multiple times.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public void cc(String cc) throws IOException {
    sendRcpt(cc);
    this.cc.addElement(cc);
  }
  /**
   * Sets the bcc address.  Does NOT set any header since it's a *blind* copy.
   * This method may be called multiple times.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public void bcc(String bcc) throws IOException {
    sendRcpt(bcc);
    // No need to keep track of Bcc'd addresses
  }
  /**
   * Sets the subject of the mail message.  Actually sets the ""Subject"" 
   * header.
   */
  public void setSubject(String subj) {
    headers.put(""Subject"", subj);
  }
  /**
   * Sets the named header to the given value.  RFC 822 provides the rules for
   * what text may constitute a header name and value.
   */
  public void setHeader(String name, String value) {
    // Blindly trust the user doesn't set any invalid headers
    headers.put(name, value);
  }
  /**
   * Returns a PrintStream that can be used to write the body of the message.
   * A stream is used since email bodies are byte-oriented.  A writer could 
   * be wrapped on top if necessary for internationalization.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public PrintStream getPrintStream() throws IOException {
    setFromHeader();
    setToHeader();
    setCcHeader();
    sendData();
    flushHeaders();
    return out;
  }
  void setFromHeader() {
    setHeader(""From"", from);
  }
  void setToHeader() {
    setHeader(""To"", vectorToList(to));
  }
  void setCcHeader() {
    setHeader(""Cc"", vectorToList(cc));
  }
  String vectorToList(Vector v) {
    StringBuffer buf = new StringBuffer();
    Enumeration e = v.elements();
    while (e.hasMoreElements()) {
      buf.append(e.nextElement());
      if (e.hasMoreElements()) {
        buf.append("", "");
      }
    }
    return buf.toString();
  }
  void flushHeaders() throws IOException {
    // XXX Should I care about order here?
    Enumeration e = headers.keys();
    while (e.hasMoreElements()) {
      String name = (String) e.nextElement();
      String value = (String) headers.get(name);
      out.println(name + "": "" + value);
    }
    out.println();
    out.flush();
  }
  /**
   * Sends the message and closes the connection to the server.
   * The MailMessage object cannot be reused.
   *
   * @exception IOException if there's any problem reported by the mail server
   */
  public void sendAndClose() throws IOException {
    sendDot();
    sendQuit();
    disconnect();
  }
  // Make a limited attempt to extract a sanitized email address
  // Prefer text in <brackets>, ignore anything in (parentheses)
  static String sanitizeAddress(String s) {
    int paramDepth = 0;
    int start = 0;
    int end = 0;
    int len = s.length();
    for (int i = 0; i < len; i++) {
      char c = s.charAt(i);
      if (c == '(') {
        paramDepth++;
        if (start == 0) {
          end = i;  // support ""address (name)""
        }
      }
      else if (c == ')') {
        paramDepth--;
        if (end == 0) {
          start = i + 1;  // support ""(name) address""
        }
      }
      else if (paramDepth == 0 && c == '<') {
        start = i + 1;
      }
      else if (paramDepth == 0 && c == '>') {
        end = i;
      }
    }
    if (end == 0) {
      end = len;
    }
    return s.substring(start, end);
  }
  // * * * * * Raw protocol methods below here * * * * *
  void connect() throws IOException {
    socket = new Socket(host, 25);
    out = new MailPrintStream(
          new BufferedOutputStream(
          socket.getOutputStream())); 
    in = new SmtpResponseReader(socket.getInputStream());
    getReady();
  }
  void getReady() throws IOException {
    String response = in.getResponse();
    int[] ok = { 220 };
    if (!isResponseOK(response, ok)) {
      throw new IOException(
        ""Didn't get introduction from server: "" + response);
    }
  }
  void sendHelo() throws IOException {
    String local = InetAddress.getLocalHost().getHostName();
    int[] ok = { 250 };
    send(""HELO "" + local, ok);
  }
  void sendFrom(String from) throws IOException {
    int[] ok = { 250 };
    send(""MAIL FROM: "" + ""<"" + sanitizeAddress(from) + "">"", ok);
  }
  void sendRcpt(String rcpt) throws IOException {
    int[] ok = { 250, 251 };
    send(""RCPT TO: "" + ""<"" + sanitizeAddress(rcpt) + "">"", ok);
  }
  void sendData() throws IOException {
    int[] ok = { 354 };
    send(""DATA"", ok);
  }
  void sendDot() throws IOException {
    int[] ok = { 250 };
    send(""\r\n."", ok);  // make sure dot is on new line
  }
  void sendQuit() throws IOException {
    int[] ok = { 221 };
    send(""QUIT"", ok);
  }
  void send(String msg, int[] ok) throws IOException {
    out.rawPrint(msg + ""\r\n"");  // raw supports <CRLF>.<CRLF>
    //System.out.println(""S: "" + msg);
    String response = in.getResponse();
    //System.out.println(""R: "" + response);
    if (!isResponseOK(response, ok)) {
      throw new IOException(
        ""Unexpected reply to command: "" + msg + "": "" + response);
    }
  }
  boolean isResponseOK(String response, int[] ok) {
    // Check that the response is one of the valid codes
    for (int i = 0; i < ok.length; i++) {
      if (response.startsWith("""" + ok[i])) {
        return true;
      }
    }
    return false;
  }
  void disconnect() throws IOException {
    if (out != null) out.close(); 
    if (in != null) in.close(); 
    if (socket != null) socket.close();
  }
}
// This PrintStream subclass makes sure that <CRLF>. becomes <CRLF>..
// per RFC 821.  It also ensures that new lines are always \r\n.
//
class MailPrintStream extends PrintStream {
  int lastChar;
  public MailPrintStream(OutputStream out) {
    super(out, true);  // deprecated, but email is byte-oriented
  }
  // Mac does \n\r, but that's tough to distinguish from Windows \r\n\r\n.
  // Don't tackle that problem right now.
  public void write(int b) {
    if (b == '\n' && lastChar != '\r') {
      rawWrite('\r');  // ensure always \r\n
      rawWrite(b);
    }
    else if (b == '.' && lastChar == '\n') {
      rawWrite('.');  // add extra dot
      rawWrite(b);
    }
    else {
      rawWrite(b);
    }
    lastChar = b;
  }
  public void write(byte buf[], int off, int len) {
    for (int i = 0; i < len; i++) {
      write(buf[off + i]);
    }
  }
  void rawWrite(int b) {
    super.write(b);
  }
  void rawPrint(String s) {
    int len = s.length();
    for (int i = 0; i < len; i++) {
      rawWrite(s.charAt(i));
    }
  }
}
"
org.apache.tools.mail.SmtpResponseReader,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 */
package org.apache.tools.mail;
import java.io.*;
/**
 * A wrapper around the raw input from the SMTP server that assembles
 * multi line responses into a single String.
 *
 * <p>The same rules used here would apply to FTP and other Telnet
 * based protocols as well.</p>
 *
 * @author <a href=""mailto:stefan.bodewig@epost.de"">Stefan Bodewig</a> 
 */
public class SmtpResponseReader {
    protected BufferedReader reader = null;
    private StringBuffer result = new StringBuffer();
    /**
     * Wrap this input stream.
     */
    public SmtpResponseReader(InputStream in) {
        reader = new BufferedReader(new InputStreamReader(in)); 
    }
    /**
     * Read until the server indicates that the response is complete.
     *
     * @return Responsecode (3 digits) + Blank + Text from all
     *         response line concatenated (with blanks replacing the \r\n
     *         sequences).
     */
    public String getResponse() throws IOException {
        result.setLength(0);
        String line = reader.readLine();
        if (line != null) {
            result.append(line.substring(0, 3));
            result.append("" "");
        }
        while (line != null) {
            append(line);
            if (!hasMoreLines(line)) {
                break;
            }
            line = reader.readLine();
        }
        return result.toString().trim();
    }
    /**
     * Closes the underlying stream.
     */
    public void close() throws IOException {
        reader.close();
    }
    /**
     * Should we expect more input?
     */
    protected boolean hasMoreLines(String line) {
        return line.charAt(3) == '-';
    }
    /**
     * Append the text from this line of the resonse.
     */
    private void append(String line) {
        result.append(line.substring(4));
        result.append("" "");
    }
}
"
org.apache.tools.tar.TarBuffer,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
import java.io.*;
/**
 * The TarBuffer class implements the tar archive concept
 * of a buffered input stream. This concept goes back to the
 * days of blocked tape drives and special io devices. In the
 * Java universe, the only real function that this class
 * performs is to ensure that files have the correct ""block""
 * size, or other tars will complain.
 * <p>
 * You should never have a need to access this class directly.
 * TarBuffers are created by Tar IO Streams.
 * 
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 */
public class TarBuffer {
    public static final int DEFAULT_RCDSIZE = (512);
    public static final int DEFAULT_BLKSIZE = (DEFAULT_RCDSIZE * 20);
    private InputStream     inStream;
    private OutputStream    outStream;
    private byte[]          blockBuffer;
    private int             currBlkIdx;
    private int             currRecIdx;
    private int             blockSize;
    private int             recordSize;
    private int             recsPerBlock;
    private boolean         debug;
    public TarBuffer(InputStream inStream) {
        this(inStream, TarBuffer.DEFAULT_BLKSIZE);
    }
    public TarBuffer(InputStream inStream, int blockSize) {
        this(inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarBuffer(InputStream inStream, int blockSize, int recordSize) {
        this.inStream = inStream;
        this.outStream = null;
        this.initialize(blockSize, recordSize);
    }
    public TarBuffer(OutputStream outStream) {
        this(outStream, TarBuffer.DEFAULT_BLKSIZE);
    }
    public TarBuffer(OutputStream outStream, int blockSize) {
        this(outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {
        this.inStream = null;
        this.outStream = outStream;
        this.initialize(blockSize, recordSize);
    }
    /**
     * Initialization common to all constructors.
     */
    private void initialize(int blockSize, int recordSize) {
        this.debug = false;
        this.blockSize = blockSize;
        this.recordSize = recordSize;
        this.recsPerBlock = (this.blockSize / this.recordSize);
        this.blockBuffer = new byte[this.blockSize];
        if (this.inStream != null) {
            this.currBlkIdx = -1;
            this.currRecIdx = this.recsPerBlock;
        } else {
            this.currBlkIdx = 0;
            this.currRecIdx = 0;
        } 
    } 
    /**
     * Get the TAR Buffer's block size. Blocks consist of multiple records.
     */
    public int getBlockSize() {
        return this.blockSize;
    } 
    /**
     * Get the TAR Buffer's record size.
     */
    public int getRecordSize() {
        return this.recordSize;
    } 
    /**
     * Set the debugging flag for the buffer.
     * 
     * @param debug If true, print debugging output.
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    } 
    /**
     * Determine if an archive record indicate End of Archive. End of
     * archive is indicated by a record that consists entirely of null bytes.
     * 
     * @param record The record data to check.
     */
    public boolean isEOFRecord(byte[] record) {
        for (int i = 0, sz = this.getRecordSize(); i < sz; ++i) {
            if (record[i] != 0) {
                return false;
            } 
        }
        return true;
    } 
    /**
     * Skip over a record on the input stream.
     */
    public void skipRecord() throws IOException {
        if (this.debug) {
            System.err.println(""SkipRecord: recIdx = "" + this.currRecIdx 
                               + "" blkIdx = "" + this.currBlkIdx);
        } 
        if (this.inStream == null) {
            throw new IOException(""reading (via skip) from an output buffer"");
        } 
        if (this.currRecIdx >= this.recsPerBlock) {
            if (!this.readBlock()) {
                return;    // UNDONE
            } 
        } 
        this.currRecIdx++;
    } 
    /**
     * Read a record from the input stream and return the data.
     * 
     * @return The record data.
     */
    public byte[] readRecord() throws IOException {
        if (this.debug) {
            System.err.println(""ReadRecord: recIdx = "" + this.currRecIdx 
                               + "" blkIdx = "" + this.currBlkIdx);
        } 
        if (this.inStream == null) {
            throw new IOException(""reading from an output buffer"");
        } 
        if (this.currRecIdx >= this.recsPerBlock) {
            if (!this.readBlock()) {
                return null;
            } 
        } 
        byte[] result = new byte[this.recordSize];
        System.arraycopy(this.blockBuffer, 
                         (this.currRecIdx * this.recordSize), result, 0, 
                         this.recordSize);
        this.currRecIdx++;
        return result;
    } 
    /**
     * @return false if End-Of-File, else true
     */
    private boolean readBlock() throws IOException {
        if (this.debug) {
            System.err.println(""ReadBlock: blkIdx = "" + this.currBlkIdx);
        } 
        if (this.inStream == null) {
            throw new IOException(""reading from an output buffer"");
        } 
        this.currRecIdx = 0;
        int offset = 0;
        int bytesNeeded = this.blockSize;
        while (bytesNeeded > 0) {
            long numBytes = this.inStream.read(this.blockBuffer, offset, 
                                               bytesNeeded);
            // 
            // NOTE
            // We have fit EOF, and the block is not full!
            // 
            // This is a broken archive. It does not follow the standard
            // blocking algorithm. However, because we are generous, and
            // it requires little effort, we will simply ignore the error
            // and continue as if the entire block were read. This does
            // not appear to break anything upstream. We used to return
            // false in this case.
            // 
            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.
            // 
            if (numBytes == -1) {
                break;
            } 
            offset += numBytes;
            bytesNeeded -= numBytes;
            if (numBytes != this.blockSize) {
                if (this.debug) {
                    System.err.println(""ReadBlock: INCOMPLETE READ "" 
                                       + numBytes + "" of "" + this.blockSize 
                                       + "" bytes read."");
                } 
            } 
        } 
        this.currBlkIdx++;
        return true;
    } 
    /**
     * Get the current block number, zero based.
     * 
     * @return The current zero based block number.
     */
    public int getCurrentBlockNum() {
        return this.currBlkIdx;
    } 
    /**
     * Get the current record number, within the current block, zero based.
     * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.
     * 
     * @return The current zero based record number.
     */
    public int getCurrentRecordNum() {
        return this.currRecIdx - 1;
    } 
    /**
     * Write an archive record to the archive.
     * 
     * @param record The record data to write to the archive.
     */
    public void writeRecord(byte[] record) throws IOException {
        if (this.debug) {
            System.err.println(""WriteRecord: recIdx = "" + this.currRecIdx 
                               + "" blkIdx = "" + this.currBlkIdx);
        } 
        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        } 
        if (record.length != this.recordSize) {
            throw new IOException(""record to write has length '"" 
                                  + record.length 
                                  + ""' which is not the record size of '"" 
                                  + this.recordSize + ""'"");
        } 
        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock();
        } 
        System.arraycopy(record, 0, this.blockBuffer, 
                         (this.currRecIdx * this.recordSize), 
                         this.recordSize);
        this.currRecIdx++;
    } 
    /**
     * Write an archive record to the archive, where the record may be
     * inside of a larger array buffer. The buffer must be ""offset plus
     * record size"" long.
     * 
     * @param buf The buffer containing the record data to write.
     * @param offset The offset of the record data within buf.
     */
    public void writeRecord(byte[] buf, int offset) throws IOException {
        if (this.debug) {
            System.err.println(""WriteRecord: recIdx = "" + this.currRecIdx 
                               + "" blkIdx = "" + this.currBlkIdx);
        } 
        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        } 
        if ((offset + this.recordSize) > buf.length) {
            throw new IOException(""record has length '"" + buf.length 
                                  + ""' with offset '"" + offset 
                                  + ""' which is less than the record size of '"" 
                                  + this.recordSize + ""'"");
        } 
        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock();
        } 
        System.arraycopy(buf, offset, this.blockBuffer, 
                         (this.currRecIdx * this.recordSize), 
                         this.recordSize);
        this.currRecIdx++;
    } 
    /**
     * Write a TarBuffer block to the archive.
     */
    private void writeBlock() throws IOException {
        if (this.debug) {
            System.err.println(""WriteBlock: blkIdx = "" + this.currBlkIdx);
        } 
        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        } 
        this.outStream.write(this.blockBuffer, 0, this.blockSize);
        this.outStream.flush();
        this.currRecIdx = 0;
        this.currBlkIdx++;
    } 
    /**
     * Flush the current data block if it has any data in it.
     */
    private void flushBlock() throws IOException {
        if (this.debug) {
            System.err.println(""TarBuffer.flushBlock() called."");
        } 
        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        } 
        if (this.currRecIdx > 0) {
            this.writeBlock();
        } 
    } 
    /**
     * Close the TarBuffer. If this is an output buffer, also flush the
     * current block before closing.
     */
    public void close() throws IOException {
        if (this.debug) {
            System.err.println(""TarBuffer.closeBuffer()."");
        } 
        if (this.outStream != null) {
            this.flushBlock();
            if (this.outStream != System.out 
                    && this.outStream != System.err) {
                this.outStream.close();
                this.outStream = null;
            } 
        } else if (this.inStream != null) {
            if (this.inStream != System.in) {
                this.inStream.close();
                this.inStream = null;
            } 
        } 
    } 
}
"
org.apache.tools.tar.TarConstants,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:  
 *       ""This product includes software developed by the 
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
/**
 * This interface contains all the definitions used in the package.
 *
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 */
public interface TarConstants {
    /**
     * The length of the name field in a header buffer.
     */
    public static final int    NAMELEN = 100;
    /**
     * The length of the mode field in a header buffer.
     */
    public static final int    MODELEN = 8;
    /**
     * The length of the user id field in a header buffer.
     */
    public static final int    UIDLEN = 8;
    /**
     * The length of the group id field in a header buffer.
     */
    public static final int    GIDLEN = 8;
    /**
     * The length of the checksum field in a header buffer.
     */
    public static final int    CHKSUMLEN = 8;
    /**
     * The length of the size field in a header buffer.
     */
    public static final int    SIZELEN = 12;
    /**
     * The length of the magic field in a header buffer.
     */
    public static final int    MAGICLEN = 8;
    /**
     * The length of the modification time field in a header buffer.
     */
    public static final int    MODTIMELEN = 12;
    /**
     * The length of the user name field in a header buffer.
     */
    public static final int    UNAMELEN = 32;
    /**
     * The length of the group name field in a header buffer.
     */
    public static final int    GNAMELEN = 32;
    /**
     * The length of the devices field in a header buffer.
     */
    public static final int    DEVLEN = 8;
    /**
     * LF_ constants represent the ""link flag"" of an entry, or more commonly,
     * the ""entry type"". This is the ""old way"" of indicating a normal file.
     */
    public static final byte   LF_OLDNORM = 0;
    /**
     * Normal file type.
     */
    public static final byte   LF_NORMAL = (byte) '0';
    /**
     * Link file type.
     */
    public static final byte   LF_LINK = (byte) '1';
    /**
     * Symbolic link file type.
     */
    public static final byte   LF_SYMLINK = (byte) '2';
    /**
     * Character device file type.
     */
    public static final byte   LF_CHR = (byte) '3';
    /**
     * Block device file type.
     */
    public static final byte   LF_BLK = (byte) '4';
    /**
     * Directory file type.
     */
    public static final byte   LF_DIR = (byte) '5';
    /**
     * FIFO (pipe) file type.
     */
    public static final byte   LF_FIFO = (byte) '6';
    /**
     * Contiguous file type.
     */
    public static final byte   LF_CONTIG = (byte) '7';
    /**
     * The magic tag representing a POSIX tar archive.
     */
    public static final String TMAGIC = ""ustar"";
    /**
     * The magic tag representing a GNU tar archive.
     */
    public static final String GNU_TMAGIC = ""ustar  "";
    /**
     * The namr of the GNU tar entry which contains a long name.
     */
    public static final String GNU_LONGLINK = ""././@LongLink"";
    /**
     * Identifies the *next* file on the tape as having a long name.  
     */
    public static final byte LF_GNUTYPE_LONGNAME = (byte) 'L';
}
"
org.apache.tools.tar.TarEntry,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
import java.io.*;
import java.util.*;
/**
 * This class represents an entry in a Tar archive. It consists
 * of the entry's header, as well as the entry's File. Entries
 * can be instantiated in one of three ways, depending on how
 * they are to be used.
 * <p>
 * TarEntries that are created from the header bytes read from
 * an archive are instantiated with the TarEntry( byte[] )
 * constructor. These entries will be used when extracting from
 * or listing the contents of an archive. These entries have their
 * header filled in using the header bytes. They also set the File
 * to null, since they reference an archive entry not a file.
 * <p>
 * TarEntries that are created from Files that are to be written
 * into an archive are instantiated with the TarEntry( File )
 * constructor. These entries have their header filled in using
 * the File's information. They also keep a reference to the File
 * for convenience when writing entries.
 * <p>
 * Finally, TarEntries can be constructed from nothing but a name.
 * This allows the programmer to construct the entry by hand, for
 * instance when only an InputStream is available for writing to
 * the archive, and the header information is constructed from
 * other information. In this case the header fields are set to
 * defaults and the File is set to null.
 * 
 * <p>
 * The C structure for a Tar Entry's header is:
 * <pre>
 * struct header {
 * char name[NAMSIZ];
 * char mode[8];
 * char uid[8];
 * char gid[8];
 * char size[12];
 * char mtime[12];
 * char chksum[8];
 * char linkflag;
 * char linkname[NAMSIZ];
 * char magic[8];
 * char uname[TUNMLEN];
 * char gname[TGNMLEN];
 * char devmajor[8];
 * char devminor[8];
 * } header;
 * </pre>
 * 
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 */
public class TarEntry implements TarConstants {
    private StringBuffer name;      /** The entry's name. */
    private int          mode;      /** The entry's permission mode. */
    private int          userId;    /** The entry's user id. */
    private int          groupId;   /** The entry's group id. */
    private long         size;      /** The entry's size. */
    private long         modTime;   /** The entry's modification time. */
    private int          checkSum;  /** The entry's checksum. */
    private byte         linkFlag;  /** The entry's link flag. */
    private StringBuffer linkName;  /** The entry's link name. */
    private StringBuffer magic;     /** The entry's magic tag. */
    private StringBuffer userName;  /** The entry's user name. */
    private StringBuffer groupName; /** The entry's group name. */
    private int          devMajor;  /** The entry's major device number. */
    private int          devMinor;  /** The entry's minor device number. */
    private File         file;      /** The entry's file reference */ 
    /** 
     * Construct an empty entry and prepares the header values.
     */ 
    private TarEntry () {
        this.magic = new StringBuffer(TMAGIC);
        this.name = new StringBuffer();
        this.linkName = new StringBuffer();
        String user = System.getProperty(""user.name"", """");
        if (user.length() > 31) {
            user = user.substring(0, 31);
        } 
        this.userId = 0;
        this.groupId = 0;
        this.userName = new StringBuffer(user);
        this.groupName = new StringBuffer("""");
        this.file = null;
    }
    /** 
     * Construct an entry with only a name. This allows the programmer
     * to construct the entry's header ""by hand"". File is set to null.
     */ 
    public TarEntry(String name) {
        this();
        boolean isDir = name.endsWith(""/"");
        this.checkSum = 0;
        this.devMajor = 0;
        this.devMinor = 0;
        this.name = new StringBuffer(name);
        this.mode = isDir ? 040755 : 0100644;
        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
        this.userId = 0;
        this.groupId = 0;
        this.size = 0;
        this.checkSum = 0;
        this.modTime = (new Date()).getTime() / 1000;
        this.linkName = new StringBuffer("""");
        this.userName = new StringBuffer("""");
        this.groupName = new StringBuffer("""");
        this.devMajor = 0;
        this.devMinor = 0;
    }   
    /** 
     * Construct an entry with a name an a link flag.
     */ 
    public TarEntry(String name, byte linkFlag) {
        this(name);
        this.linkFlag = linkFlag;
    }   
    /** 
     * Construct an entry for a file. File is set to file, and the
     * header is constructed from information from the file.
     *  
     * @param file The file that the entry represents.
     */ 
    public TarEntry(File file) {
        this();
        this.file = file;
        String name = file.getPath();
        String osname = System.getProperty(""os.name"");
        if (osname != null) {
            // Strip off drive letters!
            // REVIEW Would a better check be ""(File.separator == '\')""?
            String Win32Prefix = ""Windows"";
            String prefix = osname.substring(0, Win32Prefix.length());
            if (prefix.equalsIgnoreCase(Win32Prefix)) {
                if (name.length() > 2) {
                    char ch1 = name.charAt(0);
                    char ch2 = name.charAt(1);
                    if (ch2 == ':' 
                            && ((ch1 >= 'a' && ch1 <= 'z') 
                                || (ch1 >= 'A' && ch1 <= 'Z'))) {
                        name = name.substring(2);
                    } 
                } 
            } 
        } 
        name = name.replace(File.separatorChar, '/');
        // No absolute pathnames
        // Windows (and Posix?) paths can start with ""\\NetworkDrive\"",
        // so we loop on starting /'s.
        while (name.startsWith(""/"")) {
            name = name.substring(1);
        }
        this.linkName = new StringBuffer("""");
        this.name = new StringBuffer(name);
        if (file.isDirectory()) {
            this.mode = 040755;
            this.linkFlag = LF_DIR;
            if (this.name.charAt(this.name.length() - 1) != '/') {
                this.name.append(""/"");
            } 
        } else {
            this.mode = 0100644;
            this.linkFlag = LF_NORMAL;
        } 
        this.size = file.length();
        this.modTime = file.lastModified() / 1000;
        this.checkSum = 0;
        this.devMajor = 0;
        this.devMinor = 0;
    }   
    /** 
     * Construct an entry from an archive's header bytes. File is set
     * to null.
     *  
     * @param headerBuf The header bytes from a tar archive entry.
     */ 
    public TarEntry(byte[] headerBuf) {
        this();
        this.parseTarHeader(headerBuf);
    }   
    /** 
     * Determine if the two entries are equal. Equality is determined
     * by the header names being equal.
     *  
     * @return it Entry to be checked for equality.
     * @return True if the entries are equal.
     */ 
    public boolean equals(TarEntry it) {
        return this.getName().equals(it.getName());
    }   
    /** 
     * Determine if the given entry is a descendant of this entry.
     * Descendancy is determined by the name of the descendant
     * starting with this entry's name.
     *  
     * @param desc Entry to be checked as a descendent of this.
     * @return True if entry is a descendant of this.
     */ 
    public boolean isDescendent(TarEntry desc) {
        return desc.getName().startsWith(this.getName());
    }   
    /** 
     * Get this entry's name.
     *  
     * @return This entry's name.
     */ 
    public String getName() {
        return this.name.toString();
    }   
    /** 
     * Set this entry's name.
     *  
     * @param name This entry's new name.
     */ 
    public void setName(String name) {
        this.name = new StringBuffer(name);
    }   
    /**
     * Set the mode for this entry
     */
    public void setMode(int mode) {
        this.mode = mode;
    }
    /** 
     * Get this entry's user id.
     *  
     * @return This entry's user id.
     */ 
    public int getUserId() {
        return this.userId;
    }   
    /** 
     * Set this entry's user id.
     *  
     * @param userId This entry's new user id.
     */ 
    public void setUserId(int userId) {
        this.userId = userId;
    }   
    /** 
     * Get this entry's group id.
     *  
     * @return This entry's group id.
     */ 
    public int getGroupId() {
        return this.groupId;
    }   
    /** 
     * Set this entry's group id.
     *  
     * @param groupId This entry's new group id.
     */ 
    public void setGroupId(int groupId) {
        this.groupId = groupId;
    }   
    /** 
     * Get this entry's user name.
     *  
     * @return This entry's user name.
     */ 
    public String getUserName() {
        return this.userName.toString();
    }   
    /** 
     * Set this entry's user name.
     *  
     * @param userName This entry's new user name.
     */ 
    public void setUserName(String userName) {
        this.userName = new StringBuffer(userName);
    }   
    /** 
     * Get this entry's group name.
     *  
     * @return This entry's group name.
     */ 
    public String getGroupName() {
        return this.groupName.toString();
    }   
    /** 
     * Set this entry's group name.
     *  
     * @param groupName This entry's new group name.
     */ 
    public void setGroupName(String groupName) {
        this.groupName = new StringBuffer(groupName);
    }   
    /** 
     * Convenience method to set this entry's group and user ids.
     *  
     * @param userId This entry's new user id.
     * @param groupId This entry's new group id.
     */ 
    public void setIds(int userId, int groupId) {
        this.setUserId(userId);
        this.setGroupId(groupId);
    }   
    /** 
     * Convenience method to set this entry's group and user names.
     *  
     * @param userName This entry's new user name.
     * @param groupName This entry's new group name.
     */ 
    public void setNames(String userName, String groupName) {
        this.setUserName(userName);
        this.setGroupName(groupName);
    }   
    /** 
     * Set this entry's modification time. The parameter passed
     * to this method is in ""Java time"".
     *  
     * @param time This entry's new modification time.
     */ 
    public void setModTime(long time) {
        this.modTime = time / 1000;
    }   
    /** 
     * Set this entry's modification time.
     *  
     * @param time This entry's new modification time.
     */ 
    public void setModTime(Date time) {
        this.modTime = time.getTime() / 1000;
    }   
    /** 
     * Set this entry's modification time.
     *  
     * @param time This entry's new modification time.
     */ 
    public Date getModTime() {
        return new Date(this.modTime * 1000);
    }   
    /** 
     * Get this entry's file.
     *  
     * @return This entry's file.
     */ 
    public File getFile() {
        return this.file;
    }   
    /** 
     * Get this entry's file size.
     *  
     * @return This entry's file size.
     */ 
    public long getSize() {
        return this.size;
    }   
    /** 
     * Set this entry's file size.
     *  
     * @param size This entry's new file size.
     */ 
    public void setSize(long size) {
        this.size = size;
    }   
    /**
     * Indicate if this entry is a GNU long name block
     *
     * @return true if this is a long name extension provided by GNU tar
     */
    public boolean isGNULongNameEntry() {
        return linkFlag == LF_GNUTYPE_LONGNAME &&
               name.toString().equals(GNU_LONGLINK);
    }               
    /** 
     * Return whether or not this entry represents a directory.
     *  
     * @return True if this entry is a directory.
     */ 
    public boolean isDirectory() {
        if (this.file != null) {
            return this.file.isDirectory();
        } 
        if (this.linkFlag == LF_DIR) {
            return true;
        } 
        if (this.getName().endsWith(""/"")) {
            return true;
        } 
        return false;
    }   
    /** 
     * If this entry represents a file, and the file is a directory, return
     * an array of TarEntries for this entry's children.
     *  
     * @return An array of TarEntry's for this entry's children.
     */ 
    public TarEntry[] getDirectoryEntries() {
        if (this.file == null ||!this.file.isDirectory()) {
            return new TarEntry[0];
        } 
        String[]   list = this.file.list();
        TarEntry[] result = new TarEntry[list.length];
        for (int i = 0; i < list.length; ++i) {
            result[i] = new TarEntry(new File(this.file, list[i]));
        } 
        return result;
    }   
    /** 
     * Write an entry's header information to a header buffer.
     *  
     * @param outbuf The tar entry header buffer to fill in.
     */ 
    public void writeEntryHeader(byte[] outbuf) {
        int offset = 0;
        offset = TarUtils.getNameBytes(this.name, outbuf, offset, NAMELEN);
        offset = TarUtils.getOctalBytes(this.mode, outbuf, offset, MODELEN);
        offset = TarUtils.getOctalBytes(this.userId, outbuf, offset, UIDLEN);
        offset = TarUtils.getOctalBytes(this.groupId, outbuf, offset, GIDLEN);
        offset = TarUtils.getLongOctalBytes(this.size, outbuf, offset, SIZELEN);
        offset = TarUtils.getLongOctalBytes(this.modTime, outbuf, offset, MODTIMELEN);
        int csOffset = offset;
        for (int c = 0; c < CHKSUMLEN; ++c) {
            outbuf[offset++] = (byte) ' ';
        }
        outbuf[offset++] = this.linkFlag;
        offset = TarUtils.getNameBytes(this.linkName, outbuf, offset, NAMELEN);
        offset = TarUtils.getNameBytes(this.magic, outbuf, offset, MAGICLEN);
        offset = TarUtils.getNameBytes(this.userName, outbuf, offset, UNAMELEN);
        offset = TarUtils.getNameBytes(this.groupName, outbuf, offset, GNAMELEN);
        offset = TarUtils.getOctalBytes(this.devMajor, outbuf, offset, DEVLEN);
        offset = TarUtils.getOctalBytes(this.devMinor, outbuf, offset, DEVLEN);
        while (offset < outbuf.length) {
            outbuf[offset++] = 0;
        }
        long checkSum = TarUtils.computeCheckSum(outbuf);
        TarUtils.getCheckSumOctalBytes(checkSum, outbuf, csOffset, CHKSUMLEN);
    }   
    /** 
     * Parse an entry's header information from a header buffer.
     *  
     * @param header The tar entry header buffer to get information from.
     */ 
    public void parseTarHeader(byte[] header) {
        int offset = 0;
        this.name = TarUtils.parseName(header, offset, NAMELEN);  
        offset += NAMELEN;
        this.mode = (int) TarUtils.parseOctal(header, offset, MODELEN); 
        offset += MODELEN;
        this.userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
        offset += UIDLEN;
        this.groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
        offset += GIDLEN;
        this.size = TarUtils.parseOctal(header, offset, SIZELEN);
        offset += SIZELEN;
        this.modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
        offset += MODTIMELEN;
        this.checkSum = (int) TarUtils.parseOctal(header, offset, CHKSUMLEN);
        offset += CHKSUMLEN;
        this.linkFlag = header[offset++];
        this.linkName = TarUtils.parseName(header, offset, NAMELEN);
        offset += NAMELEN;
        this.magic = TarUtils.parseName(header, offset, MAGICLEN);
        offset += MAGICLEN;
        this.userName = TarUtils.parseName(header, offset, UNAMELEN);
        offset += UNAMELEN;
        this.groupName = TarUtils.parseName(header, offset, GNAMELEN);
        offset += GNAMELEN;
        this.devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
        offset += DEVLEN;
        this.devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
    }
}       
"
org.apache.tools.tar.TarInputStream,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
import java.io.*;
/**
 * The TarInputStream reads a UNIX tar archive as an InputStream.
 * methods are provided to position at each successive entry in
 * the archive, and the read each entry as a normal input stream
 * using read().
 * 
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 */
public class TarInputStream extends FilterInputStream {
    protected boolean      debug;
    protected boolean      hasHitEOF;
    protected int          entrySize;
    protected int          entryOffset;
    protected byte[]       oneBuf;
    protected byte[]       readBuf;
    protected TarBuffer    buffer;
    protected TarEntry     currEntry;
    public TarInputStream(InputStream is) {
        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarInputStream(InputStream is, int blockSize) {
        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarInputStream(InputStream is, int blockSize, int recordSize) {
        super(is);
        this.buffer = new TarBuffer(is, blockSize, recordSize);
        this.readBuf = null;
        this.oneBuf = new byte[1];
        this.debug = false;
        this.hasHitEOF = false;
    }
    /**
     * Sets the debugging flag.
     * 
     * @param debugF True to turn on debugging.
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
        this.buffer.setDebug(debug);
    } 
    /**
     * Closes this stream. Calls the TarBuffer's close() method.
     */
    public void close() throws IOException {
        this.buffer.close();
    } 
    /**
     * Get the record size being used by this stream's TarBuffer.
     * 
     * @return The TarBuffer record size.
     */
    public int getRecordSize() {
        return this.buffer.getRecordSize();
    } 
    /**
     * Get the available data that can be read from the current
     * entry in the archive. This does not indicate how much data
     * is left in the entire archive, only in the current entry.
     * This value is determined from the entry's size header field
     * and the amount of data already read from the current entry.
     * 
     * 
     * @return The number of available bytes for the current entry.
     */
    public int available() throws IOException {
        return this.entrySize - this.entryOffset;
    } 
    /**
     * Skip bytes in the input buffer. This skips bytes in the
     * current entry's data, not the entire archive, and will
     * stop at the end of the current entry's data if the number
     * to skip extends beyond that point.
     * 
     * @param numToSkip The number of bytes to skip.
     */
    public void skip(int numToSkip) throws IOException {
        // REVIEW
        // This is horribly inefficient, but it ensures that we
        // properly skip over bytes via the TarBuffer...
        // 
        byte[] skipBuf = new byte[8 * 1024];
        for (int num = numToSkip; num > 0; ) {
            int numRead = this.read(skipBuf, 0, 
                                    (num > skipBuf.length ? skipBuf.length 
                                     : num));
            if (numRead == -1) {
                break;
            } 
            num -= numRead;
        } 
    } 
    /**
     * Since we do not support marking just yet, we return false.
     * 
     * @return False.
     */
    public boolean markSupported() {
        return false;
    } 
    /**
     * Since we do not support marking just yet, we do nothing.
     * 
     * @param markLimit The limit to mark.
     */
    public void mark(int markLimit) {}
    /**
     * Since we do not support marking just yet, we do nothing.
     */
    public void reset() {}
    /**
     * Get the next entry in this tar archive. This will skip
     * over any remaining data in the current entry, if there
     * is one, and place the input stream at the header of the
     * next entry, and read the header and instantiate a new
     * TarEntry from the header bytes and return that entry.
     * If there are no more entries in the archive, null will
     * be returned to indicate that the end of the archive has
     * been reached.
     * 
     * @return The next TarEntry in the archive, or null.
     */
    public TarEntry getNextEntry() throws IOException {
        if (this.hasHitEOF) {
            return null;
        } 
        if (this.currEntry != null) {
            int numToSkip = this.entrySize - this.entryOffset;
            if (this.debug) {
                System.err.println(""TarInputStream: SKIP currENTRY '"" 
                                   + this.currEntry.getName() + ""' SZ "" 
                                   + this.entrySize + "" OFF "" 
                                   + this.entryOffset + ""  skipping "" 
                                   + numToSkip + "" bytes"");
            } 
            if (numToSkip > 0) {
                this.skip(numToSkip);
            } 
            this.readBuf = null;
        } 
        byte[] headerBuf = this.buffer.readRecord();
        if (headerBuf == null) {
            if (this.debug) {
                System.err.println(""READ NULL RECORD"");
            } 
            this.hasHitEOF = true;
        } else if (this.buffer.isEOFRecord(headerBuf)) {
            if (this.debug) {
                System.err.println(""READ EOF RECORD"");
            } 
            this.hasHitEOF = true;
        } 
        if (this.hasHitEOF) {
            this.currEntry = null;
        } else {
            this.currEntry = new TarEntry(headerBuf);
            if (!(headerBuf[257] == 'u' && headerBuf[258] == 's' 
                    && headerBuf[259] == 't' && headerBuf[260] == 'a' 
                    && headerBuf[261] == 'r')) {
                this.entrySize = 0;
                this.entryOffset = 0;
                this.currEntry = null;
                throw new IOException(""bad header in block "" 
                                                 + this.buffer.getCurrentBlockNum() 
                                                 + "" record "" 
                                                 + this.buffer.getCurrentRecordNum() 
                                                 + "", "" + 
                                       ""header magic is not 'ustar', but '"" 
                                                 + headerBuf[257] 
                                                 + headerBuf[258] 
                                                 + headerBuf[259] 
                                                 + headerBuf[260] 
                                                 + headerBuf[261] 
                                                 + ""', or (dec) "" 
                                                 + ((int) headerBuf[257]) 
                                                 + "", "" 
                                                 + ((int) headerBuf[258]) 
                                                 + "", "" 
                                                 + ((int) headerBuf[259]) 
                                                 + "", "" 
                                                 + ((int) headerBuf[260]) 
                                                 + "", "" 
                                                 + ((int) headerBuf[261]));
            } 
            if (this.debug) {
                System.err.println(""TarInputStream: SET CURRENTRY '"" 
                                   + this.currEntry.getName() 
                                   + ""' size = "" 
                                   + this.currEntry.getSize());
            } 
            this.entryOffset = 0;
            // REVIEW How do we resolve this discrepancy?!
            this.entrySize = (int) this.currEntry.getSize();
        } 
        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {
            // read in the name
            StringBuffer longName = new StringBuffer();
            byte[] buffer = new byte[256];
            int length = 0;
            while ((length = read(buffer)) >= 0) {
                longName.append(new String(buffer, 0, length));
            }
            getNextEntry();
            this.currEntry.setName(longName.toString());
        }
        return this.currEntry;
    } 
    /**
     * Reads a byte from the current tar archive entry.
     * 
     * This method simply calls read( byte[], int, int ).
     * 
     * @return The byte read, or -1 at EOF.
     */
    public int read() throws IOException {
        int num = this.read(this.oneBuf, 0, 1);
        if (num == -1) {
            return num;
        } else {
            return (int) this.oneBuf[0];
        }
    } 
    /**
     * Reads bytes from the current tar archive entry.
     * 
     * This method simply calls read( byte[], int, int ).
     * 
     * @param buf The buffer into which to place bytes read.
     * @return The number of bytes read, or -1 at EOF.
     */
    public int read(byte[] buf) throws IOException {
        return this.read(buf, 0, buf.length);
    } 
    /**
     * Reads bytes from the current tar archive entry.
     * 
     * This method is aware of the boundaries of the current
     * entry in the archive and will deal with them as if they
     * were this stream's start and EOF.
     * 
     * @param buf The buffer into which to place bytes read.
     * @param offset The offset at which to place bytes read.
     * @param numToRead The number of bytes to read.
     * @return The number of bytes read, or -1 at EOF.
     */
    public int read(byte[] buf, int offset, int numToRead) throws IOException {
        int totalRead = 0;
        if (this.entryOffset >= this.entrySize) {
            return -1;
        } 
        if ((numToRead + this.entryOffset) > this.entrySize) {
            numToRead = (this.entrySize - this.entryOffset);
        } 
        if (this.readBuf != null) {
            int sz = (numToRead > this.readBuf.length) ? this.readBuf.length 
                     : numToRead;
            System.arraycopy(this.readBuf, 0, buf, offset, sz);
            if (sz >= this.readBuf.length) {
                this.readBuf = null;
            } else {
                int    newLen = this.readBuf.length - sz;
                byte[] newBuf = new byte[newLen];
                System.arraycopy(this.readBuf, sz, newBuf, 0, newLen);
                this.readBuf = newBuf;
            } 
            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        } 
        while (numToRead > 0) {
            byte[] rec = this.buffer.readRecord();
            if (rec == null) {
                // Unexpected EOF!
                throw new IOException(""unexpected EOF with "" + numToRead 
                                      + "" bytes unread"");
            } 
            int sz = numToRead;
            int recLen = rec.length;
            if (recLen > sz) {
                System.arraycopy(rec, 0, buf, offset, sz);
                this.readBuf = new byte[recLen - sz];
                System.arraycopy(rec, sz, this.readBuf, 0, recLen - sz);
            } else {
                sz = recLen;
                System.arraycopy(rec, 0, buf, offset, recLen);
            } 
            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        } 
        this.entryOffset += totalRead;
        return totalRead;
    } 
    /**
     * Copies the contents of the current tar archive entry directly into
     * an output stream.
     * 
     * @param out The OutputStream into which to write the entry's data.
     */
    public void copyEntryContents(OutputStream out) throws IOException {
        byte[] buf = new byte[32 * 1024];
        while (true) {
            int numRead = this.read(buf, 0, buf.length);
            if (numRead == -1) {
                break;
            } 
            out.write(buf, 0, numRead);
        } 
    } 
}
"
org.apache.tools.tar.TarOutputStream,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
import java.io.*;
/**
 * The TarOutputStream writes a UNIX tar archive as an OutputStream.
 * Methods are provided to put entries, and then write their contents
 * by writing to this stream using write().
 * 
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 */
public class TarOutputStream extends FilterOutputStream {
    static public final int LONGFILE_ERROR = 0;
    static public final int LONGFILE_TRUNCATE = 1;
    static public final int LONGFILE_GNU = 2;
    protected boolean   debug;
    protected int       currSize;
    protected int       currBytes;
    protected byte[]    oneBuf;
    protected byte[]    recordBuf;
    protected int       assemLen;
    protected byte[]    assemBuf;
    protected TarBuffer buffer;
    protected int       longFileMode = LONGFILE_ERROR;
    public TarOutputStream(OutputStream os) {
        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarOutputStream(OutputStream os, int blockSize) {
        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }
    public TarOutputStream(OutputStream os, int blockSize, int recordSize) {
        super(os);
        this.buffer = new TarBuffer(os, blockSize, recordSize);
        this.debug = false;
        this.assemLen = 0;
        this.assemBuf = new byte[recordSize];
        this.recordBuf = new byte[recordSize];
        this.oneBuf = new byte[1];
    }
    public void setLongFileMode(int longFileMode) {
        this.longFileMode = longFileMode;
    }
    /**
     * Sets the debugging flag.
     * 
     * @param debugF True to turn on debugging.
     */
    public void setDebug(boolean debugF) {
        this.debug = debugF;
    } 
    /**
     * Sets the debugging flag in this stream's TarBuffer.
     * 
     * @param debugF True to turn on debugging.
     */
    public void setBufferDebug(boolean debug) {
        this.buffer.setDebug(debug);
    } 
    /**
     * Ends the TAR archive without closing the underlying OutputStream.
     * The result is that the EOF record of nulls is written.
     */
    public void finish() throws IOException {
        this.writeEOFRecord();
    } 
    /**
     * Ends the TAR archive and closes the underlying OutputStream.
     * This means that finish() is called followed by calling the
     * TarBuffer's close().
     */
    public void close() throws IOException {
        this.finish();
        this.buffer.close();
    } 
    /**
     * Get the record size being used by this stream's TarBuffer.
     * 
     * @return The TarBuffer record size.
     */
    public int getRecordSize() {
        return this.buffer.getRecordSize();
    } 
    /**
     * Put an entry on the output stream. This writes the entry's
     * header record and positions the output stream for writing
     * the contents of the entry. Once this method is called, the
     * stream is ready for calls to write() to write the entry's
     * contents. Once the contents are written, closeEntry()
     * <B>MUST</B> be called to ensure that all buffered data
     * is completely written to the output stream.
     * 
     * @param entry The TarEntry to be written to the archive.
     */
    public void putNextEntry(TarEntry entry) throws IOException {
        if (entry.getName().length() >= TarConstants.NAMELEN) {
            if (longFileMode == LONGFILE_GNU) {
                // create a TarEntry for the LongLink, the contents
                // of which are the entry's name 
                TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,
                                                      TarConstants.LF_GNUTYPE_LONGNAME);
                longLinkEntry.setSize(entry.getName().length() + 1);
                putNextEntry(longLinkEntry);                                                    
                write(entry.getName().getBytes());
                write(0);
                closeEntry();
            }
            else if (longFileMode != LONGFILE_TRUNCATE) {
                throw new RuntimeException(""file name '"" + entry.getName() 
                                             + ""' is too long ( > "" 
                                             + TarConstants.NAMELEN + "" bytes)"");
            }
        } 
        entry.writeEntryHeader(this.recordBuf);
        this.buffer.writeRecord(this.recordBuf);
        this.currBytes = 0;
        if (entry.isDirectory()) {
            this.currSize = 0;
        } else {
            this.currSize = (int) entry.getSize();
        }
    } 
    /**
     * Close an entry. This method MUST be called for all file
     * entries that contain data. The reason is that we must
     * buffer data written to the stream in order to satisfy
     * the buffer's record based writes. Thus, there may be
     * data fragments still being assembled that must be written
     * to the output stream before this entry is closed and the
     * next entry written.
     */
    public void closeEntry() throws IOException {
        if (this.assemLen > 0) {
            for (int i = this.assemLen; i < this.assemBuf.length; ++i) {
                this.assemBuf[i] = 0;
            }
            this.buffer.writeRecord(this.assemBuf);
            this.currBytes += this.assemLen;
            this.assemLen = 0;
        } 
        if (this.currBytes < this.currSize) {
            throw new IOException(""entry closed at '"" + this.currBytes 
                                  + ""' before the '"" + this.currSize 
                                  + ""' bytes specified in the header were written"");
        } 
    } 
    /**
     * Writes a byte to the current tar archive entry.
     * 
     * This method simply calls read( byte[], int, int ).
     * 
     * @param b The byte written.
     */
    public void write(int b) throws IOException {
        this.oneBuf[0] = (byte) b;
        this.write(this.oneBuf, 0, 1);
    } 
    /**
     * Writes bytes to the current tar archive entry.
     * 
     * This method simply calls write( byte[], int, int ).
     * 
     * @param wBuf The buffer to write to the archive.
     * @return The number of bytes read, or -1 at EOF.
     */
    public void write(byte[] wBuf) throws IOException {
        this.write(wBuf, 0, wBuf.length);
    } 
    /**
     * Writes bytes to the current tar archive entry. This method
     * is aware of the current entry and will throw an exception if
     * you attempt to write bytes past the length specified for the
     * current entry. The method is also (painfully) aware of the
     * record buffering required by TarBuffer, and manages buffers
     * that are not a multiple of recordsize in length, including
     * assembling records from small buffers.
     * 
     * @param wBuf The buffer to write to the archive.
     * @param wOffset The offset in the buffer from which to get bytes.
     * @param numToWrite The number of bytes to write.
     */
    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((this.currBytes + numToWrite) > this.currSize) {
            throw new IOException(""request to write '"" + numToWrite 
                                  + ""' bytes exceeds size in header of '"" 
                                  + this.currSize + ""' bytes"");
            // 
            // We have to deal with assembly!!!
            // The programmer can be writing little 32 byte chunks for all
            // we know, and we must assemble complete records for writing.
            // REVIEW Maybe this should be in TarBuffer? Could that help to
            // eliminate some of the buffer copying.
            // 
        } 
        if (this.assemLen > 0) {
            if ((this.assemLen + numToWrite) >= this.recordBuf.length) {
                int aLen = this.recordBuf.length - this.assemLen;
                System.arraycopy(this.assemBuf, 0, this.recordBuf, 0, 
                                 this.assemLen);
                System.arraycopy(wBuf, wOffset, this.recordBuf, 
                                 this.assemLen, aLen);
                this.buffer.writeRecord(this.recordBuf);
                this.currBytes += this.recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                this.assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen, 
                                 numToWrite);
                wOffset += numToWrite;
                this.assemLen += numToWrite;
                numToWrite -= numToWrite;
            } 
        } 
        // 
        // When we get here we have EITHER:
        // o An empty ""assemble"" buffer.
        // o No bytes to write (numToWrite == 0)
        // 
        while (numToWrite > 0) {
            if (numToWrite < this.recordBuf.length) {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen, 
                                 numToWrite);
                this.assemLen += numToWrite;
                break;
            } 
            this.buffer.writeRecord(wBuf, wOffset);
            int num = this.recordBuf.length;
            this.currBytes += num;
            numToWrite -= num;
            wOffset += num;
        } 
    } 
    /**
     * Write an EOF (end of archive) record to the tar archive.
     * An EOF record consists of a record of all zeros.
     */
    private void writeEOFRecord() throws IOException {
        for (int i = 0; i < this.recordBuf.length; ++i) {
            this.recordBuf[i] = 0;
        }
        this.buffer.writeRecord(this.recordBuf);
    } 
}
"
org.apache.tools.tar.TarUtils,"/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names ""The Jakarta Project"", ""Ant"", and ""Apache Software
 *    Foundation"" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache""
 *    nor may ""Apache"" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
/*
 * This package is based on the work done by Timothy Gerard Endres 
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */
package org.apache.tools.tar;
/**
 * This class provides static utility methods to work with byte streams.
 * 
 * @author Timothy Gerard Endres <a href=""mailto:time@ice.com"">time@ice.com</a>
 * @author Stefano Mazzocchi <a href=""mailto:stefano@apache.org"">stefano@apache.org</a>
 */
public class TarUtils {
    /**
     * Parse an octal string from a header buffer. This is used for the
     * file permission mode value.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The long value of the octal string.
     */
    public static long parseOctal(byte[] header, int offset, int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        for (int i = offset; i < end; ++i) {
            if (header[i] == 0) {
                break;
            } 
            if (header[i] == (byte) ' ' || header[i] == '0') {
                if (stillPadding) {
                    continue;
                } 
                if (header[i] == (byte) ' ') {
                    break;
                } 
            } 
            stillPadding = false;
            result = (result << 3) + (header[i] - '0');
        } 
        return result;
    } 
    /**
     * Parse an entry name from a header buffer.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The header's entry name.
     */
    public static StringBuffer parseName(byte[] header, int offset, int length) {
        StringBuffer result = new StringBuffer(length);
        int          end = offset + length;
        for (int i = offset; i < end; ++i) {
            if (header[i] == 0) {
                break;
            } 
            result.append((char) header[i]);
        } 
        return result;
    } 
    /**
     * Determine the number of bytes in an entry name.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The number of bytes in a header's entry name.
     */
    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {
        int i;
        for (i = 0; i < length && i < name.length(); ++i) {
            buf[offset + i] = (byte) name.charAt(i);
        } 
        for (; i < length; ++i) {
            buf[offset + i] = 0;
        } 
        return offset + length;
    } 
    /**
     * Parse an octal integer from a header buffer.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The integer value of the octal bytes.
     */
    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {
        byte[] result = new byte[length];
        int    idx = length - 1;
        buf[offset + idx] = 0;
        --idx;
        buf[offset + idx] = (byte) ' ';
        --idx;
        if (value == 0) {
            buf[offset + idx] = (byte) '0';
            --idx;
        } else {
            for (long val = value; idx >= 0 && val > 0; --idx) {
                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));
                val = val >> 3;
            } 
        } 
        for (; idx >= 0; --idx) {
            buf[offset + idx] = (byte) ' ';
        } 
        return offset + length;
    } 
    /**
     * Parse an octal long integer from a header buffer.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The long value of the octal bytes.
     */
    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {
        byte[] temp = new byte[length + 1];
        getOctalBytes(value, temp, 0, length + 1);
        System.arraycopy(temp, 0, buf, offset, length);
        return offset + length;
    } 
    /**
     * Parse the checksum octal integer from a header buffer.
     * 
     * @param header The header buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The number of header bytes to parse.
     * @return The integer value of the entry's checksum.
     */
    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {
        getOctalBytes(value, buf, offset, length);
        buf[offset + length - 1] = (byte) ' ';
        buf[offset + length - 2] = 0;
        return offset + length;
    }
    /** 
     * Compute the checksum of a tar entry header.
     *  
     * @param buf The tar entry's header buffer.
     * @return The computed checksum.
     */ 
    public static long computeCheckSum(byte[] buf) {
        long sum = 0;
        for (int i = 0; i < buf.length; ++i) {
            sum += 255 & buf[i];
        } 
        return sum;
    }    
}
"
