metric_name,file
org.apache.lucene.LucenePackage,"/*    */ package org.apache.lucene;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LucenePackage
/*    */ {
/* 26 */   public static Package get() { return LucenePackage.class.getPackage(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\LucenePackage.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Analyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Analyzer
/*    */ {
/*    */   public abstract TokenStream tokenStream(String paramString, Reader paramReader);
/*    */   
/* 55 */   public int getPositionIncrementGap(String fieldName) { return 0; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\Analyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CharTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class CharTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private int offset;
/*    */   private int bufferIndex;
/*    */   private int dataLen;
/*    */   private static final int MAX_WORD_LEN = 255;
/*    */   private static final int IO_BUFFER_SIZE = 1024;
/*    */   private final char[] buffer;
/*    */   private final char[] ioBuffer;
/*    */   
/*    */   public CharTokenizer(Reader input) {
/* 25 */     super(input);
/*    */ 
/*    */     
/* 28 */     this.offset = 0; this.bufferIndex = 0; this.dataLen = 0;
/*    */ 
/*    */     
/* 31 */     this.buffer = new char[255];
/* 32 */     this.ioBuffer = new char[1024];
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected abstract boolean isTokenChar(char paramChar);
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   protected char normalize(char c) { return c; }
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 49 */     int length = 0;
/* 50 */     int start = this.offset;
/*    */ 
/*    */     
/*    */     while (true) {
/* 54 */       this.offset++;
/* 55 */       if (this.bufferIndex >= this.dataLen) {
/* 56 */         this.dataLen = this.input.read(this.ioBuffer);
/* 57 */         this.bufferIndex = 0;
/*    */       } 
/*    */       
/* 60 */       if (this.dataLen == -1) {
/* 61 */         if (length > 0) {
/*    */           break;
/*    */         }
/* 64 */         return null;
/*    */       } 
/* 66 */       char c = this.ioBuffer[this.bufferIndex++];
/*    */       
/* 68 */       if (isTokenChar(c)) {
/*    */         
/* 70 */         if (length == 0) {
/* 71 */           start = this.offset - 1;
/*    */         }
/* 73 */         this.buffer[length++] = normalize(c);
/*    */         
/* 75 */         if (length == 255)
/*    */           break;  continue;
/*    */       } 
/* 78 */       if (length > 0) {
/*    */         break;
/*    */       }
/*    */     } 
/*    */     
/* 83 */     return new Token(new String(this.buffer, 0, length), start, start + length);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\CharTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.ISOLatin1AccentFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ISOLatin1AccentFilter
/*     */   extends TokenFilter
/*     */ {
/*  28 */   public ISOLatin1AccentFilter(TokenStream input) { super(input); }
/*     */ 
/*     */   
/*     */   public final Token next() throws IOException {
/*  32 */     Token t = this.input.next();
/*  33 */     if (t == null) {
/*  34 */       return null;
/*     */     }
/*  36 */     return new Token(removeAccents(t.termText()), t.startOffset(), t.endOffset(), t.type());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final String removeAccents(String input) {
/*  43 */     StringBuffer output = new StringBuffer();
/*  44 */     for (int i = 0; i < input.length(); i++) {
/*  45 */       switch (input.charAt(i)) {
/*     */         case 'À':
/*     */         case 'Á':
/*     */         case 'Â':
/*     */         case 'Ã':
/*     */         case 'Ä':
/*     */         case 'Å':
/*  52 */           output.append(""A"");
/*     */           break;
/*     */         case 'Æ':
/*  55 */           output.append(""AE"");
/*     */           break;
/*     */         case 'Ç':
/*  58 */           output.append(""C"");
/*     */           break;
/*     */         case 'È':
/*     */         case 'É':
/*     */         case 'Ê':
/*     */         case 'Ë':
/*  64 */           output.append(""E"");
/*     */           break;
/*     */         case 'Ì':
/*     */         case 'Í':
/*     */         case 'Î':
/*     */         case 'Ï':
/*  70 */           output.append(""I"");
/*     */           break;
/*     */         case 'Ð':
/*  73 */           output.append(""D"");
/*     */           break;
/*     */         case 'Ñ':
/*  76 */           output.append(""N"");
/*     */           break;
/*     */         case 'Ò':
/*     */         case 'Ó':
/*     */         case 'Ô':
/*     */         case 'Õ':
/*     */         case 'Ö':
/*     */         case 'Ø':
/*  84 */           output.append(""O"");
/*     */           break;
/*     */         case 'Œ':
/*  87 */           output.append(""OE"");
/*     */           break;
/*     */         case 'Þ':
/*  90 */           output.append(""TH"");
/*     */           break;
/*     */         case 'Ù':
/*     */         case 'Ú':
/*     */         case 'Û':
/*     */         case 'Ü':
/*  96 */           output.append(""U"");
/*     */           break;
/*     */         case 'Ý':
/*     */         case 'Ÿ':
/* 100 */           output.append(""Y"");
/*     */           break;
/*     */         case 'à':
/*     */         case 'á':
/*     */         case 'â':
/*     */         case 'ã':
/*     */         case 'ä':
/*     */         case 'å':
/* 108 */           output.append(""a"");
/*     */           break;
/*     */         case 'æ':
/* 111 */           output.append(""ae"");
/*     */           break;
/*     */         case 'ç':
/* 114 */           output.append(""c"");
/*     */           break;
/*     */         case 'è':
/*     */         case 'é':
/*     */         case 'ê':
/*     */         case 'ë':
/* 120 */           output.append(""e"");
/*     */           break;
/*     */         case 'ì':
/*     */         case 'í':
/*     */         case 'î':
/*     */         case 'ï':
/* 126 */           output.append(""i"");
/*     */           break;
/*     */         case 'ð':
/* 129 */           output.append(""d"");
/*     */           break;
/*     */         case 'ñ':
/* 132 */           output.append(""n"");
/*     */           break;
/*     */         case 'ò':
/*     */         case 'ó':
/*     */         case 'ô':
/*     */         case 'õ':
/*     */         case 'ö':
/*     */         case 'ø':
/* 140 */           output.append(""o"");
/*     */           break;
/*     */         case 'œ':
/* 143 */           output.append(""oe"");
/*     */           break;
/*     */         case 'ß':
/* 146 */           output.append(""ss"");
/*     */           break;
/*     */         case 'þ':
/* 149 */           output.append(""th"");
/*     */           break;
/*     */         case 'ù':
/*     */         case 'ú':
/*     */         case 'û':
/*     */         case 'ü':
/* 155 */           output.append(""u"");
/*     */           break;
/*     */         case 'ý':
/*     */         case 'ÿ':
/* 159 */           output.append(""y"");
/*     */           break;
/*     */         default:
/* 162 */           output.append(input.charAt(i));
/*     */           break;
/*     */       } 
/*     */     } 
/* 166 */     return output.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\ISOLatin1AccentFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 28 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new KeywordTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\KeywordAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private static final int DEFAULT_BUFFER_SIZE = 256;
/*    */   private boolean done;
/*    */   private final char[] buffer;
/*    */   
/* 33 */   public KeywordTokenizer(Reader input) { this(input, 256); }
/*    */ 
/*    */   
/*    */   public KeywordTokenizer(Reader input, int bufferSize) {
/* 37 */     super(input);
/* 38 */     this.buffer = new char[bufferSize];
/* 39 */     this.done = false;
/*    */   }
/*    */   
/*    */   public Token next() throws IOException {
/* 43 */     if (!this.done) {
/* 44 */       this.done = true;
/* 45 */       StringBuffer buffer = new StringBuffer();
/*    */       
/*    */       while (true) {
/* 48 */         int length = this.input.read(this.buffer);
/* 49 */         if (length == -1)
/*    */           break; 
/* 51 */         buffer.append(this.buffer, 0, length);
/*    */       } 
/* 53 */       String text = buffer.toString();
/* 54 */       return new Token(text, 0, text.length());
/*    */     } 
/* 56 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\KeywordTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LengthFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LengthFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   final int min;
/*    */   final int max;
/*    */   
/*    */   public LengthFilter(TokenStream in, int min, int max) {
/* 38 */     super(in);
/* 39 */     this.min = min;
/* 40 */     this.max = max;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 49 */     for (Token token = this.input.next(); token != null; token = this.input.next()) {
/*    */       
/* 51 */       int len = token.termText().length();
/* 52 */       if (len >= this.min && len <= this.max) {
/* 53 */         return token;
/*    */       }
/*    */     } 
/*    */ 
/*    */     
/* 58 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\LengthFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LetterTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LetterTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 31 */   public LetterTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 37 */   protected boolean isTokenChar(char c) { return Character.isLetter(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\LetterTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseFilter
/*    */   extends TokenFilter
/*    */ {
/* 28 */   public LowerCaseFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 32 */     Token t = this.input.next();
/*    */     
/* 34 */     if (t == null) {
/* 35 */       return null;
/*    */     }
/* 37 */     t.termText = t.termText.toLowerCase();
/*    */     
/* 39 */     return t;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\LowerCaseFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseTokenizer
/*    */   extends LetterTokenizer
/*    */ {
/* 34 */   public LowerCaseTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   protected char normalize(char c) { return Character.toLowerCase(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\LowerCaseTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PerFieldAnalyzerWrapper,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PerFieldAnalyzerWrapper
/*    */   extends Analyzer
/*    */ {
/*    */   private Analyzer defaultAnalyzer;
/* 45 */   private Map analyzerMap = new HashMap();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 55 */   public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer) { this.defaultAnalyzer = defaultAnalyzer; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 65 */   public void addAnalyzer(String fieldName, Analyzer analyzer) { this.analyzerMap.put(fieldName, analyzer); }
/*    */ 
/*    */   
/*    */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 69 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 70 */     if (analyzer == null) {
/* 71 */       analyzer = this.defaultAnalyzer;
/*    */     }
/*    */     
/* 74 */     return analyzer.tokenStream(fieldName, reader);
/*    */   }
/*    */ 
/*    */   
/* 78 */   public String toString() { return ""PerFieldAnalyzerWrapper("" + this.analyzerMap + "", default="" + this.defaultAnalyzer + "")""; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\PerFieldAnalyzerWrapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class PorterStemFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   private PorterStemmer stemmer;
/*    */   
/*    */   public PorterStemFilter(TokenStream in) {
/* 43 */     super(in);
/* 44 */     this.stemmer = new PorterStemmer();
/*    */   }
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 49 */     Token token = this.input.next();
/* 50 */     if (token == null) {
/* 51 */       return null;
/*    */     }
/* 53 */     String s = this.stemmer.stem(token.termText);
/* 54 */     if (s != token.termText)
/* 55 */       token.termText = s; 
/* 56 */     return token;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\PorterStemFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemmer,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.FileInputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class PorterStemmer
/*     */ {
/*     */   private char[] b;
/*     */   private int i;
/*     */   private int j;
/*     */   private int k;
/*     */   private int k0;
/*     */   private boolean dirty = false;
/*     */   private static final int INC = 50;
/*     */   private static final int EXTRA = 1;
/*     */   
/*     */   public PorterStemmer() {
/*  67 */     this.b = new char[50];
/*  68 */     this.i = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public void reset() { this.i = 0; this.dirty = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(char ch) {
/*  83 */     if (this.b.length <= this.i + 1) {
/*  84 */       char[] new_b = new char[this.b.length + 50];
/*  85 */       for (int c = 0; c < this.b.length; c++)
/*  86 */         new_b[c] = this.b[c]; 
/*  87 */       this.b = new_b;
/*     */     } 
/*  89 */     this.b[this.i++] = ch;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public String toString() { return new String(this.b, 0, this.i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 102 */   public int getResultLength() { return this.i; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public char[] getResultBuffer() { return this.b; }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cons(int i) {
/* 114 */     switch (this.b[i]) { case 'a': case 'e': case 'i': case 'o':
/*     */       case 'u':
/* 116 */         return false;
/*     */       case 'y':
/* 118 */         return (i == this.k0) ? true : (!cons(i - 1)); }
/*     */     
/* 120 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int m() {
/* 136 */     int n = 0;
/* 137 */     int i = this.k0;
/*     */     while (true) {
/* 139 */       if (i > this.j)
/* 140 */         return n; 
/* 141 */       if (!cons(i))
/*     */         break; 
/* 143 */       i++;
/*     */     } 
/* 145 */     i++;
/*     */     
/*     */     while (true) {
/* 148 */       if (i > this.j)
/* 149 */         return n; 
/* 150 */       if (cons(i)) {
/*     */ 
/*     */ 
/*     */         
/* 154 */         i++;
/* 155 */         n++;
/*     */         while (true) {
/* 157 */           if (i > this.j)
/* 158 */             return n; 
/* 159 */           if (!cons(i))
/*     */             break; 
/* 161 */           i++;
/*     */         } 
/* 163 */         i++;
/*     */         continue;
/*     */       } 
/*     */       i++;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final boolean vowelinstem() {
/* 171 */     for (int i = this.k0; i <= this.j; i++) {
/* 172 */       if (!cons(i))
/* 173 */         return true; 
/* 174 */     }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean doublec(int j) {
/* 180 */     if (j < this.k0 + 1)
/* 181 */       return false; 
/* 182 */     if (this.b[j] != this.b[j - 1])
/* 183 */       return false; 
/* 184 */     return cons(j);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cvc(int i) {
/* 197 */     if (i < this.k0 + 2 || !cons(i) || cons(i - 1) || !cons(i - 2)) {
/* 198 */       return false;
/*     */     }
/* 200 */     int ch = this.b[i];
/* 201 */     if (ch == 119 || ch == 120 || ch == 121) return false;
/*     */     
/* 203 */     return true;
/*     */   }
/*     */   
/*     */   private final boolean ends(String s) {
/* 207 */     int l = s.length();
/* 208 */     int o = this.k - l + 1;
/* 209 */     if (o < this.k0)
/* 210 */       return false; 
/* 211 */     for (int i = 0; i < l; i++) {
/* 212 */       if (this.b[o + i] != s.charAt(i))
/* 213 */         return false; 
/* 214 */     }  this.j = this.k - l;
/* 215 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setto(String s) {
/* 222 */     int l = s.length();
/* 223 */     int o = this.j + 1;
/* 224 */     for (int i = 0; i < l; i++)
/* 225 */       this.b[o + i] = s.charAt(i); 
/* 226 */     this.k = this.j + l;
/* 227 */     this.dirty = true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 232 */   void r(String s) { if (m() > 0) setto(s);
/*     */      }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step1() {
/* 257 */     if (this.b[this.k] == 's')
/* 258 */       if (ends(""sses"")) { this.k -= 2; }
/* 259 */       else if (ends(""ies"")) { setto(""i""); }
/* 260 */       else if (this.b[this.k - 1] != 's') { this.k--; }
/*     */        
/* 262 */     if (ends(""eed"")) {
/* 263 */       if (m() > 0) {
/* 264 */         this.k--;
/*     */       }
/* 266 */     } else if ((ends(""ed"") || ends(""ing"")) && vowelinstem()) {
/* 267 */       this.k = this.j;
/* 268 */       if (ends(""at"")) { setto(""ate""); }
/* 269 */       else if (ends(""bl"")) { setto(""ble""); }
/* 270 */       else if (ends(""iz"")) { setto(""ize""); }
/* 271 */       else if (doublec(this.k))
/* 272 */       { int ch = this.b[this.k--];
/* 273 */         if (ch == 108 || ch == 115 || ch == 122) {
/* 274 */           this.k++;
/*     */         } }
/* 276 */       else if (m() == 1 && cvc(this.k))
/* 277 */       { setto(""e""); }
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step2() {
/* 284 */     if (ends(""y"") && vowelinstem()) {
/* 285 */       this.b[this.k] = 'i';
/* 286 */       this.dirty = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step3() {
/* 295 */     if (this.k == this.k0)
/* 296 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 298 */         if (ends(""ational"")) { r(""ate""); break; }
/* 299 */          if (ends(""tional"")) r(""tion""); 
/*     */         break;
/*     */       case 'c':
/* 302 */         if (ends(""enci"")) { r(""ence""); break; }
/* 303 */          if (ends(""anci"")) r(""ance""); 
/*     */         break;
/*     */       case 'e':
/* 306 */         if (ends(""izer"")) r(""ize""); 
/*     */         break;
/*     */       case 'l':
/* 309 */         if (ends(""bli"")) { r(""ble""); break; }
/* 310 */          if (ends(""alli"")) { r(""al""); break; }
/* 311 */          if (ends(""entli"")) { r(""ent""); break; }
/* 312 */          if (ends(""eli"")) { r(""e""); break; }
/* 313 */          if (ends(""ousli"")) r(""ous""); 
/*     */         break;
/*     */       case 'o':
/* 316 */         if (ends(""ization"")) { r(""ize""); break; }
/* 317 */          if (ends(""ation"")) { r(""ate""); break; }
/* 318 */          if (ends(""ator"")) r(""ate""); 
/*     */         break;
/*     */       case 's':
/* 321 */         if (ends(""alism"")) { r(""al""); break; }
/* 322 */          if (ends(""iveness"")) { r(""ive""); break; }
/* 323 */          if (ends(""fulness"")) { r(""ful""); break; }
/* 324 */          if (ends(""ousness"")) r(""ous""); 
/*     */         break;
/*     */       case 't':
/* 327 */         if (ends(""aliti"")) { r(""al""); break; }
/* 328 */          if (ends(""iviti"")) { r(""ive""); break; }
/* 329 */          if (ends(""biliti"")) r(""ble""); 
/*     */         break;
/*     */       case 'g':
/* 332 */         if (ends(""logi"")) r(""log"");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void step4() {
/* 339 */     switch (this.b[this.k]) {
/*     */       case 'e':
/* 341 */         if (ends(""icate"")) { r(""ic""); break; }
/* 342 */          if (ends(""ative"")) { r(""""); break; }
/* 343 */          if (ends(""alize"")) r(""al""); 
/*     */         break;
/*     */       case 'i':
/* 346 */         if (ends(""iciti"")) r(""ic""); 
/*     */         break;
/*     */       case 'l':
/* 349 */         if (ends(""ical"")) { r(""ic""); break; }
/* 350 */          if (ends(""ful"")) r(""""); 
/*     */         break;
/*     */       case 's':
/* 353 */         if (ends(""ness"")) r("""");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step5() {
/* 361 */     if (this.k == this.k0)
/* 362 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 364 */         if (ends(""al""))
/*     */           break;  return;
/*     */       case 'c':
/* 367 */         if (ends(""ance"") || 
/* 368 */           ends(""ence""))
/*     */           break;  return;
/*     */       case 'e':
/* 371 */         if (ends(""er""))
/*     */           break;  return;
/* 373 */       case 'i': if (ends(""ic""))
/*     */           break;  return;
/* 375 */       case 'l': if (ends(""able"") || 
/* 376 */           ends(""ible""))
/*     */           break;  return;
/* 378 */       case 'n': if (ends(""ant"") || 
/* 379 */           ends(""ement"") || 
/* 380 */           ends(""ment""))
/*     */           break; 
/* 382 */         if (ends(""ent""))
/*     */           break;  return;
/*     */       case 'o':
/* 385 */         if (ends(""ion"") && this.j >= 0 && (this.b[this.j] == 's' || this.b[this.j] == 't'))
/*     */           break; 
/* 387 */         if (ends(""ou""))
/*     */           break; 
/*     */         return;
/*     */       case 's':
/* 391 */         if (ends(""ism""))
/*     */           break;  return;
/*     */       case 't':
/* 394 */         if (ends(""ate"") || 
/* 395 */           ends(""iti""))
/*     */           break;  return;
/*     */       case 'u':
/* 398 */         if (ends(""ous""))
/*     */           break;  return;
/*     */       case 'v':
/* 401 */         if (ends(""ive""))
/*     */           break;  return;
/*     */       case 'z':
/* 404 */         if (ends(""ize""))
/*     */           break;  return;
/*     */       default:
/*     */         return;
/*     */     } 
/* 409 */     if (m() > 1) {
/* 410 */       this.k = this.j;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step6() {
/* 416 */     this.j = this.k;
/* 417 */     if (this.b[this.k] == 'e') {
/* 418 */       int a = m();
/* 419 */       if (a > 1 || (a == 1 && !cvc(this.k - 1)))
/* 420 */         this.k--; 
/*     */     } 
/* 422 */     if (this.b[this.k] == 'l' && doublec(this.k) && m() > 1) {
/* 423 */       this.k--;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String stem(String s) {
/* 431 */     if (stem(s.toCharArray(), s.length())) {
/* 432 */       return toString();
/*     */     }
/* 434 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 442 */   public boolean stem(char[] word) { return stem(word, word.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean stem(char[] wordBuffer, int offset, int wordLen) {
/* 451 */     reset();
/* 452 */     if (this.b.length < wordLen) {
/* 453 */       char[] new_b = new char[wordLen + 1];
/* 454 */       this.b = new_b;
/*     */     } 
/* 456 */     for (int j = 0; j < wordLen; j++)
/* 457 */       this.b[j] = wordBuffer[offset + j]; 
/* 458 */     this.i = wordLen;
/* 459 */     return stem(0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 468 */   public boolean stem(char[] word, int wordLen) { return stem(word, 0, wordLen); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 477 */   public boolean stem() { return stem(0); }
/*     */ 
/*     */   
/*     */   public boolean stem(int i0) {
/* 481 */     this.k = this.i - 1;
/* 482 */     this.k0 = i0;
/* 483 */     if (this.k > this.k0 + 1) {
/* 484 */       step1(); step2(); step3(); step4(); step5(); step6();
/*     */     } 
/*     */ 
/*     */     
/* 488 */     if (this.i != this.k + 1)
/* 489 */       this.dirty = true; 
/* 490 */     this.i = this.k + 1;
/* 491 */     return this.dirty;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) {
/* 499 */     PorterStemmer s = new PorterStemmer();
/*     */     
/* 501 */     for (int i = 0; i < args.length; i++) {
/*     */       try {
/* 503 */         InputStream in = new FileInputStream(args[i]);
/* 504 */         byte[] buffer = new byte[1024];
/*     */ 
/*     */         
/* 507 */         int bufferLen = in.read(buffer);
/* 508 */         int offset = 0;
/* 509 */         s.reset();
/*     */         while (true) {
/*     */           int ch;
/* 512 */           if (offset < bufferLen) {
/* 513 */             ch = buffer[offset++];
/*     */           } else {
/* 515 */             bufferLen = in.read(buffer);
/* 516 */             offset = 0;
/* 517 */             if (bufferLen < 0) {
/* 518 */               ch = -1;
/*     */             } else {
/* 520 */               ch = buffer[offset++];
/*     */             } 
/*     */           } 
/* 523 */           if (Character.isLetter((char)ch)) {
/* 524 */             s.add(Character.toLowerCase((char)ch));
/*     */             continue;
/*     */           } 
/* 527 */           s.stem();
/* 528 */           System.out.print(s.toString());
/* 529 */           s.reset();
/* 530 */           if (ch < 0) {
/*     */             break;
/*     */           }
/* 533 */           System.out.print((char)ch);
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 538 */         in.close();
/*     */       }
/* 540 */       catch (IOException e) {
/* 541 */         System.out.println(""error reading "" + args[i]);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\PorterStemmer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.SimpleAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class SimpleAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 25 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new LowerCaseTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\SimpleAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StopAnalyzer
/*    */   extends Analyzer
/*    */ {
/*    */   private Set stopWords;
/* 31 */   public static final String[] ENGLISH_STOP_WORDS = new String[] { ""a"", ""an"", ""and"", ""are"", ""as"", ""at"", ""be"", ""but"", ""by"", ""for"", ""if"", ""in"", ""into"", ""is"", ""it"", ""no"", ""not"", ""of"", ""on"", ""or"", ""s"", ""such"", ""t"", ""that"", ""the"", ""their"", ""then"", ""there"", ""these"", ""they"", ""this"", ""to"", ""was"", ""will"", ""with"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public StopAnalyzer() { this.stopWords = StopFilter.makeStopSet(ENGLISH_STOP_WORDS); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 47 */   public StopAnalyzer(Set stopWords) { this.stopWords = stopWords; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 52 */   public StopAnalyzer(String[] stopWords) { this.stopWords = StopFilter.makeStopSet(stopWords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public StopAnalyzer(File stopwordsFile) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwordsFile); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 66 */   public StopAnalyzer(Reader stopwords) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 71 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new StopFilter(new LowerCaseTokenizer(reader), this.stopWords); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\StopAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class StopFilter
/*     */   extends TokenFilter
/*     */ {
/*     */   private final Set stopWords;
/*     */   private final boolean ignoreCase;
/*     */   
/*  37 */   public StopFilter(TokenStream input, String[] stopWords) { this(input, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream in, String[] stopWords, boolean ignoreCase) {
/*  45 */     super(in);
/*  46 */     this.ignoreCase = ignoreCase;
/*  47 */     this.stopWords = makeStopSet(stopWords, ignoreCase);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream input, Set stopWords, boolean ignoreCase) {
/*  59 */     super(input);
/*  60 */     this.ignoreCase = ignoreCase;
/*  61 */     this.stopWords = stopWords;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public StopFilter(TokenStream in, Set stopWords) { this(in, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public static final Set makeStopSet(String[] stopWords) { return makeStopSet(stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final Set makeStopSet(String[] stopWords, boolean ignoreCase) {
/*  95 */     HashSet stopTable = new HashSet(stopWords.length);
/*  96 */     for (int i = 0; i < stopWords.length; i++)
/*  97 */       stopTable.add(ignoreCase ? stopWords[i].toLowerCase() : stopWords[i]); 
/*  98 */     return stopTable;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Token next() throws IOException {
/* 106 */     for (Token token = this.input.next(); token != null; token = this.input.next()) {
/*     */       
/* 108 */       String termText = this.ignoreCase ? token.termText.toLowerCase() : token.termText;
/* 109 */       if (!this.stopWords.contains(termText)) {
/* 110 */         return token;
/*     */       }
/*     */     } 
/* 113 */     return null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\StopFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Token,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Token
/*     */ {
/*     */   String termText;
/*     */   int startOffset;
/*     */   int endOffset;
/*  37 */   String type = ""word"";
/*     */   
/*  39 */   private int positionIncrement = 1;
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end) {
/*  44 */     this.termText = text;
/*  45 */     this.startOffset = start;
/*  46 */     this.endOffset = end;
/*     */   }
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end, String typ) {
/*  51 */     this.termText = text;
/*  52 */     this.startOffset = start;
/*  53 */     this.endOffset = end;
/*  54 */     this.type = typ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setPositionIncrement(int positionIncrement) {
/*  83 */     if (positionIncrement < 0) {
/*  84 */       throw new IllegalArgumentException(""Increment must be zero or greater: "" + positionIncrement);
/*     */     }
/*  86 */     this.positionIncrement = positionIncrement;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  92 */   public int getPositionIncrement() { return this.positionIncrement; }
/*     */ 
/*     */   
/*  95 */   public final String termText() { return this.termText; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public final int startOffset() { return this.startOffset; }
/*     */ 
/*     */ 
/*     */   
/* 107 */   public final int endOffset() { return this.endOffset; }
/*     */ 
/*     */   
/* 110 */   public final String type() { return this.type; }
/*     */   
/*     */   public final String toString() {
/* 113 */     StringBuffer sb = new StringBuffer();
/* 114 */     sb.append(""("" + this.termText + "","" + this.startOffset + "","" + this.endOffset);
/* 115 */     if (!this.type.equals(""word""))
/* 116 */       sb.append("",type="" + this.type); 
/* 117 */     if (this.positionIncrement != 1)
/* 118 */       sb.append("",posIncr="" + this.positionIncrement); 
/* 119 */     sb.append("")"");
/* 120 */     return sb.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TokenFilter
/*    */   extends TokenStream
/*    */ {
/*    */   protected TokenStream input;
/*    */   
/* 32 */   protected TokenFilter(TokenStream input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 37 */   public void close() throws IOException { this.input.close(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\TokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Tokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Tokenizer
/*    */   extends TokenStream
/*    */ {
/*    */   protected Reader input;
/*    */   
/*    */   protected Tokenizer() {}
/*    */   
/* 36 */   protected Tokenizer(Reader input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public void close() throws IOException { this.input.close(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\Tokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenStream,"package org.apache.lucene.analysis;
import java.io.IOException;
public abstract class TokenStream {
  public abstract Token next() throws IOException;
  public void close() throws IOException {}
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\TokenStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class WhitespaceAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 25 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new WhitespaceTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\WhitespaceAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WhitespaceTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 27 */   public WhitespaceTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 33 */   protected boolean isTokenChar(char c) { return !Character.isWhitespace(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\WhitespaceTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WordlistLoader,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.BufferedReader;
/*     */ import java.io.File;
/*     */ import java.io.FileReader;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.HashSet;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Iterator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WordlistLoader
/*     */ {
/*     */   public static HashSet getWordSet(File wordfile) throws IOException {
/*  46 */     HashSet result = new HashSet();
/*  47 */     FileReader reader = null;
/*     */     try {
/*  49 */       reader = new FileReader(wordfile);
/*  50 */       result = getWordSet(reader);
/*     */     } finally {
/*     */       
/*  53 */       if (reader != null)
/*  54 */         reader.close(); 
/*     */     } 
/*  56 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static HashSet getWordSet(Reader reader) throws IOException {
/*  69 */     HashSet result = new HashSet();
/*  70 */     BufferedReader br = null;
/*     */     try {
/*  72 */       if (reader instanceof BufferedReader) {
/*  73 */         br = (BufferedReader)reader;
/*     */       } else {
/*  75 */         br = new BufferedReader(reader);
/*     */       } 
/*  77 */       String word = null;
/*  78 */       while ((word = br.readLine()) != null) {
/*  79 */         result.add(word.trim());
/*     */       }
/*     */     } finally {
/*     */       
/*  83 */       if (br != null)
/*  84 */         br.close(); 
/*     */     } 
/*  86 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static Hashtable makeWordTable(HashSet wordSet) {
/*  97 */     Hashtable table = new Hashtable();
/*  98 */     for (Iterator iter = wordSet.iterator(); iter.hasNext(); ) {
/*  99 */       String word = iter.next();
/* 100 */       table.put(word, word);
/*     */     } 
/* 102 */     return table;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\WordlistLoader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.CharStream,"package org.apache.lucene.analysis.standard;
import java.io.IOException;
public interface CharStream {
  char readChar() throws IOException;
  int getEndColumn();
  int getEndLine();
  int getBeginColumn();
  int getBeginLine();
  void backup(int paramInt);
  char BeginToken() throws IOException;
  String GetImage();
  char[] GetSuffix(int paramInt);
  void Done();
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\CharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.FastCharStream,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FastCharStream
/*     */   implements CharStream
/*     */ {
/*  27 */   char[] buffer = null;
/*     */   
/*  29 */   int bufferLength = 0;
/*  30 */   int bufferPosition = 0;
/*     */   
/*  32 */   int tokenStart = 0;
/*  33 */   int bufferStart = 0;
/*     */ 
/*     */   
/*     */   Reader input;
/*     */ 
/*     */   
/*  39 */   public FastCharStream(Reader r) { this.input = r; }
/*     */ 
/*     */   
/*     */   public final char readChar() throws IOException {
/*  43 */     if (this.bufferPosition >= this.bufferLength)
/*  44 */       refill(); 
/*  45 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   private final void refill() throws IOException {
/*  49 */     int newPosition = this.bufferLength - this.tokenStart;
/*     */     
/*  51 */     if (this.tokenStart == 0) {
/*  52 */       if (this.buffer == null) {
/*  53 */         this.buffer = new char[2048];
/*  54 */       } else if (this.bufferLength == this.buffer.length) {
/*  55 */         char[] newBuffer = new char[this.buffer.length * 2];
/*  56 */         System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferLength);
/*  57 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } else {
/*  60 */       System.arraycopy(this.buffer, this.tokenStart, this.buffer, 0, newPosition);
/*     */     } 
/*     */     
/*  63 */     this.bufferLength = newPosition;
/*  64 */     this.bufferPosition = newPosition;
/*  65 */     this.bufferStart += this.tokenStart;
/*  66 */     this.tokenStart = 0;
/*     */     
/*  68 */     int charsRead = this.input.read(this.buffer, newPosition, this.buffer.length - newPosition);
/*     */     
/*  70 */     if (charsRead == -1) {
/*  71 */       throw new IOException(""read past eof"");
/*     */     }
/*  73 */     this.bufferLength += charsRead;
/*     */   }
/*     */   
/*     */   public final char BeginToken() throws IOException {
/*  77 */     this.tokenStart = this.bufferPosition;
/*  78 */     return readChar();
/*     */   }
/*     */ 
/*     */   
/*  82 */   public final void backup(int amount) { this.bufferPosition -= amount; }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public final String GetImage() { return new String(this.buffer, this.tokenStart, this.bufferPosition - this.tokenStart); }
/*     */ 
/*     */   
/*     */   public final char[] GetSuffix(int len) {
/*  90 */     char[] value = new char[len];
/*  91 */     System.arraycopy(this.buffer, this.bufferPosition - len, value, 0, len);
/*  92 */     return value;
/*     */   }
/*     */   
/*     */   public final void Done() {
/*     */     try {
/*  97 */       this.input.close();
/*  98 */     } catch (IOException e) {
/*  99 */       System.err.println(""Caught: "" + e + ""; ignoring."");
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 104 */   public final int getColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 107 */   public final int getLine() { return 1; }
/*     */ 
/*     */   
/* 110 */   public final int getEndColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 113 */   public final int getEndLine() { return 1; }
/*     */ 
/*     */   
/* 116 */   public final int getBeginColumn() { return this.bufferStart + this.tokenStart; }
/*     */ 
/*     */   
/* 119 */   public final int getBeginLine() { return 1; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\FastCharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.ParseException,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParseException
/*     */   extends IOException
/*     */ {
/*     */   protected boolean specialConstructor;
/*     */   public Token currentToken;
/*     */   public int[][] expectedTokenSequences;
/*     */   public String[] tokenImage;
/*     */   protected String eol;
/*     */   
/*     */   public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
/*  32 */     super("""");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 139 */     this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = true; this.currentToken = currentTokenVal; this.expectedTokenSequences = expectedTokenSequencesVal; this.tokenImage = tokenImageVal; } public ParseException() { this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = false; } public ParseException(String message) { super(message); this.eol = System.getProperty(""line.separator"", ""\n"");
/*     */     this.specialConstructor = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String add_escapes(String str) {
/* 147 */     StringBuffer retval = new StringBuffer();
/*     */     
/* 149 */     for (int i = 0; i < str.length(); i++) {
/* 150 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/* 155 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/* 158 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/* 161 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/* 164 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/* 167 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/* 170 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/* 173 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/* 176 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/* 179 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/* 180 */             String s = ""0000"" + Integer.toString(ch, 16);
/* 181 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/* 183 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/* 188 */     return retval.toString();
/*     */   }
/*     */   
/*     */   public String getMessage() {
/*     */     if (!this.specialConstructor)
/*     */       return super.getMessage(); 
/*     */     String expected = """";
/*     */     int maxSize = 0;
/*     */     for (int i = 0; i < this.expectedTokenSequences.length; i++) {
/*     */       if (maxSize < (this.expectedTokenSequences[i]).length)
/*     */         maxSize = (this.expectedTokenSequences[i]).length; 
/*     */       for (int j = 0; j < (this.expectedTokenSequences[i]).length; j++)
/*     */         expected = expected + this.tokenImage[this.expectedTokenSequences[i][j]] + "" ""; 
/*     */       if (this.expectedTokenSequences[i][(this.expectedTokenSequences[i]).length - 1] != 0)
/*     */         expected = expected + ""...""; 
/*     */       expected = expected + this.eol + ""    "";
/*     */     } 
/*     */     String retval = ""Encountered \"""";
/*     */     Token tok = this.currentToken.next;
/*     */     for (int i = 0; i < maxSize; i++) {
/*     */       if (i != 0)
/*     */         retval = retval + "" ""; 
/*     */       if (tok.kind == 0) {
/*     */         retval = retval + this.tokenImage[0];
/*     */         break;
/*     */       } 
/*     */       retval = retval + add_escapes(tok.image);
/*     */       tok = tok.next;
/*     */     } 
/*     */     retval = retval + ""\"" at line "" + this.currentToken.next.beginLine + "", column "" + this.currentToken.next.beginColumn + ""."" + this.eol;
/*     */     if (this.expectedTokenSequences.length == 1) {
/*     */       retval = retval + ""Was expecting:"" + this.eol + ""    "";
/*     */     } else {
/*     */       retval = retval + ""Was expecting one of:"" + this.eol + ""    "";
/*     */     } 
/*     */     retval = retval + expected;
/*     */     return retval;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\ParseException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardAnalyzer,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.Set;
/*    */ import org.apache.lucene.analysis.Analyzer;
/*    */ import org.apache.lucene.analysis.LowerCaseFilter;
/*    */ import org.apache.lucene.analysis.StopAnalyzer;
/*    */ import org.apache.lucene.analysis.StopFilter;
/*    */ import org.apache.lucene.analysis.TokenStream;
/*    */ import org.apache.lucene.analysis.WordlistLoader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StandardAnalyzer
/*    */   extends Analyzer
/*    */ {
/*    */   private Set stopSet;
/* 37 */   public static final String[] STOP_WORDS = StopAnalyzer.ENGLISH_STOP_WORDS;
/*    */ 
/*    */ 
/*    */   
/* 41 */   public StandardAnalyzer() { this(STOP_WORDS); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 46 */   public StandardAnalyzer(Set stopWords) { this.stopSet = stopWords; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   public StandardAnalyzer(String[] stopWords) { this.stopSet = StopFilter.makeStopSet(stopWords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 58 */   public StandardAnalyzer(File stopwords) throws IOException { this.stopSet = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 65 */   public StandardAnalyzer(Reader stopwords) throws IOException { this.stopSet = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 71 */     StandardTokenizer standardTokenizer = new StandardTokenizer(reader);
/* 72 */     StandardFilter standardFilter = new StandardFilter((TokenStream)standardTokenizer);
/* 73 */     LowerCaseFilter lowerCaseFilter = new LowerCaseFilter((TokenStream)standardFilter);
/* 74 */     return (TokenStream)new StopFilter((TokenStream)lowerCaseFilter, this.stopSet);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\StandardAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardFilter,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.analysis.Token;
/*    */ import org.apache.lucene.analysis.TokenFilter;
/*    */ import org.apache.lucene.analysis.TokenStream;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StandardFilter
/*    */   extends TokenFilter
/*    */   implements StandardTokenizerConstants
/*    */ {
/* 29 */   public StandardFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/* 32 */   private static final String APOSTROPHE_TYPE = tokenImage[2];
/* 33 */   private static final String ACRONYM_TYPE = tokenImage[3];
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 40 */     Token t = this.input.next();
/*    */     
/* 42 */     if (t == null) {
/* 43 */       return null;
/*    */     }
/* 45 */     String text = t.termText();
/* 46 */     String type = t.type();
/*    */     
/* 48 */     if (type == APOSTROPHE_TYPE && (text.endsWith(""'s"") || text.endsWith(""'S"")))
/*    */     {
/* 50 */       return new Token(text.substring(0, text.length() - 2), t.startOffset(), t.endOffset(), type);
/*    */     }
/*    */ 
/*    */     
/* 54 */     if (type == ACRONYM_TYPE) {
/* 55 */       StringBuffer trimmed = new StringBuffer();
/* 56 */       for (int i = 0; i < text.length(); i++) {
/* 57 */         char c = text.charAt(i);
/* 58 */         if (c != '.')
/* 59 */           trimmed.append(c); 
/*    */       } 
/* 61 */       return new Token(trimmed.toString(), t.startOffset(), t.endOffset(), type);
/*    */     } 
/*    */ 
/*    */     
/* 65 */     return t;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\StandardFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizer,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.Tokenizer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class StandardTokenizer
/*     */   extends Tokenizer
/*     */   implements StandardTokenizerConstants
/*     */ {
/*     */   public StandardTokenizerTokenManager token_source;
/*     */   public Token token;
/*     */   public Token jj_nt;
/*     */   private int jj_ntk;
/*     */   private int jj_gen;
/*     */   
/*     */   public StandardTokenizer(Reader reader) {
/*  26 */     this(new FastCharStream(reader));
/*  27 */     this.input = reader;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Token next() throws ParseException, IOException {
/*  35 */     Token token = null;
/*  36 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*     */       case 1:
/*  38 */         token = jj_consume_token(1);
/*     */         break;
/*     */       case 2:
/*  41 */         token = jj_consume_token(2);
/*     */         break;
/*     */       case 3:
/*  44 */         token = jj_consume_token(3);
/*     */         break;
/*     */       case 4:
/*  47 */         token = jj_consume_token(4);
/*     */         break;
/*     */       case 5:
/*  50 */         token = jj_consume_token(5);
/*     */         break;
/*     */       case 6:
/*  53 */         token = jj_consume_token(6);
/*     */         break;
/*     */       case 7:
/*  56 */         token = jj_consume_token(7);
/*     */         break;
/*     */       case 12:
/*  59 */         token = jj_consume_token(12);
/*     */         break;
/*     */       case 0:
/*  62 */         token = jj_consume_token(0);
/*     */         break;
/*     */       default:
/*  65 */         this.jj_la1[0] = this.jj_gen;
/*  66 */         jj_consume_token(-1);
/*  67 */         throw new ParseException();
/*     */     } 
/*  69 */     if (token.kind == 0) {
/*  70 */       return null;
/*     */     }
/*  72 */     return new Token(token.image, token.beginColumn, token.endColumn, tokenImage[token.kind]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   private final int[] jj_la1 = new int[1]; private static int[] jj_la1_0; private Vector jj_expentries; private int[] jj_expentry; private int jj_kind;
/*     */   
/*     */   static  {
/*  87 */     jj_la1_0();
/*     */   }
/*     */   
/*  90 */   private static void jj_la1_0() { jj_la1_0 = new int[] { 4351 }; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void ReInit(CharStream stream) {
/* 102 */     this.token_source.ReInit(stream);
/* 103 */     this.token = new Token();
/* 104 */     this.jj_ntk = -1;
/* 105 */     this.jj_gen = 0;
/* 106 */     for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }
/*     */   
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void ReInit(StandardTokenizerTokenManager tm) {
/* 118 */     this.token_source = tm;
/* 119 */     this.token = new Token();
/* 120 */     this.jj_ntk = -1;
/* 121 */     this.jj_gen = 0;
/* 122 */     for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }
/*     */   
/*     */   }
/*     */   private final Token jj_consume_token(int kind) throws ParseException {
/*     */     Token oldToken;
/* 127 */     if ((oldToken = this.token).next != null) { this.token = this.token.next; }
/* 128 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 129 */      this.jj_ntk = -1;
/* 130 */     if (this.token.kind == kind) {
/* 131 */       this.jj_gen++;
/* 132 */       return this.token;
/*     */     } 
/* 134 */     this.token = oldToken;
/* 135 */     this.jj_kind = kind;
/* 136 */     throw generateParseException();
/*     */   }
/*     */   
/*     */   public final Token getNextToken() {
/* 140 */     if (this.token.next != null) { this.token = this.token.next; }
/* 141 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 142 */      this.jj_ntk = -1;
/* 143 */     this.jj_gen++;
/* 144 */     return this.token;
/*     */   }
/*     */   
/*     */   public final Token getToken(int index) {
/* 148 */     Token t = this.token;
/* 149 */     for (int i = 0; i < index; i++) {
/* 150 */       if (t.next != null) { t = t.next; }
/* 151 */       else { t = t.next = this.token_source.getNextToken(); }
/*     */     
/* 153 */     }  return t;
/*     */   }
/*     */   
/*     */   private final int jj_ntk() {
/* 157 */     if ((this.jj_nt = this.token.next) == null) {
/* 158 */       return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;
/*     */     }
/* 160 */     return this.jj_ntk = this.jj_nt.kind;
/*     */   }
/*     */   
/* 163 */   public StandardTokenizer(CharStream stream) { this.jj_expentries = new Vector();
/*     */     
/* 165 */     this.jj_kind = -1; this.token_source = new StandardTokenizerTokenManager(stream); this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }  } public StandardTokenizer(StandardTokenizerTokenManager tm) { this.jj_expentries = new Vector(); this.jj_kind = -1; this.token_source = tm; this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 1; ) {
/*     */       this.jj_la1[i] = -1;
/*     */       i++;
/* 168 */     }  } public ParseException generateParseException() { this.jj_expentries.removeAllElements();
/* 169 */     boolean[] la1tokens = new boolean[16];
/* 170 */     for (int i = 0; i < 16; i++) {
/* 171 */       la1tokens[i] = false;
/*     */     }
/* 173 */     if (this.jj_kind >= 0) {
/* 174 */       la1tokens[this.jj_kind] = true;
/* 175 */       this.jj_kind = -1;
/*     */     } 
/* 177 */     for (int i = 0; i < 1; i++) {
/* 178 */       if (this.jj_la1[i] == this.jj_gen) {
/* 179 */         for (int j = 0; j < 32; j++) {
/* 180 */           if ((jj_la1_0[i] & 1 << j) != 0) {
/* 181 */             la1tokens[j] = true;
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/* 186 */     for (int i = 0; i < 16; i++) {
/* 187 */       if (la1tokens[i]) {
/* 188 */         this.jj_expentry = new int[1];
/* 189 */         this.jj_expentry[0] = i;
/* 190 */         this.jj_expentries.addElement(this.jj_expentry);
/*     */       } 
/*     */     } 
/* 193 */     int[][] exptokseq = new int[this.jj_expentries.size()][];
/* 194 */     for (int i = 0; i < this.jj_expentries.size(); i++) {
/* 195 */       exptokseq[i] = this.jj_expentries.elementAt(i);
/*     */     }
/* 197 */     return new ParseException(this.token, exptokseq, tokenImage); }
/*     */ 
/*     */   
/*     */   public final void enable_tracing() {}
/*     */   
/*     */   public final void disable_tracing() {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizerConstants,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface StandardTokenizerConstants
/*    */ {
/*    */   public static final int EOF = 0;
/*    */   public static final int ALPHANUM = 1;
/*    */   public static final int APOSTROPHE = 2;
/*    */   public static final int ACRONYM = 3;
/*    */   public static final int COMPANY = 4;
/*    */   public static final int EMAIL = 5;
/*    */   public static final int HOST = 6;
/*    */   public static final int NUM = 7;
/*    */   public static final int P = 8;
/*    */   public static final int HAS_DIGIT = 9;
/*    */   public static final int ALPHA = 10;
/*    */   public static final int LETTER = 11;
/*    */   public static final int CJ = 12;
/*    */   public static final int KOREAN = 13;
/*    */   public static final int DIGIT = 14;
/*    */   public static final int NOISE = 15;
/*    */   public static final int DEFAULT = 0;
/* 25 */   public static final String[] tokenImage = new String[] { ""<EOF>"", ""<ALPHANUM>"", ""<APOSTROPHE>"", ""<ACRONYM>"", ""<COMPANY>"", ""<EMAIL>"", ""<HOST>"", ""<NUM>"", ""<P>"", ""<HAS_DIGIT>"", ""<ALPHA>"", ""<LETTER>"", ""<CJ>"", ""<KOREAN>"", ""<DIGIT>"", ""<NOISE>"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizerConstants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizerTokenManager,"/*      */ package org.apache.lucene.analysis.standard;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ 
/*      */ public class StandardTokenizerTokenManager implements StandardTokenizerConstants {
/*    7 */   public PrintStream debugStream = System.out;
/*    8 */   public void setDebugStream(PrintStream ds) { this.debugStream = ds; }
/*      */ 
/*      */   
/*   11 */   private final int jjMoveStringLiteralDfa0_0() { return jjMoveNfa_0(0, 0); }
/*      */ 
/*      */   
/*      */   private final void jjCheckNAdd(int state) {
/*   15 */     if (this.jjrounds[state] != this.jjround) {
/*      */       
/*   17 */       this.jjstateSet[this.jjnewStateCnt++] = state;
/*   18 */       this.jjrounds[state] = this.jjround;
/*      */     } 
/*      */   }
/*      */   
/*      */   private final void jjAddStates(int start, int end) {
/*      */     do {
/*   24 */       this.jjstateSet[this.jjnewStateCnt++] = jjnextStates[start];
/*   25 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddTwoStates(int state1, int state2) {
/*   29 */     jjCheckNAdd(state1);
/*   30 */     jjCheckNAdd(state2);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start, int end) {
/*      */     do {
/*   35 */       jjCheckNAdd(jjnextStates[start]);
/*   36 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start) {
/*   40 */     jjCheckNAdd(jjnextStates[start]);
/*   41 */     jjCheckNAdd(jjnextStates[start + 1]);
/*      */   }
/*   43 */   static final long[] jjbitVec0 = new long[] { 2301339409586323456L, -16384L, 4294967295L, 432345564227567616L };
/*      */ 
/*      */   
/*   46 */   static final long[] jjbitVec2 = new long[] { 0L, -1L, -1L, -1L };
/*      */ 
/*      */   
/*   49 */   static final long[] jjbitVec3 = new long[] { -1L, -1L, 65535L, 0L };
/*      */ 
/*      */   
/*   52 */   static final long[] jjbitVec4 = new long[] { -1L, -1L, 0L, 0L };
/*      */ 
/*      */   
/*   55 */   static final long[] jjbitVec5 = new long[] { 70368744177663L, 0L, 0L, 0L };
/*      */ 
/*      */   
/*   58 */   static final long[] jjbitVec6 = new long[] { 0L, 0L, -17592186044416L, 8388607L };
/*      */ 
/*      */   
/*   61 */   static final long[] jjbitVec7 = new long[] { -1L, -1L, 281474976710655L, 0L };
/*      */ 
/*      */   
/*   64 */   static final long[] jjbitVec8 = new long[] { 4294967294L, 0L, 0L, 0L };
/*      */ 
/*      */   
/*   67 */   static final long[] jjbitVec9 = new long[] { 0L, 0L, 0L, -36028797027352577L };
/*      */ 
/*      */   
/*   70 */   static final long[] jjbitVec10 = new long[] { 5632L, 0L, 0L, 0L };
/*      */ 
/*      */   
/*   73 */   static final long[] jjbitVec11 = new long[] { 0L, 281200098803712L, 0L, 281200098803712L };
/*      */ 
/*      */   
/*   76 */   static final long[] jjbitVec12 = new long[] { 0L, 4393751543808L, 0L, 287948901175001088L };
/*      */ 
/*      */   
/*   79 */   static final long[] jjbitVec13 = new long[] { 0L, 281200098803712L, 0L, 280925220896768L };
/*      */ 
/*      */   
/*   82 */   static final long[] jjbitVec14 = new long[] { 0L, 281200098803712L, 0L, 0L };
/*      */ 
/*      */   
/*   85 */   static final long[] jjbitVec15 = new long[] { 0L, 67043328L, 0L, 67043328L };
/*      */ 
/*      */   
/*   88 */   static final long[] jjbitVec16 = new long[] { 0L, 1023L, 0L, 0L };
/*      */ 
/*      */   
/*   91 */   static final long[] jjbitVec17 = new long[] { 4294967294L, 0L, -17592186044416L, 8388607L };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_0(int startState, int curPos) {
/*   97 */     int startsAt = 0;
/*   98 */     this.jjnewStateCnt = 75;
/*   99 */     int i = 1;
/*  100 */     this.jjstateSet[0] = startState;
/*  101 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  104 */       if (++this.jjround == Integer.MAX_VALUE)
/*  105 */         ReInitRounds(); 
/*  106 */       if (this.curChar < '@') {
/*      */         
/*  108 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  111 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  114 */               if ((0x3FF000000000000L & l) != 0L) {
/*      */                 
/*  116 */                 if (kind > 1)
/*  117 */                   kind = 1; 
/*  118 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  120 */               if ((0x3FF000000000000L & l) != 0L)
/*  121 */                 jjCheckNAddStates(12, 17); 
/*  122 */               if ((0x3FF000000000000L & l) != 0L)
/*  123 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 2:
/*  126 */               if ((0x3FF000000000000L & l) != 0L)
/*  127 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  130 */               if ((0x3FF000000000000L & l) != 0L)
/*  131 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 4:
/*      */             case 5:
/*  135 */               if ((0x3FF000000000000L & l) != 0L)
/*  136 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 6:
/*  139 */               if ((0xF00000000000L & l) != 0L)
/*  140 */                 jjCheckNAdd(7); 
/*      */               break;
/*      */             case 7:
/*  143 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  145 */               if (kind > 7)
/*  146 */                 kind = 7; 
/*  147 */               jjCheckNAdd(7);
/*      */               break;
/*      */             case 8:
/*  150 */               if ((0x3FF000000000000L & l) != 0L)
/*  151 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 9:
/*      */             case 10:
/*  155 */               if ((0x3FF000000000000L & l) != 0L)
/*  156 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 11:
/*  159 */               if ((0xF00000000000L & l) != 0L)
/*  160 */                 jjCheckNAdd(12); 
/*      */               break;
/*      */             case 12:
/*  163 */               if ((0x3FF000000000000L & l) != 0L)
/*  164 */                 jjCheckNAddTwoStates(12, 13); 
/*      */               break;
/*      */             case 13:
/*  167 */               if ((0xF00000000000L & l) != 0L)
/*  168 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 14:
/*  171 */               if ((0x3FF000000000000L & l) != 0L)
/*  172 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 15:
/*      */             case 16:
/*  176 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  178 */               if (kind > 7)
/*  179 */                 kind = 7; 
/*  180 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  183 */               if ((0x3FF000000000000L & l) != 0L)
/*  184 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 18:
/*      */             case 19:
/*  188 */               if ((0x3FF000000000000L & l) != 0L)
/*  189 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 20:
/*  192 */               if ((0xF00000000000L & l) != 0L)
/*  193 */                 jjCheckNAdd(21); 
/*      */               break;
/*      */             case 21:
/*  196 */               if ((0x3FF000000000000L & l) != 0L)
/*  197 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 22:
/*  200 */               if ((0xF00000000000L & l) != 0L)
/*  201 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 23:
/*  204 */               if ((0x3FF000000000000L & l) != 0L)
/*  205 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 24:
/*      */             case 25:
/*  209 */               if ((0x3FF000000000000L & l) != 0L)
/*  210 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 26:
/*  213 */               if ((0xF00000000000L & l) != 0L)
/*  214 */                 jjCheckNAdd(27); 
/*      */               break;
/*      */             case 27:
/*  217 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  219 */               if (kind > 7)
/*  220 */                 kind = 7; 
/*  221 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 28:
/*  224 */               if ((0x3FF000000000000L & l) != 0L)
/*  225 */                 jjCheckNAddStates(12, 17); 
/*      */               break;
/*      */             case 29:
/*  228 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  230 */               if (kind > 1)
/*  231 */                 kind = 1; 
/*  232 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  235 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  237 */               if (kind > 1)
/*  238 */                 kind = 1; 
/*  239 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  242 */               if ((0x3FF000000000000L & l) != 0L)
/*  243 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 32:
/*  246 */               if ((0x600000000000L & l) != 0L)
/*  247 */                 jjCheckNAdd(33); 
/*      */               break;
/*      */             case 33:
/*  250 */               if ((0x3FF000000000000L & l) != 0L)
/*  251 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 35:
/*  254 */               if ((0x3FF000000000000L & l) != 0L)
/*  255 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 36:
/*  258 */               if ((0x600000000000L & l) != 0L)
/*  259 */                 jjCheckNAdd(37); 
/*      */               break;
/*      */             case 37:
/*  262 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  264 */               if (kind > 5)
/*  265 */                 kind = 5; 
/*  266 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  269 */               if ((0x3FF000000000000L & l) != 0L)
/*  270 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 39:
/*  273 */               if (this.curChar == '.')
/*  274 */                 jjCheckNAdd(40); 
/*      */               break;
/*      */             case 40:
/*  277 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  279 */               if (kind > 6)
/*  280 */                 kind = 6; 
/*  281 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  284 */               if ((0x3FF000000000000L & l) != 0L)
/*  285 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 42:
/*  288 */               if ((0xF00000000000L & l) != 0L)
/*  289 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 43:
/*  292 */               if ((0x3FF000000000000L & l) != 0L)
/*  293 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 44:
/*      */             case 45:
/*  297 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  299 */               if (kind > 7)
/*  300 */                 kind = 7; 
/*  301 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 46:
/*  304 */               if ((0x3FF000000000000L & l) != 0L)
/*  305 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 47:
/*  308 */               if ((0xF00000000000L & l) != 0L)
/*  309 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 48:
/*  312 */               if ((0x3FF000000000000L & l) != 0L)
/*  313 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 49:
/*      */             case 50:
/*  317 */               if ((0x3FF000000000000L & l) != 0L)
/*  318 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 51:
/*  321 */               if ((0xF00000000000L & l) != 0L)
/*  322 */                 jjCheckNAdd(52); 
/*      */               break;
/*      */             case 52:
/*  325 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  327 */               if (kind > 7)
/*  328 */                 kind = 7; 
/*  329 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  332 */               if ((0x3FF000000000000L & l) != 0L)
/*  333 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 54:
/*  336 */               if ((0xF00000000000L & l) != 0L)
/*  337 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 55:
/*  340 */               if ((0x3FF000000000000L & l) != 0L)
/*  341 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 56:
/*      */             case 57:
/*  345 */               if ((0x3FF000000000000L & l) != 0L)
/*  346 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 58:
/*  349 */               if ((0xF00000000000L & l) != 0L)
/*  350 */                 jjCheckNAdd(59); 
/*      */               break;
/*      */             case 59:
/*  353 */               if ((0x3FF000000000000L & l) != 0L)
/*  354 */                 jjCheckNAddTwoStates(59, 60); 
/*      */               break;
/*      */             case 60:
/*  357 */               if ((0xF00000000000L & l) != 0L)
/*  358 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 61:
/*  361 */               if ((0x3FF000000000000L & l) != 0L)
/*  362 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 62:
/*      */             case 63:
/*  366 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  368 */               if (kind > 7)
/*  369 */                 kind = 7; 
/*  370 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 66:
/*  373 */               if (this.curChar == '\'')
/*  374 */                 this.jjstateSet[this.jjnewStateCnt++] = 67; 
/*      */               break;
/*      */             case 69:
/*  377 */               if (this.curChar == '.')
/*  378 */                 jjCheckNAdd(70); 
/*      */               break;
/*      */             case 71:
/*  381 */               if (this.curChar != '.')
/*      */                 break; 
/*  383 */               if (kind > 3)
/*  384 */                 kind = 3; 
/*  385 */               jjCheckNAdd(70);
/*      */               break;
/*      */             case 73:
/*  388 */               if (this.curChar == '&') {
/*  389 */                 this.jjstateSet[this.jjnewStateCnt++] = 74;
/*      */               }
/*      */               break;
/*      */           } 
/*  393 */         } while (i != startsAt);
/*      */       }
/*  395 */       else if (this.curChar < '') {
/*      */         
/*  397 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  400 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  403 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  404 */                 jjCheckNAddStates(30, 35); 
/*  405 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L) {
/*      */                 
/*  407 */                 if (kind > 1)
/*  408 */                   kind = 1; 
/*  409 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  411 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  412 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 2:
/*  415 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  416 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  419 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  420 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 5:
/*  423 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  424 */                 jjAddStates(36, 37); 
/*      */               break;
/*      */             case 6:
/*  427 */               if (this.curChar == '_')
/*  428 */                 jjCheckNAdd(7); 
/*      */               break;
/*      */             case 7:
/*  431 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  433 */               if (kind > 7)
/*  434 */                 kind = 7; 
/*  435 */               jjCheckNAdd(7);
/*      */               break;
/*      */             case 8:
/*  438 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  439 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 10:
/*  442 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  443 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 11:
/*  446 */               if (this.curChar == '_')
/*  447 */                 jjCheckNAdd(12); 
/*      */               break;
/*      */             case 12:
/*  450 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  451 */                 jjCheckNAddTwoStates(12, 13); 
/*      */               break;
/*      */             case 13:
/*  454 */               if (this.curChar == '_')
/*  455 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 14:
/*  458 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  459 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 16:
/*  462 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  464 */               if (kind > 7)
/*  465 */                 kind = 7; 
/*  466 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  469 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  470 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 19:
/*  473 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  474 */                 jjAddStates(38, 39); 
/*      */               break;
/*      */             case 20:
/*  477 */               if (this.curChar == '_')
/*  478 */                 jjCheckNAdd(21); 
/*      */               break;
/*      */             case 21:
/*  481 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  482 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 22:
/*  485 */               if (this.curChar == '_')
/*  486 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 23:
/*  489 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  490 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 25:
/*  493 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  494 */                 jjAddStates(40, 41); 
/*      */               break;
/*      */             case 26:
/*  497 */               if (this.curChar == '_')
/*  498 */                 jjCheckNAdd(27); 
/*      */               break;
/*      */             case 27:
/*  501 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  503 */               if (kind > 7)
/*  504 */                 kind = 7; 
/*  505 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 29:
/*  508 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  510 */               if (kind > 1)
/*  511 */                 kind = 1; 
/*  512 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  515 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  517 */               if (kind > 1)
/*  518 */                 kind = 1; 
/*  519 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  522 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  523 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 32:
/*  526 */               if (this.curChar == '_')
/*  527 */                 jjCheckNAdd(33); 
/*      */               break;
/*      */             case 33:
/*  530 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  531 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 34:
/*  534 */               if (this.curChar == '@')
/*  535 */                 jjCheckNAdd(35); 
/*      */               break;
/*      */             case 35:
/*  538 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  539 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 37:
/*  542 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  544 */               if (kind > 5)
/*  545 */                 kind = 5; 
/*  546 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  549 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  550 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 40:
/*  553 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  555 */               if (kind > 6)
/*  556 */                 kind = 6; 
/*  557 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  560 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  561 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 42:
/*  564 */               if (this.curChar == '_')
/*  565 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 43:
/*  568 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  569 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 45:
/*  572 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  574 */               if (kind > 7)
/*  575 */                 kind = 7; 
/*  576 */               this.jjstateSet[this.jjnewStateCnt++] = 45;
/*      */               break;
/*      */             case 46:
/*  579 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  580 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 47:
/*  583 */               if (this.curChar == '_')
/*  584 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 48:
/*  587 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  588 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 50:
/*  591 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  592 */                 jjAddStates(42, 43); 
/*      */               break;
/*      */             case 51:
/*  595 */               if (this.curChar == '_')
/*  596 */                 jjCheckNAdd(52); 
/*      */               break;
/*      */             case 52:
/*  599 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  601 */               if (kind > 7)
/*  602 */                 kind = 7; 
/*  603 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  606 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  607 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 54:
/*  610 */               if (this.curChar == '_')
/*  611 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 55:
/*  614 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  615 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 57:
/*  618 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  619 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 58:
/*  622 */               if (this.curChar == '_')
/*  623 */                 jjCheckNAdd(59); 
/*      */               break;
/*      */             case 59:
/*  626 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  627 */                 jjCheckNAddTwoStates(59, 60); 
/*      */               break;
/*      */             case 60:
/*  630 */               if (this.curChar == '_')
/*  631 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 61:
/*  634 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  635 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 63:
/*  638 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  640 */               if (kind > 7)
/*  641 */                 kind = 7; 
/*  642 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 64:
/*  645 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  646 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 65:
/*  649 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  650 */                 jjCheckNAddTwoStates(65, 66); 
/*      */               break;
/*      */             case 67:
/*  653 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  655 */               if (kind > 2)
/*  656 */                 kind = 2; 
/*  657 */               jjCheckNAddTwoStates(66, 67);
/*      */               break;
/*      */             case 68:
/*  660 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  661 */                 jjCheckNAddTwoStates(68, 69); 
/*      */               break;
/*      */             case 70:
/*  664 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  665 */                 jjAddStates(44, 45); 
/*      */               break;
/*      */             case 72:
/*  668 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  669 */                 jjCheckNAddTwoStates(72, 73); 
/*      */               break;
/*      */             case 73:
/*  672 */               if (this.curChar == '@')
/*  673 */                 jjCheckNAdd(74); 
/*      */               break;
/*      */             case 74:
/*  676 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  678 */               if (kind > 4)
/*  679 */                 kind = 4; 
/*  680 */               jjCheckNAdd(74);
/*      */               break;
/*      */           } 
/*      */         
/*  684 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  688 */         int hiByte = this.curChar >> 8;
/*  689 */         int i1 = hiByte >> 6;
/*  690 */         long l1 = 1L << (hiByte & 0x3F);
/*  691 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  692 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  695 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  698 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */               {
/*  700 */                 if (kind > 12)
/*  701 */                   kind = 12; 
/*      */               }
/*  703 */               if (jjCanMove_1(hiByte, i1, i2, l1, l2))
/*      */               {
/*  705 */                 if (kind > 13)
/*  706 */                   kind = 13; 
/*      */               }
/*  708 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  709 */                 jjCheckNAddStates(18, 23); 
/*  710 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  711 */                 jjCheckNAddStates(12, 17); 
/*  712 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  714 */                 if (kind > 1)
/*  715 */                   kind = 1; 
/*  716 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  718 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  719 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 1:
/*  722 */               if (jjCanMove_1(hiByte, i1, i2, l1, l2) && kind > 13)
/*  723 */                 kind = 13; 
/*      */               break;
/*      */             case 2:
/*  726 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  727 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  730 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  731 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 4:
/*  734 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  735 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 5:
/*  738 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  739 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 7:
/*  742 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  744 */               if (kind > 7)
/*  745 */                 kind = 7; 
/*  746 */               this.jjstateSet[this.jjnewStateCnt++] = 7;
/*      */               break;
/*      */             case 8:
/*  749 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  750 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 9:
/*  753 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  754 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 10:
/*  757 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  758 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 12:
/*  761 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  762 */                 jjAddStates(46, 47); 
/*      */               break;
/*      */             case 14:
/*  765 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  766 */                 jjAddStates(48, 49); 
/*      */               break;
/*      */             case 15:
/*  769 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  771 */               if (kind > 7)
/*  772 */                 kind = 7; 
/*  773 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 16:
/*  776 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  778 */               if (kind > 7)
/*  779 */                 kind = 7; 
/*  780 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  783 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  784 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 18:
/*  787 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  788 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 19:
/*  791 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  792 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 21:
/*  795 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  796 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 23:
/*  799 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  800 */                 jjAddStates(50, 51); 
/*      */               break;
/*      */             case 24:
/*  803 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  804 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 25:
/*  807 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  808 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 27:
/*  811 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  813 */               if (kind > 7)
/*  814 */                 kind = 7; 
/*  815 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 28:
/*  818 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  819 */                 jjCheckNAddStates(12, 17); 
/*      */               break;
/*      */             case 29:
/*  822 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  824 */               if (kind > 1)
/*  825 */                 kind = 1; 
/*  826 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  829 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  831 */               if (kind > 1)
/*  832 */                 kind = 1; 
/*  833 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  836 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  837 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 33:
/*  840 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  841 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 35:
/*  844 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  845 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 37:
/*  848 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  850 */               if (kind > 5)
/*  851 */                 kind = 5; 
/*  852 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  855 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  856 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 40:
/*  859 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  861 */               if (kind > 6)
/*  862 */                 kind = 6; 
/*  863 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  866 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  867 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 43:
/*  870 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  871 */                 jjAddStates(52, 53); 
/*      */               break;
/*      */             case 44:
/*  874 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  876 */               if (kind > 7)
/*  877 */                 kind = 7; 
/*  878 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 45:
/*  881 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  883 */               if (kind > 7)
/*  884 */                 kind = 7; 
/*  885 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 46:
/*  888 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  889 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 48:
/*  892 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  893 */                 jjAddStates(54, 55); 
/*      */               break;
/*      */             case 49:
/*  896 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  897 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 50:
/*  900 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  901 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 52:
/*  904 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  906 */               if (kind > 7)
/*  907 */                 kind = 7; 
/*  908 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  911 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  912 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 55:
/*  915 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  916 */                 jjAddStates(56, 57); 
/*      */               break;
/*      */             case 56:
/*  919 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  920 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 57:
/*  923 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  924 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 59:
/*  927 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  928 */                 jjAddStates(58, 59); 
/*      */               break;
/*      */             case 61:
/*  931 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  932 */                 jjAddStates(60, 61); 
/*      */               break;
/*      */             case 62:
/*  935 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  937 */               if (kind > 7)
/*  938 */                 kind = 7; 
/*  939 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 63:
/*  942 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  944 */               if (kind > 7)
/*  945 */                 kind = 7; 
/*  946 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 64:
/*  949 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  950 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 65:
/*  953 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  954 */                 jjCheckNAddTwoStates(65, 66); 
/*      */               break;
/*      */             case 67:
/*  957 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  959 */               if (kind > 2)
/*  960 */                 kind = 2; 
/*  961 */               jjCheckNAddTwoStates(66, 67);
/*      */               break;
/*      */             case 68:
/*  964 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  965 */                 jjCheckNAddTwoStates(68, 69); 
/*      */               break;
/*      */             case 70:
/*  968 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  969 */                 jjAddStates(44, 45); 
/*      */               break;
/*      */             case 72:
/*  972 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  973 */                 jjCheckNAddTwoStates(72, 73); 
/*      */               break;
/*      */             case 74:
/*  976 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  978 */               if (kind > 4)
/*  979 */                 kind = 4; 
/*  980 */               this.jjstateSet[this.jjnewStateCnt++] = 74;
/*      */               break;
/*      */           } 
/*      */         
/*  984 */         } while (i != startsAt);
/*      */       } 
/*  986 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  988 */         this.jjmatchedKind = kind;
/*  989 */         this.jjmatchedPos = curPos;
/*  990 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  992 */       curPos++;
/*  993 */       if ((i = this.jjnewStateCnt) == (startsAt = 75 - (this.jjnewStateCnt = startsAt)))
/*  994 */         return curPos;  
/*  995 */       try { this.curChar = this.input_stream.readChar(); }
/*  996 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*  999 */   } static final int[] jjnextStates = new int[] { 30, 31, 32, 34, 38, 39, 41, 42, 46, 47, 53, 54, 5, 6, 10, 11, 19, 20, 3, 4, 8, 9, 17, 18, 31, 32, 34, 32, 33, 34, 65, 66, 68, 69, 72, 73, 5, 6, 19, 20, 25, 26, 50, 51, 70, 71, 12, 13, 14, 15, 23, 24, 43, 44, 48, 49, 55, 56, 59, 60, 61, 62 };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
/* 1007 */     switch (hiByte) {
/*      */       
/*      */       case 48:
/* 1010 */         return ((jjbitVec2[i2] & l2) != 0L);
/*      */       case 49:
/* 1012 */         return ((jjbitVec3[i2] & l2) != 0L);
/*      */       case 51:
/* 1014 */         return ((jjbitVec4[i2] & l2) != 0L);
/*      */       case 61:
/* 1016 */         return ((jjbitVec5[i2] & l2) != 0L);
/*      */     } 
/* 1018 */     if ((jjbitVec0[i1] & l1) != 0L)
/* 1019 */       return true; 
/* 1020 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) {
/* 1025 */     switch (hiByte) {
/*      */       
/*      */       case 215:
/* 1028 */         return ((jjbitVec7[i2] & l2) != 0L);
/*      */     } 
/* 1030 */     if ((jjbitVec6[i1] & l1) != 0L)
/* 1031 */       return true; 
/* 1032 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2) {
/* 1037 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/* 1040 */         return ((jjbitVec9[i2] & l2) != 0L);
/*      */     } 
/* 1042 */     if ((jjbitVec8[i1] & l1) != 0L)
/* 1043 */       return true; 
/* 1044 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_3(int hiByte, int i1, int i2, long l1, long l2) {
/* 1049 */     switch (hiByte) {
/*      */       
/*      */       case 6:
/* 1052 */         return ((jjbitVec12[i2] & l2) != 0L);
/*      */       case 11:
/* 1054 */         return ((jjbitVec13[i2] & l2) != 0L);
/*      */       case 13:
/* 1056 */         return ((jjbitVec14[i2] & l2) != 0L);
/*      */       case 14:
/* 1058 */         return ((jjbitVec15[i2] & l2) != 0L);
/*      */       case 16:
/* 1060 */         return ((jjbitVec16[i2] & l2) != 0L);
/*      */     } 
/* 1062 */     if ((jjbitVec10[i1] & l1) != 0L) {
/* 1063 */       if ((jjbitVec11[i2] & l2) == 0L) {
/* 1064 */         return false;
/*      */       }
/* 1066 */       return true;
/* 1067 */     }  return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_4(int hiByte, int i1, int i2, long l1, long l2) {
/* 1072 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/* 1075 */         return ((jjbitVec9[i2] & l2) != 0L);
/*      */       case 215:
/* 1077 */         return ((jjbitVec7[i2] & l2) != 0L);
/*      */     } 
/* 1079 */     if ((jjbitVec17[i1] & l1) != 0L)
/* 1080 */       return true; 
/* 1081 */     return false;
/*      */   }
/*      */   
/* 1084 */   public static final String[] jjstrLiteralImages = new String[] { """", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
/*      */ 
/*      */   
/* 1087 */   public static final String[] lexStateNames = new String[] { ""DEFAULT"" };
/*      */ 
/*      */   
/* 1090 */   static final long[] jjtoToken = new long[] { 12543L };
/*      */ 
/*      */   
/* 1093 */   static final long[] jjtoSkip = new long[] { 32768L };
/*      */   
/*      */   protected CharStream input_stream;
/*      */   
/* 1097 */   private final int[] jjrounds = new int[75];
/* 1098 */   private final int[] jjstateSet = new int[150]; protected char curChar; int curLexState;
/*      */   int defaultLexState;
/*      */   int jjnewStateCnt;
/*      */   int jjround;
/*      */   int jjmatchedPos;
/*      */   int jjmatchedKind;
/*      */   
/*      */   public StandardTokenizerTokenManager(CharStream stream, int lexState) {
/* 1106 */     this(stream);
/* 1107 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1111 */     this.jjmatchedPos = this.jjnewStateCnt = 0;
/* 1112 */     this.curLexState = this.defaultLexState;
/* 1113 */     this.input_stream = stream;
/* 1114 */     ReInitRounds();
/*      */   }
/*      */ 
/*      */   
/*      */   private final void ReInitRounds() {
/* 1119 */     this.jjround = -2147483647;
/* 1120 */     for (int i = 75; i-- > 0;)
/* 1121 */       this.jjrounds[i] = Integer.MIN_VALUE; 
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream, int lexState) {
/* 1125 */     ReInit(stream);
/* 1126 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void SwitchTo(int lexState) {
/* 1130 */     if (lexState >= 1 || lexState < 0) {
/* 1131 */       throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", 2);
/*      */     }
/* 1133 */     this.curLexState = lexState;
/*      */   }
/*      */ 
/*      */   
/*      */   protected Token jjFillToken() {
/* 1138 */     Token t = Token.newToken(this.jjmatchedKind);
/* 1139 */     t.kind = this.jjmatchedKind;
/* 1140 */     String im = jjstrLiteralImages[this.jjmatchedKind];
/* 1141 */     t.image = (im == null) ? this.input_stream.GetImage() : im;
/* 1142 */     t.beginLine = this.input_stream.getBeginLine();
/* 1143 */     t.beginColumn = this.input_stream.getBeginColumn();
/* 1144 */     t.endLine = this.input_stream.getEndLine();
/* 1145 */     t.endColumn = this.input_stream.getEndColumn();
/* 1146 */     return t;
/*      */   }
/*      */   public StandardTokenizerTokenManager(CharStream stream) {
/* 1149 */     this.curLexState = 0;
/* 1150 */     this.defaultLexState = 0;
/*      */     this.input_stream = stream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Token getNextToken() {
/* 1159 */     Token specialToken = null;
/*      */     
/* 1161 */     int curPos = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     while (true) {
/*      */       try {
/* 1168 */         this.curChar = this.input_stream.BeginToken();
/*      */       }
/* 1170 */       catch (IOException e) {
/*      */         
/* 1172 */         this.jjmatchedKind = 0;
/* 1173 */         Token matchedToken = jjFillToken();
/* 1174 */         return matchedToken;
/*      */       } 
/*      */       
/* 1177 */       this.jjmatchedKind = Integer.MAX_VALUE;
/* 1178 */       this.jjmatchedPos = 0;
/* 1179 */       curPos = jjMoveStringLiteralDfa0_0();
/* 1180 */       if (this.jjmatchedPos == 0 && this.jjmatchedKind > 15)
/*      */       {
/* 1182 */         this.jjmatchedKind = 15;
/*      */       }
/* 1184 */       if (this.jjmatchedKind != Integer.MAX_VALUE) {
/*      */         
/* 1186 */         if (this.jjmatchedPos + 1 < curPos)
/* 1187 */           this.input_stream.backup(curPos - this.jjmatchedPos - 1); 
/* 1188 */         if ((jjtoToken[this.jjmatchedKind >> 6] & 1L << (this.jjmatchedKind & 0x3F)) != 0L) {
/*      */           
/* 1190 */           Token matchedToken = jjFillToken();
/* 1191 */           return matchedToken;
/*      */         } 
/*      */         
/*      */         continue;
/*      */       } 
/*      */       break;
/*      */     } 
/* 1198 */     int error_line = this.input_stream.getEndLine();
/* 1199 */     int error_column = this.input_stream.getEndColumn();
/* 1200 */     String error_after = null;
/* 1201 */     boolean EOFSeen = false; try {
/* 1202 */       this.input_stream.readChar(); this.input_stream.backup(1);
/* 1203 */     } catch (IOException e1) {
/* 1204 */       EOFSeen = true;
/* 1205 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/* 1206 */       if (this.curChar == '\n' || this.curChar == '\r') {
/* 1207 */         error_line++;
/* 1208 */         error_column = 0;
/*      */       } else {
/*      */         
/* 1211 */         error_column++;
/*      */       } 
/* 1213 */     }  if (!EOFSeen) {
/* 1214 */       this.input_stream.backup(1);
/* 1215 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/*      */     } 
/* 1217 */     throw new TokenMgrError(EOFSeen, this.curLexState, error_line, error_column, error_after, this.curChar, 0);
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizerTokenManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.Token,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Token
/*    */ {
/*    */   public int kind;
/*    */   public int beginLine;
/*    */   public int beginColumn;
/*    */   public int endLine;
/*    */   public int endColumn;
/*    */   public String image;
/*    */   public Token next;
/*    */   public Token specialToken;
/*    */   
/* 58 */   public String toString() { return this.image; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static final Token newToken(int ofKind) {
/* 75 */     switch (ofKind) {
/*    */     
/* 77 */     }  return new Token();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.TokenMgrError,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TokenMgrError
/*     */   extends Error
/*     */ {
/*     */   static final int LEXICAL_ERROR = 0;
/*     */   static final int STATIC_LEXER_ERROR = 1;
/*     */   static final int INVALID_LEXICAL_STATE = 2;
/*     */   static final int LOOP_DETECTED = 3;
/*     */   int errorCode;
/*     */   
/*     */   protected static final String addEscapes(String str) {
/*  41 */     StringBuffer retval = new StringBuffer();
/*     */     
/*  43 */     for (int i = 0; i < str.length(); i++) {
/*  44 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/*  49 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/*  52 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/*  55 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/*  58 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/*  61 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/*  64 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/*  67 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/*  70 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/*  73 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/*  74 */             String s = ""0000"" + Integer.toString(ch, 16);
/*  75 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/*  77 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/*  82 */     return retval.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + curChar + ""), "")) + ""after : \"""" + addEscapes(errorAfter) + ""\""""; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public String getMessage() { return super.getMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError(String message, int reason) {
/* 126 */     super(message);
/* 127 */     this.errorCode = reason;
/*     */   }
/*     */ 
/*     */   
/* 131 */   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\analysis\standard\TokenMgrError.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateField,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.util.Date;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateField
/*     */ {
/*  48 */   private static int DATE_LEN = Long.toString(31536000000000L, 36).length();
/*     */ 
/*     */ 
/*     */   
/*  52 */   public static String MIN_DATE_STRING() { return timeToString(0L); }
/*     */ 
/*     */   
/*     */   public static String MAX_DATE_STRING() {
/*  56 */     char[] buffer = new char[DATE_LEN];
/*  57 */     char c = Character.forDigit(35, 36);
/*  58 */     for (int i = 0; i < DATE_LEN; i++)
/*  59 */       buffer[i] = c; 
/*  60 */     return new String(buffer);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   public static String dateToString(Date date) { return timeToString(date.getTime()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time) {
/*  77 */     if (time < 0L) {
/*  78 */       throw new RuntimeException(""time '"" + time + ""' is too early, must be >= 0"");
/*     */     }
/*  80 */     String s = Long.toString(time, 36);
/*     */     
/*  82 */     if (s.length() > DATE_LEN) {
/*  83 */       throw new RuntimeException(""time '"" + time + ""' is too late, length of string "" + ""representation must be <= "" + DATE_LEN);
/*     */     }
/*     */ 
/*     */     
/*  87 */     if (s.length() < DATE_LEN) {
/*  88 */       StringBuffer sb = new StringBuffer(s);
/*  89 */       while (sb.length() < DATE_LEN)
/*  90 */         sb.insert(0, 0); 
/*  91 */       s = sb.toString();
/*     */     } 
/*     */     
/*  94 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  99 */   public static long stringToTime(String s) { return Long.parseLong(s, 36); }
/*     */ 
/*     */ 
/*     */   
/* 103 */   public static Date stringToDate(String s) { return new Date(stringToTime(s)); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\document\DateField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.text.ParseException;
/*     */ import java.text.SimpleDateFormat;
/*     */ import java.util.Calendar;
/*     */ import java.util.Date;
/*     */ import java.util.TimeZone;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateTools
/*     */ {
/*  41 */   private static final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public static String dateToString(Date date, Resolution resolution) { return timeToString(date.getTime(), resolution); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time, Resolution resolution) {
/*  68 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  73 */     cal.setTime(new Date(round(time, resolution)));
/*     */     
/*  75 */     SimpleDateFormat sdf = new SimpleDateFormat();
/*  76 */     sdf.setTimeZone(GMT);
/*  77 */     String pattern = null;
/*  78 */     if (resolution == Resolution.YEAR) {
/*  79 */       pattern = ""yyyy"";
/*  80 */     } else if (resolution == Resolution.MONTH) {
/*  81 */       pattern = ""yyyyMM"";
/*  82 */     } else if (resolution == Resolution.DAY) {
/*  83 */       pattern = ""yyyyMMdd"";
/*  84 */     } else if (resolution == Resolution.HOUR) {
/*  85 */       pattern = ""yyyyMMddHH"";
/*  86 */     } else if (resolution == Resolution.MINUTE) {
/*  87 */       pattern = ""yyyyMMddHHmm"";
/*  88 */     } else if (resolution == Resolution.SECOND) {
/*  89 */       pattern = ""yyyyMMddHHmmss"";
/*  90 */     } else if (resolution == Resolution.MILLISECOND) {
/*  91 */       pattern = ""yyyyMMddHHmmssSSS"";
/*     */     } else {
/*  93 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/*  95 */     sdf.applyPattern(pattern);
/*  96 */     return sdf.format(cal.getTime());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 110 */   public static long stringToTime(String dateString) throws ParseException { return stringToDate(dateString).getTime(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Date stringToDate(String dateString) throws ParseException {
/* 124 */     String pattern = null;
/* 125 */     if (dateString.length() == 4) {
/* 126 */       pattern = ""yyyy"";
/* 127 */     } else if (dateString.length() == 6) {
/* 128 */       pattern = ""yyyyMM"";
/* 129 */     } else if (dateString.length() == 8) {
/* 130 */       pattern = ""yyyyMMdd"";
/* 131 */     } else if (dateString.length() == 10) {
/* 132 */       pattern = ""yyyyMMddHH"";
/* 133 */     } else if (dateString.length() == 12) {
/* 134 */       pattern = ""yyyyMMddHHmm"";
/* 135 */     } else if (dateString.length() == 14) {
/* 136 */       pattern = ""yyyyMMddHHmmss"";
/* 137 */     } else if (dateString.length() == 17) {
/* 138 */       pattern = ""yyyyMMddHHmmssSSS"";
/*     */     } else {
/* 140 */       throw new ParseException(""Input is not valid date string: "" + dateString, 0);
/* 141 */     }  SimpleDateFormat sdf = new SimpleDateFormat(pattern);
/* 142 */     sdf.setTimeZone(GMT);
/* 143 */     Date date = sdf.parse(dateString);
/* 144 */     return date;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public static Date round(Date date, Resolution resolution) { return new Date(round(date.getTime(), resolution)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long round(long time, Resolution resolution) {
/* 171 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 176 */     cal.setTime(new Date(time));
/*     */     
/* 178 */     if (resolution == Resolution.YEAR) {
/* 179 */       cal.set(2, 0);
/* 180 */       cal.set(5, 1);
/* 181 */       cal.set(11, 0);
/* 182 */       cal.set(12, 0);
/* 183 */       cal.set(13, 0);
/* 184 */       cal.set(14, 0);
/* 185 */     } else if (resolution == Resolution.MONTH) {
/* 186 */       cal.set(5, 1);
/* 187 */       cal.set(11, 0);
/* 188 */       cal.set(12, 0);
/* 189 */       cal.set(13, 0);
/* 190 */       cal.set(14, 0);
/* 191 */     } else if (resolution == Resolution.DAY) {
/* 192 */       cal.set(11, 0);
/* 193 */       cal.set(12, 0);
/* 194 */       cal.set(13, 0);
/* 195 */       cal.set(14, 0);
/* 196 */     } else if (resolution == Resolution.HOUR) {
/* 197 */       cal.set(12, 0);
/* 198 */       cal.set(13, 0);
/* 199 */       cal.set(14, 0);
/* 200 */     } else if (resolution == Resolution.MINUTE) {
/* 201 */       cal.set(13, 0);
/* 202 */       cal.set(14, 0);
/* 203 */     } else if (resolution == Resolution.SECOND) {
/* 204 */       cal.set(14, 0);
/* 205 */     } else if (resolution != Resolution.MILLISECOND) {
/*     */ 
/*     */       
/* 208 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/* 210 */     return cal.getTime().getTime();
/*     */   }
/*     */ 
/*     */   
/*     */   public static class Resolution
/*     */   {
/* 216 */     public static final Resolution YEAR = new Resolution(""year"");
/* 217 */     public static final Resolution MONTH = new Resolution(""month"");
/* 218 */     public static final Resolution DAY = new Resolution(""day"");
/* 219 */     public static final Resolution HOUR = new Resolution(""hour"");
/* 220 */     public static final Resolution MINUTE = new Resolution(""minute"");
/* 221 */     public static final Resolution SECOND = new Resolution(""second"");
/* 222 */     public static final Resolution MILLISECOND = new Resolution(""millisecond"");
/*     */     
/*     */     private String resolution;
/*     */ 
/*     */     
/*     */     private Resolution() {}
/*     */ 
/*     */     
/* 230 */     private Resolution(String resolution) { this.resolution = resolution; }
/*     */ 
/*     */ 
/*     */     
/* 234 */     public String toString() { return this.resolution; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\document\DateTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Document,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Vector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Document
/*     */   implements Serializable
/*     */ {
/*  43 */   List fields = new Vector();
/*  44 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  89 */   public final void add(Field field) { this.fields.add(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeField(String name) {
/* 103 */     Iterator it = this.fields.iterator();
/* 104 */     while (it.hasNext()) {
/* 105 */       Field field = it.next();
/* 106 */       if (field.name().equals(name)) {
/* 107 */         it.remove();
/*     */         return;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeFields(String name) {
/* 123 */     Iterator it = this.fields.iterator();
/* 124 */     while (it.hasNext()) {
/* 125 */       Field field = it.next();
/* 126 */       if (field.name().equals(name)) {
/* 127 */         it.remove();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field getField(String name) {
/* 137 */     for (int i = 0; i < this.fields.size(); i++) {
/* 138 */       Field field = this.fields.get(i);
/* 139 */       if (field.name().equals(name))
/* 140 */         return field; 
/*     */     } 
/* 142 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String get(String name) {
/* 151 */     for (int i = 0; i < this.fields.size(); i++) {
/* 152 */       Field field = this.fields.get(i);
/* 153 */       if (field.name().equals(name) && !field.isBinary())
/* 154 */         return field.stringValue(); 
/*     */     } 
/* 156 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 161 */   public final Enumeration fields() { return ((Vector)this.fields).elements(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field[] getFields(String name) {
/* 172 */     List result = new ArrayList();
/* 173 */     for (int i = 0; i < this.fields.size(); i++) {
/* 174 */       Field field = this.fields.get(i);
/* 175 */       if (field.name().equals(name)) {
/* 176 */         result.add(field);
/*     */       }
/*     */     } 
/*     */     
/* 180 */     if (result.size() == 0) {
/* 181 */       return null;
/*     */     }
/* 183 */     return result.toArray(new Field[result.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String[] getValues(String name) {
/* 194 */     List result = new ArrayList();
/* 195 */     for (int i = 0; i < this.fields.size(); i++) {
/* 196 */       Field field = this.fields.get(i);
/* 197 */       if (field.name().equals(name) && !field.isBinary()) {
/* 198 */         result.add(field.stringValue());
/*     */       }
/*     */     } 
/* 201 */     if (result.size() == 0) {
/* 202 */       return null;
/*     */     }
/* 204 */     return result.toArray(new String[result.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[][] getBinaryValues(String name) {
/* 216 */     List result = new ArrayList();
/* 217 */     for (int i = 0; i < this.fields.size(); i++) {
/* 218 */       Field field = this.fields.get(i);
/* 219 */       if (field.name().equals(name) && field.isBinary()) {
/* 220 */         result.add(field.binaryValue());
/*     */       }
/*     */     } 
/* 223 */     if (result.size() == 0) {
/* 224 */       return (byte[][])null;
/*     */     }
/* 226 */     return result.toArray(new byte[result.size()][]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[] getBinaryValue(String name) {
/* 239 */     for (int i = 0; i < this.fields.size(); i++) {
/* 240 */       Field field = this.fields.get(i);
/* 241 */       if (field.name().equals(name) && field.isBinary())
/* 242 */         return field.binaryValue(); 
/*     */     } 
/* 244 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 249 */     StringBuffer buffer = new StringBuffer();
/* 250 */     buffer.append(""Document<"");
/* 251 */     for (int i = 0; i < this.fields.size(); i++) {
/* 252 */       Field field = this.fields.get(i);
/* 253 */       buffer.append(field.toString());
/* 254 */       if (i != this.fields.size() - 1)
/* 255 */         buffer.append("" ""); 
/*     */     } 
/* 257 */     buffer.append("">"");
/* 258 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\document\Document.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Field,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Reader;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Field
/*     */   implements Serializable
/*     */ {
/*  36 */   private String name = ""body"";
/*     */ 
/*     */   
/*  39 */   private Object fieldsData = null;
/*     */   
/*     */   private boolean storeTermVector = false;
/*     */   
/*     */   private boolean storeOffsetWithTermVector = false;
/*     */   private boolean storePositionWithTermVector = false;
/*     */   private boolean omitNorms = false;
/*     */   private boolean isStored = false;
/*     */   private boolean isIndexed = true;
/*     */   private boolean isTokenized = true;
/*     */   private boolean isBinary = false;
/*     */   private boolean isCompressed = false;
/*  51 */   private float boost = 1.0F;
/*     */   
/*     */   public static final class Store
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  57 */     private Store(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  63 */     public static final Store COMPRESS = new Store(""COMPRESS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  70 */     public static final Store YES = new Store(""YES"");
/*     */ 
/*     */     
/*  73 */     public static final Store NO = new Store(""NO"");
/*     */   }
/*     */   
/*     */   public static final class Index
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  80 */     private Index(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  86 */     public static final Index NO = new Index(""NO"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  92 */     public static final Index TOKENIZED = new Index(""TOKENIZED"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  98 */     public static final Index UN_TOKENIZED = new Index(""UN_TOKENIZED"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 106 */     public static final Index NO_NORMS = new Index(""NO_NORMS"");
/*     */   }
/*     */ 
/*     */   
/*     */   public static final class TermVector
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/* 114 */     private TermVector(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 119 */     public static final TermVector NO = new TermVector(""NO"");
/*     */ 
/*     */ 
/*     */     
/* 123 */     public static final TermVector YES = new TermVector(""YES"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 130 */     public static final TermVector WITH_POSITIONS = new TermVector(""WITH_POSITIONS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 137 */     public static final TermVector WITH_OFFSETS = new TermVector(""WITH_OFFSETS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 146 */     public static final TermVector WITH_POSITIONS_OFFSETS = new TermVector(""WITH_POSITIONS_OFFSETS"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 166 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 181 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 186 */   public String name() { return this.name; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 191 */   public String stringValue() { return (this.fieldsData instanceof String) ? (String)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public Reader readerValue() { return (this.fieldsData instanceof Reader) ? (Reader)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 201 */   public byte[] binaryValue() { return (this.fieldsData instanceof byte[]) ? (byte[])this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 216 */   public Field(String name, String value, Store store, Index index) { this(name, value, store, index, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, String value, Store store, Index index, TermVector termVector) {
/* 237 */     if (name == null)
/* 238 */       throw new NullPointerException(""name cannot be null""); 
/* 239 */     if (value == null)
/* 240 */       throw new NullPointerException(""value cannot be null""); 
/* 241 */     if (name.length() == 0 && value.length() == 0)
/* 242 */       throw new IllegalArgumentException(""name and value cannot both be empty""); 
/* 243 */     if (index == Index.NO && store == Store.NO) {
/* 244 */       throw new IllegalArgumentException(""it doesn't make sense to have a field that is neither indexed nor stored"");
/*     */     }
/* 246 */     if (index == Index.NO && termVector != TermVector.NO) {
/* 247 */       throw new IllegalArgumentException(""cannot store term vector information for a field that is not indexed"");
/*     */     }
/*     */     
/* 250 */     this.name = name.intern();
/* 251 */     this.fieldsData = value;
/*     */     
/* 253 */     if (store == Store.YES) {
/* 254 */       this.isStored = true;
/* 255 */       this.isCompressed = false;
/*     */     }
/* 257 */     else if (store == Store.COMPRESS) {
/* 258 */       this.isStored = true;
/* 259 */       this.isCompressed = true;
/*     */     }
/* 261 */     else if (store == Store.NO) {
/* 262 */       this.isStored = false;
/* 263 */       this.isCompressed = false;
/*     */     } else {
/*     */       
/* 266 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 268 */     if (index == Index.NO) {
/* 269 */       this.isIndexed = false;
/* 270 */       this.isTokenized = false;
/* 271 */     } else if (index == Index.TOKENIZED) {
/* 272 */       this.isIndexed = true;
/* 273 */       this.isTokenized = true;
/* 274 */     } else if (index == Index.UN_TOKENIZED) {
/* 275 */       this.isIndexed = true;
/* 276 */       this.isTokenized = false;
/* 277 */     } else if (index == Index.NO_NORMS) {
/* 278 */       this.isIndexed = true;
/* 279 */       this.isTokenized = false;
/* 280 */       this.omitNorms = true;
/*     */     } else {
/* 282 */       throw new IllegalArgumentException(""unknown index parameter "" + index);
/*     */     } 
/*     */     
/* 285 */     this.isBinary = false;
/*     */     
/* 287 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 299 */   public Field(String name, Reader reader) { this(name, reader, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, Reader reader, TermVector termVector) {
/* 312 */     if (name == null)
/* 313 */       throw new NullPointerException(""name cannot be null""); 
/* 314 */     if (reader == null) {
/* 315 */       throw new NullPointerException(""reader cannot be null"");
/*     */     }
/* 317 */     this.name = name.intern();
/* 318 */     this.fieldsData = reader;
/*     */     
/* 320 */     this.isStored = false;
/* 321 */     this.isCompressed = false;
/*     */     
/* 323 */     this.isIndexed = true;
/* 324 */     this.isTokenized = true;
/*     */     
/* 326 */     this.isBinary = false;
/*     */     
/* 328 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, byte[] value, Store store) {
/* 342 */     if (name == null)
/* 343 */       throw new IllegalArgumentException(""name cannot be null""); 
/* 344 */     if (value == null) {
/* 345 */       throw new IllegalArgumentException(""value cannot be null"");
/*     */     }
/* 347 */     this.name = name.intern();
/* 348 */     this.fieldsData = value;
/*     */     
/* 350 */     if (store == Store.YES) {
/* 351 */       this.isStored = true;
/* 352 */       this.isCompressed = false;
/*     */     }
/* 354 */     else if (store == Store.COMPRESS) {
/* 355 */       this.isStored = true;
/* 356 */       this.isCompressed = true;
/*     */     } else {
/* 358 */       if (store == Store.NO) {
/* 359 */         throw new IllegalArgumentException(""binary values can't be unstored"");
/*     */       }
/* 361 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 363 */     this.isIndexed = false;
/* 364 */     this.isTokenized = false;
/*     */     
/* 366 */     this.isBinary = true;
/*     */     
/* 368 */     setStoreTermVector(TermVector.NO);
/*     */   }
/*     */   
/*     */   private void setStoreTermVector(TermVector termVector) {
/* 372 */     if (termVector == TermVector.NO) {
/* 373 */       this.storeTermVector = false;
/* 374 */       this.storePositionWithTermVector = false;
/* 375 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 377 */     else if (termVector == TermVector.YES) {
/* 378 */       this.storeTermVector = true;
/* 379 */       this.storePositionWithTermVector = false;
/* 380 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 382 */     else if (termVector == TermVector.WITH_POSITIONS) {
/* 383 */       this.storeTermVector = true;
/* 384 */       this.storePositionWithTermVector = true;
/* 385 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 387 */     else if (termVector == TermVector.WITH_OFFSETS) {
/* 388 */       this.storeTermVector = true;
/* 389 */       this.storePositionWithTermVector = false;
/* 390 */       this.storeOffsetWithTermVector = true;
/*     */     }
/* 392 */     else if (termVector == TermVector.WITH_POSITIONS_OFFSETS) {
/* 393 */       this.storeTermVector = true;
/* 394 */       this.storePositionWithTermVector = true;
/* 395 */       this.storeOffsetWithTermVector = true;
/*     */     } else {
/*     */       
/* 398 */       throw new IllegalArgumentException(""unknown termVector parameter "" + termVector);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 405 */   public final boolean isStored() { return this.isStored; }
/*     */ 
/*     */ 
/*     */   
/* 409 */   public final boolean isIndexed() { return this.isIndexed; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 414 */   public final boolean isTokenized() { return this.isTokenized; }
/*     */ 
/*     */   
/* 417 */   public final boolean isCompressed() { return this.isCompressed; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 427 */   public final boolean isTermVectorStored() { return this.storeTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 434 */   public boolean isStoreOffsetWithTermVector() { return this.storeOffsetWithTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 441 */   public boolean isStorePositionWithTermVector() { return this.storePositionWithTermVector; }
/*     */ 
/*     */ 
/*     */   
/* 445 */   public final boolean isBinary() { return this.isBinary; }
/*     */ 
/*     */   
/* 448 */   public boolean getOmitNorms() { return this.omitNorms; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 455 */   public void setOmitNorms(boolean omitNorms) { this.omitNorms = omitNorms; }
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 459 */     StringBuffer result = new StringBuffer();
/* 460 */     if (this.isStored) {
/* 461 */       result.append(""stored"");
/* 462 */       if (this.isCompressed) {
/* 463 */         result.append(""/compressed"");
/*     */       } else {
/* 465 */         result.append(""/uncompressed"");
/*     */       } 
/* 467 */     }  if (this.isIndexed) {
/* 468 */       if (result.length() > 0)
/* 469 */         result.append("",""); 
/* 470 */       result.append(""indexed"");
/*     */     } 
/* 472 */     if (this.isTokenized) {
/* 473 */       if (result.length() > 0)
/* 474 */         result.append("",""); 
/* 475 */       result.append(""tokenized"");
/*     */     } 
/* 477 */     if (this.storeTermVector) {
/* 478 */       if (result.length() > 0)
/* 479 */         result.append("",""); 
/* 480 */       result.append(""termVector"");
/*     */     } 
/* 482 */     if (this.storeOffsetWithTermVector) {
/* 483 */       if (result.length() > 0)
/* 484 */         result.append("",""); 
/* 485 */       result.append(""termVectorOffsets"");
/*     */     } 
/* 487 */     if (this.storePositionWithTermVector) {
/* 488 */       if (result.length() > 0)
/* 489 */         result.append("",""); 
/* 490 */       result.append(""termVectorPosition"");
/*     */     } 
/* 492 */     if (this.isBinary) {
/* 493 */       if (result.length() > 0)
/* 494 */         result.append("",""); 
/* 495 */       result.append(""binary"");
/*     */     } 
/* 497 */     if (this.omitNorms) {
/* 498 */       result.append("",omitNorms"");
/*     */     }
/* 500 */     result.append('<');
/* 501 */     result.append(this.name);
/* 502 */     result.append(':');
/*     */     
/* 504 */     if (this.fieldsData != null) {
/* 505 */       result.append(this.fieldsData);
/*     */     }
/*     */     
/* 508 */     result.append('>');
/* 509 */     return result.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\document\Field.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.NumberTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NumberTools
/*     */ {
/*     */   private static final int RADIX = 36;
/*     */   private static final char NEGATIVE_PREFIX = '-';
/*     */   private static final char POSITIVE_PREFIX = '0';
/*     */   public static final String MIN_STRING_VALUE = ""-0000000000000"";
/*     */   public static final String MAX_STRING_VALUE = ""01y2p0ij32e8e7"";
/*  60 */   public static final int STR_SIZE = ""-0000000000000"".length();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String longToString(long l) {
/*  67 */     if (l == Long.MIN_VALUE)
/*     */     {
/*  69 */       return ""-0000000000000"";
/*     */     }
/*     */     
/*  72 */     StringBuffer buf = new StringBuffer(STR_SIZE);
/*     */     
/*  74 */     if (l < 0L) {
/*  75 */       buf.append('-');
/*  76 */       l = Long.MAX_VALUE + l + 1L;
/*     */     } else {
/*  78 */       buf.append('0');
/*     */     } 
/*  80 */     String num = Long.toString(l, 36);
/*     */     
/*  82 */     int padLen = STR_SIZE - num.length() - buf.length();
/*  83 */     while (padLen-- > 0) {
/*  84 */       buf.append('0');
/*     */     }
/*  86 */     buf.append(num);
/*     */     
/*  88 */     return buf.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long stringToLong(String str) {
/* 102 */     if (str == null) {
/* 103 */       throw new NullPointerException(""string cannot be null"");
/*     */     }
/* 105 */     if (str.length() != STR_SIZE) {
/* 106 */       throw new NumberFormatException(""string is the wrong size"");
/*     */     }
/*     */     
/* 109 */     if (str.equals(""-0000000000000"")) {
/* 110 */       return Long.MIN_VALUE;
/*     */     }
/*     */     
/* 113 */     char prefix = str.charAt(0);
/* 114 */     long l = Long.parseLong(str.substring(1), 36);
/*     */     
/* 116 */     if (prefix != '0')
/*     */     {
/* 118 */       if (prefix == '-') {
/* 119 */         l = l - Long.MAX_VALUE - 1L;
/*     */       } else {
/* 121 */         throw new NumberFormatException(""string does not begin with the correct prefix"");
/*     */       } 
/*     */     }
/*     */     
/* 125 */     return l;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\document\NumberTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import org.apache.lucene.store.BufferedIndexInput;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class CompoundFileReader
/*     */   extends Directory
/*     */ {
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private IndexInput stream;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     long offset;
/*     */     long length;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*  50 */   private HashMap entries = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public CompoundFileReader(Directory dir, String name) throws IOException {
/*  56 */     this.directory = dir;
/*  57 */     this.fileName = name;
/*     */     
/*  59 */     boolean success = false;
/*     */     
/*     */     try {
/*  62 */       this.stream = dir.openInput(name);
/*     */ 
/*     */       
/*  65 */       int count = this.stream.readVInt();
/*  66 */       FileEntry entry = null;
/*  67 */       for (int i = 0; i < count; i++) {
/*  68 */         long offset = this.stream.readLong();
/*  69 */         String id = this.stream.readString();
/*     */         
/*  71 */         if (entry != null)
/*     */         {
/*  73 */           entry.length = offset - entry.offset;
/*     */         }
/*     */         
/*  76 */         entry = new FileEntry();
/*  77 */         entry.offset = offset;
/*  78 */         this.entries.put(id, entry);
/*     */       } 
/*     */ 
/*     */       
/*  82 */       if (entry != null) {
/*  83 */         entry.length = this.stream.length() - entry.offset;
/*     */       }
/*     */       
/*  86 */       success = true;
/*     */     } finally {
/*     */       
/*  89 */       if (!success && this.stream != null) {
/*     */         try {
/*  91 */           this.stream.close();
/*  92 */         } catch (IOException e) {}
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*  98 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */   
/* 102 */   public String getName() { return this.fileName; }
/*     */ 
/*     */   
/*     */   public synchronized void close() throws IOException {
/* 106 */     if (this.stream == null) {
/* 107 */       throw new IOException(""Already closed"");
/*     */     }
/* 109 */     this.entries.clear();
/* 110 */     this.stream.close();
/* 111 */     this.stream = null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized IndexInput openInput(String id) throws IOException {
/* 117 */     if (this.stream == null) {
/* 118 */       throw new IOException(""Stream closed"");
/*     */     }
/* 120 */     FileEntry entry = (FileEntry)this.entries.get(id);
/* 121 */     if (entry == null) {
/* 122 */       throw new IOException(""No sub-file with id "" + id + "" found"");
/*     */     }
/* 124 */     return (IndexInput)new CSIndexInput(this.stream, entry.offset, entry.length);
/*     */   }
/*     */ 
/*     */   
/*     */   public String[] list() {
/* 129 */     String[] res = new String[this.entries.size()];
/* 130 */     return (String[])this.entries.keySet().toArray((Object[])res);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 135 */   public boolean fileExists(String name) { return this.entries.containsKey(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 140 */   public long fileModified(String name) throws IOException { return this.directory.fileModified(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public void touchFile(String name) throws IOException { this.directory.touchFile(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 152 */   public void deleteFile(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   public void renameFile(String from, String to) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long fileLength(String name) throws IOException {
/* 167 */     FileEntry e = (FileEntry)this.entries.get(name);
/* 168 */     if (e == null)
/* 169 */       throw new IOException(""File "" + name + "" does not exist""); 
/* 170 */     return e.length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public IndexOutput createOutput(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public Lock makeLock(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   static final class CSIndexInput
/*     */     extends BufferedIndexInput
/*     */   {
/*     */     IndexInput base;
/*     */ 
/*     */     
/*     */     long fileOffset;
/*     */     
/*     */     long length;
/*     */ 
/*     */     
/*     */     CSIndexInput(IndexInput base, long fileOffset, long length) {
/* 200 */       this.base = base;
/* 201 */       this.fileOffset = fileOffset;
/* 202 */       this.length = length;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 214 */       synchronized (this.base) {
/* 215 */         long start = getFilePointer();
/* 216 */         if (start + len > this.length)
/* 217 */           throw new IOException(""read past EOF""); 
/* 218 */         this.base.seek(this.fileOffset + start);
/* 219 */         this.base.readBytes(b, offset, len);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     protected void seekInternal(long pos) {}
/*     */ 
/*     */ 
/*     */     
/*     */     public void close() {}
/*     */ 
/*     */ 
/*     */     
/* 233 */     public long length() { return this.length; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\CompoundFileReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class CompoundFileWriter
/*     */ {
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private HashSet ids;
/*     */   private LinkedList entries;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     String file;
/*     */     long directoryOffset;
/*     */     long dataOffset;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*     */   private boolean merged = false;
/*     */   
/*     */   public CompoundFileWriter(Directory dir, String name) {
/*  77 */     if (dir == null)
/*  78 */       throw new NullPointerException(""directory cannot be null""); 
/*  79 */     if (name == null) {
/*  80 */       throw new NullPointerException(""name cannot be null"");
/*     */     }
/*  82 */     this.directory = dir;
/*  83 */     this.fileName = name;
/*  84 */     this.ids = new HashSet();
/*  85 */     this.entries = new LinkedList();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  90 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public String getName() { return this.fileName; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addFile(String file) {
/* 107 */     if (this.merged) {
/* 108 */       throw new IllegalStateException(""Can't add extensions after merge has been called"");
/*     */     }
/*     */     
/* 111 */     if (file == null) {
/* 112 */       throw new NullPointerException(""file cannot be null"");
/*     */     }
/*     */     
/* 115 */     if (!this.ids.add(file)) {
/* 116 */       throw new IllegalArgumentException(""File "" + file + "" already added"");
/*     */     }
/*     */     
/* 119 */     FileEntry entry = new FileEntry();
/* 120 */     entry.file = file;
/* 121 */     this.entries.add(entry);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 132 */     if (this.merged) {
/* 133 */       throw new IllegalStateException(""Merge already performed"");
/*     */     }
/*     */     
/* 136 */     if (this.entries.isEmpty()) {
/* 137 */       throw new IllegalStateException(""No entries to merge have been defined"");
/*     */     }
/*     */     
/* 140 */     this.merged = true;
/*     */ 
/*     */     
/* 143 */     IndexOutput os = null;
/*     */     try {
/* 145 */       os = this.directory.createOutput(this.fileName);
/*     */ 
/*     */       
/* 148 */       os.writeVInt(this.entries.size());
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 153 */       Iterator it = this.entries.iterator();
/* 154 */       while (it.hasNext()) {
/* 155 */         FileEntry fe = it.next();
/* 156 */         fe.directoryOffset = os.getFilePointer();
/* 157 */         os.writeLong(0L);
/* 158 */         os.writeString(fe.file);
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 163 */       byte[] buffer = new byte[1024];
/* 164 */       it = this.entries.iterator();
/* 165 */       while (it.hasNext()) {
/* 166 */         FileEntry fe = it.next();
/* 167 */         fe.dataOffset = os.getFilePointer();
/* 168 */         copyFile(fe, os, buffer);
/*     */       } 
/*     */ 
/*     */       
/* 172 */       it = this.entries.iterator();
/* 173 */       while (it.hasNext()) {
/* 174 */         FileEntry fe = it.next();
/* 175 */         os.seek(fe.directoryOffset);
/* 176 */         os.writeLong(fe.dataOffset);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 183 */       IndexOutput tmp = os;
/* 184 */       os = null;
/* 185 */       tmp.close();
/*     */     } finally {
/*     */       
/* 188 */       if (os != null) try { os.close(); } catch (IOException e) {}
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void copyFile(FileEntry source, IndexOutput os, byte[] buffer) throws IOException {
/* 199 */     IndexInput is = null;
/*     */     try {
/* 201 */       long startPtr = os.getFilePointer();
/*     */       
/* 203 */       is = this.directory.openInput(source.file);
/* 204 */       long length = is.length();
/* 205 */       long remainder = length;
/* 206 */       int chunk = buffer.length;
/*     */       
/* 208 */       while (remainder > 0L) {
/* 209 */         int len = (int)Math.min(chunk, remainder);
/* 210 */         is.readBytes(buffer, 0, len);
/* 211 */         os.writeBytes(buffer, len);
/* 212 */         remainder -= len;
/*     */       } 
/*     */ 
/*     */       
/* 216 */       if (remainder != 0L) {
/* 217 */         throw new IOException(""Non-zero remainder length after copying: "" + remainder + "" (id: "" + source.file + "", length: "" + length + "", buffer size: "" + chunk + "")"");
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 223 */       long endPtr = os.getFilePointer();
/* 224 */       long diff = endPtr - startPtr;
/* 225 */       if (diff != length) {
/* 226 */         throw new IOException(""Difference in the output file offsets "" + diff + "" does not match the original file length "" + length);
/*     */       }
/*     */     }
/*     */     finally {
/*     */       
/* 231 */       if (is != null) is.close(); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\CompoundFileWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocumentWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.io.Reader;
/*     */ import java.io.StringReader;
/*     */ import java.util.Arrays;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Hashtable;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocumentWriter
/*     */ {
/*     */   private Analyzer analyzer;
/*     */   private Directory directory;
/*     */   private Similarity similarity;
/*     */   private FieldInfos fieldInfos;
/*     */   private int maxFieldLength;
/*  42 */   private int termIndexInterval = 128;
/*     */ 
/*     */ 
/*     */   
/*     */   private PrintStream infoStream;
/*     */ 
/*     */ 
/*     */   
/*     */   private final Hashtable postingTable;
/*     */ 
/*     */ 
/*     */   
/*     */   private int[] fieldLengths;
/*     */ 
/*     */   
/*     */   private int[] fieldPositions;
/*     */ 
/*     */   
/*     */   private int[] fieldOffsets;
/*     */ 
/*     */   
/*     */   private float[] fieldBoosts;
/*     */ 
/*     */   
/*     */   private final Term termBuffer;
/*     */ 
/*     */ 
/*     */   
/*     */   final void addDocument(String segment, Document doc) throws IOException {
/*  71 */     this.fieldInfos = new FieldInfos();
/*  72 */     this.fieldInfos.add(doc);
/*  73 */     this.fieldInfos.write(this.directory, segment + "".fnm"");
/*     */ 
/*     */     
/*  76 */     FieldsWriter fieldsWriter = new FieldsWriter(this.directory, segment, this.fieldInfos);
/*     */     
/*     */     try {
/*  79 */       fieldsWriter.addDocument(doc);
/*     */     } finally {
/*  81 */       fieldsWriter.close();
/*     */     } 
/*     */ 
/*     */     
/*  85 */     this.postingTable.clear();
/*  86 */     this.fieldLengths = new int[this.fieldInfos.size()];
/*  87 */     this.fieldPositions = new int[this.fieldInfos.size()];
/*  88 */     this.fieldOffsets = new int[this.fieldInfos.size()];
/*     */     
/*  90 */     this.fieldBoosts = new float[this.fieldInfos.size()];
/*  91 */     Arrays.fill(this.fieldBoosts, doc.getBoost());
/*     */     
/*  93 */     invertDocument(doc);
/*     */ 
/*     */     
/*  96 */     Posting[] postings = sortPostingTable();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 112 */     writePostings(postings, segment);
/*     */ 
/*     */     
/* 115 */     writeNorms(segment);
/*     */   }
/*     */ 
/*     */   
/*     */   DocumentWriter(Directory directory, Analyzer analyzer, Similarity similarity, int maxFieldLength)
/*     */   {
/* 121 */     this.postingTable = new Hashtable();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 197 */     this.termBuffer = new Term("""", """"); this.directory = directory; this.analyzer = analyzer; this.similarity = similarity; this.maxFieldLength = maxFieldLength; } DocumentWriter(Directory directory, Analyzer analyzer, IndexWriter writer) { this.postingTable = new Hashtable(); this.termBuffer = new Term("""", """"); this.directory = directory; this.analyzer = analyzer;
/*     */     this.similarity = writer.getSimilarity();
/*     */     this.maxFieldLength = writer.getMaxFieldLength();
/* 200 */     this.termIndexInterval = writer.getTermIndexInterval(); } private final void addPosition(String field, String text, int position, TermVectorOffsetInfo offset) { this.termBuffer.set(field, text);
/*     */     
/* 202 */     Posting ti = (Posting)this.postingTable.get(this.termBuffer);
/* 203 */     if (ti != null) {
/* 204 */       int freq = ti.freq;
/* 205 */       if (ti.positions.length == freq) {
/* 206 */         int[] newPositions = new int[freq * 2];
/* 207 */         int[] positions = ti.positions;
/* 208 */         for (int i = 0; i < freq; i++)
/* 209 */           newPositions[i] = positions[i]; 
/* 210 */         ti.positions = newPositions;
/*     */       } 
/* 212 */       ti.positions[freq] = position;
/*     */       
/* 214 */       if (offset != null) {
/* 215 */         if (ti.offsets.length == freq) {
/* 216 */           TermVectorOffsetInfo[] newOffsets = new TermVectorOffsetInfo[freq * 2];
/* 217 */           TermVectorOffsetInfo[] offsets = ti.offsets;
/* 218 */           for (int i = 0; i < freq; i++)
/*     */           {
/* 220 */             newOffsets[i] = offsets[i];
/*     */           }
/* 222 */           ti.offsets = newOffsets;
/*     */         } 
/* 224 */         ti.offsets[freq] = offset;
/*     */       } 
/* 226 */       ti.freq = freq + 1;
/*     */     } else {
/* 228 */       Term term = new Term(field, text, false);
/* 229 */       this.postingTable.put(term, new Posting(term, position, offset));
/*     */     }  }
/*     */ 
/*     */ 
/*     */   
/*     */   private final Posting[] sortPostingTable() {
/* 235 */     Posting[] array = new Posting[this.postingTable.size()];
/* 236 */     Enumeration postings = this.postingTable.elements();
/* 237 */     for (int i = 0; postings.hasMoreElements(); i++) {
/* 238 */       array[i] = postings.nextElement();
/*     */     }
/*     */     
/* 241 */     quickSort(array, 0, array.length - 1);
/*     */     
/* 243 */     return array; }
/*     */   private final void invertDocument(Document doc) throws IOException { Enumeration fields = doc.fields(); while (fields.hasMoreElements()) { Field field = fields.nextElement(); String fieldName = field.name(); int fieldNumber = this.fieldInfos.fieldNumber(fieldName); int length = this.fieldLengths[fieldNumber]; int position = this.fieldPositions[fieldNumber]; if (length > 0)
/*     */         position += this.analyzer.getPositionIncrementGap(fieldName);  int offset = this.fieldOffsets[fieldNumber]; if (field.isIndexed()) { if (!field.isTokenized()) { String stringValue = field.stringValue(); if (field.isStoreOffsetWithTermVector()) { addPosition(fieldName, stringValue, position++, new TermVectorOffsetInfo(offset, offset + stringValue.length())); } else { addPosition(fieldName, stringValue, position++, null); }  offset += stringValue.length(); length++; } else { Reader reader; if (field.readerValue() != null) { reader = field.readerValue(); } else if (field.stringValue() != null) { reader = new StringReader(field.stringValue()); } else { throw new IllegalArgumentException(""field must have either String or Reader value""); }  TokenStream stream = this.analyzer.tokenStream(fieldName, reader); try { Token lastToken = null; for (Token t = stream.next(); t != null; t = stream.next()) { position += t.getPositionIncrement() - 1; if (field.isStoreOffsetWithTermVector()) { addPosition(fieldName, t.termText(), position++, new TermVectorOffsetInfo(offset + t.startOffset(), offset + t.endOffset())); } else { addPosition(fieldName, t.termText(), position++, null); }  lastToken = t; if (++length > this.maxFieldLength) { if (this.infoStream != null)
/*     */                   this.infoStream.println(""maxFieldLength "" + this.maxFieldLength + "" reached, ignoring following tokens"");  break; }  }  if (lastToken != null)
/* 247 */               offset += lastToken.endOffset() + 1;  } finally { stream.close(); }  }  this.fieldLengths[fieldNumber] = length; this.fieldPositions[fieldNumber] = position; this.fieldBoosts[fieldNumber] = this.fieldBoosts[fieldNumber] * field.getBoost(); this.fieldOffsets[fieldNumber] = offset; }  }  } private static final void quickSort(Posting[] postings, int lo, int hi) { if (lo >= hi) {
/*     */       return;
/*     */     }
/* 250 */     int mid = (lo + hi) / 2;
/*     */     
/* 252 */     if ((postings[lo]).term.compareTo((postings[mid]).term) > 0) {
/* 253 */       Posting tmp = postings[lo];
/* 254 */       postings[lo] = postings[mid];
/* 255 */       postings[mid] = tmp;
/*     */     } 
/*     */     
/* 258 */     if ((postings[mid]).term.compareTo((postings[hi]).term) > 0) {
/* 259 */       Posting tmp = postings[mid];
/* 260 */       postings[mid] = postings[hi];
/* 261 */       postings[hi] = tmp;
/*     */       
/* 263 */       if ((postings[lo]).term.compareTo((postings[mid]).term) > 0) {
/* 264 */         Posting tmp2 = postings[lo];
/* 265 */         postings[lo] = postings[mid];
/* 266 */         postings[mid] = tmp2;
/*     */       } 
/*     */     } 
/*     */     
/* 270 */     int left = lo + 1;
/* 271 */     int right = hi - 1;
/*     */     
/* 273 */     if (left >= right) {
/*     */       return;
/*     */     }
/* 276 */     Term partition = (postings[mid]).term;
/*     */     
/*     */     while (true) {
/* 279 */       while ((postings[right]).term.compareTo(partition) > 0) {
/* 280 */         right--;
/*     */       }
/* 282 */       while (left < right && (postings[left]).term.compareTo(partition) <= 0) {
/* 283 */         left++;
/*     */       }
/* 285 */       if (left < right) {
/* 286 */         Posting tmp = postings[left];
/* 287 */         postings[left] = postings[right];
/* 288 */         postings[right] = tmp;
/* 289 */         right--;
/*     */         
/*     */         continue;
/*     */       } 
/*     */       break;
/*     */     } 
/* 295 */     quickSort(postings, lo, left);
/* 296 */     quickSort(postings, left + 1, hi); }
/*     */ 
/*     */ 
/*     */   
/*     */   private final void writePostings(Posting[] postings, String segment) throws IOException {
/* 301 */     IndexOutput freq = null, prox = null;
/* 302 */     TermInfosWriter tis = null;
/* 303 */     TermVectorsWriter termVectorWriter = null;
/*     */     
/*     */     try {
/* 306 */       freq = this.directory.createOutput(segment + "".frq"");
/* 307 */       prox = this.directory.createOutput(segment + "".prx"");
/* 308 */       tis = new TermInfosWriter(this.directory, segment, this.fieldInfos, this.termIndexInterval);
/*     */       
/* 310 */       TermInfo ti = new TermInfo();
/* 311 */       String currentField = null;
/*     */       
/* 313 */       for (int i = 0; i < postings.length; i++) {
/* 314 */         Posting posting = postings[i];
/*     */ 
/*     */         
/* 317 */         ti.set(1, freq.getFilePointer(), prox.getFilePointer(), -1);
/* 318 */         tis.add(posting.term, ti);
/*     */ 
/*     */         
/* 321 */         int postingFreq = posting.freq;
/* 322 */         if (postingFreq == 1) {
/* 323 */           freq.writeVInt(1);
/*     */         } else {
/* 325 */           freq.writeVInt(0);
/* 326 */           freq.writeVInt(postingFreq);
/*     */         } 
/*     */         
/* 329 */         int lastPosition = 0;
/* 330 */         int[] positions = posting.positions;
/* 331 */         for (int j = 0; j < postingFreq; j++) {
/* 332 */           int position = positions[j];
/* 333 */           prox.writeVInt(position - lastPosition);
/* 334 */           lastPosition = position;
/*     */         } 
/*     */         
/* 337 */         String termField = posting.term.field();
/* 338 */         if (currentField != termField) {
/*     */           
/* 340 */           currentField = termField;
/* 341 */           FieldInfo fi = this.fieldInfos.fieldInfo(currentField);
/* 342 */           if (fi.storeTermVector) {
/* 343 */             if (termVectorWriter == null) {
/* 344 */               termVectorWriter = new TermVectorsWriter(this.directory, segment, this.fieldInfos);
/*     */               
/* 346 */               termVectorWriter.openDocument();
/*     */             } 
/* 348 */             termVectorWriter.openField(currentField);
/*     */           }
/* 350 */           else if (termVectorWriter != null) {
/* 351 */             termVectorWriter.closeField();
/*     */           } 
/*     */         } 
/* 354 */         if (termVectorWriter != null && termVectorWriter.isFieldOpen()) {
/* 355 */           termVectorWriter.addTerm(posting.term.text(), postingFreq, posting.positions, posting.offsets);
/*     */         }
/*     */       } 
/* 358 */       if (termVectorWriter != null) {
/* 359 */         termVectorWriter.closeDocument();
/*     */       }
/*     */     } finally {
/*     */       
/* 363 */       IOException keep = null;
/* 364 */       if (freq != null) try { freq.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 365 */           if (prox != null) try { prox.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 366 */           if (tis != null) try { tis.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 367 */           if (termVectorWriter != null) try { termVectorWriter.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 368 */           if (keep != null) throw (IOException)keep.fillInStackTrace(); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void writeNorms(String segment) throws IOException {
/* 373 */     for (int n = 0; n < this.fieldInfos.size(); n++) {
/* 374 */       FieldInfo fi = this.fieldInfos.fieldInfo(n);
/* 375 */       if (fi.isIndexed && !fi.omitNorms) {
/* 376 */         float norm = this.fieldBoosts[n] * this.similarity.lengthNorm(fi.name, this.fieldLengths[n]);
/* 377 */         IndexOutput norms = this.directory.createOutput(segment + "".f"" + n);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 390 */   void setInfoStream(PrintStream infoStream) { this.infoStream = infoStream; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\DocumentWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class FieldInfo
/*    */ {
/*    */   String name;
/*    */   boolean isIndexed;
/*    */   int number;
/*    */   boolean storeTermVector;
/*    */   boolean storeOffsetWithTermVector;
/*    */   boolean storePositionWithTermVector;
/*    */   boolean omitNorms;
/*    */   
/*    */   FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) {
/* 33 */     this.name = na;
/* 34 */     this.isIndexed = tk;
/* 35 */     this.number = nu;
/* 36 */     this.storeTermVector = storeTermVector;
/* 37 */     this.storeOffsetWithTermVector = storeOffsetWithTermVector;
/* 38 */     this.storePositionWithTermVector = storePositionWithTermVector;
/* 39 */     this.omitNorms = omitNorms;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\FieldInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldInfos
/*     */ {
/*     */   static final byte IS_INDEXED = 1;
/*     */   static final byte STORE_TERMVECTOR = 2;
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 4;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 8;
/*     */   static final byte OMIT_NORMS = 16;
/*  43 */   private ArrayList byNumber = new ArrayList();
/*  44 */   private HashMap byName = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos(Directory d, String name) throws IOException {
/*  56 */     IndexInput input = d.openInput(name);
/*     */     try {
/*  58 */       read(input);
/*     */     } finally {
/*  60 */       input.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void add(Document doc) {
/*  66 */     Enumeration fields = doc.fields();
/*  67 */     while (fields.hasMoreElements()) {
/*  68 */       Field field = fields.nextElement();
/*  69 */       add(field.name(), field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(), field.getOmitNorms());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addIndexed(Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) {
/*  84 */     Iterator i = names.iterator();
/*  85 */     while (i.hasNext()) {
/*  86 */       add(i.next(), true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Collection names, boolean isIndexed) {
/*  99 */     Iterator i = names.iterator();
/* 100 */     while (i.hasNext()) {
/* 101 */       add(i.next(), isIndexed);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public void add(String name, boolean isIndexed) { add(name, isIndexed, false, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 124 */   public void add(String name, boolean isIndexed, boolean storeTermVector) { add(name, isIndexed, storeTermVector, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 141 */   public void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) { add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) {
/* 158 */     FieldInfo fi = fieldInfo(name);
/* 159 */     if (fi == null) {
/* 160 */       addInternal(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms);
/*     */     } else {
/* 162 */       if (fi.isIndexed != isIndexed) {
/* 163 */         fi.isIndexed = true;
/*     */       }
/* 165 */       if (fi.storeTermVector != storeTermVector) {
/* 166 */         fi.storeTermVector = true;
/*     */       }
/* 168 */       if (fi.storePositionWithTermVector != storePositionWithTermVector) {
/* 169 */         fi.storePositionWithTermVector = true;
/*     */       }
/* 171 */       if (fi.storeOffsetWithTermVector != storeOffsetWithTermVector) {
/* 172 */         fi.storeOffsetWithTermVector = true;
/*     */       }
/* 174 */       if (fi.omitNorms != omitNorms) {
/* 175 */         fi.omitNorms = false;
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void addInternal(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) {
/* 185 */     FieldInfo fi = new FieldInfo(name, isIndexed, this.byNumber.size(), storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms);
/*     */ 
/*     */     
/* 188 */     this.byNumber.add(fi);
/* 189 */     this.byName.put(name, fi);
/*     */   }
/*     */   
/*     */   public int fieldNumber(String fieldName) {
/*     */     try {
/* 194 */       FieldInfo fi = fieldInfo(fieldName);
/* 195 */       if (fi != null) {
/* 196 */         return fi.number;
/*     */       }
/* 198 */     } catch (IndexOutOfBoundsException ioobe) {
/* 199 */       return -1;
/*     */     } 
/* 201 */     return -1;
/*     */   }
/*     */ 
/*     */   
/* 205 */   public FieldInfo fieldInfo(String fieldName) { return (FieldInfo)this.byName.get(fieldName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String fieldName(int fieldNumber) {
/*     */     try {
/* 217 */       return (fieldInfo(fieldNumber)).name;
/*     */     }
/* 219 */     catch (NullPointerException npe) {
/* 220 */       return """";
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FieldInfo fieldInfo(int fieldNumber) {
/*     */     try {
/* 232 */       return this.byNumber.get(fieldNumber);
/*     */     }
/* 234 */     catch (IndexOutOfBoundsException ioobe) {
/* 235 */       return null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 240 */   public int size() { return this.byNumber.size(); }
/*     */ 
/*     */   
/*     */   public boolean hasVectors() {
/* 244 */     boolean hasVectors = false;
/* 245 */     for (int i = 0; i < size(); i++) {
/* 246 */       if ((fieldInfo(i)).storeTermVector) {
/* 247 */         hasVectors = true;
/*     */         break;
/*     */       } 
/*     */     } 
/* 251 */     return hasVectors;
/*     */   }
/*     */   
/*     */   public void write(Directory d, String name) throws IOException {
/* 255 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 257 */       write(output);
/*     */     } finally {
/* 259 */       output.close();
/*     */     } 
/*     */   }
/*     */   
/*     */   public void write(IndexOutput output) throws IOException {
/* 264 */     output.writeVInt(size());
/* 265 */     for (int i = 0; i < size(); i++) {
/* 266 */       FieldInfo fi = fieldInfo(i);
/* 267 */       byte bits = 0;
/* 268 */       if (fi.isIndexed) bits = (byte)(bits | 0x1); 
/* 269 */       if (fi.storeTermVector) bits = (byte)(bits | 0x2); 
/* 270 */       if (fi.storePositionWithTermVector) bits = (byte)(bits | 0x4); 
/* 271 */       if (fi.storeOffsetWithTermVector) bits = (byte)(bits | 0x8); 
/* 272 */       if (fi.omitNorms) bits = (byte)(bits | 0x10); 
/* 273 */       output.writeString(fi.name);
/* 274 */       output.writeByte(bits);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void read(IndexInput input) throws IOException {
/* 279 */     int size = input.readVInt();
/* 280 */     for (int i = 0; i < size; i++) {
/* 281 */       String name = input.readString().intern();
/* 282 */       byte bits = input.readByte();
/* 283 */       boolean isIndexed = ((bits & 0x1) != 0);
/* 284 */       boolean storeTermVector = ((bits & 0x2) != 0);
/* 285 */       boolean storePositionsWithTermVector = ((bits & 0x4) != 0);
/* 286 */       boolean storeOffsetWithTermVector = ((bits & 0x8) != 0);
/* 287 */       boolean omitNorms = ((bits & 0x10) != 0);
/*     */       
/* 289 */       addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\FieldInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.zip.DataFormatException;
/*     */ import java.util.zip.Inflater;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsReader
/*     */ {
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexInput fieldsStream;
/*     */   private IndexInput indexStream;
/*     */   private int size;
/*     */   
/*     */   FieldsReader(Directory d, String segment, FieldInfos fn) throws IOException {
/*  43 */     this.fieldInfos = fn;
/*     */     
/*  45 */     this.fieldsStream = d.openInput(segment + "".fdt"");
/*  46 */     this.indexStream = d.openInput(segment + "".fdx"");
/*     */     
/*  48 */     this.size = (int)(this.indexStream.length() / 8L);
/*     */   }
/*     */   
/*     */   final void close() throws IOException {
/*  52 */     this.fieldsStream.close();
/*  53 */     this.indexStream.close();
/*     */   }
/*     */ 
/*     */   
/*  57 */   final int size() { return this.size; }
/*     */ 
/*     */   
/*     */   final Document doc(int n) throws IOException {
/*  61 */     this.indexStream.seek(n * 8L);
/*  62 */     long position = this.indexStream.readLong();
/*  63 */     this.fieldsStream.seek(position);
/*     */     
/*  65 */     Document doc = new Document();
/*  66 */     int numFields = this.fieldsStream.readVInt();
/*  67 */     for (int i = 0; i < numFields; i++) {
/*  68 */       int fieldNumber = this.fieldsStream.readVInt();
/*  69 */       FieldInfo fi = this.fieldInfos.fieldInfo(fieldNumber);
/*     */       
/*  71 */       byte bits = this.fieldsStream.readByte();
/*     */       
/*  73 */       boolean compressed = ((bits & 0x4) != 0);
/*  74 */       boolean tokenize = ((bits & 0x1) != 0);
/*     */       
/*  76 */       if ((bits & 0x2) != 0) {
/*  77 */         byte[] b = new byte[this.fieldsStream.readVInt()];
/*  78 */         this.fieldsStream.readBytes(b, 0, b.length);
/*  79 */         if (compressed) {
/*  80 */           doc.add(new Field(fi.name, uncompress(b), Field.Store.COMPRESS));
/*     */         } else {
/*  82 */           doc.add(new Field(fi.name, b, Field.Store.YES));
/*     */         } 
/*     */       } else {
/*     */         Field.Index index;
/*  86 */         Field.Store store = Field.Store.YES;
/*     */         
/*  88 */         if (fi.isIndexed && tokenize) {
/*  89 */           index = Field.Index.TOKENIZED;
/*  90 */         } else if (fi.isIndexed && !tokenize) {
/*  91 */           index = Field.Index.UN_TOKENIZED;
/*     */         } else {
/*  93 */           index = Field.Index.NO;
/*     */         } 
/*  95 */         Field.TermVector termVector = null;
/*  96 */         if (fi.storeTermVector) {
/*  97 */           if (fi.storeOffsetWithTermVector) {
/*  98 */             if (fi.storePositionWithTermVector) {
/*  99 */               termVector = Field.TermVector.WITH_POSITIONS_OFFSETS;
/*     */             } else {
/*     */               
/* 102 */               termVector = Field.TermVector.WITH_OFFSETS;
/*     */             }
/*     */           
/* 105 */           } else if (fi.storePositionWithTermVector) {
/* 106 */             termVector = Field.TermVector.WITH_POSITIONS;
/*     */           } else {
/*     */             
/* 109 */             termVector = Field.TermVector.YES;
/*     */           } 
/*     */         } else {
/*     */           
/* 113 */           termVector = Field.TermVector.NO;
/*     */         } 
/*     */         
/* 116 */         if (compressed) {
/* 117 */           store = Field.Store.COMPRESS;
/* 118 */           byte[] b = new byte[this.fieldsStream.readVInt()];
/* 119 */           this.fieldsStream.readBytes(b, 0, b.length);
/* 120 */           Field f = new Field(fi.name, new String(uncompress(b), ""UTF-8""), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 125 */           f.setOmitNorms(fi.omitNorms);
/* 126 */           doc.add(f);
/*     */         } else {
/*     */           
/* 129 */           Field f = new Field(fi.name, this.fieldsStream.readString(), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 134 */           f.setOmitNorms(fi.omitNorms);
/* 135 */           doc.add(f);
/*     */         } 
/*     */       } 
/*     */     } 
/*     */     
/* 140 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final byte[] uncompress(byte[] input) throws IOException {
/* 147 */     Inflater decompressor = new Inflater();
/* 148 */     decompressor.setInput(input);
/*     */ 
/*     */     
/* 151 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);
/*     */ 
/*     */     
/* 154 */     byte[] buf = new byte[1024];
/* 155 */     while (!decompressor.finished()) {
/*     */       try {
/* 157 */         int count = decompressor.inflate(buf);
/* 158 */         bos.write(buf, 0, count);
/*     */       }
/* 160 */       catch (DataFormatException e) {
/*     */         
/* 162 */         IOException newException = new IOException(""field data are in wrong format: "" + e.toString());
/* 163 */         newException.initCause(e);
/* 164 */         throw newException;
/*     */       } 
/*     */     } 
/*     */     
/* 168 */     decompressor.end();
/*     */ 
/*     */     
/* 171 */     return bos.toByteArray();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\FieldsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.Enumeration;
/*     */ import java.util.zip.Deflater;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsWriter
/*     */ {
/*     */   static final byte FIELD_IS_TOKENIZED = 1;
/*     */   static final byte FIELD_IS_BINARY = 2;
/*     */   static final byte FIELD_IS_COMPRESSED = 4;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput fieldsStream;
/*     */   private IndexOutput indexStream;
/*     */   
/*     */   FieldsWriter(Directory d, String segment, FieldInfos fn) throws IOException {
/*  42 */     this.fieldInfos = fn;
/*  43 */     this.fieldsStream = d.createOutput(segment + "".fdt"");
/*  44 */     this.indexStream = d.createOutput(segment + "".fdx"");
/*     */   }
/*     */   
/*     */   final void close() throws IOException {
/*  48 */     this.fieldsStream.close();
/*  49 */     this.indexStream.close();
/*     */   }
/*     */   
/*     */   final void addDocument(Document doc) throws IOException {
/*  53 */     this.indexStream.writeLong(this.fieldsStream.getFilePointer());
/*     */     
/*  55 */     int storedCount = 0;
/*  56 */     Enumeration fields = doc.fields();
/*  57 */     while (fields.hasMoreElements()) {
/*  58 */       Field field = fields.nextElement();
/*  59 */       if (field.isStored())
/*  60 */         storedCount++; 
/*     */     } 
/*  62 */     this.fieldsStream.writeVInt(storedCount);
/*     */     
/*  64 */     fields = doc.fields();
/*  65 */     while (fields.hasMoreElements()) {
/*  66 */       Field field = fields.nextElement();
/*  67 */       if (field.isStored()) {
/*  68 */         this.fieldsStream.writeVInt(this.fieldInfos.fieldNumber(field.name()));
/*     */         
/*  70 */         byte bits = 0;
/*  71 */         if (field.isTokenized())
/*  72 */           bits = (byte)(bits | 0x1); 
/*  73 */         if (field.isBinary())
/*  74 */           bits = (byte)(bits | 0x2); 
/*  75 */         if (field.isCompressed()) {
/*  76 */           bits = (byte)(bits | 0x4);
/*     */         }
/*  78 */         this.fieldsStream.writeByte(bits);
/*     */         
/*  80 */         if (field.isCompressed()) {
/*     */           
/*  82 */           byte[] data = null;
/*     */           
/*  84 */           if (field.isBinary()) {
/*  85 */             data = compress(field.binaryValue());
/*     */           } else {
/*     */             
/*  88 */             data = compress(field.stringValue().getBytes(""UTF-8""));
/*     */           } 
/*  90 */           int len = data.length;
/*  91 */           this.fieldsStream.writeVInt(len);
/*  92 */           this.fieldsStream.writeBytes(data, len);
/*     */           
/*     */           continue;
/*     */         } 
/*  96 */         if (field.isBinary()) {
/*  97 */           byte[] data = field.binaryValue();
/*  98 */           int len = data.length;
/*  99 */           this.fieldsStream.writeVInt(len);
/* 100 */           this.fieldsStream.writeBytes(data, len);
/*     */           continue;
/*     */         } 
/* 103 */         this.fieldsStream.writeString(field.stringValue());
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final byte[] compress(byte[] input) {
/* 113 */     Deflater compressor = new Deflater();
/* 114 */     compressor.setLevel(9);
/*     */ 
/*     */     
/* 117 */     compressor.setInput(input);
/* 118 */     compressor.finish();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 126 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);
/*     */ 
/*     */     
/* 129 */     byte[] buf = new byte[1024];
/* 130 */     while (!compressor.finished()) {
/* 131 */       int count = compressor.deflate(buf);
/* 132 */       bos.write(buf, 0, count);
/*     */     } 
/*     */     
/* 135 */     compressor.end();
/*     */ 
/*     */     
/* 138 */     return bos.toByteArray();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\FieldsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FilterIndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilterIndexReader
/*     */   extends IndexReader
/*     */ {
/*     */   protected IndexReader in;
/*     */   
/*     */   public static class FilterTermDocs
/*     */     implements TermDocs
/*     */   {
/*     */     protected TermDocs in;
/*     */     
/*  39 */     public FilterTermDocs(TermDocs in) { this.in = in; }
/*     */     
/*  41 */     public void seek(Term term) throws IOException { this.in.seek(term); }
/*  42 */     public void seek(TermEnum termEnum) throws IOException { this.in.seek(termEnum); }
/*  43 */     public int doc() { return this.in.doc(); }
/*  44 */     public int freq() { return this.in.freq(); }
/*  45 */     public boolean next() throws IOException { return this.in.next(); }
/*     */     
/*  47 */     public int read(int[] docs, int[] freqs) throws IOException { return this.in.read(docs, freqs); }
/*     */     
/*  49 */     public boolean skipTo(int i) throws IOException { return this.in.skipTo(i); }
/*  50 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermPositions
/*     */     extends FilterTermDocs
/*     */     implements TermPositions
/*     */   {
/*  57 */     public FilterTermPositions(TermPositions in) { super(in); }
/*     */ 
/*     */     
/*  60 */     public int nextPosition() throws IOException { return ((TermPositions)this.in).nextPosition(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermEnum
/*     */     extends TermEnum
/*     */   {
/*     */     protected TermEnum in;
/*     */     
/*  68 */     public FilterTermEnum(TermEnum in) { this.in = in; }
/*     */     
/*  70 */     public boolean next() throws IOException { return this.in.next(); }
/*  71 */     public Term term() { return this.in.term(); }
/*  72 */     public int docFreq() { return this.in.docFreq(); }
/*  73 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FilterIndexReader(IndexReader in) {
/*  86 */     super(in.directory());
/*  87 */     this.in = in;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  92 */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException { return this.in.getTermFreqVectors(docNumber); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException { return this.in.getTermFreqVector(docNumber, field); }
/*     */ 
/*     */   
/* 100 */   public int numDocs() { return this.in.numDocs(); }
/* 101 */   public int maxDoc() { return this.in.maxDoc(); }
/*     */   
/* 103 */   public Document document(int n) throws IOException { return this.in.document(n); }
/*     */   
/* 105 */   public boolean isDeleted(int n) { return this.in.isDeleted(n); }
/* 106 */   public boolean hasDeletions() { return this.in.hasDeletions(); }
/* 107 */   protected void doUndeleteAll() throws IOException { this.in.undeleteAll(); }
/*     */ 
/*     */   
/* 110 */   public boolean hasNorms(String field) throws IOException { return this.in.hasNorms(field); }
/*     */ 
/*     */   
/* 113 */   public byte[] norms(String f) throws IOException { return this.in.norms(f); }
/*     */   
/* 115 */   public void norms(String f, byte[] bytes, int offset) throws IOException { this.in.norms(f, bytes, offset); }
/*     */ 
/*     */   
/* 118 */   protected void doSetNorm(int d, String f, byte b) throws IOException { this.in.setNorm(d, f, b); }
/*     */ 
/*     */   
/* 121 */   public TermEnum terms() throws IOException { return this.in.terms(); }
/* 122 */   public TermEnum terms(Term t) throws IOException { return this.in.terms(t); }
/*     */   
/* 124 */   public int docFreq(Term t) throws IOException { return this.in.docFreq(t); }
/*     */   
/* 126 */   public TermDocs termDocs() throws IOException { return this.in.termDocs(); }
/*     */ 
/*     */   
/* 129 */   public TermPositions termPositions() throws IOException { return this.in.termPositions(); }
/*     */ 
/*     */   
/* 132 */   protected void doDelete(int n) throws IOException { this.in.deleteDocument(n); }
/* 133 */   protected void doCommit() throws IOException { this.in.commit(); }
/* 134 */   protected void doClose() throws IOException { this.in.close(); }
/*     */ 
/*     */ 
/*     */   
/* 138 */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) { return this.in.getFieldNames(fieldNames); }
/*     */ 
/*     */   
/* 141 */   public long getVersion() { return this.in.getVersion(); }
/* 142 */   public boolean isCurrent() throws IOException { return this.in.isCurrent(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\FilterIndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNameFilter,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.FilenameFilter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class IndexFileNameFilter
/*    */   implements FilenameFilter
/*    */ {
/*    */   public boolean accept(File dir, String name) {
/* 34 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS.length; i++) {
/* 35 */       if (name.endsWith(""."" + IndexFileNames.INDEX_EXTENSIONS[i]))
/* 36 */         return true; 
/*    */     } 
/* 38 */     if (name.equals(""deletable"")) return true; 
/* 39 */     if (name.equals(""segments"")) return true; 
/* 40 */     if (name.matches("".+\\.f\\d+"")) return true; 
/* 41 */     return false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\IndexFileNameFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNames,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class IndexFileNames
/*    */ {
/*    */   static final String SEGMENTS = ""segments"";
/*    */   static final String DELETABLE = ""deletable"";
/* 39 */   static final String[] INDEX_EXTENSIONS = new String[] { ""cfs"", ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""del"", ""tvx"", ""tvd"", ""tvf"", ""tvp"" };
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   static final String[] COMPOUND_EXTENSIONS = new String[] { ""fnm"", ""frq"", ""prx"", ""fdx"", ""fdt"", ""tii"", ""tis"" };
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   static final String[] VECTOR_EXTENSIONS = new String[] { ""tvx"", ""tvd"", ""tvf"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\IndexFileNames.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexModifier,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexModifier
/*     */ {
/*  88 */   protected IndexWriter indexWriter = null;
/*  89 */   protected IndexReader indexReader = null;
/*     */   
/*  91 */   protected Directory directory = null;
/*  92 */   protected Analyzer analyzer = null;
/*     */   
/*     */   protected boolean open = false;
/*     */   
/*  96 */   protected PrintStream infoStream = null;
/*     */   protected boolean useCompoundFile = true;
/*  98 */   protected int maxBufferedDocs = 10;
/*  99 */   protected int maxFieldLength = 10000;
/* 100 */   protected int mergeFactor = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   public IndexModifier(Directory directory, Analyzer analyzer, boolean create) throws IOException { init(directory, analyzer, create); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(String dirName, Analyzer analyzer, boolean create) throws IOException {
/* 123 */     FSDirectory fSDirectory = FSDirectory.getDirectory(dirName, create);
/* 124 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(File file, Analyzer analyzer, boolean create) throws IOException {
/* 136 */     FSDirectory fSDirectory = FSDirectory.getDirectory(file, create);
/* 137 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void init(Directory directory, Analyzer analyzer, boolean create) throws IOException {
/* 145 */     this.directory = directory;
/* 146 */     synchronized (this.directory) {
/* 147 */       this.analyzer = analyzer;
/* 148 */       this.indexWriter = new IndexWriter(directory, analyzer, create);
/* 149 */       this.open = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void assureOpen() {
/* 158 */     if (!this.open) {
/* 159 */       throw new IllegalStateException(""Index is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexWriter() throws IOException {
/* 168 */     if (this.indexWriter == null) {
/* 169 */       if (this.indexReader != null) {
/* 170 */         this.indexReader.close();
/* 171 */         this.indexReader = null;
/*     */       } 
/* 173 */       this.indexWriter = new IndexWriter(this.directory, this.analyzer, false);
/* 174 */       this.indexWriter.setInfoStream(this.infoStream);
/* 175 */       this.indexWriter.setUseCompoundFile(this.useCompoundFile);
/* 176 */       this.indexWriter.setMaxBufferedDocs(this.maxBufferedDocs);
/* 177 */       this.indexWriter.setMaxFieldLength(this.maxFieldLength);
/* 178 */       this.indexWriter.setMergeFactor(this.mergeFactor);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexReader() throws IOException {
/* 187 */     if (this.indexReader == null) {
/* 188 */       if (this.indexWriter != null) {
/* 189 */         this.indexWriter.close();
/* 190 */         this.indexWriter = null;
/*     */       } 
/* 192 */       this.indexReader = IndexReader.open(this.directory);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws IOException {
/* 201 */     synchronized (this.directory) {
/* 202 */       assureOpen();
/* 203 */       if (this.indexWriter != null) {
/* 204 */         this.indexWriter.close();
/* 205 */         this.indexWriter = null;
/* 206 */         createIndexWriter();
/*     */       } else {
/* 208 */         this.indexReader.close();
/* 209 */         this.indexReader = null;
/* 210 */         createIndexReader();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addDocument(Document doc, Analyzer docAnalyzer) throws IOException {
/* 224 */     synchronized (this.directory) {
/* 225 */       assureOpen();
/* 226 */       createIndexWriter();
/* 227 */       if (docAnalyzer != null) {
/* 228 */         this.indexWriter.addDocument(doc, docAnalyzer);
/*     */       } else {
/* 230 */         this.indexWriter.addDocument(doc);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 242 */   public void addDocument(Document doc) throws IOException { addDocument(doc, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int deleteDocuments(Term term) throws IOException {
/* 256 */     synchronized (this.directory) {
/* 257 */       assureOpen();
/* 258 */       createIndexReader();
/* 259 */       return this.indexReader.deleteDocuments(term);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void deleteDocument(int docNum) throws IOException {
/* 269 */     synchronized (this.directory) {
/* 270 */       assureOpen();
/* 271 */       createIndexReader();
/* 272 */       this.indexReader.deleteDocument(docNum);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int docCount() {
/* 284 */     synchronized (this.directory) {
/* 285 */       assureOpen();
/* 286 */       if (this.indexWriter != null) {
/* 287 */         return this.indexWriter.docCount();
/*     */       }
/* 289 */       return this.indexReader.numDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void optimize() throws IOException {
/* 301 */     synchronized (this.directory) {
/* 302 */       assureOpen();
/* 303 */       createIndexWriter();
/* 304 */       this.indexWriter.optimize();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setInfoStream(PrintStream infoStream) {
/* 316 */     synchronized (this.directory) {
/* 317 */       assureOpen();
/* 318 */       if (this.indexWriter != null) {
/* 319 */         this.indexWriter.setInfoStream(infoStream);
/*     */       }
/* 321 */       this.infoStream = infoStream;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public PrintStream getInfoStream() throws IOException {
/* 330 */     synchronized (this.directory) {
/* 331 */       assureOpen();
/* 332 */       createIndexWriter();
/* 333 */       return this.indexWriter.getInfoStream();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setUseCompoundFile(boolean useCompoundFile) {
/* 345 */     synchronized (this.directory) {
/* 346 */       assureOpen();
/* 347 */       if (this.indexWriter != null) {
/* 348 */         this.indexWriter.setUseCompoundFile(useCompoundFile);
/*     */       }
/* 350 */       this.useCompoundFile = useCompoundFile;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean getUseCompoundFile() throws IOException {
/* 359 */     synchronized (this.directory) {
/* 360 */       assureOpen();
/* 361 */       createIndexWriter();
/* 362 */       return this.indexWriter.getUseCompoundFile();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxFieldLength(int maxFieldLength) {
/* 381 */     synchronized (this.directory) {
/* 382 */       assureOpen();
/* 383 */       if (this.indexWriter != null) {
/* 384 */         this.indexWriter.setMaxFieldLength(maxFieldLength);
/*     */       }
/* 386 */       this.maxFieldLength = maxFieldLength;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxFieldLength() throws IOException {
/* 395 */     synchronized (this.directory) {
/* 396 */       assureOpen();
/* 397 */       createIndexWriter();
/* 398 */       return this.indexWriter.getMaxFieldLength();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/* 417 */     synchronized (this.directory) {
/* 418 */       assureOpen();
/* 419 */       if (this.indexWriter != null) {
/* 420 */         this.indexWriter.setMaxBufferedDocs(maxBufferedDocs);
/*     */       }
/* 422 */       this.maxBufferedDocs = maxBufferedDocs;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxBufferedDocs() throws IOException {
/* 431 */     synchronized (this.directory) {
/* 432 */       assureOpen();
/* 433 */       createIndexWriter();
/* 434 */       return this.indexWriter.getMaxBufferedDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMergeFactor(int mergeFactor) {
/* 452 */     synchronized (this.directory) {
/* 453 */       assureOpen();
/* 454 */       if (this.indexWriter != null) {
/* 455 */         this.indexWriter.setMergeFactor(mergeFactor);
/*     */       }
/* 457 */       this.mergeFactor = mergeFactor;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMergeFactor() throws IOException {
/* 466 */     synchronized (this.directory) {
/* 467 */       assureOpen();
/* 468 */       createIndexWriter();
/* 469 */       return this.indexWriter.getMergeFactor();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 479 */     synchronized (this.directory) {
/* 480 */       if (!this.open)
/* 481 */         throw new IllegalStateException(""Index is closed already""); 
/* 482 */       if (this.indexWriter != null) {
/* 483 */         this.indexWriter.close();
/* 484 */         this.indexWriter = null;
/*     */       } else {
/* 486 */         this.indexReader.close();
/* 487 */         this.indexReader = null;
/*     */       } 
/* 489 */       this.open = false;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 494 */   public String toString() { return ""Index@"" + this.directory; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\IndexModifier.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexReader
/*     */ {
/*     */   private Directory directory;
/*     */   private boolean directoryOwner;
/*     */   private boolean closeDirectory;
/*     */   private SegmentInfos segmentInfos;
/*     */   private Lock writeLock;
/*     */   private boolean stale;
/*     */   private boolean hasChanges;
/*     */   
/*     */   public static final class FieldOption
/*     */   {
/*     */     private String option;
/*     */     
/*     */     private FieldOption() {}
/*     */     
/*  58 */     private FieldOption(String option) { this.option = option; }
/*     */ 
/*     */     
/*  61 */     public String toString() { return this.option; }
/*     */ 
/*     */     
/*  64 */     public static final FieldOption ALL = new FieldOption(""ALL"");
/*     */     
/*  66 */     public static final FieldOption INDEXED = new FieldOption(""INDEXED"");
/*     */     
/*  68 */     public static final FieldOption UNINDEXED = new FieldOption(""UNINDEXED"");
/*     */     
/*  70 */     public static final FieldOption INDEXED_WITH_TERMVECTOR = new FieldOption(""INDEXED_WITH_TERMVECTOR"");
/*     */     
/*  72 */     public static final FieldOption INDEXED_NO_TERMVECTOR = new FieldOption(""INDEXED_NO_TERMVECTOR"");
/*     */     
/*  74 */     public static final FieldOption TERMVECTOR = new FieldOption(""TERMVECTOR"");
/*     */     
/*  76 */     public static final FieldOption TERMVECTOR_WITH_POSITION = new FieldOption(""TERMVECTOR_WITH_POSITION"");
/*     */     
/*  78 */     public static final FieldOption TERMVECTOR_WITH_OFFSET = new FieldOption(""TERMVECTOR_WITH_OFFSET"");
/*     */     
/*  80 */     public static final FieldOption TERMVECTOR_WITH_POSITION_OFFSET = new FieldOption(""TERMVECTOR_WITH_POSITION_OFFSET"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  90 */   protected IndexReader(Directory directory) { this.directory = directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 102 */   IndexReader(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory) { init(directory, segmentInfos, closeDirectory, true); }
/*     */ 
/*     */   
/*     */   void init(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory, boolean directoryOwner) {
/* 106 */     this.directory = directory;
/* 107 */     this.segmentInfos = segmentInfos;
/* 108 */     this.directoryOwner = directoryOwner;
/* 109 */     this.closeDirectory = closeDirectory;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public static IndexReader open(String path) throws IOException { return open((Directory)FSDirectory.getDirectory(path, false), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 131 */   public static IndexReader open(File path) throws IOException { return open((Directory)FSDirectory.getDirectory(path, false), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 136 */   public static IndexReader open(Directory directory) throws IOException { return open(directory, false); }
/*     */ 
/*     */   
/*     */   private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {
/* 140 */     synchronized (directory) {
/* 141 */       return (IndexReader)(new Lock.With(directory.makeLock(""commit.lock""), 10000L) {
/*     */           private final Directory val$directory;
/*     */           
/*     */           public Object doBody() throws IOException {
/* 145 */             SegmentInfos infos = new SegmentInfos();
/* 146 */             infos.read(directory);
/* 147 */             if (infos.size() == 1) {
/* 148 */               return SegmentReader.get(infos, infos.info(0), closeDirectory);
/*     */             }
/* 150 */             IndexReader[] readers = new IndexReader[infos.size()];
/* 151 */             for (int i = 0; i < infos.size(); i++)
/* 152 */               readers[i] = SegmentReader.get(infos.info(i)); 
/* 153 */             return new MultiReader(directory, infos, closeDirectory, readers);
/*     */           }
/*     */           
/*     */           private final boolean val$closeDirectory;
/*     */         }).run();
/*     */     } 
/*     */   }
/*     */   
/* 161 */   public Directory directory() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 169 */   public static long lastModified(String directory) throws IOException { return lastModified(new File(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 178 */   public static long lastModified(File directory) throws IOException { return FSDirectory.fileModified(directory, ""segments""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 187 */   public static long lastModified(Directory directory) throws IOException { return directory.fileModified(""segments""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 200 */   public static long getCurrentVersion(String directory) throws IOException { return getCurrentVersion(new File(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentVersion(File directory) throws IOException {
/* 213 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory, false);
/* 214 */     long version = getCurrentVersion((Directory)fSDirectory);
/* 215 */     fSDirectory.close();
/* 216 */     return version;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentVersion(Directory directory) throws IOException {
/* 229 */     synchronized (directory) {
/* 230 */       Lock commitLock = directory.makeLock(""commit.lock"");
/*     */       
/* 232 */       boolean locked = false;
/*     */       
/*     */       try {
/* 235 */         locked = commitLock.obtain(10000L);
/*     */         
/* 237 */         return SegmentInfos.readCurrentVersion(directory);
/*     */       } finally {
/* 239 */         if (locked) {
/* 240 */           commitLock.release();
/*     */         }
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 250 */   public long getVersion() { return this.segmentInfos.getVersion(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isCurrent() throws IOException {
/* 261 */     synchronized (this.directory) {
/* 262 */       Lock commitLock = this.directory.makeLock(""commit.lock"");
/*     */       
/* 264 */       boolean locked = false;
/*     */       
/*     */       try {
/* 267 */         locked = commitLock.obtain(10000L);
/*     */         
/* 269 */         return (SegmentInfos.readCurrentVersion(this.directory) == this.segmentInfos.getVersion());
/*     */       } finally {
/* 271 */         if (locked) {
/* 272 */           commitLock.release();
/*     */         }
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 321 */   public static boolean indexExists(String directory) { return (new File(directory, ""segments"")).exists(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 331 */   public static boolean indexExists(File directory) { return (new File(directory, ""segments"")).exists(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 342 */   public static boolean indexExists(Directory directory) throws IOException { return directory.fileExists(""segments""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 368 */   public boolean hasNorms(String field) throws IOException { return (norms(field) != null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void setNorm(int doc, String field, byte value) throws IOException {
/* 397 */     if (this.directoryOwner)
/* 398 */       aquireWriteLock(); 
/* 399 */     doSetNorm(doc, field, value);
/* 400 */     this.hasChanges = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 415 */   public void setNorm(int doc, String field, float value) throws IOException { setNorm(doc, field, Similarity.encodeNorm(value)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermDocs termDocs(Term term) throws IOException {
/* 444 */     TermDocs termDocs = termDocs();
/* 445 */     termDocs.seek(term);
/* 446 */     return termDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermPositions termPositions(Term term) throws IOException {
/* 469 */     TermPositions termPositions = termPositions();
/* 470 */     termPositions.seek(term);
/* 471 */     return termPositions;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void aquireWriteLock() throws IOException {
/* 484 */     if (this.stale) {
/* 485 */       throw new IOException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */     }
/* 487 */     if (this.writeLock == null) {
/* 488 */       Lock writeLock = this.directory.makeLock(""write.lock"");
/* 489 */       if (!writeLock.obtain(1000L))
/* 490 */         throw new IOException(""Index locked for write: "" + writeLock); 
/* 491 */       this.writeLock = writeLock;
/*     */ 
/*     */ 
/*     */       
/* 495 */       if (SegmentInfos.readCurrentVersion(this.directory) > this.segmentInfos.getVersion()) {
/* 496 */         this.stale = true;
/* 497 */         this.writeLock.release();
/* 498 */         this.writeLock = null;
/* 499 */         throw new IOException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void deleteDocument(int docNum) throws IOException {
/* 513 */     if (this.directoryOwner)
/* 514 */       aquireWriteLock(); 
/* 515 */     doDelete(docNum);
/* 516 */     this.hasChanges = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int deleteDocuments(Term term) throws IOException {
/* 536 */     TermDocs docs = termDocs(term);
/* 537 */     if (docs == null) return 0; 
/* 538 */     int n = 0;
/*     */     try {
/* 540 */       while (docs.next()) {
/* 541 */         deleteDocument(docs.doc());
/* 542 */         n++;
/*     */       } 
/*     */     } finally {
/* 545 */       docs.close();
/*     */     } 
/* 547 */     return n;
/*     */   }
/*     */ 
/*     */   
/*     */   public final synchronized void undeleteAll() throws IOException {
/* 552 */     if (this.directoryOwner)
/* 553 */       aquireWriteLock(); 
/* 554 */     doUndeleteAll();
/* 555 */     this.hasChanges = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final synchronized void commit() throws IOException {
/* 567 */     if (this.hasChanges)
/* 568 */       if (this.directoryOwner) {
/* 569 */         synchronized (this.directory) {
/* 570 */           (new Lock.With(this.directory.makeLock(""commit.lock""), 10000L) { private final IndexReader this$0;
/*     */               
/*     */               public Object doBody() throws IOException {
/* 573 */                 IndexReader.this.doCommit();
/* 574 */                 IndexReader.this.segmentInfos.write(IndexReader.this.directory);
/* 575 */                 return null;
/*     */               } }
/*     */             ).run();
/*     */         } 
/* 579 */         if (this.writeLock != null) {
/* 580 */           this.writeLock.release();
/* 581 */           this.writeLock = null;
/*     */         } 
/*     */       } else {
/*     */         
/* 585 */         doCommit();
/*     */       }  
/* 587 */     this.hasChanges = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void close() throws IOException {
/* 599 */     commit();
/* 600 */     doClose();
/* 601 */     if (this.closeDirectory) {
/* 602 */       this.directory.close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void finalize() {
/* 610 */     if (this.writeLock != null) {
/* 611 */       this.writeLock.release();
/* 612 */       this.writeLock = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 633 */   public static boolean isLocked(Directory directory) throws IOException { return (directory.makeLock(""write.lock"").isLocked() || directory.makeLock(""commit.lock"").isLocked()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean isLocked(String directory) throws IOException {
/* 645 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory, false);
/* 646 */     boolean result = isLocked((Directory)fSDirectory);
/* 647 */     fSDirectory.close();
/* 648 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void unlock(Directory directory) throws IOException {
/* 659 */     directory.makeLock(""write.lock"").release();
/* 660 */     directory.makeLock(""commit.lock"").release();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) {
/* 671 */     String filename = null;
/* 672 */     boolean extract = false;
/*     */     
/* 674 */     for (int i = 0; i < args.length; i++) {
/* 675 */       if (args[i].equals(""-extract"")) {
/* 676 */         extract = true;
/* 677 */       } else if (filename == null) {
/* 678 */         filename = args[i];
/*     */       } 
/*     */     } 
/*     */     
/* 682 */     if (filename == null) {
/* 683 */       System.out.println(""Usage: org.apache.lucene.index.IndexReader [-extract] <cfsfile>"");
/*     */       
/*     */       return;
/*     */     } 
/* 687 */     Object object = null;
/* 688 */     CompoundFileReader cfr = null;
/*     */     
/*     */     try {
/* 691 */       File file = new File(filename);
/* 692 */       String dirname = file.getAbsoluteFile().getParent();
/* 693 */       filename = file.getName();
/* 694 */       object = FSDirectory.getDirectory(dirname, false);
/* 695 */       cfr = new CompoundFileReader((Directory)object, filename);
/*     */       
/* 697 */       String[] files = cfr.list();
/* 698 */       Arrays.sort((Object[])files);
/*     */       
/* 700 */       for (int i = 0; i < files.length; i++) {
/* 701 */         long len = cfr.fileLength(files[i]);
/*     */         
/* 703 */         if (extract)
/* 704 */         { System.out.println(""extract "" + files[i] + "" with "" + len + "" bytes to local directory..."");
/* 705 */           IndexInput ii = cfr.openInput(files[i]);
/*     */           
/* 707 */           FileOutputStream f = new FileOutputStream(files[i]);
/*     */ 
/*     */           
/* 710 */           byte[] buffer = new byte[1024];
/* 711 */           int chunk = buffer.length;
/* 712 */           while (len > 0L) {
/* 713 */             int bufLen = (int)Math.min(chunk, len);
/* 714 */             ii.readBytes(buffer, 0, bufLen);
/* 715 */             f.write(buffer, 0, bufLen);
/* 716 */             len -= bufLen;
/*     */           } 
/*     */           
/* 719 */           f.close();
/* 720 */           ii.close(); }
/*     */         else
/*     */         
/* 723 */         { System.out.println(files[i] + "": "" + len + "" bytes""); } 
/*     */       } 
/* 725 */     } catch (IOException ioe) {
/* 726 */       ioe.printStackTrace();
/*     */     } finally {
/*     */       
/*     */       try {
/* 730 */         if (object != null)
/* 731 */           object.close(); 
/* 732 */         if (cfr != null) {
/* 733 */           cfr.close();
/*     */         }
/* 735 */       } catch (IOException ioe) {
/* 736 */         ioe.printStackTrace();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public abstract TermFreqVector[] getTermFreqVectors(int paramInt) throws IOException;
/*     */   
/*     */   public abstract TermFreqVector getTermFreqVector(int paramInt, String paramString) throws IOException;
/*     */   
/*     */   public abstract int numDocs();
/*     */   
/*     */   public abstract int maxDoc();
/*     */   
/*     */   public abstract Document document(int paramInt) throws IOException;
/*     */   
/*     */   public abstract boolean isDeleted(int paramInt);
/*     */   
/*     */   public abstract boolean hasDeletions();
/*     */   
/*     */   public abstract byte[] norms(String paramString) throws IOException;
/*     */   
/*     */   public abstract void norms(String paramString, byte[] paramArrayOfbyte, int paramInt) throws IOException;
/*     */   
/*     */   protected abstract void doSetNorm(int paramInt, String paramString, byte paramByte) throws IOException;
/*     */   
/*     */   public abstract TermEnum terms() throws IOException;
/*     */   
/*     */   public abstract TermEnum terms(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract int docFreq(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract TermDocs termDocs() throws IOException;
/*     */   
/*     */   public abstract TermPositions termPositions() throws IOException;
/*     */   
/*     */   protected abstract void doDelete(int paramInt) throws IOException;
/*     */   
/*     */   protected abstract void doUndeleteAll() throws IOException;
/*     */   
/*     */   protected abstract void doCommit() throws IOException;
/*     */   
/*     */   protected abstract void doClose() throws IOException;
/*     */   
/*     */   public abstract Collection getFieldNames(FieldOption paramFieldOption);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\IndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ import org.apache.lucene.store.RAMDirectory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexWriter
/*     */ {
/*     */   public static final long WRITE_LOCK_TIMEOUT = 1000L;
/*  66 */   private long writeLockTimeout = 1000L;
/*     */ 
/*     */ 
/*     */   
/*     */   public static final long COMMIT_LOCK_TIMEOUT = 10000L;
/*     */ 
/*     */   
/*  73 */   private long commitLockTimeout = 10000L;
/*     */ 
/*     */ 
/*     */   
/*     */   public static final String WRITE_LOCK_NAME = ""write.lock"";
/*     */ 
/*     */ 
/*     */   
/*     */   public static final String COMMIT_LOCK_NAME = ""commit.lock"";
/*     */ 
/*     */ 
/*     */   
/*     */   public static final int DEFAULT_MERGE_FACTOR = 10;
/*     */ 
/*     */   
/*     */   public static final int DEFAULT_MAX_BUFFERED_DOCS = 10;
/*     */ 
/*     */   
/*     */   public static final int DEFAULT_MAX_MERGE_DOCS = 2147483647;
/*     */ 
/*     */   
/*     */   public static final int DEFAULT_MAX_FIELD_LENGTH = 10000;
/*     */ 
/*     */   
/*     */   public static final int DEFAULT_TERM_INDEX_INTERVAL = 128;
/*     */ 
/*     */   
/*     */   private Directory directory;
/*     */ 
/*     */   
/*     */   private Analyzer analyzer;
/*     */ 
/*     */   
/* 106 */   private Similarity similarity = Similarity.getDefault();
/*     */   
/* 108 */   private SegmentInfos segmentInfos = new SegmentInfos();
/* 109 */   private final Directory ramDirectory = (Directory)new RAMDirectory();
/*     */   
/*     */   private Lock writeLock;
/*     */   
/* 113 */   private int termIndexInterval = 128;
/*     */   
/*     */   private boolean useCompoundFile = true;
/*     */   
/*     */   private boolean closeDir;
/*     */   
/*     */   private int maxFieldLength;
/*     */   
/*     */   private int mergeFactor;
/*     */   
/*     */   private int minMergeDocs;
/*     */   
/*     */   private int maxMergeDocs;
/*     */   
/*     */   private PrintStream infoStream;
/*     */   
/* 129 */   public boolean getUseCompoundFile() { return this.useCompoundFile; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 137 */   public void setUseCompoundFile(boolean value) { this.useCompoundFile = value; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public void setSimilarity(Similarity similarity) { this.similarity = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 153 */   public Similarity getSimilarity() { return this.similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 178 */   public void setTermIndexInterval(int interval) { this.termIndexInterval = interval; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 185 */   public int getTermIndexInterval() { return this.termIndexInterval; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 204 */   public IndexWriter(String path, Analyzer a, boolean create) throws IOException { this((Directory)FSDirectory.getDirectory(path, create), a, create, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 224 */   public IndexWriter(File path, Analyzer a, boolean create) throws IOException { this((Directory)FSDirectory.getDirectory(path, create), a, create, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 244 */   public IndexWriter(Directory d, Analyzer a, boolean create) throws IOException { this(d, a, create, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 279 */   public void setMaxMergeDocs(int maxMergeDocs) { this.maxMergeDocs = maxMergeDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 286 */   public int getMaxMergeDocs() { return this.maxMergeDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 302 */   public void setMaxFieldLength(int maxFieldLength) { this.maxFieldLength = maxFieldLength; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 309 */   public int getMaxFieldLength() { return this.maxFieldLength; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/* 323 */     if (maxBufferedDocs < 2)
/* 324 */       throw new IllegalArgumentException(""maxBufferedDocs must at least be 2""); 
/* 325 */     this.minMergeDocs = maxBufferedDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 332 */   public int getMaxBufferedDocs() { return this.minMergeDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMergeFactor(int mergeFactor) {
/* 346 */     if (mergeFactor < 2)
/* 347 */       throw new IllegalArgumentException(""mergeFactor cannot be less than 2""); 
/* 348 */     this.mergeFactor = mergeFactor;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 355 */   public int getMergeFactor() { return this.mergeFactor; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 362 */   public void setInfoStream(PrintStream infoStream) { this.infoStream = infoStream; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 369 */   public PrintStream getInfoStream() { return this.infoStream; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 376 */   public void setCommitLockTimeout(long commitLockTimeout) { this.commitLockTimeout = commitLockTimeout; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 383 */   public long getCommitLockTimeout() { return this.commitLockTimeout; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 390 */   public void setWriteLockTimeout(long writeLockTimeout) { this.writeLockTimeout = writeLockTimeout; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 397 */   public long getWriteLockTimeout() { return this.writeLockTimeout; }
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void close() throws IOException {
/* 402 */     flushRamSegments();
/* 403 */     this.ramDirectory.close();
/* 404 */     if (this.writeLock != null) {
/* 405 */       this.writeLock.release();
/* 406 */       this.writeLock = null;
/*     */     } 
/* 408 */     if (this.closeDir) {
/* 409 */       this.directory.close();
/*     */     }
/*     */   }
/*     */   
/*     */   protected void finalize() throws IOException {
/* 414 */     if (this.writeLock != null) {
/* 415 */       this.writeLock.release();
/* 416 */       this.writeLock = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 422 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 427 */   public Analyzer getAnalyzer() { return this.analyzer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized int docCount() {
/* 433 */     int count = 0;
/* 434 */     for (int i = 0; i < this.segmentInfos.size(); i++) {
/* 435 */       SegmentInfo si = this.segmentInfos.info(i);
/* 436 */       count += si.docCount;
/*     */     } 
/* 438 */     return count;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addDocument(Document doc) throws IOException { addDocument(doc, this.analyzer); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir) throws IOException {
/* 454 */     this.maxFieldLength = 10000;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 502 */     this.mergeFactor = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 513 */     this.minMergeDocs = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 524 */     this.maxMergeDocs = Integer.MAX_VALUE;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 529 */     this.infoStream = null; this.closeDir = closeDir; this.directory = d; this.analyzer = a; Lock writeLock = this.directory.makeLock(""write.lock""); if (!writeLock.obtain(this.writeLockTimeout))
/*     */       throw new IOException(""Index locked for write: "" + writeLock);  this.writeLock = writeLock; synchronized (this.directory) { (new Lock.With(this.directory.makeLock(""commit.lock""), this.commitLockTimeout) { private final boolean val$create; private final IndexWriter this$0; public Object doBody() throws IOException { if (create) { IndexWriter.this.segmentInfos.write(IndexWriter.this.directory); }
/*     */             else { IndexWriter.this.segmentInfos.read(IndexWriter.this.directory); }
/*     */              return null; } }).run(); }
/*     */   
/* 534 */   } public synchronized void optimize() throws IOException { flushRamSegments();
/* 535 */     while (this.segmentInfos.size() > 1 || (this.segmentInfos.size() == 1 && (SegmentReader.hasDeletions(this.segmentInfos.info(0)) || (this.segmentInfos.info(0)).dir != this.directory || (this.useCompoundFile && (!SegmentReader.usesCompoundFile(this.segmentInfos.info(0)) || SegmentReader.hasSeparateNorms(this.segmentInfos.info(0))))))) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 542 */       int minSegment = this.segmentInfos.size() - this.mergeFactor;
/* 543 */       mergeSegments((minSegment < 0) ? 0 : minSegment);
/*     */     }  }
/*     */    public void addDocument(Document doc, Analyzer analyzer) throws IOException {
/*     */     DocumentWriter dw = new DocumentWriter(this.ramDirectory, analyzer, this);
/*     */     dw.setInfoStream(this.infoStream);
/*     */     String segmentName = newSegmentName();
/*     */     dw.addDocument(segmentName, doc);
/*     */     synchronized (this) {
/*     */       this.segmentInfos.addElement((E)new SegmentInfo(segmentName, 1, this.ramDirectory));
/*     */       maybeMergeSegments();
/*     */     } 
/*     */   }
/*     */   final int getSegmentsCounter() { return this.segmentInfos.counter; }
/*     */   private final synchronized String newSegmentName() { return ""_"" + Integer.toString(this.segmentInfos.counter++, 36); }
/*     */   public synchronized void addIndexes(Directory[] dirs) throws IOException {
/* 558 */     optimize();
/*     */     
/* 560 */     int start = this.segmentInfos.size();
/*     */     
/* 562 */     for (int i = 0; i < dirs.length; i++) {
/* 563 */       SegmentInfos sis = new SegmentInfos();
/* 564 */       sis.read(dirs[i]);
/* 565 */       for (int j = 0; j < sis.size(); j++) {
/* 566 */         this.segmentInfos.addElement((E)sis.info(j));
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 571 */     while (this.segmentInfos.size() > start + this.mergeFactor) {
/* 572 */       for (int base = start; base < this.segmentInfos.size(); base++) {
/* 573 */         int end = Math.min(this.segmentInfos.size(), base + this.mergeFactor);
/* 574 */         if (end - base > 1) {
/* 575 */           mergeSegments(base, end);
/*     */         }
/*     */       } 
/*     */     } 
/* 579 */     optimize();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void addIndexes(IndexReader[] readers) throws IOException {
/* 589 */     optimize();
/*     */     
/* 591 */     final String mergedName = newSegmentName();
/* 592 */     SegmentMerger merger = new SegmentMerger(this, mergedName);
/*     */     
/* 594 */     Vector segmentsToDelete = new Vector();
/* 595 */     IndexReader sReader = null;
/* 596 */     if (this.segmentInfos.size() == 1) {
/* 597 */       sReader = SegmentReader.get(this.segmentInfos.info(0));
/* 598 */       merger.add(sReader);
/* 599 */       segmentsToDelete.addElement(sReader);
/*     */     } 
/*     */     
/* 602 */     for (int i = 0; i < readers.length; i++) {
/* 603 */       merger.add(readers[i]);
/*     */     }
/* 605 */     int docCount = merger.merge();
/*     */     
/* 607 */     this.segmentInfos.setSize(0);
/* 608 */     this.segmentInfos.addElement((E)new SegmentInfo(mergedName, docCount, this.directory));
/*     */     
/* 610 */     if (sReader != null) {
/* 611 */       sReader.close();
/*     */     }
/* 613 */     synchronized (this.directory) {
/* 614 */       (new Lock.With(this.directory.makeLock(""commit.lock""), this.commitLockTimeout) { private final IndexWriter this$0;
/*     */           public Object doBody() throws IOException {
/* 616 */             IndexWriter.this.segmentInfos.write(IndexWriter.this.directory);
/* 617 */             return null;
/*     */           } }
/*     */         ).run();
/*     */     } 
/*     */     
/* 622 */     deleteSegments(segmentsToDelete);
/*     */     
/* 624 */     if (this.useCompoundFile) {
/* 625 */       Vector filesToDelete = merger.createCompoundFile(mergedName + "".tmp"");
/* 626 */       synchronized (this.directory) {
/* 627 */         (new Lock.With(this.directory.makeLock(""commit.lock""), this.commitLockTimeout) { private final String val$mergedName; private final IndexWriter this$0;
/*     */             
/*     */             public Object doBody() throws IOException {
/* 630 */               IndexWriter.this.directory.renameFile(mergedName + "".tmp"", mergedName + "".cfs"");
/* 631 */               return null;
/*     */             } }
/*     */           ).run();
/*     */       } 
/*     */ 
/*     */       
/* 637 */       deleteFiles(filesToDelete);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void flushRamSegments() throws IOException {
/* 643 */     int minSegment = this.segmentInfos.size() - 1;
/* 644 */     int docCount = 0;
/*     */     
/* 646 */     while (minSegment >= 0 && (this.segmentInfos.info(minSegment)).dir == this.ramDirectory) {
/* 647 */       docCount += (this.segmentInfos.info(minSegment)).docCount;
/* 648 */       minSegment--;
/*     */     } 
/* 650 */     if (minSegment < 0 || docCount + (this.segmentInfos.info(minSegment)).docCount > this.mergeFactor || (this.segmentInfos.info(this.segmentInfos.size() - 1)).dir != this.ramDirectory)
/*     */     {
/*     */       
/* 653 */       minSegment++; } 
/* 654 */     if (minSegment >= this.segmentInfos.size())
/*     */       return; 
/* 656 */     mergeSegments(minSegment);
/*     */   }
/*     */ 
/*     */   
/*     */   private final void maybeMergeSegments() throws IOException {
/* 661 */     long targetMergeDocs = this.minMergeDocs;
/* 662 */     while (targetMergeDocs <= this.maxMergeDocs) {
/*     */       
/* 664 */       int minSegment = this.segmentInfos.size();
/* 665 */       int mergeDocs = 0;
/* 666 */       while (--minSegment >= 0) {
/* 667 */         SegmentInfo si = this.segmentInfos.info(minSegment);
/* 668 */         if (si.docCount >= targetMergeDocs)
/*     */           break; 
/* 670 */         mergeDocs += si.docCount;
/*     */       } 
/*     */       
/* 673 */       if (mergeDocs >= targetMergeDocs) {
/* 674 */         mergeSegments(minSegment + 1);
/*     */ 
/*     */ 
/*     */         
/* 678 */         targetMergeDocs *= this.mergeFactor;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 686 */   private final void mergeSegments(int minSegment) throws IOException { mergeSegments(minSegment, this.segmentInfos.size()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void mergeSegments(int minSegment, int end) throws IOException {
/* 693 */     final String mergedName = newSegmentName();
/* 694 */     if (this.infoStream != null) this.infoStream.print(""merging segments""); 
/* 695 */     SegmentMerger merger = new SegmentMerger(this, mergedName);
/*     */     
/* 697 */     Vector segmentsToDelete = new Vector();
/* 698 */     for (int i = minSegment; i < end; i++) {
/* 699 */       SegmentInfo si = this.segmentInfos.info(i);
/* 700 */       if (this.infoStream != null)
/* 701 */         this.infoStream.print("" "" + si.name + "" ("" + si.docCount + "" docs)""); 
/* 702 */       IndexReader reader = SegmentReader.get(si);
/* 703 */       merger.add(reader);
/* 704 */       if (reader.directory() == this.directory || reader.directory() == this.ramDirectory)
/*     */       {
/* 706 */         segmentsToDelete.addElement(reader);
/*     */       }
/*     */     } 
/* 709 */     int mergedDocCount = merger.merge();
/*     */     
/* 711 */     if (this.infoStream != null) {
/* 712 */       this.infoStream.println("" into "" + mergedName + "" ("" + mergedDocCount + "" docs)"");
/*     */     }
/*     */     
/* 715 */     for (int i = end - 1; i > minSegment; i--)
/* 716 */       this.segmentInfos.remove(i); 
/* 717 */     this.segmentInfos.set(minSegment, (E)new SegmentInfo(mergedName, mergedDocCount, this.directory));
/*     */ 
/*     */ 
/*     */     
/* 721 */     merger.closeReaders();
/*     */     
/* 723 */     synchronized (this.directory) {
/* 724 */       (new Lock.With(this.directory.makeLock(""commit.lock""), this.commitLockTimeout) { private final IndexWriter this$0;
/*     */           public Object doBody() throws IOException {
/* 726 */             IndexWriter.this.segmentInfos.write(IndexWriter.this.directory);
/* 727 */             return null;
/*     */           } }
/*     */         ).run();
/*     */     } 
/*     */     
/* 732 */     deleteSegments(segmentsToDelete);
/*     */     
/* 734 */     if (this.useCompoundFile) {
/* 735 */       Vector filesToDelete = merger.createCompoundFile(mergedName + "".tmp"");
/* 736 */       synchronized (this.directory) {
/* 737 */         (new Lock.With(this.directory.makeLock(""commit.lock""), this.commitLockTimeout) { private final String val$mergedName; private final IndexWriter this$0;
/*     */             
/*     */             public Object doBody() throws IOException {
/* 740 */               IndexWriter.this.directory.renameFile(mergedName + "".tmp"", mergedName + "".cfs"");
/* 741 */               return null;
/*     */             } }
/*     */           ).run();
/*     */       } 
/*     */ 
/*     */       
/* 747 */       deleteFiles(filesToDelete);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void deleteSegments(Vector segments) throws IOException {
/* 759 */     Vector deletable = new Vector();
/*     */     
/* 761 */     deleteFiles(readDeleteableFiles(), deletable);
/*     */     
/* 763 */     for (int i = 0; i < segments.size(); i++) {
/* 764 */       SegmentReader reader = segments.elementAt(i);
/* 765 */       if (reader.directory() == this.directory) {
/* 766 */         deleteFiles(reader.files(), deletable);
/*     */       } else {
/* 768 */         deleteFiles(reader.files(), reader.directory());
/*     */       } 
/*     */     } 
/* 771 */     writeDeleteableFiles(deletable);
/*     */   }
/*     */   
/*     */   private final void deleteFiles(Vector files) throws IOException {
/* 775 */     Vector deletable = new Vector();
/* 776 */     deleteFiles(readDeleteableFiles(), deletable);
/* 777 */     deleteFiles(files, deletable);
/* 778 */     writeDeleteableFiles(deletable);
/*     */   }
/*     */ 
/*     */   
/*     */   private final void deleteFiles(Vector files, Directory directory) throws IOException {
/* 783 */     for (int i = 0; i < files.size(); i++) {
/* 784 */       directory.deleteFile(files.elementAt(i));
/*     */     }
/*     */   }
/*     */   
/*     */   private final void deleteFiles(Vector files, Vector deletable) throws IOException {
/* 789 */     for (int i = 0; i < files.size(); i++) {
/* 790 */       String file = files.elementAt(i);
/*     */       try {
/* 792 */         this.directory.deleteFile(file);
/* 793 */       } catch (IOException e) {
/* 794 */         if (this.directory.fileExists(file)) {
/* 795 */           if (this.infoStream != null)
/* 796 */             this.infoStream.println(e.toString() + ""; Will re-try later.""); 
/* 797 */           deletable.addElement(file);
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private final Vector readDeleteableFiles() throws IOException {
/* 804 */     Vector result = new Vector();
/* 805 */     if (!this.directory.fileExists(""deletable"")) {
/* 806 */       return result;
/*     */     }
/* 808 */     IndexInput input = this.directory.openInput(""deletable"");
/*     */     try {
/* 810 */       for (int i = input.readInt(); i > 0; i--)
/* 811 */         result.addElement(input.readString()); 
/*     */     } finally {
/* 813 */       input.close();
/*     */     } 
/* 815 */     return result;
/*     */   }
/*     */   
/*     */   private final void writeDeleteableFiles(Vector files) throws IOException {
/* 819 */     IndexOutput output = this.directory.createOutput(""deleteable.new"");
/*     */     try {
/* 821 */       output.writeInt(files.size());
/* 822 */       for (int i = 0; i < files.size(); i++)
/* 823 */         output.writeString(files.elementAt(i)); 
/*     */     } finally {
/* 825 */       output.close();
/*     */     } 
/* 827 */     this.directory.renameFile(""deleteable.new"", ""deletable"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\IndexWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultipleTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultipleTermPositions
/*     */   implements TermPositions
/*     */ {
/*     */   private int _doc;
/*     */   private int _freq;
/*     */   private TermPositionsQueue _termPositionsQueue;
/*     */   private IntQueue _posList;
/*     */   
/*     */   private static final class TermPositionsQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     TermPositionsQueue(List termPositions) throws IOException {
/*  37 */       initialize(termPositions.size());
/*     */       
/*  39 */       Iterator i = termPositions.iterator();
/*  40 */       while (i.hasNext()) {
/*  41 */         TermPositions tp = i.next();
/*  42 */         if (tp.next()) {
/*  43 */           put(tp);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/*  48 */     final TermPositions peek() { return (TermPositions)top(); }
/*     */ 
/*     */ 
/*     */     
/*  52 */     public final boolean lessThan(Object a, Object b) { return (((TermPositions)a).doc() < ((TermPositions)b).doc()); }
/*     */   }
/*     */   
/*     */   private static final class IntQueue
/*     */   {
/*  57 */     private int _arraySize = 16;
/*  58 */     private int _index = 0;
/*  59 */     private int _lastIndex = 0;
/*  60 */     private int[] _array = new int[this._arraySize];
/*     */     
/*     */     final void add(int i) {
/*  63 */       if (this._lastIndex == this._arraySize) {
/*  64 */         growArray();
/*     */       }
/*  66 */       this._array[this._lastIndex++] = i;
/*     */     }
/*     */ 
/*     */     
/*  70 */     final int next() { return this._array[this._index++]; }
/*     */ 
/*     */ 
/*     */     
/*  74 */     final void sort() { Arrays.sort(this._array, this._index, this._lastIndex); }
/*     */ 
/*     */     
/*     */     final void clear() {
/*  78 */       this._index = 0;
/*  79 */       this._lastIndex = 0;
/*     */     }
/*     */ 
/*     */     
/*  83 */     final int size() { return this._lastIndex - this._index; }
/*     */ 
/*     */     
/*     */     private void growArray() {
/*  87 */       int[] newArray = new int[this._arraySize * 2];
/*  88 */       System.arraycopy(this._array, 0, newArray, 0, this._arraySize);
/*  89 */       this._array = newArray;
/*  90 */       this._arraySize *= 2;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private IntQueue() {}
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultipleTermPositions(IndexReader indexReader, Term[] terms) throws IOException {
/* 105 */     List termPositions = new LinkedList();
/*     */     
/* 107 */     for (int i = 0; i < terms.length; i++) {
/* 108 */       termPositions.add(indexReader.termPositions(terms[i]));
/*     */     }
/* 110 */     this._termPositionsQueue = new TermPositionsQueue(termPositions);
/* 111 */     this._posList = new IntQueue();
/*     */   }
/*     */   
/*     */   public final boolean next() throws IOException {
/* 115 */     if (this._termPositionsQueue.size() == 0) {
/* 116 */       return false;
/*     */     }
/* 118 */     this._posList.clear();
/* 119 */     this._doc = this._termPositionsQueue.peek().doc();
/*     */ 
/*     */     
/*     */     do {
/* 123 */       TermPositions tp = this._termPositionsQueue.peek();
/*     */       
/* 125 */       for (int i = 0; i < tp.freq(); i++) {
/* 126 */         this._posList.add(tp.nextPosition());
/*     */       }
/* 128 */       if (tp.next()) {
/* 129 */         this._termPositionsQueue.adjustTop();
/*     */       } else {
/* 131 */         this._termPositionsQueue.pop();
/* 132 */         tp.close();
/*     */       } 
/* 134 */     } while (this._termPositionsQueue.size() > 0 && this._termPositionsQueue.peek().doc() == this._doc);
/*     */     
/* 136 */     this._posList.sort();
/* 137 */     this._freq = this._posList.size();
/*     */     
/* 139 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 143 */   public final int nextPosition() { return this._posList.next(); }
/*     */ 
/*     */   
/*     */   public final boolean skipTo(int target) throws IOException {
/* 147 */     while (this._termPositionsQueue.peek() != null && target > this._termPositionsQueue.peek().doc()) {
/* 148 */       TermPositions tp = (TermPositions)this._termPositionsQueue.pop();
/* 149 */       if (tp.skipTo(target)) {
/* 150 */         this._termPositionsQueue.put(tp); continue;
/*     */       } 
/* 152 */       tp.close();
/*     */     } 
/* 154 */     return next();
/*     */   }
/*     */ 
/*     */   
/* 158 */   public final int doc() { return this._doc; }
/*     */ 
/*     */ 
/*     */   
/* 162 */   public final int freq() { return this._freq; }
/*     */ 
/*     */   
/*     */   public final void close() throws IOException {
/* 166 */     while (this._termPositionsQueue.size() > 0) {
/* 167 */       ((TermPositions)this._termPositionsQueue.pop()).close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 175 */   public void seek(Term arg0) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public void seek(TermEnum termEnum) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 191 */   public int read(int[] arg0, int[] arg1) throws IOException { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\MultipleTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashSet;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiReader
/*     */   extends IndexReader
/*     */ {
/*     */   private IndexReader[] subReaders;
/*     */   private int[] starts;
/*  33 */   private Hashtable normsCache = new Hashtable();
/*  34 */   private int maxDoc = 0;
/*  35 */   private int numDocs = -1;
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean hasDeletions = false;
/*     */ 
/*     */   
/*     */   private byte[] ones;
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiReader(IndexReader[] subReaders) throws IOException {
/*  47 */     super((subReaders.length == 0) ? null : subReaders[0].directory());
/*  48 */     initialize(subReaders);
/*     */   }
/*     */ 
/*     */   
/*     */   MultiReader(Directory directory, SegmentInfos sis, boolean closeDirectory, IndexReader[] subReaders) {
/*  53 */     super(directory, sis, closeDirectory);
/*  54 */     initialize(subReaders);
/*     */   }
/*     */   
/*     */   private void initialize(IndexReader[] subReaders) {
/*  58 */     this.subReaders = subReaders;
/*  59 */     this.starts = new int[subReaders.length + 1];
/*  60 */     for (int i = 0; i < subReaders.length; i++) {
/*  61 */       this.starts[i] = this.maxDoc;
/*  62 */       this.maxDoc += subReaders[i].maxDoc();
/*     */       
/*  64 */       if (subReaders[i].hasDeletions())
/*  65 */         this.hasDeletions = true; 
/*     */     } 
/*  67 */     this.starts[subReaders.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/*  78 */     int i = readerIndex(n);
/*  79 */     return this.subReaders[i].getTermFreqVectors(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/*  84 */     int i = readerIndex(n);
/*  85 */     return this.subReaders[i].getTermFreqVector(n - this.starts[i], field);
/*     */   }
/*     */   
/*     */   public synchronized int numDocs() {
/*  89 */     if (this.numDocs == -1) {
/*  90 */       int n = 0;
/*  91 */       for (int i = 0; i < this.subReaders.length; i++)
/*  92 */         n += this.subReaders[i].numDocs(); 
/*  93 */       this.numDocs = n;
/*     */     } 
/*  95 */     return this.numDocs;
/*     */   }
/*     */ 
/*     */   
/*  99 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */   
/*     */   public Document document(int n) throws IOException {
/* 103 */     int i = readerIndex(n);
/* 104 */     return this.subReaders[i].document(n - this.starts[i]);
/*     */   }
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 108 */     int i = readerIndex(n);
/* 109 */     return this.subReaders[i].isDeleted(n - this.starts[i]);
/*     */   }
/*     */   
/* 112 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */   
/*     */   protected void doDelete(int n) throws IOException {
/* 115 */     this.numDocs = -1;
/* 116 */     int i = readerIndex(n);
/* 117 */     this.subReaders[i].deleteDocument(n - this.starts[i]);
/* 118 */     this.hasDeletions = true;
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() throws IOException {
/* 122 */     for (int i = 0; i < this.subReaders.length; i++)
/* 123 */       this.subReaders[i].undeleteAll(); 
/* 124 */     this.hasDeletions = false;
/* 125 */     this.numDocs = -1;
/*     */   }
/*     */   
/*     */   private int readerIndex(int n) {
/* 129 */     int lo = 0;
/* 130 */     int hi = this.subReaders.length - 1;
/*     */     
/* 132 */     while (hi >= lo) {
/* 133 */       int mid = lo + hi >> 1;
/* 134 */       int midValue = this.starts[mid];
/* 135 */       if (n < midValue) {
/* 136 */         hi = mid - 1; continue;
/* 137 */       }  if (n > midValue) {
/* 138 */         lo = mid + 1; continue;
/*     */       } 
/* 140 */       while (mid + 1 < this.subReaders.length && this.starts[mid + 1] == midValue) {
/* 141 */         mid++;
/*     */       }
/* 143 */       return mid;
/*     */     } 
/*     */     
/* 146 */     return hi;
/*     */   }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 150 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 151 */       if (this.subReaders[i].hasNorms(field)) return true; 
/*     */     } 
/* 153 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 158 */     if (this.ones == null) this.ones = SegmentReader.createFakeNorms(maxDoc()); 
/* 159 */     return this.ones;
/*     */   }
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 163 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 164 */     if (bytes != null)
/* 165 */       return bytes; 
/* 166 */     if (!hasNorms(field)) {
/* 167 */       return fakeNorms();
/*     */     }
/* 169 */     bytes = new byte[maxDoc()];
/* 170 */     for (int i = 0; i < this.subReaders.length; i++)
/* 171 */       this.subReaders[i].norms(field, bytes, this.starts[i]); 
/* 172 */     this.normsCache.put(field, bytes);
/* 173 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] result, int offset) throws IOException {
/* 178 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 179 */     if (bytes == null && !hasNorms(field)) bytes = fakeNorms(); 
/* 180 */     if (bytes != null) {
/* 181 */       System.arraycopy(bytes, 0, result, offset, maxDoc());
/*     */     }
/* 183 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 184 */       this.subReaders[i].norms(field, result, offset + this.starts[i]);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws IOException {
/* 189 */     this.normsCache.remove(field);
/* 190 */     int i = readerIndex(n);
/* 191 */     this.subReaders[i].setNorm(n - this.starts[i], field, value);
/*     */   }
/*     */ 
/*     */   
/* 195 */   public TermEnum terms() throws IOException { return new MultiTermEnum(this.subReaders, this.starts, null); }
/*     */ 
/*     */ 
/*     */   
/* 199 */   public TermEnum terms(Term term) throws IOException { return new MultiTermEnum(this.subReaders, this.starts, term); }
/*     */ 
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 203 */     int total = 0;
/* 204 */     for (int i = 0; i < this.subReaders.length; i++)
/* 205 */       total += this.subReaders[i].docFreq(t); 
/* 206 */     return total;
/*     */   }
/*     */ 
/*     */   
/* 210 */   public TermDocs termDocs() throws IOException { return new MultiTermDocs(this.subReaders, this.starts); }
/*     */ 
/*     */ 
/*     */   
/* 214 */   public TermPositions termPositions() throws IOException { return new MultiTermPositions(this.subReaders, this.starts); }
/*     */ 
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 218 */     for (int i = 0; i < this.subReaders.length; i++)
/* 219 */       this.subReaders[i].commit(); 
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 223 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 224 */       this.subReaders[i].close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 232 */     Set fieldSet = new HashSet();
/* 233 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 234 */       IndexReader reader = this.subReaders[i];
/* 235 */       Collection names = reader.getFieldNames(fieldNames);
/* 236 */       fieldSet.addAll(names);
/*     */     } 
/* 238 */     return fieldSet;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\MultiReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermDocs,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermDocs
/*     */   implements TermDocs
/*     */ {
/*     */   protected IndexReader[] readers;
/*     */   protected int[] starts;
/*     */   protected Term term;
/* 312 */   protected int base = 0;
/* 313 */   protected int pointer = 0;
/*     */   
/*     */   private TermDocs[] readerTermDocs;
/*     */   protected TermDocs current;
/*     */   
/*     */   public MultiTermDocs(IndexReader[] r, int[] s) {
/* 319 */     this.readers = r;
/* 320 */     this.starts = s;
/*     */     
/* 322 */     this.readerTermDocs = new TermDocs[r.length];
/*     */   }
/*     */ 
/*     */   
/* 326 */   public int doc() { return this.base + this.current.doc(); }
/*     */ 
/*     */   
/* 329 */   public int freq() { return this.current.freq(); }
/*     */ 
/*     */   
/*     */   public void seek(Term term) {
/* 333 */     this.term = term;
/* 334 */     this.base = 0;
/* 335 */     this.pointer = 0;
/* 336 */     this.current = null;
/*     */   }
/*     */ 
/*     */   
/* 340 */   public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 344 */     if (this.current != null && this.current.next())
/* 345 */       return true; 
/* 346 */     if (this.pointer < this.readers.length) {
/* 347 */       this.base = this.starts[this.pointer];
/* 348 */       this.current = termDocs(this.pointer++);
/* 349 */       return next();
/*     */     } 
/* 351 */     return false;
/*     */   }
/*     */   
/*     */   public int read(int[] docs, int[] freqs) throws IOException {
/*     */     int end;
/*     */     while (true) {
/* 357 */       while (this.current == null) {
/* 358 */         if (this.pointer < this.readers.length) {
/* 359 */           this.base = this.starts[this.pointer];
/* 360 */           this.current = termDocs(this.pointer++); continue;
/*     */         } 
/* 362 */         return 0;
/*     */       } 
/*     */       
/* 365 */       end = this.current.read(docs, freqs);
/* 366 */       if (end == 0) {
/* 367 */         this.current = null; continue;
/*     */       }  break;
/* 369 */     }  int b = this.base;
/* 370 */     for (int i = 0; i < end; i++)
/* 371 */       docs[i] = docs[i] + b; 
/* 372 */     return end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*     */     do {
/* 380 */       if (!next())
/* 381 */         return false; 
/* 382 */     } while (target > doc());
/* 383 */     return true;
/*     */   }
/*     */   
/*     */   private TermDocs termDocs(int i) throws IOException {
/* 387 */     if (this.term == null)
/* 388 */       return null; 
/* 389 */     TermDocs result = this.readerTermDocs[i];
/* 390 */     if (result == null)
/* 391 */       result = this.readerTermDocs[i] = termDocs(this.readers[i]); 
/* 392 */     result.seek(this.term);
/* 393 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 398 */   protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termDocs(); }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 402 */     for (int i = 0; i < this.readerTermDocs.length; i++) {
/* 403 */       if (this.readerTermDocs[i] != null)
/* 404 */         this.readerTermDocs[i].close(); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\MultiTermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermEnum,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermEnum
/*     */   extends TermEnum
/*     */ {
/*     */   private SegmentMergeQueue queue;
/*     */   private Term term;
/*     */   private int docFreq;
/*     */   
/*     */   public MultiTermEnum(IndexReader[] readers, int[] starts, Term t) throws IOException {
/* 250 */     this.queue = new SegmentMergeQueue(readers.length);
/* 251 */     for (int i = 0; i < readers.length; i++) {
/* 252 */       TermEnum termEnum; IndexReader reader = readers[i];
/*     */ 
/*     */       
/* 255 */       if (t != null) {
/* 256 */         termEnum = reader.terms(t);
/*     */       } else {
/* 258 */         termEnum = reader.terms();
/*     */       } 
/* 260 */       SegmentMergeInfo smi = new SegmentMergeInfo(starts[i], termEnum, reader);
/* 261 */       if ((t == null) ? smi.next() : (termEnum.term() != null)) {
/* 262 */         this.queue.put(smi);
/*     */       } else {
/* 264 */         smi.close();
/*     */       } 
/*     */     } 
/* 267 */     if (t != null && this.queue.size() > 0) {
/* 268 */       next();
/*     */     }
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 273 */     SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top();
/* 274 */     if (top == null) {
/* 275 */       this.term = null;
/* 276 */       return false;
/*     */     } 
/*     */     
/* 279 */     this.term = top.term;
/* 280 */     this.docFreq = 0;
/*     */     
/* 282 */     while (top != null && this.term.compareTo(top.term) == 0) {
/* 283 */       this.queue.pop();
/* 284 */       this.docFreq += top.termEnum.docFreq();
/* 285 */       if (top.next()) {
/* 286 */         this.queue.put(top);
/*     */       } else {
/* 288 */         top.close();
/* 289 */       }  top = (SegmentMergeInfo)this.queue.top();
/*     */     } 
/* 291 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 295 */   public Term term() { return this.term; }
/*     */ 
/*     */ 
/*     */   
/* 299 */   public int docFreq() { return this.docFreq; }
/*     */ 
/*     */ 
/*     */   
/* 303 */   public void close() throws IOException { this.queue.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\MultiTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermPositions
/*     */   extends MultiTermDocs
/*     */   implements TermPositions
/*     */ {
/* 411 */   public MultiTermPositions(IndexReader[] r, int[] s) { super(r, s); }
/*     */ 
/*     */ 
/*     */   
/* 415 */   protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termPositions(); }
/*     */ 
/*     */ 
/*     */   
/* 419 */   public int nextPosition() throws IOException { return ((TermPositions)this.current).nextPosition(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\MultiTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ParallelReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import java.util.SortedMap;
/*     */ import java.util.TreeMap;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelReader
/*     */   extends IndexReader
/*     */ {
/*  52 */   private List readers = new ArrayList();
/*  53 */   private SortedMap fieldToReader = new TreeMap();
/*  54 */   private List storedFieldReaders = new ArrayList();
/*     */   
/*     */   private int maxDoc;
/*     */   
/*     */   private int numDocs;
/*     */   private boolean hasDeletions;
/*     */   
/*  61 */   public ParallelReader() throws IOException { super(null); }
/*     */ 
/*     */ 
/*     */   
/*  65 */   public void add(IndexReader reader) throws IOException { add(reader, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(IndexReader reader, boolean ignoreStoredFields) throws IOException {
/*  80 */     if (this.readers.size() == 0) {
/*  81 */       this.maxDoc = reader.maxDoc();
/*  82 */       this.numDocs = reader.numDocs();
/*  83 */       this.hasDeletions = reader.hasDeletions();
/*     */     } 
/*     */     
/*  86 */     if (reader.maxDoc() != this.maxDoc) {
/*  87 */       throw new IllegalArgumentException(""All readers must have same maxDoc: "" + this.maxDoc + ""!="" + reader.maxDoc());
/*     */     }
/*  89 */     if (reader.numDocs() != this.numDocs) {
/*  90 */       throw new IllegalArgumentException(""All readers must have same numDocs: "" + this.numDocs + ""!="" + reader.numDocs());
/*     */     }
/*     */     
/*  93 */     Iterator i = reader.getFieldNames(IndexReader.FieldOption.ALL).iterator();
/*  94 */     while (i.hasNext()) {
/*  95 */       String field = i.next();
/*  96 */       if (this.fieldToReader.get(field) == null) {
/*  97 */         this.fieldToReader.put(field, reader);
/*     */       }
/*     */     } 
/* 100 */     if (!ignoreStoredFields)
/* 101 */       this.storedFieldReaders.add(reader); 
/* 102 */     this.readers.add(reader);
/*     */   }
/*     */   
/* 105 */   public int numDocs() { return this.numDocs; }
/*     */   
/* 107 */   public int maxDoc() { return this.maxDoc; }
/*     */   
/* 109 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 113 */     if (this.readers.size() > 0)
/* 114 */       return ((IndexReader)this.readers.get(0)).isDeleted(n); 
/* 115 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws IOException {
/* 120 */     for (int i = 0; i < this.readers.size(); i++) {
/* 121 */       ((IndexReader)this.readers.get(i)).deleteDocument(n);
/*     */     }
/* 123 */     this.hasDeletions = true;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doUndeleteAll() throws IOException {
/* 128 */     for (int i = 0; i < this.readers.size(); i++) {
/* 129 */       ((IndexReader)this.readers.get(i)).undeleteAll();
/*     */     }
/* 131 */     this.hasDeletions = false;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document document(int n) throws IOException {
/* 136 */     Document result = new Document();
/* 137 */     for (int i = 0; i < this.storedFieldReaders.size(); i++) {
/* 138 */       IndexReader reader = this.storedFieldReaders.get(i);
/* 139 */       Enumeration fields = reader.document(n).fields();
/* 140 */       while (fields.hasMoreElements()) {
/* 141 */         result.add(fields.nextElement());
/*     */       }
/*     */     } 
/* 144 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/* 149 */     ArrayList results = new ArrayList();
/* 150 */     Iterator i = this.fieldToReader.entrySet().iterator();
/* 151 */     while (i.hasNext()) {
/* 152 */       Map.Entry e = i.next();
/* 153 */       String field = (String)e.getKey();
/* 154 */       IndexReader reader = (IndexReader)e.getValue();
/* 155 */       TermFreqVector vector = reader.getTermFreqVector(n, field);
/* 156 */       if (vector != null)
/* 157 */         results.add(vector); 
/*     */     } 
/* 159 */     return results.toArray(new TermFreqVector[results.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/* 165 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 166 */     return (reader == null) ? null : reader.getTermFreqVector(n, field);
/*     */   }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 170 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 171 */     return (reader == null) ? false : reader.hasNorms(field);
/*     */   }
/*     */   
/*     */   public byte[] norms(String field) throws IOException {
/* 175 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 176 */     return (reader == null) ? null : reader.norms(field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void norms(String field, byte[] result, int offset) throws IOException {
/* 181 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 182 */     if (reader != null) {
/* 183 */       reader.norms(field, result, offset);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws IOException {
/* 188 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 189 */     if (reader != null) {
/* 190 */       reader.doSetNorm(n, field, value);
/*     */     }
/*     */   }
/*     */   
/* 194 */   public TermEnum terms() throws IOException { return new ParallelTermEnum(); }
/*     */ 
/*     */ 
/*     */   
/* 198 */   public TermEnum terms(Term term) throws IOException { return new ParallelTermEnum(term); }
/*     */ 
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 202 */     IndexReader reader = (IndexReader)this.fieldToReader.get(term.field());
/* 203 */     return (reader == null) ? 0 : reader.docFreq(term);
/*     */   }
/*     */ 
/*     */   
/* 207 */   public TermDocs termDocs(Term term) throws IOException { return new ParallelTermDocs(term); }
/*     */ 
/*     */ 
/*     */   
/* 211 */   public TermDocs termDocs() throws IOException { return new ParallelTermDocs(); }
/*     */ 
/*     */ 
/*     */   
/* 215 */   public TermPositions termPositions(Term term) throws IOException { return new ParallelTermPositions(term); }
/*     */ 
/*     */ 
/*     */   
/* 219 */   public TermPositions termPositions() throws IOException { return new ParallelTermPositions(); }
/*     */ 
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 223 */     for (int i = 0; i < this.readers.size(); i++)
/* 224 */       ((IndexReader)this.readers.get(i)).commit(); 
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 228 */     for (int i = 0; i < this.readers.size(); i++) {
/* 229 */       ((IndexReader)this.readers.get(i)).close();
/*     */     }
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 234 */     Set fieldSet = new HashSet();
/* 235 */     for (int i = 0; i < this.readers.size(); i++) {
/* 236 */       IndexReader reader = this.readers.get(i);
/* 237 */       Collection names = reader.getFieldNames(fieldNames);
/* 238 */       fieldSet.addAll(names);
/*     */     } 
/* 240 */     return fieldSet;
/*     */   }
/*     */   
/*     */   private class ParallelTermEnum
/*     */     extends TermEnum {
/*     */     private String field;
/*     */     
/*     */     public ParallelTermEnum() throws IOException {
/* 248 */       this.field = (String)ParallelReader.this.fieldToReader.firstKey();
/* 249 */       if (this.field != null)
/* 250 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms(); 
/*     */     }
/*     */     private TermEnum termEnum; private final ParallelReader this$0;
/*     */     public ParallelTermEnum(Term term) throws IOException {
/* 254 */       this.field = term.field();
/* 255 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(this.field);
/* 256 */       if (reader != null)
/* 257 */         this.termEnum = reader.terms(term); 
/*     */     }
/*     */     
/*     */     public boolean next() throws IOException {
/* 261 */       if (this.termEnum == null) {
/* 262 */         return false;
/*     */       }
/* 264 */       boolean next = this.termEnum.next();
/*     */ 
/*     */       
/* 267 */       if (next && this.termEnum.term().field() == this.field) {
/* 268 */         return true;
/*     */       }
/* 270 */       this.termEnum.close();
/*     */ 
/*     */       
/* 273 */       this.field = (String)ParallelReader.this.fieldToReader.tailMap(this.field).firstKey();
/* 274 */       if (this.field != null) {
/* 275 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms();
/* 276 */         return true;
/*     */       } 
/*     */       
/* 279 */       return false;
/*     */     }
/*     */ 
/*     */     
/*     */     public Term term() {
/* 284 */       if (this.termEnum == null) {
/* 285 */         return null;
/*     */       }
/* 287 */       return this.termEnum.term();
/*     */     }
/*     */     
/*     */     public int docFreq() {
/* 291 */       if (this.termEnum == null) {
/* 292 */         return 0;
/*     */       }
/* 294 */       return this.termEnum.docFreq();
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 298 */       if (this.termEnum != null)
/* 299 */         this.termEnum.close(); 
/*     */     }
/*     */   }
/*     */   
/*     */   private class ParallelTermDocs implements TermDocs {
/*     */     protected TermDocs termDocs;
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermDocs() {}
/*     */     
/* 309 */     public ParallelTermDocs(Term term) throws IOException { seek(term); }
/*     */     
/* 311 */     public int doc() { return this.termDocs.doc(); }
/* 312 */     public int freq() { return this.termDocs.freq(); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 315 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 316 */       this.termDocs = (reader != null) ? reader.termDocs(term) : null;
/*     */     }
/*     */ 
/*     */     
/* 320 */     public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/* 324 */       if (this.termDocs == null) {
/* 325 */         return false;
/*     */       }
/* 327 */       return this.termDocs.next();
/*     */     }
/*     */     
/*     */     public int read(int[] docs, int[] freqs) throws IOException {
/* 331 */       if (this.termDocs == null) {
/* 332 */         return 0;
/*     */       }
/* 334 */       return this.termDocs.read(docs, freqs);
/*     */     }
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 338 */       if (this.termDocs == null) {
/* 339 */         return false;
/*     */       }
/* 341 */       return this.termDocs.skipTo(target);
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 345 */       if (this.termDocs != null)
/* 346 */         this.termDocs.close(); 
/*     */     }
/*     */   }
/*     */   
/*     */   private class ParallelTermPositions extends ParallelTermDocs implements TermPositions {
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermPositions() {}
/*     */     
/* 355 */     public ParallelTermPositions(Term term) throws IOException { seek(term); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 358 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 359 */       this.termDocs = (reader != null) ? reader.termPositions(term) : null;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 364 */     public int nextPosition() throws IOException { return ((TermPositions)this.termDocs).nextPosition(); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\ParallelReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Posting,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class Posting
/*     */ {
/*     */   Term term;
/*     */   int freq;
/*     */   int[] positions;
/*     */   TermVectorOffsetInfo[] offsets;
/*     */   
/*     */   Posting(Term t, int position, TermVectorOffsetInfo offset) {
/* 402 */     this.term = t;
/* 403 */     this.freq = 1;
/* 404 */     this.positions = new int[1];
/* 405 */     this.positions[0] = position;
/* 406 */     if (offset != null) {
/* 407 */       this.offsets = new TermVectorOffsetInfo[1];
/* 408 */       this.offsets[0] = offset;
/*     */     } else {
/*     */       
/* 411 */       this.offsets = null;
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\Posting.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import org.apache.lucene.store.Directory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentInfo
/*    */ {
/*    */   public String name;
/*    */   public int docCount;
/*    */   public Directory dir;
/*    */   
/*    */   public SegmentInfo(String name, int docCount, Directory dir) {
/* 27 */     this.name = name;
/* 28 */     this.docCount = docCount;
/* 29 */     this.dir = dir;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentInfos
/*     */   extends Vector
/*     */ {
/*     */   public static final int FORMAT = -1;
/*  32 */   public int counter = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  37 */   private long version = System.currentTimeMillis();
/*     */ 
/*     */   
/*  40 */   public final SegmentInfo info(int i) { return (SegmentInfo)elementAt(i); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(Directory directory) throws IOException {
/*  45 */     IndexInput input = directory.openInput(""segments"");
/*     */     try {
/*  47 */       int format = input.readInt();
/*  48 */       if (format < 0) {
/*     */         
/*  50 */         if (format < -1)
/*  51 */           throw new IOException(""Unknown format version: "" + format); 
/*  52 */         this.version = input.readLong();
/*  53 */         this.counter = input.readInt();
/*     */       } else {
/*     */         
/*  56 */         this.counter = format;
/*     */       } 
/*     */       
/*  59 */       for (int i = input.readInt(); i > 0; i--) {
/*  60 */         SegmentInfo si = new SegmentInfo(input.readString(), input.readInt(), directory);
/*     */         
/*  62 */         addElement((E)si);
/*     */       } 
/*     */       
/*  65 */       if (format >= 0) {
/*  66 */         if (input.getFilePointer() >= input.length()) {
/*  67 */           this.version = System.currentTimeMillis();
/*     */         } else {
/*  69 */           this.version = input.readLong();
/*     */         } 
/*     */       }
/*     */     } finally {
/*  73 */       input.close();
/*     */     } 
/*     */   }
/*     */   
/*     */   public final void write(Directory directory) throws IOException {
/*  78 */     IndexOutput output = directory.createOutput(""segments.new"");
/*     */     try {
/*  80 */       output.writeInt(-1);
/*  81 */       output.writeLong(++this.version);
/*  82 */       output.writeInt(this.counter);
/*  83 */       output.writeInt(size());
/*  84 */       for (int i = 0; i < size(); i++) {
/*  85 */         SegmentInfo si = info(i);
/*  86 */         output.writeString(si.name);
/*  87 */         output.writeInt(si.docCount);
/*     */       } 
/*     */     } finally {
/*     */       
/*  91 */       output.close();
/*     */     } 
/*     */ 
/*     */     
/*  95 */     directory.renameFile(""segments.new"", ""segments"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 102 */   public long getVersion() { return this.version; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long readCurrentVersion(Directory directory) throws IOException {
/* 111 */     IndexInput input = directory.openInput(""segments"");
/* 112 */     int format = 0;
/* 113 */     long version = 0L;
/*     */     try {
/* 115 */       format = input.readInt();
/* 116 */       if (format < 0) {
/* 117 */         if (format < -1)
/* 118 */           throw new IOException(""Unknown format version: "" + format); 
/* 119 */         version = input.readLong();
/*     */       } 
/*     */     } finally {
/*     */       
/* 123 */       input.close();
/*     */     } 
/*     */     
/* 126 */     if (format < 0) {
/* 127 */       return version;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 132 */     SegmentInfos sis = new SegmentInfos();
/* 133 */     sis.read(directory);
/* 134 */     return sis.getVersion();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeInfo
/*    */ {
/*    */   Term term;
/*    */   int base;
/*    */   TermEnum termEnum;
/*    */   IndexReader reader;
/*    */   private TermPositions postings;
/*    */   private int[] docMap;
/*    */   
/*    */   SegmentMergeInfo(int b, TermEnum te, IndexReader r) throws IOException {
/* 31 */     this.base = b;
/* 32 */     this.reader = r;
/* 33 */     this.termEnum = te;
/* 34 */     this.term = te.term();
/*    */   }
/*    */ 
/*    */   
/*    */   int[] getDocMap() {
/* 39 */     if (this.docMap == null)
/*    */     {
/* 41 */       if (this.reader.hasDeletions()) {
/* 42 */         int maxDoc = this.reader.maxDoc();
/* 43 */         this.docMap = new int[maxDoc];
/* 44 */         int j = 0;
/* 45 */         for (int i = 0; i < maxDoc; i++) {
/* 46 */           if (this.reader.isDeleted(i)) {
/* 47 */             this.docMap[i] = -1;
/*    */           } else {
/* 49 */             this.docMap[i] = j++;
/*    */           } 
/*    */         } 
/*    */       }  } 
/* 53 */     return this.docMap;
/*    */   }
/*    */   
/*    */   TermPositions getPositions() throws IOException {
/* 57 */     if (this.postings == null) {
/* 58 */       this.postings = this.reader.termPositions();
/*    */     }
/* 60 */     return this.postings;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 64 */     if (this.termEnum.next()) {
/* 65 */       this.term = this.termEnum.term();
/* 66 */       return true;
/*    */     } 
/* 68 */     this.term = null;
/* 69 */     return false;
/*    */   }
/*    */ 
/*    */   
/*    */   final void close() throws IOException {
/* 74 */     this.termEnum.close();
/* 75 */     if (this.postings != null)
/* 76 */       this.postings.close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentMergeInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeQueue,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeQueue
/*    */   extends PriorityQueue
/*    */ {
/* 24 */   SegmentMergeQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 28 */     SegmentMergeInfo stiA = (SegmentMergeInfo)a;
/* 29 */     SegmentMergeInfo stiB = (SegmentMergeInfo)b;
/* 30 */     int comparison = stiA.term.compareTo(stiB.term);
/* 31 */     if (comparison == 0) {
/* 32 */       return (stiA.base < stiB.base);
/*    */     }
/* 34 */     return (comparison < 0);
/*    */   }
/*    */   
/*    */   final void close() throws IOException {
/* 38 */     while (top() != null)
/* 39 */       ((SegmentMergeInfo)pop()).close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentMergeQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMerger,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentMerger
/*     */ {
/*     */   private Directory directory;
/*     */   private String segment;
/*  42 */   private int termIndexInterval = 128;
/*     */   
/*  44 */   private Vector readers = new Vector();
/*     */   
/*     */   private FieldInfos fieldInfos;
/*     */   
/*     */   private IndexOutput freqOutput;
/*     */   
/*     */   private IndexOutput proxOutput;
/*     */   
/*     */   private TermInfosWriter termInfosWriter;
/*     */   
/*     */   private int skipInterval;
/*     */   
/*     */   private SegmentMergeQueue queue;
/*     */   
/*     */   private final TermInfo termInfo;
/*     */   
/*     */   private RAMOutputStream skipBuffer;
/*     */   
/*     */   private int lastSkipDoc;
/*     */   
/*     */   private long lastSkipFreqPointer;
/*     */   
/*     */   private long lastSkipProxPointer;
/*     */   
/*  68 */   final void add(IndexReader reader) { this.readers.addElement(reader); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   final IndexReader segmentReader(int i) { return this.readers.elementAt(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final int merge() throws IOException {
/*  88 */     int value = mergeFields();
/*  89 */     mergeTerms();
/*  90 */     mergeNorms();
/*     */     
/*  92 */     if (this.fieldInfos.hasVectors()) {
/*  93 */       mergeVectors();
/*     */     }
/*  95 */     return value;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void closeReaders() throws IOException {
/* 104 */     for (int i = 0; i < this.readers.size(); i++) {
/* 105 */       IndexReader reader = this.readers.elementAt(i);
/* 106 */       reader.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   final Vector createCompoundFile(String fileName) throws IOException {
/* 112 */     CompoundFileWriter cfsWriter = new CompoundFileWriter(this.directory, fileName);
/*     */ 
/*     */     
/* 115 */     Vector files = new Vector(IndexFileNames.COMPOUND_EXTENSIONS.length + this.fieldInfos.size());
/*     */ 
/*     */ 
/*     */     
/* 119 */     for (int i = 0; i < IndexFileNames.COMPOUND_EXTENSIONS.length; i++) {
/* 120 */       files.add(this.segment + ""."" + IndexFileNames.COMPOUND_EXTENSIONS[i]);
/*     */     }
/*     */ 
/*     */     
/* 124 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 125 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 126 */       if (fi.isIndexed && !fi.omitNorms) {
/* 127 */         files.add(this.segment + "".f"" + i);
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 132 */     if (this.fieldInfos.hasVectors()) {
/* 133 */       for (int i = 0; i < IndexFileNames.VECTOR_EXTENSIONS.length; i++) {
/* 134 */         files.add(this.segment + ""."" + IndexFileNames.VECTOR_EXTENSIONS[i]);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/* 139 */     Iterator it = files.iterator();
/* 140 */     while (it.hasNext()) {
/* 141 */       cfsWriter.addFile(it.next());
/*     */     }
/*     */ 
/*     */     
/* 145 */     cfsWriter.close();
/*     */     
/* 147 */     return files;
/*     */   }
/*     */ 
/*     */   
/*     */   private void addIndexed(IndexReader reader, FieldInfos fieldInfos, Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) throws IOException {
/* 152 */     Iterator i = names.iterator();
/* 153 */     while (i.hasNext()) {
/* 154 */       String field = i.next();
/* 155 */       fieldInfos.add(field, true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector, !reader.hasNorms(field));
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int mergeFields() throws IOException {
/* 165 */     this.fieldInfos = new FieldInfos();
/* 166 */     int docCount = 0;
/* 167 */     for (int i = 0; i < this.readers.size(); i++) {
/* 168 */       IndexReader reader = this.readers.elementAt(i);
/* 169 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true);
/* 170 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION), true, true, false);
/* 171 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true);
/* 172 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR), true, false, false);
/* 173 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.INDEXED), false, false, false);
/* 174 */       this.fieldInfos.add(reader.getFieldNames(IndexReader.FieldOption.UNINDEXED), false);
/*     */     } 
/* 176 */     this.fieldInfos.write(this.directory, this.segment + "".fnm"");
/*     */     
/* 178 */     FieldsWriter fieldsWriter = new FieldsWriter(this.directory, this.segment, this.fieldInfos);
/*     */ 
/*     */     
/* 181 */     try { for (int i = 0; i < this.readers.size(); i++) {
/* 182 */         IndexReader reader = this.readers.elementAt(i);
/* 183 */         int maxDoc = reader.maxDoc();
/* 184 */         for (int j = 0; j < maxDoc; j++) {
/* 185 */           if (!reader.isDeleted(j)) {
/* 186 */             fieldsWriter.addDocument(reader.document(j));
/* 187 */             docCount++;
/*     */           } 
/*     */         } 
/*     */       }  }
/* 191 */     finally { fieldsWriter.close(); }
/*     */     
/* 193 */     return docCount;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void mergeVectors() throws IOException {
/* 201 */     TermVectorsWriter termVectorsWriter = new TermVectorsWriter(this.directory, this.segment, this.fieldInfos);
/*     */ 
/*     */     
/*     */     try {
/* 205 */       for (int r = 0; r < this.readers.size(); r++) {
/* 206 */         IndexReader reader = this.readers.elementAt(r);
/* 207 */         int maxDoc = reader.maxDoc();
/* 208 */         for (int docNum = 0; docNum < maxDoc; docNum++) {
/*     */           
/* 210 */           if (!reader.isDeleted(docNum))
/*     */           {
/* 212 */             termVectorsWriter.addAllDocVectors(reader.getTermFreqVectors(docNum)); } 
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 216 */       termVectorsWriter.close();
/*     */     } 
/*     */   }
/*     */   
/* 220 */   SegmentMerger(Directory dir, String name) { this.freqOutput = null;
/* 221 */     this.proxOutput = null;
/* 222 */     this.termInfosWriter = null;
/*     */     
/* 224 */     this.queue = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 284 */     this.termInfo = new TermInfo();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 366 */     this.skipBuffer = new RAMOutputStream(); this.directory = dir; this.segment = name; } SegmentMerger(IndexWriter writer, String name) { this.freqOutput = null; this.proxOutput = null; this.termInfosWriter = null; this.queue = null; this.termInfo = new TermInfo(); this.skipBuffer = new RAMOutputStream(); this.directory = writer.getDirectory(); this.segment = name; this.termIndexInterval = writer.getTermIndexInterval(); }
/*     */   private final void mergeTerms() throws IOException { try { this.freqOutput = this.directory.createOutput(this.segment + "".frq""); this.proxOutput = this.directory.createOutput(this.segment + "".prx""); this.termInfosWriter = new TermInfosWriter(this.directory, this.segment, this.fieldInfos, this.termIndexInterval); this.skipInterval = this.termInfosWriter.skipInterval; this.queue = new SegmentMergeQueue(this.readers.size()); mergeTermInfos(); } finally { if (this.freqOutput != null)
/*     */         this.freqOutput.close();  if (this.proxOutput != null)
/*     */         this.proxOutput.close();  if (this.termInfosWriter != null)
/*     */         this.termInfosWriter.close();  if (this.queue != null)
/*     */         this.queue.close();  }  }
/* 372 */   private final void mergeTermInfos() throws IOException { int base = 0; for (int i = 0; i < this.readers.size(); i++) { IndexReader reader = this.readers.elementAt(i); TermEnum termEnum = reader.terms(); SegmentMergeInfo smi = new SegmentMergeInfo(base, termEnum, reader); base += reader.numDocs(); if (smi.next()) { this.queue.put(smi); } else { smi.close(); }  }  SegmentMergeInfo[] match = new SegmentMergeInfo[this.readers.size()]; while (this.queue.size() > 0) { int matchSize = 0; match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); Term term = (match[0]).term; SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top(); while (top != null && term.compareTo(top.term) == 0) { match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); top = (SegmentMergeInfo)this.queue.top(); }  mergeTermInfo(match, matchSize); while (matchSize > 0) { SegmentMergeInfo smi = match[--matchSize]; if (smi.next()) { this.queue.put(smi); continue; }  smi.close(); }  }  } private void resetSkip() { this.skipBuffer.reset();
/* 373 */     this.lastSkipDoc = 0;
/* 374 */     this.lastSkipFreqPointer = this.freqOutput.getFilePointer();
/* 375 */     this.lastSkipProxPointer = this.proxOutput.getFilePointer(); }
/*     */   private final void mergeTermInfo(SegmentMergeInfo[] smis, int n) throws IOException { long freqPointer = this.freqOutput.getFilePointer(); long proxPointer = this.proxOutput.getFilePointer(); int df = appendPostings(smis, n); long skipPointer = writeSkip(); if (df > 0) { this.termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer - freqPointer)); this.termInfosWriter.add((smis[0]).term, this.termInfo); }  }
/*     */   private final int appendPostings(SegmentMergeInfo[] smis, int n) throws IOException { int lastDoc = 0; int df = 0; resetSkip(); for (int i = 0; i < n; i++) { SegmentMergeInfo smi = smis[i]; TermPositions postings = smi.getPositions(); int base = smi.base; int[] docMap = smi.getDocMap(); postings.seek(smi.termEnum); while (postings.next()) { int doc = postings.doc(); if (docMap != null) doc = docMap[doc];  doc += base; if (doc < lastDoc)
/*     */           throw new IllegalStateException(""docs out of order ("" + doc + "" < "" + lastDoc + "" )"");  df++; if (df % this.skipInterval == 0)
/* 379 */           bufferSkip(lastDoc);  int docCode = doc - lastDoc << 1; lastDoc = doc; int freq = postings.freq(); if (freq == 1) { this.freqOutput.writeVInt(docCode | 0x1); } else { this.freqOutput.writeVInt(docCode); this.freqOutput.writeVInt(freq); }  int lastPosition = 0; for (int j = 0; j < freq; j++) { int position = postings.nextPosition(); this.proxOutput.writeVInt(position - lastPosition); lastPosition = position; }  }  }  return df; } private void bufferSkip(int doc) throws IOException { long freqPointer = this.freqOutput.getFilePointer();
/* 380 */     long proxPointer = this.proxOutput.getFilePointer();
/*     */     
/* 382 */     this.skipBuffer.writeVInt(doc - this.lastSkipDoc);
/* 383 */     this.skipBuffer.writeVInt((int)(freqPointer - this.lastSkipFreqPointer));
/* 384 */     this.skipBuffer.writeVInt((int)(proxPointer - this.lastSkipProxPointer));
/*     */     
/* 386 */     this.lastSkipDoc = doc;
/* 387 */     this.lastSkipFreqPointer = freqPointer;
/* 388 */     this.lastSkipProxPointer = proxPointer; }
/*     */ 
/*     */   
/*     */   private long writeSkip() throws IOException {
/* 392 */     long skipPointer = this.freqOutput.getFilePointer();
/* 393 */     this.skipBuffer.writeTo(this.freqOutput);
/* 394 */     return skipPointer;
/*     */   }
/*     */   
/*     */   private void mergeNorms() throws IOException {
/* 398 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 399 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 400 */       if (fi.isIndexed && !fi.omitNorms)
/* 401 */         IndexOutput output = this.directory.createOutput(this.segment + "".f"" + i); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentMerger.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashSet;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.search.DefaultSimilarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SegmentReader
/*     */   extends IndexReader
/*     */ {
/*     */   private String segment;
/*     */   FieldInfos fieldInfos;
/*     */   private FieldsReader fieldsReader;
/*     */   TermInfosReader tis;
/*  40 */   TermVectorsReader termVectorsReaderOrig = null;
/*  41 */   ThreadLocal termVectorsLocal = new ThreadLocal();
/*     */   
/*  43 */   BitVector deletedDocs = null;
/*     */   
/*     */   private boolean deletedDocsDirty = false;
/*     */   
/*     */   private boolean normsDirty = false;
/*     */   
/*     */   private boolean undeleteAll = false;
/*     */   IndexInput freqStream;
/*     */   IndexInput proxStream;
/*  52 */   CompoundFileReader cfsReader = null;
/*     */   
/*     */   private class Norm
/*     */   {
/*     */     public Norm(IndexInput in, int number) {
/*  57 */       this.in = in;
/*  58 */       this.number = number;
/*     */     }
/*     */     private IndexInput in;
/*     */     private byte[] bytes;
/*     */     private boolean dirty;
/*     */     private int number;
/*     */     private final SegmentReader this$0;
/*     */     
/*     */     private void reWrite() throws IOException {
/*     */       String fileName;
/*  68 */       IndexOutput out = SegmentReader.this.directory().createOutput(SegmentReader.this.segment + "".tmp"");
/*     */       try {
/*  70 */         out.writeBytes(this.bytes, SegmentReader.this.maxDoc());
/*     */       } finally {
/*  72 */         out.close();
/*     */       } 
/*     */       
/*  75 */       if (SegmentReader.this.cfsReader == null) {
/*  76 */         fileName = SegmentReader.this.segment + "".f"" + this.number;
/*     */       } else {
/*     */         
/*  79 */         fileName = SegmentReader.this.segment + "".s"" + this.number;
/*     */       } 
/*  81 */       SegmentReader.this.directory().renameFile(SegmentReader.this.segment + "".tmp"", fileName);
/*  82 */       this.dirty = false;
/*     */     }
/*     */   }
/*     */   
/*  86 */   private Hashtable norms = new Hashtable();
/*     */   private static Class IMPL;
/*     */   private byte[] ones;
/*     */   
/*     */   static  {
/*     */     try {
/*  92 */       String name = System.getProperty(""org.apache.lucene.SegmentReader.class"", SegmentReader.class.getName());
/*     */ 
/*     */       
/*  95 */       IMPL = Class.forName(name);
/*  96 */     } catch (ClassNotFoundException e) {
/*  97 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/*  98 */     } catch (SecurityException se) {
/*     */       try {
/* 100 */         IMPL = Class.forName(SegmentReader.class.getName());
/* 101 */       } catch (ClassNotFoundException e) {
/* 102 */         throw new RuntimeException(""cannot load default SegmentReader class: "" + e, e);
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 107 */   protected SegmentReader() { super(null); }
/*     */ 
/*     */   
/* 110 */   public static SegmentReader get(SegmentInfo si) throws IOException { return get(si.dir, si, null, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public static SegmentReader get(SegmentInfos sis, SegmentInfo si, boolean closeDir) throws IOException { return get(si.dir, si, sis, closeDir, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static SegmentReader get(Directory dir, SegmentInfo si, SegmentInfos sis, boolean closeDir, boolean ownDir) throws IOException {
/*     */     SegmentReader instance;
/*     */     try {
/* 124 */       instance = IMPL.newInstance();
/* 125 */     } catch (Exception e) {
/* 126 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/*     */     } 
/* 128 */     instance.init(dir, sis, closeDir, ownDir);
/* 129 */     instance.initialize(si);
/* 130 */     return instance;
/*     */   }
/*     */   
/*     */   private void initialize(SegmentInfo si) throws IOException {
/* 134 */     this.segment = si.name;
/*     */ 
/*     */     
/* 137 */     Directory cfsDir = directory();
/* 138 */     if (directory().fileExists(this.segment + "".cfs"")) {
/* 139 */       this.cfsReader = new CompoundFileReader(directory(), this.segment + "".cfs"");
/* 140 */       cfsDir = this.cfsReader;
/*     */     } 
/*     */ 
/*     */     
/* 144 */     this.fieldInfos = new FieldInfos(cfsDir, this.segment + "".fnm"");
/* 145 */     this.fieldsReader = new FieldsReader(cfsDir, this.segment, this.fieldInfos);
/*     */     
/* 147 */     this.tis = new TermInfosReader(cfsDir, this.segment, this.fieldInfos);
/*     */ 
/*     */     
/* 150 */     if (hasDeletions(si)) {
/* 151 */       this.deletedDocs = new BitVector(directory(), this.segment + "".del"");
/*     */     }
/*     */ 
/*     */     
/* 155 */     this.freqStream = cfsDir.openInput(this.segment + "".frq"");
/* 156 */     this.proxStream = cfsDir.openInput(this.segment + "".prx"");
/* 157 */     openNorms(cfsDir);
/*     */     
/* 159 */     if (this.fieldInfos.hasVectors()) {
/* 160 */       this.termVectorsReaderOrig = new TermVectorsReader(cfsDir, this.segment, this.fieldInfos);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   protected void finalize() {
/* 166 */     this.termVectorsLocal.set(null);
/* 167 */     super.finalize();
/*     */   }
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 171 */     if (this.deletedDocsDirty) {
/* 172 */       this.deletedDocs.write(directory(), this.segment + "".tmp"");
/* 173 */       directory().renameFile(this.segment + "".tmp"", this.segment + "".del"");
/*     */     } 
/* 175 */     if (this.undeleteAll && directory().fileExists(this.segment + "".del"")) {
/* 176 */       directory().deleteFile(this.segment + "".del"");
/*     */     }
/* 178 */     if (this.normsDirty) {
/* 179 */       Enumeration values = this.norms.elements();
/* 180 */       while (values.hasMoreElements()) {
/* 181 */         Norm norm = values.nextElement();
/* 182 */         if (norm.dirty) {
/* 183 */           norm.reWrite();
/*     */         }
/*     */       } 
/*     */     } 
/* 187 */     this.deletedDocsDirty = false;
/* 188 */     this.normsDirty = false;
/* 189 */     this.undeleteAll = false;
/*     */   }
/*     */   
/*     */   protected void doClose() throws IOException {
/* 193 */     this.fieldsReader.close();
/* 194 */     this.tis.close();
/*     */     
/* 196 */     if (this.freqStream != null)
/* 197 */       this.freqStream.close(); 
/* 198 */     if (this.proxStream != null) {
/* 199 */       this.proxStream.close();
/*     */     }
/* 201 */     closeNorms();
/*     */     
/* 203 */     if (this.termVectorsReaderOrig != null) {
/* 204 */       this.termVectorsReaderOrig.close();
/*     */     }
/* 206 */     if (this.cfsReader != null) {
/* 207 */       this.cfsReader.close();
/*     */     }
/*     */   }
/*     */   
/* 211 */   static boolean hasDeletions(SegmentInfo si) throws IOException { return si.dir.fileExists(si.name + "".del""); }
/*     */ 
/*     */ 
/*     */   
/* 215 */   public boolean hasDeletions() { return (this.deletedDocs != null); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 220 */   static boolean usesCompoundFile(SegmentInfo si) throws IOException { return si.dir.fileExists(si.name + "".cfs""); }
/*     */ 
/*     */   
/*     */   static boolean hasSeparateNorms(SegmentInfo si) throws IOException {
/* 224 */     String[] result = si.dir.list();
/* 225 */     String pattern = si.name + "".s"";
/* 226 */     int patternLength = pattern.length();
/* 227 */     for (int i = 0; i < result.length; i++) {
/* 228 */       if (result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))
/* 229 */         return true; 
/*     */     } 
/* 231 */     return false;
/*     */   }
/*     */   
/*     */   protected void doDelete(int docNum) {
/* 235 */     if (this.deletedDocs == null)
/* 236 */       this.deletedDocs = new BitVector(maxDoc()); 
/* 237 */     this.deletedDocsDirty = true;
/* 238 */     this.undeleteAll = false;
/* 239 */     this.deletedDocs.set(docNum);
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() {
/* 243 */     this.deletedDocs = null;
/* 244 */     this.deletedDocsDirty = false;
/* 245 */     this.undeleteAll = true;
/*     */   }
/*     */   
/*     */   Vector files() throws IOException {
/* 249 */     Vector files = new Vector(16);
/*     */     
/* 251 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS.length; i++) {
/* 252 */       String name = this.segment + ""."" + IndexFileNames.INDEX_EXTENSIONS[i];
/* 253 */       if (directory().fileExists(name)) {
/* 254 */         files.addElement(name);
/*     */       }
/*     */     } 
/* 257 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 258 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 259 */       if (fi.isIndexed && !fi.omitNorms) {
/*     */         String name;
/* 261 */         if (this.cfsReader == null) {
/* 262 */           name = this.segment + "".f"" + i;
/*     */         } else {
/* 264 */           name = this.segment + "".s"" + i;
/* 265 */         }  if (directory().fileExists(name))
/* 266 */           files.addElement(name); 
/*     */       } 
/*     */     } 
/* 269 */     return files;
/*     */   }
/*     */ 
/*     */   
/* 273 */   public TermEnum terms() { return this.tis.terms(); }
/*     */ 
/*     */ 
/*     */   
/* 277 */   public TermEnum terms(Term t) throws IOException { return this.tis.terms(t); }
/*     */ 
/*     */   
/*     */   public synchronized Document document(int n) throws IOException {
/* 281 */     if (isDeleted(n)) {
/* 282 */       throw new IllegalArgumentException(""attempt to access a deleted document"");
/*     */     }
/* 284 */     return this.fieldsReader.doc(n);
/*     */   }
/*     */ 
/*     */   
/* 288 */   public synchronized boolean isDeleted(int n) { return (this.deletedDocs != null && this.deletedDocs.get(n)); }
/*     */ 
/*     */ 
/*     */   
/* 292 */   public TermDocs termDocs() throws IOException { return new SegmentTermDocs(this); }
/*     */ 
/*     */ 
/*     */   
/* 296 */   public TermPositions termPositions() throws IOException { return new SegmentTermPositions(this); }
/*     */ 
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 300 */     TermInfo ti = this.tis.get(t);
/* 301 */     if (ti != null) {
/* 302 */       return ti.docFreq;
/*     */     }
/* 304 */     return 0;
/*     */   }
/*     */   
/*     */   public int numDocs() {
/* 308 */     int n = maxDoc();
/* 309 */     if (this.deletedDocs != null)
/* 310 */       n -= this.deletedDocs.count(); 
/* 311 */     return n;
/*     */   }
/*     */ 
/*     */   
/* 315 */   public int maxDoc() { return this.fieldsReader.size(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldOption) {
/* 323 */     Set fieldSet = new HashSet();
/* 324 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 325 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 326 */       if (fieldOption == IndexReader.FieldOption.ALL) {
/* 327 */         fieldSet.add(fi.name);
/*     */       }
/* 329 */       else if (!fi.isIndexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
/* 330 */         fieldSet.add(fi.name);
/*     */       }
/* 332 */       else if (fi.isIndexed && fieldOption == IndexReader.FieldOption.INDEXED) {
/* 333 */         fieldSet.add(fi.name);
/*     */       }
/* 335 */       else if (fi.isIndexed && !fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
/* 336 */         fieldSet.add(fi.name);
/*     */       }
/* 338 */       else if (fi.storeTermVector == true && !fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR) {
/*     */ 
/*     */ 
/*     */         
/* 342 */         fieldSet.add(fi.name);
/*     */       }
/* 344 */       else if (fi.isIndexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
/* 345 */         fieldSet.add(fi.name);
/*     */       }
/* 347 */       else if (fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
/* 348 */         fieldSet.add(fi.name);
/*     */       }
/* 350 */       else if (fi.storeOffsetWithTermVector && !fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
/* 351 */         fieldSet.add(fi.name);
/*     */       }
/* 353 */       else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
/*     */         
/* 355 */         fieldSet.add(fi.name);
/*     */       } 
/*     */     } 
/* 358 */     return fieldSet;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 363 */   public synchronized boolean hasNorms(String field) { return this.norms.containsKey(field); }
/*     */ 
/*     */   
/*     */   static byte[] createFakeNorms(int size) {
/* 367 */     byte[] ones = new byte[size];
/* 368 */     Arrays.fill(ones, DefaultSimilarity.encodeNorm(1.0F));
/* 369 */     return ones;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 374 */     if (this.ones == null) this.ones = createFakeNorms(maxDoc()); 
/* 375 */     return this.ones;
/*     */   }
/*     */ 
/*     */   
/*     */   protected synchronized byte[] getNorms(String field) throws IOException {
/* 380 */     Norm norm = (Norm)this.norms.get(field);
/* 381 */     if (norm == null) return null;
/*     */     
/* 383 */     if (norm.bytes == null) {
/* 384 */       byte[] bytes = new byte[maxDoc()];
/* 385 */       norms(field, bytes, 0);
/* 386 */       norm.bytes = bytes;
/*     */     } 
/* 388 */     return norm.bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 393 */     byte[] bytes = getNorms(field);
/* 394 */     if (bytes == null) bytes = fakeNorms(); 
/* 395 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doSetNorm(int doc, String field, byte value) throws IOException {
/* 400 */     Norm norm = (Norm)this.norms.get(field);
/* 401 */     if (norm == null)
/*     */       return; 
/* 403 */     norm.dirty = true;
/* 404 */     this.normsDirty = true;
/*     */     
/* 406 */     norms(field)[doc] = value;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] bytes, int offset) throws IOException {
/* 413 */     Norm norm = (Norm)this.norms.get(field);
/* 414 */     if (norm == null) {
/* 415 */       System.arraycopy(fakeNorms(), 0, bytes, offset, maxDoc());
/*     */       
/*     */       return;
/*     */     } 
/* 419 */     if (norm.bytes != null) {
/* 420 */       System.arraycopy(norm.bytes, 0, bytes, offset, maxDoc());
/*     */       
/*     */       return;
/*     */     } 
/* 424 */     IndexInput normStream = (IndexInput)norm.in.clone();
/*     */     try {
/* 426 */       normStream.seek(0L);
/* 427 */       normStream.readBytes(bytes, offset, maxDoc());
/*     */     } finally {
/* 429 */       normStream.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void openNorms(Directory cfsDir) throws IOException {
/* 435 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 436 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 437 */       if (fi.isIndexed && !fi.omitNorms) {
/*     */         
/* 439 */         String fileName = this.segment + "".s"" + fi.number;
/* 440 */         Directory d = directory();
/* 441 */         if (!d.fileExists(fileName)) {
/* 442 */           fileName = this.segment + "".f"" + fi.number;
/* 443 */           d = cfsDir;
/*     */         } 
/* 445 */         this.norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void closeNorms() throws IOException {
/* 451 */     synchronized (this.norms) {
/* 452 */       Enumeration enumerator = this.norms.elements();
/* 453 */       while (enumerator.hasMoreElements()) {
/* 454 */         Norm norm = enumerator.nextElement();
/* 455 */         norm.in.close();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private TermVectorsReader getTermVectorsReader() {
/* 465 */     TermVectorsReader tvReader = this.termVectorsLocal.get();
/* 466 */     if (tvReader == null) {
/* 467 */       tvReader = (TermVectorsReader)this.termVectorsReaderOrig.clone();
/* 468 */       this.termVectorsLocal.set(tvReader);
/*     */     } 
/* 470 */     return tvReader;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
/* 481 */     FieldInfo fi = this.fieldInfos.fieldInfo(field);
/* 482 */     if (fi == null || !fi.storeTermVector || this.termVectorsReaderOrig == null) {
/* 483 */       return null;
/*     */     }
/* 485 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 486 */     if (termVectorsReader == null) {
/* 487 */       return null;
/*     */     }
/* 489 */     return termVectorsReader.get(docNumber, field);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
/* 501 */     if (this.termVectorsReaderOrig == null) {
/* 502 */       return null;
/*     */     }
/* 504 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 505 */     if (termVectorsReader == null) {
/* 506 */       return null;
/*     */     }
/* 508 */     return termVectorsReader.get(docNumber);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermDocs,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SegmentTermDocs
/*     */   implements TermDocs
/*     */ {
/*     */   protected SegmentReader parent;
/*     */   protected IndexInput freqStream;
/*     */   protected int count;
/*     */   protected int df;
/*     */   protected BitVector deletedDocs;
/*  29 */   int doc = 0;
/*     */   
/*     */   int freq;
/*     */   private int skipInterval;
/*     */   private int numSkips;
/*     */   private int skipCount;
/*     */   private IndexInput skipStream;
/*     */   private int skipDoc;
/*     */   private long freqPointer;
/*     */   private long proxPointer;
/*     */   private long skipPointer;
/*     */   private boolean haveSkipped;
/*     */   
/*     */   protected SegmentTermDocs(SegmentReader parent) {
/*  43 */     this.parent = parent;
/*  44 */     this.freqStream = (IndexInput)parent.freqStream.clone();
/*  45 */     this.deletedDocs = parent.deletedDocs;
/*  46 */     this.skipInterval = parent.tis.getSkipInterval();
/*     */   }
/*     */   
/*     */   public void seek(Term term) throws IOException {
/*  50 */     TermInfo ti = this.parent.tis.get(term);
/*  51 */     seek(ti);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(TermEnum termEnum) throws IOException {
/*     */     TermInfo ti;
/*  58 */     if (termEnum instanceof SegmentTermEnum && ((SegmentTermEnum)termEnum).fieldInfos == this.parent.fieldInfos) {
/*  59 */       ti = ((SegmentTermEnum)termEnum).termInfo();
/*     */     } else {
/*  61 */       ti = this.parent.tis.get(termEnum.term());
/*     */     } 
/*  63 */     seek(ti);
/*     */   }
/*     */   
/*     */   void seek(TermInfo ti) throws IOException {
/*  67 */     this.count = 0;
/*  68 */     if (ti == null) {
/*  69 */       this.df = 0;
/*     */     } else {
/*  71 */       this.df = ti.docFreq;
/*  72 */       this.doc = 0;
/*  73 */       this.skipDoc = 0;
/*  74 */       this.skipCount = 0;
/*  75 */       this.numSkips = this.df / this.skipInterval;
/*  76 */       this.freqPointer = ti.freqPointer;
/*  77 */       this.proxPointer = ti.proxPointer;
/*  78 */       this.skipPointer = this.freqPointer + ti.skipOffset;
/*  79 */       this.freqStream.seek(this.freqPointer);
/*  80 */       this.haveSkipped = false;
/*     */     } 
/*     */   }
/*     */   
/*     */   public void close() throws IOException {
/*  85 */     this.freqStream.close();
/*  86 */     if (this.skipStream != null)
/*  87 */       this.skipStream.close(); 
/*     */   }
/*     */   
/*  90 */   public final int doc() { return this.doc; }
/*  91 */   public final int freq() { return this.freq; }
/*     */ 
/*     */   
/*     */   protected void skippingDoc() throws IOException {}
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     while (true) {
/*  98 */       if (this.count == this.df) {
/*  99 */         return false;
/*     */       }
/* 101 */       int docCode = this.freqStream.readVInt();
/* 102 */       this.doc += docCode >>> 1;
/* 103 */       if ((docCode & 0x1) != 0) {
/* 104 */         this.freq = 1;
/*     */       } else {
/* 106 */         this.freq = this.freqStream.readVInt();
/*     */       } 
/* 108 */       this.count++;
/*     */       
/* 110 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc))
/*     */         break; 
/* 112 */       skippingDoc();
/*     */     } 
/* 114 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int read(int[] docs, int[] freqs) throws IOException {
/* 120 */     int length = docs.length;
/* 121 */     int i = 0;
/* 122 */     while (i < length && this.count < this.df) {
/*     */ 
/*     */       
/* 125 */       int docCode = this.freqStream.readVInt();
/* 126 */       this.doc += docCode >>> 1;
/* 127 */       if ((docCode & 0x1) != 0) {
/* 128 */         this.freq = 1;
/*     */       } else {
/* 130 */         this.freq = this.freqStream.readVInt();
/* 131 */       }  this.count++;
/*     */       
/* 133 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc)) {
/* 134 */         docs[i] = this.doc;
/* 135 */         freqs[i] = this.freq;
/* 136 */         i++;
/*     */       } 
/*     */     } 
/* 139 */     return i;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void skipProx(long proxPointer) throws IOException {}
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 147 */     if (this.df >= this.skipInterval) {
/*     */       
/* 149 */       if (this.skipStream == null) {
/* 150 */         this.skipStream = (IndexInput)this.freqStream.clone();
/*     */       }
/* 152 */       if (!this.haveSkipped) {
/* 153 */         this.skipStream.seek(this.skipPointer);
/* 154 */         this.haveSkipped = true;
/*     */       } 
/*     */ 
/*     */       
/* 158 */       int lastSkipDoc = this.skipDoc;
/* 159 */       long lastFreqPointer = this.freqStream.getFilePointer();
/* 160 */       long lastProxPointer = -1L;
/* 161 */       int numSkipped = -1 - this.count % this.skipInterval;
/*     */       
/* 163 */       while (target > this.skipDoc) {
/* 164 */         lastSkipDoc = this.skipDoc;
/* 165 */         lastFreqPointer = this.freqPointer;
/* 166 */         lastProxPointer = this.proxPointer;
/*     */         
/* 168 */         if (this.skipDoc != 0 && this.skipDoc >= this.doc) {
/* 169 */           numSkipped += this.skipInterval;
/*     */         }
/* 171 */         if (this.skipCount >= this.numSkips) {
/*     */           break;
/*     */         }
/* 174 */         this.skipDoc += this.skipStream.readVInt();
/* 175 */         this.freqPointer += this.skipStream.readVInt();
/* 176 */         this.proxPointer += this.skipStream.readVInt();
/*     */         
/* 178 */         this.skipCount++;
/*     */       } 
/*     */ 
/*     */       
/* 182 */       if (lastFreqPointer > this.freqStream.getFilePointer()) {
/* 183 */         this.freqStream.seek(lastFreqPointer);
/* 184 */         skipProx(lastProxPointer);
/*     */         
/* 186 */         this.doc = lastSkipDoc;
/* 187 */         this.count += numSkipped;
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*     */     do {
/* 194 */       if (!next())
/* 195 */         return false; 
/* 196 */     } while (target > this.doc);
/* 197 */     return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentTermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermEnum,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentTermEnum
/*     */   extends TermEnum
/*     */   implements Cloneable
/*     */ {
/*     */   private IndexInput input;
/*     */   FieldInfos fieldInfos;
/*     */   long size;
/*  26 */   long position = -1L;
/*     */   
/*  28 */   private TermBuffer termBuffer = new TermBuffer();
/*  29 */   private TermBuffer prevBuffer = new TermBuffer();
/*     */   
/*     */   private TermBuffer scratch;
/*  32 */   private TermInfo termInfo = new TermInfo();
/*     */   
/*     */   private int format;
/*     */   private boolean isIndex = false;
/*  36 */   long indexPointer = 0L;
/*     */   
/*     */   int indexInterval;
/*     */   int skipInterval;
/*     */   private int formatM1SkipInterval;
/*     */   
/*     */   SegmentTermEnum(IndexInput i, FieldInfos fis, boolean isi) throws IOException {
/*  43 */     this.input = i;
/*  44 */     this.fieldInfos = fis;
/*  45 */     this.isIndex = isi;
/*     */     
/*  47 */     int firstInt = this.input.readInt();
/*  48 */     if (firstInt >= 0) {
/*     */       
/*  50 */       this.format = 0;
/*  51 */       this.size = firstInt;
/*     */ 
/*     */       
/*  54 */       this.indexInterval = 128;
/*  55 */       this.skipInterval = Integer.MAX_VALUE;
/*     */     }
/*     */     else {
/*     */       
/*  59 */       this.format = firstInt;
/*     */ 
/*     */       
/*  62 */       if (this.format < -2) {
/*  63 */         throw new IOException(""Unknown format version:"" + this.format);
/*     */       }
/*  65 */       this.size = this.input.readLong();
/*     */       
/*  67 */       if (this.format == -1) {
/*  68 */         if (!this.isIndex) {
/*  69 */           this.indexInterval = this.input.readInt();
/*  70 */           this.formatM1SkipInterval = this.input.readInt();
/*     */         } 
/*     */ 
/*     */         
/*  74 */         this.skipInterval = Integer.MAX_VALUE;
/*     */       } else {
/*     */         
/*  77 */         this.indexInterval = this.input.readInt();
/*  78 */         this.skipInterval = this.input.readInt();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected Object clone() {
/*  85 */     SegmentTermEnum clone = null;
/*     */     try {
/*  87 */       clone = (SegmentTermEnum)super.clone();
/*  88 */     } catch (CloneNotSupportedException e) {}
/*     */     
/*  90 */     clone.input = (IndexInput)this.input.clone();
/*  91 */     clone.termInfo = new TermInfo(this.termInfo);
/*     */     
/*  93 */     clone.termBuffer = (TermBuffer)this.termBuffer.clone();
/*  94 */     clone.prevBuffer = (TermBuffer)this.prevBuffer.clone();
/*  95 */     clone.scratch = null;
/*     */     
/*  97 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   final void seek(long pointer, int p, Term t, TermInfo ti) throws IOException {
/* 102 */     this.input.seek(pointer);
/* 103 */     this.position = p;
/* 104 */     this.termBuffer.set(t);
/* 105 */     this.prevBuffer.reset();
/* 106 */     this.termInfo.set(ti);
/*     */   }
/*     */ 
/*     */   
/*     */   public final boolean next() throws IOException {
/* 111 */     if (this.position++ >= this.size - 1L) {
/* 112 */       this.termBuffer.reset();
/* 113 */       return false;
/*     */     } 
/*     */     
/* 116 */     this.prevBuffer.set(this.termBuffer);
/* 117 */     this.termBuffer.read(this.input, this.fieldInfos);
/*     */     
/* 119 */     this.termInfo.docFreq = this.input.readVInt();
/* 120 */     this.termInfo.freqPointer += this.input.readVLong();
/* 121 */     this.termInfo.proxPointer += this.input.readVLong();
/*     */     
/* 123 */     if (this.format == -1) {
/*     */ 
/*     */       
/* 126 */       if (!this.isIndex && 
/* 127 */         this.termInfo.docFreq > this.formatM1SkipInterval) {
/* 128 */         this.termInfo.skipOffset = this.input.readVInt();
/*     */       
/*     */       }
/*     */     
/*     */     }
/* 133 */     else if (this.termInfo.docFreq >= this.skipInterval) {
/* 134 */       this.termInfo.skipOffset = this.input.readVInt();
/*     */     } 
/*     */     
/* 137 */     if (this.isIndex) {
/* 138 */       this.indexPointer += this.input.readVLong();
/*     */     }
/* 140 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   final void scanTo(Term term) throws IOException {
/* 145 */     if (this.scratch == null)
/* 146 */       this.scratch = new TermBuffer(); 
/* 147 */     this.scratch.set(term);
/* 148 */     while (this.scratch.compareTo(this.termBuffer) > 0 && next());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 154 */   public final Term term() { return this.termBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   final Term prev() { return this.prevBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 165 */   final TermInfo termInfo() { return new TermInfo(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 171 */   final void termInfo(TermInfo ti) { ti.set(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public final int docFreq() { return this.termInfo.docFreq; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   final long freqPointer() { return this.termInfo.freqPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 189 */   final long proxPointer() { return this.termInfo.proxPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 194 */   public final void close() throws IOException { this.input.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositions,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.store.IndexInput;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentTermPositions
/*    */   extends SegmentTermDocs
/*    */   implements TermPositions
/*    */ {
/*    */   private IndexInput proxStream;
/*    */   private int proxCount;
/*    */   private int position;
/*    */   
/*    */   SegmentTermPositions(SegmentReader p) {
/* 30 */     super(p);
/* 31 */     this.proxStream = (IndexInput)this.parent.proxStream.clone();
/*    */   }
/*    */   
/*    */   final void seek(TermInfo ti) throws IOException {
/* 35 */     super.seek(ti);
/* 36 */     if (ti != null)
/* 37 */       this.proxStream.seek(ti.proxPointer); 
/* 38 */     this.proxCount = 0;
/*    */   }
/*    */   
/*    */   public final void close() throws IOException {
/* 42 */     super.close();
/* 43 */     this.proxStream.close();
/*    */   }
/*    */   
/*    */   public final int nextPosition() throws IOException {
/* 47 */     this.proxCount--;
/* 48 */     return this.position += this.proxStream.readVInt();
/*    */   }
/*    */   
/*    */   protected final void skippingDoc() throws IOException {
/* 52 */     for (int f = this.freq; f > 0; f--)
/* 53 */       this.proxStream.readVInt(); 
/*    */   }
/*    */   
/*    */   public final boolean next() throws IOException {
/* 57 */     for (int f = this.proxCount; f > 0; f--) {
/* 58 */       this.proxStream.readVInt();
/*    */     }
/* 60 */     if (super.next()) {
/* 61 */       this.proxCount = this.freq;
/* 62 */       this.position = 0;
/* 63 */       return true;
/*    */     } 
/* 65 */     return false;
/*    */   }
/*    */ 
/*    */   
/* 69 */   public final int read(int[] docs, int[] freqs) { throw new UnsupportedOperationException(""TermPositions does not support processing multiple documents in one call. Use TermDocs instead.""); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected void skipProx(long proxPointer) throws IOException {
/* 75 */     this.proxStream.seek(proxPointer);
/* 76 */     this.proxCount = 0;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositionVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SegmentTermPositionVector
/*    */   extends SegmentTermVector
/*    */   implements TermPositionVector
/*    */ {
/*    */   protected int[][] positions;
/*    */   protected TermVectorOffsetInfo[][] offsets;
/* 22 */   public static final int[] EMPTY_TERM_POS = new int[0];
/*    */   
/*    */   public SegmentTermPositionVector(String field, String[] terms, int[] termFreqs, int[][] positions, TermVectorOffsetInfo[][] offsets) {
/* 25 */     super(field, terms, termFreqs);
/* 26 */     this.offsets = offsets;
/* 27 */     this.positions = positions;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public TermVectorOffsetInfo[] getOffsets(int index) {
/* 38 */     TermVectorOffsetInfo[] result = TermVectorOffsetInfo.EMPTY_OFFSET_INFO;
/* 39 */     if (this.offsets == null)
/* 40 */       return null; 
/* 41 */     if (index >= 0 && index < this.offsets.length)
/*    */     {
/* 43 */       result = this.offsets[index];
/*    */     }
/* 45 */     return result;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] getTermPositions(int index) {
/* 54 */     int[] result = EMPTY_TERM_POS;
/* 55 */     if (this.positions == null)
/* 56 */       return null; 
/* 57 */     if (index >= 0 && index < this.positions.length)
/*    */     {
/* 59 */       result = this.positions[index];
/*    */     }
/*    */     
/* 62 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentTermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.Arrays;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SegmentTermVector
/*    */   implements TermFreqVector
/*    */ {
/*    */   private String field;
/*    */   private String[] terms;
/*    */   private int[] termFreqs;
/*    */   
/*    */   SegmentTermVector(String field, String[] terms, int[] termFreqs) {
/* 29 */     this.field = field;
/* 30 */     this.terms = terms;
/* 31 */     this.termFreqs = termFreqs;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public String getField() { return this.field; }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 43 */     StringBuffer sb = new StringBuffer();
/* 44 */     sb.append('{');
/* 45 */     sb.append(this.field).append("": "");
/* 46 */     if (this.terms != null) {
/* 47 */       for (int i = 0; i < this.terms.length; i++) {
/* 48 */         if (i > 0) sb.append("", ""); 
/* 49 */         sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*    */       } 
/*    */     }
/* 52 */     sb.append('}');
/*    */     
/* 54 */     return sb.toString();
/*    */   }
/*    */ 
/*    */   
/* 58 */   public int size() { return (this.terms == null) ? 0 : this.terms.length; }
/*    */ 
/*    */ 
/*    */   
/* 62 */   public String[] getTerms() { return this.terms; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*    */ 
/*    */   
/*    */   public int indexOf(String termText) {
/* 70 */     if (this.terms == null)
/* 71 */       return -1; 
/* 72 */     int res = Arrays.binarySearch((Object[])this.terms, termText);
/* 73 */     return (res >= 0) ? res : -1;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] indexesOf(String[] termNumbers, int start, int len) {
/* 82 */     int[] res = new int[len];
/*    */     
/* 84 */     for (int i = 0; i < len; i++) {
/* 85 */       res[i] = indexOf(termNumbers[start + i]);
/*    */     }
/* 87 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\SegmentTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Term,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.ObjectInputStream;
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Term
/*     */   implements Comparable, Serializable
/*     */ {
/*     */   String field;
/*     */   String text;
/*     */   
/*  33 */   public Term(String fld, String txt) { this(fld, txt, true); }
/*     */   
/*     */   Term(String fld, String txt, boolean intern) {
/*  36 */     this.field = intern ? fld.intern() : fld;
/*  37 */     this.text = txt;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  42 */   public final String field() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  47 */   public final String text() { return this.text; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   public Term createTerm(String text) { return new Term(this.field, text, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean equals(Object o) {
/*  63 */     if (o == null)
/*  64 */       return false; 
/*  65 */     Term other = (Term)o;
/*  66 */     return (this.field == other.field && this.text.equals(other.text));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public final int hashCode() { return this.field.hashCode() + this.text.hashCode(); }
/*     */ 
/*     */ 
/*     */   
/*  75 */   public int compareTo(Object other) { return compareTo((Term)other); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int compareTo(Term other) {
/*  84 */     if (this.field == other.field) {
/*  85 */       return this.text.compareTo(other.text);
/*     */     }
/*  87 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   final void set(String fld, String txt) {
/*  92 */     this.field = fld;
/*  93 */     this.text = txt;
/*     */   }
/*     */   
/*  96 */   public final String toString() { return this.field + "":"" + this.text; }
/*     */ 
/*     */ 
/*     */   
/*     */   private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
/* 101 */     in.defaultReadObject();
/* 102 */     this.field = this.field.intern();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\Term.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermBuffer,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermBuffer
/*     */   implements Cloneable
/*     */ {
/*  23 */   private static final char[] NO_CHARS = new char[0];
/*     */   
/*     */   private String field;
/*  26 */   private char[] text = NO_CHARS;
/*     */   private int textLength;
/*     */   private Term term;
/*     */   
/*     */   public final int compareTo(TermBuffer other) {
/*  31 */     if (this.field == other.field) {
/*  32 */       return compareChars(this.text, this.textLength, other.text, other.textLength);
/*     */     }
/*  34 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   private static final int compareChars(char[] v1, int len1, char[] v2, int len2) {
/*  39 */     int end = Math.min(len1, len2);
/*  40 */     for (int k = 0; k < end; k++) {
/*  41 */       char c1 = v1[k];
/*  42 */       char c2 = v2[k];
/*  43 */       if (c1 != c2) {
/*  44 */         return c1 - c2;
/*     */       }
/*     */     } 
/*  47 */     return len1 - len2;
/*     */   }
/*     */   
/*     */   private final void setTextLength(int newLength) {
/*  51 */     if (this.text.length < newLength) {
/*  52 */       char[] newText = new char[newLength];
/*  53 */       System.arraycopy(this.text, 0, newText, 0, this.textLength);
/*  54 */       this.text = newText;
/*     */     } 
/*  56 */     this.textLength = newLength;
/*     */   }
/*     */ 
/*     */   
/*     */   public final void read(IndexInput input, FieldInfos fieldInfos) throws IOException {
/*  61 */     this.term = null;
/*  62 */     int start = input.readVInt();
/*  63 */     int length = input.readVInt();
/*  64 */     int totalLength = start + length;
/*  65 */     setTextLength(totalLength);
/*  66 */     input.readChars(this.text, start, length);
/*  67 */     this.field = fieldInfos.fieldName(input.readVInt());
/*     */   }
/*     */   
/*     */   public final void set(Term term) {
/*  71 */     if (term == null) {
/*  72 */       reset();
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/*  77 */     setTextLength(term.text().length());
/*  78 */     term.text().getChars(0, term.text().length(), this.text, 0);
/*     */     
/*  80 */     this.field = term.field();
/*  81 */     this.term = term;
/*     */   }
/*     */   
/*     */   public final void set(TermBuffer other) {
/*  85 */     setTextLength(other.textLength);
/*  86 */     System.arraycopy(other.text, 0, this.text, 0, this.textLength);
/*     */     
/*  88 */     this.field = other.field;
/*  89 */     this.term = other.term;
/*     */   }
/*     */   
/*     */   public void reset() {
/*  93 */     this.field = null;
/*  94 */     this.textLength = 0;
/*  95 */     this.term = null;
/*     */   }
/*     */   
/*     */   public Term toTerm() {
/*  99 */     if (this.field == null) {
/* 100 */       return null;
/*     */     }
/* 102 */     if (this.term == null) {
/* 103 */       this.term = new Term(this.field, new String(this.text, 0, this.textLength), false);
/*     */     }
/* 105 */     return this.term;
/*     */   }
/*     */   
/*     */   protected Object clone() {
/* 109 */     TermBuffer clone = null;
/*     */     try {
/* 111 */       clone = (TermBuffer)super.clone();
/* 112 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 114 */     clone.text = new char[this.text.length];
/* 115 */     System.arraycopy(this.text, 0, clone.text, 0, this.textLength);
/*     */     
/* 117 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermBuffer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermDocs,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermDocs {
  void seek(Term paramTerm) throws IOException;
  void seek(TermEnum paramTermEnum) throws IOException;
  int doc();
  int freq();
  boolean next() throws IOException;
  int read(int[] paramArrayOfint1, int[] paramArrayOfint2) throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  void close() throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermEnum,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TermEnum
/*    */ {
/*    */   public abstract boolean next() throws IOException;
/*    */   
/*    */   public abstract Term term();
/*    */   
/*    */   public abstract int docFreq();
/*    */   
/*    */   public abstract void close() throws IOException;
/*    */   
/*    */   public boolean skipTo(Term target) throws IOException {
/*    */     do {
/* 56 */       if (!next())
/* 57 */         return false; 
/* 58 */     } while (target.compareTo(term()) > 0);
/* 59 */     return true;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermFreqVector,"package org.apache.lucene.index;
public interface TermFreqVector {
  String getField();
  int size();
  String[] getTerms();
  int[] getTermFrequencies();
  int indexOf(String paramString);
  int[] indexesOf(String[] paramArrayOfString, int paramInt1, int paramInt2);
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermFreqVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class TermInfo
/*    */ {
/* 23 */   int docFreq = 0;
/*    */   
/* 25 */   long freqPointer = 0L;
/* 26 */   long proxPointer = 0L;
/*    */   int skipOffset;
/*    */   
/*    */   TermInfo() {}
/*    */   
/*    */   TermInfo(int df, long fp, long pp) {
/* 32 */     this.docFreq = df;
/* 33 */     this.freqPointer = fp;
/* 34 */     this.proxPointer = pp;
/*    */   }
/*    */   
/*    */   TermInfo(TermInfo ti) {
/* 38 */     this.docFreq = ti.docFreq;
/* 39 */     this.freqPointer = ti.freqPointer;
/* 40 */     this.proxPointer = ti.proxPointer;
/* 41 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ 
/*    */   
/*    */   final void set(int docFreq, long freqPointer, long proxPointer, int skipOffset) {
/* 46 */     this.docFreq = docFreq;
/* 47 */     this.freqPointer = freqPointer;
/* 48 */     this.proxPointer = proxPointer;
/* 49 */     this.skipOffset = skipOffset;
/*    */   }
/*    */   
/*    */   final void set(TermInfo ti) {
/* 53 */     this.docFreq = ti.docFreq;
/* 54 */     this.freqPointer = ti.freqPointer;
/* 55 */     this.proxPointer = ti.proxPointer;
/* 56 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosReader
/*     */ {
/*     */   private Directory directory;
/*     */   private String segment;
/*     */   private FieldInfos fieldInfos;
/*  32 */   private ThreadLocal enumerators = new ThreadLocal();
/*     */   
/*     */   private SegmentTermEnum origEnum;
/*     */   private long size;
/*  36 */   private Term[] indexTerms = null;
/*     */   
/*     */   private TermInfo[] indexInfos;
/*     */   
/*     */   private long[] indexPointers;
/*     */   private SegmentTermEnum indexEnum;
/*     */   
/*     */   TermInfosReader(Directory dir, String seg, FieldInfos fis) throws IOException {
/*  44 */     this.directory = dir;
/*  45 */     this.segment = seg;
/*  46 */     this.fieldInfos = fis;
/*     */     
/*  48 */     this.origEnum = new SegmentTermEnum(this.directory.openInput(this.segment + "".tis""), this.fieldInfos, false);
/*     */     
/*  50 */     this.size = this.origEnum.size;
/*     */     
/*  52 */     this.indexEnum = new SegmentTermEnum(this.directory.openInput(this.segment + "".tii""), this.fieldInfos, true);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  59 */   protected void finalize() { this.enumerators.set(null); }
/*     */ 
/*     */ 
/*     */   
/*  63 */   public int getSkipInterval() { return this.origEnum.skipInterval; }
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/*  67 */     if (this.origEnum != null)
/*  68 */       this.origEnum.close(); 
/*  69 */     if (this.indexEnum != null) {
/*  70 */       this.indexEnum.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  75 */   final long size() { return this.size; }
/*     */ 
/*     */   
/*     */   private SegmentTermEnum getEnum() {
/*  79 */     SegmentTermEnum termEnum = this.enumerators.get();
/*  80 */     if (termEnum == null) {
/*  81 */       termEnum = terms();
/*  82 */       this.enumerators.set(termEnum);
/*     */     } 
/*  84 */     return termEnum;
/*     */   }
/*     */   
/*     */   private synchronized void ensureIndexIsRead() throws IOException {
/*  88 */     if (this.indexTerms != null)
/*     */       return; 
/*     */     try {
/*  91 */       int indexSize = (int)this.indexEnum.size;
/*     */       
/*  93 */       this.indexTerms = new Term[indexSize];
/*  94 */       this.indexInfos = new TermInfo[indexSize];
/*  95 */       this.indexPointers = new long[indexSize];
/*     */       
/*  97 */       for (int i = 0; this.indexEnum.next(); i++) {
/*  98 */         this.indexTerms[i] = this.indexEnum.term();
/*  99 */         this.indexInfos[i] = this.indexEnum.termInfo();
/* 100 */         this.indexPointers[i] = this.indexEnum.indexPointer;
/*     */       } 
/*     */     } finally {
/* 103 */       this.indexEnum.close();
/* 104 */       this.indexEnum = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final int getIndexOffset(Term term) {
/* 110 */     int lo = 0;
/* 111 */     int hi = this.indexTerms.length - 1;
/*     */     
/* 113 */     while (hi >= lo) {
/* 114 */       int mid = lo + hi >> 1;
/* 115 */       int delta = term.compareTo(this.indexTerms[mid]);
/* 116 */       if (delta < 0) {
/* 117 */         hi = mid - 1; continue;
/* 118 */       }  if (delta > 0) {
/* 119 */         lo = mid + 1; continue;
/*     */       } 
/* 121 */       return mid;
/*     */     } 
/* 123 */     return hi;
/*     */   }
/*     */ 
/*     */   
/* 127 */   private final void seekEnum(int indexOffset) throws IOException { getEnum().seek(this.indexPointers[indexOffset], indexOffset * (getEnum()).indexInterval - 1, this.indexTerms[indexOffset], this.indexInfos[indexOffset]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfo get(Term term) throws IOException {
/* 134 */     if (this.size == 0L) return null;
/*     */     
/* 136 */     ensureIndexIsRead();
/*     */ 
/*     */     
/* 139 */     SegmentTermEnum enumerator = getEnum();
/* 140 */     if (enumerator.term() != null && ((enumerator.prev() != null && term.compareTo(enumerator.prev()) > 0) || term.compareTo(enumerator.term()) >= 0)) {
/*     */ 
/*     */       
/* 143 */       int enumOffset = (int)(enumerator.position / enumerator.indexInterval) + 1;
/* 144 */       if (this.indexTerms.length == enumOffset || term.compareTo(this.indexTerms[enumOffset]) < 0)
/*     */       {
/* 146 */         return scanEnum(term);
/*     */       }
/*     */     } 
/*     */     
/* 150 */     seekEnum(getIndexOffset(term));
/* 151 */     return scanEnum(term);
/*     */   }
/*     */ 
/*     */   
/*     */   private final TermInfo scanEnum(Term term) throws IOException {
/* 156 */     SegmentTermEnum enumerator = getEnum();
/* 157 */     enumerator.scanTo(term);
/* 158 */     if (enumerator.term() != null && term.compareTo(enumerator.term()) == 0) {
/* 159 */       return enumerator.termInfo();
/*     */     }
/* 161 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   final Term get(int position) throws IOException {
/* 166 */     if (this.size == 0L) return null;
/*     */     
/* 168 */     SegmentTermEnum enumerator = getEnum();
/* 169 */     if (enumerator != null && enumerator.term() != null && position >= enumerator.position && position < enumerator.position + enumerator.indexInterval)
/*     */     {
/*     */       
/* 172 */       return scanEnum(position);
/*     */     }
/* 174 */     seekEnum(position / enumerator.indexInterval);
/* 175 */     return scanEnum(position);
/*     */   }
/*     */   
/*     */   private final Term scanEnum(int position) throws IOException {
/* 179 */     SegmentTermEnum enumerator = getEnum();
/* 180 */     while (enumerator.position < position) {
/* 181 */       if (!enumerator.next())
/* 182 */         return null; 
/*     */     } 
/* 184 */     return enumerator.term();
/*     */   }
/*     */ 
/*     */   
/*     */   final long getPosition(Term term) throws IOException {
/* 189 */     if (this.size == 0L) return -1L;
/*     */     
/* 191 */     ensureIndexIsRead();
/* 192 */     int indexOffset = getIndexOffset(term);
/* 193 */     seekEnum(indexOffset);
/*     */     
/* 195 */     SegmentTermEnum enumerator = getEnum();
/* 196 */     while (term.compareTo(enumerator.term()) > 0 && enumerator.next());
/*     */     
/* 198 */     if (term.compareTo(enumerator.term()) == 0) {
/* 199 */       return enumerator.position;
/*     */     }
/* 201 */     return -1L;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 206 */   public SegmentTermEnum terms() { return (SegmentTermEnum)this.origEnum.clone(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public SegmentTermEnum terms(Term term) throws IOException {
/* 211 */     get(term);
/* 212 */     return (SegmentTermEnum)getEnum().clone();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermInfosReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.StringHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosWriter
/*     */ {
/*     */   public static final int FORMAT = -2;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput output;
/*  34 */   private Term lastTerm = new Term("""", """");
/*  35 */   private TermInfo lastTi = new TermInfo();
/*  36 */   private long size = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   int indexInterval = 128;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   int skipInterval = 16;
/*     */   
/*  59 */   private long lastIndexPointer = 0L;
/*     */   
/*     */   private boolean isIndex = false;
/*  62 */   private TermInfosWriter other = null;
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval) throws IOException {
/*  67 */     initialize(directory, segment, fis, interval, false);
/*  68 */     this.other = new TermInfosWriter(directory, segment, fis, interval, true);
/*  69 */     this.other.other = this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  74 */   private TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval, boolean isIndex) throws IOException { initialize(directory, segment, fis, interval, isIndex); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initialize(Directory directory, String segment, FieldInfos fis, int interval, boolean isi) throws IOException {
/*  79 */     this.indexInterval = interval;
/*  80 */     this.fieldInfos = fis;
/*  81 */     this.isIndex = isi;
/*  82 */     this.output = directory.createOutput(segment + (this.isIndex ? "".tii"" : "".tis""));
/*  83 */     this.output.writeInt(-2);
/*  84 */     this.output.writeLong(0L);
/*  85 */     this.output.writeInt(this.indexInterval);
/*  86 */     this.output.writeInt(this.skipInterval);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void add(Term term, TermInfo ti) throws IOException {
/*  94 */     if (!this.isIndex && term.compareTo(this.lastTerm) <= 0) {
/*  95 */       throw new IOException(""term out of order (\"""" + term + ""\"".compareTo(\"""" + this.lastTerm + ""\"") <= 0)"");
/*     */     }
/*  97 */     if (ti.freqPointer < this.lastTi.freqPointer) {
/*  98 */       throw new IOException(""freqPointer out of order ("" + ti.freqPointer + "" < "" + this.lastTi.freqPointer + "")"");
/*     */     }
/* 100 */     if (ti.proxPointer < this.lastTi.proxPointer) {
/* 101 */       throw new IOException(""proxPointer out of order ("" + ti.proxPointer + "" < "" + this.lastTi.proxPointer + "")"");
/*     */     }
/*     */     
/* 104 */     if (!this.isIndex && this.size % this.indexInterval == 0L) {
/* 105 */       this.other.add(this.lastTerm, this.lastTi);
/*     */     }
/* 107 */     writeTerm(term);
/* 108 */     this.output.writeVInt(ti.docFreq);
/* 109 */     this.output.writeVLong(ti.freqPointer - this.lastTi.freqPointer);
/* 110 */     this.output.writeVLong(ti.proxPointer - this.lastTi.proxPointer);
/*     */     
/* 112 */     if (ti.docFreq >= this.skipInterval) {
/* 113 */       this.output.writeVInt(ti.skipOffset);
/*     */     }
/*     */     
/* 116 */     if (this.isIndex) {
/* 117 */       this.output.writeVLong(this.other.output.getFilePointer() - this.lastIndexPointer);
/* 118 */       this.lastIndexPointer = this.other.output.getFilePointer();
/*     */     } 
/*     */     
/* 121 */     this.lastTi.set(ti);
/* 122 */     this.size++;
/*     */   }
/*     */ 
/*     */   
/*     */   private final void writeTerm(Term term) throws IOException {
/* 127 */     int start = StringHelper.stringDifference(this.lastTerm.text, term.text);
/* 128 */     int length = term.text.length() - start;
/*     */     
/* 130 */     this.output.writeVInt(start);
/* 131 */     this.output.writeVInt(length);
/* 132 */     this.output.writeChars(term.text, start, length);
/*     */     
/* 134 */     this.output.writeVInt(this.fieldInfos.fieldNumber(term.field));
/*     */     
/* 136 */     this.lastTerm = term;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/* 143 */     this.output.seek(4L);
/* 144 */     this.output.writeLong(this.size);
/* 145 */     this.output.close();
/*     */     
/* 147 */     if (!this.isIndex)
/* 148 */       this.other.close(); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermInfosWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositions,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermPositions extends TermDocs {
  int nextPosition() throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositionVector,"package org.apache.lucene.index;
public interface TermPositionVector extends TermFreqVector {
  int[] getTermPositions(int paramInt);
  TermVectorOffsetInfo[] getOffsets(int paramInt);
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorOffsetInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermVectorOffsetInfo
/*    */ {
/* 20 */   public static final TermVectorOffsetInfo[] EMPTY_OFFSET_INFO = new TermVectorOffsetInfo[0];
/*    */   
/*    */   private int startOffset;
/*    */   private int endOffset;
/*    */   
/*    */   public TermVectorOffsetInfo() {}
/*    */   
/*    */   public TermVectorOffsetInfo(int startOffset, int endOffset) {
/* 28 */     this.endOffset = endOffset;
/* 29 */     this.startOffset = startOffset;
/*    */   }
/*    */ 
/*    */   
/* 33 */   public int getEndOffset() { return this.endOffset; }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public void setEndOffset(int endOffset) { this.endOffset = endOffset; }
/*    */ 
/*    */ 
/*    */   
/* 41 */   public int getStartOffset() { return this.startOffset; }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public void setStartOffset(int startOffset) { this.startOffset = startOffset; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 49 */     if (this == o) return true; 
/* 50 */     if (!(o instanceof TermVectorOffsetInfo)) return false;
/*    */     
/* 52 */     TermVectorOffsetInfo termVectorOffsetInfo = (TermVectorOffsetInfo)o;
/*    */     
/* 54 */     if (this.endOffset != termVectorOffsetInfo.endOffset) return false; 
/* 55 */     if (this.startOffset != termVectorOffsetInfo.startOffset) return false;
/*    */     
/* 57 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   public int hashCode() {
/* 62 */     int result = this.startOffset;
/* 63 */     result = 29 * result + this.endOffset;
/* 64 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermVectorOffsetInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class TermVectorsReader
/*     */   implements Cloneable
/*     */ {
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexInput tvx;
/*     */   private IndexInput tvd;
/*     */   private IndexInput tvf;
/*     */   private int size;
/*     */   private int tvdFormat;
/*     */   private int tvfFormat;
/*     */   
/*     */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos) throws IOException {
/*  40 */     if (d.fileExists(segment + "".tvx"")) {
/*  41 */       this.tvx = d.openInput(segment + "".tvx"");
/*  42 */       checkValidFormat(this.tvx);
/*  43 */       this.tvd = d.openInput(segment + "".tvd"");
/*  44 */       this.tvdFormat = checkValidFormat(this.tvd);
/*  45 */       this.tvf = d.openInput(segment + "".tvf"");
/*  46 */       this.tvfFormat = checkValidFormat(this.tvf);
/*  47 */       this.size = (int)this.tvx.length() / 8;
/*     */     } 
/*     */     
/*  50 */     this.fieldInfos = fieldInfos;
/*     */   }
/*     */ 
/*     */   
/*     */   private int checkValidFormat(IndexInput in) throws IOException {
/*  55 */     int format = in.readInt();
/*  56 */     if (format > 2)
/*     */     {
/*  58 */       throw new IOException(""Incompatible format version: "" + format + "" expected "" + '\002' + "" or less"");
/*     */     }
/*     */     
/*  61 */     return format;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void close() throws IOException {
/*  67 */     IOException keep = null;
/*  68 */     if (this.tvx != null) try { this.tvx.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  69 */         if (this.tvd != null) try { this.tvd.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  70 */         if (this.tvf != null) try { this.tvf.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  71 */         if (keep != null) throw (IOException)keep.fillInStackTrace();
/*     */   
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector get(int docNum, String field) throws IOException {
/*  91 */     int fieldNumber = this.fieldInfos.fieldNumber(field);
/*  92 */     TermFreqVector result = null;
/*  93 */     if (this.tvx != null) {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  98 */       this.tvx.seek(docNum * 8L + 4L);
/*     */       
/* 100 */       long position = this.tvx.readLong();
/*     */       
/* 102 */       this.tvd.seek(position);
/* 103 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 108 */       int number = 0;
/* 109 */       int found = -1;
/* 110 */       for (int i = 0; i < fieldCount; i++) {
/* 111 */         if (this.tvdFormat == 2) {
/* 112 */           number = this.tvd.readVInt();
/*     */         } else {
/* 114 */           number += this.tvd.readVInt();
/*     */         } 
/* 116 */         if (number == fieldNumber) {
/* 117 */           found = i;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 122 */       if (found != -1) {
/*     */         
/* 124 */         position = 0L;
/* 125 */         for (int i = 0; i <= found; i++) {
/* 126 */           position += this.tvd.readVLong();
/*     */         }
/* 128 */         result = readTermVector(field, position);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 135 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector[] get(int docNum) throws IOException {
/* 146 */     Object[] arrayOfObject = null;
/*     */     
/* 148 */     if (this.tvx != null) {
/*     */       
/* 150 */       this.tvx.seek(docNum * 8L + 4L);
/* 151 */       long position = this.tvx.readLong();
/*     */       
/* 153 */       this.tvd.seek(position);
/* 154 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */       
/* 157 */       if (fieldCount != 0) {
/* 158 */         int number = 0;
/* 159 */         String[] fields = new String[fieldCount];
/*     */         
/* 161 */         for (int i = 0; i < fieldCount; i++) {
/* 162 */           if (this.tvdFormat == 2) {
/* 163 */             number = this.tvd.readVInt();
/*     */           } else {
/* 165 */             number += this.tvd.readVInt();
/*     */           } 
/* 167 */           fields[i] = this.fieldInfos.fieldName(number);
/*     */         } 
/*     */ 
/*     */         
/* 171 */         position = 0L;
/* 172 */         long[] tvfPointers = new long[fieldCount];
/* 173 */         for (int i = 0; i < fieldCount; i++) {
/* 174 */           position += this.tvd.readVLong();
/* 175 */           tvfPointers[i] = position;
/*     */         } 
/*     */         
/* 178 */         arrayOfObject = (Object[])readTermVectors(fields, tvfPointers);
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 183 */     return (TermFreqVector[])arrayOfObject;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private SegmentTermVector[] readTermVectors(String[] fields, long[] tvfPointers) throws IOException {
/* 189 */     SegmentTermVector[] res = new SegmentTermVector[fields.length];
/* 190 */     for (int i = 0; i < fields.length; i++) {
/* 191 */       res[i] = readTermVector(fields[i], tvfPointers[i]);
/*     */     }
/* 193 */     return res;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private SegmentTermVector readTermVector(String field, long tvfPointer) throws IOException {
/*     */     SegmentTermVector tv;
/*     */     boolean storeOffsets, storePositions;
/* 208 */     this.tvf.seek(tvfPointer);
/*     */     
/* 210 */     int numTerms = this.tvf.readVInt();
/*     */ 
/*     */     
/* 213 */     if (numTerms == 0) {
/* 214 */       return new SegmentTermVector(field, null, null);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 219 */     if (this.tvfFormat == 2) {
/* 220 */       byte bits = this.tvf.readByte();
/* 221 */       storePositions = ((bits & 0x1) != 0);
/* 222 */       storeOffsets = ((bits & 0x2) != 0);
/*     */     } else {
/*     */       
/* 225 */       this.tvf.readVInt();
/* 226 */       storePositions = false;
/* 227 */       storeOffsets = false;
/*     */     } 
/*     */     
/* 230 */     String[] terms = new String[numTerms];
/* 231 */     int[] termFreqs = new int[numTerms];
/*     */ 
/*     */     
/* 234 */     int[][] positions = (int[][])null;
/* 235 */     TermVectorOffsetInfo[][] offsets = (TermVectorOffsetInfo[][])null;
/* 236 */     if (storePositions)
/* 237 */       positions = new int[numTerms][]; 
/* 238 */     if (storeOffsets) {
/* 239 */       offsets = new TermVectorOffsetInfo[numTerms][];
/*     */     }
/* 241 */     int start = 0;
/* 242 */     int deltaLength = 0;
/* 243 */     int totalLength = 0;
/* 244 */     char[] buffer = new char[10];
/* 245 */     char[] previousBuffer = new char[0];
/*     */     
/* 247 */     for (int i = 0; i < numTerms; i++) {
/* 248 */       start = this.tvf.readVInt();
/* 249 */       deltaLength = this.tvf.readVInt();
/* 250 */       totalLength = start + deltaLength;
/* 251 */       if (buffer.length < totalLength) {
/* 252 */         buffer = null;
/* 253 */         buffer = new char[totalLength];
/*     */         
/* 255 */         if (start > 0) {
/* 256 */           System.arraycopy(previousBuffer, 0, buffer, 0, start);
/*     */         }
/*     */       } 
/* 259 */       this.tvf.readChars(buffer, start, deltaLength);
/* 260 */       terms[i] = new String(buffer, 0, totalLength);
/* 261 */       previousBuffer = buffer;
/* 262 */       int freq = this.tvf.readVInt();
/* 263 */       termFreqs[i] = freq;
/*     */       
/* 265 */       if (storePositions) {
/* 266 */         int[] pos = new int[freq];
/* 267 */         positions[i] = pos;
/* 268 */         int prevPosition = 0;
/* 269 */         for (int j = 0; j < freq; j++) {
/*     */           
/* 271 */           pos[j] = prevPosition + this.tvf.readVInt();
/* 272 */           prevPosition = pos[j];
/*     */         } 
/*     */       } 
/*     */       
/* 276 */       if (storeOffsets) {
/* 277 */         TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];
/* 278 */         offsets[i] = offs;
/* 279 */         int prevOffset = 0;
/* 280 */         for (int j = 0; j < freq; j++) {
/* 281 */           int startOffset = prevOffset + this.tvf.readVInt();
/* 282 */           int endOffset = startOffset + this.tvf.readVInt();
/* 283 */           offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);
/* 284 */           prevOffset = endOffset;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 290 */     if (storePositions || storeOffsets) {
/* 291 */       tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);
/*     */     } else {
/*     */       
/* 294 */       tv = new SegmentTermVector(field, terms, termFreqs);
/*     */     } 
/* 296 */     return tv;
/*     */   }
/*     */ 
/*     */   
/*     */   protected Object clone() {
/* 301 */     if (this.tvx == null || this.tvd == null || this.tvf == null) {
/* 302 */       return null;
/*     */     }
/* 304 */     TermVectorsReader clone = null;
/*     */     try {
/* 306 */       clone = (TermVectorsReader)super.clone();
/* 307 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 309 */     clone.tvx = (IndexInput)this.tvx.clone();
/* 310 */     clone.tvd = (IndexInput)this.tvd.clone();
/* 311 */     clone.tvf = (IndexInput)this.tvf.clone();
/*     */     
/* 313 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermVectorsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.StringHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermVectorsWriter
/*     */ {
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 1;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 2;
/*     */   static final int FORMAT_VERSION = 2;
/*     */   static final int FORMAT_SIZE = 4;
/*     */   static final String TVX_EXTENSION = "".tvx"";
/*     */   static final String TVD_EXTENSION = "".tvd"";
/*     */   static final String TVF_EXTENSION = "".tvf"";
/*  64 */   private IndexOutput tvx = null; private IndexOutput tvd = null; private IndexOutput tvf = null;
/*  65 */   private Vector fields = null;
/*  66 */   private Vector terms = null;
/*     */   
/*     */   private FieldInfos fieldInfos;
/*  69 */   private TVField currentField = null;
/*  70 */   private long currentDocPointer = -1L;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermVectorsWriter(Directory directory, String segment, FieldInfos fieldInfos) throws IOException {
/*  76 */     this.tvx = directory.createOutput(segment + "".tvx"");
/*  77 */     this.tvx.writeInt(2);
/*  78 */     this.tvd = directory.createOutput(segment + "".tvd"");
/*  79 */     this.tvd.writeInt(2);
/*  80 */     this.tvf = directory.createOutput(segment + "".tvf"");
/*  81 */     this.tvf.writeInt(2);
/*     */     
/*  83 */     this.fieldInfos = fieldInfos;
/*  84 */     this.fields = new Vector(fieldInfos.size());
/*  85 */     this.terms = new Vector();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void openDocument() throws IOException {
/*  91 */     closeDocument();
/*  92 */     this.currentDocPointer = this.tvd.getFilePointer();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void closeDocument() throws IOException {
/*  98 */     if (isDocumentOpen()) {
/*  99 */       closeField();
/* 100 */       writeDoc();
/* 101 */       this.fields.clear();
/* 102 */       this.currentDocPointer = -1L;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 108 */   public final boolean isDocumentOpen() { return (this.currentDocPointer != -1L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void openField(String field) throws IOException {
/* 118 */     FieldInfo fieldInfo = this.fieldInfos.fieldInfo(field);
/* 119 */     openField(fieldInfo.number, fieldInfo.storePositionWithTermVector, fieldInfo.storeOffsetWithTermVector);
/*     */   }
/*     */ 
/*     */   
/*     */   private void openField(int fieldNumber, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) throws IOException {
/* 124 */     if (!isDocumentOpen())
/* 125 */       throw new IllegalStateException(""Cannot open field when no document is open.""); 
/* 126 */     closeField();
/* 127 */     this.currentField = new TVField(fieldNumber, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void closeField() throws IOException {
/* 135 */     if (isFieldOpen()) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 141 */       writeField();
/* 142 */       this.fields.add(this.currentField);
/* 143 */       this.terms.clear();
/* 144 */       this.currentField = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public final boolean isFieldOpen() { return (this.currentField != null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 161 */   public final void addTerm(String termText, int freq) { addTerm(termText, freq, null, null); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void addTerm(String termText, int freq, int[] positions, TermVectorOffsetInfo[] offsets) {
/* 166 */     if (!isDocumentOpen())
/* 167 */       throw new IllegalStateException(""Cannot add terms when document is not open""); 
/* 168 */     if (!isFieldOpen()) {
/* 169 */       throw new IllegalStateException(""Cannot add terms when field is not open"");
/*     */     }
/* 171 */     addTermInternal(termText, freq, positions, offsets);
/*     */   }
/*     */   
/*     */   private final void addTermInternal(String termText, int freq, int[] positions, TermVectorOffsetInfo[] offsets) {
/* 175 */     TVTerm term = new TVTerm();
/* 176 */     term.termText = termText;
/* 177 */     term.freq = freq;
/* 178 */     term.positions = positions;
/* 179 */     term.offsets = offsets;
/* 180 */     this.terms.add(term);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void addAllDocVectors(TermFreqVector[] vectors) throws IOException {
/* 192 */     openDocument();
/*     */     
/* 194 */     if (vectors != null) {
/* 195 */       for (int i = 0; i < vectors.length; i++) {
/* 196 */         boolean storePositionWithTermVector = false;
/* 197 */         boolean storeOffsetWithTermVector = false;
/*     */ 
/*     */         
/*     */         try {
/* 201 */           TermPositionVector tpVector = (TermPositionVector)vectors[i];
/*     */           
/* 203 */           if (tpVector.size() > 0 && tpVector.getTermPositions(0) != null)
/* 204 */             storePositionWithTermVector = true; 
/* 205 */           if (tpVector.size() > 0 && tpVector.getOffsets(0) != null) {
/* 206 */             storeOffsetWithTermVector = true;
/*     */           }
/* 208 */           FieldInfo fieldInfo = this.fieldInfos.fieldInfo(tpVector.getField());
/* 209 */           openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */           
/* 211 */           for (int j = 0; j < tpVector.size(); j++) {
/* 212 */             addTermInternal(tpVector.getTerms()[j], tpVector.getTermFrequencies()[j], tpVector.getTermPositions(j), tpVector.getOffsets(j));
/*     */           }
/*     */           
/* 215 */           closeField();
/*     */         }
/* 217 */         catch (ClassCastException ignore) {
/*     */           
/* 219 */           TermFreqVector tfVector = vectors[i];
/*     */           
/* 221 */           FieldInfo fieldInfo = this.fieldInfos.fieldInfo(tfVector.getField());
/* 222 */           openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */           
/* 224 */           for (int j = 0; j < tfVector.size(); j++) {
/* 225 */             addTermInternal(tfVector.getTerms()[j], tfVector.getTermFrequencies()[j], null, null);
/*     */           }
/* 227 */           closeField();
/*     */         } 
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/* 233 */     closeDocument();
/*     */   }
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/*     */     try {
/* 239 */       closeDocument();
/*     */     }
/*     */     finally {
/*     */       
/* 243 */       IOException keep = null;
/* 244 */       if (this.tvx != null)
/*     */         try {
/* 246 */           this.tvx.close();
/* 247 */         } catch (IOException e) {
/* 248 */           if (keep == null) keep = e; 
/*     */         }  
/* 250 */       if (this.tvd != null)
/*     */         try {
/* 252 */           this.tvd.close();
/* 253 */         } catch (IOException e) {
/* 254 */           if (keep == null) keep = e; 
/*     */         }  
/* 256 */       if (this.tvf != null)
/*     */         try {
/* 258 */           this.tvf.close();
/* 259 */         } catch (IOException e) {
/* 260 */           if (keep == null) keep = e; 
/*     */         }  
/* 262 */       if (keep != null) throw (IOException)keep.fillInStackTrace();
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void writeField() throws IOException {
/* 270 */     this.currentField.tvfPointer = this.tvf.getFilePointer();
/*     */ 
/*     */     
/* 273 */     int size = this.terms.size();
/* 274 */     this.tvf.writeVInt(size);
/*     */     
/* 276 */     boolean storePositions = this.currentField.storePositions;
/* 277 */     boolean storeOffsets = this.currentField.storeOffsets;
/* 278 */     byte bits = 0;
/* 279 */     if (storePositions)
/* 280 */       bits = (byte)(bits | 0x1); 
/* 281 */     if (storeOffsets)
/* 282 */       bits = (byte)(bits | 0x2); 
/* 283 */     this.tvf.writeByte(bits);
/*     */     
/* 285 */     String lastTermText = """";
/* 286 */     for (int i = 0; i < size; i++) {
/* 287 */       TVTerm term = this.terms.elementAt(i);
/* 288 */       int start = StringHelper.stringDifference(lastTermText, term.termText);
/* 289 */       int length = term.termText.length() - start;
/* 290 */       this.tvf.writeVInt(start);
/* 291 */       this.tvf.writeVInt(length);
/* 292 */       this.tvf.writeChars(term.termText, start, length);
/* 293 */       this.tvf.writeVInt(term.freq);
/* 294 */       lastTermText = term.termText;
/*     */       
/* 296 */       if (storePositions) {
/* 297 */         if (term.positions == null) {
/* 298 */           throw new IllegalStateException(""Trying to write positions that are null!"");
/*     */         }
/*     */         
/* 301 */         int position = 0;
/* 302 */         for (int j = 0; j < term.freq; j++) {
/* 303 */           this.tvf.writeVInt(term.positions[j] - position);
/* 304 */           position = term.positions[j];
/*     */         } 
/*     */       } 
/*     */       
/* 308 */       if (storeOffsets) {
/* 309 */         if (term.offsets == null) {
/* 310 */           throw new IllegalStateException(""Trying to write offsets that are null!"");
/*     */         }
/*     */         
/* 313 */         int position = 0;
/* 314 */         for (int j = 0; j < term.freq; j++) {
/* 315 */           this.tvf.writeVInt(term.offsets[j].getStartOffset() - position);
/* 316 */           this.tvf.writeVInt(term.offsets[j].getEndOffset() - term.offsets[j].getStartOffset());
/* 317 */           position = term.offsets[j].getEndOffset();
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void writeDoc() throws IOException {
/* 324 */     if (isFieldOpen()) {
/* 325 */       throw new IllegalStateException(""Field is still open while writing document"");
/*     */     }
/*     */     
/* 328 */     this.tvx.writeLong(this.currentDocPointer);
/*     */ 
/*     */     
/* 331 */     int size = this.fields.size();
/*     */ 
/*     */     
/* 334 */     this.tvd.writeVInt(size);
/*     */ 
/*     */     
/* 337 */     for (int i = 0; i < size; i++) {
/* 338 */       TVField field = this.fields.elementAt(i);
/* 339 */       this.tvd.writeVInt(field.number);
/*     */     } 
/*     */ 
/*     */     
/* 343 */     long lastFieldPointer = 0L;
/* 344 */     for (int i = 0; i < size; i++) {
/* 345 */       TVField field = this.fields.elementAt(i);
/* 346 */       this.tvd.writeVLong(field.tvfPointer - lastFieldPointer);
/* 347 */       lastFieldPointer = field.tvfPointer;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private static class TVField
/*     */   {
/*     */     int number;
/* 355 */     long tvfPointer = 0L; boolean storePositions = false;
/*     */     boolean storeOffsets = false;
/*     */     
/*     */     TVField(int number, boolean storePos, boolean storeOff) {
/* 359 */       this.number = number;
/* 360 */       this.storePositions = storePos;
/* 361 */       this.storeOffsets = storeOff;
/*     */     }
/*     */   }
/*     */   
/*     */   private static class TVTerm {
/*     */     String termText;
/* 367 */     int freq = 0;
/* 368 */     int[] positions = null; private TVTerm() {}
/* 369 */     TermVectorOffsetInfo[] offsets = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\index\TermVectorsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.CharStream,"package org.apache.lucene.queryParser;
import java.io.IOException;
public interface CharStream {
  char readChar() throws IOException;
  int getEndColumn();
  int getEndLine();
  int getBeginColumn();
  int getBeginLine();
  void backup(int paramInt);
  char BeginToken() throws IOException;
  String GetImage();
  char[] GetSuffix(int paramInt);
  void Done();
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\CharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.FastCharStream,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FastCharStream
/*     */   implements CharStream
/*     */ {
/*  27 */   char[] buffer = null;
/*     */   
/*  29 */   int bufferLength = 0;
/*  30 */   int bufferPosition = 0;
/*     */   
/*  32 */   int tokenStart = 0;
/*  33 */   int bufferStart = 0;
/*     */ 
/*     */   
/*     */   Reader input;
/*     */ 
/*     */   
/*  39 */   public FastCharStream(Reader r) { this.input = r; }
/*     */ 
/*     */   
/*     */   public final char readChar() throws IOException {
/*  43 */     if (this.bufferPosition >= this.bufferLength)
/*  44 */       refill(); 
/*  45 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   private final void refill() throws IOException {
/*  49 */     int newPosition = this.bufferLength - this.tokenStart;
/*     */     
/*  51 */     if (this.tokenStart == 0) {
/*  52 */       if (this.buffer == null) {
/*  53 */         this.buffer = new char[2048];
/*  54 */       } else if (this.bufferLength == this.buffer.length) {
/*  55 */         char[] newBuffer = new char[this.buffer.length * 2];
/*  56 */         System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferLength);
/*  57 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } else {
/*  60 */       System.arraycopy(this.buffer, this.tokenStart, this.buffer, 0, newPosition);
/*     */     } 
/*     */     
/*  63 */     this.bufferLength = newPosition;
/*  64 */     this.bufferPosition = newPosition;
/*  65 */     this.bufferStart += this.tokenStart;
/*  66 */     this.tokenStart = 0;
/*     */     
/*  68 */     int charsRead = this.input.read(this.buffer, newPosition, this.buffer.length - newPosition);
/*     */     
/*  70 */     if (charsRead == -1) {
/*  71 */       throw new IOException(""read past eof"");
/*     */     }
/*  73 */     this.bufferLength += charsRead;
/*     */   }
/*     */   
/*     */   public final char BeginToken() throws IOException {
/*  77 */     this.tokenStart = this.bufferPosition;
/*  78 */     return readChar();
/*     */   }
/*     */ 
/*     */   
/*  82 */   public final void backup(int amount) { this.bufferPosition -= amount; }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public final String GetImage() { return new String(this.buffer, this.tokenStart, this.bufferPosition - this.tokenStart); }
/*     */ 
/*     */   
/*     */   public final char[] GetSuffix(int len) {
/*  90 */     char[] value = new char[len];
/*  91 */     System.arraycopy(this.buffer, this.bufferPosition - len, value, 0, len);
/*  92 */     return value;
/*     */   }
/*     */   
/*     */   public final void Done() {
/*     */     try {
/*  97 */       this.input.close();
/*  98 */     } catch (IOException e) {
/*  99 */       System.err.println(""Caught: "" + e + ""; ignoring."");
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 104 */   public final int getColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 107 */   public final int getLine() { return 1; }
/*     */ 
/*     */   
/* 110 */   public final int getEndColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 113 */   public final int getEndLine() { return 1; }
/*     */ 
/*     */   
/* 116 */   public final int getBeginColumn() { return this.bufferStart + this.tokenStart; }
/*     */ 
/*     */   
/* 119 */   public final int getBeginLine() { return 1; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\FastCharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.MultiFieldQueryParser,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.search.BooleanClause;
/*     */ import org.apache.lucene.search.BooleanQuery;
/*     */ import org.apache.lucene.search.MultiPhraseQuery;
/*     */ import org.apache.lucene.search.PhraseQuery;
/*     */ import org.apache.lucene.search.Query;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiFieldQueryParser
/*     */   extends QueryParser
/*     */ {
/*     */   private String[] fields;
/*     */   
/*     */   public MultiFieldQueryParser(String[] fields, Analyzer analyzer) {
/*  60 */     super(null, analyzer);
/*  61 */     this.fields = fields;
/*     */   }
/*     */   
/*     */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/*  65 */     if (field == null) {
/*  66 */       Vector clauses = new Vector();
/*  67 */       for (int i = 0; i < this.fields.length; i++) {
/*  68 */         Query q = super.getFieldQuery(this.fields[i], queryText);
/*  69 */         if (q != null) {
/*  70 */           if (q instanceof PhraseQuery) {
/*  71 */             ((PhraseQuery)q).setSlop(slop);
/*     */           }
/*  73 */           if (q instanceof MultiPhraseQuery) {
/*  74 */             ((MultiPhraseQuery)q).setSlop(slop);
/*     */           }
/*  76 */           clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
/*     */         } 
/*     */       } 
/*  79 */       if (clauses.size() == 0)
/*  80 */         return null; 
/*  81 */       return getBooleanQuery(clauses, true);
/*     */     } 
/*  83 */     return super.getFieldQuery(field, queryText);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  88 */   protected Query getFieldQuery(String field, String queryText) throws ParseException { return getFieldQuery(field, queryText, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/*  94 */     if (field == null) {
/*  95 */       Vector clauses = new Vector();
/*  96 */       for (int i = 0; i < this.fields.length; i++) {
/*  97 */         clauses.add(new BooleanClause(super.getFuzzyQuery(this.fields[i], termStr, minSimilarity), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 100 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 102 */     return super.getFuzzyQuery(field, termStr, minSimilarity);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/* 107 */     if (field == null) {
/* 108 */       Vector clauses = new Vector();
/* 109 */       for (int i = 0; i < this.fields.length; i++) {
/* 110 */         clauses.add(new BooleanClause(super.getPrefixQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 113 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 115 */     return super.getPrefixQuery(field, termStr);
/*     */   }
/*     */   
/*     */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/* 119 */     if (field == null) {
/* 120 */       Vector clauses = new Vector();
/* 121 */       for (int i = 0; i < this.fields.length; i++) {
/* 122 */         clauses.add(new BooleanClause(super.getWildcardQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 125 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 127 */     return super.getWildcardQuery(field, termStr);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/* 132 */     if (field == null) {
/* 133 */       Vector clauses = new Vector();
/* 134 */       for (int i = 0; i < this.fields.length; i++) {
/* 135 */         clauses.add(new BooleanClause(super.getRangeQuery(this.fields[i], part1, part2, inclusive), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 138 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 140 */     return super.getRangeQuery(field, part1, part2, inclusive);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, Analyzer analyzer) throws ParseException {
/* 165 */     if (queries.length != fields.length)
/* 166 */       throw new IllegalArgumentException(""queries.length != fields.length""); 
/* 167 */     BooleanQuery bQuery = new BooleanQuery();
/* 168 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 170 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 171 */       Query q = qp.parse(queries[i]);
/* 172 */       bQuery.add(q, BooleanClause.Occur.SHOULD);
/*     */     } 
/* 174 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String query, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 210 */     if (fields.length != flags.length)
/* 211 */       throw new IllegalArgumentException(""fields.length != flags.length""); 
/* 212 */     BooleanQuery bQuery = new BooleanQuery();
/* 213 */     for (int i = 0; i < fields.length; i++) {
/* 214 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 215 */       Query q = qp.parse(query);
/* 216 */       bQuery.add(q, flags[i]);
/*     */     } 
/* 218 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 256 */     if (queries.length != fields.length || queries.length != flags.length)
/* 257 */       throw new IllegalArgumentException(""queries, fields, and flags array have have different length""); 
/* 258 */     BooleanQuery bQuery = new BooleanQuery();
/* 259 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 261 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 262 */       Query q = qp.parse(queries[i]);
/* 263 */       bQuery.add(q, flags[i]);
/*     */     } 
/* 265 */     return (Query)bQuery;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\MultiFieldQueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.ParseException,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParseException
/*     */   extends Exception
/*     */ {
/*     */   protected boolean specialConstructor;
/*     */   public Token currentToken;
/*     */   public int[][] expectedTokenSequences;
/*     */   public String[] tokenImage;
/*     */   protected String eol;
/*     */   
/*     */   public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
/*  32 */     super("""");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 140 */     this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = true; this.currentToken = currentTokenVal; this.expectedTokenSequences = expectedTokenSequencesVal; this.tokenImage = tokenImageVal; } public ParseException() { this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = false; } public ParseException(String message) { super(message); this.eol = System.getProperty(""line.separator"", ""\n"");
/*     */     this.specialConstructor = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String add_escapes(String str) {
/* 148 */     StringBuffer retval = new StringBuffer();
/*     */     
/* 150 */     for (int i = 0; i < str.length(); i++) {
/* 151 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/* 156 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/* 159 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/* 162 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/* 165 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/* 168 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/* 171 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/* 174 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/* 177 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/* 180 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/* 181 */             String s = ""0000"" + Integer.toString(ch, 16);
/* 182 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/* 184 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/* 189 */     return retval.toString();
/*     */   }
/*     */   
/*     */   public String getMessage() {
/*     */     if (!this.specialConstructor)
/*     */       return super.getMessage(); 
/*     */     String expected = """";
/*     */     int maxSize = 0;
/*     */     for (int i = 0; i < this.expectedTokenSequences.length; i++) {
/*     */       if (maxSize < (this.expectedTokenSequences[i]).length)
/*     */         maxSize = (this.expectedTokenSequences[i]).length; 
/*     */       for (int j = 0; j < (this.expectedTokenSequences[i]).length; j++)
/*     */         expected = expected + this.tokenImage[this.expectedTokenSequences[i][j]] + "" ""; 
/*     */       if (this.expectedTokenSequences[i][(this.expectedTokenSequences[i]).length - 1] != 0)
/*     */         expected = expected + ""...""; 
/*     */       expected = expected + this.eol + ""    "";
/*     */     } 
/*     */     String retval = ""Encountered \"""";
/*     */     Token tok = this.currentToken.next;
/*     */     for (int i = 0; i < maxSize; i++) {
/*     */       if (i != 0)
/*     */         retval = retval + "" ""; 
/*     */       if (tok.kind == 0) {
/*     */         retval = retval + this.tokenImage[0];
/*     */         break;
/*     */       } 
/*     */       retval = retval + add_escapes(tok.image);
/*     */       tok = tok.next;
/*     */     } 
/*     */     retval = retval + ""\"" at line "" + this.currentToken.next.beginLine + "", column "" + this.currentToken.next.beginColumn;
/*     */     retval = retval + ""."" + this.eol;
/*     */     if (this.expectedTokenSequences.length == 1) {
/*     */       retval = retval + ""Was expecting:"" + this.eol + ""    "";
/*     */     } else {
/*     */       retval = retval + ""Was expecting one of:"" + this.eol + ""    "";
/*     */     } 
/*     */     retval = retval + expected;
/*     */     return retval;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\ParseException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParser,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.StringReader;
/*      */ import java.text.DateFormat;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Calendar;
/*      */ import java.util.Date;
/*      */ import java.util.Enumeration;
/*      */ import java.util.List;
/*      */ import java.util.Locale;
/*      */ import java.util.Vector;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.analysis.SimpleAnalyzer;
/*      */ import org.apache.lucene.analysis.Token;
/*      */ import org.apache.lucene.analysis.TokenStream;
/*      */ import org.apache.lucene.document.DateField;
/*      */ import org.apache.lucene.index.Term;
/*      */ import org.apache.lucene.search.BooleanClause;
/*      */ import org.apache.lucene.search.BooleanQuery;
/*      */ import org.apache.lucene.search.FuzzyQuery;
/*      */ import org.apache.lucene.search.MultiPhraseQuery;
/*      */ import org.apache.lucene.search.PhraseQuery;
/*      */ import org.apache.lucene.search.PrefixQuery;
/*      */ import org.apache.lucene.search.Query;
/*      */ import org.apache.lucene.search.RangeQuery;
/*      */ import org.apache.lucene.search.TermQuery;
/*      */ import org.apache.lucene.search.WildcardQuery;
/*      */ import org.apache.lucene.util.Parameter;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParser
/*      */   implements QueryParserConstants
/*      */ {
/*      */   private static final int CONJ_NONE = 0;
/*      */   private static final int CONJ_AND = 1;
/*      */   private static final int CONJ_OR = 2;
/*      */   private static final int MOD_NONE = 0;
/*      */   private static final int MOD_NOT = 10;
/*      */   private static final int MOD_REQ = 11;
/*   77 */   public static final Operator AND_OPERATOR = Operator.AND;
/*      */   
/*   79 */   public static final Operator OR_OPERATOR = Operator.OR;
/*      */ 
/*      */   
/*   82 */   private Operator operator = OR_OPERATOR;
/*      */   
/*      */   boolean lowercaseExpandedTerms = true;
/*      */   
/*      */   Analyzer analyzer;
/*      */   String field;
/*   88 */   int phraseSlop = 0;
/*   89 */   float fuzzyMinSim = 0.5F;
/*   90 */   int fuzzyPrefixLength = 0;
/*   91 */   Locale locale = Locale.getDefault(); public QueryParserTokenManager token_source; public Token token;
/*      */   public Token jj_nt;
/*      */   private int jj_ntk;
/*      */   private Token jj_scanpos;
/*      */   private Token jj_lastpos;
/*      */   private int jj_la;
/*      */   
/*   98 */   public static final class Operator extends Parameter { private Operator(String name) { super(name); }
/*      */     
/*  100 */     public static final Operator OR = new Operator(""OR"");
/*  101 */     public static final Operator AND = new Operator(""AND""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public QueryParser(String f, Analyzer a) {
/*  110 */     this(new FastCharStream(new StringReader("""")));
/*  111 */     this.analyzer = a;
/*  112 */     this.field = f;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Query parse(String query) throws ParseException {
/*  120 */     ReInit(new FastCharStream(new StringReader(query)));
/*      */     try {
/*  122 */       return Query(this.field);
/*      */     }
/*  124 */     catch (TokenMgrError tme) {
/*  125 */       throw new ParseException(tme.getMessage());
/*      */     }
/*  127 */     catch (org.apache.lucene.search.BooleanQuery.TooManyClauses tmc) {
/*  128 */       throw new ParseException(""Too many boolean clauses"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  136 */   public Analyzer getAnalyzer() { return this.analyzer; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  143 */   public String getField() { return this.field; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  150 */   public float getFuzzyMinSim() { return this.fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  158 */   public void setFuzzyMinSim(float fuzzyMinSim) { this.fuzzyMinSim = fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  166 */   public int getFuzzyPrefixLength() { return this.fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  174 */   public void setFuzzyPrefixLength(int fuzzyPrefixLength) { this.fuzzyPrefixLength = fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  182 */   public void setPhraseSlop(int phraseSlop) { this.phraseSlop = phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  189 */   public int getPhraseSlop() { return this.phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  202 */   public void setDefaultOperator(Operator op) { this.operator = op; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  211 */   public Operator getDefaultOperator() { return this.operator; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  220 */   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) { this.lowercaseExpandedTerms = lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  228 */   public boolean getLowercaseExpandedTerms() { return this.lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  235 */   public void setLocale(Locale locale) { this.locale = locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  242 */   public Locale getLocale() { return this.locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected void addClause(Vector clauses, int conj, int mods, Query q) {
/*      */     boolean prohibited;
/*      */     boolean required;
/*  250 */     if (clauses.size() > 0 && conj == 1) {
/*  251 */       BooleanClause c = clauses.elementAt(clauses.size() - 1);
/*  252 */       if (!c.isProhibited()) {
/*  253 */         c.setOccur(BooleanClause.Occur.MUST);
/*      */       }
/*      */     } 
/*  256 */     if (clauses.size() > 0 && this.operator == AND_OPERATOR && conj == 2) {
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  261 */       BooleanClause c = clauses.elementAt(clauses.size() - 1);
/*  262 */       if (!c.isProhibited()) {
/*  263 */         c.setOccur(BooleanClause.Occur.SHOULD);
/*      */       }
/*      */     } 
/*      */ 
/*      */     
/*  268 */     if (q == null) {
/*      */       return;
/*      */     }
/*  271 */     if (this.operator == OR_OPERATOR) {
/*      */ 
/*      */       
/*  274 */       prohibited = (mods == 10);
/*  275 */       required = (mods == 11);
/*  276 */       if (conj == 1 && !prohibited) {
/*  277 */         required = true;
/*      */       }
/*      */     }
/*      */     else {
/*      */       
/*  282 */       prohibited = (mods == 10);
/*  283 */       required = (!prohibited && conj != 2);
/*      */     } 
/*  285 */     if (required && !prohibited) {
/*  286 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));
/*  287 */     } else if (!required && !prohibited) {
/*  288 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));
/*  289 */     } else if (!required && prohibited) {
/*  290 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));
/*      */     } else {
/*  292 */       throw new RuntimeException(""Clause cannot be both required and prohibited"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText) throws ParseException {
/*  303 */     TokenStream source = this.analyzer.tokenStream(field, new StringReader(queryText));
/*  304 */     Vector v = new Vector();
/*      */     
/*  306 */     int positionCount = 0;
/*  307 */     boolean severalTokensAtSamePosition = false;
/*      */     while (true) {
/*      */       Token t;
/*      */       try {
/*  311 */         t = source.next();
/*      */       }
/*  313 */       catch (IOException e) {
/*  314 */         t = null;
/*      */       } 
/*  316 */       if (t == null)
/*      */         break; 
/*  318 */       v.addElement(t);
/*  319 */       if (t.getPositionIncrement() != 0) {
/*  320 */         positionCount += t.getPositionIncrement(); continue;
/*      */       } 
/*  322 */       severalTokensAtSamePosition = true;
/*      */     } 
/*      */     try {
/*  325 */       source.close();
/*      */     }
/*  327 */     catch (IOException e) {}
/*      */ 
/*      */ 
/*      */     
/*  331 */     if (v.size() == 0)
/*  332 */       return null; 
/*  333 */     if (v.size() == 1) {
/*  334 */       Token token1 = v.elementAt(0);
/*  335 */       return (Query)new TermQuery(new Term(field, token1.termText()));
/*      */     } 
/*  337 */     if (severalTokensAtSamePosition) {
/*  338 */       if (positionCount == 1) {
/*      */         
/*  340 */         BooleanQuery q = new BooleanQuery(true);
/*  341 */         for (int i = 0; i < v.size(); i++) {
/*  342 */           Token token1 = v.elementAt(i);
/*  343 */           TermQuery currentQuery = new TermQuery(new Term(field, token1.termText()));
/*      */           
/*  345 */           q.add((Query)currentQuery, BooleanClause.Occur.SHOULD);
/*      */         } 
/*  347 */         return (Query)q;
/*      */       } 
/*      */ 
/*      */       
/*  351 */       MultiPhraseQuery mpq = new MultiPhraseQuery();
/*  352 */       mpq.setSlop(this.phraseSlop);
/*  353 */       List multiTerms = new ArrayList();
/*  354 */       for (int i = 0; i < v.size(); i++) {
/*  355 */         Token token1 = v.elementAt(i);
/*  356 */         if (token1.getPositionIncrement() == 1 && multiTerms.size() > 0) {
/*  357 */           mpq.add((Term[])multiTerms.toArray((Object[])new Term[0]));
/*  358 */           multiTerms.clear();
/*      */         } 
/*  360 */         multiTerms.add(new Term(field, token1.termText()));
/*      */       } 
/*  362 */       mpq.add(multiTerms.toArray(new Term[0]));
/*  363 */       return (Query)mpq;
/*      */     } 
/*      */ 
/*      */     
/*  367 */     PhraseQuery q = new PhraseQuery();
/*  368 */     q.setSlop(this.phraseSlop);
/*  369 */     for (int i = 0; i < v.size(); i++) {
/*  370 */       q.add(new Term(field, ((Token)v.elementAt(i)).termText()));
/*      */     }
/*      */ 
/*      */     
/*  374 */     return (Query)q;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/*  389 */     Query query = getFieldQuery(field, queryText);
/*      */     
/*  391 */     if (query instanceof PhraseQuery) {
/*  392 */       ((PhraseQuery)query).setSlop(slop);
/*      */     }
/*  394 */     if (query instanceof MultiPhraseQuery) {
/*  395 */       ((MultiPhraseQuery)query).setSlop(slop);
/*      */     }
/*      */     
/*  398 */     return query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/*  410 */     if (this.lowercaseExpandedTerms) {
/*  411 */       part1 = part1.toLowerCase();
/*  412 */       part2 = part2.toLowerCase();
/*      */     } 
/*      */     try {
/*  415 */       DateFormat df = DateFormat.getDateInstance(3, this.locale);
/*  416 */       df.setLenient(true);
/*  417 */       Date d1 = df.parse(part1);
/*  418 */       Date d2 = df.parse(part2);
/*  419 */       if (inclusive) {
/*      */ 
/*      */ 
/*      */         
/*  423 */         Calendar cal = Calendar.getInstance(this.locale);
/*  424 */         cal.setTime(d2);
/*  425 */         cal.set(11, 23);
/*  426 */         cal.set(12, 59);
/*  427 */         cal.set(13, 59);
/*  428 */         cal.set(14, 999);
/*  429 */         d2 = cal.getTime();
/*      */       } 
/*  431 */       part1 = DateField.dateToString(d1);
/*  432 */       part2 = DateField.dateToString(d2);
/*      */     }
/*  434 */     catch (Exception e) {}
/*      */     
/*  436 */     return (Query)new RangeQuery(new Term(field, part1), new Term(field, part2), inclusive);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  455 */   protected Query getBooleanQuery(Vector clauses) throws ParseException { return getBooleanQuery(clauses, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getBooleanQuery(Vector clauses, boolean disableCoord) throws ParseException {
/*  475 */     BooleanQuery query = new BooleanQuery(disableCoord);
/*  476 */     for (int i = 0; i < clauses.size(); i++) {
/*  477 */       query.add(clauses.elementAt(i));
/*      */     }
/*  479 */     return (Query)query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/*  505 */     if (this.lowercaseExpandedTerms) {
/*  506 */       termStr = termStr.toLowerCase();
/*      */     }
/*  508 */     Term t = new Term(field, termStr);
/*  509 */     return (Query)new WildcardQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/*  537 */     if (this.lowercaseExpandedTerms) {
/*  538 */       termStr = termStr.toLowerCase();
/*      */     }
/*  540 */     Term t = new Term(field, termStr);
/*  541 */     return (Query)new PrefixQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/*  558 */     if (this.lowercaseExpandedTerms) {
/*  559 */       termStr = termStr.toLowerCase();
/*      */     }
/*  561 */     Term t = new Term(field, termStr);
/*  562 */     return (Query)new FuzzyQuery(t, minSimilarity, this.fuzzyPrefixLength);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private String discardEscapeChar(String input) {
/*  570 */     char[] caSource = input.toCharArray();
/*  571 */     char[] caDest = new char[caSource.length];
/*  572 */     int j = 0;
/*  573 */     for (int i = 0; i < caSource.length; i++) {
/*  574 */       if (caSource[i] != '\\' || (i > 0 && caSource[i - 1] == '\\')) {
/*  575 */         caDest[j++] = caSource[i];
/*      */       }
/*      */     } 
/*  578 */     return new String(caDest, 0, j);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static String escape(String s) {
/*  586 */     StringBuffer sb = new StringBuffer();
/*  587 */     for (int i = 0; i < s.length(); i++) {
/*  588 */       char c = s.charAt(i);
/*      */       
/*  590 */       if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '""' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?')
/*      */       {
/*      */         
/*  593 */         sb.append('\\');
/*      */       }
/*  595 */       sb.append(c);
/*      */     } 
/*  597 */     return sb.toString();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void main(String[] args) throws Exception {
/*  606 */     if (args.length == 0) {
/*  607 */       System.out.println(""Usage: java org.apache.lucene.queryParser.QueryParser <input>"");
/*  608 */       System.exit(0);
/*      */     } 
/*  610 */     QueryParser qp = new QueryParser(""field"", (Analyzer)new SimpleAnalyzer());
/*      */     
/*  612 */     Query q = qp.parse(args[0]);
/*  613 */     System.out.println(q.toString(""field""));
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final int Conjunction() throws ParseException {
/*  619 */     int ret = 0;
/*  620 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 7:
/*      */       case 8:
/*  623 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 7:
/*  625 */             jj_consume_token(7);
/*  626 */             ret = 1;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/*  642 */             return ret;case 8: jj_consume_token(8); ret = 2; return ret; }  this.jj_la1[0] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[1] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */   
/*      */   public final int Modifiers() throws ParseException {
/*  647 */     int ret = 0;
/*  648 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 9:
/*      */       case 10:
/*      */       case 11:
/*  652 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 10:
/*  654 */             jj_consume_token(10);
/*  655 */             ret = 11;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/*  675 */             return ret;case 11: jj_consume_token(11); ret = 10; return ret;case 9: jj_consume_token(9); ret = 10; return ret; }  this.jj_la1[2] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[3] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */   
/*      */   public final Query Query(String field) throws ParseException {
/*  680 */     Vector clauses = new Vector();
/*  681 */     Query firstQuery = null;
/*      */     
/*  683 */     int mods = Modifiers();
/*  684 */     Query q = Clause(field);
/*  685 */     addClause(clauses, 0, mods, q);
/*  686 */     if (mods == 0) {
/*  687 */       firstQuery = q;
/*      */     }
/*      */     while (true) {
/*  690 */       switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */         case 7:
/*      */         case 8:
/*      */         case 9:
/*      */         case 10:
/*      */         case 11:
/*      */         case 12:
/*      */         case 16:
/*      */         case 17:
/*      */         case 19:
/*      */         case 20:
/*      */         case 21:
/*      */         case 22:
/*      */         case 23:
/*      */           break;
/*      */         
/*      */         default:
/*  707 */           this.jj_la1[4] = this.jj_gen;
/*      */           break;
/*      */       } 
/*  710 */       int conj = Conjunction();
/*  711 */       mods = Modifiers();
/*  712 */       q = Clause(field);
/*  713 */       addClause(clauses, conj, mods, q);
/*      */     } 
/*  715 */     if (clauses.size() == 1 && firstQuery != null) {
/*  716 */       return firstQuery;
/*      */     }
/*  718 */     return getBooleanQuery(clauses);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final Query Clause(String field) throws ParseException {
/*      */     Query q, q;
/*  725 */     Token fieldToken = null, boost = null;
/*  726 */     if (jj_2_1(2)) {
/*  727 */       fieldToken = jj_consume_token(17);
/*  728 */       jj_consume_token(14);
/*  729 */       field = discardEscapeChar(fieldToken.image);
/*      */     } 
/*      */ 
/*      */     
/*  733 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 16:
/*      */       case 17:
/*      */       case 19:
/*      */       case 20:
/*      */       case 21:
/*      */       case 22:
/*      */       case 23:
/*  741 */         q = Term(field);
/*      */         break;
/*      */       case 12:
/*  744 */         jj_consume_token(12);
/*  745 */         q = Query(field);
/*  746 */         jj_consume_token(13);
/*  747 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 15:
/*  749 */             jj_consume_token(15);
/*  750 */             boost = jj_consume_token(23);
/*      */             break;
/*      */         } 
/*  753 */         this.jj_la1[5] = this.jj_gen;
/*      */         break;
/*      */ 
/*      */       
/*      */       default:
/*  758 */         this.jj_la1[6] = this.jj_gen;
/*  759 */         jj_consume_token(-1);
/*  760 */         throw new ParseException();
/*      */     } 
/*  762 */     if (boost != null) {
/*  763 */       float f = 1.0F;
/*      */       try {
/*  765 */         f = Float.valueOf(boost.image).floatValue();
/*  766 */         q.setBoost(f);
/*  767 */       } catch (Exception ignored) {}
/*      */     } 
/*  769 */     return q;
/*      */   } public final Query Term(String field) throws ParseException {
/*      */     int s;
/*      */     String termImage;
/*      */     Query q, q, q, q;
/*  774 */     Token goop2, goop2, goop2, goop2, goop1, goop1, goop1, goop1, term, term, term, term, term, boost = null, fuzzySlop = null;
/*  775 */     boolean prefix = false;
/*  776 */     boolean wildcard = false;
/*  777 */     boolean fuzzy = false;
/*  778 */     boolean rangein = false;
/*      */     
/*  780 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 17:
/*      */       case 19:
/*      */       case 20:
/*      */       case 23:
/*  785 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/*  787 */             term = jj_consume_token(17);
/*      */             break;
/*      */           case 19:
/*  790 */             term = jj_consume_token(19);
/*  791 */             prefix = true;
/*      */             break;
/*      */           case 20:
/*  794 */             term = jj_consume_token(20);
/*  795 */             wildcard = true;
/*      */             break;
/*      */           case 23:
/*  798 */             term = jj_consume_token(23);
/*      */             break;
/*      */           default:
/*  801 */             this.jj_la1[7] = this.jj_gen;
/*  802 */             jj_consume_token(-1);
/*  803 */             throw new ParseException();
/*      */         } 
/*  805 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 18:
/*  807 */             fuzzySlop = jj_consume_token(18);
/*  808 */             fuzzy = true;
/*      */             break;
/*      */           default:
/*  811 */             this.jj_la1[8] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  814 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 15:
/*  816 */             jj_consume_token(15);
/*  817 */             boost = jj_consume_token(23);
/*  818 */             switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */               case 18:
/*  820 */                 fuzzySlop = jj_consume_token(18);
/*  821 */                 fuzzy = true;
/*      */                 break;
/*      */             } 
/*  824 */             this.jj_la1[9] = this.jj_gen;
/*      */             break;
/*      */ 
/*      */           
/*      */           default:
/*  829 */             this.jj_la1[10] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  832 */         termImage = discardEscapeChar(term.image);
/*  833 */         if (wildcard) {
/*  834 */           Query q = getWildcardQuery(field, termImage); break;
/*  835 */         }  if (prefix) {
/*  836 */           Query q = getPrefixQuery(field, discardEscapeChar(term.image.substring(0, term.image.length() - 1)));
/*      */           break;
/*      */         } 
/*  839 */         if (fuzzy) {
/*  840 */           float fms = this.fuzzyMinSim;
/*      */           try {
/*  842 */             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
/*  843 */           } catch (Exception ignored) {}
/*  844 */           if (fms < 0.0F || fms > 1.0F) {
/*  845 */             throw new ParseException(""Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"");
/*      */           }
/*  847 */           Query q = getFuzzyQuery(field, termImage, fms); break;
/*      */         } 
/*  849 */         q = getFieldQuery(field, termImage);
/*      */         break;
/*      */       
/*      */       case 21:
/*  853 */         jj_consume_token(21);
/*  854 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 27:
/*  856 */             goop1 = jj_consume_token(27);
/*      */             break;
/*      */           case 26:
/*  859 */             goop1 = jj_consume_token(26);
/*      */             break;
/*      */           default:
/*  862 */             this.jj_la1[11] = this.jj_gen;
/*  863 */             jj_consume_token(-1);
/*  864 */             throw new ParseException();
/*      */         } 
/*  866 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 24:
/*  868 */             jj_consume_token(24);
/*      */             break;
/*      */           default:
/*  871 */             this.jj_la1[12] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  874 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 27:
/*  876 */             goop2 = jj_consume_token(27);
/*      */             break;
/*      */           case 26:
/*  879 */             goop2 = jj_consume_token(26);
/*      */             break;
/*      */           default:
/*  882 */             this.jj_la1[13] = this.jj_gen;
/*  883 */             jj_consume_token(-1);
/*  884 */             throw new ParseException();
/*      */         } 
/*  886 */         jj_consume_token(25);
/*  887 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 15:
/*  889 */             jj_consume_token(15);
/*  890 */             boost = jj_consume_token(23);
/*      */             break;
/*      */           default:
/*  893 */             this.jj_la1[14] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  896 */         if (goop1.kind == 26) {
/*  897 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         } else {
/*  899 */           goop1.image = discardEscapeChar(goop1.image);
/*      */         } 
/*  901 */         if (goop2.kind == 26) {
/*  902 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         } else {
/*  904 */           goop2.image = discardEscapeChar(goop2.image);
/*      */         } 
/*  906 */         q = getRangeQuery(field, goop1.image, goop2.image, true);
/*      */         break;
/*      */       case 22:
/*  909 */         jj_consume_token(22);
/*  910 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 31:
/*  912 */             goop1 = jj_consume_token(31);
/*      */             break;
/*      */           case 30:
/*  915 */             goop1 = jj_consume_token(30);
/*      */             break;
/*      */           default:
/*  918 */             this.jj_la1[15] = this.jj_gen;
/*  919 */             jj_consume_token(-1);
/*  920 */             throw new ParseException();
/*      */         } 
/*  922 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 28:
/*  924 */             jj_consume_token(28);
/*      */             break;
/*      */           default:
/*  927 */             this.jj_la1[16] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  930 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 31:
/*  932 */             goop2 = jj_consume_token(31);
/*      */             break;
/*      */           case 30:
/*  935 */             goop2 = jj_consume_token(30);
/*      */             break;
/*      */           default:
/*  938 */             this.jj_la1[17] = this.jj_gen;
/*  939 */             jj_consume_token(-1);
/*  940 */             throw new ParseException();
/*      */         } 
/*  942 */         jj_consume_token(29);
/*  943 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 15:
/*  945 */             jj_consume_token(15);
/*  946 */             boost = jj_consume_token(23);
/*      */             break;
/*      */           default:
/*  949 */             this.jj_la1[18] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  952 */         if (goop1.kind == 30) {
/*  953 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         } else {
/*  955 */           goop1.image = discardEscapeChar(goop1.image);
/*      */         } 
/*  957 */         if (goop2.kind == 30) {
/*  958 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         } else {
/*  960 */           goop2.image = discardEscapeChar(goop2.image);
/*      */         } 
/*      */         
/*  963 */         q = getRangeQuery(field, goop1.image, goop2.image, false);
/*      */         break;
/*      */       case 16:
/*  966 */         term = jj_consume_token(16);
/*  967 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 18:
/*  969 */             fuzzySlop = jj_consume_token(18);
/*      */             break;
/*      */           default:
/*  972 */             this.jj_la1[19] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  975 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 15:
/*  977 */             jj_consume_token(15);
/*  978 */             boost = jj_consume_token(23);
/*      */             break;
/*      */           default:
/*  981 */             this.jj_la1[20] = this.jj_gen;
/*      */             break;
/*      */         } 
/*  984 */         s = this.phraseSlop;
/*      */         
/*  986 */         if (fuzzySlop != null) {
/*      */           try {
/*  988 */             s = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
/*      */           }
/*  990 */           catch (Exception ignored) {}
/*      */         }
/*  992 */         q = getFieldQuery(field, term.image.substring(1, term.image.length() - 1), s);
/*      */         break;
/*      */       default:
/*  995 */         this.jj_la1[21] = this.jj_gen;
/*  996 */         jj_consume_token(-1);
/*  997 */         throw new ParseException();
/*      */     } 
/*  999 */     if (boost != null) {
/* 1000 */       float f = 1.0F;
/*      */       try {
/* 1002 */         f = Float.valueOf(boost.image).floatValue();
/*      */       }
/* 1004 */       catch (Exception ignored) {}
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1011 */       if (q != null) {
/* 1012 */         q.setBoost(f);
/*      */       }
/*      */     } 
/* 1015 */     return q;
/*      */   }
/*      */ 
/*      */   
/*      */   private final boolean jj_2_1(int xla) {
/* 1020 */     this.jj_la = xla; this.jj_lastpos = this.jj_scanpos = this.token; 
/* 1021 */     try { return !jj_3_1(); }
/* 1022 */     catch (LookaheadSuccess ls) { return true; }
/* 1023 */     finally { jj_save(0, xla); }
/*      */   
/*      */   }
/*      */   private final boolean jj_3_1() {
/* 1027 */     if (jj_scan_token(17)) return true; 
/* 1028 */     if (jj_scan_token(14)) return true; 
/* 1029 */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public boolean lookingAhead = false;
/*      */   
/*      */   private boolean jj_semLA;
/*      */   
/*      */   private int jj_gen;
/*      */   
/* 1040 */   private final int[] jj_la1 = new int[22]; private static int[] jj_la1_0;
/*      */   
/*      */   static  {
/* 1043 */     jj_la1_0();
/*      */   }
/*      */   
/* 1046 */   private static void jj_la1_0() { jj_la1_0 = new int[] { 384, 384, 3584, 3584, 16457600, 32768, 16453632, 10092544, 262144, 262144, 32768, 201326592, 16777216, 201326592, 32768, -1073741824, 268435456, -1073741824, 32768, 262144, 32768, 16449536 }; }
/*      */   
/* 1048 */   private final JJCalls[] jj_2_rtns = new JJCalls[1];
/*      */   private boolean jj_rescan = false;
/* 1050 */   private int jj_gc = 0;
/*      */   
/*      */   private final LookaheadSuccess jj_ls;
/*      */   
/*      */   private Vector jj_expentries;
/*      */   
/*      */   private int[] jj_expentry;
/*      */   private int jj_kind;
/*      */   private int[] jj_lasttokens;
/*      */   private int jj_endpos;
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1062 */     this.token_source.ReInit(stream);
/* 1063 */     this.token = new Token();
/* 1064 */     this.jj_ntk = -1;
/* 1065 */     this.jj_gen = 0;
/* 1066 */     for (int i = 0; i < 22; ) { this.jj_la1[i] = -1; i++; }
/* 1067 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void ReInit(QueryParserTokenManager tm) {
/* 1080 */     this.token_source = tm;
/* 1081 */     this.token = new Token();
/* 1082 */     this.jj_ntk = -1;
/* 1083 */     this.jj_gen = 0;
/* 1084 */     for (int i = 0; i < 22; ) { this.jj_la1[i] = -1; i++; }
/* 1085 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */   private final Token jj_consume_token(int kind) throws ParseException {
/*      */     Token oldToken;
/* 1090 */     if ((oldToken = this.token).next != null) { this.token = this.token.next; }
/* 1091 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 1092 */      this.jj_ntk = -1;
/* 1093 */     if (this.token.kind == kind) {
/* 1094 */       this.jj_gen++;
/* 1095 */       if (++this.jj_gc > 100) {
/* 1096 */         this.jj_gc = 0;
/* 1097 */         for (int i = 0; i < this.jj_2_rtns.length; i++) {
/* 1098 */           JJCalls c = this.jj_2_rtns[i];
/* 1099 */           while (c != null) {
/* 1100 */             if (c.gen < this.jj_gen) c.first = null; 
/* 1101 */             c = c.next;
/*      */           } 
/*      */         } 
/*      */       } 
/* 1105 */       return this.token;
/*      */     } 
/* 1107 */     this.token = oldToken;
/* 1108 */     this.jj_kind = kind;
/* 1109 */     throw generateParseException();
/*      */   }
/*      */   private static final class LookaheadSuccess extends Error {
/*      */     private LookaheadSuccess() {} }
/* 1113 */   public QueryParser(CharStream stream) { this.jj_ls = new LookaheadSuccess();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1159 */     this.jj_expentries = new Vector();
/*      */     
/* 1161 */     this.jj_kind = -1;
/* 1162 */     this.jj_lasttokens = new int[100]; this.token_source = new QueryParserTokenManager(stream); this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 22; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  } public QueryParser(QueryParserTokenManager tm) { this.jj_ls = new LookaheadSuccess(); this.jj_expentries = new Vector(); this.jj_kind = -1; this.jj_lasttokens = new int[100]; this.token_source = tm; this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 22; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  }
/*      */   private final boolean jj_scan_token(int kind) { if (this.jj_scanpos == this.jj_lastpos) { this.jj_la--; if (this.jj_scanpos.next == null) { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken(); } else { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next; }  } else { this.jj_scanpos = this.jj_scanpos.next; }  if (this.jj_rescan) { int i = 0; Token tok = this.token; while (tok != null && tok != this.jj_scanpos) { i++; tok = tok.next; }  if (tok != null) jj_add_error_token(kind, i);  }  if (this.jj_scanpos.kind != kind)
/*      */       return true;  if (this.jj_la == 0 && this.jj_scanpos == this.jj_lastpos)
/*      */       throw this.jj_ls;  return false; }
/* 1166 */   public final Token getNextToken() { if (this.token.next != null) { this.token = this.token.next; } else { this.token = this.token.next = this.token_source.getNextToken(); }  this.jj_ntk = -1; this.jj_gen++; return this.token; } private void jj_add_error_token(int kind, int pos) { if (pos >= 100)
/* 1167 */       return;  if (pos == this.jj_endpos + 1)
/* 1168 */     { this.jj_lasttokens[this.jj_endpos++] = kind; }
/* 1169 */     else if (this.jj_endpos != 0)
/* 1170 */     { this.jj_expentry = new int[this.jj_endpos];
/* 1171 */       for (int i = 0; i < this.jj_endpos; i++) {
/* 1172 */         this.jj_expentry[i] = this.jj_lasttokens[i];
/*      */       }
/* 1174 */       boolean exists = false;
/* 1175 */       for (Enumeration e = this.jj_expentries.elements(); e.hasMoreElements(); ) {
/* 1176 */         int[] oldentry = e.nextElement();
/* 1177 */         if (oldentry.length == this.jj_expentry.length) {
/* 1178 */           exists = true;
/* 1179 */           for (int i = 0; i < this.jj_expentry.length; i++) {
/* 1180 */             if (oldentry[i] != this.jj_expentry[i]) {
/* 1181 */               exists = false;
/*      */               break;
/*      */             } 
/*      */           } 
/* 1185 */           if (exists)
/*      */             break; 
/*      */         } 
/* 1188 */       }  if (!exists) this.jj_expentries.addElement(this.jj_expentry); 
/* 1189 */       if (pos != 0) this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;  }  }
/*      */   public final Token getToken(int index) { Token t = this.lookingAhead ? this.jj_scanpos : this.token; for (int i = 0; i < index; i++) { if (t.next != null) { t = t.next; } else { t = t.next = this.token_source.getNextToken(); }
/*      */        }
/*      */      return t; }
/*      */   private final int jj_ntk() { if ((this.jj_nt = this.token.next) == null)
/* 1194 */       return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;  return this.jj_ntk = this.jj_nt.kind; } public ParseException generateParseException() { this.jj_expentries.removeAllElements();
/* 1195 */     boolean[] la1tokens = new boolean[32];
/* 1196 */     for (int i = 0; i < 32; i++) {
/* 1197 */       la1tokens[i] = false;
/*      */     }
/* 1199 */     if (this.jj_kind >= 0) {
/* 1200 */       la1tokens[this.jj_kind] = true;
/* 1201 */       this.jj_kind = -1;
/*      */     } 
/* 1203 */     for (int i = 0; i < 22; i++) {
/* 1204 */       if (this.jj_la1[i] == this.jj_gen) {
/* 1205 */         for (int j = 0; j < 32; j++) {
/* 1206 */           if ((jj_la1_0[i] & 1 << j) != 0) {
/* 1207 */             la1tokens[j] = true;
/*      */           }
/*      */         } 
/*      */       }
/*      */     } 
/* 1212 */     for (int i = 0; i < 32; i++) {
/* 1213 */       if (la1tokens[i]) {
/* 1214 */         this.jj_expentry = new int[1];
/* 1215 */         this.jj_expentry[0] = i;
/* 1216 */         this.jj_expentries.addElement(this.jj_expentry);
/*      */       } 
/*      */     } 
/* 1219 */     this.jj_endpos = 0;
/* 1220 */     jj_rescan_token();
/* 1221 */     jj_add_error_token(0, 0);
/* 1222 */     int[][] exptokseq = new int[this.jj_expentries.size()][];
/* 1223 */     for (int i = 0; i < this.jj_expentries.size(); i++) {
/* 1224 */       exptokseq[i] = this.jj_expentries.elementAt(i);
/*      */     }
/* 1226 */     return new ParseException(this.token, exptokseq, tokenImage); }
/*      */ 
/*      */ 
/*      */   
/*      */   public final void enable_tracing() {}
/*      */ 
/*      */   
/*      */   public final void disable_tracing() {}
/*      */   
/*      */   private final void jj_rescan_token() {
/* 1236 */     this.jj_rescan = true;
/* 1237 */     for (int i = 0; i < 1; i++) {
/* 1238 */       JJCalls p = this.jj_2_rtns[i];
/*      */       do {
/* 1240 */         if (p.gen > this.jj_gen) {
/* 1241 */           this.jj_la = p.arg; this.jj_lastpos = this.jj_scanpos = p.first;
/* 1242 */           switch (i) { case 0:
/* 1243 */               jj_3_1(); break; }
/*      */         
/*      */         } 
/* 1246 */         p = p.next;
/* 1247 */       } while (p != null);
/*      */     } 
/* 1249 */     this.jj_rescan = false;
/*      */   }
/*      */   
/*      */   private final void jj_save(int index, int xla) {
/* 1253 */     JJCalls p = this.jj_2_rtns[index];
/* 1254 */     while (p.gen > this.jj_gen) {
/* 1255 */       if (p.next == null) { p = p.next = new JJCalls(); break; }
/* 1256 */        p = p.next;
/*      */     } 
/* 1258 */     p.gen = this.jj_gen + xla - this.jj_la; p.first = this.token; p.arg = xla;
/*      */   }
/*      */   
/*      */   static final class JJCalls {
/*      */     int gen;
/*      */     Token first;
/*      */     int arg;
/*      */     JJCalls next;
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\QueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserConstants,"/*    */ package org.apache.lucene.queryParser;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface QueryParserConstants
/*    */ {
/*    */   public static final int EOF = 0;
/*    */   public static final int _NUM_CHAR = 1;
/*    */   public static final int _ESCAPED_CHAR = 2;
/*    */   public static final int _TERM_START_CHAR = 3;
/*    */   public static final int _TERM_CHAR = 4;
/*    */   public static final int _WHITESPACE = 5;
/*    */   public static final int AND = 7;
/*    */   public static final int OR = 8;
/*    */   public static final int NOT = 9;
/*    */   public static final int PLUS = 10;
/*    */   public static final int MINUS = 11;
/*    */   public static final int LPAREN = 12;
/*    */   public static final int RPAREN = 13;
/*    */   public static final int COLON = 14;
/*    */   public static final int CARAT = 15;
/*    */   public static final int QUOTED = 16;
/*    */   public static final int TERM = 17;
/*    */   public static final int FUZZY_SLOP = 18;
/*    */   public static final int PREFIXTERM = 19;
/*    */   public static final int WILDTERM = 20;
/*    */   public static final int RANGEIN_START = 21;
/*    */   public static final int RANGEEX_START = 22;
/*    */   public static final int NUMBER = 23;
/*    */   public static final int RANGEIN_TO = 24;
/*    */   public static final int RANGEIN_END = 25;
/*    */   public static final int RANGEIN_QUOTED = 26;
/*    */   public static final int RANGEIN_GOOP = 27;
/*    */   public static final int RANGEEX_TO = 28;
/*    */   public static final int RANGEEX_END = 29;
/*    */   public static final int RANGEEX_QUOTED = 30;
/*    */   public static final int RANGEEX_GOOP = 31;
/*    */   public static final int Boost = 0;
/*    */   public static final int RangeEx = 1;
/*    */   public static final int RangeIn = 2;
/*    */   public static final int DEFAULT = 3;
/* 43 */   public static final String[] tokenImage = new String[] { ""<EOF>"", ""<_NUM_CHAR>"", ""<_ESCAPED_CHAR>"", ""<_TERM_START_CHAR>"", ""<_TERM_CHAR>"", ""<_WHITESPACE>"", ""<token of kind 6>"", ""<AND>"", ""<OR>"", ""<NOT>"", ""\""+\"""", ""\""-\"""", ""\""(\"""", ""\"")\"""", ""\"":\"""", ""\""^\"""", ""<QUOTED>"", ""<TERM>"", ""<FUZZY_SLOP>"", ""<PREFIXTERM>"", ""<WILDTERM>"", ""\""[\"""", ""\""{\"""", ""<NUMBER>"", ""\""TO\"""", ""\""]\"""", ""<RANGEIN_QUOTED>"", ""<RANGEIN_GOOP>"", ""\""TO\"""", ""\""}\"""", ""<RANGEEX_QUOTED>"", ""<RANGEEX_GOOP>"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\QueryParserConstants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserTokenManager,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParserTokenManager
/*      */   implements QueryParserConstants
/*      */ {
/*   15 */   public PrintStream debugStream = System.out;
/*   16 */   public void setDebugStream(PrintStream ds) { this.debugStream = ds; }
/*      */   
/*      */   private final int jjStopStringLiteralDfa_3(int pos, long active0) {
/*   19 */     switch (pos) {
/*      */     
/*      */     } 
/*   22 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*   27 */   private final int jjStartNfa_3(int pos, long active0) { return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStopAtPos(int pos, int kind) {
/*   31 */     this.jjmatchedKind = kind;
/*   32 */     this.jjmatchedPos = pos;
/*   33 */     return pos + 1;
/*      */   }
/*      */   
/*      */   private final int jjStartNfaWithStates_3(int pos, int kind, int state) {
/*   37 */     this.jjmatchedKind = kind;
/*   38 */     this.jjmatchedPos = pos; 
/*   39 */     try { this.curChar = this.input_stream.readChar(); }
/*   40 */     catch (IOException e) { return pos + 1; }
/*   41 */      return jjMoveNfa_3(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_3() {
/*   45 */     switch (this.curChar) {
/*      */       
/*      */       case '(':
/*   48 */         return jjStopAtPos(0, 12);
/*      */       case ')':
/*   50 */         return jjStopAtPos(0, 13);
/*      */       case '+':
/*   52 */         return jjStopAtPos(0, 10);
/*      */       case '-':
/*   54 */         return jjStopAtPos(0, 11);
/*      */       case ':':
/*   56 */         return jjStopAtPos(0, 14);
/*      */       case '[':
/*   58 */         return jjStopAtPos(0, 21);
/*      */       case '^':
/*   60 */         return jjStopAtPos(0, 15);
/*      */       case '{':
/*   62 */         return jjStopAtPos(0, 22);
/*      */     } 
/*   64 */     return jjMoveNfa_3(0, 0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final void jjCheckNAdd(int state) {
/*   69 */     if (this.jjrounds[state] != this.jjround) {
/*      */       
/*   71 */       this.jjstateSet[this.jjnewStateCnt++] = state;
/*   72 */       this.jjrounds[state] = this.jjround;
/*      */     } 
/*      */   }
/*      */   
/*      */   private final void jjAddStates(int start, int end) {
/*      */     do {
/*   78 */       this.jjstateSet[this.jjnewStateCnt++] = jjnextStates[start];
/*   79 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddTwoStates(int state1, int state2) {
/*   83 */     jjCheckNAdd(state1);
/*   84 */     jjCheckNAdd(state2);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start, int end) {
/*      */     do {
/*   89 */       jjCheckNAdd(jjnextStates[start]);
/*   90 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start) {
/*   94 */     jjCheckNAdd(jjnextStates[start]);
/*   95 */     jjCheckNAdd(jjnextStates[start + 1]);
/*      */   }
/*   97 */   static final long[] jjbitVec0 = new long[] { -2L, -1L, -1L, -1L };
/*      */ 
/*      */   
/*  100 */   static final long[] jjbitVec2 = new long[] { 0L, 0L, -1L, -1L };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_3(int startState, int curPos) {
/*  106 */     int startsAt = 0;
/*  107 */     this.jjnewStateCnt = 33;
/*  108 */     int i = 1;
/*  109 */     this.jjstateSet[0] = startState;
/*  110 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  113 */       if (++this.jjround == Integer.MAX_VALUE)
/*  114 */         ReInitRounds(); 
/*  115 */       if (this.curChar < '@') {
/*      */         
/*  117 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  120 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  123 */               if ((0x7BFFD0F8FFFFD9FFL & l) != 0L) {
/*      */                 
/*  125 */                 if (kind > 17)
/*  126 */                   kind = 17; 
/*  127 */                 jjCheckNAddStates(0, 6);
/*      */               }
/*  129 */               else if ((0x100002600L & l) != 0L) {
/*      */                 
/*  131 */                 if (kind > 6) {
/*  132 */                   kind = 6;
/*      */                 }
/*  134 */               } else if (this.curChar == '""') {
/*  135 */                 jjCheckNAdd(15);
/*  136 */               } else if (this.curChar == '!') {
/*      */                 
/*  138 */                 if (kind > 9)
/*  139 */                   kind = 9; 
/*      */               } 
/*  141 */               if (this.curChar == '&')
/*  142 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 4:
/*  145 */               if (this.curChar == '&' && kind > 7)
/*  146 */                 kind = 7; 
/*      */               break;
/*      */             case 5:
/*  149 */               if (this.curChar == '&')
/*  150 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 13:
/*  153 */               if (this.curChar == '!' && kind > 9)
/*  154 */                 kind = 9; 
/*      */               break;
/*      */             case 14:
/*  157 */               if (this.curChar == '""')
/*  158 */                 jjCheckNAdd(15); 
/*      */               break;
/*      */             case 15:
/*  161 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  162 */                 jjCheckNAddTwoStates(15, 16); 
/*      */               break;
/*      */             case 16:
/*  165 */               if (this.curChar == '""' && kind > 16)
/*  166 */                 kind = 16; 
/*      */               break;
/*      */             case 18:
/*  169 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  171 */               if (kind > 18)
/*  172 */                 kind = 18; 
/*  173 */               jjAddStates(7, 8);
/*      */               break;
/*      */             case 19:
/*  176 */               if (this.curChar == '.')
/*  177 */                 jjCheckNAdd(20); 
/*      */               break;
/*      */             case 20:
/*  180 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  182 */               if (kind > 18)
/*  183 */                 kind = 18; 
/*  184 */               jjCheckNAdd(20);
/*      */               break;
/*      */             case 21:
/*  187 */               if ((0x7BFFD0F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  189 */               if (kind > 17)
/*  190 */                 kind = 17; 
/*  191 */               jjCheckNAddStates(0, 6);
/*      */               break;
/*      */             case 22:
/*  194 */               if ((0x7BFFF8F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  196 */               if (kind > 17)
/*  197 */                 kind = 17; 
/*  198 */               jjCheckNAddTwoStates(22, 23);
/*      */               break;
/*      */             case 24:
/*  201 */               if ((0x84002F0600000000L & l) == 0L)
/*      */                 break; 
/*  203 */               if (kind > 17)
/*  204 */                 kind = 17; 
/*  205 */               jjCheckNAddTwoStates(22, 23);
/*      */               break;
/*      */             case 25:
/*  208 */               if ((0x7BFFF8F8FFFFD9FFL & l) != 0L)
/*  209 */                 jjCheckNAddStates(9, 11); 
/*      */               break;
/*      */             case 26:
/*  212 */               if (this.curChar == '*' && kind > 19)
/*  213 */                 kind = 19; 
/*      */               break;
/*      */             case 28:
/*  216 */               if ((0x84002F0600000000L & l) != 0L)
/*  217 */                 jjCheckNAddStates(9, 11); 
/*      */               break;
/*      */             case 29:
/*  220 */               if ((0xFBFFFCF8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  222 */               if (kind > 20)
/*  223 */                 kind = 20; 
/*  224 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 31:
/*  227 */               if ((0x84002F0600000000L & l) == 0L)
/*      */                 break; 
/*  229 */               if (kind > 20)
/*  230 */                 kind = 20; 
/*  231 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */           } 
/*      */         
/*  235 */         } while (i != startsAt);
/*      */       }
/*  237 */       else if (this.curChar < '') {
/*      */         
/*  239 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  242 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  245 */               if ((0x97FFFFFF97FFFFFFL & l) != 0L) {
/*      */                 
/*  247 */                 if (kind > 17)
/*  248 */                   kind = 17; 
/*  249 */                 jjCheckNAddStates(0, 6);
/*      */               }
/*  251 */               else if (this.curChar == '~') {
/*      */                 
/*  253 */                 if (kind > 18)
/*  254 */                   kind = 18; 
/*  255 */                 this.jjstateSet[this.jjnewStateCnt++] = 18;
/*      */               } 
/*  257 */               if (this.curChar == '\\') {
/*  258 */                 jjCheckNAddStates(12, 14); break;
/*  259 */               }  if (this.curChar == 'N') {
/*  260 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; break;
/*  261 */               }  if (this.curChar == '|') {
/*  262 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; break;
/*  263 */               }  if (this.curChar == 'O') {
/*  264 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; break;
/*  265 */               }  if (this.curChar == 'A')
/*  266 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 1:
/*  269 */               if (this.curChar == 'D' && kind > 7)
/*  270 */                 kind = 7; 
/*      */               break;
/*      */             case 2:
/*  273 */               if (this.curChar == 'N')
/*  274 */                 this.jjstateSet[this.jjnewStateCnt++] = 1; 
/*      */               break;
/*      */             case 3:
/*  277 */               if (this.curChar == 'A')
/*  278 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 6:
/*  281 */               if (this.curChar == 'R' && kind > 8)
/*  282 */                 kind = 8; 
/*      */               break;
/*      */             case 7:
/*  285 */               if (this.curChar == 'O')
/*  286 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; 
/*      */               break;
/*      */             case 8:
/*  289 */               if (this.curChar == '|' && kind > 8)
/*  290 */                 kind = 8; 
/*      */               break;
/*      */             case 9:
/*  293 */               if (this.curChar == '|')
/*  294 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; 
/*      */               break;
/*      */             case 10:
/*  297 */               if (this.curChar == 'T' && kind > 9)
/*  298 */                 kind = 9; 
/*      */               break;
/*      */             case 11:
/*  301 */               if (this.curChar == 'O')
/*  302 */                 this.jjstateSet[this.jjnewStateCnt++] = 10; 
/*      */               break;
/*      */             case 12:
/*  305 */               if (this.curChar == 'N')
/*  306 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; 
/*      */               break;
/*      */             case 15:
/*  309 */               jjAddStates(15, 16);
/*      */               break;
/*      */             case 17:
/*  312 */               if (this.curChar != '~')
/*      */                 break; 
/*  314 */               if (kind > 18)
/*  315 */                 kind = 18; 
/*  316 */               this.jjstateSet[this.jjnewStateCnt++] = 18;
/*      */               break;
/*      */             case 21:
/*  319 */               if ((0x97FFFFFF97FFFFFFL & l) == 0L)
/*      */                 break; 
/*  321 */               if (kind > 17)
/*  322 */                 kind = 17; 
/*  323 */               jjCheckNAddStates(0, 6);
/*      */               break;
/*      */             case 22:
/*  326 */               if ((0x97FFFFFF97FFFFFFL & l) == 0L)
/*      */                 break; 
/*  328 */               if (kind > 17)
/*  329 */                 kind = 17; 
/*  330 */               jjCheckNAddTwoStates(22, 23);
/*      */               break;
/*      */             case 23:
/*  333 */               if (this.curChar == '\\')
/*  334 */                 jjCheckNAddTwoStates(24, 24); 
/*      */               break;
/*      */             case 24:
/*  337 */               if ((0x6800000078000000L & l) == 0L)
/*      */                 break; 
/*  339 */               if (kind > 17)
/*  340 */                 kind = 17; 
/*  341 */               jjCheckNAddTwoStates(22, 23);
/*      */               break;
/*      */             case 25:
/*  344 */               if ((0x97FFFFFF97FFFFFFL & l) != 0L)
/*  345 */                 jjCheckNAddStates(9, 11); 
/*      */               break;
/*      */             case 27:
/*  348 */               if (this.curChar == '\\')
/*  349 */                 jjCheckNAddTwoStates(28, 28); 
/*      */               break;
/*      */             case 28:
/*  352 */               if ((0x6800000078000000L & l) != 0L)
/*  353 */                 jjCheckNAddStates(9, 11); 
/*      */               break;
/*      */             case 29:
/*  356 */               if ((0x97FFFFFF97FFFFFFL & l) == 0L)
/*      */                 break; 
/*  358 */               if (kind > 20)
/*  359 */                 kind = 20; 
/*  360 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 30:
/*  363 */               if (this.curChar == '\\')
/*  364 */                 jjCheckNAddTwoStates(31, 31); 
/*      */               break;
/*      */             case 31:
/*  367 */               if ((0x6800000078000000L & l) == 0L)
/*      */                 break; 
/*  369 */               if (kind > 20)
/*  370 */                 kind = 20; 
/*  371 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*  374 */               if (this.curChar == '\\') {
/*  375 */                 jjCheckNAddStates(12, 14);
/*      */               }
/*      */               break;
/*      */           } 
/*  379 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  383 */         int hiByte = this.curChar >> 8;
/*  384 */         int i1 = hiByte >> 6;
/*  385 */         long l1 = 1L << (hiByte & 0x3F);
/*  386 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  387 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  390 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  393 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  395 */               if (kind > 17)
/*  396 */                 kind = 17; 
/*  397 */               jjCheckNAddStates(0, 6);
/*      */               break;
/*      */             case 15:
/*  400 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*  401 */                 jjAddStates(15, 16); 
/*      */               break;
/*      */             case 22:
/*  404 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  406 */               if (kind > 17)
/*  407 */                 kind = 17; 
/*  408 */               jjCheckNAddTwoStates(22, 23);
/*      */               break;
/*      */             case 25:
/*  411 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*  412 */                 jjCheckNAddStates(9, 11); 
/*      */               break;
/*      */             case 29:
/*  415 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  417 */               if (kind > 20)
/*  418 */                 kind = 20; 
/*  419 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */           } 
/*      */         
/*  423 */         } while (i != startsAt);
/*      */       } 
/*  425 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  427 */         this.jjmatchedKind = kind;
/*  428 */         this.jjmatchedPos = curPos;
/*  429 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  431 */       curPos++;
/*  432 */       if ((i = this.jjnewStateCnt) == (startsAt = 33 - (this.jjnewStateCnt = startsAt)))
/*  433 */         return curPos;  
/*  434 */       try { this.curChar = this.input_stream.readChar(); }
/*  435 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_1(int pos, long active0) {
/*  440 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  443 */         if ((active0 & 0x10000000L) != 0L) {
/*      */           
/*  445 */           this.jjmatchedKind = 31;
/*  446 */           return 4;
/*      */         } 
/*  448 */         return -1;
/*      */     } 
/*  450 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  455 */   private final int jjStartNfa_1(int pos, long active0) { return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStartNfaWithStates_1(int pos, int kind, int state) {
/*  459 */     this.jjmatchedKind = kind;
/*  460 */     this.jjmatchedPos = pos; 
/*  461 */     try { this.curChar = this.input_stream.readChar(); }
/*  462 */     catch (IOException e) { return pos + 1; }
/*  463 */      return jjMoveNfa_1(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_1() {
/*  467 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  470 */         return jjMoveStringLiteralDfa1_1(268435456L);
/*      */       case '}':
/*  472 */         return jjStopAtPos(0, 29);
/*      */     } 
/*  474 */     return jjMoveNfa_1(0, 0);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa1_1(long active0) {
/*      */     try {
/*  479 */       this.curChar = this.input_stream.readChar();
/*  480 */     } catch (IOException e) {
/*  481 */       jjStopStringLiteralDfa_1(0, active0);
/*  482 */       return 1;
/*      */     } 
/*  484 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  487 */         if ((active0 & 0x10000000L) != 0L) {
/*  488 */           return jjStartNfaWithStates_1(1, 28, 4);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  493 */     return jjStartNfa_1(0, active0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_1(int startState, int curPos) {
/*  498 */     int startsAt = 0;
/*  499 */     this.jjnewStateCnt = 5;
/*  500 */     int i = 1;
/*  501 */     this.jjstateSet[0] = startState;
/*  502 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  505 */       if (++this.jjround == Integer.MAX_VALUE)
/*  506 */         ReInitRounds(); 
/*  507 */       if (this.curChar < '@') {
/*      */         
/*  509 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  512 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  515 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  517 */                 if (kind > 31)
/*  518 */                   kind = 31; 
/*  519 */                 jjCheckNAdd(4);
/*      */               } 
/*  521 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  523 */                 if (kind > 6)
/*  524 */                   kind = 6;  break;
/*      */               } 
/*  526 */               if (this.curChar == '""')
/*  527 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 1:
/*  530 */               if (this.curChar == '""')
/*  531 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 2:
/*  534 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  535 */                 jjCheckNAddTwoStates(2, 3); 
/*      */               break;
/*      */             case 3:
/*  538 */               if (this.curChar == '""' && kind > 30)
/*  539 */                 kind = 30; 
/*      */               break;
/*      */             case 4:
/*  542 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  544 */               if (kind > 31)
/*  545 */                 kind = 31; 
/*  546 */               jjCheckNAdd(4);
/*      */               break;
/*      */           } 
/*      */         
/*  550 */         } while (i != startsAt);
/*      */       }
/*  552 */       else if (this.curChar < '') {
/*      */         
/*  554 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  557 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 4:
/*  561 */               if ((0xDFFFFFFFFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  563 */               if (kind > 31)
/*  564 */                 kind = 31; 
/*  565 */               jjCheckNAdd(4);
/*      */               break;
/*      */             case 2:
/*  568 */               jjAddStates(17, 18);
/*      */               break;
/*      */           } 
/*      */         
/*  572 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  576 */         int hiByte = this.curChar >> 8;
/*  577 */         int i1 = hiByte >> 6;
/*  578 */         long l1 = 1L << (hiByte & 0x3F);
/*  579 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  580 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  583 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 4:
/*  587 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  589 */               if (kind > 31)
/*  590 */                 kind = 31; 
/*  591 */               jjCheckNAdd(4);
/*      */               break;
/*      */             case 2:
/*  594 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  595 */                 jjAddStates(17, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  599 */         } while (i != startsAt);
/*      */       } 
/*  601 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  603 */         this.jjmatchedKind = kind;
/*  604 */         this.jjmatchedPos = curPos;
/*  605 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  607 */       curPos++;
/*  608 */       if ((i = this.jjnewStateCnt) == (startsAt = 5 - (this.jjnewStateCnt = startsAt)))
/*  609 */         return curPos;  
/*  610 */       try { this.curChar = this.input_stream.readChar(); }
/*  611 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   
/*  616 */   private final int jjMoveStringLiteralDfa0_0() { return jjMoveNfa_0(0, 0); }
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_0(int startState, int curPos) {
/*  621 */     int startsAt = 0;
/*  622 */     this.jjnewStateCnt = 3;
/*  623 */     int i = 1;
/*  624 */     this.jjstateSet[0] = startState;
/*  625 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  628 */       if (++this.jjround == Integer.MAX_VALUE)
/*  629 */         ReInitRounds(); 
/*  630 */       if (this.curChar < '@') {
/*      */         
/*  632 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  635 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  638 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  640 */               if (kind > 23)
/*  641 */                 kind = 23; 
/*  642 */               jjAddStates(19, 20);
/*      */               break;
/*      */             case 1:
/*  645 */               if (this.curChar == '.')
/*  646 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 2:
/*  649 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  651 */               if (kind > 23)
/*  652 */                 kind = 23; 
/*  653 */               jjCheckNAdd(2);
/*      */               break;
/*      */           } 
/*      */         
/*  657 */         } while (i != startsAt);
/*      */       }
/*  659 */       else if (this.curChar < '') {
/*      */         
/*  661 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  664 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  668 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  672 */         int hiByte = this.curChar >> 8;
/*  673 */         int i1 = hiByte >> 6;
/*  674 */         long l1 = 1L << (hiByte & 0x3F);
/*  675 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  676 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  679 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  683 */         } while (i != startsAt);
/*      */       } 
/*  685 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  687 */         this.jjmatchedKind = kind;
/*  688 */         this.jjmatchedPos = curPos;
/*  689 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  691 */       curPos++;
/*  692 */       if ((i = this.jjnewStateCnt) == (startsAt = 3 - (this.jjnewStateCnt = startsAt)))
/*  693 */         return curPos;  
/*  694 */       try { this.curChar = this.input_stream.readChar(); }
/*  695 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_2(int pos, long active0) {
/*  700 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  703 */         if ((active0 & 0x1000000L) != 0L) {
/*      */           
/*  705 */           this.jjmatchedKind = 27;
/*  706 */           return 4;
/*      */         } 
/*  708 */         return -1;
/*      */     } 
/*  710 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  715 */   private final int jjStartNfa_2(int pos, long active0) { return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStartNfaWithStates_2(int pos, int kind, int state) {
/*  719 */     this.jjmatchedKind = kind;
/*  720 */     this.jjmatchedPos = pos; 
/*  721 */     try { this.curChar = this.input_stream.readChar(); }
/*  722 */     catch (IOException e) { return pos + 1; }
/*  723 */      return jjMoveNfa_2(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_2() {
/*  727 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  730 */         return jjMoveStringLiteralDfa1_2(16777216L);
/*      */       case ']':
/*  732 */         return jjStopAtPos(0, 25);
/*      */     } 
/*  734 */     return jjMoveNfa_2(0, 0);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa1_2(long active0) {
/*      */     try {
/*  739 */       this.curChar = this.input_stream.readChar();
/*  740 */     } catch (IOException e) {
/*  741 */       jjStopStringLiteralDfa_2(0, active0);
/*  742 */       return 1;
/*      */     } 
/*  744 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  747 */         if ((active0 & 0x1000000L) != 0L) {
/*  748 */           return jjStartNfaWithStates_2(1, 24, 4);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  753 */     return jjStartNfa_2(0, active0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_2(int startState, int curPos) {
/*  758 */     int startsAt = 0;
/*  759 */     this.jjnewStateCnt = 5;
/*  760 */     int i = 1;
/*  761 */     this.jjstateSet[0] = startState;
/*  762 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  765 */       if (++this.jjround == Integer.MAX_VALUE)
/*  766 */         ReInitRounds(); 
/*  767 */       if (this.curChar < '@') {
/*      */         
/*  769 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  772 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  775 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  777 */                 if (kind > 27)
/*  778 */                   kind = 27; 
/*  779 */                 jjCheckNAdd(4);
/*      */               } 
/*  781 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  783 */                 if (kind > 6)
/*  784 */                   kind = 6;  break;
/*      */               } 
/*  786 */               if (this.curChar == '""')
/*  787 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 1:
/*  790 */               if (this.curChar == '""')
/*  791 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 2:
/*  794 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  795 */                 jjCheckNAddTwoStates(2, 3); 
/*      */               break;
/*      */             case 3:
/*  798 */               if (this.curChar == '""' && kind > 26)
/*  799 */                 kind = 26; 
/*      */               break;
/*      */             case 4:
/*  802 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  804 */               if (kind > 27)
/*  805 */                 kind = 27; 
/*  806 */               jjCheckNAdd(4);
/*      */               break;
/*      */           } 
/*      */         
/*  810 */         } while (i != startsAt);
/*      */       }
/*  812 */       else if (this.curChar < '') {
/*      */         
/*  814 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  817 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 4:
/*  821 */               if ((0xFFFFFFFFDFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  823 */               if (kind > 27)
/*  824 */                 kind = 27; 
/*  825 */               jjCheckNAdd(4);
/*      */               break;
/*      */             case 2:
/*  828 */               jjAddStates(17, 18);
/*      */               break;
/*      */           } 
/*      */         
/*  832 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  836 */         int hiByte = this.curChar >> 8;
/*  837 */         int i1 = hiByte >> 6;
/*  838 */         long l1 = 1L << (hiByte & 0x3F);
/*  839 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  840 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  843 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 4:
/*  847 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  849 */               if (kind > 27)
/*  850 */                 kind = 27; 
/*  851 */               jjCheckNAdd(4);
/*      */               break;
/*      */             case 2:
/*  854 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  855 */                 jjAddStates(17, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  859 */         } while (i != startsAt);
/*      */       } 
/*  861 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  863 */         this.jjmatchedKind = kind;
/*  864 */         this.jjmatchedPos = curPos;
/*  865 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  867 */       curPos++;
/*  868 */       if ((i = this.jjnewStateCnt) == (startsAt = 5 - (this.jjnewStateCnt = startsAt)))
/*  869 */         return curPos;  
/*  870 */       try { this.curChar = this.input_stream.readChar(); }
/*  871 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*  874 */   } static final int[] jjnextStates = new int[] { 22, 25, 26, 29, 30, 27, 23, 18, 19, 25, 26, 27, 24, 28, 31, 15, 16, 2, 3, 0, 1 };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
/*  880 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/*  883 */         return ((jjbitVec2[i2] & l2) != 0L);
/*      */     } 
/*  885 */     if ((jjbitVec0[i1] & l1) != 0L)
/*  886 */       return true; 
/*  887 */     return false;
/*      */   }
/*      */   
/*  890 */   public static final String[] jjstrLiteralImages = new String[] { """", null, null, null, null, null, null, null, null, null, ""+"", ""-"", ""("", "")"", "":"", ""^"", null, null, null, null, null, ""["", ""{"", null, ""TO"", ""]"", null, null, ""TO"", ""}"", null, null };
/*      */ 
/*      */ 
/*      */   
/*  894 */   public static final String[] lexStateNames = new String[] { ""Boost"", ""RangeEx"", ""RangeIn"", ""DEFAULT"" };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  900 */   public static final int[] jjnewLexState = new int[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 3, -1, 3, -1, -1, -1, 3, -1, -1 };
/*      */ 
/*      */ 
/*      */   
/*  904 */   static final long[] jjtoToken = new long[] { 4294967169L };
/*      */ 
/*      */   
/*  907 */   static final long[] jjtoSkip = new long[] { 64L };
/*      */   
/*      */   protected CharStream input_stream;
/*      */   
/*  911 */   private final int[] jjrounds = new int[33];
/*  912 */   private final int[] jjstateSet = new int[66]; protected char curChar; int curLexState;
/*      */   int defaultLexState;
/*      */   int jjnewStateCnt;
/*      */   int jjround;
/*      */   int jjmatchedPos;
/*      */   int jjmatchedKind;
/*      */   
/*      */   public QueryParserTokenManager(CharStream stream, int lexState) {
/*  920 */     this(stream);
/*  921 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream) {
/*  925 */     this.jjmatchedPos = this.jjnewStateCnt = 0;
/*  926 */     this.curLexState = this.defaultLexState;
/*  927 */     this.input_stream = stream;
/*  928 */     ReInitRounds();
/*      */   }
/*      */ 
/*      */   
/*      */   private final void ReInitRounds() {
/*  933 */     this.jjround = -2147483647;
/*  934 */     for (int i = 33; i-- > 0;)
/*  935 */       this.jjrounds[i] = Integer.MIN_VALUE; 
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream, int lexState) {
/*  939 */     ReInit(stream);
/*  940 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void SwitchTo(int lexState) {
/*  944 */     if (lexState >= 4 || lexState < 0) {
/*  945 */       throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", 2);
/*      */     }
/*  947 */     this.curLexState = lexState;
/*      */   }
/*      */ 
/*      */   
/*      */   protected Token jjFillToken() {
/*  952 */     Token t = Token.newToken(this.jjmatchedKind);
/*  953 */     t.kind = this.jjmatchedKind;
/*  954 */     String im = jjstrLiteralImages[this.jjmatchedKind];
/*  955 */     t.image = (im == null) ? this.input_stream.GetImage() : im;
/*  956 */     t.beginLine = this.input_stream.getBeginLine();
/*  957 */     t.beginColumn = this.input_stream.getBeginColumn();
/*  958 */     t.endLine = this.input_stream.getEndLine();
/*  959 */     t.endColumn = this.input_stream.getEndColumn();
/*  960 */     return t;
/*      */   }
/*      */   public QueryParserTokenManager(CharStream stream) {
/*  963 */     this.curLexState = 3;
/*  964 */     this.defaultLexState = 3;
/*      */     this.input_stream = stream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Token getNextToken() {
/*  973 */     Token specialToken = null;
/*      */     
/*  975 */     int curPos = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     while (true) {
/*      */       try {
/*  982 */         this.curChar = this.input_stream.BeginToken();
/*      */       }
/*  984 */       catch (IOException e) {
/*      */         
/*  986 */         this.jjmatchedKind = 0;
/*  987 */         Token matchedToken = jjFillToken();
/*  988 */         return matchedToken;
/*      */       } 
/*      */       
/*  991 */       switch (this.curLexState) {
/*      */         
/*      */         case 0:
/*  994 */           this.jjmatchedKind = Integer.MAX_VALUE;
/*  995 */           this.jjmatchedPos = 0;
/*  996 */           curPos = jjMoveStringLiteralDfa0_0();
/*      */           break;
/*      */         case 1:
/*  999 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1000 */           this.jjmatchedPos = 0;
/* 1001 */           curPos = jjMoveStringLiteralDfa0_1();
/*      */           break;
/*      */         case 2:
/* 1004 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1005 */           this.jjmatchedPos = 0;
/* 1006 */           curPos = jjMoveStringLiteralDfa0_2();
/*      */           break;
/*      */         case 3:
/* 1009 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1010 */           this.jjmatchedPos = 0;
/* 1011 */           curPos = jjMoveStringLiteralDfa0_3();
/*      */           break;
/*      */       } 
/* 1014 */       if (this.jjmatchedKind != Integer.MAX_VALUE) {
/*      */         
/* 1016 */         if (this.jjmatchedPos + 1 < curPos)
/* 1017 */           this.input_stream.backup(curPos - this.jjmatchedPos - 1); 
/* 1018 */         if ((jjtoToken[this.jjmatchedKind >> 6] & 1L << (this.jjmatchedKind & 0x3F)) != 0L) {
/*      */           
/* 1020 */           Token matchedToken = jjFillToken();
/* 1021 */           if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1022 */             this.curLexState = jjnewLexState[this.jjmatchedKind]; 
/* 1023 */           return matchedToken;
/*      */         } 
/*      */ 
/*      */         
/* 1027 */         if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1028 */           this.curLexState = jjnewLexState[this.jjmatchedKind];  continue;
/*      */       } 
/*      */       break;
/*      */     } 
/* 1032 */     int error_line = this.input_stream.getEndLine();
/* 1033 */     int error_column = this.input_stream.getEndColumn();
/* 1034 */     String error_after = null;
/* 1035 */     boolean EOFSeen = false; try {
/* 1036 */       this.input_stream.readChar(); this.input_stream.backup(1);
/* 1037 */     } catch (IOException e1) {
/* 1038 */       EOFSeen = true;
/* 1039 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/* 1040 */       if (this.curChar == '\n' || this.curChar == '\r') {
/* 1041 */         error_line++;
/* 1042 */         error_column = 0;
/*      */       } else {
/*      */         
/* 1045 */         error_column++;
/*      */       } 
/* 1047 */     }  if (!EOFSeen) {
/* 1048 */       this.input_stream.backup(1);
/* 1049 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/*      */     } 
/* 1051 */     throw new TokenMgrError(EOFSeen, this.curLexState, error_line, error_column, error_after, this.curChar, 0);
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\QueryParserTokenManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.Token,"/*    */ package org.apache.lucene.queryParser;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Token
/*    */ {
/*    */   public int kind;
/*    */   public int beginLine;
/*    */   public int beginColumn;
/*    */   public int endLine;
/*    */   public int endColumn;
/*    */   public String image;
/*    */   public Token next;
/*    */   public Token specialToken;
/*    */   
/* 58 */   public String toString() { return this.image; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static final Token newToken(int ofKind) {
/* 75 */     switch (ofKind) {
/*    */     
/* 77 */     }  return new Token();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.TokenMgrError,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TokenMgrError
/*     */   extends Error
/*     */ {
/*     */   static final int LEXICAL_ERROR = 0;
/*     */   static final int STATIC_LEXER_ERROR = 1;
/*     */   static final int INVALID_LEXICAL_STATE = 2;
/*     */   static final int LOOP_DETECTED = 3;
/*     */   int errorCode;
/*     */   
/*     */   protected static final String addEscapes(String str) {
/*  41 */     StringBuffer retval = new StringBuffer();
/*     */     
/*  43 */     for (int i = 0; i < str.length(); i++) {
/*  44 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/*  49 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/*  52 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/*  55 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/*  58 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/*  61 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/*  64 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/*  67 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/*  70 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/*  73 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/*  74 */             String s = ""0000"" + Integer.toString(ch, 16);
/*  75 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/*  77 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/*  82 */     return retval.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + curChar + ""), "")) + ""after : \"""" + addEscapes(errorAfter) + ""\""""; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public String getMessage() { return super.getMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError(String message, int reason) {
/* 126 */     super(message);
/* 127 */     this.errorCode = reason;
/*     */   }
/*     */ 
/*     */   
/* 131 */   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\queryParser\TokenMgrError.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanClause,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanClause
/*     */   implements Serializable
/*     */ {
/*     */   private Query query;
/*     */   
/*     */   public static final class Occur
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  29 */     private Occur(String name) { super(name); }
/*     */ 
/*     */     
/*     */     public String toString() {
/*  33 */       if (this == MUST) return ""+""; 
/*  34 */       if (this == MUST_NOT) return ""-""; 
/*  35 */       return """";
/*     */     }
/*     */ 
/*     */     
/*  39 */     public static final Occur MUST = new Occur(""MUST"");
/*     */ 
/*     */ 
/*     */     
/*  43 */     public static final Occur SHOULD = new Occur(""SHOULD"");
/*     */ 
/*     */ 
/*     */     
/*  47 */     public static final Occur MUST_NOT = new Occur(""MUST_NOT"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   private Occur occur = Occur.SHOULD;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanClause(Query query, Occur occur) {
/*  61 */     this.query = query;
/*  62 */     this.occur = occur;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  67 */   public Occur getOccur() { return this.occur; }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public void setOccur(Occur occur) { this.occur = occur; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/*  80 */   public void setQuery(Query query) { this.query = query; }
/*     */ 
/*     */ 
/*     */   
/*  84 */   public boolean isProhibited() { return Occur.MUST_NOT.equals(this.occur); }
/*     */ 
/*     */ 
/*     */   
/*  88 */   public boolean isRequired() { return Occur.MUST.equals(this.occur); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  95 */     if (!(o instanceof BooleanClause))
/*  96 */       return false; 
/*  97 */     BooleanClause other = (BooleanClause)o;
/*  98 */     return (this.query.equals(other.query) && this.occur.equals(other.occur));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public int hashCode() { return this.query.hashCode() ^ (Occur.MUST.equals(this.occur) ? 1 : 0) ^ (Occur.MUST_NOT.equals(this.occur) ? 2 : 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public String toString() { return this.occur.toString() + this.query.toString(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\BooleanClause.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanQuery
/*     */   extends Query
/*     */ {
/*  36 */   private static int maxClauseCount = 1024;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static class TooManyClauses
/*     */     extends RuntimeException {}
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public static int getMaxClauseCount() { return maxClauseCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void setMaxClauseCount(int maxClauseCount) {
/*  66 */     if (maxClauseCount < 1)
/*  67 */       throw new IllegalArgumentException(""maxClauseCount must be >= 1""); 
/*  68 */     BooleanQuery.maxClauseCount = maxClauseCount;
/*     */   }
/*     */   
/*  71 */   private Vector clauses = new Vector();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean disableCoord;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  94 */   public boolean isCoordDisabled() { return this.disableCoord; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Similarity getSimilarity(Searcher searcher) {
/*  99 */     Similarity result = super.getSimilarity(searcher);
/* 100 */     if (this.disableCoord) {
/* 101 */       result = new SimilarityDelegator(result) { private final BooleanQuery this$0;
/*     */           
/* 103 */           public float coord(int overlap, int maxOverlap) { return 1.0F; }
/*     */            }
/*     */         ;
/*     */     }
/* 107 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 133 */   public void setMinimumNumberShouldMatch(int min) { this.minNrShouldMatch = min; }
/*     */   
/* 135 */   public BooleanQuery() { this.minNrShouldMatch = 0; } public BooleanQuery(boolean disableCoord) { this.minNrShouldMatch = 0;
/*     */     this.disableCoord = disableCoord; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   public int getMinimumNumberShouldMatch() { return this.minNrShouldMatch; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 151 */   public void add(Query query, BooleanClause.Occur occur) { add(new BooleanClause(query, occur)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(BooleanClause clause) {
/* 159 */     if (this.clauses.size() >= maxClauseCount) {
/* 160 */       throw new TooManyClauses();
/*     */     }
/* 162 */     this.clauses.addElement(clause);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 167 */   public BooleanClause[] getClauses() { return (BooleanClause[])this.clauses.toArray((Object[])new BooleanClause[0]); }
/*     */   
/*     */   private class BooleanWeight
/*     */     implements Weight {
/*     */     protected Similarity similarity;
/* 172 */     protected Vector weights = new Vector();
/*     */     private final BooleanQuery this$0;
/*     */     
/*     */     public BooleanWeight(Searcher searcher) throws IOException {
/* 176 */       this.similarity = BooleanQuery.this.getSimilarity(searcher);
/* 177 */       for (int i = 0; i < BooleanQuery.this.clauses.size(); i++) {
/* 178 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 179 */         this.weights.add(c.getQuery().createWeight(searcher));
/*     */       } 
/*     */     }
/*     */     
/* 183 */     public Query getQuery() { return BooleanQuery.this; }
/* 184 */     public float getValue() { return BooleanQuery.this.getBoost(); }
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 187 */       float sum = 0.0F;
/* 188 */       for (int i = 0; i < this.weights.size(); i++) {
/* 189 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 190 */         Weight w = this.weights.elementAt(i);
/* 191 */         if (!c.isProhibited()) {
/* 192 */           sum += w.sumOfSquaredWeights();
/*     */         }
/*     */       } 
/* 195 */       sum *= BooleanQuery.this.getBoost() * BooleanQuery.this.getBoost();
/*     */       
/* 197 */       return sum;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 202 */       norm *= BooleanQuery.this.getBoost();
/* 203 */       for (int i = 0; i < this.weights.size(); i++) {
/* 204 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 205 */         Weight w = this.weights.elementAt(i);
/* 206 */         if (!c.isProhibited()) {
/* 207 */           w.normalize(norm);
/*     */         }
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 219 */       boolean allRequired = true;
/* 220 */       boolean noneBoolean = true;
/* 221 */       for (int i = 0; i < this.weights.size(); i++) {
/* 222 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 223 */         if (!c.isRequired())
/* 224 */           allRequired = false; 
/* 225 */         if (c.getQuery() instanceof BooleanQuery) {
/* 226 */           noneBoolean = false;
/*     */         }
/*     */       } 
/* 229 */       if (allRequired && noneBoolean) {
/* 230 */         ConjunctionScorer result = new ConjunctionScorer(this.similarity);
/*     */         
/* 232 */         for (int i = 0; i < this.weights.size(); i++) {
/* 233 */           Weight w = this.weights.elementAt(i);
/* 234 */           Scorer subScorer = w.scorer(reader);
/* 235 */           if (subScorer == null)
/* 236 */             return null; 
/* 237 */           result.add(subScorer);
/*     */         } 
/* 239 */         return result;
/*     */       } 
/*     */ 
/*     */       
/* 243 */       BooleanScorer result = new BooleanScorer(this.similarity);
/*     */       
/* 245 */       for (int i = 0; i < this.weights.size(); i++) {
/* 246 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 247 */         Weight w = this.weights.elementAt(i);
/* 248 */         Scorer subScorer = w.scorer(reader);
/* 249 */         if (subScorer != null) {
/* 250 */           result.add(subScorer, c.isRequired(), c.isProhibited());
/* 251 */         } else if (c.isRequired()) {
/* 252 */           return null;
/*     */         } 
/*     */       } 
/* 255 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 260 */       Explanation sumExpl = new Explanation();
/* 261 */       sumExpl.setDescription(""sum of:"");
/* 262 */       int coord = 0;
/* 263 */       int maxCoord = 0;
/* 264 */       float sum = 0.0F;
/* 265 */       for (int i = 0; i < this.weights.size(); i++) {
/* 266 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 267 */         Weight w = this.weights.elementAt(i);
/* 268 */         Explanation e = w.explain(reader, doc);
/* 269 */         if (!c.isProhibited()) maxCoord++; 
/* 270 */         if (e.getValue() > 0.0F) {
/* 271 */           if (!c.isProhibited()) {
/* 272 */             sumExpl.addDetail(e);
/* 273 */             sum += e.getValue();
/* 274 */             coord++;
/*     */           } else {
/* 276 */             return new Explanation(0.0F, ""match prohibited"");
/*     */           } 
/* 278 */         } else if (c.isRequired()) {
/* 279 */           return new Explanation(0.0F, ""match required"");
/*     */         } 
/*     */       } 
/* 282 */       sumExpl.setValue(sum);
/*     */       
/* 284 */       if (coord == 1) {
/* 285 */         sumExpl = sumExpl.getDetails()[0];
/*     */       }
/* 287 */       float coordFactor = this.similarity.coord(coord, maxCoord);
/* 288 */       if (coordFactor == 1.0F) {
/* 289 */         return sumExpl;
/*     */       }
/* 291 */       Explanation result = new Explanation();
/* 292 */       result.setDescription(""product of:"");
/* 293 */       result.addDetail(sumExpl);
/* 294 */       result.addDetail(new Explanation(coordFactor, ""coord("" + coord + ""/"" + maxCoord + "")""));
/*     */       
/* 296 */       result.setValue(sum * coordFactor);
/* 297 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   private class BooleanWeight2
/*     */     extends BooleanWeight
/*     */   {
/*     */     private final BooleanQuery this$0;
/*     */     
/* 306 */     public BooleanWeight2(Searcher searcher) throws IOException { super(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 313 */       BooleanScorer2 result = new BooleanScorer2(this.similarity, BooleanQuery.this.minNrShouldMatch);
/*     */ 
/*     */       
/* 316 */       for (int i = 0; i < this.weights.size(); i++) {
/* 317 */         BooleanClause c = BooleanQuery.this.clauses.elementAt(i);
/* 318 */         Weight w = this.weights.elementAt(i);
/* 319 */         Scorer subScorer = w.scorer(reader);
/* 320 */         if (subScorer != null) {
/* 321 */           result.add(subScorer, c.isRequired(), c.isProhibited());
/* 322 */         } else if (c.isRequired()) {
/* 323 */           return null;
/*     */         } 
/*     */       } 
/* 326 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private static boolean useScorer14 = false;
/*     */ 
/*     */   
/* 334 */   public static void setUseScorer14(boolean use14) { useScorer14 = use14; }
/*     */ 
/*     */ 
/*     */   
/* 338 */   public static boolean getUseScorer14() { return useScorer14; }
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/* 343 */     if (0 < this.minNrShouldMatch)
/*     */     {
/* 345 */       return new BooleanWeight2(searcher);
/*     */     }
/*     */     
/* 348 */     return getUseScorer14() ? new BooleanWeight(searcher) : new BooleanWeight2(searcher);
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 353 */     if (this.clauses.size() == 1) {
/* 354 */       BooleanClause c = this.clauses.elementAt(0);
/* 355 */       if (!c.isProhibited()) {
/*     */         
/* 357 */         Query query = c.getQuery().rewrite(reader);
/*     */         
/* 359 */         if (getBoost() != 1.0F) {
/* 360 */           if (query == c.getQuery())
/* 361 */             query = (Query)query.clone(); 
/* 362 */           query.setBoost(getBoost() * query.getBoost());
/*     */         } 
/*     */         
/* 365 */         return query;
/*     */       } 
/*     */     } 
/*     */     
/* 369 */     BooleanQuery clone = null;
/* 370 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 371 */       BooleanClause c = this.clauses.elementAt(i);
/* 372 */       Query query = c.getQuery().rewrite(reader);
/* 373 */       if (query != c.getQuery()) {
/* 374 */         if (clone == null)
/* 375 */           clone = (BooleanQuery)clone(); 
/* 376 */         clone.clauses.setElementAt(new BooleanClause(query, c.getOccur()), i);
/*     */       } 
/*     */     } 
/*     */     
/* 380 */     if (clone != null) {
/* 381 */       return clone;
/*     */     }
/* 383 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 388 */     for (Iterator i = this.clauses.iterator(); i.hasNext(); ) {
/* 389 */       BooleanClause clause = i.next();
/* 390 */       clause.getQuery().extractTerms(terms);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Object clone() {
/* 395 */     BooleanQuery clone = (BooleanQuery)super.clone();
/* 396 */     clone.clauses = (Vector)this.clauses.clone();
/* 397 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 402 */     StringBuffer buffer = new StringBuffer();
/* 403 */     boolean needParens = (getBoost() != 1.0D || getMinimumNumberShouldMatch() > 0);
/* 404 */     if (needParens) {
/* 405 */       buffer.append(""("");
/*     */     }
/*     */     
/* 408 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 409 */       BooleanClause c = this.clauses.elementAt(i);
/* 410 */       if (c.isProhibited()) {
/* 411 */         buffer.append(""-"");
/* 412 */       } else if (c.isRequired()) {
/* 413 */         buffer.append(""+"");
/*     */       } 
/* 415 */       Query subQuery = c.getQuery();
/* 416 */       if (subQuery instanceof BooleanQuery) {
/* 417 */         buffer.append(""("");
/* 418 */         buffer.append(c.getQuery().toString(field));
/* 419 */         buffer.append("")"");
/*     */       } else {
/* 421 */         buffer.append(c.getQuery().toString(field));
/*     */       } 
/* 423 */       if (i != this.clauses.size() - 1) {
/* 424 */         buffer.append("" "");
/*     */       }
/*     */     } 
/* 427 */     if (needParens) {
/* 428 */       buffer.append("")"");
/*     */     }
/*     */     
/* 431 */     if (getMinimumNumberShouldMatch() > 0) {
/* 432 */       buffer.append('~');
/* 433 */       buffer.append(getMinimumNumberShouldMatch());
/*     */     } 
/*     */     
/* 436 */     if (getBoost() != 1.0F)
/*     */     {
/* 438 */       buffer.append(ToStringUtils.boost(getBoost()));
/*     */     }
/*     */     
/* 441 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 446 */     if (!(o instanceof BooleanQuery))
/* 447 */       return false; 
/* 448 */     BooleanQuery other = (BooleanQuery)o;
/* 449 */     return (getBoost() == other.getBoost() && this.clauses.equals(other.clauses) && getMinimumNumberShouldMatch() == other.getMinimumNumberShouldMatch());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 456 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.clauses.hashCode() + getMinimumNumberShouldMatch(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\BooleanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class BooleanScorer
/*     */   extends Scorer
/*     */ {
/*  22 */   private SubScorer scorers = null;
/*  23 */   private BucketTable bucketTable = new BucketTable(this);
/*     */   
/*  25 */   private int maxCoord = 1;
/*  26 */   private float[] coordFactors = null;
/*     */   
/*  28 */   private int requiredMask = 0;
/*  29 */   private int prohibitedMask = 0;
/*  30 */   private int nextMask = 1;
/*     */   private int end;
/*     */   
/*  33 */   BooleanScorer(Similarity similarity) { super(similarity); }
/*     */   
/*     */   private Bucket current;
/*     */   
/*     */   static final class SubScorer
/*     */   {
/*     */     public Scorer scorer;
/*     */     public boolean done;
/*     */     public boolean required = false;
/*     */     public boolean prohibited = false;
/*     */     public HitCollector collector;
/*     */     public SubScorer next;
/*     */     
/*     */     public SubScorer(Scorer scorer, boolean required, boolean prohibited, HitCollector collector, SubScorer next) throws IOException {
/*  47 */       this.scorer = scorer;
/*  48 */       this.done = !scorer.next();
/*  49 */       this.required = required;
/*  50 */       this.prohibited = prohibited;
/*  51 */       this.collector = collector;
/*  52 */       this.next = next;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   final void add(Scorer scorer, boolean required, boolean prohibited) throws IOException {
/*  58 */     int mask = 0;
/*  59 */     if (required || prohibited) {
/*  60 */       if (this.nextMask == 0) {
/*  61 */         throw new IndexOutOfBoundsException(""More than 32 required/prohibited clauses in query."");
/*     */       }
/*  63 */       mask = this.nextMask;
/*  64 */       this.nextMask <<= 1;
/*     */     } else {
/*  66 */       mask = 0;
/*     */     } 
/*  68 */     if (!prohibited) {
/*  69 */       this.maxCoord++;
/*     */     }
/*  71 */     if (prohibited) {
/*  72 */       this.prohibitedMask |= mask;
/*  73 */     } else if (required) {
/*  74 */       this.requiredMask |= mask;
/*     */     } 
/*  76 */     this.scorers = new SubScorer(scorer, required, prohibited, this.bucketTable.newCollector(mask), this.scorers);
/*     */   }
/*     */ 
/*     */   
/*     */   private final void computeCoordFactors() {
/*  81 */     this.coordFactors = new float[this.maxCoord];
/*  82 */     for (int i = 0; i < this.maxCoord; i++) {
/*  83 */       this.coordFactors[i] = getSimilarity().coord(i, this.maxCoord - 1);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  90 */     next();
/*  91 */     score(hc, 2147483647);
/*     */   }
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/*     */     boolean more;
/*  95 */     if (this.coordFactors == null) {
/*  96 */       computeCoordFactors();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     do {
/* 102 */       this.bucketTable.first = null;
/*     */       
/* 104 */       while (this.current != null) {
/*     */ 
/*     */         
/* 107 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask) {
/*     */ 
/*     */           
/* 110 */           if (this.current.doc >= max) {
/* 111 */             Bucket tmp = this.current;
/* 112 */             this.current = this.current.next;
/* 113 */             tmp.next = this.bucketTable.first;
/* 114 */             this.bucketTable.first = tmp;
/*     */             
/*     */             continue;
/*     */           } 
/* 118 */           hc.collect(this.current.doc, this.current.score * this.coordFactors[this.current.coord]);
/*     */         } 
/*     */         
/* 121 */         this.current = this.current.next;
/*     */       } 
/*     */       
/* 124 */       if (this.bucketTable.first != null) {
/* 125 */         this.current = this.bucketTable.first;
/* 126 */         this.bucketTable.first = this.current.next;
/* 127 */         return true;
/*     */       } 
/*     */ 
/*     */       
/* 131 */       more = false;
/* 132 */       this.end += 2048;
/* 133 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 134 */         if (!sub.done) {
/* 135 */           sub.done = !sub.scorer.score(sub.collector, this.end);
/* 136 */           if (!sub.done)
/* 137 */             more = true; 
/*     */         } 
/*     */       } 
/* 140 */       this.current = this.bucketTable.first;
/*     */     }
/* 142 */     while (this.current != null || more);
/*     */     
/* 144 */     return false;
/*     */   }
/*     */   
/* 147 */   public int doc() { return this.current.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     boolean more;
/*     */     do {
/* 152 */       while (this.bucketTable.first != null) {
/* 153 */         this.current = this.bucketTable.first;
/* 154 */         this.bucketTable.first = this.current.next;
/*     */ 
/*     */         
/* 157 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask)
/*     */         {
/* 159 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 164 */       more = false;
/* 165 */       this.end += 2048;
/* 166 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 167 */         Scorer scorer = sub.scorer;
/* 168 */         while (!sub.done && scorer.doc() < this.end) {
/* 169 */           sub.collector.collect(scorer.doc(), scorer.score());
/* 170 */           sub.done = !scorer.next();
/*     */         } 
/* 172 */         if (!sub.done) {
/* 173 */           more = true;
/*     */         }
/*     */       } 
/* 176 */     } while (this.bucketTable.first != null || more);
/*     */     
/* 178 */     return false;
/*     */   }
/*     */   
/*     */   public float score() {
/* 182 */     if (this.coordFactors == null)
/* 183 */       computeCoordFactors(); 
/* 184 */     return this.current.score * this.coordFactors[this.current.coord];
/*     */   }
/*     */   
/*     */   static final class Bucket {
/* 188 */     int doc = -1;
/*     */     
/*     */     float score;
/*     */     int bits;
/*     */     int coord;
/*     */     Bucket next;
/*     */   }
/*     */   
/*     */   static final class BucketTable
/*     */   {
/*     */     public static final int SIZE = 2048;
/*     */     public static final int MASK = 2047;
/* 200 */     final BooleanScorer.Bucket[] buckets = new BooleanScorer.Bucket[2048];
/* 201 */     BooleanScorer.Bucket first = null;
/*     */     
/*     */     private BooleanScorer scorer;
/*     */ 
/*     */     
/* 206 */     public BucketTable(BooleanScorer scorer) { this.scorer = scorer; }
/*     */ 
/*     */     
/* 209 */     public final int size() { return 2048; }
/*     */ 
/*     */     
/* 212 */     public HitCollector newCollector(int mask) { return new BooleanScorer.Collector(mask, this); }
/*     */   }
/*     */   
/*     */   static final class Collector extends HitCollector {
/*     */     private BooleanScorer.BucketTable bucketTable;
/*     */     private int mask;
/*     */     
/*     */     public Collector(int mask, BooleanScorer.BucketTable bucketTable) {
/* 220 */       this.mask = mask;
/* 221 */       this.bucketTable = bucketTable;
/*     */     }
/*     */     public final void collect(int doc, float score) {
/* 224 */       BooleanScorer.BucketTable table = this.bucketTable;
/* 225 */       int i = doc & 0x7FF;
/* 226 */       BooleanScorer.Bucket bucket = table.buckets[i];
/* 227 */       if (bucket == null) {
/* 228 */         table.buckets[i] = bucket = new BooleanScorer.Bucket();
/*     */       }
/* 230 */       if (bucket.doc != doc) {
/* 231 */         bucket.doc = doc;
/* 232 */         bucket.score = score;
/* 233 */         bucket.bits = this.mask;
/* 234 */         bucket.coord = 1;
/*     */         
/* 236 */         bucket.next = table.first;
/* 237 */         table.first = bucket;
/*     */       } else {
/* 239 */         bucket.score += score;
/* 240 */         bucket.bits |= this.mask;
/* 241 */         bucket.coord++;
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 247 */   public boolean skipTo(int target) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/* 251 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 255 */     StringBuffer buffer = new StringBuffer();
/* 256 */     buffer.append(""boolean("");
/* 257 */     for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 258 */       buffer.append(sub.scorer.toString());
/* 259 */       buffer.append("" "");
/*     */     } 
/* 261 */     buffer.append("")"");
/* 262 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\BooleanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer2,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class BooleanScorer2
/*     */   extends Scorer
/*     */ {
/*  29 */   private ArrayList requiredScorers = new ArrayList();
/*  30 */   private ArrayList optionalScorers = new ArrayList();
/*  31 */   private ArrayList prohibitedScorers = new ArrayList();
/*     */   private final Coordinator coordinator;
/*     */   
/*     */   private class Coordinator {
/*  35 */     int maxCoord = 0;
/*     */     
/*  37 */     private float[] coordFactors = null; int nrMatchers;
/*     */     
/*     */     void init() {
/*  40 */       this.coordFactors = new float[this.maxCoord + 1];
/*  41 */       Similarity sim = BooleanScorer2.this.getSimilarity();
/*  42 */       for (int i = 0; i <= this.maxCoord; i++) {
/*  43 */         this.coordFactors[i] = sim.coord(i, this.maxCoord);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/*     */     private final BooleanScorer2 this$0;
/*     */     
/*  50 */     void initDoc() { this.nrMatchers = 0; }
/*     */ 
/*     */ 
/*     */     
/*  54 */     float coordFactor() { return this.coordFactors[this.nrMatchers]; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private Coordinator() {}
/*     */   }
/*     */ 
/*     */   
/*  63 */   private Scorer countingSumScorer = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanScorer2(Similarity similarity, int minNrShouldMatch) {
/*  77 */     super(similarity);
/*  78 */     if (minNrShouldMatch < 0) {
/*  79 */       throw new IllegalArgumentException(""Minimum number of optional scorers should not be negative"");
/*     */     }
/*  81 */     this.coordinator = new Coordinator();
/*  82 */     this.minNrShouldMatch = minNrShouldMatch;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  91 */   public BooleanScorer2(Similarity similarity) { this(similarity, 0); }
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer, boolean required, boolean prohibited) {
/*  95 */     if (!prohibited) {
/*  96 */       this.coordinator.maxCoord++;
/*     */     }
/*     */     
/*  99 */     if (required) {
/* 100 */       if (prohibited) {
/* 101 */         throw new IllegalArgumentException(""scorer cannot be required and prohibited"");
/*     */       }
/* 103 */       this.requiredScorers.add(scorer);
/* 104 */     } else if (prohibited) {
/* 105 */       this.prohibitedScorers.add(scorer);
/*     */     } else {
/* 107 */       this.optionalScorers.add(scorer);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initCountingSumScorer() {
/* 119 */     this.coordinator.init();
/* 120 */     this.countingSumScorer = makeCountingSumScorer();
/*     */   }
/*     */   
/*     */   private class SingleMatchScorer
/*     */     extends Scorer {
/*     */     private Scorer scorer;
/* 126 */     private int lastScoredDoc = -1; private final BooleanScorer2 this$0;
/*     */     
/*     */     SingleMatchScorer(Scorer scorer) {
/* 129 */       super(scorer.getSimilarity());
/* 130 */       this.scorer = scorer;
/*     */     }
/*     */     public float score() throws IOException {
/* 133 */       if (doc() > this.lastScoredDoc) {
/* 134 */         this.lastScoredDoc = doc();
/* 135 */         BooleanScorer2.this.coordinator.nrMatchers++;
/*     */       } 
/* 137 */       return this.scorer.score();
/*     */     }
/*     */     
/* 140 */     public int doc() { return this.scorer.doc(); }
/*     */ 
/*     */     
/* 143 */     public boolean next() throws IOException { return this.scorer.next(); }
/*     */ 
/*     */     
/* 146 */     public boolean skipTo(int docNr) throws IOException { return this.scorer.skipTo(docNr); }
/*     */ 
/*     */     
/* 149 */     public Explanation explain(int docNr) throws IOException { return this.scorer.explain(docNr); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer countingDisjunctionSumScorer(List scorers, int minMrShouldMatch) {
/* 157 */     return new DisjunctionSumScorer(scorers, minMrShouldMatch) {
/* 158 */         private int lastScoredDoc = -1;
/*     */         public float score() throws IOException {
/* 160 */           if (doc() > this.lastScoredDoc) {
/* 161 */             this.lastScoredDoc = doc();
/* 162 */             BooleanScorer2.this.coordinator.nrMatchers += this.nrMatchers;
/*     */           } 
/* 164 */           return super.score();
/*     */         }
/*     */         private final BooleanScorer2 this$0;
/*     */       };
/*     */   }
/* 169 */   private static Similarity defaultSimilarity = new DefaultSimilarity();
/*     */ 
/*     */   
/*     */   private Scorer countingConjunctionSumScorer(List requiredScorers) {
/* 173 */     final int requiredNrMatchers = requiredScorers.size();
/* 174 */     ConjunctionScorer cs = new ConjunctionScorer(defaultSimilarity) {
/* 175 */         private int lastScoredDoc = -1; private final int val$requiredNrMatchers; private final BooleanScorer2 this$0;
/*     */         
/*     */         public float score() throws IOException {
/* 178 */           if (doc() > this.lastScoredDoc) {
/* 179 */             this.lastScoredDoc = doc();
/* 180 */             BooleanScorer2.this.coordinator.nrMatchers += requiredNrMatchers;
/*     */           } 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 186 */           return super.score();
/*     */         }
/*     */       };
/* 189 */     Iterator rsi = requiredScorers.iterator();
/* 190 */     while (rsi.hasNext()) {
/* 191 */       cs.add(rsi.next());
/*     */     }
/* 193 */     return cs;
/*     */   }
/*     */   
/*     */   private Scorer dualConjunctionSumScorer(Scorer req1, Scorer req2) {
/* 197 */     int requiredNrMatchers = this.requiredScorers.size();
/* 198 */     ConjunctionScorer cs = new ConjunctionScorer(defaultSimilarity);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 203 */     cs.add(req1);
/* 204 */     cs.add(req2);
/* 205 */     return cs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 212 */   private Scorer makeCountingSumScorer() { return (this.requiredScorers.size() == 0) ? makeCountingSumScorerNoReq() : makeCountingSumScorerSomeReq(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerNoReq() {
/* 218 */     if (this.optionalScorers.size() == 0) {
/* 219 */       return new NonMatchingScorer();
/*     */     }
/*     */     
/* 222 */     int nrOptRequired = (this.minNrShouldMatch < 1) ? 1 : this.minNrShouldMatch;
/* 223 */     if (this.optionalScorers.size() < nrOptRequired) {
/* 224 */       return new NonMatchingScorer();
/*     */     }
/* 226 */     Scorer requiredCountingSumScorer = (this.optionalScorers.size() > nrOptRequired) ? countingDisjunctionSumScorer(this.optionalScorers, nrOptRequired) : ((this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingConjunctionSumScorer(this.optionalScorers));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 233 */     return addProhibitedScorers(requiredCountingSumScorer);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerSomeReq() {
/* 239 */     if (this.optionalScorers.size() < this.minNrShouldMatch)
/* 240 */       return new NonMatchingScorer(); 
/* 241 */     if (this.optionalScorers.size() == this.minNrShouldMatch) {
/* 242 */       ArrayList allReq = new ArrayList(this.requiredScorers);
/* 243 */       allReq.addAll(this.optionalScorers);
/* 244 */       return addProhibitedScorers(countingConjunctionSumScorer(allReq));
/*     */     } 
/* 246 */     Scorer requiredCountingSumScorer = (this.requiredScorers.size() == 1) ? new SingleMatchScorer(this.requiredScorers.get(0)) : countingConjunctionSumScorer(this.requiredScorers);
/*     */ 
/*     */ 
/*     */     
/* 250 */     if (this.minNrShouldMatch > 0) {
/* 251 */       return addProhibitedScorers(dualConjunctionSumScorer(requiredCountingSumScorer, countingDisjunctionSumScorer(this.optionalScorers, this.minNrShouldMatch)));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 258 */     return new ReqOptSumScorer(addProhibitedScorers(requiredCountingSumScorer), (this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingDisjunctionSumScorer(this.optionalScorers, 1));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 273 */   private Scorer addProhibitedScorers(Scorer requiredCountingSumScorer) { return (this.prohibitedScorers.size() == 0) ? requiredCountingSumScorer : new ReqExclScorer(requiredCountingSumScorer, (this.prohibitedScorers.size() == 1) ? this.prohibitedScorers.get(0) : new DisjunctionSumScorer(this.prohibitedScorers)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/* 287 */     if (this.countingSumScorer == null) {
/* 288 */       initCountingSumScorer();
/*     */     }
/* 290 */     while (this.countingSumScorer.next()) {
/* 291 */       hc.collect(this.countingSumScorer.doc(), score());
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 305 */     int docNr = this.countingSumScorer.doc();
/* 306 */     while (docNr < max) {
/* 307 */       hc.collect(docNr, score());
/* 308 */       if (!this.countingSumScorer.next()) {
/* 309 */         return false;
/*     */       }
/* 311 */       docNr = this.countingSumScorer.doc();
/*     */     } 
/* 313 */     return true;
/*     */   }
/*     */   
/* 316 */   public int doc() { return this.countingSumScorer.doc(); }
/*     */   
/*     */   public boolean next() throws IOException {
/* 319 */     if (this.countingSumScorer == null) {
/* 320 */       initCountingSumScorer();
/*     */     }
/* 322 */     return this.countingSumScorer.next();
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/* 326 */     this.coordinator.initDoc();
/* 327 */     float sum = this.countingSumScorer.score();
/* 328 */     return sum * this.coordinator.coordFactor();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 340 */     if (this.countingSumScorer == null) {
/* 341 */       initCountingSumScorer();
/*     */     }
/* 343 */     return this.countingSumScorer.skipTo(target);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 352 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\BooleanScorer2.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.CachingWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import java.util.Map;
/*    */ import java.util.WeakHashMap;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   private Filter filter;
/*    */   private transient Map cache;
/*    */   
/* 44 */   public CachingWrapperFilter(Filter filter) { this.filter = filter; }
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 48 */     if (this.cache == null) {
/* 49 */       this.cache = new WeakHashMap();
/*    */     }
/*    */     
/* 52 */     synchronized (this.cache) {
/* 53 */       BitSet cached = (BitSet)this.cache.get(reader);
/* 54 */       if (cached != null) {
/* 55 */         return cached;
/*    */       }
/*    */     } 
/*    */     
/* 59 */     BitSet bits = this.filter.bits(reader);
/*    */     
/* 61 */     synchronized (this.cache) {
/* 62 */       this.cache.put(reader, bits);
/*    */     } 
/*    */     
/* 65 */     return bits;
/*    */   }
/*    */ 
/*    */   
/* 69 */   public String toString() { return ""CachingWrapperFilter("" + this.filter + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 73 */     if (!(o instanceof CachingWrapperFilter)) return false; 
/* 74 */     return this.filter.equals(((CachingWrapperFilter)o).filter);
/*    */   }
/*    */ 
/*    */   
/* 78 */   public int hashCode() { return this.filter.hashCode() ^ 0x1117BF25; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\CachingWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConjunctionScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Comparator;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class ConjunctionScorer
/*     */   extends Scorer
/*     */ {
/*  27 */   private LinkedList scorers = new LinkedList();
/*     */   
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   private float coord;
/*     */   
/*  33 */   public ConjunctionScorer(Similarity similarity) { super(similarity); }
/*     */ 
/*     */ 
/*     */   
/*  37 */   final void add(Scorer scorer) { this.scorers.addLast(scorer); }
/*     */ 
/*     */   
/*  40 */   private Scorer first() { return this.scorers.getFirst(); }
/*  41 */   private Scorer last() { return this.scorers.getLast(); }
/*     */   
/*  43 */   public int doc() { return first().doc(); }
/*     */   
/*     */   public boolean next() throws IOException {
/*  46 */     if (this.firstTime) {
/*  47 */       init(true);
/*  48 */     } else if (this.more) {
/*  49 */       this.more = last().next();
/*     */     } 
/*  51 */     return doNext();
/*     */   }
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  55 */     while (this.more && first().doc() < last().doc()) {
/*  56 */       this.more = first().skipTo(last().doc());
/*  57 */       this.scorers.addLast(this.scorers.removeFirst());
/*     */     } 
/*  59 */     return this.more;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  63 */     if (this.firstTime) {
/*  64 */       init(false);
/*     */     }
/*     */     
/*  67 */     Iterator i = this.scorers.iterator();
/*  68 */     while (this.more && i.hasNext()) {
/*  69 */       this.more = ((Scorer)i.next()).skipTo(target);
/*     */     }
/*     */     
/*  72 */     if (this.more) {
/*  73 */       sortScorers();
/*     */     }
/*  75 */     return doNext();
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/*  79 */     float score = 0.0F;
/*  80 */     Iterator i = this.scorers.iterator();
/*  81 */     while (i.hasNext())
/*  82 */       score += ((Scorer)i.next()).score(); 
/*  83 */     score *= this.coord;
/*  84 */     return score;
/*     */   }
/*     */ 
/*     */   
/*     */   private void init(boolean initScorers) throws IOException {
/*  89 */     this.coord = getSimilarity().coord(this.scorers.size(), this.scorers.size());
/*     */     
/*  91 */     this.more = (this.scorers.size() > 0);
/*     */     
/*  93 */     if (initScorers) {
/*     */       
/*  95 */       Iterator i = this.scorers.iterator();
/*  96 */       while (this.more && i.hasNext()) {
/*  97 */         this.more = ((Scorer)i.next()).next();
/*     */       }
/*  99 */       if (this.more) {
/* 100 */         sortScorers();
/*     */       }
/*     */     } 
/* 103 */     this.firstTime = false;
/*     */   }
/*     */ 
/*     */   
/*     */   private void sortScorers() {
/* 108 */     Scorer[] array = (Scorer[])this.scorers.toArray((Object[])new Scorer[this.scorers.size()]);
/* 109 */     this.scorers.clear();
/*     */ 
/*     */     
/* 112 */     Arrays.sort(array, new Comparator() { private final ConjunctionScorer this$0;
/*     */           
/* 114 */           public int compare(Object o1, Object o2) { return ((Scorer)o1).doc() - ((Scorer)o2).doc(); }
/*     */            }
/*     */       );
/*     */     
/* 118 */     for (int i = 0; i < array.length; i++) {
/* 119 */       this.scorers.addLast(array[i]);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 124 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ConjunctionScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreQuery
/*     */   extends Query
/*     */ {
/*     */   protected final Filter filter;
/*     */   
/*  36 */   public ConstantScoreQuery(Filter filter) { this.filter = filter; }
/*     */ 
/*     */ 
/*     */   
/*  40 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   protected class ConstantWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final ConstantScoreQuery this$0;
/*     */     
/*  54 */     public ConstantWeight(Searcher searcher) { this.similarity = ConstantScoreQuery.this.getSimilarity(searcher); }
/*     */ 
/*     */ 
/*     */     
/*  58 */     public Query getQuery() { return ConstantScoreQuery.this; }
/*     */ 
/*     */ 
/*     */     
/*  62 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/*  66 */       this.queryWeight = ConstantScoreQuery.this.getBoost();
/*  67 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float norm) {
/*  71 */       this.queryNorm = norm;
/*  72 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/*  76 */     public Scorer scorer(IndexReader reader) throws IOException { return new ConstantScoreQuery.ConstantScorer(this.similarity, reader, this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  81 */       ConstantScoreQuery.ConstantScorer cs = (ConstantScoreQuery.ConstantScorer)scorer(reader);
/*  82 */       boolean exists = cs.bits.get(doc);
/*     */       
/*  84 */       Explanation result = new Explanation();
/*     */       
/*  86 */       if (exists) {
/*  87 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + ""), product of:"");
/*     */         
/*  89 */         result.setValue(this.queryWeight);
/*  90 */         result.addDetail(new Explanation(ConstantScoreQuery.this.getBoost(), ""boost""));
/*  91 */         result.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       } else {
/*  93 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + "") doesn't match id "" + doc);
/*     */         
/*  95 */         result.setValue(0.0F);
/*     */       } 
/*  97 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected class ConstantScorer extends Scorer {
/*     */     final BitSet bits;
/*     */     final float theScore;
/* 104 */     int doc = -1;
/*     */     
/*     */     public ConstantScorer(Similarity similarity, IndexReader reader, Weight w) throws IOException {
/* 107 */       super(similarity);
/* 108 */       this.theScore = w.getValue();
/* 109 */       this.bits = ConstantScoreQuery.this.filter.bits(reader);
/*     */     }
/*     */     private final ConstantScoreQuery this$0;
/*     */     public boolean next() throws IOException {
/* 113 */       this.doc = this.bits.nextSetBit(this.doc + 1);
/* 114 */       return (this.doc >= 0);
/*     */     }
/*     */ 
/*     */     
/* 118 */     public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */     
/* 122 */     public float score() throws IOException { return this.theScore; }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 126 */       this.doc = this.bits.nextSetBit(target);
/* 127 */       return (this.doc >= 0);
/*     */     }
/*     */ 
/*     */     
/* 131 */     public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 137 */   protected Weight createWeight(Searcher searcher) { return new ConstantWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 144 */   public String toString(String field) { return ""ConstantScore("" + this.filter.toString() + ((getBoost() == 1.0D) ? "")"" : (""^"" + getBoost())); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 150 */     if (this == o) return true; 
/* 151 */     if (!(o instanceof ConstantScoreQuery)) return false; 
/* 152 */     ConstantScoreQuery other = (ConstantScoreQuery)o;
/* 153 */     return (getBoost() == other.getBoost() && this.filter.equals(other.filter));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   public int hashCode() { return this.filter.hashCode() + Float.floatToIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ConstantScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreRangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreRangeQuery
/*     */   extends Query
/*     */ {
/*     */   private final String fieldName;
/*     */   private final String lowerVal;
/*     */   private final String upperVal;
/*     */   private final boolean includeLower;
/*     */   private final boolean includeUpper;
/*     */   
/*     */   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
/*  50 */     if (lowerVal == null) {
/*  51 */       includeLower = true;
/*  52 */     } else if (includeLower && lowerVal.equals("""")) {
/*  53 */       lowerVal = null;
/*     */     } 
/*  55 */     if (upperVal == null) {
/*  56 */       includeUpper = true;
/*     */     }
/*     */ 
/*     */     
/*  60 */     this.fieldName = fieldName.intern();
/*  61 */     this.lowerVal = lowerVal;
/*  62 */     this.upperVal = upperVal;
/*  63 */     this.includeLower = includeLower;
/*  64 */     this.includeUpper = includeUpper;
/*     */   }
/*     */ 
/*     */   
/*  68 */   public String getField() { return this.fieldName; }
/*     */   
/*  70 */   public String getLowerVal() { return this.lowerVal; }
/*     */   
/*  72 */   public String getUpperVal() { return this.upperVal; }
/*     */   
/*  74 */   public boolean includesLower() { return this.includeLower; }
/*     */   
/*  76 */   public boolean includesUpper() { return this.includeUpper; }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  80 */     RangeFilter rangeFilt = new RangeFilter(this.fieldName, (this.lowerVal != null) ? this.lowerVal : """", this.upperVal, (this.lowerVal == """") ? false : this.includeLower, (this.upperVal == null) ? false : this.includeUpper);
/*     */ 
/*     */     
/*  83 */     Query q = new ConstantScoreQuery(rangeFilt);
/*  84 */     q.setBoost(getBoost());
/*  85 */     return q;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/*  91 */     StringBuffer buffer = new StringBuffer();
/*  92 */     if (!getField().equals(field)) {
/*     */       
/*  94 */       buffer.append(getField());
/*  95 */       buffer.append("":"");
/*     */     } 
/*  97 */     buffer.append(this.includeLower ? 91 : 123);
/*  98 */     buffer.append((this.lowerVal != null) ? this.lowerVal : ""*"");
/*  99 */     buffer.append("" TO "");
/* 100 */     buffer.append((this.upperVal != null) ? this.upperVal : ""*"");
/* 101 */     buffer.append(this.includeUpper ? 93 : 125);
/* 102 */     if (getBoost() != 1.0F) {
/*     */       
/* 104 */       buffer.append(""^"");
/* 105 */       buffer.append(Float.toString(getBoost()));
/*     */     } 
/* 107 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 112 */     if (this == o) return true; 
/* 113 */     if (!(o instanceof ConstantScoreRangeQuery)) return false; 
/* 114 */     ConstantScoreRangeQuery other = (ConstantScoreRangeQuery)o;
/*     */     
/* 116 */     if (this.fieldName != other.fieldName || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper)
/*     */     {
/*     */       
/* 119 */       return false; } 
/* 120 */     if ((this.lowerVal != null) ? !this.lowerVal.equals(other.lowerVal) : (other.lowerVal != null)) return false; 
/* 121 */     if ((this.upperVal != null) ? !this.upperVal.equals(other.upperVal) : (other.upperVal != null)) return false; 
/* 122 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 127 */     int h = Float.floatToIntBits(getBoost()) ^ this.fieldName.hashCode();
/*     */     
/* 129 */     h ^= (this.lowerVal != null) ? this.lowerVal.hashCode() : -1772448166;
/*     */ 
/*     */     
/* 132 */     h ^= h << 17 | h >>> 16;
/* 133 */     h ^= (this.upperVal != null) ? this.upperVal.hashCode() : 1516853865;
/* 134 */     h ^= (this.includeLower ? 1716885930 : 0) ^ (this.includeUpper ? -1716890266 : 0);
/*     */     
/* 136 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ConstantScoreRangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DefaultSimilarity,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultSimilarity
/*    */   extends Similarity
/*    */ {
/* 23 */   public float lengthNorm(String fieldName, int numTerms) { return (float)(1.0D / Math.sqrt(numTerms)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 28 */   public float queryNorm(float sumOfSquaredWeights) { return (float)(1.0D / Math.sqrt(sumOfSquaredWeights)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 33 */   public float tf(float freq) { return (float)Math.sqrt(freq); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   public float sloppyFreq(int distance) { return 1.0F / (distance + 1); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 43 */   public float idf(int docFreq, int numDocs) { return (float)(Math.log(numDocs / (docFreq + 1)) + 1.0D); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public float coord(int overlap, int maxOverlap) { return overlap / maxOverlap; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\DefaultSimilarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DisjunctionMaxQuery
/*     */   extends Query
/*     */ {
/*  45 */   private ArrayList disjuncts = new ArrayList();
/*     */ 
/*     */   
/*  48 */   private float tieBreakerMultiplier = 0.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   public DisjunctionMaxQuery(float tieBreakerMultiplier) { this.tieBreakerMultiplier = tieBreakerMultiplier; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionMaxQuery(Collection disjuncts, float tieBreakerMultiplier) {
/*  66 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*  67 */     add(disjuncts);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   public void add(Query query) { this.disjuncts.add(query); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  81 */   public void add(Collection disjuncts) { this.disjuncts.addAll(disjuncts); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public Iterator iterator() { return this.disjuncts.iterator(); }
/*     */ 
/*     */   
/*     */   private class DisjunctionMaxWeight
/*     */     implements Weight
/*     */   {
/*     */     private Searcher searcher;
/*  93 */     private ArrayList weights = new ArrayList();
/*     */     private final DisjunctionMaxQuery this$0;
/*     */     
/*     */     public DisjunctionMaxWeight(Searcher searcher) throws IOException {
/*  97 */       this.searcher = searcher;
/*  98 */       for (int i = 0; i < DisjunctionMaxQuery.this.disjuncts.size(); i++) {
/*  99 */         this.weights.add(((Query)DisjunctionMaxQuery.this.disjuncts.get(i)).createWeight(searcher));
/*     */       }
/*     */     }
/*     */     
/* 103 */     public Query getQuery() { return DisjunctionMaxQuery.this; }
/*     */ 
/*     */     
/* 106 */     public float getValue() { return DisjunctionMaxQuery.this.getBoost(); }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 110 */       float max = 0.0F, sum = 0.0F;
/* 111 */       for (int i = 0; i < this.weights.size(); i++) {
/* 112 */         float sub = ((Weight)this.weights.get(i)).sumOfSquaredWeights();
/* 113 */         sum += sub;
/* 114 */         max = Math.max(max, sub);
/*     */       } 
/* 116 */       return ((sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier * DisjunctionMaxQuery.this.tieBreakerMultiplier + max) * DisjunctionMaxQuery.this.getBoost() * DisjunctionMaxQuery.this.getBoost();
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 121 */       norm *= DisjunctionMaxQuery.this.getBoost();
/* 122 */       for (int i = 0; i < this.weights.size(); i++) {
/* 123 */         ((Weight)this.weights.get(i)).normalize(norm);
/*     */       }
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 128 */       DisjunctionMaxScorer result = new DisjunctionMaxScorer(DisjunctionMaxQuery.this.tieBreakerMultiplier, DisjunctionMaxQuery.this.getSimilarity(this.searcher));
/* 129 */       for (int i = 0; i < this.weights.size(); i++) {
/* 130 */         Weight w = this.weights.get(i);
/* 131 */         Scorer subScorer = w.scorer(reader);
/* 132 */         if (subScorer == null) return null; 
/* 133 */         result.add(subScorer);
/*     */       } 
/* 135 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 140 */       if (DisjunctionMaxQuery.this.disjuncts.size() == 1) return ((Weight)this.weights.get(0)).explain(reader, doc); 
/* 141 */       Explanation result = new Explanation();
/* 142 */       float max = 0.0F, sum = 0.0F;
/* 143 */       result.setDescription((DisjunctionMaxQuery.this.tieBreakerMultiplier == 0.0F) ? ""max of:"" : (""max plus "" + DisjunctionMaxQuery.this.tieBreakerMultiplier + "" times others of:""));
/* 144 */       for (int i = 0; i < this.weights.size(); i++) {
/* 145 */         Explanation e = ((Weight)this.weights.get(i)).explain(reader, doc);
/* 146 */         if (e.getValue() > 0.0F) {
/* 147 */           result.addDetail(e);
/* 148 */           sum += e.getValue();
/* 149 */           max = Math.max(max, e.getValue());
/*     */         } 
/*     */       } 
/* 152 */       result.setValue(max + (sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier);
/* 153 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   protected Weight createWeight(Searcher searcher) throws IOException { return new DisjunctionMaxWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 167 */     if (this.disjuncts.size() == 1) {
/* 168 */       Query singleton = this.disjuncts.get(0);
/* 169 */       Query result = singleton.rewrite(reader);
/* 170 */       if (getBoost() != 1.0F) {
/* 171 */         if (result == singleton) result = (Query)result.clone(); 
/* 172 */         result.setBoost(getBoost() * result.getBoost());
/*     */       } 
/* 174 */       return result;
/*     */     } 
/* 176 */     DisjunctionMaxQuery clone = null;
/* 177 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 178 */       Query clause = this.disjuncts.get(i);
/* 179 */       Query rewrite = clause.rewrite(reader);
/* 180 */       if (rewrite != clause) {
/* 181 */         if (clone == null) clone = (DisjunctionMaxQuery)clone(); 
/* 182 */         clone.disjuncts.set(i, rewrite);
/*     */       } 
/*     */     } 
/* 185 */     if (clone != null) return clone; 
/* 186 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 192 */     DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
/* 193 */     clone.disjuncts = (ArrayList)this.disjuncts.clone();
/* 194 */     return clone;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 200 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 201 */       ((Query)this.disjuncts.get(i)).extractTerms(terms);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 211 */     StringBuffer buffer = new StringBuffer();
/* 212 */     buffer.append(""("");
/* 213 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 214 */       Query subquery = this.disjuncts.get(i);
/* 215 */       if (subquery instanceof BooleanQuery) {
/* 216 */         buffer.append(""("");
/* 217 */         buffer.append(subquery.toString(field));
/* 218 */         buffer.append("")"");
/*     */       } else {
/* 220 */         buffer.append(subquery.toString(field));
/* 221 */       }  if (i != this.disjuncts.size() - 1) buffer.append("" | ""); 
/*     */     } 
/* 223 */     buffer.append("")"");
/* 224 */     if (this.tieBreakerMultiplier != 0.0F) {
/* 225 */       buffer.append(""~"");
/* 226 */       buffer.append(this.tieBreakerMultiplier);
/*     */     } 
/* 228 */     if (getBoost() != 1.0D) {
/* 229 */       buffer.append(""^"");
/* 230 */       buffer.append(getBoost());
/*     */     } 
/* 232 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 240 */     if (!(o instanceof DisjunctionMaxQuery)) return false; 
/* 241 */     DisjunctionMaxQuery other = (DisjunctionMaxQuery)o;
/* 242 */     return (getBoost() == other.getBoost() && this.tieBreakerMultiplier == other.tieBreakerMultiplier && this.disjuncts.equals(other.disjuncts));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 251 */   public int hashCode() { return Float.floatToIntBits(getBoost()) + Float.floatToIntBits(this.tieBreakerMultiplier) + this.disjuncts.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\DisjunctionMaxQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionMaxScorer
/*     */   extends Scorer
/*     */ {
/*  32 */   private ArrayList subScorers = new ArrayList();
/*     */ 
/*     */   
/*     */   private float tieBreakerMultiplier;
/*     */ 
/*     */   
/*     */   private boolean more = false;
/*     */   
/*     */   private boolean firstTime = true;
/*     */ 
/*     */   
/*     */   public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
/*  44 */     super(similarity);
/*  45 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer) throws IOException {
/*  52 */     if (scorer.next()) {
/*  53 */       this.subScorers.add(scorer);
/*  54 */       this.more = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/*  62 */     if (!this.more) return false; 
/*  63 */     if (this.firstTime) {
/*  64 */       heapify();
/*  65 */       this.firstTime = false;
/*  66 */       return true;
/*     */     } 
/*     */     
/*  69 */     int lastdoc = ((Scorer)this.subScorers.get(0)).doc();
/*     */     do {
/*  71 */       if (((Scorer)this.subScorers.get(0)).next()) {
/*  72 */         heapAdjust(0);
/*     */       } else {
/*  74 */         heapRemoveRoot();
/*  75 */         if (this.subScorers.isEmpty()) return this.more = false; 
/*     */       } 
/*  77 */     } while (((Scorer)this.subScorers.get(0)).doc() == lastdoc);
/*  78 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public int doc() { return ((Scorer)this.subScorers.get(0)).doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/*  92 */     int doc = ((Scorer)this.subScorers.get(0)).doc();
/*  93 */     float[] sum = { ((Scorer)this.subScorers.get(0)).score() }, max = { sum[0] };
/*  94 */     int size = this.subScorers.size();
/*  95 */     scoreAll(1, size, doc, sum, max);
/*  96 */     scoreAll(2, size, doc, sum, max);
/*  97 */     return max[0] + (sum[0] - max[0]) * this.tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */   
/*     */   private void scoreAll(int root, int size, int doc, float[] sum, float[] max) throws IOException {
/* 102 */     if (root < size && ((Scorer)this.subScorers.get(root)).doc() == doc) {
/* 103 */       float sub = ((Scorer)this.subScorers.get(root)).score();
/* 104 */       sum[0] = sum[0] + sub;
/* 105 */       max[0] = Math.max(max[0], sub);
/* 106 */       scoreAll((root << 1) + 1, size, doc, sum, max);
/* 107 */       scoreAll((root << 1) + 2, size, doc, sum, max);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 116 */     while (this.subScorers.size() > 0 && ((Scorer)this.subScorers.get(0)).doc() < target) {
/* 117 */       if (((Scorer)this.subScorers.get(0)).skipTo(target)) {
/* 118 */         heapAdjust(0); continue;
/*     */       } 
/* 120 */       heapRemoveRoot();
/*     */     } 
/* 122 */     if (this.subScorers.size() == 0)
/* 123 */       return this.more = false; 
/* 124 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 132 */   public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapify() {
/* 137 */     int size = this.subScorers.size();
/* 138 */     for (int i = (size >> 1) - 1; i >= 0; i--) {
/* 139 */       heapAdjust(i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapAdjust(int root) {
/* 146 */     Scorer scorer = this.subScorers.get(root);
/* 147 */     int doc = scorer.doc();
/* 148 */     int i = root, size = this.subScorers.size();
/* 149 */     while (i <= (size >> 1) - 1) {
/* 150 */       int lchild = (i << 1) + 1;
/* 151 */       Scorer lscorer = this.subScorers.get(lchild);
/* 152 */       int ldoc = lscorer.doc();
/* 153 */       int rdoc = Integer.MAX_VALUE, rchild = (i << 1) + 2;
/* 154 */       Scorer rscorer = null;
/* 155 */       if (rchild < size) {
/* 156 */         rscorer = this.subScorers.get(rchild);
/* 157 */         rdoc = rscorer.doc();
/*     */       } 
/* 159 */       if (ldoc < doc) {
/* 160 */         if (rdoc < ldoc) {
/* 161 */           this.subScorers.set(i, rscorer);
/* 162 */           this.subScorers.set(rchild, scorer);
/* 163 */           i = rchild; continue;
/*     */         } 
/* 165 */         this.subScorers.set(i, lscorer);
/* 166 */         this.subScorers.set(lchild, scorer);
/* 167 */         i = lchild; continue;
/*     */       } 
/* 169 */       if (rdoc < doc) {
/* 170 */         this.subScorers.set(i, rscorer);
/* 171 */         this.subScorers.set(rchild, scorer);
/* 172 */         i = rchild;
/*     */         continue;
/*     */       } 
/*     */       return;
/*     */     } 
/*     */   }
/*     */   private void heapRemoveRoot() {
/* 179 */     int size = this.subScorers.size();
/* 180 */     if (size == 1) {
/* 181 */       this.subScorers.remove(0);
/*     */     } else {
/* 183 */       this.subScorers.set(0, this.subScorers.get(size - 1));
/* 184 */       this.subScorers.remove(size - 1);
/* 185 */       heapAdjust(0);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\DisjunctionMaxScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionSumScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionSumScorer
/*     */   extends Scorer
/*     */ {
/*     */   private final int nrScorers;
/*     */   protected final List subScorers;
/*     */   private final int minimumNrMatchers;
/*  50 */   private ScorerQueue scorerQueue = null;
/*     */ 
/*     */   
/*  53 */   private int currentDoc = -1;
/*     */ 
/*     */   
/*  56 */   protected int nrMatchers = -1;
/*     */   
/*  58 */   private float currentScore = NaNF;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionSumScorer(List subScorers, int minimumNrMatchers) {
/*  71 */     super(null);
/*     */     
/*  73 */     this.nrScorers = subScorers.size();
/*     */     
/*  75 */     if (minimumNrMatchers <= 0) {
/*  76 */       throw new IllegalArgumentException(""Minimum nr of matchers must be positive"");
/*     */     }
/*  78 */     if (this.nrScorers <= 1) {
/*  79 */       throw new IllegalArgumentException(""There must be at least 2 subScorers"");
/*     */     }
/*     */     
/*  82 */     this.minimumNrMatchers = minimumNrMatchers;
/*  83 */     this.subScorers = subScorers;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  90 */   public DisjunctionSumScorer(List subScorers) { this(subScorers, 1); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initScorerQueue() throws IOException {
/*  97 */     Iterator si = this.subScorers.iterator();
/*  98 */     this.scorerQueue = new ScorerQueue(this.nrScorers);
/*  99 */     while (si.hasNext()) {
/* 100 */       Scorer se = si.next();
/* 101 */       if (se.next())
/* 102 */         this.scorerQueue.insert(se); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private class ScorerQueue
/*     */     extends PriorityQueue {
/*     */     private final DisjunctionSumScorer this$0;
/*     */     
/* 110 */     ScorerQueue(int size) { initialize(size); }
/*     */ 
/*     */ 
/*     */     
/* 114 */     protected boolean lessThan(Object o1, Object o2) { return (((Scorer)o1).doc() < ((Scorer)o2).doc()); }
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 119 */     if (this.scorerQueue == null) {
/* 120 */       initScorerQueue();
/*     */     }
/* 122 */     if (this.scorerQueue.size() < this.minimumNrMatchers) {
/* 123 */       return false;
/*     */     }
/* 125 */     return advanceAfterCurrent();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean advanceAfterCurrent() throws IOException {
/*     */     do {
/* 146 */       Scorer top = (Scorer)this.scorerQueue.top();
/* 147 */       this.currentDoc = top.doc();
/* 148 */       this.currentScore = top.score();
/* 149 */       this.nrMatchers = 1;
/*     */       while (true) {
/* 151 */         if (top.next()) {
/* 152 */           this.scorerQueue.adjustTop();
/*     */         } else {
/* 154 */           this.scorerQueue.pop();
/* 155 */           if (this.scorerQueue.size() < this.minimumNrMatchers - this.nrMatchers)
/*     */           {
/*     */             
/* 158 */             return false;
/*     */           }
/* 160 */           if (this.scorerQueue.size() == 0) {
/*     */             break;
/*     */           }
/*     */         } 
/* 164 */         top = (Scorer)this.scorerQueue.top();
/* 165 */         if (top.doc() != this.currentDoc) {
/*     */           break;
/*     */         }
/* 168 */         this.currentScore += top.score();
/* 169 */         this.nrMatchers++;
/*     */       } 
/*     */ 
/*     */       
/* 173 */       if (this.nrMatchers >= this.minimumNrMatchers)
/* 174 */         return true; 
/* 175 */     } while (this.scorerQueue.size() >= this.minimumNrMatchers);
/* 176 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public float score() throws IOException { return this.currentScore; }
/*     */   
/* 186 */   public int doc() { return this.currentDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public int nrMatchers() { return this.nrMatchers; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 203 */     if (this.scorerQueue == null) {
/* 204 */       initScorerQueue();
/*     */     }
/* 206 */     if (this.scorerQueue.size() < this.minimumNrMatchers) {
/* 207 */       return false;
/*     */     }
/* 209 */     if (target <= this.currentDoc) {
/* 210 */       return true;
/*     */     }
/*     */     while (true)
/* 213 */     { Scorer top = (Scorer)this.scorerQueue.top();
/* 214 */       if (top.doc() >= target)
/* 215 */         return advanceAfterCurrent(); 
/* 216 */       if (top.skipTo(target)) {
/* 217 */         this.scorerQueue.adjustTop(); continue;
/*     */       } 
/* 219 */       this.scorerQueue.pop();
/* 220 */       if (this.scorerQueue.size() < this.minimumNrMatchers)
/* 221 */         break;  }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 231 */     Explanation res = new Explanation();
/* 232 */     res.setDescription(""At least "" + this.minimumNrMatchers + "" of"");
/* 233 */     Iterator ssi = this.subScorers.iterator();
/* 234 */     while (ssi.hasNext()) {
/* 235 */       res.addDetail(((Scorer)ssi.next()).explain(doc));
/*     */     }
/* 237 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\DisjunctionSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ExactPhraseScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class ExactPhraseScorer
/*    */   extends PhraseScorer
/*    */ {
/* 26 */   ExactPhraseScorer(Weight weight, TermPositions[] tps, int[] positions, Similarity similarity, byte[] norms) { super(weight, tps, positions, similarity, norms); }
/*    */ 
/*    */ 
/*    */   
/*    */   protected final float phraseFreq() throws IOException {
/* 31 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 32 */       pp.firstPosition();
/* 33 */       this.pq.put(pp);
/*    */     } 
/* 35 */     pqToList();
/*    */     
/* 37 */     int freq = 0;
/*    */     do {
/* 39 */       while (this.first.position < this.last.position) {
/*    */         do {
/* 41 */           if (!this.first.nextPosition())
/* 42 */             return freq; 
/* 43 */         } while (this.first.position < this.last.position);
/* 44 */         firstToLast();
/*    */       } 
/* 46 */       freq++;
/* 47 */     } while (this.last.nextPosition());
/*    */     
/* 49 */     return freq;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ExactPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Explanation,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Explanation
/*     */   implements Serializable
/*     */ {
/*     */   private float value;
/*     */   private String description;
/*     */   private ArrayList details;
/*     */   
/*     */   public Explanation() {}
/*     */   
/*     */   public Explanation(float value, String description) {
/*  30 */     this.value = value;
/*  31 */     this.description = description;
/*     */   }
/*     */ 
/*     */   
/*  35 */   public float getValue() { return this.value; }
/*     */   
/*  37 */   public void setValue(float value) { this.value = value; }
/*     */ 
/*     */   
/*  40 */   public String getDescription() { return this.description; }
/*     */ 
/*     */   
/*  43 */   public void setDescription(String description) { this.description = description; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation[] getDetails() {
/*  48 */     if (this.details == null)
/*  49 */       return null; 
/*  50 */     return (Explanation[])this.details.toArray((Object[])new Explanation[0]);
/*     */   }
/*     */ 
/*     */   
/*     */   public void addDetail(Explanation detail) {
/*  55 */     if (this.details == null)
/*  56 */       this.details = new ArrayList(); 
/*  57 */     this.details.add(detail);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public String toString() { return toString(0); }
/*     */   
/*     */   private String toString(int depth) {
/*  65 */     StringBuffer buffer = new StringBuffer();
/*  66 */     for (int i = 0; i < depth; i++) {
/*  67 */       buffer.append(""  "");
/*     */     }
/*  69 */     buffer.append(getValue());
/*  70 */     buffer.append("" = "");
/*  71 */     buffer.append(getDescription());
/*  72 */     buffer.append(""\n"");
/*     */     
/*  74 */     Explanation[] details = getDetails();
/*  75 */     if (details != null) {
/*  76 */       for (int i = 0; i < details.length; i++) {
/*  77 */         buffer.append(details[i].toString(depth + 1));
/*     */       }
/*     */     }
/*     */     
/*  81 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toHtml() {
/*  87 */     StringBuffer buffer = new StringBuffer();
/*  88 */     buffer.append(""<ul>\n"");
/*     */     
/*  90 */     buffer.append(""<li>"");
/*  91 */     buffer.append(getValue());
/*  92 */     buffer.append("" = "");
/*  93 */     buffer.append(getDescription());
/*  94 */     buffer.append(""</li>\n"");
/*     */     
/*  96 */     Explanation[] details = getDetails();
/*  97 */     if (details != null) {
/*  98 */       for (int i = 0; i < details.length; i++) {
/*  99 */         buffer.append(details[i].toHtml());
/*     */       }
/*     */     }
/*     */     
/* 103 */     buffer.append(""</ul>\n"");
/*     */     
/* 105 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Explanation.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCache,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface FieldCache
/*    */ {
/*    */   public static final int STRING_INDEX = -1;
/*    */   
/*    */   public static interface FloatParser
/*    */   {
/*    */     float parseFloat(String param1String);
/*    */   }
/*    */   
/*    */   public static interface IntParser
/*    */   {
/*    */     int parseInt(String param1String);
/*    */   }
/*    */   
/*    */   public static class StringIndex
/*    */   {
/*    */     public final String[] lookup;
/*    */     public final int[] order;
/*    */     
/*    */     public StringIndex(int[] values, String[] lookup) {
/* 50 */       this.order = values;
/* 51 */       this.lookup = lookup;
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 73 */   public static final FieldCache DEFAULT = new FieldCacheImpl();
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString, IntParser paramIntParser) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString, FloatParser paramFloatParser) throws IOException;
/*    */   
/*    */   String[] getStrings(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   StringIndex getStringIndex(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Object getAuto(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Comparable[] getCustom(IndexReader paramIndexReader, String paramString, SortComparator paramSortComparator) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FieldCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCacheImpl,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.Locale;
/*     */ import java.util.Map;
/*     */ import java.util.WeakHashMap;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldCacheImpl
/*     */   implements FieldCache
/*     */ {
/*     */   static class Entry
/*     */   {
/*     */     final String field;
/*     */     final int type;
/*     */     final Object custom;
/*     */     final Locale locale;
/*     */     
/*     */     Entry(String field, int type, Locale locale) {
/*  53 */       this.field = field.intern();
/*  54 */       this.type = type;
/*  55 */       this.custom = null;
/*  56 */       this.locale = locale;
/*     */     }
/*     */ 
/*     */     
/*     */     Entry(String field, Object custom) {
/*  61 */       this.field = field.intern();
/*  62 */       this.type = 9;
/*  63 */       this.custom = custom;
/*  64 */       this.locale = null;
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean equals(Object o) {
/*  69 */       if (o instanceof Entry) {
/*  70 */         Entry other = (Entry)o;
/*  71 */         if (other.field == this.field && other.type == this.type && (
/*  72 */           (other.locale == null) ? (this.locale == null) : other.locale.equals(this.locale))) {
/*  73 */           if (other.custom == null) {
/*  74 */             if (this.custom == null) return true; 
/*  75 */           } else if (other.custom.equals(this.custom)) {
/*  76 */             return true;
/*     */           } 
/*     */         }
/*     */       } 
/*     */       
/*  81 */       return false;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  86 */     public int hashCode() { return this.field.hashCode() ^ this.type ^ ((this.custom == null) ? 0 : this.custom.hashCode()) ^ ((this.locale == null) ? 0 : this.locale.hashCode()); }
/*     */   }
/*     */ 
/*     */   
/*  90 */   private static final FieldCache.IntParser INT_PARSER = new FieldCache.IntParser()
/*     */     {
/*  92 */       public int parseInt(String value) { return Integer.parseInt(value); }
/*     */     };
/*     */ 
/*     */   
/*  96 */   private static final FieldCache.FloatParser FLOAT_PARSER = new FieldCache.FloatParser()
/*     */     {
/*  98 */       public float parseFloat(String value) { return Float.parseFloat(value); }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 103 */   final Map cache = new WeakHashMap();
/*     */ 
/*     */   
/*     */   Object lookup(IndexReader reader, String field, int type, Locale locale) {
/* 107 */     Entry entry = new Entry(field, type, locale);
/* 108 */     synchronized (this) {
/* 109 */       HashMap readerCache = (HashMap)this.cache.get(reader);
/* 110 */       if (readerCache == null) return null; 
/* 111 */       return readerCache.get(entry);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   Object lookup(IndexReader reader, String field, Object comparer) {
/* 117 */     Entry entry = new Entry(field, comparer);
/* 118 */     synchronized (this) {
/* 119 */       HashMap readerCache = (HashMap)this.cache.get(reader);
/* 120 */       if (readerCache == null) return null; 
/* 121 */       return readerCache.get(entry);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   Object store(IndexReader reader, String field, int type, Locale locale, Object value) {
/* 127 */     Entry entry = new Entry(field, type, locale);
/* 128 */     synchronized (this) {
/* 129 */       HashMap readerCache = (HashMap)this.cache.get(reader);
/* 130 */       if (readerCache == null) {
/* 131 */         readerCache = new HashMap();
/* 132 */         this.cache.put(reader, readerCache);
/*     */       } 
/* 134 */       return readerCache.put(entry, value);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   Object store(IndexReader reader, String field, Object comparer, Object value) {
/* 140 */     Entry entry = new Entry(field, comparer);
/* 141 */     synchronized (this) {
/* 142 */       HashMap readerCache = (HashMap)this.cache.get(reader);
/* 143 */       if (readerCache == null) {
/* 144 */         readerCache = new HashMap();
/* 145 */         this.cache.put(reader, readerCache);
/*     */       } 
/* 147 */       return readerCache.put(entry, value);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 153 */   public int[] getInts(IndexReader reader, String field) throws IOException { return getInts(reader, field, INT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getInts(IndexReader reader, String field, FieldCache.IntParser parser) throws IOException {
/* 159 */     field = field.intern();
/* 160 */     Object ret = lookup(reader, field, parser);
/* 161 */     if (ret == null) {
/* 162 */       int[] retArray = new int[reader.maxDoc()];
/* 163 */       TermDocs termDocs = reader.termDocs();
/* 164 */       TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */       try {
/*     */         do {
/* 167 */           Term term = termEnum.term();
/* 168 */           if (term == null || term.field() != field)
/* 169 */             break;  int termval = parser.parseInt(term.text());
/* 170 */           termDocs.seek(termEnum);
/* 171 */           while (termDocs.next()) {
/* 172 */             retArray[termDocs.doc()] = termval;
/*     */           }
/* 174 */         } while (termEnum.next());
/*     */       } finally {
/* 176 */         termDocs.close();
/* 177 */         termEnum.close();
/*     */       } 
/* 179 */       store(reader, field, parser, retArray);
/* 180 */       return retArray;
/*     */     } 
/* 182 */     return (int[])ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 188 */   public float[] getFloats(IndexReader reader, String field) throws IOException { return getFloats(reader, field, FLOAT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float[] getFloats(IndexReader reader, String field, FieldCache.FloatParser parser) throws IOException {
/* 194 */     field = field.intern();
/* 195 */     Object ret = lookup(reader, field, parser);
/* 196 */     if (ret == null) {
/* 197 */       float[] retArray = new float[reader.maxDoc()];
/* 198 */       TermDocs termDocs = reader.termDocs();
/* 199 */       TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */       try {
/*     */         do {
/* 202 */           Term term = termEnum.term();
/* 203 */           if (term == null || term.field() != field)
/* 204 */             break;  float termval = parser.parseFloat(term.text());
/* 205 */           termDocs.seek(termEnum);
/* 206 */           while (termDocs.next()) {
/* 207 */             retArray[termDocs.doc()] = termval;
/*     */           }
/* 209 */         } while (termEnum.next());
/*     */       } finally {
/* 211 */         termDocs.close();
/* 212 */         termEnum.close();
/*     */       } 
/* 214 */       store(reader, field, parser, retArray);
/* 215 */       return retArray;
/*     */     } 
/* 217 */     return (float[])ret;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String[] getStrings(IndexReader reader, String field) throws IOException {
/* 223 */     field = field.intern();
/* 224 */     Object ret = lookup(reader, field, 3, null);
/* 225 */     if (ret == null) {
/* 226 */       String[] retArray = new String[reader.maxDoc()];
/* 227 */       TermDocs termDocs = reader.termDocs();
/* 228 */       TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */       try {
/*     */         do {
/* 231 */           Term term = termEnum.term();
/* 232 */           if (term == null || term.field() != field)
/* 233 */             break;  String termval = term.text();
/* 234 */           termDocs.seek(termEnum);
/* 235 */           while (termDocs.next()) {
/* 236 */             retArray[termDocs.doc()] = termval;
/*     */           }
/* 238 */         } while (termEnum.next());
/*     */       } finally {
/* 240 */         termDocs.close();
/* 241 */         termEnum.close();
/*     */       } 
/* 243 */       store(reader, field, 3, null, retArray);
/* 244 */       return retArray;
/*     */     } 
/* 246 */     return (String[])ret;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public FieldCache.StringIndex getStringIndex(IndexReader reader, String field) throws IOException {
/* 252 */     field = field.intern();
/* 253 */     Object ret = lookup(reader, field, -1, null);
/* 254 */     if (ret == null) {
/* 255 */       int[] retArray = new int[reader.maxDoc()];
/* 256 */       String[] mterms = new String[reader.maxDoc() + 1];
/* 257 */       TermDocs termDocs = reader.termDocs();
/* 258 */       TermEnum termEnum = reader.terms(new Term(field, """"));
/* 259 */       int t = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 265 */       mterms[t++] = null;
/*     */       
/*     */       try {
/*     */         do {
/* 269 */           Term term = termEnum.term();
/* 270 */           if (term == null || term.field() != field) {
/*     */             break;
/*     */           }
/*     */           
/* 274 */           if (t >= mterms.length) throw new RuntimeException(""there are more terms than documents in field \"""" + field + ""\"", but it's impossible to sort on "" + ""tokenized fields"");
/*     */ 
/*     */           
/* 277 */           mterms[t] = term.text();
/*     */           
/* 279 */           termDocs.seek(termEnum);
/* 280 */           while (termDocs.next()) {
/* 281 */             retArray[termDocs.doc()] = t;
/*     */           }
/*     */           
/* 284 */           t++;
/* 285 */         } while (termEnum.next());
/*     */       } finally {
/* 287 */         termDocs.close();
/* 288 */         termEnum.close();
/*     */       } 
/*     */       
/* 291 */       if (t == 0) {
/*     */ 
/*     */         
/* 294 */         mterms = new String[1];
/* 295 */       } else if (t < mterms.length) {
/*     */ 
/*     */         
/* 298 */         String[] terms = new String[t];
/* 299 */         System.arraycopy(mterms, 0, terms, 0, t);
/* 300 */         mterms = terms;
/*     */       } 
/*     */       
/* 303 */       FieldCache.StringIndex value = new FieldCache.StringIndex(retArray, mterms);
/* 304 */       store(reader, field, -1, null, value);
/* 305 */       return value;
/*     */     } 
/* 307 */     return (FieldCache.StringIndex)ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object getAuto(IndexReader reader, String field) throws IOException {
/* 324 */     field = field.intern();
/* 325 */     Object ret = lookup(reader, field, 2, null);
/* 326 */     if (ret == null) {
/* 327 */       TermEnum enumerator = reader.terms(new Term(field, """"));
/*     */       try {
/* 329 */         Term term = enumerator.term();
/* 330 */         if (term == null) {
/* 331 */           throw new RuntimeException(""no terms in field "" + field + "" - cannot determine sort type"");
/*     */         }
/* 333 */         if (term.field() == field) {
/* 334 */           String termtext = term.text().trim();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/*     */           try {
/* 348 */             Integer.parseInt(termtext);
/* 349 */             ret = getInts(reader, field);
/* 350 */           } catch (NumberFormatException nfe1) {
/*     */             try {
/* 352 */               Float.parseFloat(termtext);
/* 353 */               ret = getFloats(reader, field);
/* 354 */             } catch (NumberFormatException nfe2) {
/* 355 */               ret = getStringIndex(reader, field);
/*     */             } 
/*     */           } 
/* 358 */           if (ret != null) {
/* 359 */             store(reader, field, 2, null, ret);
/*     */           }
/*     */         } else {
/* 362 */           throw new RuntimeException(""field \"""" + field + ""\"" does not appear to be indexed"");
/*     */         } 
/*     */       } finally {
/* 365 */         enumerator.close();
/*     */       } 
/*     */     } 
/*     */     
/* 369 */     return ret;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Comparable[] getCustom(IndexReader reader, String field, SortComparator comparator) throws IOException {
/* 375 */     field = field.intern();
/* 376 */     Object ret = lookup(reader, field, comparator);
/* 377 */     if (ret == null) {
/* 378 */       Comparable[] retArray = new Comparable[reader.maxDoc()];
/* 379 */       TermDocs termDocs = reader.termDocs();
/* 380 */       TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */       try {
/*     */         do {
/* 383 */           Term term = termEnum.term();
/* 384 */           if (term == null || term.field() != field)
/* 385 */             break;  Comparable termval = comparator.getComparable(term.text());
/* 386 */           termDocs.seek(termEnum);
/* 387 */           while (termDocs.next()) {
/* 388 */             retArray[termDocs.doc()] = termval;
/*     */           }
/* 390 */         } while (termEnum.next());
/*     */       } finally {
/* 392 */         termDocs.close();
/* 393 */         termEnum.close();
/*     */       } 
/* 395 */       store(reader, field, comparator, retArray);
/* 396 */       return retArray;
/*     */     } 
/* 398 */     return (Comparable[])ret;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FieldCacheImpl.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldDoc
/*    */   extends ScoreDoc
/*    */ {
/*    */   public Comparable[] fields;
/*    */   
/* 55 */   public FieldDoc(int doc, float score) { super(doc, score); }
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldDoc(int doc, float score, Comparable[] fields) {
/* 60 */     super(doc, score);
/* 61 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FieldDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDocSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.text.Collator;
/*     */ import java.util.Locale;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldDocSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   volatile SortField[] fields;
/*     */   volatile Collator[] collators;
/*     */   
/*     */   FieldDocSortedHitQueue(SortField[] fields, int size) {
/*  52 */     this.fields = fields;
/*  53 */     this.collators = hasCollators(fields);
/*  54 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   synchronized void setFields(SortField[] fields) {
/*  67 */     if (this.fields == null) {
/*  68 */       this.fields = fields;
/*  69 */       this.collators = hasCollators(fields);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Collator[] hasCollators(SortField[] fields) {
/*  86 */     if (fields == null) return null; 
/*  87 */     Collator[] ret = new Collator[fields.length];
/*  88 */     for (int i = 0; i < fields.length; i++) {
/*  89 */       Locale locale = fields[i].getLocale();
/*  90 */       if (locale != null)
/*  91 */         ret[i] = Collator.getInstance(locale); 
/*     */     } 
/*  93 */     return ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean lessThan(Object a, Object b) {
/* 104 */     FieldDoc docA = (FieldDoc)a;
/* 105 */     FieldDoc docB = (FieldDoc)b;
/* 106 */     int n = this.fields.length;
/* 107 */     int c = 0;
/* 108 */     for (int i = 0; i < n && c == 0; i++) {
/* 109 */       float f2, f1; String s2, s1; int i2, i1; float r2, r1; int type = this.fields[i].getType();
/* 110 */       switch (type) {
/*     */         case 0:
/* 112 */           r1 = ((Float)docA.fields[i]).floatValue();
/* 113 */           r2 = ((Float)docB.fields[i]).floatValue();
/* 114 */           if (r1 > r2) c = -1; 
/* 115 */           if (r1 < r2) c = 1; 
/*     */           break;
/*     */         case 1:
/*     */         case 4:
/* 119 */           i1 = ((Integer)docA.fields[i]).intValue();
/* 120 */           i2 = ((Integer)docB.fields[i]).intValue();
/* 121 */           if (i1 < i2) c = -1; 
/* 122 */           if (i1 > i2) c = 1; 
/*     */           break;
/*     */         case 3:
/* 125 */           s1 = (String)docA.fields[i];
/* 126 */           s2 = (String)docB.fields[i];
/*     */ 
/*     */ 
/*     */           
/* 130 */           if (s1 == null) { c = (s2 == null) ? 0 : -1; break; }
/* 131 */            if (s2 == null) { c = 1; break; }
/* 132 */            if (this.fields[i].getLocale() == null) {
/* 133 */             c = s1.compareTo(s2); break;
/*     */           } 
/* 135 */           c = this.collators[i].compare(s1, s2);
/*     */           break;
/*     */         
/*     */         case 5:
/* 139 */           f1 = ((Float)docA.fields[i]).floatValue();
/* 140 */           f2 = ((Float)docB.fields[i]).floatValue();
/* 141 */           if (f1 < f2) c = -1; 
/* 142 */           if (f1 > f2) c = 1; 
/*     */           break;
/*     */         case 9:
/* 145 */           c = docA.fields[i].compareTo(docB.fields[i]);
/*     */           break;
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*     */         case 2:
/* 152 */           throw new RuntimeException(""FieldDocSortedHitQueue cannot use an AUTO SortField"");
/*     */         default:
/* 154 */           throw new RuntimeException(""invalid SortField type: "" + type);
/*     */       } 
/* 156 */       if (this.fields[i].getReverse()) {
/* 157 */         c = -c;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 162 */     if (c == 0) {
/* 163 */       return (docA.doc > docB.doc);
/*     */     }
/* 165 */     return (c > 0);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FieldDocSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import java.util.HashMap;
/*     */ import java.util.Locale;
/*     */ import java.util.Map;
/*     */ import java.util.WeakHashMap;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FieldSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   protected ScoreDocComparator[] comparators;
/*     */   protected SortField[] fields;
/*     */   
/*     */   public FieldSortedHitQueue(IndexReader reader, SortField[] fields, int size) throws IOException {
/*  53 */     int n = fields.length;
/*  54 */     this.comparators = new ScoreDocComparator[n];
/*  55 */     this.fields = new SortField[n];
/*  56 */     for (int i = 0; i < n; i++) {
/*  57 */       String fieldname = fields[i].getField();
/*  58 */       this.comparators[i] = getCachedComparator(reader, fieldname, fields[i].getType(), fields[i].getLocale(), fields[i].getFactory());
/*     */       
/*  60 */       if (this.comparators[i].sortType() == 3) {
/*  61 */         this.fields[i] = new SortField(fieldname, fields[i].getLocale(), fields[i].getReverse());
/*     */       } else {
/*  63 */         this.fields[i] = new SortField(fieldname, this.comparators[i].sortType(), fields[i].getReverse());
/*     */       } 
/*     */     } 
/*  66 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   protected float maxscore = Float.NEGATIVE_INFINITY;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  82 */   public float getMaxScore() { return this.maxscore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(FieldDoc fdoc) {
/*  89 */     this.maxscore = Math.max(this.maxscore, fdoc.score);
/*  90 */     return super.insert(fdoc);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public boolean insert(Object fdoc) { return insert((FieldDoc)fdoc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean lessThan(Object a, Object b) {
/* 107 */     ScoreDoc docA = (ScoreDoc)a;
/* 108 */     ScoreDoc docB = (ScoreDoc)b;
/*     */ 
/*     */     
/* 111 */     int n = this.comparators.length;
/* 112 */     int c = 0;
/* 113 */     for (int i = 0; i < n && c == 0; i++) {
/* 114 */       c = (this.fields[i]).reverse ? this.comparators[i].compare(docB, docA) : this.comparators[i].compare(docA, docB);
/*     */     }
/*     */ 
/*     */     
/* 118 */     if (c == 0)
/* 119 */       return (docA.doc > docB.doc); 
/* 120 */     return (c > 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldDoc fillFields(FieldDoc doc) {
/* 135 */     int n = this.comparators.length;
/* 136 */     Comparable[] fields = new Comparable[n];
/* 137 */     for (int i = 0; i < n; i++)
/* 138 */       fields[i] = this.comparators[i].sortValue(doc); 
/* 139 */     doc.fields = fields;
/*     */     
/* 141 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 147 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 152 */   static final Map Comparators = new WeakHashMap();
/*     */ 
/*     */   
/*     */   static ScoreDocComparator lookup(IndexReader reader, String field, int type, Locale locale, Object factory) {
/* 156 */     FieldCacheImpl.Entry entry = (factory != null) ? new FieldCacheImpl.Entry(field, factory) : new FieldCacheImpl.Entry(field, type, locale);
/*     */ 
/*     */     
/* 159 */     synchronized (Comparators) {
/* 160 */       HashMap readerCache = (HashMap)Comparators.get(reader);
/* 161 */       if (readerCache == null) return null; 
/* 162 */       return (ScoreDocComparator)readerCache.get(entry);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   static Object store(IndexReader reader, String field, int type, Locale locale, Object factory, Object value) {
/* 168 */     FieldCacheImpl.Entry entry = (factory != null) ? new FieldCacheImpl.Entry(field, factory) : new FieldCacheImpl.Entry(field, type, locale);
/*     */ 
/*     */     
/* 171 */     synchronized (Comparators) {
/* 172 */       HashMap readerCache = (HashMap)Comparators.get(reader);
/* 173 */       if (readerCache == null) {
/* 174 */         readerCache = new HashMap();
/* 175 */         Comparators.put(reader, readerCache);
/*     */       } 
/* 177 */       return readerCache.put(entry, value);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   static ScoreDocComparator getCachedComparator(IndexReader reader, String fieldname, int type, Locale locale, SortComparatorSource factory) throws IOException {
/* 183 */     if (type == 1) return ScoreDocComparator.INDEXORDER; 
/* 184 */     if (type == 0) return ScoreDocComparator.RELEVANCE; 
/* 185 */     ScoreDocComparator comparator = lookup(reader, fieldname, type, locale, factory);
/* 186 */     if (comparator == null) {
/* 187 */       switch (type) {
/*     */         case 2:
/* 189 */           comparator = comparatorAuto(reader, fieldname);
/*     */           break;
/*     */         case 4:
/* 192 */           comparator = comparatorInt(reader, fieldname);
/*     */           break;
/*     */         case 5:
/* 195 */           comparator = comparatorFloat(reader, fieldname);
/*     */           break;
/*     */         case 3:
/* 198 */           if (locale != null) { comparator = comparatorStringLocale(reader, fieldname, locale); break; }
/* 199 */            comparator = comparatorString(reader, fieldname);
/*     */           break;
/*     */         case 9:
/* 202 */           comparator = factory.newComparator(reader, fieldname);
/*     */           break;
/*     */         default:
/* 205 */           throw new RuntimeException(""unknown field type: "" + type);
/*     */       } 
/* 207 */       store(reader, fieldname, type, locale, factory, comparator);
/*     */     } 
/* 209 */     return comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorInt(IndexReader reader, String fieldname) throws IOException {
/* 221 */     String field = fieldname.intern();
/* 222 */     final int[] fieldOrder = FieldCache.DEFAULT.getInts(reader, field);
/* 223 */     return new ScoreDocComparator() { private final int[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 226 */           int fi = fieldOrder[i.doc];
/* 227 */           int fj = fieldOrder[j.doc];
/* 228 */           if (fi < fj) return -1; 
/* 229 */           if (fi > fj) return 1; 
/* 230 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 234 */         public Comparable sortValue(ScoreDoc i) { return new Integer(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 238 */         public int sortType() { return 4; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorFloat(IndexReader reader, String fieldname) throws IOException {
/* 252 */     String field = fieldname.intern();
/* 253 */     final float[] fieldOrder = FieldCache.DEFAULT.getFloats(reader, field);
/* 254 */     return new ScoreDocComparator() { private final float[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 257 */           float fi = fieldOrder[i.doc];
/* 258 */           float fj = fieldOrder[j.doc];
/* 259 */           if (fi < fj) return -1; 
/* 260 */           if (fi > fj) return 1; 
/* 261 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 265 */         public Comparable sortValue(ScoreDoc i) { return new Float(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 269 */         public int sortType() { return 5; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorString(IndexReader reader, String fieldname) throws IOException {
/* 283 */     String field = fieldname.intern();
/* 284 */     final FieldCache.StringIndex index = FieldCache.DEFAULT.getStringIndex(reader, field);
/* 285 */     return new ScoreDocComparator() { private final FieldCache.StringIndex val$index;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 288 */           int fi = index.order[i.doc];
/* 289 */           int fj = index.order[j.doc];
/* 290 */           if (fi < fj) return -1; 
/* 291 */           if (fi > fj) return 1; 
/* 292 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 296 */         public Comparable sortValue(ScoreDoc i) { return index.lookup[index.order[i.doc]]; }
/*     */ 
/*     */ 
/*     */         
/* 300 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorStringLocale(IndexReader reader, String fieldname, Locale locale) throws IOException {
/* 314 */     final Collator collator = Collator.getInstance(locale);
/* 315 */     String field = fieldname.intern();
/* 316 */     final String[] index = FieldCache.DEFAULT.getStrings(reader, field);
/* 317 */     return new ScoreDocComparator() { private final Collator val$collator;
/*     */         private final String[] val$index;
/*     */         
/* 320 */         public final int compare(ScoreDoc i, ScoreDoc j) { return collator.compare(index[i.doc], index[j.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 324 */         public Comparable sortValue(ScoreDoc i) { return index[i.doc]; }
/*     */ 
/*     */ 
/*     */         
/* 328 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorAuto(IndexReader reader, String fieldname) throws IOException {
/* 345 */     String field = fieldname.intern();
/* 346 */     Object lookupArray = FieldCache.DEFAULT.getAuto(reader, field);
/* 347 */     if (lookupArray instanceof FieldCache.StringIndex)
/* 348 */       return comparatorString(reader, field); 
/* 349 */     if (lookupArray instanceof int[])
/* 350 */       return comparatorInt(reader, field); 
/* 351 */     if (lookupArray instanceof float[])
/* 352 */       return comparatorFloat(reader, field); 
/* 353 */     if (lookupArray instanceof String[]) {
/* 354 */       return comparatorString(reader, field);
/*     */     }
/* 356 */     throw new RuntimeException(""unknown data type in field '"" + field + ""'"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FieldSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Filter,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import java.util.BitSet;
import org.apache.lucene.index.IndexReader;
public abstract class Filter implements Serializable {
  public abstract BitSet bits(IndexReader paramIndexReader) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Filter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilteredQuery
/*     */   extends Query
/*     */ {
/*     */   Query query;
/*     */   Filter filter;
/*     */   
/*     */   public FilteredQuery(Query query, Filter filter) {
/*  54 */     this.query = query;
/*  55 */     this.filter = filter;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/*  65 */     final Weight weight = this.query.createWeight(searcher);
/*  66 */     final Similarity similarity = this.query.getSimilarity(searcher);
/*  67 */     return new Weight() {
/*     */         private final Weight val$weight;
/*     */         
/*  70 */         public float getValue() { return weight.getValue(); } private final Similarity val$similarity; private final FilteredQuery this$0;
/*  71 */         public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }
/*  72 */         public void normalize(float v) { weight.normalize(v); }
/*  73 */         public Explanation explain(IndexReader ir, int i) throws IOException { return weight.explain(ir, i); }
/*     */ 
/*     */         
/*  76 */         public Query getQuery() { return FilteredQuery.this; }
/*     */ 
/*     */         
/*     */         public Scorer scorer(IndexReader indexReader) throws IOException {
/*  80 */           Scorer scorer = weight.scorer(indexReader);
/*  81 */           BitSet bitset = FilteredQuery.this.filter.bits(indexReader);
/*  82 */           return (Scorer)new Object(this, similarity, scorer, bitset);
/*     */         }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 131 */     Query rewritten = this.query.rewrite(reader);
/* 132 */     if (rewritten != this.query) {
/* 133 */       FilteredQuery clone = (FilteredQuery)clone();
/* 134 */       clone.query = rewritten;
/* 135 */       return clone;
/*     */     } 
/* 137 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 142 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/* 146 */   public Filter getFilter() { return this.filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 151 */   public void extractTerms(Set terms) { getQuery().extractTerms(terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String s) {
/* 156 */     StringBuffer buffer = new StringBuffer();
/* 157 */     buffer.append(""filtered("");
/* 158 */     buffer.append(this.query.toString(s));
/* 159 */     buffer.append("")->"");
/* 160 */     buffer.append(this.filter);
/* 161 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 162 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 167 */     if (o instanceof FilteredQuery) {
/* 168 */       FilteredQuery fq = (FilteredQuery)o;
/* 169 */       return (this.query.equals(fq.query) && this.filter.equals(fq.filter));
/*     */     } 
/* 171 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 176 */   public int hashCode() { return this.query.hashCode() ^ this.filter.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FilteredQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredTermEnum,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class FilteredTermEnum
/*    */   extends TermEnum
/*    */ {
/* 28 */   private Term currentTerm = null;
/* 29 */   private TermEnum actualEnum = null;
/*    */ 
/*    */ 
/*    */   
/*    */   protected abstract boolean termCompare(Term paramTerm);
/*    */ 
/*    */   
/*    */   public abstract float difference();
/*    */ 
/*    */   
/*    */   protected abstract boolean endEnum();
/*    */ 
/*    */   
/*    */   protected void setEnum(TermEnum actualEnum) throws IOException {
/* 43 */     this.actualEnum = actualEnum;
/*    */     
/* 45 */     Term term = actualEnum.term();
/* 46 */     if (term != null && termCompare(term))
/* 47 */     { this.currentTerm = term; }
/* 48 */     else { next(); }
/*    */   
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int docFreq() {
/* 56 */     if (this.actualEnum == null) return -1; 
/* 57 */     return this.actualEnum.docFreq();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean next() throws IOException {
/* 62 */     if (this.actualEnum == null) return false; 
/* 63 */     this.currentTerm = null;
/* 64 */     while (this.currentTerm == null) {
/* 65 */       if (endEnum()) return false; 
/* 66 */       if (this.actualEnum.next()) {
/* 67 */         Term term = this.actualEnum.term();
/* 68 */         if (termCompare(term)) {
/* 69 */           this.currentTerm = term;
/* 70 */           return true;
/*    */         }  continue;
/*    */       } 
/* 73 */       return false;
/*    */     } 
/* 75 */     this.currentTerm = null;
/* 76 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 82 */   public Term term() { return this.currentTerm; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void close() throws IOException {
/* 87 */     this.actualEnum.close();
/* 88 */     this.currentTerm = null;
/* 89 */     this.actualEnum = null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FilteredTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FuzzyQuery
/*     */   extends MultiTermQuery
/*     */ {
/*     */   public static final float defaultMinSimilarity = 0.5F;
/*     */   public static final int defaultPrefixLength = 0;
/*     */   private float minimumSimilarity;
/*     */   private int prefixLength;
/*     */   
/*     */   public FuzzyQuery(Term term, float minimumSimilarity, int prefixLength) throws IllegalArgumentException {
/*  54 */     super(term);
/*     */     
/*  56 */     if (minimumSimilarity >= 1.0F)
/*  57 */       throw new IllegalArgumentException(""minimumSimilarity >= 1""); 
/*  58 */     if (minimumSimilarity < 0.0F)
/*  59 */       throw new IllegalArgumentException(""minimumSimilarity < 0""); 
/*  60 */     if (prefixLength < 0) {
/*  61 */       throw new IllegalArgumentException(""prefixLength < 0"");
/*     */     }
/*  63 */     this.minimumSimilarity = minimumSimilarity;
/*  64 */     this.prefixLength = prefixLength;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  71 */   public FuzzyQuery(Term term, float minimumSimilarity) throws IllegalArgumentException { this(term, minimumSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  78 */   public FuzzyQuery(Term term) { this(term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public float getMinSimilarity() { return this.minimumSimilarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public int getPrefixLength() { return this.prefixLength; }
/*     */ 
/*     */ 
/*     */   
/*  99 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new FuzzyTermEnum(reader, getTerm(), this.minimumSimilarity, this.prefixLength); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 103 */     FilteredTermEnum enumerator = getEnum(reader);
/* 104 */     int maxClauseCount = BooleanQuery.getMaxClauseCount();
/* 105 */     ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);
/*     */     
/*     */     try {
/*     */       do {
/* 109 */         float minScore = 0.0F;
/* 110 */         float score = 0.0F;
/* 111 */         Term t = enumerator.term();
/* 112 */         if (t == null)
/* 113 */           continue;  score = enumerator.difference();
/*     */ 
/*     */         
/* 116 */         if (stQueue.size() >= maxClauseCount && score <= minScore)
/* 117 */           continue;  stQueue.insert(new ScoreTerm(t, score));
/* 118 */         minScore = ((ScoreTerm)stQueue.top()).score;
/*     */       
/*     */       }
/* 121 */       while (enumerator.next());
/*     */     } finally {
/* 123 */       enumerator.close();
/*     */     } 
/*     */     
/* 126 */     BooleanQuery query = new BooleanQuery(true);
/* 127 */     int size = stQueue.size();
/* 128 */     for (int i = 0; i < size; i++) {
/* 129 */       ScoreTerm st = (ScoreTerm)stQueue.pop();
/* 130 */       TermQuery tq = new TermQuery(st.term);
/* 131 */       tq.setBoost(getBoost() * st.score);
/* 132 */       query.add(tq, BooleanClause.Occur.SHOULD);
/*     */     } 
/*     */     
/* 135 */     return query;
/*     */   }
/*     */   
/*     */   public String toString(String field) {
/* 139 */     StringBuffer buffer = new StringBuffer();
/* 140 */     Term term = getTerm();
/* 141 */     if (!term.field().equals(field)) {
/* 142 */       buffer.append(term.field());
/* 143 */       buffer.append("":"");
/*     */     } 
/* 145 */     buffer.append(term.text());
/* 146 */     buffer.append('~');
/* 147 */     buffer.append(Float.toString(this.minimumSimilarity));
/* 148 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 149 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   private static class ScoreTerm {
/*     */     public Term term;
/*     */     public float score;
/*     */     
/*     */     public ScoreTerm(Term term, float score) {
/* 157 */       this.term = term;
/* 158 */       this.score = score;
/*     */     }
/*     */   }
/*     */   
/*     */   private static class ScoreTermQueue
/*     */     extends PriorityQueue
/*     */   {
/* 165 */     public ScoreTermQueue(int size) { initialize(size); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected boolean lessThan(Object a, Object b) {
/* 172 */       FuzzyQuery.ScoreTerm termA = (FuzzyQuery.ScoreTerm)a;
/* 173 */       FuzzyQuery.ScoreTerm termB = (FuzzyQuery.ScoreTerm)b;
/* 174 */       if (termA.score == termB.score) {
/* 175 */         return (termA.term.compareTo(termB.term) > 0);
/*     */       }
/* 177 */       return (termA.score < termB.score);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 183 */     if (this == o) return true; 
/* 184 */     if (!(o instanceof FuzzyQuery)) return false; 
/* 185 */     if (!super.equals(o)) return false;
/*     */     
/* 187 */     FuzzyQuery fuzzyQuery = (FuzzyQuery)o;
/*     */     
/* 189 */     if (this.minimumSimilarity != fuzzyQuery.minimumSimilarity) return false; 
/* 190 */     if (this.prefixLength != fuzzyQuery.prefixLength) return false;
/*     */     
/* 192 */     return true;
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 196 */     int result = super.hashCode();
/* 197 */     result = ((29 * result) + this.minimumSimilarity != 0.0F) ? Float.floatToIntBits(this.minimumSimilarity) : 0;
/* 198 */     result = 29 * result + this.prefixLength;
/* 199 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FuzzyQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FuzzyTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19;
/*     */   private int[][] d;
/*     */   private float similarity;
/*     */   private boolean endEnum = false;
/*  46 */   private Term searchTerm = null;
/*     */   
/*     */   private final String field;
/*     */   private final String text;
/*     */   private final String prefix;
/*     */   private final float minimumSimilarity;
/*     */   private final float scale_factor;
/*  53 */   private final int[] maxDistances = new int[19];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  67 */   public FuzzyTermEnum(IndexReader reader, Term term) throws IOException { this(reader, term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  83 */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity) throws IOException { this(reader, term, minSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity, int prefixLength) throws IOException {
/* 103 */     if (minSimilarity >= 1.0F)
/* 104 */       throw new IllegalArgumentException(""minimumSimilarity cannot be greater than or equal to 1""); 
/* 105 */     if (minSimilarity < 0.0F)
/* 106 */       throw new IllegalArgumentException(""minimumSimilarity cannot be less than 0""); 
/* 107 */     if (prefixLength < 0) {
/* 108 */       throw new IllegalArgumentException(""prefixLength cannot be less than 0"");
/*     */     }
/* 110 */     this.minimumSimilarity = minSimilarity;
/* 111 */     this.scale_factor = 1.0F / (1.0F - this.minimumSimilarity);
/* 112 */     this.searchTerm = term;
/* 113 */     this.field = this.searchTerm.field();
/*     */ 
/*     */ 
/*     */     
/* 117 */     int fullSearchTermLength = this.searchTerm.text().length();
/* 118 */     int realPrefixLength = (prefixLength > fullSearchTermLength) ? fullSearchTermLength : prefixLength;
/*     */     
/* 120 */     this.text = this.searchTerm.text().substring(realPrefixLength);
/* 121 */     this.prefix = this.searchTerm.text().substring(0, realPrefixLength);
/*     */     
/* 123 */     initializeMaxDistances();
/* 124 */     this.d = initDistanceArray();
/*     */     
/* 126 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.prefix)));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/* 134 */     if (this.field == term.field() && term.text().startsWith(this.prefix)) {
/* 135 */       String target = term.text().substring(this.prefix.length());
/* 136 */       this.similarity = similarity(target);
/* 137 */       return (this.similarity > this.minimumSimilarity);
/*     */     } 
/* 139 */     this.endEnum = true;
/* 140 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 144 */   public final float difference() { return (this.similarity - this.minimumSimilarity) * this.scale_factor; }
/*     */ 
/*     */ 
/*     */   
/* 148 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int min(int a, int b, int c) {
/* 159 */     int t = (a < b) ? a : b;
/* 160 */     return (t < c) ? t : c;
/*     */   }
/*     */ 
/*     */   
/* 164 */   private final int[][] initDistanceArray() { return new int[this.text.length() + 1][19]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final synchronized float similarity(String target) {
/* 205 */     int m = target.length();
/* 206 */     int n = this.text.length();
/* 207 */     if (n == 0)
/*     */     {
/*     */       
/* 210 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - m / this.prefix.length());
/*     */     }
/* 212 */     if (m == 0) {
/* 213 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - n / this.prefix.length());
/*     */     }
/*     */     
/* 216 */     int maxDistance = getMaxDistance(m);
/*     */     
/* 218 */     if (maxDistance < Math.abs(m - n))
/*     */     {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 226 */       return 0.0F;
/*     */     }
/*     */ 
/*     */     
/* 230 */     if ((this.d[0]).length <= m) {
/* 231 */       growDistanceArray(m);
/*     */     }
/*     */ 
/*     */     
/* 235 */     for (int i = 0; i <= n; ) { this.d[i][0] = i; i++; }
/* 236 */      for (int j = 0; j <= m; ) { this.d[0][j] = j; j++; }
/*     */ 
/*     */     
/* 239 */     for (int i = 1; i <= n; i++) {
/* 240 */       int bestPossibleEditDistance = m;
/* 241 */       char s_i = this.text.charAt(i - 1);
/* 242 */       for (int j = 1; j <= m; j++) {
/* 243 */         if (s_i != target.charAt(j - 1)) {
/* 244 */           this.d[i][j] = min(this.d[i - 1][j], this.d[i][j - 1], this.d[i - 1][j - 1]) + 1;
/*     */         } else {
/*     */           
/* 247 */           this.d[i][j] = min(this.d[i - 1][j] + 1, this.d[i][j - 1] + 1, this.d[i - 1][j - 1]);
/*     */         } 
/* 249 */         bestPossibleEditDistance = Math.min(bestPossibleEditDistance, this.d[i][j]);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 256 */       if (i > maxDistance && bestPossibleEditDistance > maxDistance)
/*     */       {
/*     */         
/* 259 */         return 0.0F;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 268 */     return 1.0F - this.d[n][m] / (this.prefix.length() + Math.min(n, m));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void growDistanceArray(int m) {
/* 276 */     for (int i = 0; i < this.d.length; i++) {
/* 277 */       this.d[i] = new int[m + 1];
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 289 */   private final int getMaxDistance(int m) { return (m < this.maxDistances.length) ? this.maxDistances[m] : calculateMaxDistance(m); }
/*     */ 
/*     */   
/*     */   private void initializeMaxDistances() {
/* 293 */     for (int i = 0; i < this.maxDistances.length; i++) {
/* 294 */       this.maxDistances[i] = calculateMaxDistance(i);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 299 */   private int calculateMaxDistance(int m) { return (int)((1.0F - this.minimumSimilarity) * (Math.min(this.text.length(), m) + this.prefix.length())); }
/*     */ 
/*     */ 
/*     */   
/* 303 */   public void close() throws IOException { super.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\FuzzyTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hit,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Hit
/*     */   implements Serializable
/*     */ {
/*  31 */   private Document doc = null;
/*     */   
/*     */   private boolean resolved = false;
/*     */   
/*  35 */   private Hits hits = null;
/*     */ 
/*     */ 
/*     */   
/*     */   private int hitNumber;
/*     */ 
/*     */ 
/*     */   
/*     */   Hit(Hits hits, int hitNumber) {
/*  44 */     this.hits = hits;
/*  45 */     this.hitNumber = hitNumber;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Document getDocument() throws IOException {
/*  54 */     if (!this.resolved) fetchTheHit(); 
/*  55 */     return this.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public float getScore() throws IOException { return this.hits.score(this.hitNumber); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public int getId() throws IOException { return this.hits.id(this.hitNumber); }
/*     */ 
/*     */   
/*     */   private void fetchTheHit() throws IOException {
/*  77 */     this.doc = this.hits.doc(this.hitNumber);
/*  78 */     this.resolved = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  89 */   public float getBoost() throws IOException { return getDocument().getBoost(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public String get(String name) throws IOException { return getDocument().get(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString() {
/* 108 */     StringBuffer buffer = new StringBuffer();
/* 109 */     buffer.append(""Hit<"");
/* 110 */     buffer.append(this.hits.toString());
/* 111 */     buffer.append("" ["");
/* 112 */     buffer.append(this.hitNumber);
/* 113 */     buffer.append(""] "");
/* 114 */     if (this.resolved) {
/* 115 */       buffer.append(""resolved"");
/*     */     } else {
/* 117 */       buffer.append(""unresolved"");
/*     */     } 
/* 119 */     buffer.append("">"");
/* 120 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Hit.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitCollector,"package org.apache.lucene.search;
public abstract class HitCollector {
  public abstract void collect(int paramInt, float paramFloat);
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\HitCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitDoc,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class HitDoc
/*     */ {
/*     */   float score;
/*     */   int id;
/* 182 */   Document doc = null;
/*     */   
/*     */   HitDoc next;
/*     */   HitDoc prev;
/*     */   
/*     */   HitDoc(float s, int i) {
/* 188 */     this.score = s;
/* 189 */     this.id = i;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\HitDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitIterator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.util.Iterator;
/*    */ import java.util.NoSuchElementException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class HitIterator
/*    */   implements Iterator
/*    */ {
/*    */   private Hits hits;
/* 31 */   private int hitNumber = 0;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 37 */   HitIterator(Hits hits) { this.hits = hits; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public boolean hasNext() { return (this.hitNumber < this.hits.length()); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Object next() {
/* 53 */     if (this.hitNumber == this.hits.length()) {
/* 54 */       throw new NoSuchElementException();
/*    */     }
/* 56 */     Object next = new Hit(this.hits, this.hitNumber);
/* 57 */     this.hitNumber++;
/* 58 */     return next;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 67 */   public void remove() { throw new UnsupportedOperationException(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 74 */   public int length() { return this.hits.length(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\HitIterator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class HitQueue
/*    */   extends PriorityQueue
/*    */ {
/* 23 */   HitQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 27 */     ScoreDoc hitA = (ScoreDoc)a;
/* 28 */     ScoreDoc hitB = (ScoreDoc)b;
/* 29 */     if (hitA.score == hitB.score) {
/* 30 */       return (hitA.doc > hitB.doc);
/*    */     }
/* 32 */     return (hitA.score < hitB.score);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\HitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hits,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Hits
/*     */ {
/*     */   private Weight weight;
/*     */   private Searcher searcher;
/*  29 */   private Filter filter = null;
/*  30 */   private Sort sort = null;
/*     */   
/*     */   private int length;
/*  33 */   private Vector hitDocs = new Vector();
/*     */   
/*     */   private HitDoc first;
/*     */   private HitDoc last;
/*  37 */   private int numDocs = 0;
/*  38 */   private int maxDocs = 200;
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f) throws IOException {
/*  41 */     this.weight = q.weight(s);
/*  42 */     this.searcher = s;
/*  43 */     this.filter = f;
/*  44 */     getMoreDocs(50);
/*     */   }
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f, Sort o) throws IOException {
/*  48 */     this.weight = q.weight(s);
/*  49 */     this.searcher = s;
/*  50 */     this.filter = f;
/*  51 */     this.sort = o;
/*  52 */     getMoreDocs(50);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void getMoreDocs(int min) throws IOException {
/*  60 */     if (this.hitDocs.size() > min) {
/*  61 */       min = this.hitDocs.size();
/*     */     }
/*     */     
/*  64 */     int n = min * 2;
/*  65 */     TopDocs topDocs = (this.sort == null) ? this.searcher.search(this.weight, this.filter, n) : this.searcher.search(this.weight, this.filter, n, this.sort);
/*  66 */     this.length = topDocs.totalHits;
/*  67 */     ScoreDoc[] scoreDocs = topDocs.scoreDocs;
/*     */     
/*  69 */     float scoreNorm = 1.0F;
/*     */     
/*  71 */     if (this.length > 0 && topDocs.getMaxScore() > 1.0F) {
/*  72 */       scoreNorm = 1.0F / topDocs.getMaxScore();
/*     */     }
/*     */     
/*  75 */     int end = (scoreDocs.length < this.length) ? scoreDocs.length : this.length;
/*  76 */     for (int i = this.hitDocs.size(); i < end; i++) {
/*  77 */       this.hitDocs.addElement(new HitDoc((scoreDocs[i]).score * scoreNorm, (scoreDocs[i]).doc));
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public final int length() { return this.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Document doc(int n) throws IOException {
/*  91 */     HitDoc hitDoc = hitDoc(n);
/*     */ 
/*     */     
/*  94 */     remove(hitDoc);
/*  95 */     addToFront(hitDoc);
/*  96 */     if (this.numDocs > this.maxDocs) {
/*  97 */       HitDoc oldLast = this.last;
/*  98 */       remove(this.last);
/*  99 */       oldLast.doc = null;
/*     */     } 
/*     */     
/* 102 */     if (hitDoc.doc == null) {
/* 103 */       hitDoc.doc = this.searcher.doc(hitDoc.id);
/*     */     }
/*     */     
/* 106 */     return hitDoc.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 111 */   public final float score(int n) throws IOException { return (hitDoc(n)).score; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   public final int id(int n) throws IOException { return (hitDoc(n)).id; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 129 */   public Iterator iterator() { return new HitIterator(this); }
/*     */ 
/*     */   
/*     */   private final HitDoc hitDoc(int n) throws IOException {
/* 133 */     if (n >= this.length) {
/* 134 */       throw new IndexOutOfBoundsException(""Not a valid hit number: "" + n);
/*     */     }
/*     */     
/* 137 */     if (n >= this.hitDocs.size()) {
/* 138 */       getMoreDocs(n);
/*     */     }
/*     */     
/* 141 */     return this.hitDocs.elementAt(n);
/*     */   }
/*     */   
/*     */   private final void addToFront(HitDoc hitDoc) {
/* 145 */     if (this.first == null) {
/* 146 */       this.last = hitDoc;
/*     */     } else {
/* 148 */       this.first.prev = hitDoc;
/*     */     } 
/*     */     
/* 151 */     hitDoc.next = this.first;
/* 152 */     this.first = hitDoc;
/* 153 */     hitDoc.prev = null;
/*     */     
/* 155 */     this.numDocs++;
/*     */   }
/*     */   
/*     */   private final void remove(HitDoc hitDoc) {
/* 159 */     if (hitDoc.doc == null) {
/*     */       return;
/*     */     }
/*     */     
/* 163 */     if (hitDoc.next == null) {
/* 164 */       this.last = hitDoc.prev;
/*     */     } else {
/* 166 */       hitDoc.next.prev = hitDoc.prev;
/*     */     } 
/*     */     
/* 169 */     if (hitDoc.prev == null) {
/* 170 */       this.first = hitDoc.next;
/*     */     } else {
/* 172 */       hitDoc.prev.next = hitDoc.next;
/*     */     } 
/*     */     
/* 175 */     this.numDocs--;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Hits.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.IndexSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexSearcher
/*     */   extends Searcher
/*     */ {
/*     */   IndexReader reader;
/*     */   private boolean closeReader;
/*     */   
/*  42 */   public IndexSearcher(String path) throws IOException { this(IndexReader.open(path), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  47 */   public IndexSearcher(Directory directory) throws IOException { this(IndexReader.open(directory), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  52 */   public IndexSearcher(IndexReader r) { this(r, false); }
/*     */ 
/*     */   
/*     */   private IndexSearcher(IndexReader r, boolean closeReader) {
/*  56 */     this.reader = r;
/*  57 */     this.closeReader = closeReader;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public IndexReader getIndexReader() { return this.reader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/*  72 */     if (this.closeReader) {
/*  73 */       this.reader.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  78 */   public int docFreq(Term term) throws IOException { return this.reader.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  83 */   public Document doc(int i) throws IOException { return this.reader.document(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  88 */   public int maxDoc() throws IOException { return this.reader.maxDoc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/*  95 */     if (nDocs <= 0) {
/*  96 */       throw new IllegalArgumentException(""nDocs must be > 0"");
/*     */     }
/*  98 */     TopDocCollector collector = new TopDocCollector(nDocs);
/*  99 */     search(weight, filter, collector);
/* 100 */     return collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 108 */     TopFieldDocCollector collector = new TopFieldDocCollector(this.reader, sort, nDocs);
/*     */     
/* 110 */     search(weight, filter, collector);
/* 111 */     return (TopFieldDocs)collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 117 */     HitCollector collector = results;
/* 118 */     if (filter != null) {
/* 119 */       final BitSet bits = filter.bits(this.reader);
/* 120 */       collector = new HitCollector() { private final BitSet val$bits; private final HitCollector val$results;
/*     */           public final void collect(int doc, float score) {
/* 122 */             if (bits.get(doc))
/* 123 */               results.collect(doc, score); 
/*     */           }
/*     */           
/*     */           private final IndexSearcher this$0; }
/*     */         ;
/*     */     } 
/* 129 */     Scorer scorer = weight.scorer(this.reader);
/* 130 */     if (scorer == null)
/*     */       return; 
/* 132 */     scorer.score(collector);
/*     */   }
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 136 */     Query query = original;
/* 137 */     for (Query rewrittenQuery = query.rewrite(this.reader); rewrittenQuery != query; 
/* 138 */       rewrittenQuery = query.rewrite(this.reader)) {
/* 139 */       query = rewrittenQuery;
/*     */     }
/* 141 */     return query;
/*     */   }
/*     */ 
/*     */   
/* 145 */   public Explanation explain(Weight weight, int doc) throws IOException { return weight.explain(this.reader, doc); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\IndexSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MatchAllDocsQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MatchAllDocsQuery
/*     */   extends Query
/*     */ {
/*     */   private class MatchAllScorer
/*     */     extends Scorer
/*     */   {
/*     */     final IndexReader reader;
/*     */     int id;
/*     */     final int maxId;
/*     */     final float score;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*     */     MatchAllScorer(IndexReader reader, Similarity similarity, Weight w) {
/*  48 */       super(similarity);
/*  49 */       this.reader = reader;
/*  50 */       this.id = -1;
/*  51 */       this.maxId = reader.maxDoc() - 1;
/*  52 */       this.score = w.getValue();
/*     */     }
/*     */ 
/*     */     
/*  56 */     public Explanation explain(int doc) { return null; }
/*     */ 
/*     */ 
/*     */     
/*  60 */     public int doc() { return this.id; }
/*     */ 
/*     */     
/*     */     public boolean next() {
/*  64 */       while (this.id < this.maxId) {
/*  65 */         this.id++;
/*  66 */         if (!this.reader.isDeleted(this.id)) {
/*  67 */           return true;
/*     */         }
/*     */       } 
/*  70 */       return false;
/*     */     }
/*     */ 
/*     */     
/*  74 */     public float score() { return this.score; }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) {
/*  78 */       this.id = target - 1;
/*  79 */       return next();
/*     */     }
/*     */   }
/*     */   
/*     */   private class MatchAllDocsWeight
/*     */     implements Weight {
/*     */     private Searcher searcher;
/*     */     private float queryWeight;
/*     */     private float queryNorm;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*  90 */     public MatchAllDocsWeight(Searcher searcher) { this.searcher = searcher; }
/*     */ 
/*     */ 
/*     */     
/*  94 */     public String toString() { return ""weight("" + MatchAllDocsQuery.this + "")""; }
/*     */ 
/*     */ 
/*     */     
/*  98 */     public Query getQuery() { return MatchAllDocsQuery.this; }
/*     */ 
/*     */ 
/*     */     
/* 102 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 106 */       this.queryWeight = MatchAllDocsQuery.this.getBoost();
/* 107 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 111 */       this.queryNorm = queryNorm;
/* 112 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/* 116 */     public Scorer scorer(IndexReader reader) { return new MatchAllDocsQuery.MatchAllScorer(reader, MatchAllDocsQuery.this.getSimilarity(this.searcher), this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) {
/* 121 */       Explanation queryExpl = new Explanation();
/* 122 */       queryExpl.setDescription(""MatchAllDocsQuery, product of:"");
/* 123 */       queryExpl.setValue(getValue());
/* 124 */       if (MatchAllDocsQuery.this.getBoost() != 1.0F) {
/* 125 */         queryExpl.addDetail(new Explanation(MatchAllDocsQuery.this.getBoost(), ""boost""));
/*     */       }
/* 127 */       queryExpl.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       
/* 129 */       return queryExpl;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 134 */   protected Weight createWeight(Searcher searcher) { return new MatchAllDocsWeight(searcher); }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 141 */     StringBuffer buffer = new StringBuffer();
/* 142 */     buffer.append(""MatchAllDocsQuery"");
/* 143 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 144 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 148 */     if (!(o instanceof MatchAllDocsQuery))
/* 149 */       return false; 
/* 150 */     MatchAllDocsQuery other = (MatchAllDocsQuery)o;
/* 151 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/* 155 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ 0x1AA71190; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\MatchAllDocsQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiPhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collections;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.MultipleTermPositions;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiPhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  42 */   private ArrayList termArrays = new ArrayList();
/*  43 */   private Vector positions = new Vector();
/*     */   
/*  45 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public void setSlop(int s) { this.slop = s; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public void add(Term term) { add(new Term[] { term }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms) {
/*  68 */     int position = 0;
/*  69 */     if (this.positions.size() > 0) {
/*  70 */       position = ((Integer)this.positions.lastElement()).intValue() + 1;
/*     */     }
/*  72 */     add(terms, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms, int position) {
/*  83 */     if (this.termArrays.size() == 0) {
/*  84 */       this.field = terms[0].field();
/*     */     }
/*  86 */     for (int i = 0; i < terms.length; i++) {
/*  87 */       if (terms[i].field() != this.field) {
/*  88 */         throw new IllegalArgumentException(""All phrase terms must be in the same field ("" + this.field + ""): "" + terms[i]);
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*  94 */     this.termArrays.add(terms);
/*  95 */     this.positions.addElement(new Integer(position));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public List getTermArrays() { return Collections.unmodifiableList(this.termArrays); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 110 */     int[] result = new int[this.positions.size()];
/* 111 */     for (int i = 0; i < this.positions.size(); i++)
/* 112 */       result[i] = ((Integer)this.positions.elementAt(i)).intValue(); 
/* 113 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 118 */     for (Iterator iter = this.termArrays.iterator(); iter.hasNext(); ) {
/* 119 */       Term[] arr = iter.next();
/* 120 */       for (int i = 0; i < arr.length; i++)
/* 121 */         terms.add(arr[i]); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private class MultiPhraseWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final MultiPhraseQuery this$0;
/*     */     
/*     */     public MultiPhraseWeight(Searcher searcher) throws IOException {
/* 136 */       this.similarity = MultiPhraseQuery.this.getSimilarity(searcher);
/*     */ 
/*     */       
/* 139 */       Iterator i = MultiPhraseQuery.this.termArrays.iterator();
/* 140 */       while (i.hasNext()) {
/* 141 */         Term[] terms = i.next();
/* 142 */         for (int j = 0; j < terms.length; j++) {
/* 143 */           this.idf += MultiPhraseQuery.this.getSimilarity(searcher).idf(terms[j], searcher);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/* 148 */     public Query getQuery() { return MultiPhraseQuery.this; }
/* 149 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 152 */       this.queryWeight = this.idf * MultiPhraseQuery.this.getBoost();
/* 153 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 157 */       this.queryNorm = queryNorm;
/* 158 */       this.queryWeight *= queryNorm;
/* 159 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 163 */       if (MultiPhraseQuery.this.termArrays.size() == 0) {
/* 164 */         return null;
/*     */       }
/* 166 */       TermPositions[] tps = new TermPositions[MultiPhraseQuery.this.termArrays.size()];
/* 167 */       for (int i = 0; i < tps.length; i++) {
/* 168 */         Object p; Term[] terms = MultiPhraseQuery.this.termArrays.get(i);
/*     */ 
/*     */         
/* 171 */         if (terms.length > 1) {
/* 172 */           p = new MultipleTermPositions(reader, terms);
/*     */         } else {
/* 174 */           p = reader.termPositions(terms[0]);
/*     */         } 
/* 176 */         if (p == null) {
/* 177 */           return null;
/*     */         }
/* 179 */         tps[i] = (TermPositions)p;
/*     */       } 
/*     */       
/* 182 */       if (MultiPhraseQuery.this.slop == 0) {
/* 183 */         return new ExactPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, reader.norms(MultiPhraseQuery.this.field));
/*     */       }
/*     */       
/* 186 */       return new SloppyPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, MultiPhraseQuery.this.slop, reader.norms(MultiPhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 192 */       Explanation result = new Explanation();
/* 193 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 195 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + getQuery() + "")"");
/*     */ 
/*     */       
/* 198 */       Explanation queryExpl = new Explanation();
/* 199 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 201 */       Explanation boostExpl = new Explanation(MultiPhraseQuery.this.getBoost(), ""boost"");
/* 202 */       if (MultiPhraseQuery.this.getBoost() != 1.0F) {
/* 203 */         queryExpl.addDetail(boostExpl);
/*     */       }
/* 205 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 207 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 208 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 210 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 214 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 217 */       Explanation fieldExpl = new Explanation();
/* 218 */       fieldExpl.setDescription(""fieldWeight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 221 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 222 */       fieldExpl.addDetail(tfExpl);
/* 223 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 225 */       Explanation fieldNormExpl = new Explanation();
/* 226 */       byte[] fieldNorms = reader.norms(MultiPhraseQuery.this.field);
/* 227 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 229 */       fieldNormExpl.setValue(fieldNorm);
/* 230 */       fieldNormExpl.setDescription(""fieldNorm(field="" + MultiPhraseQuery.this.field + "", doc="" + doc + "")"");
/* 231 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 233 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 237 */       result.addDetail(fieldExpl);
/*     */ 
/*     */       
/* 240 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 242 */       if (queryExpl.getValue() == 1.0F) {
/* 243 */         return fieldExpl;
/*     */       }
/* 245 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) {
/* 250 */     if (this.termArrays.size() == 1) {
/* 251 */       Term[] terms = this.termArrays.get(0);
/* 252 */       BooleanQuery boq = new BooleanQuery(true);
/* 253 */       for (int i = 0; i < terms.length; i++) {
/* 254 */         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
/*     */       }
/* 256 */       boq.setBoost(getBoost());
/* 257 */       return boq;
/*     */     } 
/* 259 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 264 */   protected Weight createWeight(Searcher searcher) throws IOException { return new MultiPhraseWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String toString(String f) {
/* 269 */     StringBuffer buffer = new StringBuffer();
/* 270 */     if (!this.field.equals(f)) {
/* 271 */       buffer.append(this.field);
/* 272 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 275 */     buffer.append(""\"""");
/* 276 */     Iterator i = this.termArrays.iterator();
/* 277 */     while (i.hasNext()) {
/* 278 */       Term[] terms = i.next();
/* 279 */       if (terms.length > 1) {
/* 280 */         buffer.append(""("");
/* 281 */         for (int j = 0; j < terms.length; j++) {
/* 282 */           buffer.append(terms[j].text());
/* 283 */           if (j < terms.length - 1)
/* 284 */             buffer.append("" ""); 
/*     */         } 
/* 286 */         buffer.append("")"");
/*     */       } else {
/* 288 */         buffer.append(terms[0].text());
/*     */       } 
/* 290 */       if (i.hasNext())
/* 291 */         buffer.append("" ""); 
/*     */     } 
/* 293 */     buffer.append(""\"""");
/*     */     
/* 295 */     if (this.slop != 0) {
/* 296 */       buffer.append(""~"");
/* 297 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 300 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 302 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 308 */     if (!(o instanceof MultiPhraseQuery)) return false; 
/* 309 */     MultiPhraseQuery other = (MultiPhraseQuery)o;
/* 310 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.termArrays.equals(other.termArrays) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 318 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.termArrays.hashCode() ^ this.positions.hashCode() ^ 0x4AC65113; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\MultiPhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiSearcher
/*     */   extends Searcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   private static class CachedDfSource
/*     */     extends Searcher
/*     */   {
/*     */     private Map dfMap;
/*     */     private int maxDoc;
/*     */     
/*     */     public CachedDfSource(Map dfMap, int maxDoc) {
/*  44 */       this.dfMap = dfMap;
/*  45 */       this.maxDoc = maxDoc;
/*     */     }
/*     */     
/*     */     public int docFreq(Term term) {
/*     */       int df;
/*     */       try {
/*  51 */         df = ((Integer)this.dfMap.get(term)).intValue();
/*  52 */       } catch (NullPointerException e) {
/*  53 */         throw new IllegalArgumentException(""df for term "" + term.text() + "" not available"");
/*     */       } 
/*     */       
/*  56 */       return df;
/*     */     }
/*     */     
/*     */     public int[] docFreqs(Term[] terms) {
/*  60 */       int[] result = new int[terms.length];
/*  61 */       for (int i = 0; i < terms.length; i++) {
/*  62 */         result[i] = docFreq(terms[i]);
/*     */       }
/*  64 */       return result;
/*     */     }
/*     */ 
/*     */     
/*  68 */     public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  76 */     public Query rewrite(Query query) { return query; }
/*     */ 
/*     */ 
/*     */     
/*  80 */     public void close() { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  84 */     public Document doc(int i) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  88 */     public Explanation explain(Weight weight, int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  92 */     public void search(Weight weight, Filter filter, HitCollector results) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  96 */     public TopDocs search(Weight weight, Filter filter, int n) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 100 */     public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   private int maxDoc = 0;
/*     */ 
/*     */   
/*     */   public MultiSearcher(Searchable[] searchables) throws IOException {
/* 111 */     this.searchables = searchables;
/*     */     
/* 113 */     this.starts = new int[searchables.length + 1];
/* 114 */     for (int i = 0; i < searchables.length; i++) {
/* 115 */       this.starts[i] = this.maxDoc;
/* 116 */       this.maxDoc += searchables[i].maxDoc();
/*     */     } 
/* 118 */     this.starts[searchables.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 123 */   public Searchable[] getSearchables() { return this.searchables; }
/*     */ 
/*     */ 
/*     */   
/* 127 */   protected int[] getStarts() { return this.starts; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 132 */     for (int i = 0; i < this.searchables.length; i++)
/* 133 */       this.searchables[i].close(); 
/*     */   }
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 137 */     int docFreq = 0;
/* 138 */     for (int i = 0; i < this.searchables.length; i++)
/* 139 */       docFreq += this.searchables[i].docFreq(term); 
/* 140 */     return docFreq;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document doc(int n) throws IOException {
/* 145 */     int i = subSearcher(n);
/* 146 */     return this.searchables[i].doc(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int subSearcher(int n) {
/* 154 */     int lo = 0;
/* 155 */     int hi = this.searchables.length - 1;
/*     */     
/* 157 */     while (hi >= lo) {
/* 158 */       int mid = lo + hi >> 1;
/* 159 */       int midValue = this.starts[mid];
/* 160 */       if (n < midValue) {
/* 161 */         hi = mid - 1; continue;
/* 162 */       }  if (n > midValue) {
/* 163 */         lo = mid + 1; continue;
/*     */       } 
/* 165 */       while (mid + 1 < this.searchables.length && this.starts[mid + 1] == midValue) {
/* 166 */         mid++;
/*     */       }
/* 168 */       return mid;
/*     */     } 
/*     */     
/* 171 */     return hi;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public int subDoc(int n) { return n - this.starts[subSearcher(n)]; }
/*     */ 
/*     */ 
/*     */   
/* 181 */   public int maxDoc() throws IOException { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/* 187 */     HitQueue hq = new HitQueue(nDocs);
/* 188 */     int totalHits = 0;
/*     */     
/* 190 */     for (int i = 0; i < this.searchables.length; i++) {
/* 191 */       TopDocs docs = this.searchables[i].search(weight, filter, nDocs);
/* 192 */       totalHits += docs.totalHits;
/* 193 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 194 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 195 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 196 */         scoreDoc.doc += this.starts[i];
/* 197 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 202 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 203 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 204 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 206 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/* 208 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException {
/* 213 */     FieldDocSortedHitQueue hq = null;
/* 214 */     int totalHits = 0;
/*     */     
/* 216 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 218 */     for (int i = 0; i < this.searchables.length; i++) {
/* 219 */       TopFieldDocs docs = this.searchables[i].search(weight, filter, n, sort);
/*     */       
/* 221 */       if (hq == null) hq = new FieldDocSortedHitQueue(docs.fields, n); 
/* 222 */       totalHits += docs.totalHits;
/* 223 */       maxScore = Math.max(maxScore, docs.getMaxScore());
/* 224 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 225 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 226 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 227 */         scoreDoc.doc += this.starts[i];
/* 228 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 233 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 234 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 235 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 237 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 244 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 246 */       final int start = this.starts[i];
/*     */       
/* 248 */       this.searchables[i].search(weight, filter, new HitCollector() { private final HitCollector val$results;
/*     */             
/* 250 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */             private final int val$start;
/*     */             private final MultiSearcher this$0; }
/*     */         );
/*     */     } 
/*     */   }
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 258 */     Query[] queries = new Query[this.searchables.length];
/* 259 */     for (int i = 0; i < this.searchables.length; i++) {
/* 260 */       queries[i] = this.searchables[i].rewrite(original);
/*     */     }
/* 262 */     return queries[0].combine(queries);
/*     */   }
/*     */   
/*     */   public Explanation explain(Weight weight, int doc) throws IOException {
/* 266 */     int i = subSearcher(doc);
/* 267 */     return this.searchables[i].explain(weight, doc - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Query original) throws IOException {
/* 287 */     Query rewrittenQuery = rewrite(original);
/*     */ 
/*     */     
/* 290 */     Set terms = new HashSet();
/* 291 */     rewrittenQuery.extractTerms(terms);
/*     */ 
/*     */     
/* 294 */     Term[] allTermsArray = new Term[terms.size()];
/* 295 */     terms.toArray((Object[])allTermsArray);
/* 296 */     int[] aggregatedDfs = new int[terms.size()];
/* 297 */     for (int i = 0; i < this.searchables.length; i++) {
/* 298 */       int[] dfs = this.searchables[i].docFreqs(allTermsArray);
/* 299 */       for (int j = 0; j < aggregatedDfs.length; j++) {
/* 300 */         aggregatedDfs[j] = aggregatedDfs[j] + dfs[j];
/*     */       }
/*     */     } 
/*     */     
/* 304 */     HashMap dfMap = new HashMap();
/* 305 */     for (int i = 0; i < allTermsArray.length; i++) {
/* 306 */       dfMap.put(allTermsArray[i], new Integer(aggregatedDfs[i]));
/*     */     }
/*     */ 
/*     */     
/* 310 */     int numDocs = maxDoc();
/* 311 */     CachedDfSource cacheSim = new CachedDfSource(dfMap, numDocs);
/*     */     
/* 313 */     return rewrittenQuery.weight(cacheSim);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\MultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcherThread,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiSearcherThread
/*     */   extends Thread
/*     */ {
/*     */   private Searchable searchable;
/*     */   private Weight weight;
/*     */   private Filter filter;
/*     */   private int nDocs;
/*     */   private TopDocs docs;
/*     */   private int i;
/*     */   private PriorityQueue hq;
/*     */   private int[] starts;
/*     */   private IOException ioe;
/*     */   private Sort sort;
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, HitQueue hq, int i, int[] starts, String name) {
/* 216 */     super(name);
/* 217 */     this.searchable = searchable;
/* 218 */     this.weight = weight;
/* 219 */     this.filter = filter;
/* 220 */     this.nDocs = nDocs;
/* 221 */     this.hq = hq;
/* 222 */     this.i = i;
/* 223 */     this.starts = starts;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, FieldDocSortedHitQueue hq, Sort sort, int i, int[] starts, String name) {
/* 236 */     super(name);
/* 237 */     this.searchable = searchable;
/* 238 */     this.weight = weight;
/* 239 */     this.filter = filter;
/* 240 */     this.nDocs = nDocs;
/* 241 */     this.hq = hq;
/* 242 */     this.i = i;
/* 243 */     this.starts = starts;
/* 244 */     this.sort = sort;
/*     */   }
/*     */   
/*     */   public void run() {
/*     */     try {
/* 249 */       this.docs = (this.sort == null) ? this.searchable.search(this.weight, this.filter, this.nDocs) : this.searchable.search(this.weight, this.filter, this.nDocs, this.sort);
/*     */ 
/*     */     
/*     */     }
/* 253 */     catch (IOException ioe) {
/* 254 */       this.ioe = ioe;
/*     */     } 
/* 256 */     if (this.ioe == null) {
/*     */ 
/*     */ 
/*     */       
/* 260 */       if (this.sort != null) {
/* 261 */         ((FieldDocSortedHitQueue)this.hq).setFields(((TopFieldDocs)this.docs).fields);
/*     */       }
/* 263 */       ScoreDoc[] scoreDocs = this.docs.scoreDocs;
/* 264 */       int j = 0;
/* 265 */       for (; j < scoreDocs.length; 
/* 266 */         j++) {
/* 267 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 268 */         scoreDoc.doc += this.starts[this.i];
/*     */         
/* 270 */         synchronized (this.hq) {
/* 271 */           if (!this.hq.insert(scoreDoc)) {
/*     */             break;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 279 */   public int hits() { return this.docs.totalHits; }
/*     */ 
/*     */ 
/*     */   
/* 283 */   public float getMaxScore() { return this.docs.getMaxScore(); }
/*     */ 
/*     */ 
/*     */   
/* 287 */   public IOException getIOException() { return this.ioe; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\MultiSearcherThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiTermQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class MultiTermQuery
/*    */   extends Query
/*    */ {
/*    */   private Term term;
/*    */   
/* 43 */   public MultiTermQuery(Term term) { this.term = term; }
/*    */ 
/*    */ 
/*    */   
/* 47 */   public Term getTerm() { return this.term; }
/*    */ 
/*    */   
/*    */   protected abstract FilteredTermEnum getEnum(IndexReader paramIndexReader) throws IOException;
/*    */ 
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 54 */     FilteredTermEnum enumerator = getEnum(reader);
/* 55 */     BooleanQuery query = new BooleanQuery(true);
/*    */     try {
/*    */       do {
/* 58 */         Term t = enumerator.term();
/* 59 */         if (t == null)
/* 60 */           continue;  TermQuery tq = new TermQuery(t);
/* 61 */         tq.setBoost(getBoost() * enumerator.difference());
/* 62 */         query.add(tq, BooleanClause.Occur.SHOULD);
/*    */       }
/* 64 */       while (enumerator.next());
/*    */     } finally {
/* 66 */       enumerator.close();
/*    */     } 
/* 68 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 73 */     StringBuffer buffer = new StringBuffer();
/* 74 */     if (!this.term.field().equals(field)) {
/* 75 */       buffer.append(this.term.field());
/* 76 */       buffer.append("":"");
/*    */     } 
/* 78 */     buffer.append(this.term.text());
/* 79 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 80 */     return buffer.toString();
/*    */   }
/*    */   
/*    */   public boolean equals(Object o) {
/* 84 */     if (this == o) return true; 
/* 85 */     if (!(o instanceof MultiTermQuery)) return false;
/*    */     
/* 87 */     MultiTermQuery multiTermQuery = (MultiTermQuery)o;
/*    */     
/* 89 */     if (!this.term.equals(multiTermQuery.term)) return false;
/*    */     
/* 91 */     return (getBoost() == multiTermQuery.getBoost());
/*    */   }
/*    */ 
/*    */   
/* 95 */   public int hashCode() { return this.term.hashCode() + Float.floatToRawIntBits(getBoost()); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\MultiTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.NonMatchingScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class NonMatchingScorer
/*    */   extends Scorer
/*    */ {
/* 23 */   public NonMatchingScorer() { super(null); }
/*    */   
/* 25 */   public int doc() { throw new UnsupportedOperationException(); }
/*    */   
/* 27 */   public boolean next() throws IOException { return false; }
/*    */   
/* 29 */   public float score() { throw new UnsupportedOperationException(); }
/*    */   
/* 31 */   public boolean skipTo(int target) { return false; }
/*    */   
/*    */   public Explanation explain(int doc) {
/* 34 */     Explanation e = new Explanation();
/* 35 */     e.setDescription(""No document matches."");
/* 36 */     return e;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\NonMatchingScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ParallelMultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelMultiSearcher
/*     */   extends MultiSearcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   public ParallelMultiSearcher(Searchable[] searchables) throws IOException {
/*  36 */     super(searchables);
/*  37 */     this.searchables = searchables;
/*  38 */     this.starts = getStarts();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  45 */   public int docFreq(Term term) throws IOException { return super.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/*  55 */     HitQueue hq = new HitQueue(nDocs);
/*  56 */     int totalHits = 0;
/*  57 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/*     */     
/*  59 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/*  61 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  71 */       msta[i].start();
/*     */     } 
/*     */     
/*  74 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/*  76 */         msta[i].join();
/*  77 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/*  80 */       IOException ioe = msta[i].getIOException();
/*  81 */       if (ioe == null) {
/*  82 */         totalHits += msta[i].hits();
/*     */       } else {
/*     */         
/*  85 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/*  89 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/*  90 */     for (int i = hq.size() - 1; i >= 0; i--) {
/*  91 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/*  93 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/*  95 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 106 */     FieldDocSortedHitQueue hq = new FieldDocSortedHitQueue(null, nDocs);
/* 107 */     int totalHits = 0;
/* 108 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/* 109 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 111 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, sort, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 122 */       msta[i].start();
/*     */     } 
/*     */     
/* 125 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 127 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/* 129 */         msta[i].join();
/* 130 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/* 133 */       IOException ioe = msta[i].getIOException();
/* 134 */       if (ioe == null) {
/* 135 */         totalHits += msta[i].hits();
/* 136 */         maxScore = Math.max(maxScore, msta[i].getMaxScore());
/*     */       } else {
/*     */         
/* 139 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/* 143 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 144 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 145 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 147 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 168 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 170 */       final int start = this.starts[i];
/*     */       
/* 172 */       this.searchables[i].search(weight, filter, new HitCollector()
/*     */           {
/* 174 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */ 
/*     */             
/*     */             private final HitCollector val$results;
/*     */             
/*     */             private final int val$start;
/*     */             
/*     */             private final ParallelMultiSearcher this$0;
/*     */           });
/*     */     } 
/*     */   }
/*     */   
/* 186 */   public Query rewrite(Query original) throws IOException { return super.rewrite(original); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ParallelMultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhrasePositions,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhrasePositions
/*    */ {
/*    */   int doc;
/*    */   int position;
/*    */   int count;
/*    */   int offset;
/*    */   TermPositions tp;
/*    */   PhrasePositions next;
/*    */   
/*    */   PhrasePositions(TermPositions t, int o) {
/* 31 */     this.tp = t;
/* 32 */     this.offset = o;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 36 */     if (!this.tp.next()) {
/* 37 */       this.tp.close();
/* 38 */       this.doc = Integer.MAX_VALUE;
/* 39 */       return false;
/*    */     } 
/* 41 */     this.doc = this.tp.doc();
/* 42 */     this.position = 0;
/* 43 */     return true;
/*    */   }
/*    */   
/*    */   final boolean skipTo(int target) throws IOException {
/* 47 */     if (!this.tp.skipTo(target)) {
/* 48 */       this.tp.close();
/* 49 */       this.doc = Integer.MAX_VALUE;
/* 50 */       return false;
/*    */     } 
/* 52 */     this.doc = this.tp.doc();
/* 53 */     this.position = 0;
/* 54 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   final void firstPosition() throws IOException {
/* 59 */     this.count = this.tp.freq();
/* 60 */     nextPosition();
/*    */   }
/*    */   
/*    */   final boolean nextPosition() throws IOException {
/* 64 */     if (this.count-- > 0) {
/* 65 */       this.position = this.tp.nextPosition() - this.offset;
/* 66 */       return true;
/*    */     } 
/* 68 */     return false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\PhrasePositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  35 */   private Vector terms = new Vector();
/*  36 */   private Vector positions = new Vector();
/*  37 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public void setSlop(int s) { this.slop = s; }
/*     */   
/*  58 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term) {
/*  65 */     int position = 0;
/*  66 */     if (this.positions.size() > 0) {
/*  67 */       position = ((Integer)this.positions.lastElement()).intValue() + 1;
/*     */     }
/*  69 */     add(term, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term, int position) {
/*  82 */     if (this.terms.size() == 0) {
/*  83 */       this.field = term.field();
/*  84 */     } else if (term.field() != this.field) {
/*  85 */       throw new IllegalArgumentException(""All phrase terms must be in the same field: "" + term);
/*     */     } 
/*  87 */     this.terms.addElement(term);
/*  88 */     this.positions.addElement(new Integer(position));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  93 */   public Term[] getTerms() { return (Term[])this.terms.toArray((Object[])new Term[0]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 100 */     int[] result = new int[this.positions.size()];
/* 101 */     for (int i = 0; i < this.positions.size(); i++)
/* 102 */       result[i] = ((Integer)this.positions.elementAt(i)).intValue(); 
/* 103 */     return result;
/*     */   }
/*     */   
/*     */   private class PhraseWeight implements Weight {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final PhraseQuery this$0;
/*     */     
/*     */     public PhraseWeight(Searcher searcher) throws IOException {
/* 115 */       this.similarity = PhraseQuery.this.getSimilarity(searcher);
/*     */       
/* 117 */       this.idf = this.similarity.idf(PhraseQuery.this.terms, searcher);
/*     */     }
/*     */     
/* 120 */     public String toString() { return ""weight("" + PhraseQuery.this + "")""; }
/*     */     
/* 122 */     public Query getQuery() { return PhraseQuery.this; }
/* 123 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 126 */       this.queryWeight = this.idf * PhraseQuery.this.getBoost();
/* 127 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 131 */       this.queryNorm = queryNorm;
/* 132 */       this.queryWeight *= queryNorm;
/* 133 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 137 */       if (PhraseQuery.this.terms.size() == 0) {
/* 138 */         return null;
/*     */       }
/* 140 */       TermPositions[] tps = new TermPositions[PhraseQuery.this.terms.size()];
/* 141 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 142 */         TermPositions p = reader.termPositions(PhraseQuery.this.terms.elementAt(i));
/* 143 */         if (p == null)
/* 144 */           return null; 
/* 145 */         tps[i] = p;
/*     */       } 
/*     */       
/* 148 */       if (PhraseQuery.this.slop == 0) {
/* 149 */         return new ExactPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, reader.norms(PhraseQuery.this.field));
/*     */       }
/*     */       
/* 152 */       return new SloppyPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, PhraseQuery.this.slop, reader.norms(PhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 161 */       Explanation result = new Explanation();
/* 162 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 164 */       StringBuffer docFreqs = new StringBuffer();
/* 165 */       StringBuffer query = new StringBuffer();
/* 166 */       query.append('""');
/* 167 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 168 */         if (i != 0) {
/* 169 */           docFreqs.append("" "");
/* 170 */           query.append("" "");
/*     */         } 
/*     */         
/* 173 */         Term term = PhraseQuery.this.terms.elementAt(i);
/*     */         
/* 175 */         docFreqs.append(term.text());
/* 176 */         docFreqs.append(""="");
/* 177 */         docFreqs.append(reader.docFreq(term));
/*     */         
/* 179 */         query.append(term.text());
/*     */       } 
/* 181 */       query.append('""');
/*     */       
/* 183 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + PhraseQuery.this.field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */       
/* 187 */       Explanation queryExpl = new Explanation();
/* 188 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 190 */       Explanation boostExpl = new Explanation(PhraseQuery.this.getBoost(), ""boost"");
/* 191 */       if (PhraseQuery.this.getBoost() != 1.0F)
/* 192 */         queryExpl.addDetail(boostExpl); 
/* 193 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 195 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 196 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 198 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 202 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 205 */       Explanation fieldExpl = new Explanation();
/* 206 */       fieldExpl.setDescription(""fieldWeight("" + PhraseQuery.this.field + "":"" + query + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 209 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 210 */       fieldExpl.addDetail(tfExpl);
/* 211 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 213 */       Explanation fieldNormExpl = new Explanation();
/* 214 */       byte[] fieldNorms = reader.norms(PhraseQuery.this.field);
/* 215 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 217 */       fieldNormExpl.setValue(fieldNorm);
/* 218 */       fieldNormExpl.setDescription(""fieldNorm(field="" + PhraseQuery.this.field + "", doc="" + doc + "")"");
/* 219 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 221 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 225 */       result.addDetail(fieldExpl);
/*     */ 
/*     */       
/* 228 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 230 */       if (queryExpl.getValue() == 1.0F) {
/* 231 */         return fieldExpl;
/*     */       }
/* 233 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/* 238 */     if (this.terms.size() == 1) {
/* 239 */       Term term = this.terms.elementAt(0);
/* 240 */       Query termQuery = new TermQuery(term);
/* 241 */       termQuery.setBoost(getBoost());
/* 242 */       return termQuery.createWeight(searcher);
/*     */     } 
/* 244 */     return new PhraseWeight(searcher);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 251 */   public void extractTerms(Set queryTerms) { queryTerms.addAll(this.terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String f) {
/* 256 */     StringBuffer buffer = new StringBuffer();
/* 257 */     if (!this.field.equals(f)) {
/* 258 */       buffer.append(this.field);
/* 259 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 262 */     buffer.append(""\"""");
/* 263 */     for (int i = 0; i < this.terms.size(); i++) {
/* 264 */       buffer.append(((Term)this.terms.elementAt(i)).text());
/* 265 */       if (i != this.terms.size() - 1)
/* 266 */         buffer.append("" ""); 
/*     */     } 
/* 268 */     buffer.append(""\"""");
/*     */     
/* 270 */     if (this.slop != 0) {
/* 271 */       buffer.append(""~"");
/* 272 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 275 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 277 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 282 */     if (!(o instanceof PhraseQuery))
/* 283 */       return false; 
/* 284 */     PhraseQuery other = (PhraseQuery)o;
/* 285 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.terms.equals(other.terms) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 293 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.terms.hashCode() ^ this.positions.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\PhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhraseQueue
/*    */   extends PriorityQueue
/*    */ {
/* 23 */   PhraseQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object o1, Object o2) {
/* 27 */     PhrasePositions pp1 = (PhrasePositions)o1;
/* 28 */     PhrasePositions pp2 = (PhrasePositions)o2;
/* 29 */     if (pp1.doc == pp2.doc) {
/* 30 */       return (pp1.position < pp2.position);
/*    */     }
/* 32 */     return (pp1.doc < pp2.doc);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\PhraseQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class PhraseScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   protected byte[] norms;
/*     */   protected float value;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   protected PhraseQueue pq;
/*     */   protected PhrasePositions first;
/*     */   protected PhrasePositions last;
/*     */   private float freq;
/*     */   
/*     */   PhraseScorer(Weight weight, TermPositions[] tps, int[] positions, Similarity similarity, byte[] norms) {
/*  38 */     super(similarity);
/*  39 */     this.norms = norms;
/*  40 */     this.weight = weight;
/*  41 */     this.value = weight.getValue();
/*     */ 
/*     */     
/*  44 */     for (int i = 0; i < tps.length; i++) {
/*  45 */       PhrasePositions pp = new PhrasePositions(tps[i], positions[i]);
/*  46 */       if (this.last != null) {
/*  47 */         this.last.next = pp;
/*     */       } else {
/*  49 */         this.first = pp;
/*  50 */       }  this.last = pp;
/*     */     } 
/*     */     
/*  53 */     this.pq = new PhraseQueue(tps.length);
/*     */   }
/*     */ 
/*     */   
/*  57 */   public int doc() { return this.first.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*  60 */     if (this.firstTime) {
/*  61 */       init();
/*  62 */       this.firstTime = false;
/*  63 */     } else if (this.more) {
/*  64 */       this.more = this.last.next();
/*     */     } 
/*  66 */     return doNext();
/*     */   }
/*     */ 
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  71 */     while (this.more) {
/*  72 */       while (this.more && this.first.doc < this.last.doc) {
/*  73 */         this.more = this.first.skipTo(this.last.doc);
/*  74 */         firstToLast();
/*     */       } 
/*     */       
/*  77 */       if (this.more) {
/*     */         
/*  79 */         this.freq = phraseFreq();
/*  80 */         if (this.freq == 0.0F) {
/*  81 */           this.more = this.last.next(); continue;
/*     */         } 
/*  83 */         return true;
/*     */       } 
/*     */     } 
/*  86 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/*  91 */     float raw = getSimilarity().tf(this.freq) * this.value;
/*  92 */     return raw * Similarity.decodeNorm(this.norms[this.first.doc]);
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  96 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next) {
/*  97 */       this.more = pp.skipTo(target);
/*     */     }
/*  99 */     if (this.more)
/* 100 */       sort(); 
/* 101 */     return doNext();
/*     */   }
/*     */   
/*     */   protected abstract float phraseFreq() throws IOException;
/*     */   
/*     */   private void init() throws IOException {
/* 107 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next)
/* 108 */       this.more = pp.next(); 
/* 109 */     if (this.more)
/* 110 */       sort(); 
/*     */   }
/*     */   
/*     */   private void sort() {
/* 114 */     this.pq.clear();
/* 115 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next)
/* 116 */       this.pq.put(pp); 
/* 117 */     pqToList();
/*     */   }
/*     */   
/*     */   protected final void pqToList() {
/* 121 */     this.last = this.first = null;
/* 122 */     while (this.pq.top() != null) {
/* 123 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/* 124 */       if (this.last != null) {
/* 125 */         this.last.next = pp;
/*     */       } else {
/* 127 */         this.first = pp;
/* 128 */       }  this.last = pp;
/* 129 */       pp.next = null;
/*     */     } 
/*     */   }
/*     */   
/*     */   protected final void firstToLast() {
/* 134 */     this.last.next = this.first;
/* 135 */     this.last = this.first;
/* 136 */     this.first = this.first.next;
/* 137 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 141 */     Explanation tfExplanation = new Explanation();
/*     */     
/* 143 */     while (next() && doc() < doc);
/*     */     
/* 145 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/* 146 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/* 147 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 149 */     return tfExplanation;
/*     */   }
/*     */   
/* 152 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\PhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PrefixQuery
/*    */   extends Query
/*    */ {
/*    */   private Term prefix;
/*    */   
/* 33 */   public PrefixQuery(Term prefix) { this.prefix = prefix; }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public Term getPrefix() { return this.prefix; }
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 40 */     BooleanQuery query = new BooleanQuery(true);
/* 41 */     TermEnum enumerator = reader.terms(this.prefix);
/*    */     
/* 43 */     try { String prefixText = this.prefix.text();
/* 44 */       String prefixField = this.prefix.field();
/*    */       while (true)
/* 46 */       { Term term = enumerator.term();
/* 47 */         if (term != null && term.text().startsWith(prefixText) && term.field() == prefixField)
/*    */         
/*    */         { 
/* 50 */           TermQuery tq = new TermQuery(term);
/* 51 */           tq.setBoost(getBoost());
/* 52 */           query.add(tq, BooleanClause.Occur.SHOULD);
/*    */ 
/*    */ 
/*    */ 
/*    */           
/* 57 */           if (!enumerator.next())
/*    */             break;  continue; }  break; }  }
/* 59 */     finally { enumerator.close(); }
/*    */     
/* 61 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 66 */     StringBuffer buffer = new StringBuffer();
/* 67 */     if (!this.prefix.field().equals(field)) {
/* 68 */       buffer.append(this.prefix.field());
/* 69 */       buffer.append("":"");
/*    */     } 
/* 71 */     buffer.append(this.prefix.text());
/* 72 */     buffer.append('*');
/* 73 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 74 */     return buffer.toString();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 79 */     if (!(o instanceof PrefixQuery))
/* 80 */       return false; 
/* 81 */     PrefixQuery other = (PrefixQuery)o;
/* 82 */     return (getBoost() == other.getBoost() && this.prefix.equals(other.prefix));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 88 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.prefix.hashCode() ^ 0x6634D93C; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\PrefixQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Query,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Query
/*     */   implements Serializable, Cloneable
/*     */ {
/*  47 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  53 */   public void setBoost(float b) { this.boost = b; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  59 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract String toString(String paramString);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   public String toString() { return toString(""""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   protected Weight createWeight(Searcher searcher) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Weight weight(Searcher searcher) throws IOException {
/*  93 */     Query query = searcher.rewrite(this);
/*  94 */     Weight weight = query.createWeight(searcher);
/*  95 */     float sum = weight.sumOfSquaredWeights();
/*  96 */     float norm = getSimilarity(searcher).queryNorm(sum);
/*  97 */     weight.normalize(norm);
/*  98 */     return weight;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query combine(Query[] queries) {
/* 121 */     HashSet uniques = new HashSet();
/* 122 */     for (int i = 0; i < queries.length; i++) {
/* 123 */       Query query = queries[i];
/* 124 */       BooleanClause[] clauses = null;
/*     */       
/* 126 */       boolean splittable = query instanceof BooleanQuery;
/* 127 */       if (splittable) {
/* 128 */         BooleanQuery bq = (BooleanQuery)query;
/* 129 */         splittable = bq.isCoordDisabled();
/* 130 */         clauses = bq.getClauses();
/* 131 */         for (int j = 0; splittable && j < clauses.length; j++) {
/* 132 */           splittable = (clauses[j].getOccur() == BooleanClause.Occur.SHOULD);
/*     */         }
/*     */       } 
/* 135 */       if (splittable) {
/* 136 */         for (int j = 0; j < clauses.length; j++) {
/* 137 */           uniques.add(clauses[j].getQuery());
/*     */         }
/*     */       } else {
/* 140 */         uniques.add(query);
/*     */       } 
/*     */     } 
/*     */     
/* 144 */     if (uniques.size() == 1) {
/* 145 */       return uniques.iterator().next();
/*     */     }
/* 147 */     Iterator it = uniques.iterator();
/* 148 */     BooleanQuery result = new BooleanQuery(true);
/* 149 */     while (it.hasNext())
/* 150 */       result.add(it.next(), BooleanClause.Occur.SHOULD); 
/* 151 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 162 */   public void extractTerms(Set terms) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query mergeBooleanQueries(Query[] queries) {
/* 172 */     HashSet allClauses = new HashSet();
/* 173 */     for (int i = 0; i < queries.length; i++) {
/* 174 */       BooleanClause[] clauses = ((BooleanQuery)queries[i]).getClauses();
/* 175 */       for (int j = 0; j < clauses.length; j++) {
/* 176 */         allClauses.add(clauses[j]);
/*     */       }
/*     */     } 
/*     */     
/* 180 */     boolean coordDisabled = (queries.length == 0) ? false : ((BooleanQuery)queries[0]).isCoordDisabled();
/*     */     
/* 182 */     BooleanQuery result = new BooleanQuery(coordDisabled);
/* 183 */     Iterator i = allClauses.iterator();
/* 184 */     while (i.hasNext()) {
/* 185 */       result.add(i.next());
/*     */     }
/* 187 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 195 */   public Similarity getSimilarity(Searcher searcher) { return searcher.getSimilarity(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 201 */       return super.clone();
/* 202 */     } catch (CloneNotSupportedException e) {
/* 203 */       throw new RuntimeException(""Clone not supported: "" + e.getMessage());
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Query.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import java.util.WeakHashMap;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueryFilter
/*    */   extends Filter
/*    */ {
/*    */   private Query query;
/* 38 */   private transient WeakHashMap cache = null;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public QueryFilter(Query query) { this.query = query; }
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 49 */     if (this.cache == null) {
/* 50 */       this.cache = new WeakHashMap();
/*    */     }
/*    */     
/* 53 */     synchronized (this.cache) {
/* 54 */       BitSet cached = (BitSet)this.cache.get(reader);
/* 55 */       if (cached != null) {
/* 56 */         return cached;
/*    */       }
/*    */     } 
/*    */     
/* 60 */     final BitSet bits = new BitSet(reader.maxDoc());
/*    */     
/* 62 */     (new IndexSearcher(reader)).search(this.query, new HitCollector()
/*    */         {
/* 64 */           public final void collect(int doc, float score) { bits.set(doc); }
/*    */           private final BitSet val$bits;
/*    */           private final QueryFilter this$0;
/*    */         });
/* 68 */     synchronized (this.cache) {
/* 69 */       this.cache.put(reader, bits);
/*    */     } 
/*    */     
/* 72 */     return bits;
/*    */   }
/*    */ 
/*    */   
/* 76 */   public String toString() { return ""QueryFilter("" + this.query + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 80 */     if (!(o instanceof QueryFilter)) return false; 
/* 81 */     return this.query.equals(((QueryFilter)o).query);
/*    */   }
/*    */ 
/*    */   
/* 85 */   public int hashCode() { return this.query.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\QueryFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryTermVector,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.StringReader;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Arrays;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.index.TermFreqVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class QueryTermVector
/*     */   implements TermFreqVector
/*     */ {
/*  33 */   private String[] terms = new String[0];
/*  34 */   private int[] termFreqs = new int[0];
/*     */   
/*  36 */   public String getField() { return null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  44 */   public QueryTermVector(String[] queryTerms) { processTerms(queryTerms); }
/*     */ 
/*     */   
/*     */   public QueryTermVector(String queryString, Analyzer analyzer) {
/*  48 */     if (analyzer != null) {
/*     */       
/*  50 */       TokenStream stream = analyzer.tokenStream("""", new StringReader(queryString));
/*  51 */       if (stream != null) {
/*     */         
/*  53 */         Token next = null;
/*  54 */         List terms = new ArrayList();
/*     */         try {
/*  56 */           while ((next = stream.next()) != null)
/*     */           {
/*  58 */             terms.add(next.termText());
/*     */           }
/*  60 */           processTerms(terms.toArray(new String[terms.size()]));
/*  61 */         } catch (IOException e) {}
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void processTerms(String[] queryTerms) {
/*  68 */     if (queryTerms != null) {
/*  69 */       Arrays.sort((Object[])queryTerms);
/*  70 */       Map tmpSet = new HashMap(queryTerms.length);
/*     */       
/*  72 */       List tmpList = new ArrayList(queryTerms.length);
/*  73 */       List tmpFreqs = new ArrayList(queryTerms.length);
/*  74 */       int j = 0;
/*  75 */       for (int i = 0; i < queryTerms.length; i++) {
/*  76 */         String term = queryTerms[i];
/*  77 */         Integer position = (Integer)tmpSet.get(term);
/*  78 */         if (position == null) {
/*  79 */           tmpSet.put(term, new Integer(j++));
/*  80 */           tmpList.add(term);
/*  81 */           tmpFreqs.add(new Integer(1));
/*     */         } else {
/*     */           
/*  84 */           Integer integer = tmpFreqs.get(position.intValue());
/*  85 */           tmpFreqs.set(position.intValue(), new Integer(integer.intValue() + 1));
/*     */         } 
/*     */       } 
/*  88 */       this.terms = tmpList.toArray(this.terms);
/*     */       
/*  90 */       this.termFreqs = new int[tmpFreqs.size()];
/*  91 */       int i = 0;
/*  92 */       for (Iterator iter = tmpFreqs.iterator(); iter.hasNext(); ) {
/*  93 */         Integer integer = iter.next();
/*  94 */         this.termFreqs[i++] = integer.intValue();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public final String toString() {
/* 100 */     StringBuffer sb = new StringBuffer();
/* 101 */     sb.append('{');
/* 102 */     for (int i = 0; i < this.terms.length; i++) {
/* 103 */       if (i > 0) sb.append("", ""); 
/* 104 */       sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*     */     } 
/* 106 */     sb.append('}');
/* 107 */     return sb.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 112 */   public int size() { return this.terms.length; }
/*     */ 
/*     */ 
/*     */   
/* 116 */   public String[] getTerms() { return this.terms; }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*     */ 
/*     */   
/*     */   public int indexOf(String term) {
/* 124 */     int res = Arrays.binarySearch((Object[])this.terms, term);
/* 125 */     return (res >= 0) ? res : -1;
/*     */   }
/*     */   
/*     */   public int[] indexesOf(String[] terms, int start, int len) {
/* 129 */     int[] res = new int[len];
/*     */     
/* 131 */     for (int i = 0; i < len; i++) {
/* 132 */       res[i] = indexOf(terms[i]);
/*     */     }
/* 134 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\QueryTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeFilter,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeFilter
/*     */   extends Filter
/*     */ {
/*     */   private String fieldName;
/*     */   private String lowerTerm;
/*     */   private String upperTerm;
/*     */   private boolean includeLower;
/*     */   private boolean includeUpper;
/*     */   
/*     */   public RangeFilter(String fieldName, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
/*  56 */     this.fieldName = fieldName;
/*  57 */     this.lowerTerm = lowerTerm;
/*  58 */     this.upperTerm = upperTerm;
/*  59 */     this.includeLower = includeLower;
/*  60 */     this.includeUpper = includeUpper;
/*     */     
/*  62 */     if (null == lowerTerm && null == upperTerm) {
/*  63 */       throw new IllegalArgumentException(""At least one value must be non-null"");
/*     */     }
/*     */     
/*  66 */     if (includeLower && null == lowerTerm) {
/*  67 */       throw new IllegalArgumentException(""The lower bound must be non-null to be inclusive"");
/*     */     }
/*     */     
/*  70 */     if (includeUpper && null == upperTerm) {
/*  71 */       throw new IllegalArgumentException(""The upper bound must be non-null to be inclusive"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  81 */   public static RangeFilter Less(String fieldName, String upperTerm) { return new RangeFilter(fieldName, null, upperTerm, false, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  89 */   public static RangeFilter More(String fieldName, String lowerTerm) { return new RangeFilter(fieldName, lowerTerm, null, true, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitSet bits(IndexReader reader) throws IOException {
/*  98 */     BitSet bits = new BitSet(reader.maxDoc());
/*  99 */     TermEnum enumerator = (null != this.lowerTerm) ? reader.terms(new Term(this.fieldName, this.lowerTerm)) : reader.terms(new Term(this.fieldName, """"));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 106 */       if (enumerator.term() == null) {
/* 107 */         return bits;
/*     */       }
/*     */       
/* 110 */       boolean checkLower = false;
/* 111 */       if (!this.includeLower) {
/* 112 */         checkLower = true;
/*     */       }
/* 114 */       TermDocs termDocs = reader.termDocs();
/*     */ 
/*     */       
/*     */       try { while (true) {
/* 118 */           Term term = enumerator.term();
/* 119 */           if (term != null && term.field().equals(this.fieldName))
/* 120 */           { if (!checkLower || null == this.lowerTerm || term.text().compareTo(this.lowerTerm) > 0) {
/* 121 */               checkLower = false;
/* 122 */               if (this.upperTerm != null) {
/* 123 */                 int compare = this.upperTerm.compareTo(term.text());
/*     */ 
/*     */                 
/* 126 */                 if (compare < 0 || (!this.includeUpper && compare == 0)) {
/*     */                   break;
/*     */                 }
/*     */               } 
/*     */ 
/*     */ 
/*     */               
/* 133 */               termDocs.seek(enumerator.term());
/* 134 */               while (termDocs.next()) {
/* 135 */                 bits.set(termDocs.doc());
/*     */               }
/*     */             } 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 142 */             if (!enumerator.next())
/*     */               break;  continue; }  break;
/*     */         }  }
/* 145 */       finally { termDocs.close(); }
/*     */     
/*     */     } finally {
/* 148 */       enumerator.close();
/*     */     } 
/*     */     
/* 151 */     return bits;
/*     */   }
/*     */   
/*     */   public String toString() {
/* 155 */     StringBuffer buffer = new StringBuffer();
/* 156 */     buffer.append(this.fieldName);
/* 157 */     buffer.append("":"");
/* 158 */     buffer.append(this.includeLower ? ""["" : ""{"");
/* 159 */     if (null != this.lowerTerm) {
/* 160 */       buffer.append(this.lowerTerm);
/*     */     }
/* 162 */     buffer.append(""-"");
/* 163 */     if (null != this.upperTerm) {
/* 164 */       buffer.append(this.upperTerm);
/*     */     }
/* 166 */     buffer.append(this.includeUpper ? ""]"" : ""}"");
/* 167 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 172 */     if (this == o) return true; 
/* 173 */     if (!(o instanceof RangeFilter)) return false; 
/* 174 */     RangeFilter other = (RangeFilter)o;
/*     */     
/* 176 */     if (!this.fieldName.equals(other.fieldName) || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper)
/*     */     {
/*     */       
/* 179 */       return false; } 
/* 180 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 181 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 182 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 187 */     int h = this.fieldName.hashCode();
/* 188 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : -1225987966;
/* 189 */     h = h << 1 | h >>> 31;
/* 190 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : -1849769278;
/* 191 */     h ^= (this.includeLower ? -729499341 : 0) ^ (this.includeUpper ? 1793336236 : 0);
/*     */     
/* 193 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\RangeFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeQuery
/*     */   extends Query
/*     */ {
/*     */   private Term lowerTerm;
/*     */   private Term upperTerm;
/*     */   private boolean inclusive;
/*     */   
/*     */   public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
/*  46 */     if (lowerTerm == null && upperTerm == null)
/*     */     {
/*  48 */       throw new IllegalArgumentException(""At least one term must be non-null"");
/*     */     }
/*  50 */     if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
/*     */     {
/*  52 */       throw new IllegalArgumentException(""Both terms must be for the same field"");
/*     */     }
/*     */ 
/*     */     
/*  56 */     if (lowerTerm != null) {
/*  57 */       this.lowerTerm = lowerTerm;
/*     */     } else {
/*     */       
/*  60 */       this.lowerTerm = new Term(upperTerm.field(), """");
/*     */     } 
/*     */     
/*  63 */     this.upperTerm = upperTerm;
/*  64 */     this.inclusive = inclusive;
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  69 */     BooleanQuery query = new BooleanQuery(true);
/*  70 */     TermEnum enumerator = reader.terms(this.lowerTerm);
/*     */ 
/*     */ 
/*     */     
/*  74 */     try { boolean checkLower = false;
/*  75 */       if (!this.inclusive) {
/*  76 */         checkLower = true;
/*     */       }
/*  78 */       String testField = getField();
/*     */       
/*     */       while (true) {
/*  81 */         Term term = enumerator.term();
/*  82 */         if (term != null && term.field() == testField)
/*  83 */         { if (!checkLower || term.text().compareTo(this.lowerTerm.text()) > 0) {
/*  84 */             checkLower = false;
/*  85 */             if (this.upperTerm != null) {
/*  86 */               int compare = this.upperTerm.text().compareTo(term.text());
/*     */ 
/*     */               
/*  89 */               if (compare < 0 || (!this.inclusive && compare == 0))
/*     */                 break; 
/*     */             } 
/*  92 */             TermQuery tq = new TermQuery(term);
/*  93 */             tq.setBoost(getBoost());
/*  94 */             query.add(tq, BooleanClause.Occur.SHOULD);
/*     */           } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 101 */           if (!enumerator.next())
/*     */             break;  continue; }  break;
/*     */       }  }
/* 104 */     finally { enumerator.close(); }
/*     */     
/* 106 */     return query;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 111 */   public String getField() { return (this.lowerTerm != null) ? this.lowerTerm.field() : this.upperTerm.field(); }
/*     */ 
/*     */ 
/*     */   
/* 115 */   public Term getLowerTerm() { return this.lowerTerm; }
/*     */ 
/*     */   
/* 118 */   public Term getUpperTerm() { return this.upperTerm; }
/*     */ 
/*     */   
/* 121 */   public boolean isInclusive() { return this.inclusive; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 127 */     StringBuffer buffer = new StringBuffer();
/* 128 */     if (!getField().equals(field)) {
/*     */       
/* 130 */       buffer.append(getField());
/* 131 */       buffer.append("":"");
/*     */     } 
/* 133 */     buffer.append(this.inclusive ? ""["" : ""{"");
/* 134 */     buffer.append((this.lowerTerm != null) ? this.lowerTerm.text() : ""null"");
/* 135 */     buffer.append("" TO "");
/* 136 */     buffer.append((this.upperTerm != null) ? this.upperTerm.text() : ""null"");
/* 137 */     buffer.append(this.inclusive ? ""]"" : ""}"");
/* 138 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 139 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 144 */     if (this == o) return true; 
/* 145 */     if (!(o instanceof RangeQuery)) return false;
/*     */     
/* 147 */     RangeQuery other = (RangeQuery)o;
/* 148 */     if (getBoost() != other.getBoost()) return false; 
/* 149 */     if (this.inclusive != other.inclusive) return false;
/*     */     
/* 151 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 152 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 153 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 158 */     int h = Float.floatToIntBits(getBoost());
/* 159 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : 0;
/*     */ 
/*     */     
/* 162 */     h ^= h << 25 | h >>> 8;
/* 163 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : 0;
/* 164 */     h ^= this.inclusive ? 658696010 : 0;
/* 165 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\RangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.rmi.Naming;
/*     */ import java.rmi.RMISecurityManager;
/*     */ import java.rmi.RemoteException;
/*     */ import java.rmi.server.UnicastRemoteObject;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RemoteSearchable
/*     */   extends UnicastRemoteObject
/*     */   implements Searchable
/*     */ {
/*     */   private Searchable local;
/*     */   
/*  42 */   public RemoteSearchable(Searchable local) throws RemoteException { this.local = local; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  48 */   public void search(Weight weight, Filter filter, HitCollector results) throws IOException { this.local.search(weight, filter, results); }
/*     */ 
/*     */ 
/*     */   
/*  52 */   public void close() throws IOException { this.local.close(); }
/*     */ 
/*     */ 
/*     */   
/*  56 */   public int docFreq(Term term) throws IOException { return this.local.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public int[] docFreqs(Term[] terms) throws IOException { return this.local.docFreqs(terms); }
/*     */ 
/*     */ 
/*     */   
/*  65 */   public int maxDoc() throws IOException { return this.local.maxDoc(); }
/*     */ 
/*     */ 
/*     */   
/*  69 */   public TopDocs search(Weight weight, Filter filter, int n) throws IOException { return this.local.search(weight, filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException { return this.local.search(weight, filter, n, sort); }
/*     */ 
/*     */ 
/*     */   
/*  79 */   public Document doc(int i) throws IOException { return this.local.doc(i); }
/*     */ 
/*     */ 
/*     */   
/*  83 */   public Query rewrite(Query original) throws IOException { return this.local.rewrite(original); }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public Explanation explain(Weight weight, int doc) throws IOException { return this.local.explain(weight, doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) throws Exception {
/*  93 */     String indexName = null;
/*     */     
/*  95 */     if (args != null && args.length == 1) {
/*  96 */       indexName = args[0];
/*     */     }
/*  98 */     if (indexName == null) {
/*  99 */       System.out.println(""Usage: org.apache.lucene.search.RemoteSearchable <index>"");
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/* 104 */     if (System.getSecurityManager() == null) {
/* 105 */       System.setSecurityManager(new RMISecurityManager());
/*     */     }
/*     */     
/* 108 */     Searchable local = new IndexSearcher(indexName);
/* 109 */     RemoteSearchable impl = new RemoteSearchable(local);
/*     */ 
/*     */     
/* 112 */     Naming.rebind(""//localhost/Searchable"", impl);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\RemoteSearchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable_Stub,"package org.apache.lucene.search;
import java.io.IOException;
import java.lang.reflect.Method;
import java.rmi.Remote;
import java.rmi.UnexpectedException;
import java.rmi.server.RemoteRef;
import java.rmi.server.RemoteStub;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.Term;
public final class RemoteSearchable_Stub extends RemoteStub implements Searchable, Remote {
  private static final long serialVersionUID = 2L;
  private static Method $method_close_0;
  private static Method $method_doc_1;
  private static Method $method_docFreq_2;
  private static Method $method_docFreqs_3;
  private static Method $method_explain_4;
  private static Method $method_maxDoc_5;
  private static Method $method_rewrite_6;
  private static Method $method_search_7;
  private static Method $method_search_8;
  private static Method $method_search_9;
  static Class array$Lorg$apache$lucene$index$Term;
  static  {
    try {
      $method_close_0 = Searchable.class.getMethod(""close"", new Class[0]);
      $method_doc_1 = Searchable.class.getMethod(""doc"", new Class[] { int.class });
      $method_docFreq_2 = Searchable.class.getMethod(""docFreq"", new Class[] { Term.class });
      $method_docFreqs_3 = Searchable.class.getMethod(""docFreqs"", new Class[] { (array$Lorg$apache$lucene$index$Term != null) ? array$Lorg$apache$lucene$index$Term : (array$Lorg$apache$lucene$index$Term = class$(""[Lorg.apache.lucene.index.Term;"")) });
      $method_explain_4 = Searchable.class.getMethod(""explain"", new Class[] { Weight.class, int.class });
      $method_maxDoc_5 = Searchable.class.getMethod(""maxDoc"", new Class[0]);
      $method_rewrite_6 = Searchable.class.getMethod(""rewrite"", new Class[] { Query.class });
      $method_search_7 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class });
      $method_search_8 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class, Sort.class });
      $method_search_9 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, HitCollector.class });
    } catch (NoSuchMethodException noSuchMethodException) {
      throw new NoSuchMethodError(""stub class initialization failed"");
    } 
  }
  public RemoteSearchable_Stub(RemoteRef paramRemoteRef) { super(paramRemoteRef); }
  public void close() throws IOException {
    try {
      this.ref.invoke(this, $method_close_0, null, -4742752445160157748L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Document doc(int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_doc_1, new Object[] { new Integer(paramInt) }, -3205250690722925732L);
      return (Document)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int docFreq(Term paramTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreq_2, new Object[] { paramTerm }, -7822449680410044026L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int[] docFreqs(Term[] paramArrayOfTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreqs_3, new Object[] { paramArrayOfTerm }, -6962924314824234139L);
      return (int[])object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Explanation explain(Weight paramWeight, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_explain_4, new Object[] { paramWeight, new Integer(paramInt) }, -5828411204312880318L);
      return (Explanation)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int maxDoc() throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_maxDoc_5, null, -2054052621300804366L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Query rewrite(Query paramQuery) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_rewrite_6, new Object[] { paramQuery }, 6327992687997160630L);
      return (Query)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_7, new Object[] { paramWeight, paramFilter, new Integer(paramInt) }, -851074451725023257L);
      return (TopDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_8, new Object[] { paramWeight, paramFilter, new Integer(paramInt), paramSort }, 587843085215608570L);
      return (TopFieldDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException {
    try {
      this.ref.invoke(this, $method_search_9, new Object[] { paramWeight, paramFilter, paramHitCollector }, -5970991905374566433L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\RemoteSearchable_Stub.class
 * Java compiler version: 1 (45.3)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqExclScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ReqExclScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Scorer reqScorer;
/*     */   private Scorer exclScorer;
/*     */   private boolean firstTime;
/*     */   
/*     */   public ReqExclScorer(Scorer reqScorer, Scorer exclScorer) {
/*  37 */     super(null);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  42 */     this.firstTime = true;
/*     */     this.reqScorer = reqScorer;
/*     */     this.exclScorer = exclScorer; } public boolean next() throws IOException {
/*  45 */     if (this.firstTime) {
/*  46 */       if (!this.exclScorer.next()) {
/*  47 */         this.exclScorer = null;
/*     */       }
/*  49 */       this.firstTime = false;
/*     */     } 
/*  51 */     if (this.reqScorer == null) {
/*  52 */       return false;
/*     */     }
/*  54 */     if (!this.reqScorer.next()) {
/*  55 */       this.reqScorer = null;
/*  56 */       return false;
/*     */     } 
/*  58 */     if (this.exclScorer == null) {
/*  59 */       return true;
/*     */     }
/*  61 */     return toNonExcluded();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean toNonExcluded() throws IOException {
/*  76 */     int exclDoc = this.exclScorer.doc();
/*     */     do {
/*  78 */       int reqDoc = this.reqScorer.doc();
/*  79 */       if (reqDoc < exclDoc)
/*  80 */         return true; 
/*  81 */       if (reqDoc <= exclDoc)
/*  82 */         continue;  if (!this.exclScorer.skipTo(reqDoc)) {
/*  83 */         this.exclScorer = null;
/*  84 */         return true;
/*     */       } 
/*  86 */       exclDoc = this.exclScorer.doc();
/*  87 */       if (exclDoc > reqDoc) {
/*  88 */         return true;
/*     */       }
/*     */     }
/*  91 */     while (this.reqScorer.next());
/*  92 */     this.reqScorer = null;
/*  93 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  97 */   public int doc() { return this.reqScorer.doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 105 */   public float score() throws IOException { return this.reqScorer.score(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 115 */     if (this.firstTime) {
/* 116 */       this.firstTime = false;
/* 117 */       if (!this.exclScorer.skipTo(target)) {
/* 118 */         this.exclScorer = null;
/*     */       }
/*     */     } 
/* 121 */     if (this.reqScorer == null) {
/* 122 */       return false;
/*     */     }
/* 124 */     if (this.exclScorer == null) {
/* 125 */       return this.reqScorer.skipTo(target);
/*     */     }
/* 127 */     if (!this.reqScorer.skipTo(target)) {
/* 128 */       this.reqScorer = null;
/* 129 */       return false;
/*     */     } 
/* 131 */     return toNonExcluded();
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 135 */     Explanation res = new Explanation();
/* 136 */     if (this.exclScorer.skipTo(doc) && this.exclScorer.doc() == doc) {
/* 137 */       res.setDescription(""excluded"");
/*     */     } else {
/* 139 */       res.setDescription(""not excluded"");
/* 140 */       res.addDetail(this.reqScorer.explain(doc));
/*     */     } 
/* 142 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ReqExclScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqOptSumScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ReqOptSumScorer
/*    */   extends Scorer
/*    */ {
/*    */   private Scorer reqScorer;
/*    */   private Scorer optScorer;
/*    */   private boolean firstTimeOptScorer;
/*    */   
/*    */   public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer) {
/* 40 */     super(null);
/*    */ 
/*    */ 
/*    */ 
/*    */     
/* 45 */     this.firstTimeOptScorer = true;
/*    */     this.reqScorer = reqScorer;
/*    */     this.optScorer = optScorer;
/* 48 */   } public boolean next() throws IOException { return this.reqScorer.next(); }
/*    */ 
/*    */ 
/*    */   
/* 52 */   public boolean skipTo(int target) throws IOException { return this.reqScorer.skipTo(target); }
/*    */ 
/*    */ 
/*    */   
/* 56 */   public int doc() { return this.reqScorer.doc(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public float score() throws IOException {
/* 65 */     int curDoc = this.reqScorer.doc();
/* 66 */     float reqScore = this.reqScorer.score();
/* 67 */     if (this.firstTimeOptScorer)
/* 68 */     { this.firstTimeOptScorer = false;
/* 69 */       if (!this.optScorer.skipTo(curDoc)) {
/* 70 */         this.optScorer = null;
/* 71 */         return reqScore;
/*    */       }  }
/* 73 */     else { if (this.optScorer == null)
/* 74 */         return reqScore; 
/* 75 */       if (this.optScorer.doc() < curDoc && !this.optScorer.skipTo(curDoc)) {
/* 76 */         this.optScorer = null;
/* 77 */         return reqScore;
/*    */       }  }
/*    */     
/* 80 */     return (this.optScorer.doc() == curDoc) ? (reqScore + this.optScorer.score()) : reqScore;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Explanation explain(int doc) throws IOException {
/* 90 */     Explanation res = new Explanation();
/* 91 */     res.setDescription(""required, optional"");
/* 92 */     res.addDetail(this.reqScorer.explain(doc));
/* 93 */     res.addDetail(this.optScorer.explain(doc));
/* 94 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ReqOptSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ScoreDoc
/*    */   implements Serializable
/*    */ {
/*    */   public float score;
/*    */   public int doc;
/*    */   
/*    */   public ScoreDoc(int doc, float score) {
/* 32 */     this.doc = doc;
/* 33 */     this.score = score;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ScoreDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDocComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface ScoreDocComparator
/*    */ {
/* 32 */   public static final ScoreDocComparator RELEVANCE = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 34 */         if (i.score > j.score) return -1; 
/* 35 */         if (i.score < j.score) return 1; 
/* 36 */         return 0;
/*    */       }
/*    */       
/* 39 */       public Comparable sortValue(ScoreDoc i) { return new Float(i.score); }
/*    */ 
/*    */       
/* 42 */       public int sortType() { return 0; }
/*    */     };
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public static final ScoreDocComparator INDEXORDER = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 50 */         if (i.doc < j.doc) return -1; 
/* 51 */         if (i.doc > j.doc) return 1; 
/* 52 */         return 0;
/*    */       }
/*    */       
/* 55 */       public Comparable sortValue(ScoreDoc i) { return new Integer(i.doc); }
/*    */ 
/*    */       
/* 58 */       public int sortType() { return 1; }
/*    */     };
/*    */   
/*    */   int compare(ScoreDoc paramScoreDoc1, ScoreDoc paramScoreDoc2);
/*    */   
/*    */   Comparable sortValue(ScoreDoc paramScoreDoc);
/*    */   
/*    */   int sortType();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\ScoreDocComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Scorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Scorer
/*    */ {
/*    */   private Similarity similarity;
/*    */   
/* 33 */   protected Scorer(Similarity similarity) { this.similarity = similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Similarity getSimilarity() { return this.similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void score(HitCollector hc) throws IOException {
/* 47 */     while (next()) {
/* 48 */       hc.collect(doc(), score());
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 61 */     while (doc() < max) {
/* 62 */       hc.collect(doc(), score());
/* 63 */       if (!next())
/* 64 */         return false; 
/*    */     } 
/* 66 */     return true;
/*    */   }
/*    */   
/*    */   public abstract boolean next() throws IOException;
/*    */   
/*    */   public abstract int doc();
/*    */   
/*    */   public abstract float score() throws IOException;
/*    */   
/*    */   public abstract boolean skipTo(int paramInt) throws IOException;
/*    */   
/*    */   public abstract Explanation explain(int paramInt) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Scorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searchable,"package org.apache.lucene.search;
import java.io.IOException;
import java.rmi.Remote;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.Term;
public interface Searchable extends Remote {
  void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
  void close() throws IOException;
  int docFreq(Term paramTerm) throws IOException;
  int[] docFreqs(Term[] paramArrayOfTerm) throws IOException;
  int maxDoc() throws IOException;
  TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
  Document doc(int paramInt) throws IOException;
  Query rewrite(Query paramQuery) throws IOException;
  Explanation explain(Weight paramWeight, int paramInt) throws IOException;
  TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Searchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Searcher
/*     */   implements Searchable
/*     */ {
/*  36 */   public final Hits search(Query query) throws IOException { return search(query, (Filter)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  44 */   public Hits search(Query query, Filter filter) throws IOException { return new Hits(this, query, filter); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  53 */   public Hits search(Query query, Sort sort) throws IOException { return new Hits(this, query, null, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   public Hits search(Query query, Filter filter, Sort sort) throws IOException { return new Hits(this, query, filter, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public TopFieldDocs search(Query query, Filter filter, int n, Sort sort) throws IOException { return search(createWeight(query), filter, n, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public void search(Query query, HitCollector results) throws IOException { search(query, (Filter)null, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   public void search(Query query, Filter filter, HitCollector results) throws IOException { search(createWeight(query), filter, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 130 */   public TopDocs search(Query query, Filter filter, int n) throws IOException { return search(createWeight(query), filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   public Explanation explain(Query query, int doc) throws IOException { return explain(createWeight(query), doc); }
/*     */ 
/*     */ 
/*     */   
/* 146 */   private Similarity similarity = Similarity.getDefault();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 153 */   public void setSimilarity(Similarity similarity) { this.similarity = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 161 */   public Similarity getSimilarity() { return this.similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 169 */   protected Weight createWeight(Query query) throws IOException { return query.weight(this); }
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] docFreqs(Term[] terms) throws IOException {
/* 174 */     int[] result = new int[terms.length];
/* 175 */     for (int i = 0; i < terms.length; i++) {
/* 176 */       result[i] = docFreq(terms[i]);
/*     */     }
/* 178 */     return result;
/*     */   }
/*     */   
/*     */   public abstract void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract int docFreq(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract int maxDoc() throws IOException;
/*     */   
/*     */   public abstract TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
/*     */   
/*     */   public abstract Document doc(int paramInt) throws IOException;
/*     */   
/*     */   public abstract Query rewrite(Query paramQuery) throws IOException;
/*     */   
/*     */   public abstract Explanation explain(Weight paramWeight, int paramInt) throws IOException;
/*     */   
/*     */   public abstract TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Searcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Similarity,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.SmallFloat;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Similarity
/*     */   implements Serializable
/*     */ {
/*  90 */   private static Similarity defaultImpl = new DefaultSimilarity();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public static void setDefault(Similarity similarity) { defaultImpl = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   public static Similarity getDefault() { return defaultImpl; }
/*     */ 
/*     */ 
/*     */   
/* 115 */   private static final float[] NORM_TABLE = new float[256];
/*     */   
/*     */   static  {
/* 118 */     for (int i = 0; i < 256; i++) {
/* 119 */       NORM_TABLE[i] = SmallFloat.byte315ToFloat((byte)i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public static float decodeNorm(byte b) { return NORM_TABLE[b & 0xFF]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 133 */   public static float[] getNormDecoder() { return NORM_TABLE; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 186 */   public static byte encodeNorm(float f) { return SmallFloat.floatToByte315(f); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 206 */   public float tf(int freq) { return tf(freq); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 255 */   public float idf(Term term, Searcher searcher) throws IOException { return idf(searcher.docFreq(term), searcher.maxDoc()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float idf(Collection terms, Searcher searcher) throws IOException {
/* 268 */     float idf = 0.0F;
/* 269 */     Iterator i = terms.iterator();
/* 270 */     while (i.hasNext()) {
/* 271 */       idf += idf(i.next(), searcher);
/*     */     }
/* 273 */     return idf;
/*     */   }
/*     */   
/*     */   public abstract float lengthNorm(String paramString, int paramInt);
/*     */   
/*     */   public abstract float queryNorm(float paramFloat);
/*     */   
/*     */   public abstract float sloppyFreq(int paramInt);
/*     */   
/*     */   public abstract float tf(float paramFloat);
/*     */   
/*     */   public abstract float idf(int paramInt1, int paramInt2);
/*     */   
/*     */   public abstract float coord(int paramInt1, int paramInt2);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Similarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SimilarityDelegator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimilarityDelegator
/*    */   extends Similarity
/*    */ {
/*    */   private Similarity delegee;
/*    */   
/* 31 */   public SimilarityDelegator(Similarity delegee) { this.delegee = delegee; }
/*    */ 
/*    */ 
/*    */   
/* 35 */   public float lengthNorm(String fieldName, int numTerms) { return this.delegee.lengthNorm(fieldName, numTerms); }
/*    */ 
/*    */ 
/*    */   
/* 39 */   public float queryNorm(float sumOfSquaredWeights) { return this.delegee.queryNorm(sumOfSquaredWeights); }
/*    */ 
/*    */ 
/*    */   
/* 43 */   public float tf(float freq) { return this.delegee.tf(freq); }
/*    */ 
/*    */ 
/*    */   
/* 47 */   public float sloppyFreq(int distance) { return this.delegee.sloppyFreq(distance); }
/*    */ 
/*    */ 
/*    */   
/* 51 */   public float idf(int docFreq, int numDocs) { return this.delegee.idf(docFreq, numDocs); }
/*    */ 
/*    */ 
/*    */   
/* 55 */   public float coord(int overlap, int maxOverlap) { return this.delegee.coord(overlap, maxOverlap); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\SimilarityDelegator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SloppyPhraseScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SloppyPhraseScorer
/*    */   extends PhraseScorer
/*    */ {
/*    */   private int slop;
/*    */   
/*    */   SloppyPhraseScorer(Weight weight, TermPositions[] tps, int[] positions, Similarity similarity, int slop, byte[] norms) {
/* 28 */     super(weight, tps, positions, similarity, norms);
/* 29 */     this.slop = slop;
/*    */   }
/*    */   
/*    */   protected final float phraseFreq() throws IOException {
/* 33 */     this.pq.clear();
/* 34 */     int end = 0;
/* 35 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 36 */       pp.firstPosition();
/* 37 */       if (pp.position > end)
/* 38 */         end = pp.position; 
/* 39 */       this.pq.put(pp);
/*    */     } 
/*    */     
/* 42 */     float freq = 0.0F;
/* 43 */     boolean done = false;
/*    */     do {
/* 45 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/* 46 */       int start = pp.position;
/* 47 */       int next = ((PhrasePositions)this.pq.top()).position; int pos;
/* 48 */       for (pos = start; pos <= next; pos = pp.position) {
/* 49 */         start = pos;
/* 50 */         if (!pp.nextPosition()) {
/* 51 */           done = true;
/*    */           
/*    */           break;
/*    */         } 
/*    */       } 
/* 56 */       int matchLength = end - start;
/* 57 */       if (matchLength <= this.slop) {
/* 58 */         freq += getSimilarity().sloppyFreq(matchLength);
/*    */       }
/* 60 */       if (pp.position > end)
/* 61 */         end = pp.position; 
/* 62 */       this.pq.put(pp);
/* 63 */     } while (!done);
/*    */     
/* 65 */     return freq;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\SloppyPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Sort,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Sort
/*     */   implements Serializable
/*     */ {
/* 109 */   public static final Sort RELEVANCE = new Sort();
/*     */ 
/*     */   
/* 112 */   public static final Sort INDEXORDER = new Sort(SortField.FIELD_DOC);
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   SortField[] fields;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   public Sort() { this(new SortField[] { SortField.FIELD_SCORE, SortField.FIELD_DOC }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 134 */   public Sort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public Sort(String field, boolean reverse) { setSort(field, reverse); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public Sort(String[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public Sort(SortField field) { setSort(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 165 */   public Sort(SortField[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 173 */   public final void setSort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setSort(String field, boolean reverse) {
/* 181 */     SortField[] nfields = { new SortField(field, 2, reverse), SortField.FIELD_DOC };
/*     */     
/* 183 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setSort(String[] fieldnames) {
/* 188 */     int n = fieldnames.length;
/* 189 */     SortField[] nfields = new SortField[n];
/* 190 */     for (int i = 0; i < n; i++) {
/* 191 */       nfields[i] = new SortField(fieldnames[i], 2);
/*     */     }
/* 193 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 198 */   public void setSort(SortField field) { this.fields = new SortField[] { field }; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 203 */   public void setSort(SortField[] fields) { this.fields = fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 211 */   public SortField[] getSort() { return this.fields; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 215 */     StringBuffer buffer = new StringBuffer();
/*     */     
/* 217 */     for (int i = 0; i < this.fields.length; i++) {
/* 218 */       buffer.append(this.fields[i].toString());
/* 219 */       if (i + 1 < this.fields.length) {
/* 220 */         buffer.append(',');
/*     */       }
/*     */     } 
/* 223 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Sort.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SortComparator
/*    */   implements SortComparatorSource
/*    */ {
/*    */   public ScoreDocComparator newComparator(IndexReader reader, String fieldname) throws IOException {
/* 31 */     String field = fieldname.intern();
/* 32 */     final Comparable[] cachedValues = FieldCache.DEFAULT.getCustom(reader, field, this);
/*    */     
/* 34 */     return new ScoreDocComparator() {
/*    */         private final Comparable[] val$cachedValues;
/*    */         
/* 37 */         public int compare(ScoreDoc i, ScoreDoc j) { return cachedValues[i.doc].compareTo(cachedValues[j.doc]); }
/*    */         
/*    */         private final SortComparator this$0;
/*    */         
/* 41 */         public Comparable sortValue(ScoreDoc i) { return cachedValues[i.doc]; }
/*    */ 
/*    */ 
/*    */         
/* 45 */         public int sortType() { return 9; }
/*    */       };
/*    */   }
/*    */   
/*    */   protected abstract Comparable getComparable(String paramString);
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\SortComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparatorSource,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface SortComparatorSource extends Serializable {
  ScoreDocComparator newComparator(IndexReader paramIndexReader, String paramString) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\SortComparatorSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortField,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.Locale;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SortField
/*     */   implements Serializable
/*     */ {
/*     */   public static final int SCORE = 0;
/*     */   public static final int DOC = 1;
/*     */   public static final int AUTO = 2;
/*     */   public static final int STRING = 3;
/*     */   public static final int INT = 4;
/*     */   public static final int FLOAT = 5;
/*     */   public static final int CUSTOM = 9;
/*  72 */   public static final SortField FIELD_SCORE = new SortField(null, 0);
/*     */ 
/*     */   
/*  75 */   public static final SortField FIELD_DOC = new SortField(null, 1);
/*     */   
/*     */   private String field;
/*     */   
/*  79 */   private int type = 2;
/*     */ 
/*     */   
/*     */   private Locale locale;
/*     */   
/*     */   boolean reverse = false;
/*     */   
/*     */   private SortComparatorSource factory;
/*     */ 
/*     */   
/*  89 */   public SortField(String field) { this.field = field.intern(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, boolean reverse) {
/*  98 */     this.field = field.intern();
/*  99 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type) {
/* 109 */     this.field = (field != null) ? field.intern() : field;
/* 110 */     this.type = type;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type, boolean reverse) {
/* 121 */     this.field = (field != null) ? field.intern() : field;
/* 122 */     this.type = type;
/* 123 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale) {
/* 132 */     this.field = field.intern();
/* 133 */     this.type = 3;
/* 134 */     this.locale = locale;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale, boolean reverse) {
/* 143 */     this.field = field.intern();
/* 144 */     this.type = 3;
/* 145 */     this.locale = locale;
/* 146 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator) {
/* 154 */     this.field = (field != null) ? field.intern() : field;
/* 155 */     this.type = 9;
/* 156 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator, boolean reverse) {
/* 165 */     this.field = (field != null) ? field.intern() : field;
/* 166 */     this.type = 9;
/* 167 */     this.reverse = reverse;
/* 168 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public int getType() { return this.type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 191 */   public Locale getLocale() { return this.locale; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 198 */   public boolean getReverse() { return this.reverse; }
/*     */ 
/*     */ 
/*     */   
/* 202 */   public SortComparatorSource getFactory() { return this.factory; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 206 */     StringBuffer buffer = new StringBuffer();
/* 207 */     switch (this.type) { case 0:
/* 208 */         buffer.append(""<score>"");
/*     */         break;
/*     */       case 1:
/* 211 */         buffer.append(""<doc>"");
/*     */         break;
/*     */       case 9:
/* 214 */         buffer.append(""<custom:\"""" + this.field + ""\"": "" + this.factory + "">"");
/*     */         break;
/*     */       
/*     */       default:
/* 218 */         buffer.append(""\"""" + this.field + ""\"""");
/*     */         break; }
/*     */ 
/*     */     
/* 222 */     if (this.locale != null) buffer.append(""("" + this.locale + "")""); 
/* 223 */     if (this.reverse) buffer.append('!');
/*     */     
/* 225 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\SortField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TermQuery
/*     */   extends Query
/*     */ {
/*     */   private Term term;
/*     */   
/*     */   private class TermWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final TermQuery this$0;
/*     */     
/*     */     public TermWeight(Searcher searcher) throws IOException {
/*  42 */       this.similarity = TermQuery.this.getSimilarity(searcher);
/*  43 */       this.idf = this.similarity.idf(TermQuery.this.term, searcher);
/*     */     }
/*     */     
/*  46 */     public String toString() { return ""weight("" + TermQuery.this + "")""; }
/*     */     
/*  48 */     public Query getQuery() { return TermQuery.this; }
/*  49 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/*  52 */       this.queryWeight = this.idf * TermQuery.this.getBoost();
/*  53 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/*  57 */       this.queryNorm = queryNorm;
/*  58 */       this.queryWeight *= queryNorm;
/*  59 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/*  63 */       TermDocs termDocs = reader.termDocs(TermQuery.this.term);
/*     */       
/*  65 */       if (termDocs == null) {
/*  66 */         return null;
/*     */       }
/*  68 */       return new TermScorer(this, termDocs, this.similarity, reader.norms(TermQuery.this.term.field()));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  75 */       Explanation result = new Explanation();
/*  76 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/*  78 */       Explanation idfExpl = new Explanation(this.idf, ""idf(docFreq="" + reader.docFreq(TermQuery.this.term) + "")"");
/*     */ 
/*     */ 
/*     */       
/*  82 */       Explanation queryExpl = new Explanation();
/*  83 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/*  85 */       Explanation boostExpl = new Explanation(TermQuery.this.getBoost(), ""boost"");
/*  86 */       if (TermQuery.this.getBoost() != 1.0F)
/*  87 */         queryExpl.addDetail(boostExpl); 
/*  88 */       queryExpl.addDetail(idfExpl);
/*     */       
/*  90 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/*  91 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/*  93 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/*  97 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 100 */       String field = TermQuery.this.term.field();
/* 101 */       Explanation fieldExpl = new Explanation();
/* 102 */       fieldExpl.setDescription(""fieldWeight("" + TermQuery.this.term + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 105 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 106 */       fieldExpl.addDetail(tfExpl);
/* 107 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 109 */       Explanation fieldNormExpl = new Explanation();
/* 110 */       byte[] fieldNorms = reader.norms(field);
/* 111 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 113 */       fieldNormExpl.setValue(fieldNorm);
/* 114 */       fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 115 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 117 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 121 */       result.addDetail(fieldExpl);
/*     */ 
/*     */       
/* 124 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 126 */       if (queryExpl.getValue() == 1.0F) {
/* 127 */         return fieldExpl;
/*     */       }
/* 129 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 135 */   public TermQuery(Term t) { this.term = t; }
/*     */ 
/*     */ 
/*     */   
/* 139 */   public Term getTerm() { return this.term; }
/*     */ 
/*     */   
/* 142 */   protected Weight createWeight(Searcher searcher) throws IOException { return new TermWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/* 146 */   public void extractTerms(Set terms) { terms.add(getTerm()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 151 */     StringBuffer buffer = new StringBuffer();
/* 152 */     if (!this.term.field().equals(field)) {
/* 153 */       buffer.append(this.term.field());
/* 154 */       buffer.append("":"");
/*     */     } 
/* 156 */     buffer.append(this.term.text());
/* 157 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 158 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 163 */     if (!(o instanceof TermQuery))
/* 164 */       return false; 
/* 165 */     TermQuery other = (TermQuery)o;
/* 166 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 172 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   private TermDocs termDocs;
/*     */   private byte[] norms;
/*     */   private float weightValue;
/*     */   private int doc;
/*  32 */   private final int[] docs = new int[32];
/*  33 */   private final int[] freqs = new int[32];
/*     */   
/*     */   private int pointer;
/*     */   private int pointerMax;
/*     */   private static final int SCORE_CACHE_SIZE = 32;
/*  38 */   private float[] scoreCache = new float[32];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermScorer(Weight weight, TermDocs td, Similarity similarity, byte[] norms) {
/*  48 */     super(similarity);
/*  49 */     this.weight = weight;
/*  50 */     this.termDocs = td;
/*  51 */     this.norms = norms;
/*  52 */     this.weightValue = weight.getValue();
/*     */     
/*  54 */     for (int i = 0; i < 32; i++)
/*  55 */       this.scoreCache[i] = getSimilarity().tf(i) * this.weightValue; 
/*     */   }
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  59 */     next();
/*  60 */     score(hc, 2147483647);
/*     */   }
/*     */   
/*     */   protected boolean score(HitCollector c, int end) throws IOException {
/*  64 */     Similarity similarity = getSimilarity();
/*  65 */     float[] normDecoder = Similarity.getNormDecoder();
/*  66 */     while (this.doc < end) {
/*  67 */       int f = this.freqs[this.pointer];
/*  68 */       float score = (f < 32) ? this.scoreCache[f] : (similarity.tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  73 */       score *= normDecoder[this.norms[this.doc] & 0xFF];
/*     */       
/*  75 */       c.collect(this.doc, score);
/*     */       
/*  77 */       if (++this.pointer >= this.pointerMax) {
/*  78 */         this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/*  79 */         if (this.pointerMax != 0) {
/*  80 */           this.pointer = 0;
/*     */         } else {
/*  82 */           this.termDocs.close();
/*  83 */           this.doc = Integer.MAX_VALUE;
/*  84 */           return false;
/*     */         } 
/*     */       } 
/*  87 */       this.doc = this.docs[this.pointer];
/*     */     } 
/*  89 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 103 */     this.pointer++;
/* 104 */     if (this.pointer >= this.pointerMax) {
/* 105 */       this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/* 106 */       if (this.pointerMax != 0) {
/* 107 */         this.pointer = 0;
/*     */       } else {
/* 109 */         this.termDocs.close();
/* 110 */         this.doc = Integer.MAX_VALUE;
/* 111 */         return false;
/*     */       } 
/*     */     } 
/* 114 */     this.doc = this.docs[this.pointer];
/* 115 */     return true;
/*     */   }
/*     */   
/*     */   public float score() {
/* 119 */     int f = this.freqs[this.pointer];
/* 120 */     float raw = (f < 32) ? this.scoreCache[f] : (getSimilarity().tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 125 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 136 */     this.pointer++; for (; this.pointer < this.pointerMax; this.pointer++) {
/* 137 */       if (this.docs[this.pointer] >= target) {
/* 138 */         this.doc = this.docs[this.pointer];
/* 139 */         return true;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 144 */     boolean result = this.termDocs.skipTo(target);
/* 145 */     if (result) {
/* 146 */       this.pointerMax = 1;
/* 147 */       this.pointer = 0;
/* 148 */       this.docs[this.pointer] = this.doc = this.termDocs.doc();
/* 149 */       this.freqs[this.pointer] = this.termDocs.freq();
/*     */     } else {
/* 151 */       this.doc = Integer.MAX_VALUE;
/*     */     } 
/* 153 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 163 */     TermQuery query = (TermQuery)this.weight.getQuery();
/* 164 */     Explanation tfExplanation = new Explanation();
/* 165 */     int tf = 0;
/* 166 */     while (this.pointer < this.pointerMax) {
/* 167 */       if (this.docs[this.pointer] == doc)
/* 168 */         tf = this.freqs[this.pointer]; 
/* 169 */       this.pointer++;
/*     */     } 
/* 171 */     if (tf == 0) {
/* 172 */       while (this.termDocs.next()) {
/* 173 */         if (this.termDocs.doc() == doc) {
/* 174 */           tf = this.termDocs.freq();
/*     */         }
/*     */       } 
/*     */     }
/* 178 */     this.termDocs.close();
/* 179 */     tfExplanation.setValue(getSimilarity().tf(tf));
/* 180 */     tfExplanation.setDescription(""tf(termFreq("" + query.getTerm() + "")="" + tf + "")"");
/*     */     
/* 182 */     return tfExplanation;
/*     */   }
/*     */ 
/*     */   
/* 186 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TermScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocCollector
/*    */   extends HitCollector
/*    */ {
/*    */   private int numHits;
/* 31 */   private float minScore = 0.0F;
/*    */ 
/*    */   
/*    */   int totalHits;
/*    */ 
/*    */   
/*    */   PriorityQueue hq;
/*    */ 
/*    */   
/* 40 */   public TopDocCollector(int numHits) { this(numHits, new HitQueue(numHits)); }
/*    */ 
/*    */   
/*    */   TopDocCollector(int numHits, PriorityQueue hq) {
/* 44 */     this.numHits = numHits;
/* 45 */     this.hq = hq;
/*    */   }
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 50 */     if (score > 0.0F) {
/* 51 */       this.totalHits++;
/* 52 */       if (this.hq.size() < this.numHits || score >= this.minScore) {
/* 53 */         this.hq.insert(new ScoreDoc(doc, score));
/* 54 */         this.minScore = ((ScoreDoc)this.hq.top()).score;
/*    */       } 
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 60 */   public int getTotalHits() { return this.totalHits; }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 64 */     ScoreDoc[] scoreDocs = new ScoreDoc[this.hq.size()];
/* 65 */     for (int i = this.hq.size() - 1; i >= 0; i--) {
/* 66 */       scoreDocs[i] = (ScoreDoc)this.hq.pop();
/*    */     }
/* 68 */     float maxScore = (this.totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*    */ 
/*    */ 
/*    */     
/* 72 */     return new TopDocs(this.totalHits, scoreDocs, maxScore);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TopDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocs
/*    */   implements Serializable
/*    */ {
/*    */   public int totalHits;
/*    */   public ScoreDoc[] scoreDocs;
/*    */   private float maxScore;
/*    */   
/* 33 */   public float getMaxScore() { return this.maxScore; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   public void setMaxScore(float maxScore) { this.maxScore = maxScore; }
/*    */ 
/*    */ 
/*    */   
/*    */   TopDocs(int totalHits, ScoreDoc[] scoreDocs, float maxScore) {
/* 43 */     this.totalHits = totalHits;
/* 44 */     this.scoreDocs = scoreDocs;
/* 45 */     this.maxScore = maxScore;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TopDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocCollector
/*    */   extends TopDocCollector
/*    */ {
/* 40 */   public TopFieldDocCollector(IndexReader reader, Sort sort, int numHits) throws IOException { super(numHits, new FieldSortedHitQueue(reader, sort.fields, numHits)); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 45 */     if (score > 0.0F) {
/* 46 */       this.totalHits++;
/* 47 */       this.hq.insert(new FieldDoc(doc, score));
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 53 */     FieldSortedHitQueue fshq = (FieldSortedHitQueue)this.hq;
/* 54 */     ScoreDoc[] scoreDocs = new ScoreDoc[fshq.size()];
/* 55 */     for (int i = fshq.size() - 1; i >= 0; i--) {
/* 56 */       scoreDocs[i] = fshq.fillFields((FieldDoc)fshq.pop());
/*    */     }
/* 58 */     return new TopFieldDocs(this.totalHits, scoreDocs, fshq.getFields(), fshq.getMaxScore());
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TopFieldDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocs
/*    */   extends TopDocs
/*    */ {
/*    */   public SortField[] fields;
/*    */   
/*    */   TopFieldDocs(int totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore) {
/* 43 */     super(totalHits, scoreDocs, maxScore);
/* 44 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\TopFieldDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Weight,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface Weight extends Serializable {
  Query getQuery();
  float getValue();
  float sumOfSquaredWeights() throws IOException;
  void normalize(float paramFloat);
  Scorer scorer(IndexReader paramIndexReader) throws IOException;
  Explanation explain(IndexReader paramIndexReader, int paramInt) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\Weight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WildcardQuery
/*    */   extends MultiTermQuery
/*    */ {
/* 34 */   public WildcardQuery(Term term) { super(term); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new WildcardTermEnum(reader, getTerm()); }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 42 */     if (o instanceof WildcardQuery) {
/* 43 */       return super.equals(o);
/*    */     }
/* 45 */     return false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\WildcardQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WildcardTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   Term searchTerm;
/*  35 */   String field = """";
/*  36 */   String text = """";
/*  37 */   String pre = """";
/*  38 */   int preLen = 0;
/*     */ 
/*     */   
/*     */   boolean endEnum = false;
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_STRING = '*';
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_CHAR = '?';
/*     */ 
/*     */   
/*     */   public WildcardTermEnum(IndexReader reader, Term term) throws IOException {
/*  51 */     this.searchTerm = term;
/*  52 */     this.field = this.searchTerm.field();
/*  53 */     this.text = this.searchTerm.text();
/*     */     
/*  55 */     int sidx = this.text.indexOf('*');
/*  56 */     int cidx = this.text.indexOf('?');
/*  57 */     int idx = sidx;
/*  58 */     if (idx == -1) {
/*  59 */       idx = cidx;
/*     */     }
/*  61 */     else if (cidx >= 0) {
/*  62 */       idx = Math.min(idx, cidx);
/*     */     } 
/*     */     
/*  65 */     this.pre = this.searchTerm.text().substring(0, idx);
/*  66 */     this.preLen = this.pre.length();
/*  67 */     this.text = this.text.substring(this.preLen);
/*  68 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.pre)));
/*     */   }
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/*  72 */     if (this.field == term.field()) {
/*  73 */       String searchText = term.text();
/*  74 */       if (searchText.startsWith(this.pre)) {
/*  75 */         return wildcardEquals(this.text, 0, searchText, this.preLen);
/*     */       }
/*     */     } 
/*  78 */     this.endEnum = true;
/*  79 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  83 */   public final float difference() { return 1.0F; }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final boolean wildcardEquals(String pattern, int patternIdx, String string, int stringIdx) {
/* 105 */     int p = patternIdx;
/*     */     
/* 107 */     for (int s = stringIdx;; p++, s++) {
/*     */ 
/*     */       
/* 110 */       boolean sEnd = (s >= string.length());
/*     */       
/* 112 */       boolean pEnd = (p >= pattern.length());
/*     */ 
/*     */       
/* 115 */       if (sEnd) {
/*     */ 
/*     */         
/* 118 */         boolean justWildcardsLeft = true;
/*     */ 
/*     */         
/* 121 */         int wildcardSearchPos = p;
/*     */ 
/*     */         
/* 124 */         while (wildcardSearchPos < pattern.length() && justWildcardsLeft) {
/*     */ 
/*     */           
/* 127 */           char wildchar = pattern.charAt(wildcardSearchPos);
/*     */ 
/*     */ 
/*     */           
/* 131 */           if (wildchar != '?' && wildchar != '*') {
/*     */             
/* 133 */             justWildcardsLeft = false;
/*     */             
/*     */             continue;
/*     */           } 
/*     */           
/* 138 */           if (wildchar == '?') {
/* 139 */             return false;
/*     */           }
/*     */ 
/*     */           
/* 143 */           wildcardSearchPos++;
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 149 */         if (justWildcardsLeft)
/*     */         {
/* 151 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 157 */       if (sEnd || pEnd) {
/*     */         break;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 163 */       if (pattern.charAt(p) != '?') {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 169 */         if (pattern.charAt(p) == '*') {
/*     */ 
/*     */           
/* 172 */           p++;
/*     */           
/* 174 */           for (int i = string.length(); i >= s; i--) {
/*     */             
/* 176 */             if (wildcardEquals(pattern, p, string, i))
/*     */             {
/* 178 */               return true;
/*     */             }
/*     */           } 
/*     */           break;
/*     */         } 
/* 183 */         if (pattern.charAt(p) != string.charAt(s)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 188 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 193 */     super.close();
/* 194 */     this.searchTerm = null;
/* 195 */     this.field = null;
/* 196 */     this.text = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\WildcardTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.NearSpans,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NearSpans
/*     */   implements Spans
/*     */ {
/*     */   private SpanNearQuery query;
/*  30 */   private List ordered = new ArrayList();
/*     */   
/*     */   private int slop;
/*     */   private boolean inOrder;
/*     */   private SpansCell first;
/*     */   private SpansCell last;
/*     */   private int totalLength;
/*     */   private CellQueue queue;
/*     */   private SpansCell max;
/*     */   private boolean more = true;
/*     */   private boolean firstTime = true;
/*     */   
/*     */   private class CellQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     private final NearSpans this$0;
/*     */     
/*  47 */     public CellQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/*  51 */       NearSpans.SpansCell spans1 = (NearSpans.SpansCell)o1;
/*  52 */       NearSpans.SpansCell spans2 = (NearSpans.SpansCell)o2;
/*  53 */       if (spans1.doc() == spans2.doc()) {
/*  54 */         if (spans1.start() == spans2.start()) {
/*  55 */           if (spans1.end() == spans2.end()) {
/*  56 */             return (spans1.index > spans2.index);
/*     */           }
/*  58 */           return (spans1.end() < spans2.end());
/*     */         } 
/*     */         
/*  61 */         return (spans1.start() < spans2.start());
/*     */       } 
/*     */       
/*  64 */       return (spans1.doc() < spans2.doc());
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private class SpansCell
/*     */     implements Spans
/*     */   {
/*     */     private Spans spans;
/*     */     private SpansCell next;
/*  74 */     private int length = -1;
/*     */     private int index;
/*     */     
/*     */     public SpansCell(Spans spans, int index) {
/*  78 */       this.spans = spans;
/*  79 */       this.index = index;
/*     */     }
/*     */     private final NearSpans this$0;
/*     */     public boolean next() throws IOException {
/*  83 */       if (this.length != -1) {
/*  84 */         NearSpans.this.totalLength -= this.length;
/*     */       }
/*  86 */       boolean more = this.spans.next();
/*     */       
/*  88 */       if (more) {
/*  89 */         this.length = end() - start();
/*  90 */         NearSpans.this.totalLength += this.length;
/*     */         
/*  92 */         if (NearSpans.this.max == null || doc() > NearSpans.this.max.doc() || (doc() == NearSpans.this.max.doc() && end() > NearSpans.this.max.end()))
/*     */         {
/*  94 */           NearSpans.this.max = this;
/*     */         }
/*     */       } 
/*  97 */       return more;
/*     */     }
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 101 */       if (this.length != -1) {
/* 102 */         NearSpans.this.totalLength -= this.length;
/*     */       }
/* 104 */       boolean more = this.spans.skipTo(target);
/*     */       
/* 106 */       if (more) {
/* 107 */         this.length = end() - start();
/* 108 */         NearSpans.this.totalLength += this.length;
/*     */         
/* 110 */         if (NearSpans.this.max == null || doc() > NearSpans.this.max.doc() || (doc() == NearSpans.this.max.doc() && end() > NearSpans.this.max.end()))
/*     */         {
/* 112 */           NearSpans.this.max = this;
/*     */         }
/*     */       } 
/* 115 */       return more;
/*     */     }
/*     */     
/* 118 */     public int doc() { return this.spans.doc(); }
/* 119 */     public int start() { return this.spans.start(); }
/* 120 */     public int end() { return this.spans.end(); }
/*     */     
/* 122 */     public String toString() { return this.spans.toString() + ""#"" + this.index; }
/*     */   }
/*     */ 
/*     */   
/*     */   public NearSpans(SpanNearQuery query, IndexReader reader) throws IOException {
/* 127 */     this.query = query;
/* 128 */     this.slop = query.getSlop();
/* 129 */     this.inOrder = query.isInOrder();
/*     */     
/* 131 */     SpanQuery[] clauses = query.getClauses();
/* 132 */     this.queue = new CellQueue(clauses.length);
/* 133 */     for (int i = 0; i < clauses.length; i++) {
/* 134 */       SpansCell cell = new SpansCell(clauses[i].getSpans(reader), i);
/*     */       
/* 136 */       this.ordered.add(cell);
/*     */     } 
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 141 */     if (this.firstTime) {
/* 142 */       initList(true);
/* 143 */       listToQueue();
/* 144 */       this.firstTime = false;
/* 145 */     } else if (this.more) {
/* 146 */       this.more = min().next();
/* 147 */       if (this.more) {
/* 148 */         this.queue.adjustTop();
/*     */       }
/*     */     } 
/* 151 */     while (this.more) {
/*     */       
/* 153 */       boolean queueStale = false;
/*     */       
/* 155 */       if (min().doc() != this.max.doc()) {
/* 156 */         queueToList();
/* 157 */         queueStale = true;
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 162 */       while (this.more && this.first.doc() < this.last.doc()) {
/* 163 */         this.more = this.first.skipTo(this.last.doc());
/* 164 */         firstToLast();
/* 165 */         queueStale = true;
/*     */       } 
/*     */       
/* 168 */       if (!this.more) return false;
/*     */ 
/*     */ 
/*     */       
/* 172 */       if (queueStale) {
/* 173 */         listToQueue();
/* 174 */         queueStale = false;
/*     */       } 
/*     */       
/* 177 */       if (atMatch()) {
/* 178 */         return true;
/*     */       }
/*     */       
/* 181 */       if (this.inOrder && checkSlop()) {
/*     */         
/* 183 */         this.more = firstNonOrderedNextToPartialList();
/* 184 */         if (this.more)
/* 185 */           partialListToQueue(); 
/*     */         continue;
/*     */       } 
/* 188 */       this.more = min().next();
/* 189 */       if (this.more) {
/* 190 */         this.queue.adjustTop();
/*     */       }
/*     */     } 
/*     */     
/* 194 */     return false;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 198 */     if (this.firstTime) {
/* 199 */       initList(false);
/* 200 */       for (SpansCell cell = this.first; this.more && cell != null; cell = cell.next) {
/* 201 */         this.more = cell.skipTo(target);
/*     */       }
/* 203 */       if (this.more) {
/* 204 */         listToQueue();
/*     */       }
/* 206 */       this.firstTime = false;
/*     */     } else {
/* 208 */       while (this.more && min().doc() < target) {
/* 209 */         this.more = min().skipTo(target);
/* 210 */         if (this.more)
/* 211 */           this.queue.adjustTop(); 
/*     */       } 
/*     */     } 
/* 214 */     if (this.more) {
/*     */       
/* 216 */       if (atMatch()) {
/* 217 */         return true;
/*     */       }
/* 219 */       return next();
/*     */     } 
/*     */     
/* 222 */     return false;
/*     */   }
/*     */   
/* 225 */   private SpansCell min() { return (SpansCell)this.queue.top(); }
/*     */   
/* 227 */   public int doc() { return min().doc(); }
/* 228 */   public int start() { return min().start(); }
/* 229 */   public int end() { return this.max.end(); }
/*     */ 
/*     */ 
/*     */   
/* 233 */   public String toString() { return ""spans("" + this.query.toString() + "")@"" + (this.firstTime ? ""START"" : (this.more ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initList(boolean next) throws IOException {
/* 238 */     for (int i = 0; this.more && i < this.ordered.size(); i++) {
/* 239 */       SpansCell cell = this.ordered.get(i);
/* 240 */       if (next)
/* 241 */         this.more = cell.next(); 
/* 242 */       if (this.more) {
/* 243 */         addToList(cell);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private void addToList(SpansCell cell) {
/* 249 */     if (this.last != null) {
/* 250 */       this.last.next = cell;
/*     */     } else {
/* 252 */       this.first = cell;
/* 253 */     }  this.last = cell;
/* 254 */     cell.next = null;
/*     */   }
/*     */   
/*     */   private void firstToLast() {
/* 258 */     this.last.next = this.first;
/* 259 */     this.last = this.first;
/* 260 */     this.first = this.first.next;
/* 261 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   private void queueToList() {
/* 265 */     this.last = this.first = null;
/* 266 */     while (this.queue.top() != null) {
/* 267 */       addToList((SpansCell)this.queue.pop());
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean firstNonOrderedNextToPartialList() throws IOException {
/* 275 */     this.last = this.first = null;
/* 276 */     int orderedIndex = 0;
/* 277 */     while (this.queue.top() != null) {
/* 278 */       SpansCell cell = (SpansCell)this.queue.pop();
/* 279 */       addToList(cell);
/* 280 */       if (cell.index == orderedIndex) {
/* 281 */         orderedIndex++; continue;
/*     */       } 
/* 283 */       return cell.next();
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 291 */     throw new RuntimeException(""Unexpected: ordered"");
/*     */   }
/*     */   
/*     */   private void listToQueue() {
/* 295 */     this.queue.clear();
/* 296 */     partialListToQueue();
/*     */   }
/*     */   
/*     */   private void partialListToQueue() {
/* 300 */     for (SpansCell cell = this.first; cell != null; cell = cell.next) {
/* 301 */       this.queue.put(cell);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 306 */   private boolean atMatch() { return (min().doc() == this.max.doc() && checkSlop() && (!this.inOrder || matchIsOrdered())); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean checkSlop() {
/* 312 */     int matchLength = this.max.end() - min().start();
/* 313 */     return (matchLength - this.totalLength <= this.slop);
/*     */   }
/*     */   
/*     */   private boolean matchIsOrdered() {
/* 317 */     int lastStart = -1;
/* 318 */     for (int i = 0; i < this.ordered.size(); i++) {
/* 319 */       int start = ((SpansCell)this.ordered.get(i)).start();
/* 320 */       if (start <= lastStart)
/* 321 */         return false; 
/* 322 */       lastStart = start;
/*     */     } 
/* 324 */     return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\NearSpans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanFirstQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanFirstQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery match;
/*     */   private int end;
/*     */   
/*     */   public SpanFirstQuery(SpanQuery match, int end) {
/*  36 */     this.match = match;
/*  37 */     this.end = end;
/*     */   }
/*     */ 
/*     */   
/*  41 */   public SpanQuery getMatch() { return this.match; }
/*     */ 
/*     */   
/*  44 */   public int getEnd() { return this.end; }
/*     */   
/*  46 */   public String getField() { return this.match.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  52 */   public Collection getTerms() { return this.match.getTerms(); }
/*     */   
/*     */   public String toString(String field) {
/*  55 */     StringBuffer buffer = new StringBuffer();
/*  56 */     buffer.append(""spanFirst("");
/*  57 */     buffer.append(this.match.toString(field));
/*  58 */     buffer.append("", "");
/*  59 */     buffer.append(this.end);
/*  60 */     buffer.append("")"");
/*  61 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  62 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*  66 */   public void extractTerms(Set terms) { this.match.extractTerms(terms); }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  70 */     return new Spans() {
/*  71 */         private Spans spans = SpanFirstQuery.this.match.getSpans(reader); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  74 */           while (this.spans.next()) {
/*  75 */             if (end() <= SpanFirstQuery.this.end)
/*  76 */               return true; 
/*     */           } 
/*  78 */           return false;
/*     */         }
/*     */         private final SpanFirstQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/*  82 */           if (!this.spans.skipTo(target)) {
/*  83 */             return false;
/*     */           }
/*  85 */           if (this.spans.end() <= SpanFirstQuery.this.end) {
/*  86 */             return true;
/*     */           }
/*  88 */           return next();
/*     */         }
/*     */         
/*  91 */         public int doc() { return this.spans.doc(); }
/*  92 */         public int start() { return this.spans.start(); }
/*  93 */         public int end() { return this.spans.end(); }
/*     */ 
/*     */         
/*  96 */         public String toString() { return ""spans("" + SpanFirstQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 103 */     SpanFirstQuery clone = null;
/*     */     
/* 105 */     SpanQuery rewritten = (SpanQuery)this.match.rewrite(reader);
/* 106 */     if (rewritten != this.match) {
/* 107 */       clone = (SpanFirstQuery)clone();
/* 108 */       clone.match = rewritten;
/*     */     } 
/*     */     
/* 111 */     if (clone != null) {
/* 112 */       return clone;
/*     */     }
/* 114 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 119 */     if (this == o) return true; 
/* 120 */     if (!(o instanceof SpanFirstQuery)) return false;
/*     */     
/* 122 */     SpanFirstQuery other = (SpanFirstQuery)o;
/* 123 */     return (this.end == other.end && this.match.equals(other.match) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 129 */     int h = this.match.hashCode();
/* 130 */     h ^= h << 8 | h >>> 25;
/* 131 */     h ^= Float.floatToRawIntBits(getBoost()) ^ this.end;
/* 132 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanFirstQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNearQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNearQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private int slop;
/*     */   private boolean inOrder;
/*     */   private String field;
/*     */   
/*     */   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder) {
/*  49 */     this.clauses = new ArrayList(clauses.length);
/*  50 */     for (int i = 0; i < clauses.length; i++) {
/*  51 */       SpanQuery clause = clauses[i];
/*  52 */       if (i == 0) {
/*  53 */         this.field = clause.getField();
/*  54 */       } else if (!clause.getField().equals(this.field)) {
/*  55 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  57 */       this.clauses.add(clause);
/*     */     } 
/*     */     
/*  60 */     this.slop = slop;
/*  61 */     this.inOrder = inOrder;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  66 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */ 
/*     */   
/*  70 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */   
/*  73 */   public boolean isInOrder() { return this.inOrder; }
/*     */   
/*  75 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  82 */     Collection terms = new ArrayList();
/*  83 */     Iterator i = this.clauses.iterator();
/*  84 */     while (i.hasNext()) {
/*  85 */       SpanQuery clause = i.next();
/*  86 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  88 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  92 */     Iterator i = this.clauses.iterator();
/*  93 */     while (i.hasNext()) {
/*  94 */       SpanQuery clause = i.next();
/*  95 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 101 */     StringBuffer buffer = new StringBuffer();
/* 102 */     buffer.append(""spanNear(["");
/* 103 */     Iterator i = this.clauses.iterator();
/* 104 */     while (i.hasNext()) {
/* 105 */       SpanQuery clause = i.next();
/* 106 */       buffer.append(clause.toString(field));
/* 107 */       if (i.hasNext()) {
/* 108 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 111 */     buffer.append(""], "");
/* 112 */     buffer.append(this.slop);
/* 113 */     buffer.append("", "");
/* 114 */     buffer.append(this.inOrder);
/* 115 */     buffer.append("")"");
/* 116 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 117 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public Spans getSpans(IndexReader reader) throws IOException {
/* 121 */     if (this.clauses.size() == 0) {
/* 122 */       return (new SpanOrQuery(getClauses())).getSpans(reader);
/*     */     }
/* 124 */     if (this.clauses.size() == 1) {
/* 125 */       return ((SpanQuery)this.clauses.get(0)).getSpans(reader);
/*     */     }
/* 127 */     return new NearSpans(this, reader);
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 131 */     SpanNearQuery clone = null;
/* 132 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 133 */       SpanQuery c = this.clauses.get(i);
/* 134 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/* 135 */       if (query != c) {
/* 136 */         if (clone == null)
/* 137 */           clone = (SpanNearQuery)clone(); 
/* 138 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/* 141 */     if (clone != null) {
/* 142 */       return clone;
/*     */     }
/* 144 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 150 */     if (this == o) return true; 
/* 151 */     if (!(o instanceof SpanNearQuery)) return false;
/*     */     
/* 153 */     SpanNearQuery spanNearQuery = (SpanNearQuery)o;
/*     */     
/* 155 */     if (this.inOrder != spanNearQuery.inOrder) return false; 
/* 156 */     if (this.slop != spanNearQuery.slop) return false; 
/* 157 */     if (!this.clauses.equals(spanNearQuery.clauses)) return false;
/*     */     
/* 159 */     return (getBoost() == spanNearQuery.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 164 */     int result = this.clauses.hashCode();
/*     */ 
/*     */ 
/*     */     
/* 168 */     result ^= result << 14 | result >>> 19;
/* 169 */     result += Float.floatToRawIntBits(getBoost());
/* 170 */     result += this.slop;
/* 171 */     result ^= this.inOrder ? -1716530243 : 0;
/* 172 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanNearQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNotQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNotQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery include;
/*     */   private SpanQuery exclude;
/*     */   
/*     */   public SpanNotQuery(SpanQuery include, SpanQuery exclude) {
/*  36 */     this.include = include;
/*  37 */     this.exclude = exclude;
/*     */     
/*  39 */     if (!include.getField().equals(exclude.getField())) {
/*  40 */       throw new IllegalArgumentException(""Clauses must have same field."");
/*     */     }
/*     */   }
/*     */   
/*  44 */   public SpanQuery getInclude() { return this.include; }
/*     */ 
/*     */   
/*  47 */   public SpanQuery getExclude() { return this.exclude; }
/*     */   
/*  49 */   public String getField() { return this.include.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public Collection getTerms() { return this.include.getTerms(); }
/*     */   
/*  57 */   public void extractTerms(Set terms) { this.include.extractTerms(terms); }
/*     */   
/*     */   public String toString(String field) {
/*  60 */     StringBuffer buffer = new StringBuffer();
/*  61 */     buffer.append(""spanNot("");
/*  62 */     buffer.append(this.include.toString(field));
/*  63 */     buffer.append("", "");
/*  64 */     buffer.append(this.exclude.toString(field));
/*  65 */     buffer.append("")"");
/*  66 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  67 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  72 */     return new Spans() {
/*  73 */         private Spans includeSpans = SpanNotQuery.this.include.getSpans(reader);
/*     */         
/*     */         private boolean moreInclude = true;
/*  76 */         private Spans excludeSpans = SpanNotQuery.this.exclude.getSpans(reader);
/*  77 */         private boolean moreExclude = this.excludeSpans.next(); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  80 */           if (this.moreInclude) {
/*  81 */             this.moreInclude = this.includeSpans.next();
/*     */           }
/*  83 */           while (this.moreInclude && this.moreExclude) {
/*     */             
/*  85 */             if (this.includeSpans.doc() > this.excludeSpans.doc()) {
/*  86 */               this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */             }
/*     */ 
/*     */             
/*  90 */             while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/*  91 */               this.moreExclude = this.excludeSpans.next();
/*     */             }
/*     */             
/*  94 */             if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start()) {
/*     */               break;
/*     */             }
/*     */ 
/*     */             
/*  99 */             this.moreInclude = this.includeSpans.next();
/*     */           } 
/* 101 */           return this.moreInclude;
/*     */         }
/*     */         private final SpanNotQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/* 105 */           if (this.moreInclude) {
/* 106 */             this.moreInclude = this.includeSpans.skipTo(target);
/*     */           }
/* 108 */           if (!this.moreInclude) {
/* 109 */             return false;
/*     */           }
/* 111 */           if (this.moreExclude && this.includeSpans.doc() > this.excludeSpans.doc())
/*     */           {
/* 113 */             this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */           }
/*     */ 
/*     */           
/* 117 */           while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/* 118 */             this.moreExclude = this.excludeSpans.next();
/*     */           }
/*     */           
/* 121 */           if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start())
/*     */           {
/*     */             
/* 124 */             return true;
/*     */           }
/* 126 */           return next();
/*     */         }
/*     */         
/* 129 */         public int doc() { return this.includeSpans.doc(); }
/* 130 */         public int start() { return this.includeSpans.start(); }
/* 131 */         public int end() { return this.includeSpans.end(); }
/*     */ 
/*     */         
/* 134 */         public String toString() { return ""spans("" + SpanNotQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 141 */     SpanNotQuery clone = null;
/*     */     
/* 143 */     SpanQuery rewrittenInclude = (SpanQuery)this.include.rewrite(reader);
/* 144 */     if (rewrittenInclude != this.include) {
/* 145 */       clone = (SpanNotQuery)clone();
/* 146 */       clone.include = rewrittenInclude;
/*     */     } 
/* 148 */     SpanQuery rewrittenExclude = (SpanQuery)this.exclude.rewrite(reader);
/* 149 */     if (rewrittenExclude != this.exclude) {
/* 150 */       if (clone == null) clone = (SpanNotQuery)clone(); 
/* 151 */       clone.exclude = rewrittenExclude;
/*     */     } 
/*     */     
/* 154 */     if (clone != null) {
/* 155 */       return clone;
/*     */     }
/* 157 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 163 */     if (this == o) return true; 
/* 164 */     if (!(o instanceof SpanNotQuery)) return false;
/*     */     
/* 166 */     SpanNotQuery other = (SpanNotQuery)o;
/* 167 */     return (this.include.equals(other.include) && this.exclude.equals(other.exclude) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 173 */     int h = this.include.hashCode();
/* 174 */     h = h << 1 | h >>> 31;
/* 175 */     h ^= this.exclude.hashCode();
/* 176 */     h = h << 1 | h >>> 31;
/* 177 */     h ^= Float.floatToRawIntBits(getBoost());
/* 178 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanNotQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanOrQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanOrQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private String field;
/*     */   
/*     */   public SpanOrQuery(SpanQuery[] clauses) {
/*  41 */     this.clauses = new ArrayList(clauses.length);
/*  42 */     for (int i = 0; i < clauses.length; i++) {
/*  43 */       SpanQuery clause = clauses[i];
/*  44 */       if (i == 0) {
/*  45 */         this.field = clause.getField();
/*  46 */       } else if (!clause.getField().equals(this.field)) {
/*  47 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  49 */       this.clauses.add(clause);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  55 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */   
/*  58 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  65 */     Collection terms = new ArrayList();
/*  66 */     Iterator i = this.clauses.iterator();
/*  67 */     while (i.hasNext()) {
/*  68 */       SpanQuery clause = i.next();
/*  69 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  71 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  75 */     Iterator i = this.clauses.iterator();
/*  76 */     while (i.hasNext()) {
/*  77 */       SpanQuery clause = i.next();
/*  78 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  84 */     SpanOrQuery clone = null;
/*  85 */     for (int i = 0; i < this.clauses.size(); i++) {
/*  86 */       SpanQuery c = this.clauses.get(i);
/*  87 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/*  88 */       if (query != c) {
/*  89 */         if (clone == null)
/*  90 */           clone = (SpanOrQuery)clone(); 
/*  91 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/*  94 */     if (clone != null) {
/*  95 */       return clone;
/*     */     }
/*  97 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 102 */     StringBuffer buffer = new StringBuffer();
/* 103 */     buffer.append(""spanOr(["");
/* 104 */     Iterator i = this.clauses.iterator();
/* 105 */     while (i.hasNext()) {
/* 106 */       SpanQuery clause = i.next();
/* 107 */       buffer.append(clause.toString(field));
/* 108 */       if (i.hasNext()) {
/* 109 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 112 */     buffer.append(""])"");
/* 113 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 114 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 118 */     if (this == o) return true; 
/* 119 */     if (o == null || getClass() != o.getClass()) return false;
/*     */     
/* 121 */     SpanOrQuery that = (SpanOrQuery)o;
/*     */     
/* 123 */     if (!this.clauses.equals(that.clauses)) return false; 
/* 124 */     if (!this.field.equals(that.field)) return false;
/*     */     
/* 126 */     return (getBoost() == that.getBoost());
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 130 */     int h = this.clauses.hashCode();
/* 131 */     h ^= h << 10 | h >>> 23;
/* 132 */     h ^= Float.floatToRawIntBits(getBoost());
/* 133 */     return h;
/*     */   }
/*     */   
/*     */   private class SpanQueue extends PriorityQueue { private final SpanOrQuery this$0;
/*     */     
/* 138 */     public SpanQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/* 142 */       Spans spans1 = (Spans)o1;
/* 143 */       Spans spans2 = (Spans)o2;
/* 144 */       if (spans1.doc() == spans2.doc()) {
/* 145 */         if (spans1.start() == spans2.start()) {
/* 146 */           return (spans1.end() < spans2.end());
/*     */         }
/* 148 */         return (spans1.start() < spans2.start());
/*     */       } 
/*     */       
/* 151 */       return (spans1.doc() < spans2.doc());
/*     */     } }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/* 158 */     if (this.clauses.size() == 1) {
/* 159 */       return ((SpanQuery)this.clauses.get(0)).getSpans(reader);
/*     */     }
/* 161 */     return new Spans() {
/* 162 */         private List all = new ArrayList(SpanOrQuery.this.clauses.size());
/* 163 */         private SpanOrQuery.SpanQueue queue = new SpanOrQuery.SpanQueue(SpanOrQuery.this.clauses.size());
/*     */ 
/*     */         
/*     */         private boolean firstTime;
/*     */ 
/*     */         
/*     */         private final IndexReader val$reader;
/*     */         
/*     */         private final SpanOrQuery this$0;
/*     */ 
/*     */         
/*     */         public boolean next() throws IOException {
/* 175 */           if (this.firstTime) {
/* 176 */             for (int i = 0; i < this.all.size(); i++) {
/* 177 */               Spans spans = this.all.get(i);
/* 178 */               if (spans.next()) {
/* 179 */                 this.queue.put(spans);
/*     */               } else {
/* 181 */                 this.all.remove(i--);
/*     */               } 
/*     */             } 
/* 184 */             this.firstTime = false;
/* 185 */             return (this.queue.size() != 0);
/*     */           } 
/*     */           
/* 188 */           if (this.queue.size() == 0) {
/* 189 */             return false;
/*     */           }
/*     */           
/* 192 */           if (top().next()) {
/* 193 */             this.queue.adjustTop();
/* 194 */             return true;
/*     */           } 
/*     */           
/* 197 */           this.all.remove(this.queue.pop());
/*     */           
/* 199 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 202 */         private Spans top() { return (Spans)this.queue.top(); }
/*     */         
/*     */         public boolean skipTo(int target) throws IOException {
/* 205 */           if (this.firstTime) {
/* 206 */             for (int i = 0; i < this.all.size(); i++) {
/* 207 */               Spans spans = this.all.get(i);
/* 208 */               if (spans.skipTo(target)) {
/* 209 */                 this.queue.put(spans);
/*     */               } else {
/* 211 */                 this.all.remove(i--);
/*     */               } 
/*     */             } 
/* 214 */             this.firstTime = false;
/*     */           } else {
/* 216 */             while (this.queue.size() != 0 && top().doc() < target) {
/* 217 */               if (top().skipTo(target)) {
/* 218 */                 this.queue.adjustTop(); continue;
/*     */               } 
/* 220 */               this.all.remove(this.queue.pop());
/*     */             } 
/*     */           } 
/*     */ 
/*     */           
/* 225 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 228 */         public int doc() { return top().doc(); }
/* 229 */         public int start() { return top().start(); }
/* 230 */         public int end() { return top().end(); }
/*     */ 
/*     */         
/* 233 */         public String toString() { return ""spans("" + SpanOrQuery.this + "")@"" + (this.firstTime ? ""START"" : ((this.queue.size() > 0) ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanOrQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanQuery,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Collection;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.Query;
/*    */ import org.apache.lucene.search.Searcher;
/*    */ import org.apache.lucene.search.Weight;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SpanQuery
/*    */   extends Query
/*    */ {
/*    */   public abstract Spans getSpans(IndexReader paramIndexReader) throws IOException;
/*    */   
/*    */   public abstract String getField();
/*    */   
/*    */   public abstract Collection getTerms();
/*    */   
/* 45 */   protected Weight createWeight(Searcher searcher) throws IOException { return new SpanWeight(this, searcher); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.Spans,"package org.apache.lucene.search.spans;
import java.io.IOException;
public interface Spans {
  boolean next() throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  int doc();
  int start();
  int end();
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\Spans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanScorer,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SpanScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Spans spans;
/*     */   private Weight weight;
/*     */   private byte[] norms;
/*     */   private float value;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   private int doc;
/*     */   private float freq;
/*     */   
/*     */   SpanScorer(Spans spans, Weight weight, Similarity similarity, byte[] norms) throws IOException {
/*  41 */     super(similarity);
/*  42 */     this.spans = spans;
/*  43 */     this.norms = norms;
/*  44 */     this.weight = weight;
/*  45 */     this.value = weight.getValue();
/*  46 */     this.doc = -1;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/*  50 */     if (this.firstTime) {
/*  51 */       this.more = this.spans.next();
/*  52 */       this.firstTime = false;
/*     */     } 
/*  54 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  58 */     if (this.firstTime) {
/*  59 */       this.more = this.spans.skipTo(target);
/*  60 */       this.firstTime = false;
/*     */     } 
/*  62 */     if (!this.more) {
/*  63 */       return false;
/*     */     }
/*  65 */     if (this.spans.doc() < target) {
/*  66 */       this.more = this.spans.skipTo(target);
/*     */     }
/*  68 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   private boolean setFreqCurrentDoc() throws IOException {
/*  72 */     if (!this.more) {
/*  73 */       return false;
/*     */     }
/*  75 */     this.doc = this.spans.doc();
/*  76 */     this.freq = 0.0F;
/*  77 */     while (this.more && this.doc == this.spans.doc()) {
/*  78 */       int matchLength = this.spans.end() - this.spans.start();
/*  79 */       this.freq += getSimilarity().sloppyFreq(matchLength);
/*  80 */       this.more = this.spans.next();
/*     */     } 
/*  82 */     return (this.more || this.freq != 0.0F);
/*     */   }
/*     */   
/*  85 */   public int doc() { return this.doc; }
/*     */   
/*     */   public float score() throws IOException {
/*  88 */     float raw = getSimilarity().tf(this.freq) * this.value;
/*  89 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/*  93 */     Explanation tfExplanation = new Explanation();
/*     */     
/*  95 */     skipTo(doc);
/*     */     
/*  97 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/*  98 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/*  99 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 101 */     return tfExplanation;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanTermQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanTermQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private Term term;
/*     */   
/*  35 */   public SpanTermQuery(Term term) { this.term = term; }
/*     */ 
/*     */   
/*  38 */   public Term getTerm() { return this.term; }
/*     */   
/*  40 */   public String getField() { return this.term.field(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  47 */     Collection terms = new ArrayList();
/*  48 */     terms.add(this.term);
/*  49 */     return terms;
/*     */   }
/*     */   
/*  52 */   public void extractTerms(Set terms) { terms.add(this.term); }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/*  56 */     StringBuffer buffer = new StringBuffer();
/*  57 */     if (this.term.field().equals(field)) {
/*  58 */       buffer.append(this.term.text());
/*     */     } else {
/*  60 */       buffer.append(this.term.toString());
/*  61 */     }  buffer.append(ToStringUtils.boost(getBoost()));
/*  62 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  67 */     if (!(o instanceof SpanTermQuery))
/*  68 */       return false; 
/*  69 */     SpanTermQuery other = (SpanTermQuery)o;
/*  70 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode() ^ 0xD23FE494; }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  80 */     return new Spans() {
/*  81 */         private TermPositions positions = reader.termPositions(SpanTermQuery.this.term);
/*     */         
/*  83 */         private int doc = -1;
/*     */         
/*     */         private int freq;
/*     */         private int count;
/*     */         
/*     */         public boolean next() throws IOException {
/*  89 */           if (this.count == this.freq) {
/*  90 */             if (!this.positions.next()) {
/*  91 */               this.doc = Integer.MAX_VALUE;
/*  92 */               return false;
/*     */             } 
/*  94 */             this.doc = this.positions.doc();
/*  95 */             this.freq = this.positions.freq();
/*  96 */             this.count = 0;
/*     */           } 
/*  98 */           this.position = this.positions.nextPosition();
/*  99 */           this.count++;
/* 100 */           return true;
/*     */         }
/*     */         private int position; private final IndexReader val$reader; private final SpanTermQuery this$0;
/*     */         
/*     */         public boolean skipTo(int target) throws IOException {
/* 105 */           if (this.doc >= target) {
/* 106 */             return true;
/*     */           }
/*     */           
/* 109 */           if (!this.positions.skipTo(target)) {
/* 110 */             this.doc = Integer.MAX_VALUE;
/* 111 */             return false;
/*     */           } 
/*     */           
/* 114 */           this.doc = this.positions.doc();
/* 115 */           this.freq = this.positions.freq();
/* 116 */           this.count = 0;
/*     */           
/* 118 */           this.position = this.positions.nextPosition();
/* 119 */           this.count++;
/*     */           
/* 121 */           return true;
/*     */         }
/*     */         
/* 124 */         public int doc() { return this.doc; }
/* 125 */         public int start() { return this.position; }
/* 126 */         public int end() { return this.position + 1; }
/*     */ 
/*     */         
/* 129 */         public String toString() { return ""spans("" + SpanTermQuery.this.toString() + "")@"" + ((this.doc == -1) ? ""START"" : ((this.doc == Integer.MAX_VALUE) ? ""END"" : (this.doc + ""-"" + this.position))); }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanWeight,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SpanWeight
/*     */   implements Weight
/*     */ {
/*     */   private Similarity similarity;
/*     */   private float value;
/*     */   private float idf;
/*     */   private float queryNorm;
/*     */   private float queryWeight;
/*     */   private Set terms;
/*     */   private SpanQuery query;
/*     */   
/*     */   public SpanWeight(SpanQuery query, Searcher searcher) throws IOException {
/*  47 */     this.similarity = query.getSimilarity(searcher);
/*  48 */     this.query = query;
/*  49 */     this.terms = new HashSet();
/*  50 */     query.extractTerms(this.terms);
/*     */     
/*  52 */     this.idf = this.query.getSimilarity(searcher).idf(this.terms, searcher);
/*     */   }
/*     */   
/*  55 */   public Query getQuery() { return this.query; }
/*  56 */   public float getValue() { return this.value; }
/*     */   
/*     */   public float sumOfSquaredWeights() throws IOException {
/*  59 */     this.queryWeight = this.idf * this.query.getBoost();
/*  60 */     return this.queryWeight * this.queryWeight;
/*     */   }
/*     */   
/*     */   public void normalize(float queryNorm) {
/*  64 */     this.queryNorm = queryNorm;
/*  65 */     this.queryWeight *= queryNorm;
/*  66 */     this.value = this.queryWeight * this.idf;
/*     */   }
/*     */ 
/*     */   
/*  70 */   public Scorer scorer(IndexReader reader) throws IOException { return new SpanScorer(this.query.getSpans(reader), this, this.similarity, reader.norms(this.query.getField())); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  78 */     Explanation result = new Explanation();
/*  79 */     result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*  80 */     String field = ((SpanQuery)getQuery()).getField();
/*     */     
/*  82 */     StringBuffer docFreqs = new StringBuffer();
/*  83 */     Iterator i = this.terms.iterator();
/*  84 */     while (i.hasNext()) {
/*  85 */       Term term = i.next();
/*  86 */       docFreqs.append(term.text());
/*  87 */       docFreqs.append(""="");
/*  88 */       docFreqs.append(reader.docFreq(term));
/*     */       
/*  90 */       if (i.hasNext()) {
/*  91 */         docFreqs.append("" "");
/*     */       }
/*     */     } 
/*     */     
/*  95 */     Explanation idfExpl = new Explanation(this.idf, ""idf("" + field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */     
/*  99 */     Explanation queryExpl = new Explanation();
/* 100 */     queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */     
/* 102 */     Explanation boostExpl = new Explanation(getQuery().getBoost(), ""boost"");
/* 103 */     if (getQuery().getBoost() != 1.0F)
/* 104 */       queryExpl.addDetail(boostExpl); 
/* 105 */     queryExpl.addDetail(idfExpl);
/*     */     
/* 107 */     Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 108 */     queryExpl.addDetail(queryNormExpl);
/*     */     
/* 110 */     queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 114 */     result.addDetail(queryExpl);
/*     */ 
/*     */     
/* 117 */     Explanation fieldExpl = new Explanation();
/* 118 */     fieldExpl.setDescription(""fieldWeight("" + field + "":"" + this.query.toString(field) + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */     
/* 121 */     Explanation tfExpl = scorer(reader).explain(doc);
/* 122 */     fieldExpl.addDetail(tfExpl);
/* 123 */     fieldExpl.addDetail(idfExpl);
/*     */     
/* 125 */     Explanation fieldNormExpl = new Explanation();
/* 126 */     byte[] fieldNorms = reader.norms(field);
/* 127 */     float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */     
/* 129 */     fieldNormExpl.setValue(fieldNorm);
/* 130 */     fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 131 */     fieldExpl.addDetail(fieldNormExpl);
/*     */     
/* 133 */     fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 137 */     result.addDetail(fieldExpl);
/*     */ 
/*     */     
/* 140 */     result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */     
/* 142 */     if (queryExpl.getValue() == 1.0F) {
/* 143 */       return fieldExpl;
/*     */     }
/* 145 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\search\spans\SpanWeight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexInput
/*     */   extends IndexInput
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*     */   private byte[] buffer;
/*  27 */   private long bufferStart = 0L;
/*  28 */   private int bufferLength = 0;
/*  29 */   private int bufferPosition = 0;
/*     */   
/*     */   public byte readByte() throws IOException {
/*  32 */     if (this.bufferPosition >= this.bufferLength)
/*  33 */       refill(); 
/*  34 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */ 
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len) throws IOException {
/*  39 */     if (len < 1024) {
/*  40 */       for (int i = 0; i < len; i++)
/*  41 */         b[i + offset] = readByte(); 
/*     */     } else {
/*  43 */       long start = getFilePointer();
/*  44 */       seekInternal(start);
/*  45 */       readInternal(b, offset, len);
/*     */       
/*  47 */       this.bufferStart = start + len;
/*  48 */       this.bufferPosition = 0;
/*  49 */       this.bufferLength = 0;
/*     */     } 
/*     */   }
/*     */   
/*     */   private void refill() throws IOException {
/*  54 */     long start = this.bufferStart + this.bufferPosition;
/*  55 */     long end = start + 1024L;
/*  56 */     if (end > length())
/*  57 */       end = length(); 
/*  58 */     this.bufferLength = (int)(end - start);
/*  59 */     if (this.bufferLength <= 0) {
/*  60 */       throw new IOException(""read past EOF"");
/*     */     }
/*  62 */     if (this.buffer == null)
/*  63 */       this.buffer = new byte[1024]; 
/*  64 */     readInternal(this.buffer, 0, this.bufferLength);
/*     */     
/*  66 */     this.bufferStart = start;
/*  67 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void readInternal(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */   
/*     */   public void seek(long pos) throws IOException {
/*  82 */     if (pos >= this.bufferStart && pos < this.bufferStart + this.bufferLength) {
/*  83 */       this.bufferPosition = (int)(pos - this.bufferStart);
/*     */     } else {
/*  85 */       this.bufferStart = pos;
/*  86 */       this.bufferPosition = 0;
/*  87 */       this.bufferLength = 0;
/*  88 */       seekInternal(pos);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void seekInternal(long paramLong) throws IOException;
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*  99 */     BufferedIndexInput clone = (BufferedIndexInput)super.clone();
/*     */     
/* 101 */     if (this.buffer != null) {
/* 102 */       clone.buffer = new byte[1024];
/* 103 */       System.arraycopy(this.buffer, 0, clone.buffer, 0, this.bufferLength);
/*     */     } 
/*     */     
/* 106 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\BufferedIndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexOutput
/*     */   extends IndexOutput
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*  25 */   private final byte[] buffer = new byte[1024];
/*  26 */   private long bufferStart = 0L;
/*  27 */   private int bufferPosition = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeByte(byte b) throws IOException {
/*  33 */     if (this.bufferPosition >= 1024)
/*  34 */       flush(); 
/*  35 */     this.buffer[this.bufferPosition++] = b;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeBytes(byte[] b, int length) throws IOException {
/*  44 */     int bytesLeft = 1024 - this.bufferPosition;
/*     */     
/*  46 */     if (bytesLeft >= length) {
/*     */       
/*  48 */       System.arraycopy(b, 0, this.buffer, this.bufferPosition, length);
/*  49 */       this.bufferPosition += length;
/*     */       
/*  51 */       if (1024 - this.bufferPosition == 0) {
/*  52 */         flush();
/*     */       }
/*     */     }
/*  55 */     else if (length > 1024) {
/*     */       
/*  57 */       if (this.bufferPosition > 0) {
/*  58 */         flush();
/*     */       }
/*  60 */       flushBuffer(b, length);
/*  61 */       this.bufferStart += length;
/*     */     } else {
/*     */       
/*  64 */       int pos = 0;
/*     */       
/*  66 */       while (pos < length) {
/*  67 */         int pieceLength = (length - pos < bytesLeft) ? (length - pos) : bytesLeft;
/*  68 */         System.arraycopy(b, pos, this.buffer, this.bufferPosition, pieceLength);
/*  69 */         pos += pieceLength;
/*  70 */         this.bufferPosition += pieceLength;
/*     */         
/*  72 */         bytesLeft = 1024 - this.bufferPosition;
/*  73 */         if (bytesLeft == 0) {
/*  74 */           flush();
/*  75 */           bytesLeft = 1024;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws IOException {
/*  84 */     flushBuffer(this.buffer, this.bufferPosition);
/*  85 */     this.bufferStart += this.bufferPosition;
/*  86 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void flushBuffer(byte[] paramArrayOfbyte, int paramInt) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public void close() throws IOException { flush(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 113 */     flush();
/* 114 */     this.bufferStart = pos;
/*     */   }
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\BufferedIndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Directory,"package org.apache.lucene.store;
import java.io.IOException;
public abstract class Directory {
  public abstract String[] list() throws IOException;
  public abstract boolean fileExists(String paramString) throws IOException;
  public abstract long fileModified(String paramString) throws IOException;
  public abstract void touchFile(String paramString) throws IOException;
  public abstract void deleteFile(String paramString) throws IOException;
  public abstract void renameFile(String paramString1, String paramString2) throws IOException;
  public abstract long fileLength(String paramString) throws IOException;
  public abstract IndexOutput createOutput(String paramString) throws IOException;
  public abstract IndexInput openInput(String paramString) throws IOException;
  public abstract Lock makeLock(String paramString);
  public abstract void close() throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\Directory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.FSDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileInputStream;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.FilenameFilter;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.OutputStream;
/*     */ import java.security.MessageDigest;
/*     */ import java.security.NoSuchAlgorithmException;
/*     */ import java.util.Hashtable;
/*     */ import org.apache.lucene.index.IndexFileNameFilter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FSDirectory
/*     */   extends Directory
/*     */ {
/*  45 */   private static final Hashtable DIRECTORIES = new Hashtable();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean disableLocks = false;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public static void setDisableLocks(boolean doDisableLocks) { disableLocks = doDisableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   public static boolean getDisableLocks() { return disableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  70 */   public static final String LOCK_DIR = System.getProperty(""org.apache.lucene.lockDir"", System.getProperty(""java.io.tmpdir"")); private static Class IMPL; private static MessageDigest DIGESTER; private byte[] buffer = null; public static FSDirectory getDirectory(String path, boolean create) throws IOException { return getDirectory(new File(path), create); } public static FSDirectory getDirectory(File file, boolean create) throws IOException { FSDirectory dir; file = new File(file.getCanonicalPath()); synchronized (DIRECTORIES) { dir = (FSDirectory)DIRECTORIES.get(file); if (dir == null) { try { dir = IMPL.newInstance(); }
/*     */         catch (Exception e) { throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e); }
/*     */          dir.init(file, create); DIRECTORIES.put(file, dir); }
/*     */       else if (create) { dir.create(); }
/*     */        }
/*     */      synchronized (dir) { dir.refCount++; }
/*     */      return dir; } private File directory = null; private int refCount;
/*     */   static  { try {
/*  78 */       String name = System.getProperty(""org.apache.lucene.FSDirectory.class"", FSDirectory.class.getName());
/*     */ 
/*     */       
/*  81 */       IMPL = Class.forName(name);
/*  82 */     } catch (ClassNotFoundException e) {
/*  83 */       throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e);
/*  84 */     } catch (SecurityException se) {
/*     */       try {
/*  86 */         IMPL = Class.forName(FSDirectory.class.getName());
/*  87 */       } catch (ClassNotFoundException e) {
/*  88 */         throw new RuntimeException(""cannot load default FSDirectory class: "" + e.toString(), e);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/*  97 */       DIGESTER = MessageDigest.getInstance(""MD5"");
/*  98 */     } catch (NoSuchAlgorithmException e) {
/*  99 */       throw new RuntimeException(e.toString(), e);
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 335 */     HEX_DIGITS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; } private File lockDir; private static final char[] HEX_DIGITS; private void init(File path, boolean create) throws IOException { this.directory = path; if (LOCK_DIR == null) { this.lockDir = this.directory; } else { this.lockDir = new File(LOCK_DIR); }  if (!this.lockDir.exists()) { if (!this.lockDir.mkdirs()) throw new IOException(""Cannot create directory: "" + this.lockDir.getAbsolutePath());  } else if (!this.lockDir.isDirectory()) { throw new IOException(""Found regular file where directory expected: "" + this.lockDir.getAbsolutePath()); }  if (create)
/*     */       create();  if (!this.directory.isDirectory())
/*     */       throw new IOException(path + "" not a directory"");  }
/*     */   private synchronized void create() throws IOException { if (!this.directory.exists() && !this.directory.mkdirs())
/*     */       throw new IOException(""Cannot create directory: "" + this.directory);  if (!this.directory.isDirectory())
/*     */       throw new IOException(this.directory + "" not a directory"");  String[] files = this.directory.list((FilenameFilter)new IndexFileNameFilter()); if (files == null)
/*     */       throw new IOException(""Cannot read directory "" + this.directory.getAbsolutePath());  for (int i = 0; i < files.length; i++) { File file = new File(this.directory, files[i]); if (!file.delete())
/*     */         throw new IOException(""Cannot delete "" + file);  }  String lockPrefix = getLockPrefix().toString(); files = this.lockDir.list(); if (files == null)
/*     */       throw new IOException(""Cannot read lock directory "" + this.lockDir.getAbsolutePath());  for (int i = 0; i < files.length; i++) { if (files[i].startsWith(lockPrefix)) { File lockFile = new File(this.lockDir, files[i]); if (!lockFile.delete())
/*     */           throw new IOException(""Cannot delete "" + lockFile);  }  }  }
/* 345 */   public Lock makeLock(String name) { StringBuffer buf = getLockPrefix();
/* 346 */     buf.append(""-"");
/* 347 */     buf.append(name);
/*     */ 
/*     */     
/* 350 */     final File lockFile = new File(this.lockDir, buf.toString());
/*     */     
/* 352 */     return new Lock() { private final File val$lockFile; private final FSDirectory this$0;
/*     */         public boolean obtain() throws IOException {
/* 354 */           if (disableLocks) {
/* 355 */             return true;
/*     */           }
/* 357 */           if (!FSDirectory.this.lockDir.exists() && 
/* 358 */             !FSDirectory.this.lockDir.mkdirs()) {
/* 359 */             throw new IOException(""Cannot create lock directory: "" + FSDirectory.this.lockDir);
/*     */           }
/*     */ 
/*     */           
/* 363 */           return lockFile.createNewFile();
/*     */         }
/*     */         public void release() {
/* 366 */           if (disableLocks)
/*     */             return; 
/* 368 */           lockFile.delete();
/*     */         }
/*     */         public boolean isLocked() {
/* 371 */           if (disableLocks)
/* 372 */             return false; 
/* 373 */           return lockFile.exists();
/*     */         }
/*     */ 
/*     */         
/* 377 */         public String toString() { return ""Lock@"" + lockFile; } }
/*     */       ; }
/*     */ 
/*     */ 
/*     */   
/*     */   public String[] list() { return this.directory.list(); }
/*     */ 
/*     */   
/*     */   public boolean fileExists(String name) {
/*     */     File file = new File(this.directory, name);
/*     */     return file.exists();
/*     */   }
/*     */ 
/*     */   
/*     */   public long fileModified(String name) {
/*     */     File file = new File(this.directory, name);
/*     */     return file.lastModified();
/*     */   }
/*     */   
/*     */   public static long fileModified(File directory, String name) {
/*     */     File file = new File(directory, name);
/*     */     return file.lastModified();
/*     */   }
/*     */   
/*     */   public void touchFile(String name) {
/*     */     File file = new File(this.directory, name);
/*     */     file.setLastModified(System.currentTimeMillis());
/*     */   }
/*     */   
/*     */   public synchronized void close() {
/* 407 */     if (--this.refCount <= 0)
/* 408 */       synchronized (DIRECTORIES)
/* 409 */       { DIRECTORIES.remove(this.directory); }  
/*     */   }
/*     */   public long fileLength(String name) { File file = new File(this.directory, name); return file.length(); }
/*     */   public void deleteFile(String name) throws IOException { File file = new File(this.directory, name); if (!file.delete()) throw new IOException(""Cannot delete "" + file);  }
/*     */   public synchronized void renameFile(String from, String to) throws IOException { File old = new File(this.directory, from); File nu = new File(this.directory, to); if (nu.exists() && !nu.delete()) throw new IOException(""Cannot delete "" + nu);  if (!old.renameTo(nu)) { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(old); out = new FileOutputStream(nu); if (this.buffer == null) this.buffer = new byte[1024];  int len; while ((len = in.read(this.buffer)) >= 0) out.write(this.buffer, 0, len);  old.delete(); } catch (IOException ioe) { IOException newExc = new IOException(""Cannot rename "" + old + "" to "" + nu); newExc.initCause(ioe); throw newExc; } finally { if (in != null) try { in.close(); } catch (IOException e) { throw new RuntimeException(""Cannot close input stream: "" + e.toString(), e); }   if (out != null)
/*     */           try { out.close(); } catch (IOException e) { throw new RuntimeException(""Cannot close output stream: "" + e.toString(), e); }   }  }  } public IndexOutput createOutput(String name) throws IOException { File file = new File(this.directory, name); if (file.exists() && !file.delete())
/*     */       throw new IOException(""Cannot overwrite: "" + file);  return new FSIndexOutput(file); } public IndexInput openInput(String name) throws IOException { return new FSIndexInput(new File(this.directory, name)); } private StringBuffer getLockPrefix() { // Byte code:
/*     */     //   0: aload_0
/*     */     //   1: getfield directory : Ljava/io/File;
/*     */     //   4: invokevirtual getCanonicalPath : ()Ljava/lang/String;
/*     */     //   7: astore_1
/*     */     //   8: goto -> 25
/*     */     //   11: astore_2
/*     */     //   12: new java/lang/RuntimeException
/*     */     //   15: dup
/*     */     //   16: aload_2
/*     */     //   17: invokevirtual toString : ()Ljava/lang/String;
/*     */     //   20: aload_2
/*     */     //   21: invokespecial <init> : (Ljava/lang/String;Ljava/lang/Throwable;)V
/*     */     //   24: athrow
/*     */     //   25: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   28: dup
/*     */     //   29: astore_3
/*     */     //   30: monitorenter
/*     */     //   31: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   34: aload_1
/*     */     //   35: invokevirtual getBytes : ()[B
/*     */     //   38: invokevirtual digest : ([B)[B
/*     */     //   41: astore_2
/*     */     //   42: aload_3
/*     */     //   43: monitorexit
/*     */     //   44: goto -> 54
/*     */     //   47: astore #4
/*     */     //   49: aload_3
/*     */     //   50: monitorexit
/*     */     //   51: aload #4
/*     */     //   53: athrow
/*     */     //   54: new java/lang/StringBuffer
/*     */     //   57: dup
/*     */     //   58: invokespecial <init> : ()V
/*     */     //   61: astore_3
/*     */     //   62: aload_3
/*     */     //   63: ldc 'lucene-'
/*     */     //   65: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
/*     */     //   68: pop
/*     */     //   69: iconst_0
/*     */     //   70: istore #4
/*     */     //   72: iload #4
/*     */     //   74: aload_2
/*     */     //   75: arraylength
/*     */     //   76: if_icmpge -> 121
/*     */     //   79: aload_2
/*     */     //   80: iload #4
/*     */     //   82: baload
/*     */     //   83: istore #5
/*     */     //   85: aload_3
/*     */     //   86: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   89: iload #5
/*     */     //   91: iconst_4
/*     */     //   92: ishr
/*     */     //   93: bipush #15
/*     */     //   95: iand
/*     */     //   96: caload
/*     */     //   97: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   100: pop
/*     */     //   101: aload_3
/*     */     //   102: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   105: iload #5
/*     */     //   107: bipush #15
/*     */     //   109: iand
/*     */     //   110: caload
/*     */     //   111: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   114: pop
/*     */     //   115: iinc #4, 1
/*     */     //   118: goto -> 72
/*     */     //   121: aload_3
/*     */     //   122: areturn
/*     */     // Line number table:
/*     */     //   Java source line number -> byte code offset
/*     */     //   #385	-> 0
/*     */     //   #388	-> 8
/*     */     //   #386	-> 11
/*     */     //   #387	-> 12
/*     */     //   #391	-> 25
/*     */     //   #392	-> 31
/*     */     //   #393	-> 42
/*     */     //   #394	-> 54
/*     */     //   #395	-> 62
/*     */     //   #396	-> 69
/*     */     //   #397	-> 79
/*     */     //   #398	-> 85
/*     */     //   #399	-> 101
/*     */     //   #396	-> 115
/*     */     //   #402	-> 121
/*     */     // Local variable table:
/*     */     //   start	length	slot	name	descriptor
/*     */     //   8	3	1	dirName	Ljava/lang/String;
/*     */     //   12	13	2	e	Ljava/io/IOException;
/*     */     //   42	5	2	digest	[B
/*     */     //   85	30	5	b	I
/*     */     //   72	49	4	i	I
/*     */     //   0	123	0	this	Lorg/apache/lucene/store/FSDirectory;
/*     */     //   25	98	1	dirName	Ljava/lang/String;
/*     */     //   54	69	2	digest	[B
/*     */     //   54	69	3	buf	Ljava/lang/StringBuffer;
/*     */     // Exception table:
/*     */     //   from	to	target	type
/*     */     //   0	8	11	java/io/IOException
/*     */     //   31	44	47	finally
/* 415 */     //   47	51	47	finally } public File getFile() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 420 */   public String toString() { return getClass().getName() + ""@"" + this.directory; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\FSDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.FSIndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FSIndexInput
/*     */   extends BufferedIndexInput
/*     */ {
/*     */   private class Descriptor
/*     */     extends RandomAccessFile
/*     */   {
/*     */     public long position;
/*     */     private final FSIndexInput this$0;
/*     */     
/* 430 */     public Descriptor(File file, String mode) throws IOException { super(file, mode); }
/*     */   }
/*     */ 
/*     */   
/* 434 */   private Descriptor file = null;
/*     */   boolean isClone;
/*     */   private long length;
/*     */   
/*     */   public FSIndexInput(File path) throws IOException {
/* 439 */     this.file = new Descriptor(path, ""r"");
/* 440 */     this.length = this.file.length();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 446 */     synchronized (this.file) {
/* 447 */       long position = getFilePointer();
/* 448 */       if (position != this.file.position) {
/* 449 */         this.file.seek(position);
/* 450 */         this.file.position = position;
/*     */       } 
/* 452 */       int total = 0;
/*     */       do {
/* 454 */         int i = this.file.read(b, offset + total, len - total);
/* 455 */         if (i == -1)
/* 456 */           throw new IOException(""read past EOF""); 
/* 457 */         this.file.position += i;
/* 458 */         total += i;
/* 459 */       } while (total < len);
/*     */     } 
/*     */   }
/*     */   
/*     */   public void close() throws IOException {
/* 464 */     if (!this.isClone) {
/* 465 */       this.file.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   protected void seekInternal(long position) {}
/*     */   
/* 472 */   public long length() { return this.length; }
/*     */ 
/*     */ 
/*     */   
/* 476 */   protected void finalize() throws IOException { close(); }
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 480 */     FSIndexInput clone = (FSIndexInput)super.clone();
/* 481 */     clone.isClone = true;
/* 482 */     return clone;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 489 */   boolean isFDValid() throws IOException { return this.file.getFD().valid(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\FSIndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.FSIndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FSIndexOutput
/*     */   extends BufferedIndexOutput
/*     */ {
/* 495 */   RandomAccessFile file = null;
/*     */ 
/*     */   
/* 498 */   public FSIndexOutput(File path) throws IOException { this.file = new RandomAccessFile(path, ""rw""); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 503 */   public void flushBuffer(byte[] b, int size) throws IOException { this.file.write(b, 0, size); }
/*     */   
/*     */   public void close() throws IOException {
/* 506 */     super.close();
/* 507 */     this.file.close();
/*     */   }
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 512 */     super.seek(pos);
/* 513 */     this.file.seek(pos);
/*     */   }
/*     */   
/* 516 */   public long length() throws IOException { return this.file.length(); }
/*     */ 
/*     */ 
/*     */   
/* 520 */   protected void finalize() throws IOException { this.file.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\FSIndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexInput
/*     */   implements Cloneable
/*     */ {
/*     */   private char[] chars;
/*     */   
/*     */   public abstract byte readByte() throws IOException;
/*     */   
/*     */   public abstract void readBytes(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */   
/*  46 */   public int readInt() throws IOException { return (readByte() & 0xFF) << 24 | (readByte() & 0xFF) << 16 | (readByte() & 0xFF) << 8 | readByte() & 0xFF; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int readVInt() throws IOException {
/*  56 */     byte b = readByte();
/*  57 */     int i = b & Byte.MAX_VALUE;
/*  58 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/*  59 */       b = readByte();
/*  60 */       i |= (b & Byte.MAX_VALUE) << shift;
/*     */     } 
/*  62 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   public long readLong() throws IOException { return readInt() << 32L | readInt() & 0xFFFFFFFFL; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long readVLong() throws IOException {
/*  76 */     byte b = readByte();
/*  77 */     long i = (b & Byte.MAX_VALUE);
/*  78 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/*  79 */       b = readByte();
/*  80 */       i |= (b & 0x7FL) << shift;
/*     */     } 
/*  82 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String readString() throws IOException {
/*  89 */     int length = readVInt();
/*  90 */     if (this.chars == null || length > this.chars.length)
/*  91 */       this.chars = new char[length]; 
/*  92 */     readChars(this.chars, 0, length);
/*  93 */     return new String(this.chars, 0, length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void readChars(char[] buffer, int start, int length) throws IOException {
/* 104 */     int end = start + length;
/* 105 */     for (int i = start; i < end; i++) {
/* 106 */       byte b = readByte();
/* 107 */       if ((b & 0x80) == 0) {
/* 108 */         buffer[i] = (char)(b & Byte.MAX_VALUE);
/* 109 */       } else if ((b & 0xE0) != 224) {
/* 110 */         buffer[i] = (char)((b & 0x1F) << 6 | readByte() & 0x3F);
/*     */       } else {
/*     */         
/* 113 */         buffer[i] = (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | readByte() & 0x3F);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long getFilePointer();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long length();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 146 */     IndexInput clone = null;
/*     */     try {
/* 148 */       clone = (IndexInput)super.clone();
/* 149 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 151 */     clone.chars = null;
/*     */     
/* 153 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\IndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexOutput
/*     */ {
/*     */   public abstract void writeByte(byte paramByte) throws IOException;
/*     */   
/*     */   public abstract void writeBytes(byte[] paramArrayOfbyte, int paramInt) throws IOException;
/*     */   
/*     */   public void writeInt(int i) throws IOException {
/*  44 */     writeByte((byte)(i >> 24));
/*  45 */     writeByte((byte)(i >> 16));
/*  46 */     writeByte((byte)(i >> 8));
/*  47 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVInt(int i) throws IOException {
/*  56 */     while ((i & 0xFFFFFF80) != 0) {
/*  57 */       writeByte((byte)(i & 0x7F | 0x80));
/*  58 */       i >>>= 7;
/*     */     } 
/*  60 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeLong(long i) throws IOException {
/*  67 */     writeInt((int)(i >> 32L));
/*  68 */     writeInt((int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVLong(long i) throws IOException {
/*  77 */     while ((i & 0xFFFFFFFFFFFFFF80L) != 0L) {
/*  78 */       writeByte((byte)(int)(i & 0x7FL | 0x80L));
/*  79 */       i >>>= 7L;
/*     */     } 
/*  81 */     writeByte((byte)(int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeString(String s) throws IOException {
/*  88 */     int length = s.length();
/*  89 */     writeVInt(length);
/*  90 */     writeChars(s, 0, length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeChars(String s, int start, int length) throws IOException {
/* 101 */     int end = start + length;
/* 102 */     for (int i = start; i < end; i++) {
/* 103 */       int code = s.charAt(i);
/* 104 */       if (code >= 1 && code <= 127) {
/* 105 */         writeByte((byte)code);
/* 106 */       } else if ((code >= 128 && code <= 2047) || code == 0) {
/* 107 */         writeByte((byte)(0xC0 | code >> 6));
/* 108 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } else {
/* 110 */         writeByte((byte)(0xE0 | code >>> 12));
/* 111 */         writeByte((byte)(0x80 | code >> 6 & 0x3F));
/* 112 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public abstract void flush() throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract long getFilePointer();
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\IndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Lock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Lock
/*     */ {
/*  35 */   public static long LOCK_POLL_INTERVAL = 1000L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract boolean obtain() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean obtain(long lockWaitTimeout) throws IOException {
/*  51 */     boolean locked = obtain();
/*  52 */     int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);
/*  53 */     int sleepCount = 0;
/*  54 */     while (!locked) {
/*  55 */       if (sleepCount++ == maxSleepCount) {
/*  56 */         throw new IOException(""Lock obtain timed out: "" + toString());
/*     */       }
/*     */       try {
/*  59 */         Thread.sleep(LOCK_POLL_INTERVAL);
/*  60 */       } catch (InterruptedException e) {
/*  61 */         throw new IOException(e.toString());
/*     */       } 
/*  63 */       locked = obtain();
/*     */     } 
/*  65 */     return locked;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void release();
/*     */ 
/*     */   
/*     */   public abstract boolean isLocked();
/*     */ 
/*     */   
/*     */   public static abstract class With
/*     */   {
/*     */     private Lock lock;
/*     */     
/*     */     private long lockWaitTimeout;
/*     */ 
/*     */     
/*     */     public With(Lock lock, long lockWaitTimeout) {
/*  84 */       this.lock = lock;
/*  85 */       this.lockWaitTimeout = lockWaitTimeout;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected abstract Object doBody() throws IOException;
/*     */ 
/*     */ 
/*     */     
/*     */     public Object run() throws IOException {
/*  96 */       boolean locked = false;
/*     */       try {
/*  98 */         locked = this.lock.obtain(this.lockWaitTimeout);
/*  99 */         return doBody();
/*     */       } finally {
/* 101 */         if (locked)
/* 102 */           this.lock.release(); 
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\Lock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.MMapDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.ByteBuffer;
/*     */ import java.nio.channels.FileChannel;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MMapDirectory
/*     */   extends FSDirectory
/*     */ {
/*     */   private static class MMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer buffer;
/*     */     private final long length;
/*     */     
/*     */     private MMapIndexInput(RandomAccessFile raf) throws IOException {
/*  41 */       this.length = raf.length();
/*  42 */       this.buffer = raf.getChannel().map(FileChannel.MapMode.READ_ONLY, 0L, this.length);
/*     */     }
/*     */ 
/*     */     
/*  46 */     public byte readByte() throws IOException { return this.buffer.get(); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  51 */     public void readBytes(byte[] b, int offset, int len) throws IOException { this.buffer.get(b, offset, len); }
/*     */ 
/*     */ 
/*     */     
/*  55 */     public long getFilePointer() { return this.buffer.position(); }
/*     */ 
/*     */ 
/*     */     
/*  59 */     public void seek(long pos) throws IOException { this.buffer.position((int)pos); }
/*     */ 
/*     */ 
/*     */     
/*  63 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/*  67 */       MMapIndexInput clone = (MMapIndexInput)super.clone();
/*  68 */       clone.buffer = this.buffer.duplicate();
/*  69 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/*     */ 
/*     */   
/*     */   private static class MultiMMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer[] buffers;
/*     */     
/*     */     private int[] bufSizes;
/*     */     
/*     */     private final long length;
/*     */     private int curBufIndex;
/*     */     private final int maxBufSize;
/*     */     private ByteBuffer curBuf;
/*     */     private int curAvail;
/*     */     
/*     */     public MultiMMapIndexInput(RandomAccessFile raf, int maxBufSize) throws IOException {
/*  91 */       this.length = raf.length();
/*  92 */       this.maxBufSize = maxBufSize;
/*     */       
/*  94 */       if (maxBufSize <= 0) {
/*  95 */         throw new IllegalArgumentException(""Non positive maxBufSize: "" + maxBufSize);
/*     */       }
/*     */       
/*  98 */       if (this.length / maxBufSize > 2147483647L) {
/*  99 */         throw new IllegalArgumentException(""RandomAccessFile too big for maximum buffer size: "" + raf.toString());
/*     */       }
/*     */ 
/*     */       
/* 103 */       int nrBuffers = (int)(this.length / maxBufSize);
/* 104 */       if ((nrBuffers * maxBufSize) < this.length) nrBuffers++;
/*     */       
/* 106 */       this.buffers = new ByteBuffer[nrBuffers];
/* 107 */       this.bufSizes = new int[nrBuffers];
/*     */       
/* 109 */       long bufferStart = 0L;
/* 110 */       FileChannel rafc = raf.getChannel();
/* 111 */       for (int bufNr = 0; bufNr < nrBuffers; bufNr++) {
/* 112 */         int bufSize = (this.length > bufferStart + maxBufSize) ? maxBufSize : (int)(this.length - bufferStart);
/*     */ 
/*     */         
/* 115 */         this.buffers[bufNr] = rafc.map(FileChannel.MapMode.READ_ONLY, bufferStart, bufSize);
/* 116 */         this.bufSizes[bufNr] = bufSize;
/* 117 */         bufferStart += bufSize;
/*     */       } 
/* 119 */       seek(0L);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public byte readByte() throws IOException {
/* 125 */       if (this.curAvail == 0) {
/* 126 */         this.curBufIndex++;
/* 127 */         this.curBuf = this.buffers[this.curBufIndex];
/* 128 */         this.curBuf.position(0);
/* 129 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 131 */       this.curAvail--;
/* 132 */       return this.curBuf.get();
/*     */     }
/*     */     
/*     */     public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 136 */       while (len > this.curAvail) {
/* 137 */         this.curBuf.get(b, offset, this.curAvail);
/* 138 */         len -= this.curAvail;
/* 139 */         offset += this.curAvail;
/* 140 */         this.curBufIndex++;
/* 141 */         this.curBuf = this.buffers[this.curBufIndex];
/* 142 */         this.curBuf.position(0);
/* 143 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 145 */       this.curBuf.get(b, offset, len);
/* 146 */       this.curAvail -= len;
/*     */     }
/*     */ 
/*     */     
/* 150 */     public long getFilePointer() { return this.curBufIndex * this.maxBufSize + this.curBuf.position(); }
/*     */ 
/*     */     
/*     */     public void seek(long pos) throws IOException {
/* 154 */       this.curBufIndex = (int)(pos / this.maxBufSize);
/* 155 */       this.curBuf = this.buffers[this.curBufIndex];
/* 156 */       int bufOffset = (int)(pos - (this.curBufIndex * this.maxBufSize));
/* 157 */       this.curBuf.position(bufOffset);
/* 158 */       this.curAvail = this.bufSizes[this.curBufIndex] - bufOffset;
/*     */     }
/*     */ 
/*     */     
/* 162 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/* 166 */       MultiMMapIndexInput clone = (MultiMMapIndexInput)super.clone();
/* 167 */       clone.buffers = new ByteBuffer[this.buffers.length];
/*     */ 
/*     */ 
/*     */       
/* 171 */       for (int bufNr = 0; bufNr < this.buffers.length; bufNr++) {
/* 172 */         clone.buffers[bufNr] = this.buffers[bufNr].duplicate();
/*     */       }
/*     */       try {
/* 175 */         clone.seek(getFilePointer());
/* 176 */       } catch (IOException ioe) {
/* 177 */         RuntimeException newException = new RuntimeException(ioe);
/* 178 */         newException.initCause(ioe);
/* 179 */         throw newException;
/*     */       } 
/* 181 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/* 187 */   private final int MAX_BBUF = Integer.MAX_VALUE;
/*     */   
/*     */   public IndexInput openInput(String name) throws IOException {
/* 190 */     File f = new File(getFile(), name);
/* 191 */     RandomAccessFile raf = new RandomAccessFile(f, ""r"");
/*     */     try {
/* 193 */       return (IndexInput)((raf.length() <= 2147483647L) ? new MMapIndexInput(raf) : new MultiMMapIndexInput(raf, 2147483647));
/*     */     }
/*     */     finally {
/*     */       
/* 197 */       raf.close();
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\MMapDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Hashtable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class RAMDirectory
/*     */   extends Directory
/*     */ {
/*  34 */   Hashtable files = new Hashtable();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RAMDirectory() {}
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   public RAMDirectory(Directory dir) throws IOException { this(dir, false); }
/*     */ 
/*     */   
/*     */   private RAMDirectory(Directory dir, boolean closeDir) throws IOException {
/*  55 */     String[] files = dir.list();
/*  56 */     byte[] buf = new byte[1024];
/*  57 */     for (int i = 0; i < files.length; i++) {
/*     */       
/*  59 */       IndexOutput os = createOutput(files[i]);
/*     */       
/*  61 */       IndexInput is = dir.openInput(files[i]);
/*     */       
/*  63 */       long len = is.length();
/*  64 */       long readCount = 0L;
/*  65 */       while (readCount < len) {
/*  66 */         int toRead = (readCount + 1024L > len) ? (int)(len - readCount) : 1024;
/*  67 */         is.readBytes(buf, 0, toRead);
/*  68 */         os.writeBytes(buf, toRead);
/*  69 */         readCount += toRead;
/*     */       } 
/*     */ 
/*     */       
/*  73 */       is.close();
/*  74 */       os.close();
/*     */     } 
/*  76 */     if (closeDir) {
/*  77 */       dir.close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public RAMDirectory(File dir) throws IOException { this(FSDirectory.getDirectory(dir, false), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public RAMDirectory(String dir) throws IOException { this(FSDirectory.getDirectory(dir, false), true); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String[] list() {
/* 100 */     String[] result = new String[this.files.size()];
/* 101 */     int i = 0;
/* 102 */     Enumeration names = this.files.keys();
/* 103 */     while (names.hasMoreElements())
/* 104 */       result[i++] = names.nextElement(); 
/* 105 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public final boolean fileExists(String name) {
/* 110 */     RAMFile file = (RAMFile)this.files.get(name);
/* 111 */     return (file != null);
/*     */   }
/*     */ 
/*     */   
/*     */   public final long fileModified(String name) {
/* 116 */     RAMFile file = (RAMFile)this.files.get(name);
/* 117 */     return file.lastModified;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void touchFile(String name) {
/*     */     long ts2;
/* 124 */     RAMFile file = (RAMFile)this.files.get(name);
/* 125 */     long ts1 = System.currentTimeMillis();
/*     */     do {
/*     */       try {
/* 128 */         Thread.sleep(0L, 1);
/* 129 */       } catch (InterruptedException e) {}
/* 130 */       ts2 = System.currentTimeMillis();
/*     */ 
/*     */     
/*     */     }
/* 134 */     while (ts1 == ts2);
/*     */     
/* 136 */     file.lastModified = ts2;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final long fileLength(String name) {
/* 144 */     RAMFile file = (RAMFile)this.files.get(name);
/* 145 */     return file.length;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public final void deleteFile(String name) { this.files.remove(name); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void renameFile(String from, String to) {
/* 155 */     RAMFile file = (RAMFile)this.files.get(from);
/* 156 */     this.files.remove(from);
/* 157 */     this.files.put(to, file);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final IndexOutput createOutput(String name) {
/* 163 */     RAMFile file = new RAMFile();
/* 164 */     this.files.put(name, file);
/* 165 */     return new RAMOutputStream(file);
/*     */   }
/*     */ 
/*     */   
/*     */   public final IndexInput openInput(String name) {
/* 170 */     RAMFile file = (RAMFile)this.files.get(name);
/* 171 */     return new RAMInputStream(file);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Lock makeLock(final String name) {
/* 178 */     return new Lock() { private final String val$name;
/*     */         public boolean obtain() throws IOException {
/* 180 */           synchronized (RAMDirectory.this.files) {
/* 181 */             if (!RAMDirectory.this.fileExists(name)) {
/* 182 */               RAMDirectory.this.createOutput(name).close();
/* 183 */               return true;
/*     */             } 
/* 185 */             return false;
/*     */           } 
/*     */         }
/*     */         private final RAMDirectory this$0;
/* 189 */         public void release() { RAMDirectory.this.deleteFile(name); }
/*     */ 
/*     */         
/* 192 */         public boolean isLocked() { return RAMDirectory.this.fileExists(name); } }
/*     */       ;
/*     */   }
/*     */   
/*     */   public final void close() {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\RAMDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMFile,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.util.Vector;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class RAMFile
/*    */ {
/* 22 */   Vector buffers = new Vector();
/*    */   long length;
/* 24 */   long lastModified = System.currentTimeMillis();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\RAMFile.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMInputStream,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class RAMInputStream
/*    */   extends BufferedIndexInput
/*    */   implements Cloneable
/*    */ {
/*    */   private RAMFile file;
/* 27 */   private long pointer = 0L;
/*    */   private long length;
/*    */   
/*    */   public RAMInputStream(RAMFile f) {
/* 31 */     this.file = f;
/* 32 */     this.length = this.file.length;
/*    */   }
/*    */   
/*    */   public void readInternal(byte[] dest, int destOffset, int len) {
/* 36 */     int remainder = len;
/* 37 */     long start = this.pointer;
/* 38 */     while (remainder != 0) {
/* 39 */       int bufferNumber = (int)(start / 1024L);
/* 40 */       int bufferOffset = (int)(start % 1024L);
/* 41 */       int bytesInBuffer = 1024 - bufferOffset;
/* 42 */       int bytesToCopy = (bytesInBuffer >= remainder) ? remainder : bytesInBuffer;
/* 43 */       byte[] buffer = this.file.buffers.elementAt(bufferNumber);
/* 44 */       System.arraycopy(buffer, bufferOffset, dest, destOffset, bytesToCopy);
/* 45 */       destOffset += bytesToCopy;
/* 46 */       start += bytesToCopy;
/* 47 */       remainder -= bytesToCopy;
/*    */     } 
/* 49 */     this.pointer += len;
/*    */   }
/*    */ 
/*    */   
/*    */   public void close() {}
/*    */ 
/*    */   
/* 56 */   public void seekInternal(long pos) { this.pointer = pos; }
/*    */ 
/*    */ 
/*    */   
/* 60 */   public long length() { return this.length; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\RAMInputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMOutputStream,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RAMOutputStream
/*     */   extends BufferedIndexOutput
/*     */ {
/*     */   private RAMFile file;
/*  29 */   private long pointer = 0L;
/*     */ 
/*     */ 
/*     */   
/*  33 */   public RAMOutputStream() { this(new RAMFile()); }
/*     */ 
/*     */ 
/*     */   
/*  37 */   RAMOutputStream(RAMFile f) { this.file = f; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeTo(IndexOutput out) throws IOException {
/*  42 */     flush();
/*  43 */     long end = this.file.length;
/*  44 */     long pos = 0L;
/*  45 */     int buffer = 0;
/*  46 */     while (pos < end) {
/*  47 */       int length = 1024;
/*  48 */       long nextPos = pos + length;
/*  49 */       if (nextPos > end) {
/*  50 */         length = (int)(end - pos);
/*     */       }
/*  52 */       out.writeBytes(this.file.buffers.elementAt(buffer++), length);
/*  53 */       pos = nextPos;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void reset() {
/*     */     try {
/*  60 */       seek(0L);
/*  61 */     } catch (IOException e) {
/*  62 */       throw new RuntimeException(e.toString());
/*     */     } 
/*     */     
/*  65 */     this.file.length = 0L;
/*     */   }
/*     */ 
/*     */   
/*     */   public void flushBuffer(byte[] src, int len) {
/*  70 */     int bufferPos = 0;
/*  71 */     while (bufferPos != len) {
/*  72 */       byte[] buffer; int bufferNumber = (int)(this.pointer / 1024L);
/*  73 */       int bufferOffset = (int)(this.pointer % 1024L);
/*  74 */       int bytesInBuffer = 1024 - bufferOffset;
/*  75 */       int remainInSrcBuffer = len - bufferPos;
/*  76 */       int bytesToCopy = (bytesInBuffer >= remainInSrcBuffer) ? remainInSrcBuffer : bytesInBuffer;
/*     */       
/*  78 */       if (bufferNumber == this.file.buffers.size()) {
/*  79 */         buffer = new byte[1024];
/*  80 */         this.file.buffers.addElement(buffer);
/*     */       } else {
/*  82 */         buffer = this.file.buffers.elementAt(bufferNumber);
/*     */       } 
/*     */       
/*  85 */       System.arraycopy(src, bufferPos, buffer, bufferOffset, bytesToCopy);
/*  86 */       bufferPos += bytesToCopy;
/*  87 */       this.pointer += bytesToCopy;
/*     */     } 
/*     */     
/*  90 */     if (this.pointer > this.file.length) {
/*  91 */       this.file.length = this.pointer;
/*     */     }
/*  93 */     this.file.lastModified = System.currentTimeMillis();
/*     */   }
/*     */ 
/*     */   
/*  97 */   public void close() throws IOException { super.close(); }
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 101 */     super.seek(pos);
/* 102 */     this.pointer = pos;
/*     */   }
/*     */   
/* 105 */   public long length() { return this.file.length; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucene\store\RAMOutputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.BitVector,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class BitVector
/*     */ {
/*     */   private byte[] bits;
/*     */   private int size;
/*  40 */   private int count = -1;
/*     */ 
/*     */   
/*     */   public BitVector(int n) {
/*  44 */     this.size = n;
/*  45 */     this.bits = new byte[(this.size >> 3) + 1];
/*     */   }
/*     */ 
/*     */   
/*     */   public final void set(int bit) {
/*  50 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] | 1 << (bit & 0x7));
/*  51 */     this.count = -1;
/*     */   }
/*     */ 
/*     */   
/*     */   public final void clear(int bit) {
/*  56 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] & (1 << (bit & 0x7) ^ 0xFFFFFFFF));
/*  57 */     this.count = -1;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   public final boolean get(int bit) { return ((this.bits[bit >> 3] & 1 << (bit & 0x7)) != 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int count() {
/*  77 */     if (this.count == -1) {
/*  78 */       int c = 0;
/*  79 */       int end = this.bits.length;
/*  80 */       for (int i = 0; i < end; i++)
/*  81 */         c += BYTE_COUNTS[this.bits[i] & 0xFF]; 
/*  82 */       this.count = c;
/*     */     } 
/*  84 */     return this.count;
/*     */   }
/*     */   
/*  87 */   private static final byte[] BYTE_COUNTS = new byte[] { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void write(Directory d, String name) throws IOException {
/* 111 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 113 */       output.writeInt(size());
/* 114 */       output.writeInt(count());
/* 115 */       output.writeBytes(this.bits, this.bits.length);
/*     */     } finally {
/* 117 */       output.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitVector(Directory d, String name) throws IOException {
/* 125 */     IndexInput input = d.openInput(name);
/*     */     try {
/* 127 */       this.size = input.readInt();
/* 128 */       this.count = input.readInt();
/* 129 */       this.bits = new byte[(this.size >> 3) + 1];
/* 130 */       input.readBytes(this.bits, 0, this.bits.length);
/*     */     } finally {
/* 132 */       input.close();
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\BitVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Constants,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class Constants
/*    */ {
/* 30 */   public static final String JAVA_VERSION = System.getProperty(""java.version"");
/*    */   
/* 32 */   public static final boolean JAVA_1_1 = JAVA_VERSION.startsWith(""1.1."");
/*    */   
/* 34 */   public static final boolean JAVA_1_2 = JAVA_VERSION.startsWith(""1.2."");
/*    */   
/* 36 */   public static final boolean JAVA_1_3 = JAVA_VERSION.startsWith(""1.3."");
/*    */ 
/*    */   
/* 39 */   public static final String OS_NAME = System.getProperty(""os.name"");
/*    */   
/* 41 */   public static final boolean LINUX = OS_NAME.startsWith(""Linux"");
/*    */   
/* 43 */   public static final boolean WINDOWS = OS_NAME.startsWith(""Windows"");
/*    */   
/* 45 */   public static final boolean SUN_OS = OS_NAME.startsWith(""SunOS"");
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\Constants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Parameter,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.io.ObjectStreamException;
/*    */ import java.io.Serializable;
/*    */ import java.io.StreamCorruptedException;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Parameter
/*    */   implements Serializable
/*    */ {
/* 30 */   static Map allParameters = new HashMap();
/*    */ 
/*    */   
/*    */   private String name;
/*    */ 
/*    */   
/*    */   private Parameter() {}
/*    */ 
/*    */   
/*    */   protected Parameter(String name) {
/* 40 */     this.name = name;
/* 41 */     String key = makeKey(name);
/*    */     
/* 43 */     if (allParameters.containsKey(key)) {
/* 44 */       throw new IllegalArgumentException(""Parameter name "" + key + "" already used!"");
/*    */     }
/* 46 */     allParameters.put(key, this);
/*    */   }
/*    */ 
/*    */   
/* 50 */   private String makeKey(String name) { return getClass() + "" "" + name; }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public String toString() { return this.name; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected Object readResolve() throws ObjectStreamException {
/* 65 */     Object par = allParameters.get(makeKey(this.name));
/*    */     
/* 67 */     if (par == null) {
/* 68 */       throw new StreamCorruptedException(""Unknown parameter value: "" + this.name);
/*    */     }
/* 70 */     return par;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\Parameter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.PriorityQueue,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class PriorityQueue
/*     */ {
/*     */   private Object[] heap;
/*     */   private int size;
/*     */   private int maxSize;
/*     */   
/*     */   protected abstract boolean lessThan(Object paramObject1, Object paramObject2);
/*     */   
/*     */   protected final void initialize(int maxSize) {
/*  33 */     this.size = 0;
/*  34 */     int heapSize = maxSize + 1;
/*  35 */     this.heap = new Object[heapSize];
/*  36 */     this.maxSize = maxSize;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void put(Object element) {
/*  45 */     this.size++;
/*  46 */     this.heap[this.size] = element;
/*  47 */     upHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(Object element) {
/*  57 */     if (this.size < this.maxSize) {
/*  58 */       put(element);
/*  59 */       return true;
/*     */     } 
/*  61 */     if (this.size > 0 && !lessThan(element, top())) {
/*  62 */       this.heap[1] = element;
/*  63 */       adjustTop();
/*  64 */       return true;
/*     */     } 
/*     */     
/*  67 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public final Object top() {
/*  72 */     if (this.size > 0) {
/*  73 */       return this.heap[1];
/*     */     }
/*  75 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final Object pop() {
/*  81 */     if (this.size > 0) {
/*  82 */       Object result = this.heap[1];
/*  83 */       this.heap[1] = this.heap[this.size];
/*  84 */       this.heap[this.size] = null;
/*  85 */       this.size--;
/*  86 */       downHeap();
/*  87 */       return result;
/*     */     } 
/*  89 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 100 */   public final void adjustTop() { downHeap(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear() {
/* 111 */     for (int i = 0; i <= this.size; i++)
/* 112 */       this.heap[i] = null; 
/* 113 */     this.size = 0;
/*     */   }
/*     */   
/*     */   private final void upHeap() {
/* 117 */     int i = this.size;
/* 118 */     Object node = this.heap[i];
/* 119 */     int j = i >>> 1;
/* 120 */     while (j > 0 && lessThan(node, this.heap[j])) {
/* 121 */       this.heap[i] = this.heap[j];
/* 122 */       i = j;
/* 123 */       j >>>= 1;
/*     */     } 
/* 125 */     this.heap[i] = node;
/*     */   }
/*     */   
/*     */   private final void downHeap() {
/* 129 */     int i = 1;
/* 130 */     Object node = this.heap[i];
/* 131 */     int j = i << 1;
/* 132 */     int k = j + 1;
/* 133 */     if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 134 */       j = k;
/*     */     }
/* 136 */     while (j <= this.size && lessThan(this.heap[j], node)) {
/* 137 */       this.heap[i] = this.heap[j];
/* 138 */       i = j;
/* 139 */       j = i << 1;
/* 140 */       k = j + 1;
/* 141 */       if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 142 */         j = k;
/*     */       }
/*     */     } 
/* 145 */     this.heap[i] = node;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\PriorityQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.SmallFloat,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SmallFloat
/*     */ {
/*     */   public static byte floatToByte(float f, int numMantissaBits, int zeroExp) {
/*  40 */     int fzero = 63 - zeroExp << numMantissaBits;
/*  41 */     int bits = Float.floatToRawIntBits(f);
/*  42 */     int smallfloat = bits >> 24 - numMantissaBits;
/*  43 */     if (smallfloat < fzero) {
/*  44 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*     */     
/*  47 */     if (smallfloat >= fzero + 256) {
/*  48 */       return -1;
/*     */     }
/*  50 */     return (byte)(smallfloat - fzero);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byteToFloat(byte b, int numMantissaBits, int zeroExp) {
/*  58 */     if (b == 0) return 0.0F; 
/*  59 */     int bits = (b & 0xFF) << 24 - numMantissaBits;
/*  60 */     bits += 63 - zeroExp << 24;
/*  61 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte315(float f) {
/*  77 */     int bits = Float.floatToRawIntBits(f);
/*  78 */     int smallfloat = bits >> 21;
/*  79 */     if (smallfloat < 384) {
/*  80 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*  82 */     if (smallfloat >= 640) {
/*  83 */       return -1;
/*     */     }
/*  85 */     return (byte)(smallfloat - 384);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte315ToFloat(byte b) {
/*  92 */     if (b == 0) return 0.0F; 
/*  93 */     int bits = (b & 0xFF) << 21;
/*  94 */     bits += 805306368;
/*  95 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte52(float f) {
/* 105 */     int bits = Float.floatToRawIntBits(f);
/* 106 */     int smallfloat = bits >> 19;
/* 107 */     if (smallfloat < 1952) {
/* 108 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/* 110 */     if (smallfloat >= 2208) {
/* 111 */       return -1;
/*     */     }
/* 113 */     return (byte)(smallfloat - 1952);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte52ToFloat(byte b) {
/* 120 */     if (b == 0) return 0.0F; 
/* 121 */     int bits = (b & 0xFF) << 19;
/* 122 */     bits += 1023410176;
/* 123 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\SmallFloat.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.StringHelper,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class StringHelper
/*    */ {
/*    */   public static final int stringDifference(String s1, String s2) {
/* 36 */     int len1 = s1.length();
/* 37 */     int len2 = s2.length();
/* 38 */     int len = (len1 < len2) ? len1 : len2;
/* 39 */     for (int i = 0; i < len; i++) {
/* 40 */       if (s1.charAt(i) != s2.charAt(i)) {
/* 41 */         return i;
/*    */       }
/*    */     } 
/* 44 */     return len;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\StringHelper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ToStringUtils,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ToStringUtils
/*    */ {
/*    */   public static String boost(float boost) {
/* 21 */     if (boost != 1.0F)
/* 22 */       return ""^"" + Float.toString(boost); 
/* 23 */     return """";
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.0.0.jar!\org\apache\lucen\\util\ToStringUtils.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
