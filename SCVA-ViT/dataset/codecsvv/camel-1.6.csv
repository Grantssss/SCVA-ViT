metric_name,file
org.apache.camel.management.JmxSystemPropertyKeys,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
/**
 * This module contains jmx related system property key constants.
 *
 * @version $Revision: 669756 $
 */
public final class JmxSystemPropertyKeys {
    // disable jmx
    public static final String DISABLED = ""org.apache.camel.jmx.disabled"";
    // jmx (rmi registry) port
    public static final String REGISTRY_PORT = ""org.apache.camel.jmx.rmiConnector.registryPort"";
    // jmx (rmi server connection) port
    public static final String CONNECTOR_PORT = ""org.apache.camel.jmx.rmiConnector.connectorPort"";
    // jmx domain name
    public static final String DOMAIN = ""org.apache.camel.jmx.mbeanServerDefaultDomain"";
    // the domain name for the camel mbeans
    public static final String MBEAN_DOMAIN = ""org.apache.camel.jmx.mbeanObjectDomainName"";
    // JMX service URL path 
    public static final String SERVICE_URL_PATH = ""org.apache.camel.jmx.serviceUrlPath"";
    // A flag that indicates whether the agent should be created
    public static final String CREATE_CONNECTOR = ""org.apache.camel.jmx.createRmiConnector"";
    // use jvm platform mbean server flag
    public static final String USE_PLATFORM_MBS = 
        ""org.apache.camel.jmx.usePlatformMBeanServer"";
    private JmxSystemPropertyKeys() {
        // not instantiated
    }
}
"
org.apache.camel.management.ManagedEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Endpoint"", currencyTimeLimit = 15)
public class ManagedEndpoint {
    private Endpoint<? extends Exchange> endpoint;
    public ManagedEndpoint(Endpoint<? extends Exchange> endpoint) {
        this.endpoint = endpoint;
    }
    public Endpoint<? extends Exchange> getEndpoint() {
        return endpoint;
    }
    @ManagedAttribute(description = ""Endpoint Uri"")
    public String getUri() throws Exception {
        return endpoint.getEndpointUri();
    }
    @ManagedAttribute(description = ""Singleton"")
    public boolean getSingleton() throws Exception {
        return endpoint.isSingleton();
    }
}
"
org.apache.camel.management.ManagedRoute,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Route"", currencyTimeLimit = 15)
public class ManagedRoute extends PerformanceCounter {
    public static final String VALUE_UNKNOWN = ""Unknown"";
    private Route<? extends Exchange> route;
    private String description;
    ManagedRoute(Route<? extends Exchange> route) {
        this.route = route;
        this.description = route.toString();
    }
    public Route<? extends Exchange> getRoute() {
        return route;
    }
    @ManagedAttribute(description = ""Route Endpoint Uri"")
    public String getEndpointUri() {
        Endpoint<? extends Exchange> ep = route.getEndpoint();
        return ep != null ? ep.getEndpointUri() : VALUE_UNKNOWN;
    }
    @ManagedAttribute(description = ""Route description"")
    public String getDescription() {
        return description;
    }
    @ManagedOperation(description = ""Start Route"")
    public void start() throws IOException {
        throw new IOException(""Not supported"");
    }
    @ManagedOperation(description = ""Stop Route"")
    public void stop() throws IOException {
        throw new IOException(""Not supported"");
    }
}
"
org.apache.camel.management.ManagedService,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Service"", currencyTimeLimit = 15)
public class ManagedService {
    private ServiceSupport service;
    public ManagedService(ServiceSupport service) {
        this.service = service;
    }
    public Service getService() {
        return service;
    }
    @ManagedAttribute(description = ""Service running state"")
    public boolean isStarted() throws IOException {
        return service.isStarted();
    }
    @ManagedOperation(description = ""Start Service"")
    public void start() throws IOException {
        try {
            service.start();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
    @ManagedOperation(description = ""Stop Service"")
    public void stop() throws IOException {
        try {
            service.stop();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
}
"
org.apache.camel.management.MultiInstanceProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Set;
import javax.management.ObjectName;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * A unit test to verify mbean registration of multi-instances of a processor
 *
 * @version $Revision: 702970 $
 */
public class MultiInstanceProcessorTest extends JmxInstrumentationUsingDefaultsTest {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:end"").to(""mock:end"");
            }
        };
    }
    /**
     * It retrieves a mbean for each ""to"" processor instance in the query "":type=processor""
     */
    @Override
    public void testMBeansRegistered() throws Exception {
        if (System.getProperty(JmxSystemPropertyKeys.USE_PLATFORM_MBS) != null
                && !Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS)) {
            assertEquals(domainName, mbsc.getDefaultDomain());
        }
        resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        Set s = mbsc.queryNames(
                new ObjectName(domainName + "":type=endpoints,*""), null);
        assertEquals(""Could not find 2 endpoints: "" + s, 2, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":name=context,*""), null);
        assertEquals(""Could not find 1 context: "" + s, 1, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=processors,*""), null);
        assertEquals(""Could not find 2 processor: "" + s, 2, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=routes,*""), null);
        assertEquals(""Could not find 1 route: "" + s, 1, s.size());
    }
    @Override
    public void testCounters() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(
                new Object[] {""<hello>world!</hello>"", ""<hello>world!</hello>""});
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        verifyCounter(mbsc, new ObjectName(domainName + "":type=routes,*""));
        verifyCounter(mbsc, new ObjectName(domainName + "":type=processors,nodeid=to3,*""));
        verifyCounter(mbsc, new ObjectName(domainName + "":type=processors,nodeid=to4,*""));
    }
}
"
org.apache.camel.management.PerformanceCounter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Date;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""PerformanceCounter"", currencyTimeLimit = 15)
public class PerformanceCounter extends Counter {
    private AtomicLong numCompleted = new AtomicLong(0L);
    private double minProcessingTime;
    private double maxProcessingTime;
    private double totalProcessingTime;
    private Date lastExchangeCompletionTime;
    private Date lastExchangeFailureTime;
    private Date firstExchangeCompletionTime;
    private Date firstExchangeFailureTime;
    @Override
    @ManagedOperation(description = ""Reset counters"")
    public synchronized void reset() {
        super.reset();
        numCompleted.set(0L);
        minProcessingTime = 0.0;
        maxProcessingTime = 0.0;
        totalProcessingTime = 0.0;
        lastExchangeCompletionTime = null;
        lastExchangeFailureTime = null;
        firstExchangeCompletionTime = null;
        firstExchangeFailureTime = null;
    }
    @ManagedAttribute(description = ""Number of successful exchanges"")
    public long getNumCompleted() throws Exception {
        return numCompleted.get();
    }
    @ManagedAttribute(description = ""Number of failed exchanges"")
    public long getNumFailed() throws Exception {
        return numExchanges.get() - numCompleted.get();
    }
    @ManagedAttribute(description = ""Min Processing Time [milliseconds]"")
    public synchronized double getMinProcessingTimeMillis() throws Exception {
        return minProcessingTime;
    }
    @ManagedAttribute(description = ""Mean Processing Time [milliseconds]"")
    public synchronized double getMeanProcessingTimeMillis() throws Exception {
        long count = numCompleted.get();
        return count > 0 ? totalProcessingTime / count : 0.0;
    }
    @ManagedAttribute(description = ""Max Processing Time [milliseconds]"")
    public synchronized double getMaxProcessingTimeMillis() throws Exception {
        return maxProcessingTime;
    }
    @ManagedAttribute(description = ""Total Processing Time [milliseconds]"")
    public synchronized double getTotalProcessingTimeMillis() throws Exception {
        return totalProcessingTime;
    }
    @ManagedAttribute(description = ""Last Exchange Completed Timestamp"")
    public synchronized Date getLastExchangeCompletionTime() {
        return lastExchangeCompletionTime;
    }
    @ManagedAttribute(description = ""First Exchange Completed Timestamp"")
    public synchronized Date getFirstExchangeCompletionTime() {
        return firstExchangeCompletionTime;
    }
    @ManagedAttribute(description = ""Last Exchange Failed Timestamp"")
    public synchronized Date getLastExchangeFailureTime() {
        return lastExchangeFailureTime;
    }
    @ManagedAttribute(description = ""First Exchange Failed Timestamp"")
    public synchronized Date getFirstExchangeFailureTime() {
        return firstExchangeFailureTime;
    }
    /**
     * This method is called when an exchange has been processed successfully.
     * 
     * @param time in milliseconds it spent on processing the exchange
     */
    public synchronized void completedExchange(double time) {
        increment();
        numCompleted.incrementAndGet();
        totalProcessingTime += time;
        if (minProcessingTime <= 0 || time < minProcessingTime) {
            minProcessingTime = time;
        }
        if (time > maxProcessingTime) {
            maxProcessingTime = time;
        }
        Date timestamp = new Date();
        if (firstExchangeCompletionTime == null) {
            firstExchangeCompletionTime = timestamp;
        }
        lastExchangeCompletionTime = timestamp;
    }
    /**
     * This method is called when an exchange has been processed and failed.
     */
    public synchronized void failedExchange() {
        increment();
        Date timestamp = new Date();
        if (firstExchangeFailureTime == null) {
            firstExchangeFailureTime = timestamp;
        }
        lastExchangeFailureTime = timestamp;
    }
}
"
org.apache.camel.model.AggregatorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Aggregator;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;aggregator/&gt; element
 *
 * @version $Revision: 724629 $
 */
@XmlRootElement(name = ""aggregator"")
@XmlAccessorType(XmlAccessType.FIELD)
public class AggregatorType extends ExpressionNode {
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlTransient
    private AggregationCollection aggregationCollection;
    @XmlAttribute(required = false)
    private Integer batchSize;
    @XmlAttribute(required = false)
    private Integer outBatchSize;
    @XmlAttribute(required = false)
    private Long batchTimeout;
    @XmlAttribute(required = false)
    private String strategyRef;
    @XmlAttribute(required = false)
    private String collectionRef;    
    @XmlElement(name = ""completedPredicate"", required = false)
    private ExpressionSubElementType completedPredicate;
    public AggregatorType() {
    }
    public AggregatorType(Expression correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(ExpressionType correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        super(correlationExpression);
        this.aggregationStrategy = aggregationStrategy;
    }
    @Override
    public String toString() {
        return ""Aggregator["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""aggregator"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createAggregator(routeContext);
    }
    protected Aggregator createAggregator(RouteContext routeContext) throws Exception {
        final Processor processor = routeContext.createProcessor(this);
        final Aggregator aggregator;
        if (getAggregationCollection() == null) {
            setAggregationCollection(createAggregationCollection(routeContext));
        }
        if (aggregationCollection != null) {
            // create the aggregator using the collection
            // pre configure the collection if its expression and strategy is not set, then
            // use the ones that is pre configured with this type
            if (aggregationCollection.getCorrelationExpression() == null) {
                aggregationCollection.setCorrelationExpression(getExpression());
            }
            if (aggregationCollection.getAggregationStrategy() == null) {
                AggregationStrategy strategy = createAggregationStrategy(routeContext);
                aggregationCollection.setAggregationStrategy(strategy);
            }
            aggregator = new Aggregator(processor, aggregationCollection);
        } else {
            // create the aggregator using a default collection
            AggregationStrategy strategy = createAggregationStrategy(routeContext);
            Expression aggregateExpression = getExpression().createExpression(routeContext);
            Predicate predicate = null;
            if (getCompletedPredicate() != null) {
                predicate = getCompletedPredicate().createPredicate(routeContext);
            }
            if (predicate != null) {
                aggregator = new Aggregator(processor, aggregateExpression, strategy, predicate);
            } else {
                aggregator = new Aggregator(processor, aggregateExpression, strategy);
            }
        }
        if (batchSize != null) {
            aggregator.setBatchSize(batchSize);
        }
        if (batchTimeout != null) {
            aggregator.setBatchTimeout(batchTimeout);
        }
        if (outBatchSize != null) {
            aggregator.setOutBatchSize(outBatchSize);
        }
        return aggregator;
    }
    private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
        AggregationStrategy strategy = getAggregationStrategy();
        if (strategy == null && strategyRef != null) {
            strategy = routeContext.lookup(strategyRef, AggregationStrategy.class);
        }
        if (strategy == null) {
            // fallback to use latest
            strategy = new UseLatestAggregationStrategy();
        }
        return strategy;
    }
    private AggregationCollection createAggregationCollection(RouteContext routeContext) {
        AggregationCollection collection = getAggregationCollection();
        if (collection == null && collectionRef != null) {
            collection = routeContext.lookup(collectionRef, AggregationCollection.class);
        }
        return collection;
    }    
    public AggregationCollection getAggregationCollection() {
        return aggregationCollection;
    }
    public void setAggregationCollection(AggregationCollection aggregationCollection) {
        this.aggregationCollection = aggregationCollection;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
    public Integer getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }
    public Integer getOutBatchSize() {
        return outBatchSize;
    }
    public void setOutBatchSize(Integer outBatchSize) {
        this.outBatchSize = outBatchSize;
    }
    public Long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(Long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    public String getStrategyRef() {
        return strategyRef;
    }
    public void setStrategyRef(String strategyRef) {
        this.strategyRef = strategyRef;
    }
    public void setCompletedPredicate(ExpressionSubElementType completedPredicate) {
        this.completedPredicate = completedPredicate;
    }
    public ExpressionSubElementType getCompletedPredicate() {
        return completedPredicate;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public AggregatorType batchSize(int batchSize) {
        setBatchSize(batchSize);
        return this;
    }
    public AggregatorType outBatchSize(int batchSize) {
        setOutBatchSize(batchSize);
        return this;
    }
    public AggregatorType batchTimeout(long batchTimeout) {
        setBatchTimeout(batchTimeout);
        return this;
    }
    public AggregatorType aggregationCollection(AggregationCollection aggregationCollection) {
        setAggregationCollection(aggregationCollection);
        return this;
    }
    public AggregatorType aggregationStrategy(AggregationStrategy aggregationStrategy) {
        setAggregationStrategy(aggregationStrategy);
        return this;
    }
    public AggregatorType strategyRef(String strategyRef) {
        setStrategyRef(strategyRef);
        return this;
    }
    /**
     * Sets the predicate used to determine if the aggregation is completed
     *
     * @return the clause used to create the predicate
     */
    public ExpressionClause<AggregatorType> completedPredicate() {
        checkNoCompletedPredicate();
        ExpressionClause<AggregatorType> clause = new ExpressionClause<AggregatorType>(this);
        setCompletedPredicate(new ExpressionSubElementType((Expression)clause));
        return clause;
    }
    /**
     * Sets the predicate used to determine if the aggregation is completed
     */
    public AggregatorType completedPredicate(Predicate predicate) {
        checkNoCompletedPredicate();
        setCompletedPredicate(new ExpressionSubElementType(predicate));
        return this;
    }
    protected void checkNoCompletedPredicate() {
        if (getCompletedPredicate() != null) {
            throw new IllegalArgumentException(""There is already a completedPredicate defined for this aggregator: "" + this);
        }
    }
}
"
org.apache.camel.model.BeanRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.bean.RegistryBean;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;bean/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""bean"")
@XmlAccessorType(XmlAccessType.FIELD)
public class BeanRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    @XmlAttribute(required = false)
    private String method;
    @XmlAttribute(required = false)
    private Class beanType;
    @XmlTransient
    private Object bean;
    public BeanRef() {
    }
    public BeanRef(String ref) {
        this.ref = ref;
    }
    public BeanRef(String ref, String method) {
        this.ref = ref;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""Bean["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""bean"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    public void setBean(Object bean) {
        this.bean = bean;
    }
    public Class getBeanType() {
        return beanType;
    }
    public void setBeanType(Class beanType) {
        this.beanType = beanType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        BeanProcessor answer;
        if (ref != null) {
            answer = new BeanProcessor(new RegistryBean(routeContext.getCamelContext(), ref));
        } else {
            if (bean == null) {
                ObjectHelper.notNull(beanType, ""bean, ref or beanType"");
                bean = CamelContextHelper.newInstance(routeContext.getCamelContext(), beanType);
            }
            answer = new BeanProcessor(bean, routeContext.getCamelContext());
        }
        if (method != null) {
            answer.setMethod(method);
        }
        return answer;
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            String methodText = """";
            if (method != null) {
                methodText = "" method: "" + method;
            }
            return ""ref: "" + ref + methodText;
        } else if (bean != null) {
            return bean.toString();
        } else if (beanType != null) {
            return beanType.getName();
        } else {
            return """";
        }
    }
}
"
org.apache.camel.model.Block,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
/**
 * Interface to add block featuring to the XML element type.
 *
 * @version $Revision: 660266 $
 */
public interface Block {
    void addOutput(ProcessorType processorType);
}
"
org.apache.camel.model.CatchType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;catch/&gt; element
 *
 * @version $Revision: 725074 $
 */
@XmlRootElement(name = ""catch"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CatchType extends ProcessorType<CatchType> {
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    public CatchType() {
    }
    public CatchType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public CatchType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Catch[ "" + getExceptionClasses() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""catch"";
    }
    @Override
    public String getLabel() {
        return getExceptionClasses().toString();
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ChoiceType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents an XML &lt;choice/&gt; element
 *
 * @version $Revision: 719980 $
 */
@XmlRootElement(name = ""choice"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ChoiceType extends ProcessorType<ChoiceType> {
    private static final transient Log LOG = LogFactory.getLog(ChoiceType.class);
    @XmlElementRef
    private List<WhenType> whenClauses = new ArrayList<WhenType>();
    @XmlElement(required = false)
    private OtherwiseType otherwise;
    @Override
    public String toString() {
        if (getOtherwise() != null) {
            return ""Choice["" + getWhenClauses() + "" "" + getOtherwise() + ""]"";
        } else {
            return ""Choice["" + getWhenClauses() + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""choice"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
        for (WhenType whenClaus : whenClauses) {
            filters.add(whenClaus.createProcessor(routeContext));
        }
        Processor otherwiseProcessor = null;
        if (otherwise != null) {
            otherwiseProcessor = otherwise.createProcessor(routeContext);
        } else {
            LOG.warn(""No otherwise clause was specified for a choice block -- any unmatched exchanges will be dropped"");
        }
        return new ChoiceProcessor(filters, otherwiseProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public ChoiceType when(Predicate predicate) {
        getWhenClauses().add(new WhenType(predicate));
        return this;
    }
    public ExpressionClause<ChoiceType> when() {
        WhenType when = new WhenType();
        getWhenClauses().add(when);
        ExpressionClause<ChoiceType> clause = new ExpressionClause<ChoiceType>(this);
        when.setExpression(clause);
        return clause;
    }
    public ChoiceType otherwise() {
        OtherwiseType answer = new OtherwiseType();
        setOtherwise(answer);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public String getLabel() {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        List<WhenType> list = getWhenClauses();
        for (WhenType whenType : list) {
            buffer.append(whenType.getLabel());
        }
        return buffer.toString();
    }
    public List<WhenType> getWhenClauses() {
        return whenClauses;
    }
    public void setWhenClauses(List<WhenType> whenClauses) {
        this.whenClauses = whenClauses;
    }
    public List<ProcessorType<?>> getOutputs() {
        if (otherwise != null) {
            return otherwise.getOutputs();
        } else if (whenClauses.isEmpty()) {
            return Collections.EMPTY_LIST;
        } else {
            WhenType when = whenClauses.get(whenClauses.size() - 1);
            return when.getOutputs();
        }
    }
    public OtherwiseType getOtherwise() {
        return otherwise;
    }
    public void setOtherwise(OtherwiseType otherwise) {
        this.otherwise = otherwise;
    }
}
"
org.apache.camel.model.ConvertBodyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.processor.ConvertBodyProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;convertBodyTo/&gt; element
 */
@XmlRootElement(name = ""convertBodyTo"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ConvertBodyType extends ProcessorType<ProcessorType> {
    @XmlAttribute
    private String type;
    @XmlTransient
    private Class typeClass;
    public ConvertBodyType() {
    }
    public ConvertBodyType(String type) {
        setType(type);
    }
    public ConvertBodyType(Class typeClass) {
        setTypeClass(typeClass);
        setType(typeClass.getName());
    }
    @Override
    public String toString() {        
        return ""convertBodyTo["" + getType() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""convertBodyTo"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new ConvertBodyProcessor(getTypeClass());
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    protected Class createTypeClass() {
        return ObjectHelper.loadClass(getType(), getClass().getClassLoader());
    }
    public void setType(String type) {
        this.type = type;
    }
    public String getType() {
        return type;
    }
    public void setTypeClass(Class typeClass) {
        this.typeClass = typeClass;
    }
    public Class getTypeClass() {
        if (typeClass == null) {
            Class clazz = createTypeClass();
            if (clazz == null) {
                throw new RuntimeCamelException(""Can't load the class with the class name: "" + getType());
            }
            setTypeClass(clazz);
        }
        return typeClass;
    }
}
"
org.apache.camel.model.DelayerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Delayer;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;delayer/&gt; element
 *
 * @version $Revision: 719456 $
 */
@XmlRootElement(name = ""delayer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DelayerType extends ExpressionNode {
    @XmlElement
    private Long delay = 0L;
    public DelayerType() {
    }
    public DelayerType(Expression processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(ExpressionType processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(Expression processAtExpression, long delay) {
        super(processAtExpression);
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""delayer"";
    }
    public Long getDelay() {
        return delay;
    }
    public void setDelay(Long delay) {
        this.delay = delay;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        Expression processAtExpression = createAbsoluteTimeDelayExpression(routeContext);
        return new Delayer(childProcessor, processAtExpression, delay);
    }
    private Expression createAbsoluteTimeDelayExpression(RouteContext routeContext) {
        ExpressionType expr = getExpression();
        if (expr != null) {
            if (ObjectHelper.isNotNullAndNonEmpty(expr.getExpression()) 
                || expr.getExpressionValue() != null) {
                return expr.createExpression(routeContext);
            } 
        } 
        return null;
    }
}
"
org.apache.camel.model.Description,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlValue;
/**
 * Represents a description element which can be used on any element in the EIP route
 *
 * @version $Revision: 662301 $
 */
@XmlRootElement(name = ""description"")
@XmlAccessorType(XmlAccessType.FIELD)
public class Description {
    @XmlAttribute(required = false)
    private String lang;
    @XmlValue
    private String text;
    public String getLang() {
        return lang;
    }
    public void setLang(String lang) {
        this.lang = lang;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
}
"
org.apache.camel.model.ExceptionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.language.constant.ConstantLanguage;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.builder.PredicateBuilder.toPredicate;
/**
 * Represents an XML &lt;onException/&gt; element
 *
 * @version $Revision: 719980 $
 */
@XmlRootElement(name = ""onException"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExceptionType extends ProcessorType<ProcessorType> {
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElement(name = ""onWhen"", required = false)
    private WhenType onWhen;
    @XmlElement(name = ""redeliveryPolicy"", required = false)
    private RedeliveryPolicyType redeliveryPolicy;
    @XmlElement(name = ""handled"", required = false)
    private ExpressionSubElementType handled;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    @XmlTransient
    private Processor errorHandler;
    @XmlTransient
    private Predicate handledPolicy;
    public ExceptionType() {
    }
    public ExceptionType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public ExceptionType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Exception["" + getExceptionClasses() + (onWhen != null ? "" "" + onWhen : """") + "" -> "" + getOutputs() + ""]"";
    }
    /**
     * Catches an exception type.
     */
    @Override
    public ExceptionType onException(Class exceptionType) {
        getExceptionClasses().add(exceptionType);
        return this;
    }
    /**
     * Allows an exception handler to create a new redelivery policy for this exception type
     * @param context the camel context
     * @param parentPolicy the current redelivery policy
     * @return a newly created redelivery policy, or return the original policy if no customization is required
     * for this exception handler.
     */
    public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
        if (redeliveryPolicy != null) {
            return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);
        } else if (errorHandler != null) {
            // lets create a new error handler that has no retries
            RedeliveryPolicy answer = parentPolicy.copy();
            answer.setMaximumRedeliveries(0);
            return answer;
        }
        return parentPolicy;
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        setHandledFromExpressionType(routeContext);
        // lets attach a processor to an error handler
        errorHandler = routeContext.createProcessor(this);
        ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
        builder.addErrorHandlers(this);
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public ExceptionType handled(boolean handled) {
        ConstantLanguage constant = new ConstantLanguage();
        return handled(constant.createPredicate(Boolean.toString(handled)));
    }
    public ExceptionType handled(Predicate handled) {
        setHandledPolicy(handled);
        return this;
    }
    public ExceptionType handled(Expression handled) {
        setHandledPolicy(toPredicate(handled));
        return this;
    }
    public ExceptionType onWhen(Predicate predicate) {
        setOnWhen(new WhenType(predicate));
        return this;
    }
    public ExpressionClause<ExceptionType> onWhen() {
        onWhen = new WhenType();
        ExpressionClause<ExceptionType> clause = new ExpressionClause<ExceptionType>(this);
        onWhen.setExpression(clause);
        return clause;
    }
    public ExceptionType backOffMultiplier(double backOffMultiplier) {
        getOrCreateRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public ExceptionType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        getOrCreateRedeliveryPolicy().collisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public ExceptionType collisionAvoidancePercent(short collisionAvoidancePercent) {
        getOrCreateRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public ExceptionType initialRedeliveryDelay(long initialRedeliveryDelay) {
        getOrCreateRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public ExceptionType retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        getOrCreateRedeliveryPolicy().retriesExhaustedLogLevel(retriesExhaustedLogLevel);
        return this;
    }
    public ExceptionType retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        getOrCreateRedeliveryPolicy().retryAttemptedLogLevel(retryAttemptedLogLevel);
        return this;
    }
    public ExceptionType maximumRedeliveries(int maximumRedeliveries) {
        getOrCreateRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public ExceptionType useCollisionAvoidance() {
        getOrCreateRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public ExceptionType useExponentialBackOff() {
        getOrCreateRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    public ExceptionType maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        getOrCreateRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    public Processor getErrorHandler() {
        return errorHandler;
    }
    public RedeliveryPolicyType getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    public void setRedeliveryPolicy(RedeliveryPolicyType redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public Predicate getHandledPolicy() {
        return handledPolicy;
    }
    public void setHandled(ExpressionSubElementType handled) {
        this.handled = handled;
    }
    public ExpressionSubElementType getHandled() {
        return handled;
    }    
    private void setHandledFromExpressionType(RouteContext routeContext) {
        if (getHandled() != null && handledPolicy == null && routeContext != null) {  
            handled(getHandled().createPredicate(routeContext));
        }
    }
    public void setHandledPolicy(Predicate handledPolicy) {
        this.handledPolicy = handledPolicy;
    }
    public WhenType getOnWhen() {
        return onWhen;
    }
    public void setOnWhen(WhenType onWhen) {
        this.onWhen = onWhen;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RedeliveryPolicyType getOrCreateRedeliveryPolicy() {
        if (redeliveryPolicy == null) {
            redeliveryPolicy = new RedeliveryPolicyType();
        }
        return redeliveryPolicy;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ExpressionNode,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * A base class for nodes which contain an expression and a number of outputs
 *
 * @version $Revision: 671918 $
 */
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionNode extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private ExpressionType expression;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public ExpressionNode() {
    }
    public ExpressionNode(ExpressionType expression) {
        this.expression = expression;
    }
    public ExpressionNode(Expression expression) {
        if (expression != null) {
            setExpression(new ExpressionType(expression));
        }
    }
    public ExpressionNode(Predicate predicate) {
        if (predicate != null) {
            setExpression(new ExpressionType(predicate));
        }
    }
    @Override
    public String getShortName() {
        return ""exp"";
    }
    public ExpressionType getExpression() {
        return expression;
    }
    public void setExpression(ExpressionType expression) {
        this.expression = expression;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    @Override
    public String getLabel() {
        if (getExpression() == null) {
            return """";
        }
        return getExpression().getLabel();
    }
    protected FilterProcessor createFilterProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new FilterProcessor(getExpression().createPredicate(routeContext), childProcessor);
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
    }
}
"
org.apache.camel.model.ExpressionSubElementType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an expression sub element
 */
@XmlRootElement(name = ""expression"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionSubElementType {
    @XmlElementRef
    private ExpressionType expressionType;
    @XmlTransient
    private Expression expression;
    @XmlTransient
    private Predicate predicate;
    public ExpressionSubElementType() {
    }
    public ExpressionSubElementType(Expression expression) {
        this.expression = expression;
    }
    public ExpressionSubElementType(Predicate predicate) {
        this.predicate = predicate;
    }   
    public ExpressionType getExpressionType() {
        return expressionType;
    }
    public void setExpressionType(ExpressionType expressionType) {
        this.expressionType = expressionType;
    }
    public Expression getExpression() {
        return expression;
    }   
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
    public void setPredicate(Predicate predicate) {
        this.predicate = predicate;
    }
    public Predicate getPredicate() {
        return predicate;
    }    
    public Expression createExpression(RouteContext routeContext) {
        ExpressionType expressionType = getExpressionType();
        if (expressionType != null && expression == null) {
            expression = expressionType.createExpression(routeContext);
        }
        return expression;
    }
    public Predicate createPredicate(RouteContext routeContext) {
        ExpressionType expressionType = getExpressionType();
        if (expressionType != null && getPredicate() == null) {
            setPredicate(expressionType.createPredicate(routeContext));
        }
        return getPredicate();
    }
}
"
org.apache.camel.model.FilterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;filter/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""filter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FilterType extends ExpressionNode implements Block {
    public FilterType() {
    }
    public FilterType(ExpressionType expression) {
        super(expression);
    }
    public FilterType(Predicate predicate) {
        super(predicate);
    }
    @Override
    public String toString() {
        return ""Filter["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""filter"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.FinallyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;finally/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""finally"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FinallyType extends OutputType<ProcessorType> implements Block {
    @Override
    public String toString() {
        return ""Finally["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""finally"";
    }
    @Override
    public String getLabel() {
        return """";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
}
"
org.apache.camel.model.FromType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;from/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""from"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FromType extends OptionalIdentifiedType<FromType> {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String ref;
    @XmlTransient
    private Endpoint<? extends Exchange> endpoint;
    public FromType() {
    }
    public FromType(String uri) {
        setUri(uri);
    }
    public FromType(Endpoint<? extends Exchange> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""From["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""from"";
    }
    public String getLabel() {
        return description(getUri(), getRef(), getEndpoint());
    }
    public Endpoint<? extends Exchange> resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI of the endpoint to use
     *
     * @param uri the endpoint URI to use
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getRef() {
        return ref;
    }
    /**
     * Sets the name of the endpoint within the registry (such as the Spring
     * ApplicationContext or JNDI) to use
     *
     * @param ref the reference name to use
     */
    public void setRef(String ref) {
        this.ref = ref;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        if (ObjectHelper.isNullOrBlank(uri)) {
            return uri;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return ref;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected static String description(String uri, String ref, Endpoint endpoint) {
        if (ref != null) {
            return ""ref:"" + ref;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        } else if (uri != null) {
            return uri;
        } else {
            return ""no uri or ref supplied!"";
        }
    }
}
"
org.apache.camel.model.GenerateXmlTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.io.StringWriter;
import java.util.List;
import javax.xml.bind.Marshaller;
import org.apache.camel.model.language.GroovyExpression;
import org.apache.camel.model.language.XQueryExpression;
/**
 * @version $Revision: 668035 $
 */
public class GenerateXmlTest extends XmlTestSupport {
    public void testCreateSimpleXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.filter(new XQueryExpression(""in.header.foo == 'bar'"")).
                to(""seda:b"");
        route.description(""This is a description of the route"");
        dump(context);
    }
    public void testGroovyFilterXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.interceptors(""interceptor1"", ""interceptor2"");
        route.filter(new GroovyExpression(""in.headers.any { h -> h.startsWith('foo') }"")).
                to(""seda:b"");
        route.description(""This is a description of the route"");
        List<ProcessorType<?>> list = route.getOutputs();
        assertEquals(""Size of list: "" + list, 1, list.size());
        dump(context);
    }
    protected void dump(RouteContainer context) throws Exception {
        Marshaller marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        StringWriter buffer = new StringWriter();
        marshaller.marshal(context, buffer);
        log.info(""Created: "" + buffer);
        assertNotNull(buffer);
        String out = buffer.toString();
        assertTrue(""Should contain the description"", out.indexOf(""This is a description of the route"") > 0);
    }
}
"
org.apache.camel.model.HandleFaultType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.HandleFaultProcessor;
/**
 * Represents an XML &lt;handleFault/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""handleFault"")
@XmlAccessorType(XmlAccessType.FIELD)
public class HandleFaultType extends InterceptorRef {
    public HandleFaultType() {
        super(new HandleFaultProcessor());
    }
    @Override
    public String getShortName() {
        return ""handleFault"";
    }
    @Override
    public String toString() {
        return ""HandleFault["" + getLabel() + ""]"";
    }
}
"
org.apache.camel.model.IdempotentConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;idempotentConsumer/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""idempotentConsumer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class IdempotentConsumerType extends ExpressionNode {
    @XmlAttribute
    private String messageIdRepositoryRef;
    @XmlTransient
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumerType() {
    }
    public IdempotentConsumerType(Expression messageIdExpression, MessageIdRepository messageIdRepository) {
        super(messageIdExpression);
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""idempotentConsumer"";
    }
    public String getMessageIdRepositoryRef() {
        return messageIdRepositoryRef;
    }
    public void setMessageIdRepositoryRef(String messageIdRepositoryRef) {
        this.messageIdRepositoryRef = messageIdRepositoryRef;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public void setMessageIdRepository(MessageIdRepository messageIdRepository) {
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        MessageIdRepository messageIdRepository = resolveMessageIdRepository(routeContext);
        return new IdempotentConsumer(getExpression().createExpression(routeContext), messageIdRepository,
                                      childProcessor);
    }
    public MessageIdRepository resolveMessageIdRepository(RouteContext routeContext) {
        if (messageIdRepository == null) {
            messageIdRepository = routeContext.lookup(messageIdRepositoryRef, MessageIdRepository.class);
        }
        return messageIdRepository;
    }
}
"
org.apache.camel.model.IdentifiedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
/**
 * The unique identifier for a bean. The scope of the identifier is the enclosing bean factory.
 * <p>
 * The following schema fragment specifies the expected content contained within this class.
 * <pre>
 * &lt;complexType name=""identifiedType"">
 *   &lt;complexContent>
 *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
 *       &lt;attribute name=""id"" type=""{http://www.w3.org/2001/XMLSchema}ID"" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 * @version $Revision: 660266 $
 */
@XmlType(name = ""identifiedType"")
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class IdentifiedType {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    /**
     * Gets the value of the id property.
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     */
    public void setId(String value) {
        this.id = value;
    }
}
"
org.apache.camel.model.InOnlyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
/**
 * Represents an XML &lt;inOnly/&gt; element
 *
 * @version $Revision: 733652 $
 */
@XmlRootElement(name = ""inOnly"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InOnlyType extends SendType<InOnlyType> {
    public InOnlyType() {
    }
    public InOnlyType(String uri) {
        setUri(uri);
    }
    public InOnlyType(Endpoint endpoint) {
        setEndpoint(endpoint);
    }
    @Override
    public String toString() {
        return ""InOnly["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""inOnly"";
    }
    @Override
    public ExchangePattern getPattern() {
        return ExchangePattern.InOnly;
    }
}
"
org.apache.camel.model.InOutType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
/**
 * Represents an XML &lt;inOut/&gt; element
 *
 * @version $Revision: 725680 $
 */
@XmlRootElement(name = ""inOut"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InOutType extends SendType<InOutType> {
    public InOutType() {
    }
    public InOutType(String uri) {
        setUri(uri);
    }
    public InOutType(Endpoint endpoint) {
        setEndpoint(endpoint);
    }
    @Override
    public String toString() {
        return ""InOut["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""inOut"";
    }
    @Override
    public ExchangePattern getPattern() {
        return ExchangePattern.InOut;
    }
}
"
org.apache.camel.model.InterceptorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Base class for interceptor types.
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""interceptor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptorRef extends InterceptorType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private DelegateProcessor interceptor;
    public InterceptorRef() {
    }
    public InterceptorRef(String ref) {
        setRef(ref);
    }
    public InterceptorRef(DelegateProcessor interceptor) {
        this.interceptor = interceptor;
    }
    @Override
    public String toString() {
        return ""Interceptor["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""interceptor"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        DelegateProcessor processor = createInterceptor(routeContext);
        Processor child = createOutputsProcessor(routeContext);
        processor.setProcessor(child);
        return processor;
    }
    public DelegateProcessor createInterceptor(RouteContext routeContext) {
        if (interceptor == null) {
            interceptor = routeContext.lookup(getRef(), DelegateProcessor.class);
        }
        if (interceptor == null) {
            throw new IllegalArgumentException(""No DelegateProcessor bean available for reference: "" + getRef());
        }
        return interceptor;
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        } else if (interceptor != null) {
            return interceptor.toString();
        } else {
            return """";
        }
    }
    /**
     * Get the underlying {@link DelegateProcessor} implementation
     * 
     * @return the {@link DelegateProcessor}
     */
    @XmlTransient
    public DelegateProcessor getInterceptor() {
        return interceptor;
    }
}
"
org.apache.camel.model.InterceptorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Base class for interceptor types.
 * 
 * @version $Revision: 660266 $
 */
@XmlType(name = ""interceptorType"")
public abstract class InterceptorType extends OutputType implements Block {
    public abstract DelegateProcessor createInterceptor(RouteContext routeContext) throws Exception;
}
"
org.apache.camel.model.InterceptType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Intercept;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.processor.Interceptor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;intercept/&gt; element
 *
 * @version $Revision: 699876 $
 */
@XmlRootElement(name = ""intercept"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptType extends OutputType<ProcessorType> {
    @XmlTransient
    private ProceedType proceed = new ProceedType();
    @XmlTransient
    private Boolean stopIntercept = Boolean.FALSE;
    @XmlTransient
    private Boolean usePredicate = Boolean.FALSE;
    @Override
    public String toString() {
        return ""Intercept["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""intercept"";
    }
    @Override
    public String getLabel() {
        return ""intercept"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Interceptor interceptor = new Interceptor();
        routeContext.intercept(interceptor);
        final Processor interceptRoute = createOutputsProcessor(routeContext);
        interceptor.setInterceptorLogic(interceptRoute);
        return interceptor;
    }
    /**
     * Applies this interceptor only if the given predicate is true
     */
    public ChoiceType when(Predicate predicate) {
        usePredicate = Boolean.TRUE;
        ChoiceType choice = choice().when(PredicateBuilder.not(predicate));
        choice.addOutput(proceed);
        return choice.otherwise();
    }
    public ProceedType getProceed() {
        return proceed;
    }
    public void stopIntercept() {
        setStopIntercept(Boolean.TRUE);
    }
    @XmlElement(name = ""stop"", required = false)
    public void setStop(String elementValue /* not used */) {
        stopIntercept();
    }    
    public InterceptType createProxy() {
        InterceptType answer = new InterceptType();
        answer.getOutputs().addAll(this.getOutputs());
        answer.setStopIntercept(getStopIntercept());
        // hack: now we need to replace the proceed of the proxy with its own
        // a bit ugly, operating based on the assumption that the proceed is
        // in its outputs (if proceed() was called) and/or in the
        // outputs of the otherwise or last when clause for the predicated version.
        if (answer.getOutputs().size() > 0) {
            // this is for the predicate version or if a choice() is present
            ChoiceType choice = null;
            for (ProcessorType processor : answer.getOutputs()) {
                if (processor instanceof ChoiceType) {
                    // special cases for predicates (choices)
                    choice = (ChoiceType) processor;
                    // for the predicated version we add the proceed() to otherwise()
                    // before knowing if stop() will follow, so let's make a small adjustment
                    if (usePredicate.booleanValue() && getStopIntercept().booleanValue()) {
                        WhenType when = choice.getWhenClauses().get(0);
                        when.getOutputs().remove(this.getProceed());
                    }
                    // add proceed to the when clause
                    addProceedProxy(this.getProceed(), answer.getProceed(),
                        choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue() && !getStopIntercept().booleanValue());
                    // force adding a proceed at the end (otherwise) if its not a stop type
                    addProceedProxy(this.getProceed(), answer.getProceed(), choice.getOtherwise(), !getStopIntercept().booleanValue());
                    if (getStopIntercept().booleanValue()) {
                        // must add proceed to when clause if stop is explictiy declared, otherwise when the
                        // predicate test fails then there is no proceed
                        // See example: InterceptorSimpleRouteTest (City Paris is never proceeded)  
                        addProceedProxy(this.getProceed(), answer.getProceed(),
                            choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue());
                    }
                    break;
                }
            }
            if (choice == null) {
                // force adding a proceed at the end if its not a stop type
                addProceedProxy(this.getProceed(), answer.getProceed(), answer, !getStopIntercept().booleanValue());
            }
        }
        return answer;
    }
    private void addProceedProxy(ProceedType orig, ProceedType proxy, ProcessorType<?> processor, boolean force) {
        int index = processor.getOutputs().indexOf(orig);
        if (index >= 0) {
            processor.addOutput(proxy);
            // replace original proceed with proxy
            List<ProcessorType<?>> outs = processor.getOutputs();
            outs.remove(proxy);
            outs.set(index, proxy);
        } else if (force) {
            processor.addOutput(proxy);
        }
    }
    public void setStopIntercept(Boolean stop) {
        this.stopIntercept = stop;
    }
    public Boolean getStopIntercept() {
        return stopIntercept;
    }
}
"
org.apache.camel.model.LoadBalanceType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.loadbalancer.LoadBalancerType;
import org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RandomLoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.processor.loadbalancer.StickyLoadBalancer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
/**
 * Represents an XML &lt;loadBalance/&gt; element
 */
@XmlRootElement(name = ""loadBalance"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LoadBalanceType extends ProcessorType<LoadBalanceType> {
    @XmlAttribute(required = false)
    private String ref;
    @XmlElements({
        @XmlElement(required = false, name = ""roundRobin"", type = RoundRobinLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""random"", type = RandomLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""sticky"", type = StickyLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""topic"", type = TopicLoadBalanceStrategy.class)}
        )
    private LoadBalancerType loadBalancerType;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public LoadBalanceType() {
    }
    @Override
    public String getShortName() {
        return ""loadbalance"";
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public LoadBalancerType getLoadBalancerType() {
        return loadBalancerType;
    }
    public void setLoadBalancerType(LoadBalancerType loadbalancer) {
        loadBalancerType = loadbalancer;
    }
    protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorType<?>> outputs)
        throws Exception {
        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);
        for (ProcessorType processorType : outputs) {
            // The outputs should be the SendProcessor
            SendProcessor processor = (SendProcessor) processorType.createProcessor(routeContext);
            loadBalancer.addProcessor(processor);
        }
        return loadBalancer;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);
        for (ProcessorType processorType : getOutputs()) {            
            Processor processor = processorType.createProcessor(routeContext);
            processor = processorType.wrapProcessorInInterceptors(routeContext, processor);
            loadBalancer.addProcessor(processor);
        }
        return loadBalancer;
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public LoadBalanceType setLoadBalancer(LoadBalancer loadBalancer) {
        loadBalancerType = new LoadBalancerType(loadBalancer);
        return this;
    }
    public LoadBalanceType roundRobin() {
        loadBalancerType = new LoadBalancerType(new RoundRobinLoadBalancer());
        return this;
    }
    public LoadBalanceType random() {
        loadBalancerType = new LoadBalancerType(new RandomLoadBalancer());
        return this;
    }
    public LoadBalanceType sticky(Expression<Exchange> correlationExpression) {
        loadBalancerType = new LoadBalancerType(new StickyLoadBalancer(correlationExpression));
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0, use multicast instead
     */
    public LoadBalanceType topic() {
        loadBalancerType = new LoadBalancerType(new TopicLoadBalancer());
        return this;
    }
    @Override
    public String getLabel() {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        List<ProcessorType<?>> list = getOutputs();
        for (ProcessorType<?> processorType : list) {
            buffer.append(processorType.getLabel());
        }
        return buffer.toString();
    }
    @Override
    public String toString() {
        if (loadBalancerType != null) {
            return ""LoadBalanceType["" + loadBalancerType + "", "" + getOutputs() + ""]"";
        } else {
            return ""LoadBalanceType[ref: "" + ref + "", "" + getOutputs() + ""]"";
        }
    }
}
"
org.apache.camel.model.LoggingLevel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlEnum;
/**
 * Used to configure the logging levels
 *
 * @version $Revision: 724293 $
 */
@XmlEnum
public enum LoggingLevel {
    DEBUG, ERROR, FATAL, INFO, TRACE, WARN, OFF
}
"
org.apache.camel.model.LoopType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.LoopProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;loop/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""loop"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LoopType extends ExpressionNode implements Block {
    public LoopType() {
    }
    public LoopType(Expression expression) {
        super(expression);
    }
    public LoopType(ExpressionType expression) {
        super(expression);
    }
    public void setExpression(Expression<?> expr) {
        if (expr != null) {
            setExpression(new ExpressionType(expr));
        }
    }
    @Override
    public String toString() {
        return ""Loop["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""loop"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new LoopProcessor(
            getExpression().createExpression(routeContext),
            routeContext.createProcessor(this));
    }
}
"
org.apache.camel.model.MarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.FlatpackDataFormat;
import org.apache.camel.model.dataformat.HL7DataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.dataformat.XStreamDataFormat;
import org.apache.camel.model.dataformat.ZipDataFormat;
import org.apache.camel.processor.MarshalProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Marshals to a binary payload using the given {@link DataFormatType}
 *
 * @version $Revision: 727622 $
 */
@XmlRootElement(name = ""marshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MarshalType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    // TODO cannot use @XmlElementRef as it doesn't allow optional properties
    // @XmlElementRef
    @XmlElements({
    @XmlElement(required = false, name = ""artixDS"", type = ArtixDSDataFormat.class),
    @XmlElement(required = false, name = ""csv"", type = CsvDataFormat.class),
    @XmlElement(required = false, name = ""flatpack"", type = FlatpackDataFormat.class),
    @XmlElement(required = false, name = ""hl7"", type = HL7DataFormat.class),
    @XmlElement(required = false, name = ""jaxb"", type = JaxbDataFormat.class),
    @XmlElement(required = false, name = ""serialization"", type = SerializationDataFormat.class),
    @XmlElement(required = false, name = ""string"", type = StringDataFormat.class), 
    @XmlElement(required = false, name = ""xmlBeans"", type = XMLBeansDataFormat.class),
    @XmlElement(required = false, name = ""xstream"", type = XStreamDataFormat.class),
    @XmlElement(required = false, name = ""zip"", type = ZipDataFormat.class)}
    )
    private DataFormatType dataFormatType;
    public MarshalType() {
    }
    public MarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public MarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        } else {
            return ""Marshal[ref: "" + ref + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""marshal"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormat dataFormat = DataFormatType.getDataFormat(routeContext, getDataFormatType(), ref);
        return new MarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.MulticastType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;multicast/&gt; element
 *
 * @version $Revision: 727988 $
 */
@XmlRootElement(name = ""multicast"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MulticastType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private Boolean parallelProcessing;
    @XmlAttribute(required = false)
    private String strategyRef;
    @XmlAttribute(required = false)
    private String threadPoolRef;    
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlTransient
    private ThreadPoolExecutor threadPoolExecutor;
    @Override
    public String toString() {
        return ""Multicast["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""multicast"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createOutputsProcessor(routeContext);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Set the multicasting aggregationStrategy
     * @param aggregationStrategy 
     *
     * @return the builder
     */
    public MulticastType aggregationStrategy(AggregationStrategy aggregationStrategy) {
        setAggregationStrategy(aggregationStrategy);
        return this;
    }
    /**
     * Set to run the multicasting action parallely
     *
     * @return the builder
     */
    public MulticastType parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }
    /**
     * Set the multicasting action's thread model
     * @param parallelProcessing <tt>true</tt> to use a thread pool, 
     * if <tt>false</tt> then work is done in the calling thread
     *
     * @return the builder
     */
    public MulticastType parallelProcessing(boolean parallelProcessing) {
        setParallelProcessing(parallelProcessing);
        return this;
    }
    /**
     * Setting the executor for executing the multicasting action.
     *   
     * @param executor , it should be a instance of ThreadPoolExcutor
     * NOTE in Camel 2.0 , it will change to use the instance which implements Executor interface
     *
     * @return the builder
     */
    public MulticastType executor(ThreadPoolExecutor executor) {
        setThreadPoolExecutor(executor);
        return this;
    }    
    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) {
        if (aggregationStrategy == null && strategyRef != null) {
            aggregationStrategy = routeContext.lookup(strategyRef, AggregationStrategy.class);
        }
        if (aggregationStrategy == null) {
            aggregationStrategy = new UseLatestAggregationStrategy();
        }
        if (threadPoolRef != null) {
            threadPoolExecutor = routeContext.lookup(threadPoolRef, ThreadPoolExecutor.class);
        }
        return new MulticastProcessor(list, aggregationStrategy, isParallelProcessing(), threadPoolExecutor);
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;        
    }
    public boolean isParallelProcessing() {
        return parallelProcessing != null ? parallelProcessing : false;
    }
    public void setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;        
    }
    public ThreadPoolExecutor getThreadPoolExecutor() {
        return threadPoolExecutor;
    }
    public void setThreadPoolExecutor(ThreadPoolExecutor executor) {
        this.threadPoolExecutor = executor;        
    }
    @Override
    protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {        
        //CAMEL-1193 now we need to wrap the multicast processor with the interceptors
        //Current we wrap the StreamCachingInterceptor by default
        return super.wrapProcessorInInterceptors(routeContext, new StreamCachingInterceptor(target));        
    }
}
"
org.apache.camel.model.NodeFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
/**
 * A simple factory used to create new child nodes which allows pluggable extension points
 * such as to add extra DSL helper methods such as for the Groovy or Ruby DSLs
 *
 * @version $Revision: 698396 $
 */
public class NodeFactory {
    public FilterType createFilter() {
        return new FilterType();
    }
    public LoopType createLoop() {
        return new LoopType();
    }
    public RouteType createRoute() {
        return new RouteType();
    }
}
"
org.apache.camel.model.OptionalIdentifiedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
/**
 * Allows an element to have an optional ID specified
 *
 * @version $Revision: 720270 $
 */
@XmlType(name = ""optionalIdentifiedType"")
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class OptionalIdentifiedType<T extends OptionalIdentifiedType> {
    @XmlTransient
    protected static Map<String, AtomicInteger> nodeCounters = new HashMap<String, AtomicInteger>();
    @XmlAttribute(required = false)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    @XmlElement(required = false)
    private Description description;
    /**
     * Gets the value of the id property.
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     */
    public void setId(String value) {
        this.id = value;
    }
    public Description getDescription() {
        return description;
    }
    public void setDescription(Description description) {
        this.description = description;
    }
    /**
     * Returns a short name for this node which can be useful for ID generation or referring to related resources like images
     *
     * @return defaults to ""node"" but derived nodes should overload this to provide a unique name
     */
    public String getShortName() {
        return ""node"";
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sets the description of this node
     *
     * @param id  sets the id, use null to not set an id
     * @param text  sets the text description, use null to not set a text
     * @param lang  sets the language for the description, use null to not set a language
     * @return the builder
     */
    public T describe(String id, String text, String lang) {
        if (id != null) {
            setId(id);
        }
        if (text != null) {
            if (description == null) {
                description = new Description();
            }
            description.setText(text);
        }
        if (lang != null) {
            if (description == null) {
                description = new Description();
            }
            description.setLang(lang);
        }
        return (T) this;
    }
    /**
     * Sets the description of this node
     *
     * @param text  the description
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public T description(String text) {
        if (description == null) {
            description = new Description();
        }
        description.setText(text);
        return (T) this;
    }
    /**
     * Sets the description of this node
     *
     * @param text  the description
     * @param lang  the language for the description
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public T description(String text, String lang) {
        description(text);
        description.setLang(lang);
        return (T) this;
    }
    /**
     * Sets the id of this node
     *
     * @param id the id
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public T id(String id) {
        setId(id);
        return (T) this;
    }
    public String idOrCreate() {
        if (id == null) {
            setId(createId());
        }
        return getId();
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A helper method to create a new ID for this node
     */
    protected String createId() {
        String key = getShortName();
        return key + getNodeCounter(key).incrementAndGet();
    }
    /**
     * Returns the counter for the given node key, lazily creating one if necessary
     */
    protected static synchronized AtomicInteger getNodeCounter(String key) {
        AtomicInteger answer = nodeCounters.get(key);
        if (answer == null) {
            answer = new AtomicInteger(0);
            nodeCounters.put(key, answer);
        }
        return answer;
    }
}
"
org.apache.camel.model.OtherwiseType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;otherwise/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""otherwise"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OtherwiseType extends OutputType<ProcessorType> implements Block {
    @Override
    public String toString() {
        return ""Otherwise["" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
    @Override
    public String getShortName() {
        return ""otherwise"";
    }
    @Override
    public String getLabel() {
        return ""otherwise"";
    }
}
"
org.apache.camel.model.OutputType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for output types
 *
 * @version $Revision: 640438 $
 */
@XmlType(name = ""outputType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OutputType<Type extends ProcessorType> extends ProcessorType<Type> {
    private static final transient Log LOG = LogFactory.getLog(OutputType.class);
    @XmlElementRef
    protected List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        // don't inherit interceptors by default
/*
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            log.warn(""No interceptor collection: "" + output);
        }
        else {
            list.addAll(getInterceptors());
        }
*/
    }
}
"
org.apache.camel.model.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/xml-configuration.html"">XML Configuration</a>
 * of the routing rules.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model;
"
org.apache.camel.model.PipelineType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;pipeline/&gt; element which can be used to define an explicit pipeline; or to define
 * a specific pipeline within a &lt;multicast&gt; block
 *
 * @version $Revision: 673835 $
 */
@XmlRootElement(name = ""pipeline"")
@XmlAccessorType(XmlAccessType.FIELD)
public class PipelineType extends OutputType<ProcessorType> {
    @Override
    public String getShortName() {
        return ""pipeline"";
    }
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createOutputsProcessor(routeContext);
    }
}
"
org.apache.camel.model.PolicyRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;policy/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""policy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class PolicyRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Policy policy;
    public PolicyRef() {
    }
    public PolicyRef(Policy policy) {
        this.policy = policy;
    }
    @Override
    public String toString() {
        return ""Policy["" + description() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""policy"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        } else if (policy != null) {
            return policy.toString();
        } else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = createOutputsProcessor(routeContext);
        Policy policy = resolvePolicy(routeContext);
        if (policy == null) {
            throw new IllegalArgumentException(""No policy configured: "" + this);
        }
        return policy.wrap(childProcessor);
    }
    protected Policy resolvePolicy(RouteContext routeContext) {
        if (policy == null) {
            policy = routeContext.lookup(getRef(), Policy.class);
        }
        return policy;
    }
    protected String description() {
        if (policy != null) {
            return policy.toString();
        } else {
            return ""ref: "" + ref;
        }
    }
}
"
org.apache.camel.model.ProceedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;proceed/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""proceed"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProceedType extends OutputType<ProcessorType> {
    @Override
    public String getShortName() {
        return ""proceed"";
    }
    // TODO we should be just returning the outputs!
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        //return routeContext.createProceedProcessor();
        return createOutputsProcessor(routeContext);
    }
}
"
org.apache.camel.model.ProcessorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;process/&gt; element
 *
 * @version $Revision: 699876 $
 */
@XmlRootElement(name = ""process"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProcessorRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Processor processor;
    public ProcessorRef() {
    }
    public ProcessorRef(Processor processor) {
        this.processor = processor;
    }
    @Override
    public String getShortName() {
        return ""process"";
    }
    @Override
    public String toString() {
        return ""process[""
                + ((ref != null) ? ""ref: "" + ref : processor)
                + ""]"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref: "" + ref;
        } else if (processor != null) {
            return processor.toString();
        } else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            processor = routeContext.lookup(getRef(), Processor.class);
        }
        return processor;
    }
}
"
org.apache.camel.model.ProcessorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelException;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.DataFormatClause;
import org.apache.camel.builder.DeadLetterChannelBuilder;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.ErrorHandlerBuilderRef;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.builder.NoErrorHandlerBuilder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.language.ConstantExpression;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.language.LanguageExpression;
import org.apache.camel.processor.ConvertBodyProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Policy;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for processor types that most XML types extend.
 *
 * @version $Revision: 725675 $
 */
@XmlAccessorType(XmlAccessType.PROPERTY)
public abstract class ProcessorType<Type extends ProcessorType> extends OptionalIdentifiedType<Type> implements Block {
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public static final String DEFAULT_TRACE_CATEGORY = ""org.apache.camel.TRACE"";
    private static final transient Log LOG = LogFactory.getLog(ProcessorType.class);
    private ErrorHandlerBuilder errorHandlerBuilder;
    private Boolean inheritErrorHandlerFlag;
    private NodeFactory nodeFactory;
    private LinkedList<Block> blocks = new LinkedList<Block>();
    private ProcessorType<? extends ProcessorType> parent;
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    private String errorHandlerRef;
    // else to use an optional attribute in JAXB2
    public abstract List<ProcessorType<?>> getOutputs();
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        throw new UnsupportedOperationException(""Not implemented yet for class: "" + getClass().getName());
    }
    public Processor createOutputsProcessor(RouteContext routeContext) throws Exception {
        Collection<ProcessorType<?>> outputs = getOutputs();
        return createOutputsProcessor(routeContext, outputs);
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        Processor processor = makeProcessor(routeContext);
        if (!routeContext.isRouteAdded()) {
            routeContext.addEventDrivenProcessor(processor);
        }
    }
    /**
     * Wraps the child processor in whatever necessary interceptors and error
     * handlers
     */
    public Processor wrapProcessor(RouteContext routeContext, Processor processor) throws Exception {
        processor = wrapProcessorInInterceptors(routeContext, processor);
        return wrapInErrorHandler(routeContext, processor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint URI
     */
    public Type to(String uri) {
        addOutput(new ToType(uri));
        return (Type) this;
    }   
    /**
     * Sends the exchange to the given endpoint
     */
    public Type to(Endpoint endpoint) {
        addOutput(new ToType(endpoint));
        return (Type) this;
    }
    /**
     * Sends the exchange with certain exchange pattern to the given endpoint
     *
     * @param pattern the pattern to use for the message exchange
     * @param uri  the endpoint to send to
     * @return the builder
     */
    public Type to(ExchangePattern pattern, String uri) {
        addOutput(new ToType(uri, pattern));
        return (Type) this;
    }   
    /**
     * Sends the exchange with certain exchange pattern to the given endpoint
     *
     * @param pattern the pattern to use for the message exchange
     * @param endpoint  the endpoint to send to
     * @return the builder
     */
    public Type to(ExchangePattern pattern, Endpoint endpoint) {
        addOutput(new ToType(endpoint, pattern));
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints
     */
    public Type to(String... uris) {
        for (String uri : uris) {
            addOutput(new ToType(uri));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints
     */
    public Type to(Endpoint... endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoint
     */
    public Type to(Iterable<Endpoint> endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints
     *
     * @param pattern the pattern to use for the message exchanges
     * @param uris  list of endpoints to send to
     * @return the builder
     */
    public Type to(ExchangePattern pattern, String... uris) {
        for (String uri : uris) {
            addOutput(new ToType(uri, pattern));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints
     *
     * @param pattern the pattern to use for the message exchanges
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type to(ExchangePattern pattern, Endpoint... endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint, pattern));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints
     *
     * @param pattern the pattern to use for the message exchanges
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type to(ExchangePattern pattern, Iterable<Endpoint> endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint, pattern));
        }
        return (Type) this;
    }
    /**
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">ExchangePattern:</a>
     * set the ExchangePattern {@link ExchangePattern} into the exchange
     *
     * @param exchangePattern  instance of {@link ExchangePattern}
     * @return the builder
     */
    public Type setExchangePattern(ExchangePattern exchangePattern) {
        addOutput(new SetExchangePatternType(exchangePattern));
        return (Type) this;
    }
    /**
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">ExchangePattern:</a>
     * set the exchange's ExchangePattern {@link ExchangePattern} to be InOnly
     *
     *
     * @return the builder
     */
    public Type inOnly() {
        return setExchangePattern(ExchangePattern.InOnly);
    }
    /**
     * Sends the message to the given endpoint using an
     * <a href=""http://activemq.apache.org/camel/event-message.html"">Event Message</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOnly exchange pattern</a>
     *
     * @param uri The endpoint uri which is used for sending the exchange
     * @return the builder
     */
    public Type inOnly(String uri) {
        return to(ExchangePattern.InOnly, uri);
    }
    /**
     * Sends the message to the given endpoint using an
     * <a href=""http://activemq.apache.org/camel/event-message.html"">Event Message</a> or 
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOnly exchange pattern</a>
     *
     * @param endpoint The endpoint which is used for sending the exchange
     * @return the builder
     */
    public Type inOnly(Endpoint endpoint) {
        return to(ExchangePattern.InOnly, endpoint);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/event-message.html"">Event Message</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOnly exchange pattern</a>
     *
     * @param uris  list of endpoints to send to
     * @return the builder
     */
    public Type inOnly(String... uris) {
        return to(ExchangePattern.InOnly, uris);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/event-message.html"">Event Message</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOnly exchange pattern</a>
     *
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type inOnly(Endpoint... endpoints) {
        return to(ExchangePattern.InOnly, endpoints);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/event-message.html"">Event Message</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOnly exchange pattern</a>
     *
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type inOnly(Iterable<Endpoint> endpoints) {
        return to(ExchangePattern.InOnly, endpoints);
    }
    /**
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">ExchangePattern:</a>
     * set the exchange's ExchangePattern {@link ExchangePattern} to be InOut
     *
     *
     * @return the builder
     */
    public Type inOut() {
        return setExchangePattern(ExchangePattern.InOut);
    }
    /**
     * Sends the message to the given endpoint using an
     * <a href=""http://activemq.apache.org/camel/request-reply.html"">Request Reply</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOut exchange pattern</a>
     *
     * @param uri The endpoint uri which is used for sending the exchange
     * @return the builder
     */
    public Type inOut(String uri) {
        return to(ExchangePattern.InOut, uri);
    }
    /**
     * Sends the message to the given endpoint using an
     * <a href=""http://activemq.apache.org/camel/request-reply.html"">Request Reply</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOut exchange pattern</a>
     *
     * @param endpoint The endpoint which is used for sending the exchange
     * @return the builder
     */
    public Type inOut(Endpoint endpoint) {
        return to(ExchangePattern.InOut, endpoint);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/request-reply.html"">Request Reply</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOut exchange pattern</a>
     *
     * @param uris  list of endpoints to send to
     * @return the builder
     */
    public Type inOut(String... uris) {
        return to(ExchangePattern.InOut, uris);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/request-reply.html"">Request Reply</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOut exchange pattern</a>
     *
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type inOut(Endpoint... endpoints) {
        return to(ExchangePattern.InOut, endpoints);
    }
    /**
     * Sends the message to the given endpoints using an
     * <a href=""http://activemq.apache.org/camel/request-reply.html"">Request Reply</a> or
     * <a href=""http://activemq.apache.org/camel/exchange-pattern.html"">InOut exchange pattern</a>
     *
     * @param endpoints  list of endpoints to send to
     * @return the builder
     */
    public Type inOut(Iterable<Endpoint> endpoints) {
        return to(ExchangePattern.InOut, endpoints);
    }
    /**
     * <a href=""http://activemq.apache.org/camel/multicast.html"">Multicast EIP:</a>
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     */
    public MulticastType multicast() {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        return answer;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the multicast type
     */
    public MulticastType multicast(AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the multicast type
     */
    public MulticastType multicast(AggregationStrategy aggregationStrategy) {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return answer;
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(String... uris) {
        // TODO pipeline v mulicast
        return to(uris);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Endpoint... endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Collection<Endpoint> endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Ends the current block
     */
    public ProcessorType<? extends ProcessorType> end() {
        if (blocks.isEmpty()) {
            if (parent == null) {
                throw new IllegalArgumentException(""Root node with no active block"");
            }
            return parent;
        }
        popBlock();
        return this;
    }
    /**
     * Causes subsequent processors to be called asynchronously
     *
     * @param coreSize the number of threads that will be used to process
     *                 messages in subsequent processors.
     * @return a ThreadType builder that can be used to further configure the
     *         the thread pool.
     */
    public ThreadType thread(int coreSize) {
        ThreadType answer = new ThreadType(coreSize);
        addOutput(answer);
        return answer;
    }
    /**
     * Causes subsequent processors to be called asynchronously
     *
     * @param executor the executor that will be used to process
     *                 messages in subsequent processors.
     * @return a ThreadType builder that can be used to further configure the
     *         the thread pool.
     */
    public ProcessorType<Type> thread(ThreadPoolExecutor executor) {
        ThreadType answer = new ThreadType(executor);
        addOutput(answer);
        return this;
    }
    /**
     * Creates an {@link org.apache.camel.processor.idempotent.IdempotentConsumer}
     * to avoid duplicate messages
     */
    public IdempotentConsumerType idempotentConsumer(Expression messageIdExpression,
            MessageIdRepository messageIdRepository) {
        IdempotentConsumerType answer = new IdempotentConsumerType(messageIdExpression, messageIdRepository);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates an {@link org.apache.camel.processor.idempotent.IdempotentConsumer}
     * to avoid duplicate messages
     *
     * @return the builder used to create the expression
     */
    public ExpressionClause<IdempotentConsumerType> idempotentConsumer(MessageIdRepository messageIdRepository) {
        IdempotentConsumerType answer = new IdempotentConsumerType();
        answer.setMessageIdRepository(messageIdRepository);
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates a predicate expression which only if it is true then the
     * exchange is forwarded to the destination
     *
     * @return the clause used to create the filter expression
     */
    public ExpressionClause<FilterType> filter() {
        FilterType filter = new FilterType();
        addOutput(filter);
        return ExpressionClause.createAndSetExpression(filter);
    }
    /**
     * Creates a predicate which is applied and only if it is true then the
     * exchange is forwarded to the destination
     *
     * @return the builder for a predicate
     */
    public FilterType filter(Predicate predicate) {
        FilterType filter = new FilterType(predicate);
        addOutput(filter);
        return filter;
    }
    public FilterType filter(ExpressionType expression) {
        FilterType filter = getNodeFactory().createFilter();
        filter.setExpression(expression);
        addOutput(filter);
        return filter;
    }
    public FilterType filter(String language, String expression) {
        return filter(new LanguageExpression(language, expression));
    }
    public LoadBalanceType loadBalance() {
        LoadBalanceType answer = new LoadBalanceType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a choice of one or more predicates with an otherwise clause
     *
     * @return the builder for a choice expression
     */
    public ChoiceType choice() {
        ChoiceType answer = new ChoiceType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a try/catch block
     *
     * @return the builder for a tryBlock expression
     */
    public TryType tryBlock() {
        TryType answer = new TryType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a dynamic <a
     * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient
     * List</a> pattern.
     *
     * @param recipients is the builder of the expression used in the
     *                    {@link org.apache.camel.processor.RecipientList}
     *                    to decide the destinations
     */
    public Type recipientList(Expression recipients) {
        RecipientListType answer = new RecipientListType(recipients);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a dynamic <a
     * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient
     * List</a> pattern.
     *
     * @return the expression clause for the expression used in the
     *                    {@link org.apache.camel.processor.RecipientList}
     *                    to decide the destinations
     */
    public ExpressionClause<ProcessorType<Type>> recipientList() {
        RecipientListType answer = new RecipientListType();
        addOutput(answer);
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        answer.setExpression(clause);
        return clause;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern.
     *
     * @param header is the header that the {@link org.apache.camel.processor.RoutingSlip RoutingSlip}
     * class will look in for the list of URIs to route the message to.
     * @param uriDelimiter is the delimiter that will be used to split up
     * the list of URIs in the routing slip.
     */
    public Type routingSlip(String header, String uriDelimiter) {
        RoutingSlipType answer = new RoutingSlipType(header, uriDelimiter);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern.
     *
     * @param header is the header that the {@link org.apache.camel.processor.RoutingSlip RoutingSlip}
     * class will look in for the list of URIs to route the message to. The list of URIs
     * will be split based on the default delimiter
     * {@link RoutingSlipType#DEFAULT_DELIMITER}.
     */
    public Type routingSlip(String header) {
        RoutingSlipType answer = new RoutingSlipType(header);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern with the default header {@link RoutingSlipType#ROUTING_SLIP_HEADER}.
     * The list of URIs in the header will be split based on the default delimiter
     * {@link RoutingSlipType#DEFAULT_DELIMITER}.
     */
    public Type routingSlip() {
        RoutingSlipType answer = new RoutingSlipType();
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param recipients the expression on which to split
     * @return the builder
     */
    public SplitterType splitter(Expression recipients) {
        SplitterType answer = new SplitterType(recipients);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter() {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param partsExpression the expression on which to split
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the builder
     */
    public SplitterType splitter(Expression partsExpression, AggregationStrategy aggregationStrategy) {
        SplitterType answer = new SplitterType(partsExpression);
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(AggregationStrategy aggregationStrategy) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param recipients the expression on which to split
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the builder
     */
    public SplitterType splitter(Expression recipients, boolean parallelProcessing) {
        SplitterType answer = new SplitterType(recipients);
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param recipients the expression on which to split
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @param threadPoolExecutor override the default {@link ThreadPoolExecutor} 
     * @return the builder
     */
    public SplitterType splitter(Expression recipients, boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor) {
        SplitterType answer = new SplitterType(recipients);
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        answer.setThreadPoolExecutor(threadPoolExecutor);
        return answer;
    }    
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(boolean parallelProcessing) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @param threadPoolExecutor override the default {@link ThreadPoolExecutor} 
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        answer.setThreadPoolExecutor(threadPoolExecutor);
        return ExpressionClause.createAndSetExpression(answer);
    }    
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param partsExpression the expression on which to split
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the builder
     */
    public SplitterType splitter(Expression partsExpression,
            AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        SplitterType answer = new SplitterType(partsExpression);
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param partsExpression the expression on which to split
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @param threadPoolExecutor override the default {@link ThreadPoolExecutor} 
     * @return the builder
     */
    public SplitterType splitter(Expression partsExpression,
            AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor) {
        SplitterType answer = new SplitterType(partsExpression);
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        answer.setThreadPoolExecutor(threadPoolExecutor);        
        return answer;
    }    
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @param threadPoolExecutor override the default {@link ThreadPoolExecutor} 
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        answer.setThreadPoolExecutor(threadPoolExecutor);           
        return ExpressionClause.createAndSetExpression(answer);
    }   
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @return the expression clause for the expressions on which to compare messages in order
     */
    public ExpressionClause<ResequencerType> resequencer() {
        ResequencerType answer = new ResequencerType();
        addOutput(answer);
        ExpressionClause<ResequencerType> clause = new ExpressionClause<ResequencerType>(answer);
        answer.expression(clause);
        return clause;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where an expression is evaluated to be able to compare the
     * message exchanges to reorder them. e.g. you may wish to sort by some
     * header
     *
     * @param expression the expression on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression<Exchange> expression) {
        return resequencer(Collections.<Expression>singletonList(expression));
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(List<Expression> expressions) {
        ResequencerType answer = new ResequencerType(expressions);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression... expressions) {
        List<Expression> list = new ArrayList<Expression>();
        list.addAll(Arrays.asList(expressions));
        return resequencer(list);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     */
    public ExpressionClause<AggregatorType> aggregator() {
        AggregatorType answer = new AggregatorType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param aggregationStrategy the strategy used for the aggregation
     */
    public ExpressionClause<AggregatorType> aggregator(AggregationStrategy aggregationStrategy) {
        AggregatorType answer = new AggregatorType();
        answer.setAggregationStrategy(aggregationStrategy);
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern using a custom aggregation collection implementation. The aggregation collection must
     * be configued with the strategy and correlation expression that this aggregator should use.
     * This avoids duplicating this configuration on both the collection and the aggregator itself.
     *
     * @param aggregationCollection the collection used to perform the aggregation
     */
    public AggregatorType aggregator(AggregationCollection aggregationCollection) {
        AggregatorType answer = new AggregatorType();
        answer.setAggregationCollection(aggregationCollection);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param correlationExpression the expression used to calculate the
     *                              correlation key. For a JMS message this could be the
     *                              expression <code>header(""JMSDestination"")</code> or
     *                              <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression) {
        AggregatorType answer = new AggregatorType(correlationExpression);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param correlationExpression the expression used to calculate the
     *                              correlation key. For a JMS message this could be the
     *                              expression <code>header(""JMSDestination"")</code> or
     *                              <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        AggregatorType answer = new AggregatorType(correlationExpression, aggregationStrategy);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @param processAtExpression an expression to calculate the time at which
     *                            the messages should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression) {
        return delayer(processAtExpression, 0L);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @param processAtExpression an expression to calculate the time at which
     *                            the messages should be processed
     * @param delay               the delay in milliseconds which is added to the
     *                            processAtExpression to determine the time the message
     *                            should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression, long delay) {
        DelayerType answer = new DelayerType(processAtExpression, delay);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     * @return the expression clause to create the expression
     */
    public ExpressionClause<DelayerType> delayer() {
        DelayerType answer = new DelayerType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where a fixed amount of milliseconds are used to delay processing of a
     * message exchange
     *
     * @param delay the default delay in milliseconds
     * @return the builder
     */
    public DelayerType delayer(long delay) {
        return delayer(null, delay);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @return the builder
     */
    public ThrottlerType throttler(long maximumRequestCount) {
        ThrottlerType answer = new ThrottlerType(maximumRequestCount);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a expression which must evaluate to an integer that determines
     * how many times the exchange should be sent down the rest of the route.
     *
     * @return the clause used to create the loop expression
     */
    public ExpressionClause<LoopType> loop() {
        LoopType loop = new LoopType();
        addOutput(loop);
        return ExpressionClause.createAndSetExpression(loop);
    }
    public LoopType loop(Expression<?> expression) {
        LoopType loop = getNodeFactory().createLoop();
        loop.setExpression(expression);
        addOutput(loop);
        return loop;
    }
    public LoopType loop(int count) {
        LoopType loop = getNodeFactory().createLoop();
        loop.setExpression(new ConstantExpression(Integer.toString(count)));
        addOutput(loop);
        return loop;
    }
    public Type throwFault(Throwable fault) {
        ThrowFaultType answer = new ThrowFaultType();
        answer.setFault(fault);
        addOutput(answer);
        return (Type) this;
    }
    public Type throwFault(String message) {
        return throwFault(new CamelException(message));
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public Type interceptor(String ref) {
        InterceptorRef interceptor = new InterceptorRef(ref);
        intercept(interceptor);
        return (Type) this;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public Type intercept(DelegateProcessor interceptor) {
        intercept(new InterceptorRef(interceptor));
        //lastInterceptor = interceptor;
        return (Type) this;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public void intercept(InterceptorType interceptor) {
        addOutput(interceptor);
        pushBlock(interceptor);
    }
    /**
     * Adds an interceptor around the whole of this nodes processing
     *
     * @param interceptor
     */
    public void addInterceptor(InterceptorType interceptor) {
        interceptors.add(interceptor);
    }
    /**
     * Adds an interceptor around the whole of this nodes processing
     *
     * @param interceptor
     */
    public void addInterceptor(DelegateProcessor interceptor) {
        addInterceptor(new InterceptorRef(interceptor));
    }
    public void pushBlock(Block block) {
        blocks.add(block);
    }
    public Block popBlock() {
        return blocks.isEmpty() ? null : blocks.removeLast();
    }
    public Type proceed() {
        ProceedType proceed = null;
        ProcessorType currentProcessor = this;
        if (currentProcessor instanceof InterceptType) {
            proceed = ((InterceptType) currentProcessor).getProceed();
            LOG.info(""proceed() is the implied and hence not needed for an intercept()"");
        }
        if (proceed == null) {
            for (ProcessorType node = parent; node != null; node = node.getParent()) {
                if (node instanceof InterceptType) {
                    InterceptType intercept = (InterceptType)node;
                    proceed = intercept.getProceed();
                    break;
                }
            }
            if (proceed == null) {
                throw new IllegalArgumentException(""Cannot use proceed() without being within an intercept() block"");
            }
        }
        addOutput(proceed);
        return (Type) this;
    }
    public Type stop() {
        ProcessorType currentProcessor = this;
        if (currentProcessor instanceof InterceptType) {
            ((InterceptType) currentProcessor).stopIntercept();
        } else {
            ProcessorType node;
            for (node = parent; node != null; node = node.getParent()) {
                if (node instanceof InterceptType) {
                    ((InterceptType) node).stopIntercept();
                    break;
                }
            }
            if (node == null) {
                throw new IllegalArgumentException(""Cannot use stop() without being within an intercept() block"");
            }
        }
        return (Type) this;
    }
    /**
     * Catches an exception type.
     *
     * @deprecated Please use {@link #onException(Class)} instead. Will be removed in Camel 2.0.
     */
    public ExceptionType exception(Class exceptionType) {
        return onException(exceptionType);
    }
    /**
     * Catches an exception type.
     */
    public ExceptionType onException(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        addOutput(answer);
        return answer;
    }
    /**
     * Apply an interceptor route if the predicate is true
     */
    public ChoiceType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer.when(predicate);
    }
    public Type interceptors(String... refs) {
        for (String ref : refs) {
            interceptor(ref);
        }
        return (Type) this;
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the {@link #DEFAULT_TRACE_CATEGORY} logging category.
     *
     * @deprecated Please use <a href=""http://activemq.apache.org/camel/tracer.html>Tracer Support</a>
     * instead. Will be removed in Camel 2.0.
     */
    public Type trace() {
        return trace(DEFAULT_TRACE_CATEGORY);
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the specified logging category.
     *
     * @param category the logging category trace messages will sent to.
     *
     * @deprecated Please use <a href=""http://activemq.apache.org/camel/tracer.html>Tracer Support</a>
     * instead. Will be removed in Camel 2.0.
     */
    public Type trace(String category) {
        final Log log = LogFactory.getLog(category);
        return intercept(new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                log.trace(exchange);
                processNext(exchange);
            }
        });
    }
    public PolicyRef policies() {
        PolicyRef answer = new PolicyRef();
        addOutput(answer);
        return answer;
    }
    public PolicyRef policy(Policy policy) {
        PolicyRef answer = new PolicyRef(policy);
        addOutput(answer);
        return answer;
    }
    /**
     * Forces handling of faults as exceptions
     *
     * @return the current builder with the fault handler configured
     */
    public Type handleFault() {
        intercept(new HandleFaultType());
        return (Type) this;
    }
    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for
     *                            all child routes
     * @return the current builder with the error handler configured
     */
    public Type errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return (Type) this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     *
     * @param condition the flag as to whether error handlers should be
     *                  inherited or not
     * @return the current builder
     */
    public Type inheritErrorHandler(boolean condition) {
        setInheritErrorHandlerFlag(condition);
        return (Type) this;
    }
    // Transformers
    // -------------------------------------------------------------------------
    /**
     * Adds the custom processor to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type process(Processor processor) {
        ProcessorRef answer = new ProcessorRef(processor);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds the custom processor reference to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type processRef(String ref) {
        ProcessorRef answer = new ProcessorRef();
        answer.setRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Object bean) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Object bean, String method) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean by type which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Class beanType) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean type and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Class beanType, String method) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type beanRef(String ref) {
        BeanRef answer = new BeanRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type beanRef(String ref, String method) {
        BeanRef answer = new BeanRef(ref, method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the IN message
     */
    public ExpressionClause<ProcessorType<Type>> setBody() {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetBodyType answer = new SetBodyType(clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the body on the IN message
     */
    public Type setBody(Expression expression) {
        SetBodyType answer = new SetBodyType(expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the OUT message
     *
     * @deprecated Please use {@link #transform(Expression)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type setOutBody(Expression expression) {
        return transform(expression);
    }
    /**
     * Adds a processor which sets the body on the OUT message
     *
     * @deprecated Please use {@link #transform()} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public ExpressionClause<ProcessorType<Type>> setOutBody() {
        return transform();
    }
    /**
     * Adds a processor which sets the body on the OUT message
     */
    public Type transform(Expression expression) {
        TransformType answer = new TransformType(expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the OUT message
     */
    public ExpressionClause<ProcessorType<Type>> transform() {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        TransformType answer = new TransformType(clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the body on the FAULT message
     */
    public Type setFaultBody(Expression expression) {
        return process(ProcessorBuilder.setFaultBody(expression));
    }
    /**
     * Adds a processor which sets the header on the IN message
     */
    public ExpressionClause<ProcessorType<Type>> setHeader(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetHeaderType answer = new SetHeaderType(name, clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the header on the IN message
     */
    public Type setHeader(String name, Expression expression) {
        SetHeaderType answer = new SetHeaderType(name, expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the header on the IN message to the given value
     * @deprecated Please use {@link #setHeader(String, Expression)} instead. Will be removed in Camel 2.0.
     */
    public Type setHeader(String name, String value) {
        SetHeaderType answer = new SetHeaderType(name, value);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public ExpressionClause<ProcessorType<Type>> setOutHeader(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetOutHeaderType answer = new SetOutHeaderType(name, clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public Type setOutHeader(String name, Expression expression) {
        SetOutHeaderType answer = new SetOutHeaderType(name, expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the header on the FAULT message
     */
    public Type setFaultHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setFaultHeader(name, expression));
    }
    /**
     * Adds a processor which sets the exchange property
     */
    public Type setProperty(String name, Expression expression) {
        SetPropertyType answer = new SetPropertyType(name, expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the exchange property
     */
    public ExpressionClause<ProcessorType<Type>> setProperty(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetPropertyType answer = new SetPropertyType(name, clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which removes the header on the IN message
     */
    public Type removeHeader(String name) {
        RemoveHeaderType answer = new RemoveHeaderType(name);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which removes the header on the FAULT message
     */
    public Type removeFaultHeader(String name) {
        return process(ProcessorBuilder.removeFaultHeader(name));
    }
    /**
     * Adds a processor which removes the exchange property
     */
    public Type removeProperty(String name) {
        RemovePropertyType answer = new RemovePropertyType(name);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Converts the IN message body to the specified type
     */
    public Type convertBodyTo(Class type) {
        addOutput(new ConvertBodyType(type));
        return (Type) this;
    }
    /**
     * Converts the IN message body to the specified class type
     */
    public Type convertBodyTo(String typeString) {
        addOutput(new ConvertBodyType(typeString));
        return (Type) this;
    }
    /**
     * Converts the OUT message body to the specified type
     *
     * @deprecated Please use {@link #convertBodyTo(Class)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type convertOutBodyTo(Class type) {
        return process(new ConvertBodyProcessor(type));
    }
    /**
     * Converts the FAULT message body to the specified type
     *
     * @deprecated Please use {@link #convertBodyTo(Class)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type convertFaultBodyTo(Class type) {
        return process(new ConvertBodyProcessor(type));
    }
    // DataFormat support
    // -------------------------------------------------------------------------
    /**
     * Unmarshals the in body using a {@link DataFormat} expression to define
     * the format of the input message and the output will be set on the out message body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataFormatClause<ProcessorType<Type>> unmarshal() {
        return new DataFormatClause<ProcessorType<Type>>(this, DataFormatClause.Operation.Unmarshal);
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormatType dataFormatType) {
        addOutput(new UnmarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormat dataFormat) {
        return unmarshal(new DataFormatType(dataFormat));
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * reference in the {@link org.apache.camel.spi.Registry} and sets
     * the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(String dataTypeRef) {
        addOutput(new UnmarshalType(dataTypeRef));
        return (Type) this;
    }
    /**
     * Marshals the in body using a {@link DataFormat} expression to define
     * the format of the output which will be added to the out body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataFormatClause<ProcessorType<Type>> marshal() {
        return new DataFormatClause<ProcessorType<Type>>(this, DataFormatClause.Operation.Marshal);
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormatType dataFormatType) {
        addOutput(new MarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormat dataFormat) {
        return marshal(new DataFormatType(dataFormat));
    }
    /**
     * Marshals the in body the specified {@link DataFormat}
     * reference in the {@link org.apache.camel.spi.Registry} and sets
     * the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(String dataTypeRef) {
        addOutput(new MarshalType(dataTypeRef));
        return (Type) this;
    }
    // Properties
    // -------------------------------------------------------------------------
    @XmlTransient
    public ProcessorType<? extends ProcessorType> getParent() {
        return parent;
    }
    public void setParent(ProcessorType<? extends ProcessorType> parent) {
        this.parent = parent;
    }
    @XmlTransient
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    /**
     * Sets the error handler if one is not already set
     */
    protected void setErrorHandlerBuilderIfNull(ErrorHandlerBuilder errorHandlerBuilder) {
        if (this.errorHandlerBuilder == null) {
            setErrorHandlerBuilder(errorHandlerBuilder);
        }
    }
    public String getErrorHandlerRef() {
        return errorHandlerRef;
    }
    /**
     * Sets the bean ref name of the error handler builder to use on this route
     */
    @XmlAttribute(required = false)
    public void setErrorHandlerRef(String errorHandlerRef) {
        this.errorHandlerRef = errorHandlerRef;
        setErrorHandlerBuilder(new ErrorHandlerBuilderRef(errorHandlerRef));
    }
    @XmlTransient
    public boolean isInheritErrorHandler() {
        return isInheritErrorHandler(getInheritErrorHandlerFlag());
    }
    /**
     * Lets default the inherit value to be true if there is none specified
     */
    public static boolean isInheritErrorHandler(Boolean value) {
        return value == null || value.booleanValue();
    }
    @XmlAttribute(name = ""inheritErrorHandler"", required = false)
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    @XmlTransient
    public NodeFactory getNodeFactory() {
        if (nodeFactory == null) {
            nodeFactory = new NodeFactory();
        }
        return nodeFactory;
    }
    public void setNodeFactory(NodeFactory nodeFactory) {
        this.nodeFactory = nodeFactory;
    }
    /**
     * Returns a label to describe this node such as the expression if some kind of expression node
     */
    public String getLabel() {
        return """";
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Creates the processor and wraps it in any necessary interceptors and
     * error handlers
     */
    protected Processor makeProcessor(RouteContext routeContext) throws Exception {
        Processor processor = createProcessor(routeContext);
        return wrapProcessor(routeContext, processor);
    }
    /**
     * A strategy method which allows derived classes to wrap the child
     * processor in some kind of interceptor
     *
     * @param routeContext
     * @param target       the processor which can be wrapped
     * @return the original processor or a new wrapped interceptor
     */
    protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {
        // The target is required.
        if (target == null) {
            throw new IllegalArgumentException(""target not provided on node: "" + this);
        }
        List<InterceptStrategy> strategies = new ArrayList<InterceptStrategy>();
        CamelContext camelContext = routeContext.getCamelContext();
        if (camelContext instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) camelContext;
            strategies.addAll(defaultCamelContext.getInterceptStrategies());
        }
        strategies.addAll(routeContext.getInterceptStrategies());
        for (InterceptStrategy strategy : strategies) {
            if (strategy != null) {
                target = strategy.wrapProcessorInInterceptors(this, target);
            }
        }
        List<InterceptorType> list = routeContext.getRoute().getInterceptors();
        if (interceptors != null) {
            list.addAll(interceptors);
        }
        // lets reverse the list so we apply the inner interceptors first
        Collections.reverse(list);
        Set<Processor> interceptors = new HashSet<Processor>();
        interceptors.add(target);
        for (InterceptorType interceptorType : list) {
            DelegateProcessor interceptor = interceptorType.createInterceptor(routeContext);
            if (!interceptors.contains(interceptor)) {
                interceptors.add(interceptor);
                if (interceptor.getProcessor() != null) {
                    LOG.warn(""Interceptor "" + interceptor + "" currently wraps target ""
                            + interceptor.getProcessor()
                            + "" is attempting to change target "" + target
                            + "" new wrapping has been denied."");
                } else {
                    interceptor.setProcessor(target);
                    target = interceptor;
                }
            }
        }
        return target;
    }
    /**
     * A strategy method to allow newly created processors to be wrapped in an
     * error handler.
     */
    protected Processor wrapInErrorHandler(RouteContext routeContext, Processor target) throws Exception {
        // The target is required.
        if (target == null) {
            throw new IllegalArgumentException(""target not provided on node: "" + this);
        }
        ErrorHandlerWrappingStrategy strategy = routeContext.getErrorHandlerWrappingStrategy();
        if (strategy != null) {
            return strategy.wrapProcessorInErrorHandler(routeContext, this, target);
        }
        return getErrorHandlerBuilder().createErrorHandler(routeContext, target);
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (errorHandlerRef != null) {
            return new ErrorHandlerBuilderRef(errorHandlerRef);
        }
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    protected void configureChild(ProcessorType output) {
        output.setNodeFactory(getNodeFactory());
    }
    public void addOutput(ProcessorType processorType) {
        processorType.setParent(this);
        configureChild(processorType);
        if (blocks.isEmpty()) {
            getOutputs().add(processorType);
        } else {
            Block block = blocks.getLast();
            block.addOutput(processorType);
        }
    }
    /**
     * Creates a new instance of some kind of composite processor which defaults
     * to using a {@link Pipeline} but derived classes could change the
     * behaviour
     */
    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) {
        // return new MulticastProcessor(list);
        return new Pipeline(list);
    }
    protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorType<?>> outputs)
        throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorType output : outputs) {
            Processor processor = output.createProcessor(routeContext);
            // if the ProceedType create processor is null we keep on going
            if (output instanceof ProceedType && processor == null) {
                continue;
            }
            processor = output.wrapProcessorInInterceptors(routeContext, processor);
            ProcessorType currentProcessor = this;
            if (!(currentProcessor instanceof ExceptionType || currentProcessor instanceof TryType)) {
                processor = output.wrapInErrorHandler(routeContext, processor);
            }
            list.add(processor);
        }
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(routeContext, list);
            }
        }
        return processor;
    }
    public void clearOutput() {
        getOutputs().clear();
        blocks.clear();
    }
}
"
org.apache.camel.model.ProcessorTypeConfigurationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test to verify end-user exceptions for miss configuration
 */
public class ProcessorTypeConfigurationTest extends ContextTestSupport {
    public void testProcessorRefMissConfigured() throws Exception {
        try {
            context.addRoutes(new RouteBuilder() {
                public void configure() throws Exception {
                    from(""direct:in"").processRef(""hello"");
                }
            });
            fail(""Should have thrown RuntimeCamelException"");
        } catch (IllegalArgumentException e) {
            assertEquals(""target not provided on node: process[ref: hello]"", e.getMessage());
        }
    }
}
"
org.apache.camel.model.RecipientListType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;recipientList/&gt; element
 *
 * @version $Revision: 734353 $
 */
@XmlRootElement(name = ""recipientList"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RecipientListType extends ExpressionNode {
    @XmlAttribute(required = false)
    private String delimiter;
    public RecipientListType() {
    }
    public RecipientListType(ExpressionType expression) {
        super(expression);
    }
    public RecipientListType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""RecipientList["" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""recipientList"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expression = getExpression().createExpression(routeContext);
        // add a tokenizer if we have a delimiter
        if (delimiter != null) {
            expression = ExpressionBuilder.tokenizeExpression(expression, delimiter);
        }
        return new RecipientList(expression);
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getDelimiter() {
        return delimiter;
    }
    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }
}
"
org.apache.camel.model.RedeliveryPolicyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.CamelContext;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.util.CamelContextHelper;
/**
 * Represents an XML &lt;redeliveryPolicy/&gt; element
 *
 * @version $Revision: 719343 $
 */
@XmlRootElement(name = ""redeliveryPolicy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RedeliveryPolicyType {
    @XmlAttribute()
    private String ref;
    @XmlAttribute
    private Integer maximumRedeliveries;
    @XmlAttribute
    private Long initialRedeliveryDelay;
    @XmlAttribute
    private Double backOffMultiplier;
    @XmlAttribute
    private Boolean useExponentialBackOff;
    @XmlAttribute
    private Double collisionAvoidanceFactor;
    @XmlAttribute
    private Boolean useCollisionAvoidance;
    @XmlAttribute
    private Long maximumRedeliveryDelay;
    @XmlAttribute
    private LoggingLevel retriesExhaustedLogLevel;
    @XmlAttribute
    private LoggingLevel retryAttemptedLogLevel;
    public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
        if (ref != null) {
            // lookup in registry if ref provided
            return CamelContextHelper.mandatoryLookup(context, ref, RedeliveryPolicy.class);
        }
        RedeliveryPolicy answer = parentPolicy.copy();
        // copy across the properties - if they are set
        if (maximumRedeliveries != null) {
            answer.setMaximumRedeliveries(maximumRedeliveries);
        }
        if (initialRedeliveryDelay != null) {
            answer.setDelay(initialRedeliveryDelay);
        }
        if (retriesExhaustedLogLevel != null) {
            answer.setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        }
        if (retryAttemptedLogLevel != null) {
            answer.setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        }
        if (backOffMultiplier != null) {
            answer.setBackOffMultiplier(backOffMultiplier);
        }
        if (useExponentialBackOff != null) {
            answer.setUseExponentialBackOff(useExponentialBackOff);
        }
        if (collisionAvoidanceFactor != null) {
            answer.setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        }
        if (useCollisionAvoidance != null) {
            answer.setUseCollisionAvoidance(useCollisionAvoidance);
        }
        if (maximumRedeliveryDelay != null) {
            answer.setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        }
        return answer;
    }
    public String toString() {
        return ""RedeliveryPolicy[maximumRedeliveries: "" + maximumRedeliveries + ""]"";
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public RedeliveryPolicyType backOffMultiplier(double backOffMultiplier) {
        setBackOffMultiplier(backOffMultiplier);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidancePercent(double collisionAvoidancePercent) {
        setCollisionAvoidanceFactor(collisionAvoidancePercent * 0.01d);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public RedeliveryPolicyType initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public RedeliveryPolicyType retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        return this;
    }    
    public RedeliveryPolicyType retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        return this;
    }
    public RedeliveryPolicyType maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public RedeliveryPolicyType useCollisionAvoidance() {
        setUseCollisionAvoidance(Boolean.TRUE);
        return this;
    }
    public RedeliveryPolicyType useExponentialBackOff() {
        setUseExponentialBackOff(Boolean.TRUE);
        return this;
    }
    public RedeliveryPolicyType maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    public RedeliveryPolicyType ref(String ref) {
        setRef(ref);
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public Double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    public void setBackOffMultiplier(Double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public Double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    public void setCollisionAvoidanceFactor(Double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    public Long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }
    public void setInitialRedeliveryDelay(Long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }
    public Integer getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    public void setMaximumRedeliveries(Integer maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public Boolean getUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    public void setUseCollisionAvoidance(Boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public Boolean getUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    public void setUseExponentialBackOff(Boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
    public Long getMaximumRedeliveryDelay() {
        return maximumRedeliveryDelay;
    }
    public void setMaximumRedeliveryDelay(Long maximumRedeliveryDelay) {
        this.maximumRedeliveryDelay = maximumRedeliveryDelay;
    }
    public void setRetriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        this.retriesExhaustedLogLevel = retriesExhaustedLogLevel;
    }
    public LoggingLevel getRetriesExhaustedLogLevel() {
        return retriesExhaustedLogLevel;
    } 
    public void setRetryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        this.retryAttemptedLogLevel = retryAttemptedLogLevel;
    }
    public LoggingLevel getRetryAttemptedLogLevel() {
        return retryAttemptedLogLevel;
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
}
"
org.apache.camel.model.RemoveHeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;removeHeader/&gt; element
 */
@XmlRootElement(name = ""removeHeader"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RemoveHeaderType extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String headerName;   
    public RemoveHeaderType() {
    }
    public RemoveHeaderType(String headerName) {
        setHeaderName(headerName);
    }
    @Override
    public String toString() {
        return ""RemoveHeader["" + getHeaderName() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""removeHeader"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {        
        ObjectHelper.notNull(getHeaderName(), ""headerName"");
        return ProcessorBuilder.removeHeader(getHeaderName());
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return headerName;
    }
}
"
org.apache.camel.model.RemovePropertyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;removeProperty/&gt; element
 */
@XmlRootElement(name = ""removeProperty"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RemovePropertyType extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String propertyName;   
    public RemovePropertyType() {
    }
    public RemovePropertyType(String propertyName) {
        setPropertyName(propertyName);
    }
    @Override
    public String toString() {
        return ""RemoveProperty["" + getPropertyName() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""removeProperty"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {        
        ObjectHelper.notNull(getPropertyName(), ""propertyName"");
        return ProcessorBuilder.removeProperty(getPropertyName());
    }
    public void setPropertyName(String propertyName) {
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.model.ResequencerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.config.BatchResequencerConfig;
import org.apache.camel.model.config.StreamResequencerConfig;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Resequencer;
import org.apache.camel.processor.StreamResequencer;
import org.apache.camel.processor.resequencer.ExpressionResultComparator;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;resequencer/&gt; element
 *
 * @version $Revision: 724629 $
 */
@XmlRootElement(name = ""resequencer"")
public class ResequencerType extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private List<ExpressionType> expressions = new ArrayList<ExpressionType>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    // Binding annotation at setter
    private BatchResequencerConfig batchConfig;
    // Binding annotation at setter
    private StreamResequencerConfig streamConfig;
    @XmlTransient
    private List<Expression> expressionList;
    public ResequencerType() {
        this(null);
    }
    public ResequencerType(List<Expression> expressions) {
        this.expressionList = expressions;
        this.batch();
    }
    @Override
    public String getShortName() {
        return ""resequencer"";
    }
    /**
     * Configures the stream-based resequencing algorithm using the default
     * configuration.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType stream() {
        return stream(StreamResequencerConfig.getDefault());
    }
    /**
     * Configures the batch-based resequencing algorithm using the default
     * configuration.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType batch() {
        return batch(BatchResequencerConfig.getDefault());
    }
    /**
     * Configures the stream-based resequencing algorithm using the given
     * {@link StreamResequencerConfig}.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType stream(StreamResequencerConfig config) {
        this.streamConfig = config;
        this.batchConfig = null;
        return this;
    }
    /**
     * Configures the batch-based resequencing algorithm using the given
     * {@link BatchResequencerConfig}.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType batch(BatchResequencerConfig config) {
        this.batchConfig = config;
        this.streamConfig = null;
        return this;
    }
    public ResequencerType expression(ExpressionType expression) {
        expressions.add(expression);
        return this;
    }
    @Override
    public String toString() {
        return ""Resequencer["" + getExpressions() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return ExpressionType.getLabel(getExpressions());
    }
    public List<ExpressionType> getExpressions() {
        return expressions;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public BatchResequencerConfig getBatchConfig() {
        return batchConfig;
    }
    public BatchResequencerConfig getBatchConfig(BatchResequencerConfig defaultConfig) {
        return batchConfig;
    }
    public StreamResequencerConfig getStreamConfig() {
        return streamConfig;
    }
    @XmlElement(name = ""batch-config"", required = false)
    public void setBatchConfig(BatchResequencerConfig batchConfig) {
        // TODO: find out how to have these two within an <xsd:choice>
        batch(batchConfig);
    }
    @XmlElement(name = ""stream-config"", required = false)
    public void setStreamConfig(StreamResequencerConfig streamConfig) {
        // TODO: find out how to have these two within an <xsd:choice>
        stream(streamConfig);
    }
    public ResequencerType timeout(long timeout) {
        if (batchConfig != null) {
            batchConfig.setBatchTimeout(timeout);
        } else {
            streamConfig.setTimeout(timeout);
        }
        return this;
    }
    public ResequencerType size(int batchSize) {
        if (batchConfig == null) {
            throw new IllegalStateException(""size() only supported for batch resequencer"");
        }
        batchConfig.setBatchSize(batchSize);
        return this;
    }
    public ResequencerType capacity(int capacity) {
        if (streamConfig == null) {
            throw new IllegalStateException(""capacity() only supported for stream resequencer"");
        }
        streamConfig.setCapacity(capacity);
        return this;
    }
    public ResequencerType comparator(ExpressionResultComparator<Exchange> comparator) {
        if (streamConfig == null) {
            throw new IllegalStateException(""comparator() only supported for stream resequencer"");
        }
        streamConfig.setComparator(comparator);
        return this;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        if (batchConfig != null) {
            return createBatchResequencer(routeContext, batchConfig);
        } else {
            // streamConfig should be non-null if batchConfig is null
            return createStreamResequencer(routeContext, streamConfig);
        }
    }
    /**
     * Creates a batch {@link Resequencer} instance applying the given
     * <code>config</code>.
     * 
     * @param routeContext
     *            route context.
     * @param config
     *            batch resequencer configuration.
     * @return the configured batch resequencer.
     * @throws Exception 
     */
    protected Resequencer createBatchResequencer(RouteContext routeContext,
            BatchResequencerConfig config) throws Exception {
        Processor processor = routeContext.createProcessor(this);
        Resequencer resequencer = new Resequencer(processor, resolveExpressionList(routeContext));
        resequencer.setBatchSize(config.getBatchSize());
        resequencer.setBatchTimeout(config.getBatchTimeout());
        return resequencer;
    }
    /**
     * Creates a {@link StreamResequencer} instance applying the given
     * <code>config</code>.
     * 
     * @param routeContext
     *            route context.
     * @param config
     *            stream resequencer configuration.
     * @return the configured stream resequencer.
     * @throws Exception
     */
    protected StreamResequencer createStreamResequencer(RouteContext routeContext, 
            StreamResequencerConfig config) throws Exception {
        config.getComparator().setExpressions(resolveExpressionList(routeContext));
        Processor processor = routeContext.createProcessor(this);
        StreamResequencer resequencer = new StreamResequencer(processor, config.getComparator());
        resequencer.setTimeout(config.getTimeout());
        resequencer.setCapacity(config.getCapacity());
        return resequencer;
    }
    private List<Expression> resolveExpressionList(RouteContext routeContext) {
        if (expressionList == null) {
            expressionList = new ArrayList<Expression>();
            for (ExpressionType expression : expressions) {
                expressionList.add(expression.createExpression(routeContext));
            }
        }
        if (expressionList.isEmpty()) {
            throw new IllegalArgumentException(""No expressions configured for: "" + this);
        }
        return expressionList;
    }
}
"
org.apache.camel.model.RouteBuilderRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;routeBuilderRef/&gt; element
 *
 * @version $Revision: 660266 $
 */
@XmlRootElement(name = ""routeBuilderRef"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RouteBuilderRef extends IdentifiedType {
    @XmlAttribute(required = true)
    private String ref;
    public RouteBuilderRef() {
    }
    public RouteBuilderRef(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        return ""RouteBuilderRef["" + getRef() + ""]"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public RouteBuilder createRouteBuilder(CamelContext camelContext) {
        ObjectHelper.notNull(camelContext, ""camelContext"");
        ObjectHelper.notNull(ref, ""ref"");
        RouteBuilder builder = CamelContextHelper.lookup(camelContext, ref, RouteBuilder.class);
        return builder != null ? builder : CamelContextHelper.newInstance(camelContext, RouteBuilder.class);
    }
}
"
org.apache.camel.model.RouteContainer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.annotation.XmlElementRef;
/**
 * Container to hold {@link org.apache.camel.model.RouteType Route}.
 *
 * @version $Revision: 660266 $
 */
public interface RouteContainer {
    /**
     * Returns the routes
     */
    @XmlElementRef
    List<RouteType> getRoutes();
    /**
     * Sets the routes to use
     */
    void setRoutes(List<RouteType> routes);
}
"
org.apache.camel.model.RoutesType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.processor.DelegateProcessor;
/**
 * Represents a collection of routes
 *
 * @version $Revision: 720799 $
 */
@XmlRootElement(name = ""routes"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RoutesType extends OptionalIdentifiedType<RoutesType> implements RouteContainer {
    // TODO: not sure how else to use an optional attribute in JAXB2
    @XmlAttribute
    private Boolean inheritErrorHandlerFlag;
    @XmlElementRef
    private List<RouteType> routes = new ArrayList<RouteType>();
    // @deprecated will be removed in Camel 2.0
    @XmlElementRef
    private List<ServiceActivationType> activations = new ArrayList<ServiceActivationType>();
    @XmlTransient
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlTransient
    private List<InterceptType> intercepts = new ArrayList<InterceptType>();
    @XmlTransient
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    @XmlTransient
    private CamelContext camelContext;
    @XmlTransient
    private ErrorHandlerBuilder errorHandlerBuilder;
    @Override
    public String toString() {
        return ""Routes: "" + routes;
    }
    // Properties
    //-----------------------------------------------------------------------
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<InterceptType> getIntercepts() {
        return intercepts;
    }
    public void setIntercepts(List<InterceptType> intercepts) {
        this.intercepts = intercepts;
    }
    public List<ExceptionType> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<ExceptionType> exceptions) {
        this.exceptions = exceptions;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public boolean isInheritErrorHandler() {
        return ProcessorType.isInheritErrorHandler(getInheritErrorHandlerFlag());
    }
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        return errorHandlerBuilder;
    }
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    /**
     * Creates a new route
     */
    public RouteType route() {
        RouteType route = createRoute();
        return route(route);
    }
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType route = createRoute();
        route.from(uri);
        return route(route);
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType route = createRoute();
        route.from(endpoint);
        return route(route);
    }
    public RouteType route(RouteType route) {
        // lets configure the route
        route.setCamelContext(getCamelContext());
        route.setInheritErrorHandlerFlag(getInheritErrorHandlerFlag());
        List<InterceptorType> list = getInterceptors();
        for (InterceptorType interceptorType : list) {
            route.addInterceptor(interceptorType);
        }
        List<InterceptType> intercepts = getIntercepts();
        for (InterceptType intercept : intercepts) {
            // need to create a proxy for this one and use the
            // proceed of the proxy which will be local to this route
            InterceptType proxy = intercept.createProxy();
            route.addOutput(proxy);
            route.pushBlock(proxy.getProceed());
        }
        route.getOutputs().addAll(getExceptions());
        getRoutes().add(route);
        return route;
    }
    public RoutesType intercept(DelegateProcessor interceptor) {
        getInterceptors().add(new InterceptorRef(interceptor));
        return this;
    }
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer;
    }
    public ChoiceType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer.when(predicate);
    }
    public ExceptionType onException(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        getExceptions().add(answer);
        return answer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RouteType createRoute() {
        RouteType route = new RouteType();
        ErrorHandlerBuilder handler = getErrorHandlerBuilder();
        if (isInheritErrorHandler() && handler != null) {
            route.setErrorHandlerBuilderIfNull(handler);
        }
        return route;
    }
}
"
org.apache.camel.model.RouteType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Route;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents an XML &lt;route/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""route"")
@XmlType(propOrder = {""inputs"", ""outputs"" })
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RouteType extends ProcessorType<ProcessorType> implements CamelContextAware {
    private static final transient Log LOG = LogFactory.getLog(RouteType.class);
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    private List<FromType> inputs = new ArrayList<FromType>();
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    private String group;
    private CamelContext camelContext;
    private Boolean streamCaching;
    public RouteType() {
    }
    public RouteType(String uri) {
        from(uri);
    }
    public RouteType(Endpoint endpoint) {
        from(endpoint);
    }
    @Override
    public String toString() {
        return ""Route["" + inputs + "" -> "" + outputs + ""]"";
    }
    public void addRoutes(CamelContext context, Collection<Route> routes) throws Exception {
        setCamelContext(context);
        if (context instanceof CamelContext) {
            ErrorHandlerBuilder handler = context.getErrorHandlerBuilder();
            if (handler != null) {
                setErrorHandlerBuilderIfNull(handler);
            }
        }
        for (FromType fromType : inputs) {
            addRoutes(routes, fromType);
        }
    }
    public Endpoint resolveEndpoint(String uri) throws NoSuchEndpointException {
        CamelContext context = getCamelContext();
        if (context == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        return CamelContextHelper.getMandatoryEndpoint(context, uri);
    }
    // Fluent API
    // -----------------------------------------------------------------------
    /**
     * Creates an input to the route
     */
    public RouteType from(String uri) {
        getInputs().add(new FromType(uri));
        return this;
    }
    /**
     * Creates an input to the route
     */
    public RouteType from(Endpoint endpoint) {
        getInputs().add(new FromType(endpoint));
        return this;
    }
    /**
     * Set the group name for this route
     */
    public RouteType group(String name) {
        setGroup(name);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    @XmlTransient
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<FromType> getInputs() {
        return inputs;
    }
    @XmlElementRef
    public void setInputs(List<FromType> inputs) {
        this.inputs = inputs;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    @XmlElementRef
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        // TODO I don't think this is called when using JAXB!
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @XmlTransient
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    /**
     * The group that this route belongs to; could be the name of the RouteBuilder class
     * or be explicitly configured in the XML.
     *
     * May be null.
     */
    public String getGroup() {
        return group;
    }
    @XmlAttribute
    public void setGroup(String group) {
        this.group = group;
    }
    public Boolean getStreamCaching() {
        return streamCaching;
    }
    /**
     * Enable stream caching on this route
     * @param streamCaching <code>true</code> for enabling stream caching
     */
    @XmlAttribute(required = false)
    public void setStreamCaching(Boolean streamCaching) {
        this.streamCaching = streamCaching;
        if (streamCaching != null && streamCaching) {
            streamCaching();
        } else {
            noStreamCaching();
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void addRoutes(Collection<Route> routes, FromType fromType) throws Exception {
        RouteContext routeContext = new DefaultRouteContext(this, fromType, routes);
        routeContext.getEndpoint(); // force endpoint resolution
        if (camelContext != null) {
            camelContext.getLifecycleStrategy().onRouteContextCreate(routeContext);
        }
        List<ProcessorType<?>> list = new ArrayList<ProcessorType<?>>(outputs);
        for (ProcessorType output : list) {
            output.addRoutes(routeContext, routes);
        }
        routeContext.commit();
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        List<InterceptorType> interceptors = getInterceptors();
        for (InterceptorType interceptor : interceptors) {
            output.addInterceptor(interceptor);
        }
/*
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            LOG.warn(""No interceptor collection: "" + output);
        } else {
            list.addAll(getInterceptors());
        }
*/
    }
    /**
     * Disable stream caching for this Route.
     */
    public RouteType noStreamCaching() {
        StreamCachingInterceptor.noStreamCaching(interceptors);
        return this;
    }
    /**
     * Enable stream caching for this Route.
     */
    public RouteType streamCaching() {
        addInterceptor(new StreamCachingInterceptor());
        return this;
    }
    @Override
    public void addInterceptor(InterceptorType interceptor) {
        getInterceptors().add(interceptor);
    }
}
"
org.apache.camel.model.RoutingSlipType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.processor.RoutingSlip;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;routingSlip/&gt; element
 */
@XmlRootElement(name = ""routingSlip"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RoutingSlipType extends ProcessorType<ProcessorType> {
    public static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    public static final String DEFAULT_DELIMITER = "","";
    @XmlAttribute
    private String headerName;
    @XmlAttribute
    private String uriDelimiter;
    public RoutingSlipType() {
        this(ROUTING_SLIP_HEADER, DEFAULT_DELIMITER);
    }
    public RoutingSlipType(String headerName) {
        this(headerName, DEFAULT_DELIMITER);
    }
    public RoutingSlipType(String headerName, String uriDelimiter) {
        setHeaderName(headerName);
        setUriDelimiter(uriDelimiter);
    }
    @Override
    public String toString() {
        return ""RoutingSlip[headerName="" + getHeaderName() + "", uriDelimiter="" + getUriDelimiter() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""routingSlip"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new RoutingSlip(getHeaderName(), getUriDelimiter());
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return this.headerName;
    }
    public void setUriDelimiter(String uriDelimiter) {
        this.uriDelimiter = uriDelimiter;
    }
    public String getUriDelimiter() {
        return uriDelimiter;
    }
}
"
org.apache.camel.model.SendType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Base class for sending to an endpoint with an optional {@link ExchangePattern}
 *
 * @version $Revision: 733652 $
 */
//@XmlType(name = ""sendType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SendType<Type extends ProcessorType> extends ProcessorType<Type> {
    @XmlAttribute(required = false)
    private String uri;
    @XmlAttribute(required = false)
    private String ref;
    @XmlTransient
    private Endpoint endpoint;
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Endpoint endpoint = resolveEndpoint(routeContext);
        return new SendProcessor(endpoint, getPattern());
    }
    public Endpoint resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public ExchangePattern getPattern() {
        return null;
    }
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        String uri = getUri();
        if (ObjectHelper.isEmpty(uri)) {
            return uri;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return getRef();
    }
    @Override
    public String getLabel() {
        return FromType.description(getUri(), getRef(), getEndpoint());
    }
}
"
org.apache.camel.model.ServiceActivationType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.language.ExpressionType;
/**
 * Represents an XML &lt;serviceActivation/&gt; element
 *
 * @deprecated will be removed in Camel 2.0 
 * @version $Revision: 720799 $
 *
 */
@XmlRootElement(name = ""serviceActivation"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ServiceActivationType {
    @XmlAttribute
    private String group = ""default"";
    @XmlElementRef
    private List<ExpressionType> uris = new ArrayList<ExpressionType>();
    public String getGroup() {
        return group;
    }
    public void setGroup(String group) {
        this.group = group;
    }
    public List<ExpressionType> getUris() {
        return uris;
    }
    public void setUris(List<ExpressionType> uris) {
        this.uris = uris;
    }
}
"
org.apache.camel.model.SetBodyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;setBody/&gt; element.
 */
@XmlRootElement(name = ""setBody"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetBodyType extends ExpressionNode {
    public SetBodyType() {
    }
    public SetBodyType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""SetBody["" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setBody"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expr = getExpression().createExpression(routeContext);
        return ProcessorBuilder.setBody(expr);
    }
}
"
org.apache.camel.model.SetExchangePatternType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.processor.ExchangePatternProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;setExchangePattern/&gt; element
 *
 * @version $Revision: 727389 $
 */
@XmlRootElement(name = ""setExchangePattern"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetExchangePatternType extends OutputType {
    @XmlAttribute(required = true)
    private ExchangePattern pattern;
    @XmlTransient
    private ExchangePatternProcessor processor;
    public SetExchangePatternType() {
    }
    public SetExchangePatternType(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    public SetExchangePatternType pattern(ExchangePattern pattern) {
        setPattern(pattern);
        return this;
    }
    public ExchangePattern getPattern() {
        return pattern;
    }
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    @Override
    public String getShortName() {
        return ""setExchangePattern"";
    }
    @Override
    public String toString() {
        return ""setExchangePattern[""
                + ""pattern: "" + pattern
                + ""]"";
    }
    @Override
    public String getLabel() {
        return ""setExchangePattern: "" + pattern;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            processor = new ExchangePatternProcessor(getPattern());
        }
        return processor;
    }
}
"
org.apache.camel.model.SetHeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;setHeader/&gt; element
 */
@XmlRootElement(name = ""setHeader"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetHeaderType extends ExpressionNode {
    @XmlAttribute(required = true)
    private String headerName;
    public SetHeaderType() {
    }
    public SetHeaderType(String headerName, ExpressionType expression) {
        super(expression);
        setHeaderName(headerName);
    }
    public SetHeaderType(String headerName, Expression expression) {
        super(expression);
        setHeaderName(headerName);        
    }
    public SetHeaderType(String headerName, String value) {
        super(ExpressionBuilder.constantExpression(value));
        setHeaderName(headerName);        
    }   
    @Override
    public String toString() {
        return ""SetHeader["" + getHeaderName() + "", "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setHeader"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ObjectHelper.notEmpty(headerName, ""headerName"");
        Expression expr = getExpression().createExpression(routeContext);
        return ProcessorBuilder.setHeader(getHeaderName(), expr);
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return headerName;
    }
}
"
org.apache.camel.model.SetOutHeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;setOutHeader/&gt; element
 */
@XmlRootElement(name = ""setOutHeader"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetOutHeaderType extends ExpressionNode {
    @XmlAttribute(required = true)
    private String headerName;
    public SetOutHeaderType() {
    }
    public SetOutHeaderType(String headerName, ExpressionType expression) {
        super(expression);
        setHeaderName(headerName);
    }
    public SetOutHeaderType(String headerName, Expression expression) {
        super(expression);
        setHeaderName(headerName);        
    }
    @Override
    public String toString() {
        return ""SetOutHeader["" + getHeaderName() + "", "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setOutHeader"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ObjectHelper.notNull(getHeaderName(), ""headerName"");
        Expression expr = getExpression().createExpression(routeContext);
        return ProcessorBuilder.setOutHeader(getHeaderName(), expr);
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return headerName;
    }
}
"
org.apache.camel.model.SetPropertyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;setProperty/&gt; element
 */
@XmlRootElement(name = ""setProperty"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetPropertyType extends ExpressionNode {
    @XmlAttribute(required = true)
    private String propertyName;
    public SetPropertyType() {
    }
    public SetPropertyType(String propertyName, ExpressionType expression) {
        super(expression);
        setPropertyName(propertyName);
    }
    public SetPropertyType(String propertyName, Expression expression) {
        super(expression);
        setPropertyName(propertyName);        
    }
    public SetPropertyType(String propertyName, String value) {
        super(ExpressionBuilder.constantExpression(value));
        setPropertyName(propertyName);        
    }   
    @Override
    public String toString() {
        return ""SetProperty["" + getPropertyName() + "", "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setProperty"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ObjectHelper.notNull(getPropertyName(), ""propertyName"");
        Expression expr = getExpression().createExpression(routeContext);
        return ProcessorBuilder.setProperty(getPropertyName(), expr);
    }
    public void setPropertyName(String propertyName) {
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.model.SplitterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Splitter;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;splitter/&gt; element
 *
 * @version $Revision: 727988 $
 */
@XmlRootElement(name = ""splitter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SplitterType extends ExpressionNode {
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlAttribute(required = false)
    private Boolean parallelProcessing;
    @XmlTransient
    private ThreadPoolExecutor threadPoolExecutor;
    @XmlAttribute(required = false)
    private String threadPoolExecutorRef;
    @XmlAttribute(required = false)
    private Boolean streaming = false;
    public SplitterType() {
    }
    public SplitterType(Expression expression) {
        super(expression);
    }
    public SplitterType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""Splitter["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""splitter"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        if (aggregationStrategy == null) {
            aggregationStrategy = new UseLatestAggregationStrategy();
        }
        threadPoolExecutor = createThreadPoolExecutor(routeContext);
        return new Splitter(getExpression().createExpression(routeContext), childProcessor, aggregationStrategy,
                isParallelProcessing(), threadPoolExecutor, streaming);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Set the spliter's aggregationStrategy
     * @param aggregationStrategy 
     *
     * @return the builder
     */
    public SplitterType aggregationStrategy(AggregationStrategy aggregationStrategy) {
        setAggregationStrategy(aggregationStrategy);
        return this;
    }
    /**
     * Set to run the splitting action parallelly
     * 
     * @return the builder
     */
    public SplitterType parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }
    /**
     * Set the splitting action's thread model
     * @param parallelProcessing <tt>true</tt> to use a thread pool, 
     * if <tt>false</tt> then work is done in the calling thread. 
     *
     * @return the builder
     */
    public SplitterType parallelProcessing(boolean parallelProcessing) {
        setParallelProcessing(parallelProcessing);
        return this;
    }
    /**
     * Enables streaming. 
     * See {@link SplitterType#setStreaming(boolean)} for more information
     *
     * @return the builder
     */
    public SplitterType streaming() {
        setStreaming(true);
        return this;
    }
    /**
     * Setting the executor for executing the splitting action. 
     * @param executor , it should be a instance of ThreadPoolExcutor
     * NOTE in Camel 2.0 , it will change to use the instance which implements Executor interface
     * @return the builder
     */
    public SplitterType executor(ThreadPoolExecutor executor) {
        setThreadPoolExecutor(executor);
        return this;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
    public boolean isParallelProcessing() {
        return parallelProcessing != null ? parallelProcessing : false;
    }
    public void setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;
    }
    /**
     * The splitter should use streaming -- exchanges are being sent as the data for them becomes available.
     * This improves throughput and memory usage, but it has a drawback: 
     * - the sent exchanges will no longer contain the {@link Splitter#SPLIT_SIZE} header property 
     * 
     * @return whether or not streaming should be used
     */
    public boolean isStreaming() {
        return streaming != null ? streaming : false;
    }
    public void setStreaming(boolean streaming) {
        this.streaming = streaming;
    }
    private ThreadPoolExecutor createThreadPoolExecutor(RouteContext routeContext) {
        ThreadPoolExecutor threadPoolExecutor = getThreadPoolExecutor();
        if (threadPoolExecutor == null && threadPoolExecutorRef != null) {
            threadPoolExecutor = routeContext.lookup(threadPoolExecutorRef, ThreadPoolExecutor.class);
        }
        if (threadPoolExecutor == null) {
            // fall back and use default
            threadPoolExecutor = new ThreadPoolExecutor(4, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
        }
        return threadPoolExecutor;
    }    
    public ThreadPoolExecutor getThreadPoolExecutor() {
        return threadPoolExecutor;
    }
    public void setThreadPoolExecutor(ThreadPoolExecutor threadPoolExecutor) {
        this.threadPoolExecutor = threadPoolExecutor;
    }
}
"
org.apache.camel.model.ThreadType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ThreadProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;thread/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""thread"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThreadType extends ProcessorType<ProcessorType> {
    @XmlAttribute(required = false)
    private Integer coreSize = 1;
    @XmlAttribute(required = false)
    private Boolean daemon = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Long keepAliveTime;
    @XmlAttribute(required = false)
    private Integer maxSize = 1;
    @XmlAttribute(required = false)
    private String name = ""Thread Processor"";
    @XmlAttribute(required = false)
    private Integer priority = Thread.NORM_PRIORITY;
    @XmlAttribute(required = false)
    private Long stackSize;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private BlockingQueue<Runnable> taskQueue;
    @XmlTransient
    private ThreadGroup threadGroup;
    @XmlTransient
    private ThreadPoolExecutor executor;
    public ThreadType() {
    }
    public ThreadType(int coreSize) {
        this.coreSize = coreSize;
        this.maxSize = coreSize;
    }
    public ThreadType(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    @Override
    public String toString() {
        return ""Thread["" + name + ""]"";
    }
    @Override
    public String getShortName() {
        return ""thread"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ThreadProcessor thread = new ThreadProcessor();
        thread.setExecutor(executor);
        if (coreSize != null) {
            thread.setCoreSize(coreSize);
        }
        if (daemon != null) {
            thread.setDaemon(daemon);
        }
        if (keepAliveTime != null) {
            thread.setKeepAliveTime(keepAliveTime);
        }
        if (maxSize != null) {
            thread.setMaxSize(maxSize);
        }
        thread.setName(name);
        thread.setPriority(priority);
        if (stackSize != null) {
            thread.setStackSize(stackSize);
        }
        thread.setTaskQueue(taskQueue);
        thread.setThreadGroup(threadGroup);
        // TODO: see if we can avoid creating so many nested pipelines
        ArrayList<Processor> pipe = new ArrayList<Processor>(2);
        pipe.add(thread);
        pipe.add(createOutputsProcessor(routeContext, outputs));
        return new Pipeline(pipe);
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
    }
    // Fluent methods
    // -----------------------------------------------------------------------
    @Override
    public ProcessorType errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        // do not support setting error handling on thread type as its confusing and will not be used
        throw new IllegalArgumentException(""Setting errorHandler on ThreadType is not supported.""
            + "" Instead set the errorHandler on the parent."");
    }
    public ThreadType coreSize(int coreSize) {
        setCoreSize(coreSize);
        return this;
    }
    public ThreadType daemon(boolean daemon) {
        setDaemon(daemon);
        return this;
    }
    public ThreadType keepAliveTime(long keepAliveTime) {
        setKeepAliveTime(keepAliveTime);
        return this;
    }
    public ThreadType maxSize(int maxSize) {
        setMaxSize(maxSize);
        return this;
    }
    public ThreadType name(String name) {
        setName(name);
        return this;
    }
    public ThreadType priority(int priority) {
        setPriority(priority);
        return this;
    }
    public ThreadType stackSize(long stackSize) {
        setStackSize(stackSize);
        return this;
    }
    public ThreadType taskQueue(BlockingQueue<Runnable> taskQueue) {
        setTaskQueue(taskQueue);
        return this;
    }
    public ThreadType threadGroup(ThreadGroup threadGroup) {
        setThreadGroup(threadGroup);
        return this;
    }
    public ThreadType executor(ThreadPoolExecutor executor) {
        setExecutor(executor);
        return this;
    }
    ///////////////////////////////////////////////////////////////////
    //
    // Property Accessors
    //
    ///////////////////////////////////////////////////////////////////
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public ThreadPoolExecutor getExecutor() {
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
}
"
org.apache.camel.model.ThrottlerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.processor.Throttler;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;throttler/&gt; element
 *
 * @version $Revision: 727389 $
 */
@XmlRootElement(name = ""throttler"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThrottlerType extends ProcessorType<ProcessorType> {
    @XmlAttribute
    private Long maximumRequestsPerPeriod;
    @XmlAttribute
    private long timePeriodMillis = 1000;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public ThrottlerType() {
    }
    public ThrottlerType(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    @Override
    public String toString() {
        return ""Throttler["" + getMaximumRequestsPerPeriod() + "" request per "" + getTimePeriodMillis()
               + "" millis -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""throttler"";
    }
    @Override
    public String getLabel() {
        return """" + getMaximumRequestsPerPeriod() + "" per "" + getTimePeriodMillis() + "" (ms)"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new Throttler(childProcessor, maximumRequestsPerPeriod, timePeriodMillis);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sets the time period during which the maximum request count is valid for
     */
    public ThrottlerType timePeriodMillis(long timePeriodMillis) {
        setTimePeriodMillis(timePeriodMillis);
        return this;
    }
    /**
     * Sets the time period during which the maximum request count per period
     *
     * @param maximumRequestsPerPeriod  the maximum request count number per time period
     * @return the builder
     */
    public ThrottlerType maximumRequestsPerPeriod(Long maximumRequestsPerPeriod) {
        setMaximumRequestsPerPeriod(maximumRequestsPerPeriod);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    public void setMaximumRequestsPerPeriod(Long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
}
"
org.apache.camel.model.ThrowFaultType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelException;
import org.apache.camel.Processor;
import org.apache.camel.processor.ThrowFaultProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;throwFault/&gt; element
 */
@XmlRootElement(name = ""throwFault"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThrowFaultType extends ProcessorType<ThrowFaultType> {
    @XmlTransient
    private Throwable fault;
    @XmlTransient
    private Processor processor;
    @XmlAttribute (required = true)
    private String faultRef;
    public ThrowFaultType() {
    }
    @Override
    public String getShortName() {
        return ""throwFault"";
    }
    @Override
    public String toString() {
        if (faultRef != null) {
            return ""ThrowFault[ref: "" + faultRef + ""]"";
        } else {
            return ""ThrowFault["" + fault.getClass().getCanonicalName();
        }
    }
    public void setFault(Throwable fault) {
        this.fault = fault;
    }
    public Throwable getFault() {
        return fault;
    }
    public void setFaultRef(String ref) {
        this.faultRef = ref;
    }
    public String getFaultRef() {
        return faultRef;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            if (fault == null) {
                fault = routeContext.lookup(faultRef, Throwable.class);
                if (fault == null) {
                    // can't find the fault instance, create a new one
                    fault = new CamelException(faultRef);
                }
            }
            processor = new ThrowFaultProcessor(fault);
        }
        return processor;
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
}
"
org.apache.camel.model.ToType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
/**
 * Represents an XML &lt;to/&gt; element
 *
 * @version $Revision: 725675 $
 */
@XmlRootElement(name = ""to"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ToType extends SendType<ToType> {
    @XmlAttribute(required = false)
    private ExchangePattern pattern;
    public ToType() {
    }
    public ToType(String uri) {
        setUri(uri);
    }
    public ToType(Endpoint endpoint) {
        setEndpoint(endpoint);
    }
    public ToType(String uri, ExchangePattern pattern) {
        this(uri);
        this.pattern = pattern;
    }
    public ToType(Endpoint endpoint, ExchangePattern pattern) {
        this(endpoint);
        this.pattern = pattern;
    }
    @Override
    public String toString() {
        return ""To["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""to"";
    }
    @Override
    public ExchangePattern getPattern() {
        return pattern;
    }
    /**
     * Sets the optional {@link ExchangePattern} used to invoke this endpoint
     */
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
}
"
org.apache.camel.model.TransformType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.TransformProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;transform/&gt; element
 */
@XmlRootElement(name = ""transform"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TransformType extends ExpressionNode {
    public TransformType() {
    }
    public TransformType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""Transform["" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""transform"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expr = getExpression().createExpression(routeContext);
        Processor childProcessor = routeContext.createProcessor(this);
        return new TransformProcessor(expr, childProcessor);
    }
}
"
org.apache.camel.model.TryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.TryProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;try/&gt; element
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""try"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TryType extends OutputType<TryType> {
    @XmlTransient
    private List<CatchType> catchClauses;
    @XmlTransient
    private FinallyType finallyClause;
    @XmlTransient
    private boolean initialized;
    @XmlTransient
    private List<ProcessorType<?>> outputsWithoutCatches;
    @Override
    public String toString() {
        return ""Try["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""try"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor tryProcessor = createOutputsProcessor(routeContext, getOutputsWithoutCatches());
        Processor finallyProcessor = null;
        if (finallyClause != null) {
            finallyProcessor = finallyClause.createProcessor(routeContext);
        }
        List<CatchProcessor> catchProcessors = new ArrayList<CatchProcessor>();
        if (catchClauses != null) {
            for (CatchType catchClause : catchClauses) {
                catchProcessors.add(catchClause.createProcessor(routeContext));
            }
        }
        return new TryProcessor(tryProcessor, catchProcessors, finallyProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public TryType handle(Class<?> exceptionType) {
        popBlock();
        CatchType answer = new CatchType(exceptionType);
        addOutput(answer);
        pushBlock(answer);
        return this;
    }
    /**
     * @deprecated Use {@link #finallyBlock()} instead, as the name
     * is better. Current name sugests that it handles exception,
     * while it mimics java finally keyword. Will be removed in Camel 2.0.
     */
    @Deprecated
    public TryType handleAll() {
        return finallyBlock();
    }
    public TryType finallyBlock() {
        popBlock();
        FinallyType answer = new FinallyType();
        addOutput(answer);
        pushBlock(answer);
        return this;
    }
    @Override
    public ProcessorType<? extends ProcessorType> end() {
        popBlock();
        return super.end();
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<CatchType> getCatchClauses() {
        if (catchClauses == null) {
            checkInitialized();
        }
        return catchClauses;
    }
    public FinallyType getFinallyClause() {
        if (finallyClause == null) {
            checkInitialized();
        }
        return finallyClause;
    }
    public List<ProcessorType<?>> getOutputsWithoutCatches() {
        if (outputsWithoutCatches == null) {
            checkInitialized();
        }
        return outputsWithoutCatches;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        initialized = false;
        super.setOutputs(outputs);
    }
    @Override
    public void addOutput(ProcessorType output) {
        initialized = false;
        super.addOutput(output);
    }
    /**
     * Checks whether or not this object has been initialized
     */
    protected void checkInitialized() {
        if (!initialized) {
            initialized = true;
            outputsWithoutCatches = new ArrayList<ProcessorType<?>>();
            catchClauses = new ArrayList<CatchType>();
            finallyClause = null;
            for (ProcessorType output : outputs) {
                if (output instanceof CatchType) {
                    catchClauses.add((CatchType)output);
                } else if (output instanceof FinallyType) {
                    if (finallyClause != null) {
                        throw new IllegalArgumentException(""Multiple finally clauses added: "" + finallyClause
                                                           + "" and "" + output);
                    } else {
                        finallyClause = (FinallyType)output;
                    }
                } else {
                    outputsWithoutCatches.add(output);
                }
            }
        }
    }
}
"
org.apache.camel.model.UnmarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.FlatpackDataFormat;
import org.apache.camel.model.dataformat.HL7DataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.TidyMarkupDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.dataformat.XStreamDataFormat;
import org.apache.camel.model.dataformat.ZipDataFormat;
import org.apache.camel.processor.UnmarshalProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Unmarshals the binary payload using the given {@link DataFormatType}
 *
 * @version $Revision: 727622 $
 */
@XmlRootElement(name = ""unmarshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class UnmarshalType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    // TODO cannot use @XmlElementRef as it doesn't allow optional properties
    // @XmlElementRef
    @XmlElements({
    @XmlElement(required = false, name = ""artixDS"", type = ArtixDSDataFormat.class),
    @XmlElement(required = false, name = ""csv"", type = CsvDataFormat.class),
    @XmlElement(required = false, name = ""flatpack"", type = FlatpackDataFormat.class),
    @XmlElement(required = false, name = ""hl7"", type = HL7DataFormat.class),
    @XmlElement(required = false, name = ""jaxb"", type = JaxbDataFormat.class),
    @XmlElement(required = false, name = ""serialization"", type = SerializationDataFormat.class),
    @XmlElement(required = false, name = ""string"", type = StringDataFormat.class),
    @XmlElement(required = false, name = ""tidyMarkup"", type = TidyMarkupDataFormat.class),    
    @XmlElement(required = false, name = ""xmlBeans"", type = XMLBeansDataFormat.class),
    @XmlElement(required = false, name = ""xstream"", type = XStreamDataFormat.class),
    @XmlElement(required = false, name = ""zip"", type = ZipDataFormat.class)}
    )
    private DataFormatType dataFormatType;
    public UnmarshalType() {
    }
    public UnmarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public UnmarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        } else {
            return ""Marshal[ref: "" + ref + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""unmarshal"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormat dataFormat = DataFormatType.getDataFormat(routeContext, getDataFormatType(), ref);
        return new UnmarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.WhenType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;when/&gt; element
 * 
 * @version $Revision: 705880 $
 */
@XmlRootElement(name = ""when"")
public class WhenType<Type extends ProcessorType> extends ExpressionNode {
    public WhenType() {
    }
    public WhenType(Predicate predicate) {
        super(predicate);
    }
    public WhenType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""When["" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""when"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.XmlParseTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.xml.bind.JAXBException;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
/**
 * @version $Revision: 699766 $
 */
public class XmlParseTest extends XmlTestSupport {
    public void testParseSimpleRouteXml() throws Exception {
        RouteType route = assertOneRoute(""simpleRoute.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:b"");
    }
    public void testParseProcessorXml() throws Exception {
        RouteType route = assertOneRoute(""processor.xml"");
        assertFrom(route, ""seda:a"");
        ProcessorRef to = assertOneProcessorInstanceOf(ProcessorRef.class, route);
        assertEquals(""Processor ref"", ""myProcessor"", to.getRef());
    }
    public void testParseProcessorWithFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertOneProcessorInstanceOf(FilterType.class, route);
        assertExpression(filter.getExpression(), ""juel"", ""in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithHeaderFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithHeaderFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertOneProcessorInstanceOf(FilterType.class, route);
        assertExpression(filter.getExpression(), ""header"", ""foo"");
    }
    public void testParseProcessorWithElFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithElFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertOneProcessorInstanceOf(FilterType.class, route);
        assertExpression(filter.getExpression(), ""el"", ""$in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithGroovyFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithGroovyFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertOneProcessorInstanceOf(FilterType.class, route);
        assertExpression(filter.getExpression(), ""groovy"", ""in.headers.any { h -> h.startsWith('foo')}"");
    }
    public void testParseRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""dynamicRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        RecipientListType node = assertOneProcessorInstanceOf(RecipientListType.class, route);
        assertExpression(node.getExpression(), ""header"", ""foo"");
    }
    public void testParseStaticRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""staticRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(route, ""seda:b"", ""seda:c"", ""seda:d"");
    }
    public void testParseTransformXml() throws Exception {
        RouteType route = assertOneRoute(""transform.xml"");
        assertFrom(route, ""direct:start"");
        TransformType node = assertNthProcessorInstanceOf(TransformType.class, route, 0);
        assertExpression(node.getExpression(), ""simple"", ""${in.body} extra data!"");
        assertChildTo(route, ""mock:end"", 1);
    }
    public void testParseSetBodyXml() throws Exception {
        RouteType route = assertOneRoute(""setBody.xml"");
        assertFrom(route, ""direct:start"");
        SetBodyType node = assertNthProcessorInstanceOf(SetBodyType.class, route, 0);
        assertExpression(node.getExpression(), ""simple"", ""${in.body} extra data!"");
        assertChildTo(route, ""mock:end"", 1);
    }
    public void testParseSetHeaderXml() throws Exception {
        RouteType route = assertOneRoute(""setHeader.xml"");
        assertFrom(route, ""seda:a"");
        SetHeaderType node = assertNthProcessorInstanceOf(SetHeaderType.class, route, 0);
        assertEquals(""oldBodyValue"", node.getHeaderName());
        assertExpression(node.getExpression(), ""simple"", ""body"");
        assertChildTo(route, ""mock:b"", 1);
    }
    public void testParseSetHeaderToConstantXml() throws Exception {
        RouteType route = assertOneRoute(""setHeaderToConstant.xml"");
        assertFrom(route, ""seda:a"");
        SetHeaderType node = assertNthProcessorInstanceOf(SetHeaderType.class, route, 0);
        assertEquals(""theHeader"", node.getHeaderName());
        assertExpression(node.getExpression(), ""constant"", ""a value"");
        assertChildTo(route, ""mock:b"", 1);
    }
    public void testParseSetOutHeaderXml() throws Exception {
        RouteType route = assertOneRoute(""setOutHeader.xml"");
        assertFrom(route, ""seda:a"");
        SetOutHeaderType node = assertNthProcessorInstanceOf(SetOutHeaderType.class, route, 0);
        assertEquals(""oldBodyValue"", node.getHeaderName());
        assertExpression(node.getExpression(), ""simple"", ""body"");
        assertChildTo(route, ""mock:b"", 1);
    }
    public void testParseSetOutHeaderToConstantXml() throws Exception {
        RouteType route = assertOneRoute(""setOutHeaderToConstant.xml"");
        assertFrom(route, ""seda:a"");
        SetOutHeaderType node = assertNthProcessorInstanceOf(SetOutHeaderType.class, route, 0);
        assertEquals(""theHeader"", node.getHeaderName());
        assertExpression(node.getExpression(), ""constant"", ""a value"");
        assertChildTo(route, ""mock:b"", 1);
    }
    public void testParseConvertBodyXml() throws Exception {
        RouteType route = assertOneRoute(""convertBody.xml"");
        assertFrom(route, ""seda:a"");
        ConvertBodyType node = assertOneProcessorInstanceOf(ConvertBodyType.class, route);
        assertEquals(""java.lang.Integer"", node.getType());
        assertEquals(Integer.class, node.getTypeClass());
    }
    public void testParseRoutingSlipXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlip.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertOneProcessorInstanceOf(RoutingSlipType.class, route);
        assertEquals(RoutingSlipType.ROUTING_SLIP_HEADER, node.getHeaderName());
        assertEquals(RoutingSlipType.DEFAULT_DELIMITER, node.getUriDelimiter());
    }
    public void testParseRoutingSlipWithHeaderSetXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlipHeaderSet.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertOneProcessorInstanceOf(RoutingSlipType.class, route);
        assertEquals(""theRoutingSlipHeader"", node.getHeaderName());
        assertEquals(RoutingSlipType.DEFAULT_DELIMITER, node.getUriDelimiter());
    }
    public void testParseRoutingSlipWithHeaderAndDelimiterSetXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlipHeaderAndDelimiterSet.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertOneProcessorInstanceOf(RoutingSlipType.class, route);
        assertEquals(""theRoutingSlipHeader"", node.getHeaderName());
        assertEquals(""#"", node.getUriDelimiter());
    }
    //TODO get the test fixed
    public void xtestParseRouteWithInterceptorXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithInterceptor.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:d"");
        assertInterceptorRefs(route, ""interceptor1"", ""interceptor2"");
    }
    @SuppressWarnings(""unchecked"")
    public void testParseRouteWithChoiceXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithChoice.xml"");
        assertFrom(route, ""seda:a"");
        ChoiceType choice = assertOneProcessorInstanceOf(ChoiceType.class, route);
        List<WhenType> whens = assertListSize(choice.getWhenClauses(), 2);
        assertChildTo(""when(0)"", whens.get(0), ""seda:b"");
        assertChildTo(""when(1)"", whens.get(1), ""seda:c"");
        OtherwiseType otherwise = choice.getOtherwise();
        assertNotNull(""Otherwise is null"", otherwise);
        assertChildTo(""otherwise"", otherwise, ""seda:d"");
    }
    public void testParseSplitterXml() throws Exception {
        RouteType route = assertOneRoute(""splitter.xml"");
        assertFrom(route, ""seda:a"");
        SplitterType splitter = assertOneProcessorInstanceOf(SplitterType.class, route);
        assertExpression(splitter.getExpression(), ""xpath"", ""/foo/bar"");
        assertChildTo(""to"", splitter, ""seda:b"");
    }
    public void testParseLoadBalance() throws Exception {
        RouteType route = assertOneRoute(""routeWithLoadBalance.xml"");
        assertFrom(route, ""seda:a"");
        LoadBalanceType loadBalance = assertOneProcessorInstanceOf(LoadBalanceType.class, route);
        assertEquals(""Here should have 3 output here"", 3, loadBalance.getOutputs().size());
        assertTrue(""The loadBalancer shoud be RoundRobinLoadBalanceStrategy"", loadBalance.getLoadBalancerType() instanceof RoundRobinLoadBalanceStrategy);
    }
    public void testParseStickyLoadBalance() throws Exception {
        RouteType route = assertOneRoute(""routeWithStickyLoadBalance.xml"");
        assertFrom(route, ""seda:a"");
        LoadBalanceType loadBalance = assertOneProcessorInstanceOf(LoadBalanceType.class, route);
        assertEquals(""Here should have 3 output here"", 3, loadBalance.getOutputs().size());
        assertTrue(""The loadBalancer shoud be StickyLoadBalanceStrategy"", loadBalance.getLoadBalancerType() instanceof StickyLoadBalanceStrategy);
        StickyLoadBalanceStrategy strategy = (StickyLoadBalanceStrategy)loadBalance.getLoadBalancerType();
        assertNotNull(""the expression should not be null "", strategy.getExpressionType());
    }
    public void testParseBatchResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerBatch.xml"");
        ResequencerType resequencer = assertOneProcessorInstanceOf(ResequencerType.class, route);
        assertNull(resequencer.getStreamConfig());
        assertNotNull(resequencer.getBatchConfig());
        assertEquals(500, resequencer.getBatchConfig().getBatchSize());
        assertEquals(2000L, resequencer.getBatchConfig().getBatchTimeout());
    }
    public void testParseStreamResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerStream.xml"");
        ResequencerType resequencer = assertOneProcessorInstanceOf(ResequencerType.class, route);
        assertNotNull(resequencer.getStreamConfig());
        assertNull(resequencer.getBatchConfig());
        assertEquals(1000, resequencer.getStreamConfig().getCapacity());
        assertEquals(2000L, resequencer.getStreamConfig().getTimeout());
    }
    public void testLoop() throws Exception {
        RouteType route = assertOneRoute(""loop.xml"");
        LoopType loop = assertOneProcessorInstanceOf(LoopType.class, route);
        assertNotNull(loop.getExpression());
        assertEquals(""constant"", loop.getExpression().getLanguage());
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected RouteType assertOneRoute(String uri) throws JAXBException {
        RouteContainer context = assertParseAsJaxb(uri);
        RouteType route = assertOneElement(context.getRoutes());
        return route;
    }
    protected void assertFrom(RouteType route, String uri) {
        FromType from = assertOneElement(route.getInputs());
        assertEquals(""From URI"", uri, from.getUri());
    }
    protected void assertChildTo(String message, ProcessorType<?> route, String uri) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertTo(String message, ProcessorType<?> processor, String uri) {
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertChildTo(ProcessorType<?> route, String... uris) {
        List<ProcessorType<?>> list = assertListSize(route.getOutputs(), uris.length);
        int idx = 0;
        for (String uri : uris) {
            assertTo(""output["" + idx + ""] "", list.get(idx++), uri);
        }
    }
    protected void assertChildTo(ProcessorType<?> route, String uri, int toIdx) {
        List<ProcessorType<?>> list = route.getOutputs();
        assertTo(""to and idx="" + toIdx, list.get(toIdx), uri);
    }
    protected <T> T assertOneProcessorInstanceOf(Class<T> type, ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(type, processor);
    }
    protected <T> T assertNthProcessorInstanceOf(Class<T> type, ProcessorType<?> route, int index) {
        ProcessorType<?> processor = route.getOutputs().get(index);
        return assertIsInstanceOf(type, processor);
    }
    protected void assertExpression(ExpressionType expression, String language, String languageExpression) {
        assertNotNull(""Expression should not be null!"", expression);
        assertEquals(""Expression language"", language, expression.getLanguage());
        assertEquals(""Expression"", languageExpression, expression.getExpression());
    }
    protected void assertInterceptorRefs(ProcessorType route, String... names) {
        RouteType rt = (RouteType)route;
        assertNotNull(rt);
        // Rely on the fact that reference ids are unique
        List<InterceptorType> interceptors = rt.getInterceptors();
        assertEquals(""Interceptor count does not match"", names.length, interceptors.size());
        Set<String> refs = new HashSet<String>();
        for (InterceptorType it : interceptors) {
            InterceptorRef ir = assertIsInstanceOf(InterceptorRef.class, it);
            refs.add(ir.getRef());
        }
        for (String name : names) {
            assertTrue(""Interceptor \"""" + name + ""\"" not found"", refs.contains(name));
        }
    }
}
"
org.apache.camel.model.XmlTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.net.URL;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.TestSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 725598 $
 */
public abstract class XmlTestSupport extends TestSupport {
    protected final transient Log log = LogFactory.getLog(getClass());
    protected JAXBContext jaxbContext;
    protected RouteContainer assertParseAsJaxb(String uri) throws JAXBException {
        Object value = parseUri(uri);
        RouteContainer context = assertIsInstanceOf(RouteContainer.class, value);
        log.info(""Found: "" + context);
        return context;
    }
    protected Object parseUri(String uri) throws JAXBException {
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        URL resource = getClass().getResource(uri);
        assertNotNull(""Cannot find resource on the classpath: "" + uri, resource);
        Object value = unmarshaller.unmarshal(resource);
        return value;
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        jaxbContext = JAXBContext
            .newInstance(""org.apache.camel:org.apache.camel.model:org.apache.camel.model.config:org.apache.camel.model.dataformat:org.apache.camel.model.language:org.apache.camel.model.loadbalancer"");
    }
}
"
org.apache.camel.model.config.BatchResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.Resequencer;
/**
 * Defines the configuration parameters for the batch-processing
 * {@link Resequencer}. Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         BatchResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * or
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>batchSize</code> and <code>batchTimeout</code>
 * can be set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         new BatchResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630568 $
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class BatchResequencerConfig {
    @XmlAttribute
    private Integer batchSize; // optional XML attribute requires wrapper object 
    @XmlAttribute
    private Long batchTimeout; // optional XML attribute requires wrapper object
    /**
     * Creates a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     */
    public BatchResequencerConfig() {
        this(100, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>batchSize</code> and <code>batchTimeout</code>.
     * 
     * @param batchSize
     *            size of the batch to be re-ordered.
     * @param batchTimeout
     *            timeout for collecting elements to be re-ordered.
     */
    public BatchResequencerConfig(int batchSize, long batchTimeout) {
        this.batchSize = batchSize;
        this.batchTimeout = batchTimeout;
    }
    /**
     * Returns a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     * 
     * @return a default {@link BatchResequencerConfig}.
     */
    public static BatchResequencerConfig getDefault() {
        return new BatchResequencerConfig();
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
}
"
org.apache.camel.model.config.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The Resequencer Configuration classes
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.config;
"
org.apache.camel.model.config.StreamResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.processor.StreamResequencer;
import org.apache.camel.processor.resequencer.DefaultExchangeComparator;
import org.apache.camel.processor.resequencer.ExpressionResultComparator;
/**
 * Defines the configuration parameters for the {@link StreamResequencer}.
 * Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         StreamResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>capacity</code> and <code>timeout</code> can be
 * set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         new StreamResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class StreamResequencerConfig {
    @XmlAttribute
    private Integer capacity; // optional XML attribute requires wrapper object
    @XmlAttribute
    private Long timeout; // optional XML attribute requires wrapper object
    @XmlTransient
    private ExpressionResultComparator<Exchange> comparator;
    /**
     * Creates a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (1000) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     */
    public StreamResequencerConfig() {
        this(1000, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared using the {@link DefaultExchangeComparator}.
     * 
     * @param capacity   capacity of the resequencer's inbound queue.
     * @param timeout    minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout) {
        this(capacity, timeout, new DefaultExchangeComparator());
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared with the given
     * {@link ExpressionResultComparator}.
     * 
     * @param capacity   capacity of the resequencer's inbound queue.
     * @param timeout    minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout, ExpressionResultComparator<Exchange> comparator) {
        this.capacity = capacity;
        this.timeout = timeout;
        this.comparator = comparator;
    }
    /**
     * Returns a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (1000) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     * 
     * @return a default {@link StreamResequencerConfig}.
     */
    public static StreamResequencerConfig getDefault() {
        return new StreamResequencerConfig();
    }
    public int getCapacity() {
        return capacity;
    }
    public void setCapacity(int capacity) {
        this.capacity = capacity;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public ExpressionResultComparator<Exchange> getComparator() {
        return comparator;
    }
    public void setComparator(ExpressionResultComparator<Exchange> comparator) {
        this.comparator = comparator;
    }
}
"
org.apache.camel.model.dataformat.ArtixDSContentType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlEnum;
/**
 * @version $Revision: 640438 $
 */
@XmlEnum(String.class)
public enum ArtixDSContentType {
    Default, Auto, Binary, Text, Java, Xml, Sax, TagValuePair
}
"
org.apache.camel.model.dataformat.ArtixDSDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents the <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
 * {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""artixDS"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ArtixDSDataFormat extends DataFormatType {
    private static final transient Log LOG = LogFactory.getLog(ArtixDSDataFormat.class);
    @XmlAttribute(required = false)
    private String elementTypeName;
    @XmlAttribute(required = false)
    private String format;
    @XmlAttribute(required = false)
    private Class<?> elementType;
    @XmlAttribute(required = false)
    private ArtixDSContentType contentType;
    public ArtixDSDataFormat() {
        super(""org.apache.camel.artix.ds.ArtixDSFormat"");
    }
    public ArtixDSDataFormat(Class<?> elementType) {
        this();
        this.elementType = elementType;
    }
    public ArtixDSDataFormat(Class<?> elementType, ArtixDSContentType contentType) {
        this();
        this.elementType = elementType;
        this.contentType = contentType;
    }
    public ArtixDSDataFormat(ArtixDSContentType contentType) {
        this();
        this.contentType = contentType;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getElementTypeName() {
        return elementTypeName;
    }
    public void setElementTypeName(String elementTypeName) {
        this.elementTypeName = elementTypeName;
    }
    public ArtixDSContentType getContentType() {
        return contentType;
    }
    public void setContentType(ArtixDSContentType contentType) {
        this.contentType = contentType;
    }
    public Class<?> getElementType() {
        if (elementType == null) {
            if (elementTypeName != null) {
                elementType = ObjectHelper.loadClass(elementTypeName, getClass().getClassLoader());
                if (elementType == null) {
                    throw new IllegalArgumentException(""The ArtixDS Element class "" + elementTypeName + "" is not on the classpath! Cannot use the dataFormat "" + this);
                }
            }
        }
        return elementType;
    }
    public void setElementType(Class<?> elementType) {
        this.elementType = elementType;
    }
    public String getFormat() {
        return format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Class<?> type = getElementType();
        if (type != null) {
            setProperty(dataFormat, ""elementType"", type);
        }
        ArtixDSContentType content = getContentType();
        if (content != null) {
            setProperty(dataFormat, ""contentType"", content);
        }
    }
}
"
org.apache.camel.model.dataformat.CsvDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents a CSV (Comma Separated Values) {@link DataFormat}
 *
 * @version $Revision: 686463 $
 */
@XmlRootElement(name = ""csv"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CsvDataFormat extends DataFormatType {
    public CsvDataFormat() {
        super(""org.apache.camel.dataformat.csv.CsvDataFormat"");
    }
}
"
org.apache.camel.model.dataformat.DataFormatsType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
/**
 * Represents the XML type for a collection of DataFormats.
 */
@XmlRootElement(name = ""dataFormats"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DataFormatsType {
    // TODO cannot use @XmlElementRef as it doesn't allow optional properties
    // @XmlElementRef
    @XmlElements({
        @XmlElement(required = false, name = ""artixDS"", type = ArtixDSDataFormat.class),
        @XmlElement(required = false, name = ""csv"", type = CsvDataFormat.class),        
        @XmlElement(required = false, name = ""flatpack"", type = FlatpackDataFormat.class),
        @XmlElement(required = false, name = ""hl7"", type = HL7DataFormat.class),
        @XmlElement(required = false, name = ""jaxb"", type = JaxbDataFormat.class),
        @XmlElement(required = false, name = ""json"", type = JsonDataFormat.class),
        @XmlElement(required = false, name = ""serialization"", type = SerializationDataFormat.class),
        @XmlElement(required = false, name = ""string"", type = StringDataFormat.class),
        @XmlElement(required = false, name = ""tidyMarkup"", type = TidyMarkupDataFormat.class),        
        @XmlElement(required = false, name = ""xmlBeans"", type = XMLBeansDataFormat.class),
        @XmlElement(required = false, name = ""xstream"", type = XStreamDataFormat.class),
        @XmlElement(required = false, name = ""zip"", type = ZipDataFormat.class)}
        )
    private List<DataFormatType> dataFormats;
    public void setDataFormats(List<DataFormatType> dataFormats) {
        this.dataFormats = dataFormats;
    }
    public List<DataFormatType> getDataFormats() {
        return dataFormats;
    }
    /***
     * @return A Map of the contained DataFormatType's indexed by id.
     */
    public Map<String, DataFormatType> asMap() {
        Map<String, DataFormatType> dataFormatsAsMap = new HashMap<String, DataFormatType>();
        for (DataFormatType dataFormatType : getDataFormats()) {
            dataFormatsAsMap.put(dataFormatType.getId(), dataFormatType);
        }
        return dataFormatsAsMap;
    }
}
"
org.apache.camel.model.dataformat.DataFormatType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.Exchange;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Represents the base XML type for DataFormat.
 *
 * @version $Revision: 695550 $
 */
@XmlType(name = ""dataFormatType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DataFormatType extends IdentifiedType implements DataFormat {
    @XmlTransient
    private DataFormat dataFormat;
    @XmlTransient
    private String dataFormatTypeName;
    public DataFormatType() {
    }
    public DataFormatType(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    protected DataFormatType(String dataFormatTypeName) {
        this.dataFormatTypeName = dataFormatTypeName;
    }
    public static DataFormat getDataFormat(RouteContext routeContext, DataFormatType type, String ref) {
        if (type == null) {
            notNull(ref, ""ref or dataFormatType"");
            DataFormat dataFormat = routeContext.lookup(ref, DataFormat.class);
            if (dataFormat == null) {
                dataFormat = routeContext.getDataFormat(ref);
            }
            if (dataFormat instanceof DataFormatType) {
                type = (DataFormatType)dataFormat;
            } else {
                return dataFormat;
            }
        }
        return type.getDataFormat(routeContext);
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
        ObjectHelper.notNull(dataFormat, ""dataFormat"");
        dataFormat.marshal(exchange, graph, stream);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        ObjectHelper.notNull(dataFormat, ""dataFormat"");
        return dataFormat.unmarshal(exchange, stream);
    }
    public DataFormat getDataFormat(RouteContext routeContext) {
        if (dataFormat == null) {
            dataFormat = createDataFormat(routeContext);
            ObjectHelper.notNull(dataFormat, ""dataFormat"");
            configureDataFormat(dataFormat);
        }
        return dataFormat;
    }
    /**
     * Factory method to create the data format instance
     */
    protected DataFormat createDataFormat(RouteContext routeContext) {
        if (dataFormatTypeName != null) {
            Class type = ObjectHelper.loadClass(dataFormatTypeName, getClass().getClassLoader());
            if (type == null) {
                throw new IllegalArgumentException(""The class "" + dataFormatTypeName + "" is not on the classpath! Cannot use the dataFormat "" + this);
            }
            return (DataFormat) ObjectHelper.newInstance(type);
        }
        return null;
    }
    /**
     * Allows derived classes to customize the data format
     */
    protected void configureDataFormat(DataFormat dataFormat) {
    }
    /**
     * Sets a named property on the data format instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
}
"
org.apache.camel.model.dataformat.FlatpackDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents a <a href=""http://activemq.apache.org/camel/flatpack.html"">Flatpack</a> {@link org.apache.camel.spi.DataFormat}.
 * 
 * @version $Revision: 711235 $
 */
@XmlRootElement(name = ""flatpack"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FlatpackDataFormat extends DataFormatType {
    public FlatpackDataFormat() {
        super(""org.apache.camel.component.flatpack.FlatpackDataFormat"");
    }
}
"
org.apache.camel.model.dataformat.HL7DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents a <a href=""http://activemq.apache.org/camel/hl7.html"">HL7</a> {@link org.apache.camel.spi.DataFormat}.
 *
 * @version $Revision: 711235 $
 */
@XmlRootElement(name = ""hl7"")
@XmlAccessorType(XmlAccessType.FIELD)
public class HL7DataFormat extends DataFormatType {
    public HL7DataFormat() {
        super(""org.apache.camel.dataformat.hl7.HL7DataFormat"");
    }
}
"
org.apache.camel.model.dataformat.JaxbDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents the JAXB2 XML {@link DataFormat}
 *
 * @version $Revision: 720208 $
 */
@XmlRootElement(name = ""jaxb"")
@XmlAccessorType(XmlAccessType.FIELD)
public class JaxbDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private String contextPath;
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    @XmlAttribute(required = false)
    private Boolean ignoreJAXBElement;
    public JaxbDataFormat() {
        super(""org.apache.camel.converter.jaxb.JaxbDataFormat"");
    }
    public JaxbDataFormat(boolean prettyPrint) {
        this();
        setPrettyPrint(prettyPrint);
    }
    public String getContextPath() {
        return contextPath;
    }
    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public Boolean getIgnoreJAXBElement() {
        return ignoreJAXBElement;
    }
    public void setIgnoreJAXBElement(Boolean ignoreJAXBElement) {
        this.ignoreJAXBElement = ignoreJAXBElement;
    }
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Boolean answer = ObjectHelper.toBoolean(getPrettyPrint());
        if (answer != null && !answer.booleanValue()) {
            setProperty(dataFormat, ""prettyPrint"", Boolean.FALSE);
        } else { // the default value is true
            setProperty(dataFormat, ""prettyPrint"", Boolean.TRUE);
        }
        answer = ObjectHelper.toBoolean(getIgnoreJAXBElement());
        if (answer != null && !answer.booleanValue()) {
            setProperty(dataFormat, ""ignoreJAXBElement"", Boolean.FALSE);
        } else { // the default value is true
            setProperty(dataFormat, ""ignoreJAXBElement"", Boolean.TRUE);
        } 
        setProperty(dataFormat, ""contextPath"", contextPath);
    }
}
"
org.apache.camel.model.dataformat.JsonDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
@XmlRootElement(name = ""json"")
@XmlAccessorType(XmlAccessType.FIELD)
public class JsonDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public JsonDataFormat() {
        super(""org.apache.camel.dataformat.xstream.JsonDataFormat"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.dataformat.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/data-format.html"">Data Formats</a> used to marshal and unmarshal objects to
 * and from streams inside <a href=""http://activemq.apache.org/camel/components.html"">components</a>
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.dataformat;
"
org.apache.camel.model.dataformat.SerializationDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Represents the Java Serialization {@link DataFormat}
 *
 * @version $Revision: 686463 $
 */
@XmlRootElement(name = ""serialization"")
public class SerializationDataFormat extends DataFormatType {
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.SerializationDataFormat();
    }
}
"
org.apache.camel.model.dataformat.StringDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Represents the String (text based) {@link DataFormat}
 *
 * @version $Revision: 659007 $
 */
@XmlRootElement(name = ""string"")
@XmlAccessorType(XmlAccessType.FIELD)
public class StringDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private String charset;
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.StringDataFormat(charset);
    }
    public String getCharset() {
        return charset;
    }
    public void setCharset(String charset) {
        this.charset = charset;
    }
}
"
org.apache.camel.model.dataformat.TidyMarkupDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.w3c.dom.Node;
import org.apache.camel.spi.DataFormat;
/**
 * Represents a wellformed HTML document (XML well Formed) {@link DataFormat}
 *
 */
@XmlRootElement(name = ""tidyMarkup"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TidyMarkupDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Class<?> dataObjectType;
    public TidyMarkupDataFormat() {
        super(""org.apache.camel.dataformat.tagsoup.TidyMarkupDataFormat"");
        this.setDataObjectType(Node.class);
    }
    public TidyMarkupDataFormat(Class<?> dataObjectType) {
        this();
        if (!dataObjectType.isAssignableFrom(String.class) && !dataObjectType.isAssignableFrom(Node.class)) {
            throw new IllegalArgumentException(""TidyMarkupDataFormat only supports returning a String or a org.w3c.dom.Node object"");
        }
        this.setDataObjectType(dataObjectType);
    }
    public void setDataObjectType(Class<?> dataObjectType) {
        this.dataObjectType = dataObjectType;
    }
    public Class<?> getDataObjectType() {
        return dataObjectType;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Class<?> type = getDataObjectType();
        if (type != null) {
            setProperty(dataFormat, ""dataObjectType"", type);
        }
    }
}
"
org.apache.camel.model.dataformat.XMLBeansDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the XMLBeans XML {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""xmlBeans"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XMLBeansDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public XMLBeansDataFormat() {
        super(""org.apache.camel.converter.xmlbeans.XmlBeansDataFormat"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.dataformat.XStreamDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the XStream XML {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""xstream"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XStreamDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public XStreamDataFormat() {
        super(""org.apache.camel.dataformat.xstream.XStreamDataFormat"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.dataformat.ZipDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import java.util.zip.Deflater;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
@XmlRootElement(name = ""zip"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ZipDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private int compressionLevel = Deflater.BEST_SPEED;
    public ZipDataFormat() {
    }
    public ZipDataFormat(int compressionLevel) {
        this.compressionLevel = compressionLevel;
    }
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.ZipDataFormat(compressionLevel);
    }
    public int getCompressionLevel() {
        return compressionLevel;
    }
    public void setCompressionLevel(int compressionLevel) {
        this.compressionLevel = compressionLevel;
    }
}
"
org.apache.camel.model.language.BeanShellExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For BeanShell expressions and predicates
 *
 * @deprecated use {@link org.apache.camel.model.language.LanguageExpression} will be removed in Camel 2.0
 * @version $Revision: 711235 $
 */
@XmlRootElement(name = ""beanshell"")
public class BeanShellExpression extends ExpressionType {
    public BeanShellExpression() {
    }
    public BeanShellExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""beanshell"";
    }
}
"
org.apache.camel.model.language.ConstantExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For expressions and predicates using a constant
 *
 */
@XmlRootElement(name = ""constant"")
public class ConstantExpression extends ExpressionType {
    public ConstantExpression() {
    }
    public ConstantExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""constant"";
    }
}
"
org.apache.camel.model.language.ELExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For EL expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""el"")
public class ELExpression extends ExpressionType {
    public ELExpression() {
    }
    public ELExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""el"";
    }
}
"
org.apache.camel.model.language.ExpressionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
/**
 * A useful base class for an expression
 *
 * @version $Revision: 705880 $
 */
@XmlRootElement
@XmlType(name = ""expressionType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionType implements Expression<Exchange>, Predicate<Exchange> {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    @XmlValue
    private String expression;
    @XmlTransient
    private Predicate predicate;
    @XmlTransient
    private Expression expressionValue;
    @XmlTransient
    private ExpressionType expressionType;
    public ExpressionType() {
    }
    public ExpressionType(String expression) {
        this.expression = expression;
    }
    public ExpressionType(Predicate predicate) {
        this.predicate = predicate;
    }
    public ExpressionType(Expression expression) {
        this.expressionValue = expression;
    }
    public static String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(expression.getLabel());
        }
        return buffer.toString();
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        if (getLanguage() != null) {
            sb.append(getLanguage() + ""{"");
        }
        if (getExpression() != null) {
            sb.append(getExpression());
        }
        if (getPredicate() != null) {
            sb.append(getPredicate().toString());
        }
        if (getExpressionValue() != null) {
            sb.append(getExpressionValue().toString());
        }
        if (getLanguage() != null) {
            sb.append(""}"");
        }
        return sb.toString();
    }
    public Object evaluate(Exchange exchange) {
        if (expressionValue == null) {
            RouteContext routeContext = new DefaultRouteContext(exchange.getContext());
            expressionValue = createExpression(routeContext);
        }
        ObjectHelper.notNull(expressionValue, ""expressionValue"");
        return expressionValue.evaluate(exchange);
    }
    public void assertMatches(String text, Exchange exchange) throws AssertionError {
        if (!matches(exchange)) {
            throw new AssertionError(text + getExpression() + "" for exchange: "" + exchange);
        }
    }
    public boolean matches(Exchange exchange) {
        if (predicate == null) {
            RouteContext routeContext = new DefaultRouteContext(exchange.getContext());
            predicate = createPredicate(routeContext);
        }
        ObjectHelper.notNull(predicate, ""predicate"");
        return predicate.matches(exchange);
    }
    public String getLanguage() {
        return """";
    }
    public Predicate<Exchange> createPredicate(RouteContext routeContext) {
        if (predicate == null) {
            if (expressionType != null) {
                predicate = expressionType.createPredicate(routeContext);
            } else {
                CamelContext camelContext = routeContext.getCamelContext();
                Language language = camelContext.resolveLanguage(getLanguage());
                predicate = language.createPredicate(getExpression());
                configurePredicate(routeContext, predicate);
            }
        }
        return predicate;
    }
    public Expression createExpression(RouteContext routeContext) {
        if (expressionValue == null) {
            if (expressionType != null) {
                expressionValue = expressionType.createExpression(routeContext);
            } else {
                CamelContext camelContext = routeContext.getCamelContext();
                Language language = camelContext.resolveLanguage(getLanguage());
                expressionValue = language.createExpression(getExpression());
                configureExpression(routeContext, expressionValue);
            }
        }
        return expressionValue;
    }
    public String getExpression() {
        return expression;
    }
    public void setExpression(String expression) {
        this.expression = expression;
    }
    /**
     * Gets the value of the id property.
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     */
    public void setId(String value) {
        this.id = value;
    }
    public Predicate getPredicate() {
        return predicate;
    }
    public Expression getExpressionValue() {
        return expressionValue;
    }
    protected void setExpressionValue(Expression expressionValue) {
        this.expressionValue = expressionValue;
    }
    /**
     * Returns some descriptive text to describe this node
     */
    public String getLabel() {
        String language = getExpression();
        if (ObjectHelper.isNullOrBlank(language)) {
            Predicate predicate = getPredicate();
            if (predicate != null) {
                return predicate.toString();
            }
            Expression expressionValue = getExpressionValue();
            if (expressionValue != null) {
                return expressionValue.toString();
            }
        } else {
            return language;
        }
        return """";
    }
    /**
     * Allows derived classes to set a lazily created expressionType instance
     * such as if using the {@link ExpressionClause}
     */
    protected void setExpressionType(ExpressionType expressionType) {
        this.expressionType = expressionType;
    }
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
    }
    protected void configureExpression(RouteContext routeContext, Expression expression) {
    }
    /**
     * Sets a named property on the object instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
}
"
org.apache.camel.model.language.GroovyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Groovy expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""groovy"")
public class GroovyExpression extends ExpressionType {
    public GroovyExpression() {
    }
    public GroovyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""groovy"";
    }
}
"
org.apache.camel.model.language.HeaderExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * An expression which extracts the named header
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""header"")
public class HeaderExpression extends ExpressionType {
    public HeaderExpression() {
    }
    public HeaderExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""header"";
    }
}
"
org.apache.camel.model.language.JavaScriptExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For JavaScript expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""javaScript"")
public class JavaScriptExpression extends ExpressionType {
    public JavaScriptExpression() {
    }
    public JavaScriptExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""js"";
    }
}
"
org.apache.camel.model.language.JXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For <a href=""http://commons.apache.org/jxpath/"">JXPath</a> expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""jxpath"")
public class JXPathExpression extends ExpressionType {
    public JXPathExpression() {
    }
    public JXPathExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""jxpath"";
    }
}
"
org.apache.camel.model.language.LanguageExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * Represents a parameterised language expression which can support any language
 * at runtime using the language attribute.
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""expression"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LanguageExpression extends ExpressionType {
    @XmlAttribute
    private String language;
    public LanguageExpression() {
    }
    public LanguageExpression(String language, String expression) {
        setLanguage(language);
        setExpression(expression);
    }
    public String getLanguage() {
        return language;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
}
"
org.apache.camel.model.language.MethodCallExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.language.bean.BeanExpression;
import org.apache.camel.spi.RouteContext;
/**
 * For expressions and predicates using the
 * <a href=""http://activemq.apache.org/camel/bean-language.html"">bean language</a>
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""methodCall"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MethodCallExpression extends ExpressionType {
    @XmlAttribute(required = false)
    private String bean;
    @XmlAttribute(required = false)
    private String method;
    public MethodCallExpression() {
    }
    public MethodCallExpression(String beanName) {
        super(beanName);
    }
    public MethodCallExpression(String beanName, String method) {
        super(beanName);
        this.method = method;
    }
    public String getLanguage() {
        return ""bean"";
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    @Override
    public Expression createExpression(RouteContext routeContext) {
        return new BeanExpression(beanName(), getMethod());
    }
    @Override
    public Predicate<Exchange> createPredicate(RouteContext routeContext) {
        return new BeanExpression<Exchange>(beanName(), getMethod());
    }
    protected String beanName() {
        if (bean != null) {
            return bean;
        }
        return getExpression();
    }
}
"
org.apache.camel.model.language.NamespaceAwareExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.spi.RouteContext;
/**
 * A useful base class for any expression which may be namespace or XML content aware
 * such as {@link XPathExpression} or {@link XQueryExpression}
 *
 * @version $Revision: 659007 $
 */
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class NamespaceAwareExpression extends ExpressionType implements NamespaceAware {
    @XmlTransient
    private Map<String, String> namespaces;
    public NamespaceAwareExpression() {
    }
    public NamespaceAwareExpression(String expression) {
        super(expression);
    }
    public Map<String, String> getNamespaces() {
        return namespaces;
    }
    /**
     * Injects the XML Namespaces of prefix -> uri mappings
     *
     * @param namespaces the XML namespaces with the key of prefixes and the value the URIs
     */
    public void setNamespaces(Map<String, String> namespaces) {
        this.namespaces = namespaces;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        configureNamespaceAware(expression);
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        configureNamespaceAware(predicate);
    }
    protected void configureNamespaceAware(Object builder) {
        if (namespaces != null && builder instanceof NamespaceAware) {
            NamespaceAware namespaceAware = (NamespaceAware) builder;
            namespaceAware.setNamespaces(namespaces);
        }
    }
}
"
org.apache.camel.model.language.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For OGNL expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""ognl"")
public class OgnlExpression extends ExpressionType {
    public OgnlExpression() {
    }
    public OgnlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ognl"";
    }
}
"
org.apache.camel.model.language.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/expression.html"">Expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">Predicate</a> plugins for the
 * <a href=""http://activemq.apache.org/camel/xml-configuration.html"">XML Configuration</a>.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.language;
"
org.apache.camel.model.language.PhpExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For PHP expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""php"")
public class PhpExpression extends ExpressionType {
    public PhpExpression() {
    }
    public PhpExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""php"";
    }
}
"
org.apache.camel.model.language.PythonExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Python expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""python"")
public class PythonExpression extends ExpressionType {
    public PythonExpression() {
    }
    public PythonExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""python"";
    }
}
"
org.apache.camel.model.language.RubyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Ruby expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""ruby"")
public class RubyExpression extends ExpressionType {
    public RubyExpression() {
    }
    public RubyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ruby"";
    }
}
"
org.apache.camel.model.language.SimpleExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For expressions and predicates using the
 * <a href=""http://activemq.apache.org/camel/simple.html>simple language</a>
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""simple"")
public class SimpleExpression extends ExpressionType {
    public SimpleExpression() {
    }
    public SimpleExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""simple"";
    }
}
"
org.apache.camel.model.language.SqlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For SQL expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""sql"")
public class SqlExpression extends ExpressionType {
    public SqlExpression() {
    }
    public SqlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""sql"";
    }
}
"
org.apache.camel.model.language.XPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.RouteContext;
/**
 * For XPath expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""xpath"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XPathExpression extends NamespaceAwareExpression {
    @XmlAttribute(required = false)
    private Class resultType;
    public XPathExpression() {
    }
    public XPathExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xpath"";
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        super.configureExpression(routeContext, expression);
        if (resultType != null) {
            setProperty(expression, ""resultType"", resultType);
        }
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        super.configurePredicate(routeContext, predicate);
        if (resultType != null) {
            setProperty(predicate, ""resultType"", resultType);
        }
    }
}
"
org.apache.camel.model.language.XQueryExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For XQuery expressions and predicates
 *
 * @version $Revision: 679483 $
 */
@XmlRootElement(name = ""xquery"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XQueryExpression extends NamespaceAwareExpression {
    private static final transient Log LOG = LogFactory.getLog(XQueryExpression.class);
    @XmlAttribute(required = false)
    private String type;
    @XmlTransient
    private Class resultType;
    public XQueryExpression() {
    }
    public XQueryExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xquery"";
    }
    public String getType() {
        return type;
    }
    public void setType(String type) {
        this.type = type;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        super.configureExpression(routeContext, expression);
        updateResultType();
        if (resultType != null) {
            setProperty(expression, ""resultType"", resultType);
        }
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        super.configurePredicate(routeContext, predicate);
        updateResultType();
        if (resultType != null) {
            setProperty(predicate, ""resultType"", resultType);
        }
    }
    private void updateResultType() {
        if (resultType == null && type != null) {
            try {
                resultType = Class.forName(type);
            } catch (ClassNotFoundException e) {
                LOG.error(""ClassNotFoundException creating class: "" + type);
            }
        }
    }
}
"
org.apache.camel.model.loadbalancer.LoadBalancerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Represents an XML &lt;loadBalance/&gt; element
 */
@XmlType(name = ""loadBalancerType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LoadBalancerType extends IdentifiedType implements LoadBalancer {
    @XmlTransient
    private LoadBalancer loadBalancer;
    @XmlTransient
    private String loadBalancerTypeName;
    public LoadBalancerType() {
    }
    public LoadBalancerType(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    protected LoadBalancerType(String loadBalancerTypeName) {
        this.loadBalancerTypeName = loadBalancerTypeName;
    }
    public static LoadBalancer getLoadBalancer(RouteContext routeContext, LoadBalancerType type, String ref) {
        if (type == null) {
            notNull(ref, ""ref or LoadBalancerType"");
            LoadBalancer loadBalancer = routeContext.lookup(ref, LoadBalancer.class);
            if (loadBalancer instanceof LoadBalancerType) {
                type = (LoadBalancerType) loadBalancer;
            } else {
                return loadBalancer;
            }
        }
        return type.getLoadBalancer(routeContext);
    }
    /**
     * Sets a named property on the data format instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
    /**
     * Allows derived classes to customize the load balancer
     */
    protected void configureLoadBalancer(LoadBalancer loadBalancer) {
    }
    public LoadBalancer getLoadBalancer(RouteContext routeContext) {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer(routeContext);
            ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
            configureLoadBalancer(loadBalancer);
        }
        return loadBalancer;
    }
    /**
     * Factory method to create the load balancer instance
     */
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        if (loadBalancerTypeName != null) {
            Class type = ObjectHelper.loadClass(loadBalancerTypeName, getClass().getClassLoader());
            if (type == null) {
                throw new IllegalArgumentException(""The class "" + loadBalancerTypeName + "" is not on the classpath! Cannot use the loadBalancer "" + this);
            }
            return (LoadBalancer) ObjectHelper.newInstance(type);
        }
        return null;
    }
    public void addProcessor(Processor processor) {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.addProcessor(processor);
    }
    public List<Processor> getProcessors() {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        return loadBalancer.getProcessors();
    }
    public void removeProcessor(Processor processor) {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.removeProcessor(processor);
    }
    public void process(Exchange exchange) throws Exception {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.process(exchange);
    }
    public boolean process(Exchange exchange, final AsyncCallback callback) {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        return loadBalancer.process(exchange, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                // Only handle the async case...
                if (doneSynchronously) {
                    return;
                } else {
                    callback.done(doneSynchronously);
                }
            }
        });                
    }
}
"
org.apache.camel.model.loadbalancer.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The LoadBalancer and the LoadBalancerStrategy JAXB Objects
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.loadbalancer;
"
org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;random/&gt; element
 */
@XmlRootElement(name = ""random"")
public class RandomLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.RandomLoadBalancer();
    }
}
"
org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;roundRobin/&gt; element
 */
@XmlRootElement(name = ""roundRobin"")
public class RoundRobinLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer();
    }
}
"
org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
/**
 * Represents an XML &lt;sticky/&gt; element
 */
@XmlRootElement(name = ""sticky"")
@XmlAccessorType(XmlAccessType.FIELD)
public class StickyLoadBalanceStrategy extends LoadBalancerType {
    @XmlElement(required = true, name = ""expression"", type = ExpressionType.class)
    private ExpressionType expressionType;
    @XmlElement(required = false, name = ""loadBalancer"", type = LoadBalancerType.class)
    private LoadBalancerType loadBalancerType;
    public StickyLoadBalanceStrategy() {
        super(""org.apache.camel.processor.loadbalancer.StickyLoadBalancer"");
    }
    public StickyLoadBalanceStrategy(ExpressionType expressionType) {
        this();
        this.expressionType = expressionType;
    }
    public StickyLoadBalanceStrategy(ExpressionType expressionType, LoadBalancerType loadBalancerType) {
        this();
        this.expressionType = expressionType;
        this.loadBalancerType = loadBalancerType;
    }
    public void setExpressionType(ExpressionType expressionType) {
        this.expressionType = expressionType;
    }
    public ExpressionType getExpressionType() {
        return expressionType;
    }
    public void setLoadBalancerType(LoadBalancerType loadBalancerType) {
        this.loadBalancerType = loadBalancerType;
    }
    public LoadBalancerType getLoadBalancerType() {
        return loadBalancerType;
    }
    @Override
    protected void configureLoadBalancer(LoadBalancer loadBalancer) {
        ExpressionType expression = getExpressionType();
        if (expression != null) {
            setProperty(loadBalancer, ""correlationExpression"", expression);
        }
        LoadBalancerType type = getLoadBalancerType();
        if (type != null) {
            setProperty(loadBalancer, ""loadBalancer"", type);
        }
    }
    @Override
    public String toString() {
        return ""StickyLoadBalanceStrategy["" + expressionType + "", "" + loadBalancerType + ""]"";
    }
}
"
org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;topic/&gt; element
 * 
 */
@XmlRootElement(name = ""topic"")
public class TopicLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.TopicLoadBalancer();
    }
}
"
org.apache.camel.processor.Aggregator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.DefaultAggregationCollection;
import org.apache.camel.processor.aggregate.PredicateAggregationCollection;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
 * pattern where a batch of messages are processed (up to a maximum amount or
 * until some timeout is reached) and messages for the same correlation key are
 * combined together using some kind of {@link AggregationStrategy}
 * (by default the latest message is used) to compress many message exchanges
 * into a smaller number of exchanges.
 * <p/>
 * A good example of this is stock market data; you may be receiving 30,000
 * messages/second and you may want to throttle it right down so that multiple
 * messages for the same stock are combined (or just the latest message is used
 * and older prices are discarded). Another idea is to combine line item messages
 * together into a single invoice message.
 *
 * @version $Revision: 726941 $
 */
public class Aggregator extends BatchProcessor {
    private Predicate aggregationCompletedPredicate;
    public Aggregator(Processor processor, Expression correlationExpression,
                      AggregationStrategy aggregationStrategy) {
        this(processor, new DefaultAggregationCollection(correlationExpression, aggregationStrategy));
    }
    public Aggregator(Processor processor, Expression correlationExpression,
                      AggregationStrategy aggregationStrategy, Predicate aggregationCompletedPredicate) {
        this(processor, new PredicateAggregationCollection(correlationExpression, aggregationStrategy, aggregationCompletedPredicate));
        this.aggregationCompletedPredicate = aggregationCompletedPredicate;
    }
    public Aggregator(Processor processor, AggregationCollection collection) {
        super(processor, collection);
    }
    @Override
    public String toString() {
        return ""Aggregator[to: "" + getProcessor() + ""]"";
    }
}
"
org.apache.camel.processor.AggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 726941 $
 */
public class AggregatorTest extends ContextTestSupport {
    protected int messageCount = 100;
    public void testSendingLotsOfMessagesGetAggregatedToTheLatestMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(""message:"" + messageCount);
        // lets send a large batch of messages
        for (int i = 1; i <= messageCount; i++) {
            String body = ""message:"" + i;
            template.sendBodyAndHeader(""direct:start"", body, ""cheese"", 123);
        }
        resultEndpoint.assertIsSatisfied();
    }
    public void testPredicate() throws Exception {
        testSendALargeBatch(""direct:predicate"");
    }
    public void testOutBatchPredicate() throws Exception {
        testSendALargeBatch(""direct:outBatchPredicate"");
    }
    public void testOutBatchWithNoInBatching() throws Exception {
        testSendALargeBatch(""direct:outBatchNoInBatching"");
    }
    public void testOneMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:predicate"", ""test"", ""aggregated"", 5);
        resultEndpoint.assertIsSatisfied();
    }
    public void testBatchTimeoutExpiry() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.setSleepForEmptyTest(2 * BatchProcessor.DEFAULT_BATCH_TIMEOUT);
        template.sendBodyAndHeader(""direct:start"", ""message:1"", ""cheese"", 123);
        resultEndpoint.assertIsSatisfied();
    }
    public void testAggregatorNotAtStart() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.message(0).header(""visited"").isNotNull();
        resultEndpoint.setSleepForEmptyTest(2 * BatchProcessor.DEFAULT_BATCH_TIMEOUT);
        template.sendBodyAndHeader(""seda:header"", ""message:1"", ""cheese"", 123);
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                // in this route we aggregate all from direct:state based on the header id cheese
                from(""direct:start"").aggregator(header(""cheese"")).to(""mock:result"");
                from(""seda:header"").setHeader(""visited"", constant(true)).aggregator(header(""cheese"")).to(""mock:result"");
                // in this sample we aggreagte using our own startegy with a completion predicate
                // stating that the aggregated header is equal to 5.
                from(""direct:predicate"").aggregator(header(""cheese""), new MyAggregationStrategy()).
                    completedPredicate(header(""aggregated"").isEqualTo(5)).to(""mock:result"");
                // this sample is similar to the one above but it also illustrates the use of outBatchSize 
                // to send exchanges to mock:endpoint in batches of 10.  
                from(""direct:outBatchPredicate"").aggregator(header(""cheese""), new MyAggregationStrategy()).
                    completedPredicate(header(""aggregated"").isEqualTo(5)).outBatchSize(10).to(""mock:result"");
                // END SNIPPET: ex
                // turning off in batching (batchSize = 1) is a good way to test ""out"" batching.  Don't include
                // in wiki snippet as it may not be a good example to follow.
                from(""direct:outBatchNoInBatching"").aggregator(header(""cheese""), new MyAggregationStrategy()).
                completedPredicate(header(""aggregated"").isEqualTo(5)).batchSize(1).outBatchSize(10).to(""mock:result"");
            }
        };
    }
    private void testSendALargeBatch(String endpointUri) throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(messageCount / 5);
        // lets send a large batch of messages
        for (int i = 1; i <= messageCount; i++) {
            String body = ""message:"" + i;
            template.sendBodyAndHeader(endpointUri, body, ""cheese"", 123);
        }
        resultEndpoint.assertIsSatisfied();
    }
}
"
org.apache.camel.processor.AppendingProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
public class AppendingProcessor implements Processor {
    private String suffixString;
    public AppendingProcessor() {
        this(""+output"");
    }
    public AppendingProcessor(String suffix) {
        suffixString = suffix;
    }
    public void setSuffixString(String suffix) {
        suffixString = suffix;
    }
    public void process(Exchange exchange) {
        // lets transform the IN message
        Message in = exchange.getIn();
        String body = in.getBody(String.class);
        in.setBody(body + suffixString);
    }
}
"
org.apache.camel.processor.BatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.LoggingExceptionHandler;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
/**
 * A base class for any kind of {@link Processor} which implements some kind of
 * batch processing.
 * 
 * @version $Revision: 726941 $
 */
public class BatchProcessor extends ServiceSupport implements Processor {
    public static final long DEFAULT_BATCH_TIMEOUT = 1000L;
    public static final int DEFAULT_BATCH_SIZE = 100;
    private long batchTimeout = DEFAULT_BATCH_TIMEOUT;
    private int batchSize = DEFAULT_BATCH_SIZE;
    private int outBatchSize;
    private Processor processor;
    private Collection<Exchange> collection;
    private ExceptionHandler exceptionHandler;
    private BatchSender sender;
    public BatchProcessor(Processor processor, Collection<Exchange> collection) {
        this.processor = processor;
        this.collection = collection;
        this.sender = new BatchSender();
    }
    @Override
    public String toString() {
        return ""BatchProcessor[to: "" + processor + ""]"";
    }
    // Properties
    // -------------------------------------------------------------------------
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    public int getBatchSize() {
        return batchSize;
    }
    /**
     * Sets the <b>in</b> batch size. This is the number of incoming exchanges that this batch processor
     * will process before its completed. The default value is {@link #DEFAULT_BATCH_SIZE}.
     *
     * @param batchSize the size
     */
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public int getOutBatchSize() {
        return outBatchSize;
    }
    /**
     * Sets the <b>out</b> batch size. If the batch processor holds more exchanges than this out size then
     * the completion is triggered. Can for instance be used to ensure that this batch is completed when
     * a certain number of exchanges has been collected. By default this feature is <b>not</b> enabled.
     *
     * @param outBatchSize the size
     */
    public void setOutBatchSize(int outBatchSize) {
        this.outBatchSize = outBatchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * A strategy method to decide if the ""in"" batch is completed.  That is, whether the resulting 
     * exchanges in the in queue should be drained to the ""out"" collection.
     */
    protected boolean isInBatchCompleted(int num) {
        return num >= batchSize;
    }
    /**
     * A strategy method to decide if the ""out"" batch is completed. That is, whether the resulting 
     * exchange in the out collection should be sent.
     */
    protected boolean isOutBatchCompleted() {
        if (outBatchSize == 0) {
            // out batch is disabled, so go ahead and send.
            return true;
        }
        return collection.size() > 0 && collection.size() >= outBatchSize;
    }
    /**
     * Strategy Method to process an exchange in the batch. This method allows
     * derived classes to perform custom processing before or after an
     * individual exchange is processed
     */
    protected void processExchange(Exchange exchange) throws Exception {
        processor.process(exchange);
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
        sender.start();
    }
    protected void doStop() throws Exception {
        sender.cancel();
        ServiceHelper.stopServices(processor);
        collection.clear();
    }
    protected Collection<Exchange> getCollection() {
        return collection;
    }
    /**
     * Enqueues an exchange for later batch processing.
     */
    public void process(Exchange exchange) throws Exception {
        sender.enqueueExchange(exchange);
    }
    /**
     * Sender thread for queued-up exchanges.
     */
    private class BatchSender extends Thread {
        private volatile boolean cancelRequested;
        private LinkedBlockingQueue<Exchange> queue;
        public BatchSender() {
            super(""Batch Sender"");
            this.queue = new LinkedBlockingQueue<Exchange>();
        }
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(batchTimeout);
                    queue.drainTo(collection, batchSize);  
                } catch (InterruptedException e) {
                    if (cancelRequested) {
                        return;
                    }
                    while (isInBatchCompleted(queue.size())) {
                        queue.drainTo(collection, batchSize);  
                    }
                    if (!isOutBatchCompleted()) {
                        continue;
                    }
                }
                try {
                    sendExchanges();
                } catch (Exception e) {
                    getExceptionHandler().handleException(e);
                }
            }
        }
        public void cancel() {
            cancelRequested = true;
            interrupt();
        }
        public void enqueueExchange(Exchange exchange) {
            queue.add(exchange);
            interrupt();
        }
        private void sendExchanges() throws Exception {
            Iterator<Exchange> iter = collection.iterator();
            while (iter.hasNext()) {
                Exchange exchange = iter.next();
                iter.remove();
                processExchange(exchange);
            }
        }
    }
}
"
org.apache.camel.processor.BeanInvocationThrowsExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test for bean invocation that throws an exception
 */
public class BeanInvocationThrowsExceptionTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testBeanInvocation() {
        int result = (Integer) template.sendBody(""direct:input"", ExchangePattern.InOut, ""Hello London"");
        assertEquals(1, result);
    }
    public void testBeanInvocationFailure() {
        // must create an exchange to get the result as an exchange where we can get the caused exception
        Exchange exchange = getMandatoryEndpoint(""direct:input"").createExchange(ExchangePattern.InOut);
        exchange.getIn().setBody(""Hello Paris"");
        Exchange result = template.send(""direct:input"", exchange);
        assertTrue(""Should be failed"", result.isFailed());
        assertTrue(""Should be IllegalArgumentException"", result.getException() instanceof IllegalArgumentException);
        assertEquals(""Forced exception"", result.getException().getMessage());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:input"").bean(new ExceptionBean());
            }
        };
    }
    public static class ExceptionBean {
        public int doSomething(String request) throws Exception {
            if (request.equals(""Hello London"")) {
                return 1;
            } else {
                throw new IllegalArgumentException(""Forced exception"");
            }
        }
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.BeanMethodHeartbeatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * This test shows we can poll a bean for a method and send the POJO over some transport
 *
 * @version $Revision: 630568 $
 */
public class BeanMethodHeartbeatTest extends ContextTestSupport {
    protected MyService bean = new MyService(""Beer"");
    public void testHeartbeatsArrive() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMinimumMessageCount(1);
        resultEndpoint.assertIsSatisfied();
        List<Exchange> list = new ArrayList<Exchange>(resultEndpoint.getReceivedExchanges());
        log.debug(""Received: "" + list);
        Exchange exchange = list.get(0);
        log.debug(""In: "" + exchange.getIn());
        log.debug(""Out: "" + exchange.getOut());
        Map map = assertIsInstanceOf(Map.class, exchange.getIn().getBody());
        log.debug(""Received: "" + map);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""myService"", bean);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""bean:myService?method=status"").to(""mock:result"");
            }
        };
    }
    public static class MyService {
        private String name;
        public MyService(String name) {
            this.name = name;
        }
        public Map status() {
            Map answer = new HashMap();
            answer.put(""name"", name);
            answer.put(""time"", new Date());
            return answer;
        }
    }
}
"
org.apache.camel.processor.BeanRecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.atomic.AtomicInteger;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 711235 $
 */
public class BeanRecipientListTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRecipientListTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        final String expectedBody = ""Wibble"";
        getMockEndpoint(""mock:a"").expectedBodiesReceived(expectedBody);
        getMockEndpoint(""mock:b"").expectedBodiesReceived(expectedBody);
        template.sendBody(""direct:in"", expectedBody);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"", ""route"");
            }
        };
    }
    public static class MyBean {
        private static AtomicInteger counter = new AtomicInteger(0);
        private int id;
        public MyBean() {
            id = counter.incrementAndGet();
        }
        @Override
        public String toString() {
            return ""MyBean:"" + id;
        }
        @org.apache.camel.RecipientList
        public String[] route(String body) {
            LOG.debug(""Called "" + this + "" with body: "" + body);
            return new String[] {""mock:a"", ""mock:b""};
        }
    }
}
"
org.apache.camel.processor.BeanRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.atomic.AtomicInteger;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanRouteTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendingMessageWithMethodNameHeader() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, BeanProcessor.METHOD_NAME, ""read"");
        assertEquals(""bean received correct value for: "" + myBean, expectedBody, myBean.body);
    }
    public void testSendingMessageWithMethodNameHeaderWithMoreVerboseCoe() throws Exception {
        final String expectedBody = ""Wibble"";
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(expectedBody);
                in.setHeader(BeanProcessor.METHOD_NAME, ""read"");
            }
        });
        assertEquals(""bean received correct value"", expectedBody, myBean.body);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        private static AtomicInteger counter = new AtomicInteger(0);
        public String body;
        private int id;
        public MyBean() {
            id = counter.incrementAndGet();
        }
        @Override
        public String toString() {
            return ""MyBean:"" + id;
        }
        public void read(String body) {
            this.body = body;
            LOG.info(""read() method on "" + this + "" with body: "" + body);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.processor.BeanWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Header;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 694753 $
 */
public class BeanWithExceptionTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisfied();
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        try {
            template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new ValidationBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").beanRef(""myBean"").to(""mock:valid"");
            }
        };
    }
    public static class ValidationBean {
        private static final transient Log LOG = LogFactory.getLog(ValidationBean.class);
        public void someMethod(String body, @Header(name = ""foo"")
                               String header) throws ValidationException {
            if (""bar"".equals(header)) {
                LOG.info(""someMethod() called with valid header and body: "" + body);
            } else {
                throw new ValidationException(null, ""Invalid header foo: "" + header);
            }
        }
    }
}
"
org.apache.camel.processor.BeanWithXPathInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.XPath;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithXPathInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""<env:Envelope xmlns:env='http://www.w3.org/2003/05/soap-envelope'><env:Body>""
                              + ""<foo>bar</foo></env:Body></env:Envelope>"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
        assertEquals(""bean foo: "" + myBean, ""bar"", myBean.foo);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public String foo;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" body: "" + body + ""]"";
        }
        public void read(String body, @XPath(""/soap:Envelope/soap:Body/foo/text()"") String foo) {
            this.foo = foo;
            this.body = body;
            LOG.info(""read() method called on "" + this);
        }
    }
}
"
org.apache.camel.processor.BodyInAggregatingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Header;
import org.apache.camel.Message;
import org.apache.camel.processor.aggregate.AggregationStrategy;
public class BodyInAggregatingStrategy implements AggregationStrategy {
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Exchange copy = newExchange.copy();
        Message newIn = copy.getIn();
        String oldBody = oldExchange.getIn().getBody(String.class);
        String newBody = newIn.getBody(String.class);
        newIn.setBody(oldBody + ""+"" + newBody);
        return copy;
    }
    /**
     * An expression used to determine if the aggregation is complete
     */
    public boolean isCompleted(@Header(name = Exchange.AGGREGATED_COUNT)
                               Integer aggregated) {
        if (aggregated == null) {
            return false;
        }
        return aggregated == 3;
    }
}
"
org.apache.camel.processor.BodyOutAggregatingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.processor.aggregate.AggregationStrategy;
public class BodyOutAggregatingStrategy implements AggregationStrategy {
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Message newOut = newExchange.getOut();
        String oldBody = oldExchange.getOut().getBody(String.class);
        String newBody = newOut.getBody(String.class);
        newOut.setBody(oldBody + ""+"" + newBody);
        return newExchange;
    }
}
"
org.apache.camel.processor.Camel715ThreadProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import junit.framework.TestCase;
import org.apache.camel.AsyncCallback;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
public class Camel715ThreadProcessorTest extends TestCase {
    private static final int ITERS = 50000;
    class SendingProcessor implements Processor {
        int iterationNumber;
        public SendingProcessor(int iter) {
            iterationNumber = iter;
        }
        public void process(Exchange exchange) throws Exception {
            Message in = exchange.getIn();
            in.setBody(""a"");
            // may set the property here
            exchange.setProperty(""iterationNumber"", iterationNumber);
        }
    }
    public void testThreadProcessor() {
        try {
            CamelContext context = new DefaultCamelContext();
            final CountDownLatch latch = new CountDownLatch(ITERS);
            context.addRoutes(new RouteBuilder() {
                @Override
                public void configure() throws Exception {
                    from(""direct:a"").thread(4).process(new Processor() {
                        public void process(Exchange ex) throws Exception {
                            latch.countDown();
                        }
                    });
                }
            });
            final ProducerTemplate<Exchange> template = context.createProducerTemplate();
            final Endpoint e = context.getEndpoint(""direct:a"");
            context.start();
            for (int i = 0; i < ITERS; i++) {
                template.send(e, new SendingProcessor(i), new AsyncCallback() {
                    public void done(boolean arg0) {
                        // Do nothing here
                    }
                });
            }
            latch.await();
            context.stop();
        } catch (Exception ex) {
            fail(""Get the exception "" + ex + ""here"");
            // Make sure we the threads will exit, or the test will hung
            System.exit(-1);
        }
    }
}
"
org.apache.camel.processor.CatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Processor;
/**
 * A processor which catches exceptions.
 *
 * @version $Revision: 659760 $
 */
public class CatchProcessor extends DelegateProcessor {
    private List<Class> exceptions;
    public CatchProcessor(List<Class> exceptions, Processor processor) {
        super(processor);
        this.exceptions = exceptions;
    }
    @Override
    public String toString() {
        return ""Catch["" + exceptions + "" -> "" + getProcessor() + ""]"";
    }
    public boolean catches(Throwable e) {
        for (Class type : exceptions) {
            if (type.isInstance(e)) {
                return true;
            }
        }
        return false;
    }
    public List<Class> getExceptions() {
        return exceptions;
    }
}
"
org.apache.camel.processor.ChoiceProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Implements a Choice structure where one or more predicates are used which if
 * they are true their processors are used, with a default otherwise clause used
 * if none match.
 * 
 * @version $Revision: 674278 $
 */
public class ChoiceProcessor extends ServiceSupport implements Processor {
    private List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
    private Processor otherwise;
    public ChoiceProcessor(List<FilterProcessor> filters, Processor otherwise) {
        this.filters = filters;
        this.otherwise = otherwise;
    }
    public void process(Exchange exchange) throws Exception {
        for (FilterProcessor filterProcessor : filters) {
            Predicate<Exchange> predicate = filterProcessor.getPredicate();
            if (predicate != null && predicate.matches(exchange)) {
                // process next will also take care (has not null test) if next was a stop().
                // stop() has no processor to execute, and thus we will end in a NPE 
                filterProcessor.processNext(exchange);
                return;
            }
        }
        if (otherwise != null) {
            otherwise.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (FilterProcessor processor : filters) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor.getPredicate().toString());
            builder.append("": "");
            builder.append(processor.getProcessor());
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }
    public List<FilterProcessor> getFilters() {
        return filters;
    }
    public Processor getOtherwise() {
        return otherwise;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(filters);
        ServiceHelper.startServices(otherwise);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(otherwise);
        ServiceHelper.stopServices(filters);
    }
}
"
org.apache.camel.processor.ChoiceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 693948 $
 */
public class ChoiceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendToFirstWhen() throws Exception {
        String body = ""<one/>"";
        x.expectedBodiesReceived(body);
        // The SpringChoiceTest.java can't setup the header by Spring configure file
        // x.expectedHeaderReceived(""name"", ""a"");
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisfied();
    }
    public void testSendToSecondWhen() throws Exception {
        String body = ""<two/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""cheese"", body);
        assertMockEndpointsSatisfied();
    }
    public void testSendToOtherwiseClause() throws Exception {
        String body = ""<three/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""somethingUndefined"", body);
        assertMockEndpointsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                  .when().xpath(""$foo = 'bar'"").to(""mock:x"")
                  .when().xpath(""$foo = 'cheese'"").to(""mock:y"")
                  .otherwise().to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.CompositeProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Represents a composite pattern, aggregating a collection of processors
 * together as a single processor
 * 
 * @version $Revision: 630591 $
 */
public class CompositeProcessor extends ServiceSupport implements Processor {
    private final Collection<Processor> processors;
    public CompositeProcessor(Collection<Processor> processors) {
        this.processors = processors;
    }
    public void process(Exchange exchange) throws Exception {
        for (Processor processor : processors) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""[ "");
        boolean first = true;
        for (Processor processor : processors) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(processor.toString());
        }
        builder.append("" ]"");
        return builder.toString();
    }
    public Collection<Processor> getProcessors() {
        return processors;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);
    }
}
"
org.apache.camel.processor.ConvertBodyProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A processor which converts the payload of the input message to be of the given type
 *
 * @version $Revision: 700474 $
 */
public class ConvertBodyProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(ConvertBodyProcessor.class);
    private final Class type;
    public ConvertBodyProcessor(Class type) {
        this.type = type;
    }
    public void process(Exchange exchange) throws Exception {
        Message in = exchange.getIn();        
        Object value = null;
        try {
            value = in.getBody(type);
        } catch (NoTypeConversionAvailableException e) {
            LOG.warn(""Could not convert body of IN message: "" + in + "" to type: "" + type.getName());
        }
        if (exchange.getPattern().isOutCapable()) {
            Message out = exchange.getOut();
            out.copyFrom(in);
            out.setBody(value);
        } else {
            in.setBody(value);
        }
    }
}
"
org.apache.camel.processor.ConvertBodyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class ConvertBodyTest extends ContextTestSupport {
    public void testConvertToInteger() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"",
                MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(11);
        template.sendBody(""direct:start"", ""11"");
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").convertBodyTo(Integer.class).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.CreateRouteWithNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class CreateRouteWithNonExistingEndpointTest extends ContextTestSupport {
    public void testCreateRouteWithBadEndpoint() throws Exception {
    }
    @Override
    protected void setUp() throws Exception {
        try {
            super.setUp();
            fail(""Should have failed to create this route!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""thisUriDoesNotExist"");
            }
        };
    }
}
"
org.apache.camel.processor.DataFormatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.util.ObjectHelper.equal;
/**
 * @version $Revision: 659842 $
 */
public class DataFormatTest extends ContextTestSupport {
    public void testMarshalThenUnmarshalBean() throws Exception {
        MyBean bean = new MyBean();
        bean.name = ""James"";
        bean.counter = 5;
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(bean);
        template.sendBody(""direct:start"", bean);
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").marshal().serialization().to(""direct:marshalled"");
                from(""direct:marshalled"").unmarshal().serialization().to(""mock:result"");
            }
        };
    }
    protected static class MyBean implements Serializable {
        public String name;
        public int counter;
        @Override
        public boolean equals(Object o) {
            if (o instanceof MyBean) {
                MyBean that = (MyBean) o;
                return equal(this.name, that.name) && equal(this.counter,  that.counter);
            }
            return false;
        }
        @Override
        public int hashCode() {
            return name.hashCode() + counter;
        }
    }
}
"
org.apache.camel.processor.DeadLetterChannel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.RejectedExecutionException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.MessageHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Implements a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a> after attempting to redeliver the message using the
 * {@link RedeliveryPolicy}
 *
 * @version $Revision: 740263 $
 */
public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor {
    public static final String REDELIVERY_COUNTER = ""org.apache.camel.RedeliveryCounter"";
    public static final String REDELIVERED = ""org.apache.camel.Redelivered"";
    public static final String EXCEPTION_CAUSE_PROPERTY = ""CamelCauseException"";
    public static final String CAUGHT_EXCEPTION_HEADER = ""org.apache.camel.CamelCaughtException"";    
    private static final transient Log LOG = LogFactory.getLog(DeadLetterChannel.class);
    private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel.class.getName() + "".FAILURE_HANDLED"";
    private static Timer timer = new Timer();
    private Processor output;
    private Processor deadLetter;
    private AsyncProcessor outputAsync;
    private RedeliveryPolicy redeliveryPolicy;
    private Logger logger;
    private Processor redeliveryProcessor;
    private class RedeliveryData {
        int redeliveryCounter;
        long redeliveryDelay;
        boolean sync = true;
        Predicate handledPredicate;
        // default behavior which can be overloaded on a per exception basis
        RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy;
        Processor failureProcessor = deadLetter;
    }
    private class RedeliverTimerTask extends TimerTask {
        private final Exchange exchange;
        private final AsyncCallback callback;
        private final RedeliveryData data;
        public RedeliverTimerTask(Exchange exchange, AsyncCallback callback, RedeliveryData data) {
            this.exchange = exchange;
            this.callback = callback;
            this.data = data;
        }
        @Override
        public void run() {
            //only handle the real AsyncProcess the exchange 
            outputAsync.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Only handle the async case...
                    if (sync) {
                        return;
                    }
                    data.sync = false;
                    // only process if the exchange hasn't failed
                    // and it has not been handled by the error processor
                    if (exchange.getException() != null && !isFailureHandled(exchange)) {
                        // if we are redelivering then sleep before trying again
                        asyncProcess(exchange, callback, data);
                    } else {
                        callback.done(sync);
                    }
                }
            });                
        } 
    }
    public DeadLetterChannel(Processor output, Processor deadLetter, Processor redeliveryProcessor, RedeliveryPolicy redeliveryPolicy, Logger logger, ExceptionPolicyStrategy exceptionPolicyStrategy) {
        this.output = output;
        this.deadLetter = deadLetter;
        this.redeliveryProcessor = redeliveryProcessor;
        this.outputAsync = AsyncProcessorTypeConverter.convert(output);
        this.redeliveryPolicy = redeliveryPolicy;
        this.logger = logger;
        setExceptionPolicy(exceptionPolicyStrategy);
    }
    public static <E extends Exchange> Logger createDefaultLogger() {
        return new Logger(LOG, LoggingLevel.ERROR);
    }
    @Override
    public String toString() {
        return ""DeadLetterChannel["" + output + "", "" + deadLetter + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, final AsyncCallback callback) {
        return process(exchange, callback, new RedeliveryData());
    }
    /**
     * Processes the exchange using decorated with this dead letter channel.
     */
    protected boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {
        while (true) {
            // we can't keep retrying if the route is being shutdown.
            if (!isRunAllowed()) {
                if (exchange.getException() == null) {
                    exchange.setException(new RejectedExecutionException());
                }
                callback.done(data.sync);
                return data.sync;
            }
            // if the exchange is transacted then let the underlying system handle the redelivery etc.
            // this DeadLetterChannel is only for non transacted exchanges
            if (exchange.isTransacted() && exchange.getException() != null) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""This is a transacted exchange, bypassing this DeadLetterChannel: "" + this + "" for exchange: "" + exchange);
                }
                return data.sync;
            }
            // did previous processing caused an exception?
            if (exchange.getException() != null) {
                handleException(exchange, data);
            }
            // compute if we should redeliver or not
            boolean shouldRedeliver = shouldRedeliver(exchange, data);
            if (!shouldRedeliver) {
                return deliverToFaultProcessor(exchange, callback, data);
            }
            // if we are redelivering then sleep before trying again
            if (data.redeliveryCounter > 0) {
                // okay we will give it another go so clear the exception so we can try again
                if (exchange.getException() != null) {
                    exchange.setException(null);
                }
                // reset cached streams so they can be read again
                MessageHelper.resetStreamCache(exchange.getIn());
                // wait until we should redeliver
                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay);
                // letting onRedeliver be executed
                deliverToRedeliveryProcessor(exchange, callback, data);
            }
            // process the exchange
            boolean sync = outputAsync.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Only handle the async case...
                    if (sync) {
                        return;
                    }
                    data.sync = false;
                    // only process if the exchange hasn't failed
                    // and it has not been handled by the error processor
                    if (exchange.getException() != null && !isFailureHandled(exchange)) {                        
                        //TODO Call the Timer for the asyncProcessor
                        asyncProcess(exchange, callback, data);
                    } else {
                        callback.done(sync);
                    }
                }
            });
            if (!sync) {
                // It is going to be processed async..
                return false;
            }
            if (exchange.getException() == null || isFailureHandled(exchange)) {
                // If everything went well.. then we exit here..
                callback.done(true);
                return true;
            }
            // error occurred so loop back around.....
        }
    }
    protected void asyncProcess(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {
        // set the timer here
        if (!isRunAllowed()) {
            if (exchange.getException() == null) {
                exchange.setException(new RejectedExecutionException());
            }
            callback.done(data.sync);
            return;
        }
        // if the exchange is transacted then let the underlying system handle the redelivery etc.
        // this DeadLetterChannel is only for non transacted exchanges
        if (exchange.isTransacted() && exchange.getException() != null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""This is a transacted exchange, bypassing this DeadLetterChannel: "" + this + "" for exchange: "" + exchange);
            }
            return;
        }
        // did previous processing caused an exception?
        if (exchange.getException() != null) {
            handleException(exchange, data);
        }
        // compute if we should redeliver or not
        boolean shouldRedeliver = shouldRedeliver(exchange, data);
        if (!shouldRedeliver) {
            deliverToFaultProcessor(exchange, callback, data);
            return;
        }
        // process the next try
        // if we are redelivering then sleep before trying again
        if (data.redeliveryCounter > 0) {
            // okay we will give it another go so clear the exception so we can try again
            if (exchange.getException() != null) {
                exchange.setException(null);
            }
            // wait until we should redeliver
            data.redeliveryDelay = data.currentRedeliveryPolicy.getRedeliveryDelay(data.redeliveryDelay);
            timer.schedule(new RedeliverTimerTask(exchange, callback, data), data.redeliveryDelay);
            // letting onRedeliver be executed
            deliverToRedeliveryProcessor(exchange, callback, data);
        }
    }
    private void handleException(Exchange exchange, RedeliveryData data) {
        Throwable e = exchange.getException();
        // set the original caused exception
        exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, e);
        // find the error handler to use (if any)
        ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);
        if (exceptionPolicy != null) {
            data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(exchange.getContext(), data.currentRedeliveryPolicy);
            data.handledPredicate = exceptionPolicy.getHandledPolicy();
            Processor processor = exceptionPolicy.getErrorHandler();
            if (processor != null) {
                data.failureProcessor = processor;
            }
        }
        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId()
                + "". On delivery attempt: "" + data.redeliveryCounter + "" caught: "" + e;
        logFailedDelivery(true, exchange, msg, data, e);
        data.redeliveryCounter = incrementRedeliveryCounter(exchange, e);
    }
    /**
     * Gives an optional configure redelivery processor a chance to process before the Exchange
     * will be redelivered. This can be used to alter the Exchange.
     */
    private boolean deliverToRedeliveryProcessor(final Exchange exchange, final AsyncCallback callback,
                                            final RedeliveryData data) {
        if (redeliveryProcessor == null) {
            return true;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(""RedeliveryProcessor "" + redeliveryProcessor + "" is processing Exchange before its redelivered"");
        }
        AsyncProcessor afp = AsyncProcessorTypeConverter.convert(redeliveryProcessor);
        boolean sync = afp.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                callback.done(data.sync);
            }
        });
        return sync;
    }
    private boolean deliverToFaultProcessor(final Exchange exchange, final AsyncCallback callback,
                                            final RedeliveryData data) {
        // we did not success with the redelivery so now we let the failure processor handle it
        setFailureHandled(exchange);
        // must decrement the redelivery counter as we didn't process the redelivery but is
        // handling by the failure handler. So we must -1 to not let the counter be out-of-sync
        decrementRedeliveryCounter(exchange);
        AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor);
        boolean sync = afp.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                restoreExceptionOnExchange(exchange, data.handledPredicate);
                callback.done(data.sync);
            }
        });
        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId()
                + "". Handled by the failure processor: "" + data.failureProcessor;
        logFailedDelivery(false, exchange, msg, data, null);
        return sync;
    }
    // Properties
    // -------------------------------------------------------------------------
    public static boolean isFailureHandled(Exchange exchange) {
        return exchange.getProperty(FAILURE_HANDLED_PROPERTY) != null
            || exchange.getIn().getHeader(CAUGHT_EXCEPTION_HEADER) != null;
    }
    public static void setFailureHandled(Exchange exchange) {
        exchange.setProperty(FAILURE_HANDLED_PROPERTY, exchange.getException());
        exchange.getIn().setHeader(CAUGHT_EXCEPTION_HEADER, exchange.getException());
        exchange.setException(null);
    }
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    /**
     * Returns the dead letter that message exchanges will be sent to if the
     * redelivery attempts fail
     */
    public Processor getDeadLetter() {
        return deadLetter;
    }
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public Logger getLogger() {
        return logger;
    }
    /**
     * Sets the logger strategy; which {@link Log} to use and which
     * {@link LoggingLevel} to use
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected static void restoreExceptionOnExchange(Exchange exchange, Predicate handledPredicate) {
        if (handledPredicate == null || !handledPredicate.matches(exchange)) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""This exchange is not handled so its marked as failed: "" + exchange);
            }
            // exception not handled, put exception back in the exchange
            exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""This exchange is handled so its marked as not failed: "" + exchange);
            }
            exchange.setProperty(Exchange.EXCEPTION_HANDLED_PROPERTY, Boolean.TRUE);
        }
    }
    private void logFailedDelivery(boolean shouldRedeliver, Exchange exchange, String message, RedeliveryData data, Throwable e) {
        LoggingLevel newLogLevel;
        if (shouldRedeliver) {
            newLogLevel = data.currentRedeliveryPolicy.getRetryAttemptedLogLevel();
        } else {
            newLogLevel = data.currentRedeliveryPolicy.getRetriesExhaustedLogLevel();
        }
        if (e != null) {
            logger.log(message, e, newLogLevel);
        } else {
            logger.log(message, newLogLevel);
        }
    }
    private boolean shouldRedeliver(Exchange exchange, RedeliveryData data) {
        return data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter);
    }
    /**
     * Increments the redelivery counter and adds the redelivered flag if the
     * message has been redelivered
     */
    protected int incrementRedeliveryCounter(Exchange exchange, Throwable e) {
        Message in = exchange.getIn();
        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);
        int next = 1;
        if (counter != null) {
            next = counter + 1;
        }
        in.setHeader(REDELIVERY_COUNTER, next);
        in.setHeader(REDELIVERED, Boolean.TRUE);
        return next;
    }
    /**
     * Prepares the redelivery counter and boolean flag for the failure handle processor
     */
    private void decrementRedeliveryCounter(Exchange exchange) {
        Message in = exchange.getIn();
        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);
        if (counter != null) {
            int prev = counter - 1;
            in.setHeader(REDELIVERY_COUNTER, prev);
            // set boolean flag according to counter
            in.setHeader(REDELIVERED, prev > 0 ? Boolean.TRUE : Boolean.FALSE);
        } else {
            // not redelivered
            in.setHeader(REDELIVERY_COUNTER, 0);
            in.setHeader(REDELIVERED, Boolean.FALSE);
        }
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output, deadLetter);
    }
    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(deadLetter, output);
    }    
}
"
org.apache.camel.processor.DeadLetterChannelExceptionCausePropagatedTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class DeadLetterChannelExceptionCausePropagatedTest extends ContextTestSupport {
    private static final RuntimeException RUNTIME_EXCEPTION = new RuntimeException(""Expected exception."");
    private String body = ""<hello>world!</hello>"";
    public void testFirstFewAttemptsFail() throws Exception {
        MockEndpoint failedEndpoint = getMockEndpoint(""mock:failed"");
        MockEndpoint successEndpoint = getMockEndpoint(""mock:success"");
        failedEndpoint.expectedBodiesReceived(body);
        failedEndpoint.message(0).header(DeadLetterChannel.CAUGHT_EXCEPTION_HEADER)
            .isEqualTo(RUNTIME_EXCEPTION);
        failedEndpoint.expectedMessageCount(1);
        successEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisfied();
        assertNull(failedEndpoint.getExchanges().get(0).getException());
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                onException(RuntimeException.class).handled(true).to(""mock:failed"");
                from(""direct:start"").process(ProcessorBuilder.throwException(RUNTIME_EXCEPTION))
                    .to(""mock:success"");
            }
        };
    }
}
"
org.apache.camel.processor.DeadLetterChannelHandledExampleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Map;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Headers;
import org.apache.camel.OutHeaders;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to verify that handled policy is working as expected for wiki documentation.
 */
public class DeadLetterChannelHandledExampleTest extends ContextTestSupport {
    public void testOrderOK() throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(""Order OK"");
        result.expectedHeaderReceived(""orderid"", ""123"");
        MockEndpoint error = getMockEndpoint(""mock:error"");
        error.expectedMessageCount(0);
        Object out = template.requestBodyAndHeader(""direct:start"", ""Order: MacBook Pro"", ""customerid"", ""444"");
        assertEquals(""Order OK"", out);
        assertMockEndpointsSatisfied();
    }
    public void testOrderERROR() throws Exception {
        MockEndpoint error = getMockEndpoint(""mock:error"");
        error.expectedBodiesReceived(""Order ERROR"");
        error.expectedHeaderReceived(""orderid"", ""failed"");
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMessageCount(0);
        Object out = template.requestBodyAndHeader(""direct:start"", ""Order: kaboom"", ""customerid"", ""555"");
        assertEquals(""Order ERROR"", out);
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // we do special error handling for when OrderFailedException is thrown
                onException(OrderFailedException.class)
                    // we mark the exchange as handled so the caller doesn't receive the
                    // OrderFailedException but whatever we want to return instead
                    .handled(true)
                    // this bean handles the error handling where we can customize the error
                    // response using java code
                    .bean(OrderService.class, ""orderFailed"")
                    // and since this is an unit test we use mocks for testing
                    .to(""mock:error"");
                // this is just the generic error handler where we set the destination
                // and the number of redeliveries we want to try
                errorHandler(deadLetterChannel(""mock:error"").maximumRedeliveries(1));
                // this is our route where we handle orders
                from(""direct:start"")
                    // this bean is our order service
                    .bean(OrderService.class, ""handleOrder"")
                    // this is the destination if the order is OK
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        };
    }
    // START SNIPPET: e2
    /**
     * Order service as a plain POJO class
     */
    public static class OrderService {
        /**
         * This method handle our order input and return the order
         *
         * @param in      the in headers
         * @param payload the in payload
         * @param out     the out headers
         * @return the out payload
         * @throws OrderFailedException is thrown if the order can not be processed
         */
        public Object handleOrder(@Headers Map in, @Body String payload, @OutHeaders Map out)
            throws OrderFailedException {
            out.put(""customerid"", in.get(""customerid""));
            if (""Order: kaboom"".equals(payload)) {
                throw new OrderFailedException(""Can not order: kaboom"");
            } else {
                out.put(""orderid"", ""123"");
                return ""Order OK"";
            }
        }
        /**
         * This method creates the response to the caller if the order could not be processed
         * @param in      the in headers
         * @param payload the in payload
         * @param out     the out headers
         * @return the out payload
         */
        public Object orderFailed(@Headers Map in, @Body String payload, @OutHeaders Map out) {
            out.put(""customerid"", in.get(""customerid""));
            out.put(""orderid"", ""failed"");
            return ""Order ERROR"";
        }
    }
    // END SNIPPET: e2
    // START SNIPPET: e3
    /**
     * Exception thrown if the order can not be processed
     */
    public static class OrderFailedException extends Exception {
        public OrderFailedException(String message) {
            super(message);
        }
    }
    // END SNIPPET: e3
}
"
org.apache.camel.processor.DeadLetterChannelOnRedeliveryTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for testing possibility to modify exchange before redelivering
 */
public class DeadLetterChannelOnRedeliveryTest extends ContextTestSupport {
    static int counter;
    public void testOnExceptionAlterMessageBeforeRedelivery() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""Hello World123"");
        template.sendBody(""direct:start"", ""Hello World"");
        assertMockEndpointsSatisfied();
    }
    public void testOnExceptionAlterMessageWithHeadersBeforeRedelivery() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""Hello World123"");
        mock.expectedHeaderReceived(""foo"", ""123"");
        template.sendBodyAndHeader(""direct:start"", ""Hello World"", ""foo"", ""123"");
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        counter = 0;
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // START SNIPPET: e1
                // we configure our Dead Letter Channel to invoke
                // MyRedeliveryProcessor before a redelivery is
                // attempted. This allows us to alter the message before
                errorHandler(deadLetterChannel(""mock:error"")
                        .onRedelivery(new MyRedeliverPrcessor())
                        // setting delay to zero is just to make unit teting faster
                        .initialRedeliveryDelay(0L));
                // END SNIPPET: e1
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        // force some error so Camel will do redelivery
                        if (++counter <= 3) {
                            throw new IllegalArgumentException(""Forced by unit test"");
                        }
                    }
                }).to(""mock:result"");
            }
        };
    }
    // START SNIPPET: e2
    // This is our processor that is executed before every redelivery attempt
    // here we can do what we want in the java code, such as altering the message
    public class MyRedeliverPrcessor implements Processor {
        public void process(Exchange exchange) throws Exception {
            // the message is being redelivered so we can alter it
            // we just append the redelivery counter to the body
            // you can of course do all kind of stuff instead
            String body = exchange.getIn().getBody(String.class);
            int count = exchange.getIn().getHeader(""org.apache.camel.RedeliveryCounter"", Integer.class);
            exchange.getIn().setBody(body + count);
        }
    }
    // END SNIPPET: e2
}
"
org.apache.camel.processor.DeadLetterChannelRedeliveryTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to verify that redelivery counters is working as expected.
 */
public class DeadLetterChannelRedeliveryTest extends ContextTestSupport {
    private static int counter;
    public void testRedeliveryTest() throws Exception {
        counter = 0;
        // We expect the exchange here after 1 delivery and 2 re-deliveries
        MockEndpoint mock = getMockEndpoint(""mock:error"");
        mock.expectedMessageCount(1);
        mock.message(0).header(""org.apache.camel.Redelivered"").isEqualTo(Boolean.TRUE);
        mock.message(0).header(""org.apache.camel.RedeliveryCounter"").isEqualTo(2);
        try {
            template.sendBody(""direct:start"", ""Hello World"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        assertMockEndpointsSatisfied();
        assertEquals(3, counter); // One call + 2 re-deliveries
    }
    public void testNoRedeliveriesTest() throws Exception {
        counter = 0;
        // We expect the exchange here after 1 delivery
        MockEndpoint mock = getMockEndpoint(""mock:no"");
        mock.expectedMessageCount(1);
        mock.message(0).header(""org.apache.camel.Redelivered"").isEqualTo(Boolean.FALSE);
        mock.message(0).header(""org.apache.camel.RedeliveryCounter"").isEqualTo(0);
        try {
            template.sendBody(""direct:no"", ""Hello World"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        assertMockEndpointsSatisfied();
        assertEquals(1, counter); // One call
    }
    public void testOneRedeliveryTest() throws Exception {
        counter = 0;
        // We expect the exchange here after 1 delivery and 1 re delivery
        MockEndpoint mock = getMockEndpoint(""mock:one"");
        mock.expectedMessageCount(1);
        mock.message(0).header(""org.apache.camel.Redelivered"").isEqualTo(Boolean.TRUE);
        mock.message(0).header(""org.apache.camel.RedeliveryCounter"").isEqualTo(1);
        try {
            template.sendBody(""direct:one"", ""Hello World"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        assertMockEndpointsSatisfied();
        assertEquals(2, counter); // One call + 1 re-delivery
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"")
                    .errorHandler(deadLetterChannel(""mock:error"").maximumRedeliveries(2))
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            counter++;
                            throw new Exception(""Forced exception by unit test"");
                        }
                    });
                from(""direct:no"")
                    .errorHandler(deadLetterChannel(""mock:no"").maximumRedeliveries(0))
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            counter++;
                            throw new Exception(""Forced exception by unit test"");
                        }
                    });
                from(""direct:one"")
                    .errorHandler(deadLetterChannel(""mock:one"").maximumRedeliveries(1))
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            counter++;
                            throw new Exception(""Forced exception by unit test"");
                        }
                    });
            }
        };
    }
}
"
org.apache.camel.processor.DeadLetterChannelTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.LoggingLevel;
/**
 * @version $Revision: 722772 $
 */
public class DeadLetterChannelTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint deadEndpoint;
    protected MockEndpoint successEndpoint;
    protected int failUntilAttempt = 2;
    protected String body = ""<hello>world!</hello>"";
    public void testFirstFewAttemptsFail() throws Exception {
        successEndpoint.expectedBodiesReceived(body);
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(1);
        deadEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisfied();
    }
    public void testLotsOfAttemptsFail() throws Exception {
        failUntilAttempt = 5;
        deadEndpoint.expectedBodiesReceived(body);
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(2);
        successEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisfied();
        Throwable t = deadEndpoint.getExchanges().get(0).getProperty(DeadLetterChannel.EXCEPTION_CAUSE_PROPERTY, Throwable.class);
        assertNotNull(""Should have been a cause property"", t);
        assertTrue(t instanceof RuntimeException);
        assertEquals(""Failed to process due to attempt: 3 being less than: 5"", t.getMessage());
        Throwable t2 = deadEndpoint.getExchanges().get(0).getException();
        assertEquals(t, t2);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        deadEndpoint = getMockEndpoint(""mock:failed"");
        successEndpoint = getMockEndpoint(""mock:success"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new AsyncProcessor() {
            public void process(Exchange exchange) {
                Integer counter = exchange.getIn().getHeader(DeadLetterChannel.REDELIVERY_COUNTER,
                                                             Integer.class);
                int attempt = (counter == null) ? 1 : counter + 1;
                if (attempt < failUntilAttempt) {
                    throw new RuntimeException(""Failed to process due to attempt: "" + attempt
                                               + "" being less than: "" + failUntilAttempt);
                }
            }
            public boolean process(Exchange exchange, AsyncCallback callback) {                
                Integer counter = exchange.getIn().getHeader(DeadLetterChannel.REDELIVERY_COUNTER,
                                                             Integer.class);
                int attempt = (counter == null) ? 1 : counter + 1;
                if (attempt > 1) {
                    assertEquals(""Now we should use TimerThread to call the process"", Thread.currentThread().getName(), ""Timer-0"");
                }
                if (attempt < failUntilAttempt) {
                    // we can't throw the exception here , or the callback will not be invoked.
                    exchange.setException(new RuntimeException(""Failed to process due to attempt: "" + attempt
                                               + "" being less than: "" + failUntilAttempt));
                }
                callback.done(false);
                return false;
            }
        };
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").errorHandler(
                    deadLetterChannel(""mock:failed"").maximumRedeliveries(2)
                        .initialRedeliveryDelay(1000)
                        .loggingLevel(LoggingLevel.DEBUG)
                ).process(processor).to(""mock:success"");
            }
        };
    }
}
"
org.apache.camel.processor.DebugInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Debugger;
/**
 * @version $Revision: 673954 $
 */
public class DebugInterceptorTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testSendingSomeMessages() throws Exception {
        template.sendBodyAndHeader(""direct:start"", ""Hello London"", ""to"", ""James"");
        template.sendBodyAndHeader(""direct:start"", ""This is Copenhagen calling"", ""from"", ""Claus"");
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // add debugger as an interceptor. The debugger is an enhanced tracer that also
                // logs the exchanges at runtime. It is also a framework where we programatically
                // can access the internal states of Camel etc.
                getContext().addInterceptStrategy(new Debugger());
                from(""direct:start"").
                        process(new Processor() {
                            public void process(Exchange exchange) throws Exception {
                                // do nothing
                            }
                            @Override
                            public String toString() {
                                return ""MyProcessor"";
                            }
                        }).
                        to(""mock:a"").
                        to(""mock:b"");
            }
        };
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.Delayer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> which
 * delays processing the exchange until the correct amount of time has elapsed
 * using an expression to determine the delivery time. <p/> For example if you
 * wish to delay JMS messages by 25 seconds from their publish time you could
 * create an instance of this class with the expression
 * <code>header(""JMSTimestamp"")</code> and a delay value of 25000L.
 * 
 * @version $Revision: 630591 $
 */
public class Delayer extends DelayProcessorSupport {
    private Expression<Exchange> timeExpression;
    private long delay;
    public Delayer(Processor processor, Expression<Exchange> timeExpression, long delay) {
        super(processor);
        this.timeExpression = timeExpression;
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer[on: "" + timeExpression + "" delay: "" + delay + "" to: "" + getProcessor() + ""]"";
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getDelay() {
        return delay;
    }
    /**
     * Sets the delay from the publish time; which is typically the time from
     * the expression or the current system time if none is available
     */
    public void setDelay(long delay) {
        this.delay = delay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Waits for an optional time period before continuing to process the
     * exchange
     */
    protected void delay(Exchange exchange) throws Exception {
        long time = 0;
        if (timeExpression != null) {
            Long longValue = ExpressionHelper.evaluateAsType(timeExpression, exchange, Long.class);
            if (longValue != null) {
                time = longValue.longValue();
            }
        }
        if (time <= 0) {
            time = defaultProcessTime(exchange);
        }
        time += delay;
        waitUntil(time, exchange);
    }
    /**
     * A Strategy Method to allow derived implementations to decide the current
     * system time or some other default exchange property
     * 
     * @param exchange
     */
    protected long defaultProcessTime(Exchange exchange) {
        return currentSystemTime();
    }
}
"
org.apache.camel.processor.DelayerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class DelayerTest extends ContextTestSupport {
    public void testSendingMessageGetsDelayed() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""seda:a"", ""<hello>world!</hello>"", ""JMSTimestamp"", System
            .currentTimeMillis());
        resultEndpoint.assertIsSatisfied();
        // now if we wait a bit longer we should receive the message!
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
        template.sendBody(""seda:b"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        // now if we wait a bit longer we should receive the message!
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").delayer(header(""JMSTimestamp""), 3000).to(""mock:result"");
                // END SNIPPET: ex
                // START SNIPPET: ex2
                from(""seda:b"").delayer(3000).to(""mock:result"");
                // END SNIPPET: ex2
            }
        };
    }
}
"
org.apache.camel.processor.DelayInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Delayer;
/**
 * Delay interceptor unit test.
 *
 * @version $Revision: 711235 $
 */
public class DelayInterceptorTest extends ContextTestSupport {
    public void testSendingSomeMessages() throws Exception {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            template.sendBody(""direct:start"", ""Message #"" + i);
        }
        long delta = System.currentTimeMillis() - start;
        assertTrue(""Should be slower to run: "" + delta, delta > 4000);
        assertTrue(""Should not take that long to run: "" + delta, delta < 7000);
    }
    @Override
    protected void setUp() throws Exception {
        disableJMX();
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            // START SNIPPET: e1
            public void configure() throws Exception {
                // add the delay interceptor to delay each step 200 millis
                getContext().addInterceptStrategy(new Delayer(200));
                // regular routes here
            // END SNIPPET: e1
                from(""direct:start"").
                        process(new Processor() {
                            public void process(Exchange exchange) throws Exception {
                                // do nothing
                            }
                        }).
                        to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.DelayPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
/**
 * The base policy used when a fixed delay is needed.
 * <p/>
 * This policy is used by
 * <a href=""http://activemq.apache.org/camel/transactional-client.html"">Transactional client</a>
 * and <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a>.
 *
 * The default values is:
 * <ul>
 *   <li>delay = 1000L</li>
 * </ul>
 * <p/>
 *
 * @version $Revision: 693940 $
 */
public class DelayPolicy implements Cloneable, Serializable {
    protected long delay = 1000L;
    public DelayPolicy() {
    }
    @Override
    public String toString() {
        return ""DelayPolicy[delay="" + delay + ""]"";
    }
    public DelayPolicy copy() {
        try {
            return (DelayPolicy)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(""Could not clone: "" + e, e);
        }
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the delay in milliseconds
     */
    public DelayPolicy delay(long delay) {
        setDelay(delay);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getDelay() {
        return delay;
    }
    /**
     * Sets the delay in milliseconds
     */
    public void setDelay(long delay) {
        this.delay = delay;
    }
}
"
org.apache.camel.processor.DelayProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any processor which provides some kind of throttling
 * or delayed processing
 * 
 * @version $Revision: 696610 $
 */
public abstract class DelayProcessorSupport extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(Delayer.class);
    private CountDownLatch stoppedLatch = new CountDownLatch(1);
    private boolean fastStop = true;
    public DelayProcessorSupport(Processor processor) {
        super(processor);
    }
    public void process(Exchange exchange) throws Exception {
        delay(exchange);
        super.process(exchange);
    }
    public boolean isFastStop() {
        return fastStop;
    }
    /**
     * Enables & disables a fast stop; basically to avoid waiting a possibly
     * long time for delays to complete before the context shuts down; instead
     * the current processing method throws
     * {@link org.apache.camel.AlreadyStoppedException} to terminate processing.
     */
    public void setFastStop(boolean fastStop) {
        this.fastStop = fastStop;
    }
    protected void doStop() throws Exception {
        stoppedLatch.countDown();
        super.doStop();
    }
    protected abstract void delay(Exchange exchange) throws Exception;
    /**
     * Wait until the given system time before continuing
     * 
     * @param time the system time to wait for
     * @param exchange the exchange being processed
     */
    protected void waitUntil(long time, Exchange exchange) throws Exception {
        while (true) {
            long delay = time - currentSystemTime();
            if (delay < 0) {
                return;
            } else {
                if (isFastStop() && !isRunAllowed()) {
                    throw new AlreadyStoppedException();
                }
                try {
                    sleep(delay);
                } catch (InterruptedException e) {
                    handleSleepInteruptedException(e);
                }
            }
        }
    }
    protected void sleep(long delay) throws InterruptedException {
        if (delay <= 0) {
            return;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Sleeping for: "" + delay + "" millis"");
        }
        if (isFastStop()) {
            stoppedLatch.await(delay, TimeUnit.MILLISECONDS);
        } else {
            Thread.sleep(delay);
        }
    }
    /**
     * Called when a sleep is interupted; allows derived classes to handle this
     * case differently
     */
    protected void handleSleepInteruptedException(InterruptedException e) {
        LOG.debug(""Sleep interupted: "" + e, e);
    }
    protected long currentSystemTime() {
        return System.currentTimeMillis();
    }
}
"
org.apache.camel.processor.DelegateAsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested AsyncProcessor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 */
public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor {
    protected AsyncProcessor processor;
    public DelegateAsyncProcessor() {
    }
    public DelegateAsyncProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""DelegateAsync("" + processor + "")"";
    }
    public AsyncProcessor getProcessor() {
        return processor;
    }
    public void setProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
}
"
org.apache.camel.processor.DelegateProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested processor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 * 
 * @version $Revision: 658240 $
 */
public class DelegateProcessor extends ServiceSupport implements Processor {
    protected Processor processor;
    public DelegateProcessor() {
    }
    public DelegateProcessor(Processor processor) {
        if (processor == this) {
            throw new IllegalArgumentException(""Recursive DelegateProcessor!"");
        }
        this.processor = processor;
    }
    public void process(Exchange exchange) throws Exception {
        processNext(exchange);
    }
    protected void processNext(Exchange exchange) throws Exception {
        if (processor != null) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Delegate("" + processor + "")"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    /**
     * Proceed with the underlying delegated processor
     */
    public void proceed(Exchange exchange) throws Exception {
        processNext(exchange);
    }
}
"
org.apache.camel.processor.ErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Processor;
/**
 * An interface used to represent an error handler
 *
 * @version $Revision: 630591 $
 */
public interface ErrorHandler extends Processor {
}
"
org.apache.camel.processor.ErrorHandlerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
/**
 * Support class for {@link ErrorHandler} implementations.
 *
 * @version $Revision: 719980 $
 */
public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler {
    private Map<ExceptionPolicyKey, ExceptionType> exceptionPolicies = new LinkedHashMap<ExceptionPolicyKey, ExceptionType>();
    private ExceptionPolicyStrategy exceptionPolicy = createDefaultExceptionPolicyStrategy();
    public void addExceptionPolicy(ExceptionType exceptionType) {
        Processor processor = exceptionType.getErrorHandler();
        addChildService(processor);
        List<Class> list = exceptionType.getExceptionClasses();
        for (Class clazz : list) {
            ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());
            exceptionPolicies.put(key, exceptionType);
        }
    }
    /**
     * Attempts to invoke the handler for this particular exception if one is available
     */
    protected boolean customProcessorForException(Exchange exchange, Throwable exception) throws Exception {
        ExceptionType policy = getExceptionPolicy(exchange, exception);
        if (policy != null) {
            Processor processor = policy.getErrorHandler();
            if (processor != null) {
                processor.process(exchange);
                return true;
            }
        }
        return false;
    }
    /**
     * Attempts to find the best suited {@link ExceptionType} to be used for handling the given thrown exception.
     *
     * @param exchange  the exchange
     * @param exception the exception that was thrown
     * @return the best exception type to handle this exception, <tt>null</tt> if none found.
     */
    protected ExceptionType getExceptionPolicy(Exchange exchange, Throwable exception) {
        if (exceptionPolicy == null) {
            throw new IllegalStateException(""The exception policy has not been set"");
        }
        return exceptionPolicy.getExceptionPolicy(exceptionPolicies, exchange, exception);
    }
    /**
     * Sets the strategy to use for resolving the {@link ExceptionType} to use
     * for handling thrown exceptions.
     */
    public void setExceptionPolicy(ExceptionPolicyStrategy exceptionPolicy) {
        this.exceptionPolicy = exceptionPolicy;
    }
    /**
     * Creates the default exception policy strategy to use.
     */
    public static ExceptionPolicyStrategy createDefaultExceptionPolicyStrategy() {
        return new DefaultExceptionPolicyStrategy();
    }
}
"
org.apache.camel.processor.ErrorHandlerSupportTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
public class ErrorHandlerSupportTest extends TestCase {
    public void testOnePolicyChildFirst() {
        List<Class> exceptions = new ArrayList<Class>();
        exceptions.add(ChildException.class);
        exceptions.add(ParentException.class);
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(exceptions));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 1));
    }
    public void testOnePolicyChildLast() {
        List<Class> exceptions = new ArrayList<Class>();
        exceptions.add(ParentException.class);
        exceptions.add(ChildException.class);
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(exceptions));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 1));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    public void testTwoPolicyChildFirst() {
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(ChildException.class));
        support.addExceptionPolicy(new ExceptionType(ParentException.class));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    public void testTwoPolicyChildLast() {
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(ParentException.class));
        support.addExceptionPolicy(new ExceptionType(ChildException.class));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    private static Class getExceptionPolicyFor(ErrorHandlerSupport support, Throwable childException,
                                               int index) {
        return support.getExceptionPolicy(null, childException).getExceptionClasses().get(index);
    }
    private static class ParentException extends Exception {
    }
    private static class ChildException extends ParentException {
    }
    private static class ShuntErrorHandlerSupport extends ErrorHandlerSupport {
        protected void doStart() throws Exception {
        }
        protected void doStop() throws Exception {
        }
        public void process(Exchange exchange) throws Exception {
        }
    }
}
"
org.apache.camel.processor.ErrorHandlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Error Handler unit test
 */
public class ErrorHandlerTest extends ContextTestSupport {
    public void testNoError() throws Exception {
        MockEndpoint error = getMockEndpoint(""mock:error"");
        MockEndpoint result = getMockEndpoint(""mock:result"");
        error.expectedMessageCount(0);
        result.expectedMessageCount(1);
        result.expectedBodiesReceived(""Bye World"");
        template.sendBody(""direct:start"", ""Hello World"");
        assertMockEndpointsSatisfied();
    }
    public void testError() throws Exception {
        MockEndpoint error = getMockEndpoint(""mock:error"");
        MockEndpoint result = getMockEndpoint(""mock:result"");
        error.expectedMessageCount(1);
        // we exepect the orignal input when moved to the DLC queue
        error.expectedBodiesReceived(""Boom"");
        result.expectedMessageCount(0);
        try {
            template.sendBody(""direct:start"", ""Boom"");
            fail(""Should have thrown a RuntimeCamelException"");
        } catch (RuntimeCamelException e) {
            assertIsInstanceOf(IllegalArgumentException.class, e.getCause());
        }
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"")
                    .errorHandler(deadLetterChannel(""mock:error"").maximumRedeliveries(1))
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            String body = exchange.getIn().getBody(String.class);
                            if (""Boom"".equals(body)) {
                                throw new IllegalArgumentException(""Forced exception by unit test"");
                            }
                            exchange.getIn().setBody(""Bye World"");
                        }
                    })
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.ExchangePatternProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
public class ExchangePatternProcessor implements AsyncProcessor {
    private ExchangePattern exchangePattern = ExchangePattern.InOnly;
    public ExchangePatternProcessor() {
    }
    public ExchangePatternProcessor(ExchangePattern ep) {
        setExchangePattern(ep);
    }
    public void setExchangePattern(ExchangePattern ep) {
        exchangePattern = ep;
    }
    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(exchangePattern);        
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        exchange.setPattern(exchangePattern);
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.processor.ExpressionAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.impl.ExpressionSupport;
/**
 * A helper class for developers wishing to implement an {@link Expression} using Java code with a minimum amount
 * of code to write so that the developer only needs to implement the {@link #evaluate(Exchange)} method.
 *
 * @version $Revision: 700334 $
 */
public abstract class ExpressionAdapter extends ExpressionSupport<Exchange> {
    public abstract Object evaluate(Exchange exchange);
    protected String assertionFailureMessage(Exchange exchange) {
        return toString();
    }
}
"
org.apache.camel.processor.FaultRetryRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.CamelException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.LoggingLevel;
public class FaultRetryRouteTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    protected MockEndpoint error;
    protected final Processor successOnRetryProcessor = new Processor() {
        int count;
        public void process(Exchange exchange) throws CamelException {
            if (count++ == 0) {
                Message message = exchange.getFault();
                message.setBody(new CamelException(""Failed the first time""));
            }
        }
    };
    public void testSuccessfulRetry() throws Exception {
        a.expectedBodiesReceived(""in"");
        b.expectedBodiesReceived(""in"");
        error.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, error);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
        error = resolveMandatoryEndpoint(""mock:error"", MockEndpoint.class);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:start"").errorHandler(
                    deadLetterChannel(""mock:error"")
                        .maximumRedeliveries(4)
                        .loggingLevel(LoggingLevel.DEBUG))
                    .to(""mock:a"").handleFault().process(successOnRetryProcessor).to(""mock:b"");
            }
        };
    }
}
"
org.apache.camel.processor.FaultRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.CamelException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.LoggingLevel;
/**
 * @version $Revision: 710133 $
 */
public class FaultRouteTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    protected MockEndpoint c;
    protected MockEndpoint err;
    protected boolean shouldWork = true;
    public void testWithOut() throws Exception {
        a.whenExchangeReceived(1, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getOut().setBody(""out"");
            }
        });
        a.expectedMessageCount(1);
        b.expectedBodiesReceived(""out"");
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
    }
    public void testWithFault() throws Exception {
        shouldWork = false;
        a.whenExchangeReceived(1, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getFault().setBody(""fault"");
            }
        });
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
        // TODO wrap up as an exception on the mock endpoint
        List<Exchange> list = a.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Message fault = exchange.getFault();
        assertNotNull(""Should have a fault on A"", fault);
        assertEquals(""Fault body"", ""fault"", fault.getBody());
    }
    public void testWithThrowFaultMessage() throws Exception {
        throwFaultTest(""direct:string"");
    }
    public void testWithThrowFaultException() throws Exception {
        throwFaultTest(""direct:exception"");
    }
    public void testWithThrowFaultMessageUnhandled() throws Exception {
        throwFaultTest(""direct:fault"");
    }
    public void testWithHandleFaultMessage() throws Exception {
        throwFaultTest(""direct:error"", 1);
    }
    private void throwFaultTest(String startPoint) throws InterruptedException {
        throwFaultTest(startPoint, 0);
    }
    private void throwFaultTest(String startPoint, int errors) throws InterruptedException {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
        c.expectedMessageCount(0);
        err.expectedMessageCount(errors);
        try {
            template.sendBody(startPoint, ""in"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        MockEndpoint.assertIsSatisfied(a, b, c, err);
        List<Exchange> list = a.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Message fault = exchange.getFault();
        assertNotNull(""Should have a fault on A"", fault);
        if (startPoint.equals(""direct:exception"")) {
            assertTrue(""It should be the IllegalStateException"",
                       fault.getBody() instanceof IllegalStateException);
            assertEquals(""Fault message"", ""It makes no sense of business logic"",
                         ((IllegalStateException)(fault.getBody())).getMessage());
        } else { // test for the throwFault with String
            if (errors == 0) {
                // fault *not* handled
                assertTrue(""It should be the CamelException"", fault.getBody() instanceof CamelException);
                assertEquals(""Fault message"", ""ExceptionMessage"", ((CamelException)(fault.getBody())).getMessage());
            } else {
                // fault handled, exception should contain the fault
                assertNull(""Fault body should be null"", fault.getBody());
                CamelException faultex = (CamelException)exchange.getException();
                assertNotNull(""Exception body should contain the fault"", faultex);
                assertEquals(""Fault message"", ""ExceptionMessage"", faultex.getMessage());
            }
        }
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
        c = resolveMandatoryEndpoint(""mock:c"", MockEndpoint.class);
        err = resolveMandatoryEndpoint(""mock:error"", MockEndpoint.class);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:start"").to(""mock:a"").to(""mock:b"");
                from(""direct:string"").to(""mock:a"").throwFault(""ExceptionMessage"").to(""mock:b"");
                from(""direct:exception"").to(""mock:a"")
                    .throwFault(new IllegalStateException(""It makes no sense of business logic""))
                    .to(""mock:b"");
                from(""direct:fault"").errorHandler(
                    deadLetterChannel(""mock:error"")
                            .maximumRedeliveries(2)
                        .loggingLevel(LoggingLevel.DEBUG))
                    .to(""mock:a"").throwFault(""ExceptionMessage"").to(""mock:b"");
                from(""direct:error"").errorHandler(
                    deadLetterChannel(""mock:error"")
                            .maximumRedeliveries(2)
                        .loggingLevel(LoggingLevel.DEBUG))
                    .to(""mock:a"").handleFault().throwFault(""ExceptionMessage"").to(""mock:b"");
            }
        };
    }
}
"
org.apache.camel.processor.FilterProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
/**
 * The processor which implements the
 * <a href=""http://activemq.apache.org/camel/message-filter.html"">Message Filter</a> EIP pattern.
 *
 * @version $Revision: 659760 $
 */
public class FilterProcessor extends DelegateProcessor {
    private Predicate<Exchange> predicate;
    public FilterProcessor(Predicate<Exchange> predicate, Processor processor) {
        super(processor);
        this.predicate = predicate;
    }
    public void process(Exchange exchange) throws Exception {
        if (predicate.matches(exchange)) {
            super.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Filter[if: "" + predicate + "" do: "" + getProcessor() + ""]"";
    }
    public Predicate<Exchange> getPredicate() {
        return predicate;
    }
}
"
org.apache.camel.processor.FilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class FilterTest extends ContextTestSupport {
    public void testSendMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").filter(header(""foo"").isEqualTo(""bar"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.HandleFaultProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.util.AsyncProcessorHelper;
public class HandleFaultProcessor extends DelegateProcessor implements AsyncProcessor {
    @Override
    public String toString() {
        return ""HandleFaultProcessor("" + processor + "")"";
    }
    @Override
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (processor == null) {
            // no processor so nothing to process, so return
            callback.done(true);
            return true;
        }      
        if (processor instanceof AsyncProcessor) {
            return ((AsyncProcessor)processor).process(exchange, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    // Take the fault message out before we keep on going                    
                    Message faultMessage = exchange.getFault(false);
                    if (faultMessage != null) {
                        final Object faultBody = faultMessage.getBody();
                        if (faultBody != null) {
                            faultMessage.setBody(null); // Reset it since we are handling it.
                            if (faultBody instanceof Throwable) {
                                exchange.setException((Throwable)faultBody);
                            } else {
                                if (exchange.getException() == null) {                                
                                    exchange.setException(new CamelException(""Message contains fault of type ""
                                        + faultBody.getClass().getName() + "":\n"" + faultBody));
                                }
                            }
                        }
                    }
                    callback.done(doneSynchronously);
                }                
            });
        }
        try {
            processor.process(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        final Message faultMessage = exchange.getFault(false);
        if (faultMessage != null) {
            final Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                faultMessage.setBody(null); // Reset it since we are handling it.
                if (faultBody instanceof Throwable) {
                    exchange.setException((Throwable)faultBody);
                } else {
                    if (exchange.getException() == null) {
                        exchange.setException(new CamelException(""Message contains fault of type ""
                            + faultBody.getClass().getName() + "":\n"" + faultBody));
                    }
                }
            }
        }
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.processor.IdempotentConsumerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.processor.idempotent.MemoryMessageIdRepository.memoryMessageIdRepository;
/**
 * @version $Revision: 630568 $
 */
public class IdempotentConsumerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testDuplicateMessagesAreFilteredOut() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""3"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object messageId, final Object body) {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""messageId"", messageId);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").idempotentConsumer(
                        header(""messageId""), memoryMessageIdRepository(200)
                ).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.Interceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.Processor;
import org.apache.camel.util.ServiceHelper;
/**
 * An interceptor which provides the processing logic as a pluggable processor
 * which allows the {@link #proceed(Exchange)} method to be called at some point
 *
 * @version $Revision: 662664 $
 */
public class Interceptor extends DelegateProcessor implements Intercept {
    private Processor interceptorLogic;
    public Interceptor() {
    }
    public Interceptor(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    public void process(Exchange exchange) throws Exception {
        interceptorLogic.process(exchange);
    }
    public Processor getInterceptorLogic() {
        return interceptorLogic;
    }
    public void setInterceptorLogic(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startService(interceptorLogic);
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopService(interceptorLogic);
        super.doStop();
    }
}
"
org.apache.camel.processor.InterceptorSimpleRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * A simple interceptor routing test
 */
public class InterceptorSimpleRouteTest extends ContextTestSupport {
    public void testIntercept() throws Exception {
        MockEndpoint intercepted = getMockEndpoint(""mock:intercepted"");
        intercepted.expectedBodiesReceived(""Hello London"");
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(""Hello Paris"");
        template.sendBodyAndHeader(""seda:a"", ""Hello London"", ""city"", ""London"");
        template.sendBodyAndHeader(""seda:a"", ""Hello Paris"", ""city"", ""Paris"");
        intercepted.assertIsSatisfied();
        result.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // In Camel 1.4 proceed is default so we must use stop to not route it to the result mock
                intercept(header(""city"").isEqualTo(""London"")).to(""mock:intercepted"").stop();
                from(""seda:a"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.InterceptRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().choice().
                        when(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").
                        otherwise().proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptRouteTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public abstract class InterceptRouteTestSupport extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        prepareMatchingTest();
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisfied();
    }
    public void testSendNonMatchingMessage() throws Exception {
        prepareNonMatchingTest();
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected abstract void prepareMatchingTest();
    protected abstract void prepareNonMatchingTest();
}
"
org.apache.camel.processor.InterceptWithoutProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptWithoutProceedRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().filter(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateAndProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptWithPredicateAndProceedRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateAndStopRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 674289 $
 */
public class InterceptWithPredicateAndStopRouteTest extends
        InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").stop();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 674289 $
 */
public class InterceptWithPredicateRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // no stop so the message will proceed in its normal route also
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithStopRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 673954 $
 */
public class InterceptWithStopRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().filter(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").stop();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.JoinRoutesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class JoinRoutesTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testMessagesThroughDifferentRoutes() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""bar"", ""one"");
        sendMessage(""cheese"", ""two"");
        sendMessage(""somethingUndefined"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""foo"", headerValue);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:a"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice()
                        .when(header(""foo"").isEqualTo(""bar"")).to(""direct:b"")
                        .when(header(""foo"").isEqualTo(""cheese"")).to(""direct:c"")
                        .otherwise().to(""direct:d"");
                from(""direct:b"").to(""mock:result"");
                from(""direct:c"").to(""mock:result"");
                from(""direct:d"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.LoadBalanceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
public class LoadBalanceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").loadBalance().
                roundRobin().to(""mock:x"", ""mock:y"", ""mock:z"");
                // END SNIPPET: example
            }
        };
    }
    public void testRoundRobin() throws Exception {
        String body = ""<one/>"";
        x.expectedBodiesReceived(body);
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisfied();
        body = ""<two/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisfied();
        body = ""<three/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
}
"
org.apache.camel.processor.Logger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultExchangeFormatter;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which just logs to a {@link Log} object which can be used
 * as an exception handler instead of using a dead letter queue.
 *
 * @version $Revision: 710133 $
 */
public class Logger implements Processor {
    private Log log;
    private LoggingLevel level;
    private ExchangeFormatter formatter = DefaultExchangeFormatter.getInstance();
    public Logger() {
        this(LogFactory.getLog(Logger.class));
    }
    public Logger(Log log) {
        this(log, LoggingLevel.INFO);
    }
    public Logger(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public Logger(String logName) {
        this(LogFactory.getLog(logName));
    }
    public Logger(String logName, LoggingLevel level) {
        this(LogFactory.getLog(logName), level);
    }
    public Logger(Log log, ExchangeFormatter formatter) {
        this(log);
        this.formatter = formatter;
    }
    @Override
    public String toString() {
        return ""Logger["" + log + ""]"";
    }
    public void process(Exchange exchange) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange));
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange));
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange));
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange));
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange));
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange));
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }
    public void process(Exchange exchange, Throwable exception) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange), exception);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange), exception);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange), exception);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange), exception);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange), exception);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange), exception);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }
    public void log(String message, LoggingLevel loggingLevel) {
        LoggingLevel oldLogLevel = getLevel();
        setLevel(loggingLevel);
        log(message);
        setLevel(oldLogLevel);
    }
    public void log(String message) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message);
        }
    }
    public void log(String message, Throwable exception, LoggingLevel loggingLevel) {
        LoggingLevel oldLogLevel = getLevel();
        setLevel(loggingLevel);
        log(message, exception);
        setLevel(oldLogLevel);
    }   
    public void log(String message, Throwable exception) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message, exception);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message, exception);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message, exception);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message, exception);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message, exception);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message, exception);
            }
            break;
        case OFF:
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message, exception);
        }
    }
    protected Object logMessage(Exchange exchange) {
        return formatter.format(exchange);
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public void setFormatter(ExchangeFormatter formatter) {
        this.formatter = formatter;
    }
}
"
org.apache.camel.processor.LoggingErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An {@link ErrorHandler} which uses commons-logging to dump the error
 *
 * @version $Revision: 710133 $
 */
public class LoggingErrorHandler extends ErrorHandlerSupport {
    private Processor output;
    private Log log;
    private LoggingLevel level;
    public LoggingErrorHandler(Processor output) {
        this(output, LogFactory.getLog(LoggingErrorHandler.class), LoggingLevel.INFO);
    }
    public LoggingErrorHandler(Processor output, Log log, LoggingLevel level) {
        this.output = output;
        this.log = log;
        this.level = level;
    }
    @Override
    public String toString() {
        return ""LoggingErrorHandler["" + output + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Throwable error = null;
        try {
            output.process(exchange);
            // could also fail and set exception on the exchange itself
            if (exchange.getException() != null) {
                error = exchange.getException();
            }
        } catch (Throwable e) {
            error = e;
        }
        if (error != null) {
            if (!customProcessorForException(exchange, error)) {
                logError(exchange, error);
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void logError(Exchange exchange, Throwable e) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange, e), e);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange, e), e);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange, e), e);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange, e), e);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange, e), e);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange, e), e);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange, e),
                      e);
        }
    }
    protected Object logMessage(Exchange exchange, Throwable e) {
        return e + "" while processing exchange: "" + exchange;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(output);
    }
}
"
org.apache.camel.processor.LoggingErrorHandlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.commons.logging.Log;
/**
 * Exception throw inside Pipeline was not reported or handled when error
 * handler is LoggingErrorHandler. (CAMEL-792)
 */
public class LoggingErrorHandlerTest extends ContextTestSupport {
    private MyLog log = new MyLog();
    public void testLogException() {
        try {
            template.sendBody(""direct:in"", ""Hello World"");
        } catch (Exception e) {
            // expected
        }
        assertTrue(""Should have logged it"", log.logged);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // set to use our logger
                errorHandler(loggingErrorHandler(log));
                from(""direct:in"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        throw new IllegalArgumentException(""Hello World"");
                    }
                });
            }
        };
    }
    /**
     * Just implement the Log interface, dont wanna mess with easymock or the like at current time
     * for this simple test.
     */
    private class MyLog implements Log {
        boolean logged;
        public boolean isDebugEnabled() {
            return false;
        }
        public boolean isErrorEnabled() {
            return true;
        }
        public boolean isFatalEnabled() {
            return false;
        }
        public boolean isInfoEnabled() {
            return true;
        }
        public boolean isTraceEnabled() {
            return false;
        }
        public boolean isWarnEnabled() {
            return true;
        }
        public void trace(Object message) {
        }
        public void trace(Object message, Throwable t) {
        }
        public void debug(Object message) {
        }
        public void debug(Object message, Throwable t) {
        }
        public void info(Object message) {
        }
        public void info(Object message, Throwable t) {
        }
        public void warn(Object message) {
        }
        public void warn(Object message, Throwable t) {
        }
        public void error(Object message) {
        }
        public void error(Object message, Throwable t) {
            assertNotNull(t);
            assertNotNull(message);
            logged = true;
        }
        public void fatal(Object message) {
        }
        public void fatal(Object message, Throwable t) {
        }
    }
}
"
org.apache.camel.processor.LoopProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The processor which sends messages in a loop.
 *
 * @version $Revision: 699771 $
 */
public class LoopProcessor extends DelegateProcessor {
    public static final String PROP_ITER_COUNT = ""CamelIterationCount"";
    public static final String PROP_ITER_INDEX = ""CamelIterationIndex"";
    private static final Log LOG = LogFactory.getLog(LoopProcessor.class);
    private Expression<Exchange> expression;
    public LoopProcessor(Expression<Exchange> expression, Processor processor) {
        super(processor);
        this.expression = expression;
    }
    @Override
    public void process(Exchange exchange) throws Exception {
        // Intermediate conversion to String is needed when direct conversion to Integer is not available
        // but evaluation result is a textual representation of a numeric value.
        String text = ExchangeHelper.convertToType(exchange, String.class, expression.evaluate(exchange));
        Integer value = ExchangeHelper.convertToType(exchange, Integer.class, text);
        if (value == null) {
            // TODO: we should probably catch evaluate/convert exception an set is as fault (after fix for CAMEL-316)
            throw new RuntimeCamelException(""Expression \"""" + expression + ""\"" does not evaluate to an int."");
        }
        int count = value.intValue();
        exchange.setProperty(PROP_ITER_COUNT, count);
        for (int i = 0; i < count; i++) {
            LOG.debug(""LoopProcessor: iteration #"" + i);
            exchange.setProperty(PROP_ITER_INDEX, i);
            super.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Loop[for: "" + expression + "" times do: "" + getProcessor() + ""]"";
    }
    public Expression<Exchange> getExpression() {
        return expression;
    }
}
"
org.apache.camel.processor.LoopTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 699771 $
 */
public class LoopTest extends ContextTestSupport {
    MockEndpoint resultEndpoint;
    public void testCounterLoop() throws Exception {
        performLoopTest(""direct:a"", 8);
    }
    public void testExpressionLoop() throws Exception {
        performLoopTest(""direct:b"", 6);
    }
    public void testExpressionClauseLoop() throws Exception {
        performLoopTest(""direct:c"", 4);
    }
    public void testLoopAsBlock() throws Exception {
        MockEndpoint lastEndpoint = resolveMandatoryEndpoint(""mock:last"", MockEndpoint.class);
        lastEndpoint.expectedMessageCount(1);
        performLoopTest(""direct:d"", 2);
        lastEndpoint.assertIsSatisfied();
    }
    public void testLoopWithInvalidExpression() throws Exception {
        try {
            performLoopTest(""direct:b"", 4, ""invalid"");
            fail(""Exception expected for invalid expression"");
        } catch (RuntimeCamelException e) {
            // expected
        }
    }
    public void testLoopProperties() throws Exception {
        performLoopTest(""direct:e"", 10);
    }
    private void performLoopTest(String endpointUri, int expectedIterations, String header) throws InterruptedException {
        resultEndpoint.expectedMessageCount(expectedIterations);
        template.sendBodyAndHeader(endpointUri, ""<hello times='4'>world!</hello>"", ""loop"", header);
        resultEndpoint.assertIsSatisfied();
    }
    private void performLoopTest(String endpointUri, int expectedIterations) throws InterruptedException {
        performLoopTest(endpointUri, expectedIterations, ""6"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.reset();
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor loopTest = new LoopTestProcessor(10);
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex1
                from(""direct:a"").loop(8).to(""mock:result"");
                // END SNIPPET: ex1
                // START SNIPPET: ex2
                from(""direct:b"").loop(header(""loop"")).to(""mock:result"");
                // END SNIPPET: ex2
                // START SNIPPET: ex3
                from(""direct:c"").loop().xpath(""/hello/@times"").to(""mock:result"");
                // END SNIPPET: ex3
                // START SNIPPET: ex4
                from(""direct:d"").loop(2).to(""mock:result"").end().to(""mock:last"");
                // END SNIPPET: ex4
                // START SNIPPET: ex5
                from(""direct:e"").loop(10).process(loopTest).to(""mock:result"");
                // END SNIPPET: ex5
            }
        };
    }
}
"
org.apache.camel.processor.LoopTestProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
public class LoopTestProcessor implements Processor {
    private int count;
    private int index;
    public LoopTestProcessor() {
    }
    public LoopTestProcessor(int count) {
        setCount(count);
    }
    public void setCount(int count) {
        this.count = count;
        reset();
    }
    public void reset() {
        this.index = 0;
    }
    public void process(Exchange exchange) {
        Integer c = exchange.getProperty(LoopProcessor.PROP_ITER_COUNT, Integer.class);
        Integer i = exchange.getProperty(LoopProcessor.PROP_ITER_INDEX, Integer.class);
        if (c == null || c.intValue() != this.count) {
            exchange.setException(new CamelException(
                ""Invalid count value.  Expected "" + this.count + "" but was "" + c));
        }
        if (i == null || i.intValue() != this.index++) {
            exchange.setException(new CamelException(
                ""Invalid index value.  Expected "" + this.index + "" but was "" + i));
        }
    }
}
"
org.apache.camel.processor.MarshalProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.ByteArrayOutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.spi.DataFormat;
/**
 * Marshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 640438 $
 */
public class MarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public MarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Message in = exchange.getIn();
        Object body = in.getBody();
        // lets setup the out message before we invoke the dataFormat
        // so that it can mutate it if necessary
        Message out = exchange.getOut(true);
        out.copyFrom(in);
        dataFormat.marshal(exchange, body, buffer);
        byte[] data = buffer.toByteArray();
        out.setBody(data);
    }
}
"
org.apache.camel.processor.MethodFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Header;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 697361 $
 */
public class MethodFilterTest extends ContextTestSupport {
    public void testSendMatchingMessage() throws Exception {
        String body = ""<person name='James' city='London'/>"";
        getMockEndpoint(""mock:result"").expectedBodiesReceived(body);
        template.sendBodyAndHeader(""direct:start"", ExchangePattern.InOut, body, ""foo"", ""London"");
        assertMockEndpointsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        String body = ""<person name='Hiram' city='Tampa'/>"";
        getMockEndpoint(""mock:result"").expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ExchangePattern.InOut, body, ""foo"", ""Tampa"");
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").
                        filter().method(""myBean"", ""matches"").
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""myBean"", new MyBean());
        return context;
    }
    // START SNIPPET: filter
    public static class MyBean {
        public boolean matches(@Header(name = ""foo"")String location) {
            return ""London"".equals(location);
        }
    }
    // END SNIPPET: filter
}
"
org.apache.camel.processor.MultiCastAggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Header;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationStrategy;
public class MultiCastAggregatorTest extends ContextTestSupport {
    public void testMulticastReceivesItsOwnExchangeParallelly() throws Exception {
        sendingAMessageUsingMulticastReceivesItsOwnExchange(true);
    }
    public void testMulticastReceivesItsOwnExchangeSequentially() throws Exception {
        sendingAMessageUsingMulticastReceivesItsOwnExchange(false);
    }
    private void sendingAMessageUsingMulticastReceivesItsOwnExchange(boolean isParallel) throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(""inputx+inputy+inputz"");
        String url;
        if (isParallel) {
            url = ""direct:parallel"";
        } else {
            url = ""direct:sequential"";
        }
        // use InOut
        Exchange exchange = template.request(url, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""input"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertNotNull(""We should get result here"", exchange);
        assertEquals(""Can't get the right result"", ""inputx+inputy+inputz"", exchange.getOut().getBody(String.class));
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                ThreadPoolExecutor tpExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));
                // START SNIPPET: example
                // The message will be sent parallelly to the endpoints
                from(""direct:parallel"")
                    .multicast(new BodyOutAggregatingStrategy(), true).executor(tpExecutor)
                        .to(""direct:x"", ""direct:y"", ""direct:z"");
                // Multicast the message in a sequential way
                from(""direct:sequential"").multicast(new BodyOutAggregatingStrategy()).to(""direct:x"", ""direct:y"", ""direct:z"");
                from(""direct:x"").process(new AppendingProcessor(""x"")).to(""direct:aggregator"");
                from(""direct:y"").process(new AppendingProcessor(""y"")).to(""direct:aggregator"");
                from(""direct:z"").process(new AppendingProcessor(""z"")).to(""direct:aggregator"");
                from(""direct:aggregator"").aggregator(header(""cheese""), new BodyInAggregatingStrategy()).
                completedPredicate(header(Exchange.AGGREGATED_COUNT).isEqualTo(3)).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.MulticastProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.camel.util.concurrent.AtomicExchange;
import org.apache.camel.util.concurrent.CountingLatch;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements the Multicast pattern to send a message exchange to a number of
 * endpoints, each endpoint receiving a copy of the message exchange.
 *
 * @see Pipeline
 * @version $Revision: 727409 $
 */
public class MulticastProcessor extends ServiceSupport implements Processor {
    static class ProcessorExchangePair {
        private final Processor processor;
        private final Exchange exchange;
        public ProcessorExchangePair(Processor processor, Exchange exchange) {
            this.processor = processor;
            this.exchange = exchange;
        }
        public Processor getProcessor() {
            return processor;
        }
        public Exchange getExchange() {
            return exchange;
        }
    }
    private Collection<Processor> processors;
    private AggregationStrategy aggregationStrategy;
    private boolean isParallelProcessing;
    private ThreadPoolExecutor executor;
    private final boolean streaming;
    private final AtomicBoolean shutdown = new AtomicBoolean(true);
    public MulticastProcessor(Collection<Processor> processors) {
        this(processors, null);
    }
    public MulticastProcessor(Collection<Processor> processors, AggregationStrategy aggregationStrategy) {
        this(processors, aggregationStrategy, false, null);
    }
    public MulticastProcessor(Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor) {
        this(processors, aggregationStrategy, parallelProcessing, executor, false);
    }
    public MulticastProcessor(Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor, boolean streaming) {
        notNull(processors, ""processors"");
        this.processors = processors;
        this.aggregationStrategy = aggregationStrategy;
        this.isParallelProcessing = parallelProcessing;
        if (isParallelProcessing) {
            if (executor != null) {
                this.executor = executor;
            } else { 
                // setup default Executor
                this.executor = new ThreadPoolExecutor(processors.size(), processors.size(), 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(processors.size()));
            }
        }
        this.streaming = streaming;
    }
    /**
     * A helper method to convert a list of endpoints into a list of processors
     */
    public static <E extends Exchange> Collection<Processor> toProducers(Collection<Endpoint> endpoints)
        throws Exception {
        Collection<Processor> answer = new ArrayList<Processor>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint.createProducer());
        }
        return answer;
    }
    @Override
    public String toString() {
        return ""Multicast"" + getProcessors();
    }
    class ProcessCall implements Runnable {
        private final Exchange exchange;
        private final AsyncCallback callback;
        private final Processor processor;
        public ProcessCall(Exchange exchange, Processor processor, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
            this.processor = processor;
        }
        public void run() {
            if (shutdown.get()) {
                exchange.setException(new RejectedExecutionException());
                callback.done(false);
            } else {
                try {
                    processor.process(exchange);
                } catch (Exception ex) {
                    exchange.setException(ex);
                }
                callback.done(false);
            }
        }
    }
    public void process(Exchange exchange) throws Exception {
        final AtomicExchange result = new AtomicExchange();
        Iterable<ProcessorExchangePair> pairs = createProcessorExchangePairs(exchange);
        // Parallel Processing the producer
        if (isParallelProcessing) {
            List<Exchange> exchanges = new LinkedList<Exchange>();
            final CountingLatch completedExchanges = new CountingLatch();
            int i = 0;
            for (ProcessorExchangePair pair : pairs) {
                Processor producer = pair.getProcessor();
                final Exchange subExchange = pair.getExchange();
                updateNewExchange(subExchange, i, pairs);
                exchanges.add(subExchange);
                completedExchanges.increment(); 
                ProcessCall call = new ProcessCall(subExchange, producer, new AsyncCallback() {
                    public void done(boolean doneSynchronously) {
                        if (streaming && aggregationStrategy != null) {
                            doAggregate(result, subExchange);
                        }
                        completedExchanges.decrement();
                    }
                });
                executor.execute(call);
                i++;
            }
            completedExchanges.await();
            if (!streaming && aggregationStrategy != null) {
                for (Exchange resultExchange : exchanges) {
                    doAggregate(result, resultExchange);
                }
            }
        } else {
            // we call the producer one by one sequentially
            int i = 0;
            for (ProcessorExchangePair pair : pairs) {
                Processor producer = pair.getProcessor();
                Exchange subExchange = pair.getExchange();
                updateNewExchange(subExchange, i, pairs);
                try {
                    producer.process(subExchange);
                } catch (Exception exception) {
                    subExchange.setException(exception);
                }
                doAggregate(result, subExchange);
                i++;
            }
        }
        if (result.get() != null) {
            ExchangeHelper.copyResults(exchange, result.get());
        }
    }
    /**
     * Aggregate the {@link Exchange} with the current result
     *
     * @param result the current result
     * @param exchange the exchange to be added to the result
     */
    protected synchronized void doAggregate(AtomicExchange result, Exchange exchange) {
        if (aggregationStrategy != null) {
            if (result.get() == null) {
                result.set(exchange);
            } else {
                result.set(aggregationStrategy.aggregate(result.get(), exchange));
            }
        }
    }
    protected void updateNewExchange(Exchange exchange, int i, Iterable<ProcessorExchangePair> allPairs) {
        // No updates needed
    }
    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());
        Processor[] processorsArray = processors.toArray(new Processor[processors.size()]);
        for (int i = 0; i < processorsArray.length; i++) {
            result.add(new ProcessorExchangePair(processorsArray[i], exchange.copy()));
        }
        return result;
    }
    protected void doStop() throws Exception {
        shutdown.set(true);
        if (executor != null) {
            executor.shutdown();
            executor.awaitTermination(0, TimeUnit.SECONDS);
        }
        ServiceHelper.stopServices(processors);
    }
    protected void doStart() throws Exception {
        shutdown.set(false);
        if (executor != null) {
            executor.setRejectedExecutionHandler(new RejectedExecutionHandler() {
                public void rejectedExecution(Runnable runnable, ThreadPoolExecutor executor) {
                    ProcessCall call = (ProcessCall)runnable;
                    call.exchange.setException(new RejectedExecutionException());
                    call.callback.done(false);
                }
            });
        }
        ServiceHelper.startServices(processors);
    }
    /**
     * Is the multicast processor working in streaming mode?
     * 
     * In streaming mode:
     * <ul>
     * <li>we use {@link Iterable} to ensure we can send messages as soon as the data becomes available</li>
     * <li>for parallel processing, we start aggregating responses as they get send back to the processor;
     * this means the {@link org.apache.camel.processor.aggregate.AggregationStrategy} has to take care of handling out-of-order arrival of exchanges</li>
     * </ul>
     */
    protected boolean isStreaming() {
        return streaming;
    }
    /**
     * Returns the producers to multicast to
     */
    public Collection<Processor> getProcessors() {
        return processors;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
}
"
org.apache.camel.processor.MulticastStreamCachingTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.StringReader;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class MulticastStreamCachingTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendingAMessageUsingMulticastConvertsToReReadable() throws Exception {
        x.expectedBodiesReceived(""<input/>+output"");
        y.expectedBodiesReceived(""<input/>+output"");
        z.expectedBodiesReceived(""<input/>+output"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(new StreamSource(new StringReader(""<input/>"")));
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                // lets transform the IN message
                Message in = exchange.getIn();
                String body = in.getBody(String.class);
                in.setBody(body + ""+output"");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                //stream caching should fix re-readability issues when multicasting messags
                from(""direct:a"").multicast().to(""direct:x"", ""direct:y"", ""direct:z"");
                from(""direct:x"").process(processor).to(""mock:x"");
                from(""direct:y"").process(processor).to(""mock:y"");
                from(""direct:z"").process(processor).to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.MulticastTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class MulticastTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        x.expectedBodiesReceived(""input+output"");
        y.expectedBodiesReceived(""input+output"");
        z.expectedBodiesReceived(""input+output"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""input"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new AppendingProcessor();
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").multicast().to(""direct:x"", ""direct:y"", ""direct:z"");
                // END SNIPPET: example
                from(""direct:x"").process(processor).to(""mock:x"");
                from(""direct:y"").process(processor).to(""mock:y"");
                from(""direct:z"").process(processor).to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.MultiErrorHandlerInRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test with multi route specific error handlers
 */
public class MultiErrorHandlerInRouteTest extends ContextTestSupport {
    private MyProcessor outer = new MyProcessor();
    private MyProcessor inner = new MyProcessor();
    public void testNoErrors() throws Exception {
        outer.setName(""Claus"");
        inner.setName(""James"");
        MockEndpoint mock = getMockEndpoint(""mock:end"");
        mock.expectedHeaderReceived(""name"", ""James"");
        template.sendBody(""direct:start"", ""Hello World"");
        assertMockEndpointsSatisfied();
    }
    public void testOuterError() throws Exception {
        outer.setName(""Error"");
        inner.setName(""James"");
        MockEndpoint mock = getMockEndpoint(""mock:outer"");
        mock.expectedMessageCount(1);
        try {
            template.sendBody(""direct:start"", ""Hello World"");
            fail(""Should have thrown a IllegalArgumentException"");
        } catch (RuntimeCamelException e) {
            assertTrue(e.getCause() instanceof IllegalArgumentException);
            assertEquals(""Forced exception by unit test"", e.getCause().getMessage());
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    public void testInnerError() throws Exception {
        outer.setName(""Claus"");
        inner.setName(""Error"");
        MockEndpoint mock = getMockEndpoint(""mock:inner"");
        mock.expectedHeaderReceived(""name"", ""Claus"");
        mock.expectedMessageCount(1);
        try {
            template.sendBody(""direct:start"", ""Hello World"");
            fail(""Should have thrown a IllegalArgumentException"");
        } catch (RuntimeCamelException e) {
            assertTrue(e.getCause() instanceof IllegalArgumentException);
            assertEquals(""Forced exception by unit test"", e.getCause().getMessage());
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"")
                    .errorHandler(deadLetterChannel(""mock:outer"").maximumRedeliveries(1))
                    .process(outer)
                    .to(""direct:outer"");
                from(""direct:outer"")
                    .errorHandler(deadLetterChannel(""mock:inner"").maximumRedeliveries(2))
                    .process(inner)
                    .to(""mock:end"");
            }
        };
    }
    private class MyProcessor implements Processor {
        private String name;
        public void process(Exchange exchange) throws Exception {
            if (name.equals(""Error"")) {
                throw new IllegalArgumentException(""Forced exception by unit test"");
            }
            exchange.getIn().setHeader(""name"", name);
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}
"
org.apache.camel.processor.MyAggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Header;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * @version $Revision: 689325 $
*/
public class MyAggregationStrategy extends UseLatestAggregationStrategy {
    @Override
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Exchange result = super.aggregate(oldExchange, newExchange);
        Integer old = (Integer) oldExchange.getProperty(""aggregated"");
        if (old == null) {
            old = 1;
        }
        result.setProperty(""aggregated"", old + 1);
        return result;
    }
    /**
     * An expression used to determine if the aggregation is complete
     */
    public boolean isCompleted(@Header(name = ""aggregated"")
                               Integer aggregated) {
        if (aggregated == null) {
            return false;
        }
        return aggregated == 5;
    }
}
"
org.apache.camel.processor.MyNormalizer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.language.XPath;
// START SNIPPET: example   
public class MyNormalizer {
    public void employeeToPerson(Exchange exchange, @XPath(""/employee/name/text()"") String name) {
        exchange.getOut().setBody(createPerson(name));            
    }
    public void customerToPerson(Exchange exchange, @XPath(""/customer/@name"") String name) {
        exchange.getOut().setBody(createPerson(name));
    }        
    private String createPerson(String name) {
        return ""<person name=\"""" + name + ""\""/>"";
    }
}    
// END SNIPPET: example   
"
org.apache.camel.processor.MyValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
/**
 * @version $Revision: 630568 $
 */
public class MyValidator implements Processor {
    public void process(Exchange exchange) throws Exception {
        Object value = exchange.getIn().getHeader(""foo"");
        if (value == null || !value.equals(""bar"")) {
            throw new ValidationException(exchange, ""The foo header does not equal bar! Was: "" + value);
        }
    }
}
"
org.apache.camel.processor.NormalizerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.language.XPath;
import org.apache.camel.util.jndi.JndiContext;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
public class NormalizerTest extends ContextTestSupport {
    protected MockEndpoint result;
    protected MyNormalizer myNormalizer = new MyNormalizer();
    public void testSendToFirstWhen() throws Exception {
        String employeeBody1 = ""<employee><name>Jon</name></employee>"";
        String employeeBody2 = ""<employee><name>Hadrian</name></employee>"";
        String employeeBody3 = ""<employee><name>Claus</name></employee>"";        
        String customerBody = ""<customer name=\""James\""/>"";
        // expect only one person named Jon
        result.expectedMessageCount(1);
        result.expectedBodiesReceived(""<person name=\""Jon\""/>"");
        template.sendBody(""direct:start"", employeeBody1);
        template.sendBody(""direct:start"", employeeBody2);
        template.sendBody(""direct:start"", employeeBody3);        
        template.sendBody(""direct:start"", customerBody);        
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        result = getMockEndpoint(""mock:result"");
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""normalizer"", myNormalizer);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example                
                // before we can filter, we need to normalize the incoming messages
                from(""direct:start"").choice()
                  .when().xpath(""/employee"").to(""bean:normalizer?method=employeeToPerson"").to(""seda:queue"")
                  .when().xpath(""/customer"").to(""bean:normalizer?method=customerToPerson"").to(""seda:queue"");
                // filter the normalized messages
                from(""seda:queue"").filter().xpath(""/person[@name='Jon']"").to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.Pipeline,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Creates a Pipeline pattern where the output of the previous step is sent as
 * input to the next step, reusing the same message exchanges
 *
 * @version $Revision: 706857 $
 */
public class Pipeline extends MulticastProcessor implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(Pipeline.class);
    public Pipeline(Collection<Processor> processors) {
        super(processors);
    }
    public static Processor newInstance(List<Processor> processors) {
        if (processors.isEmpty()) {
            return null;
        } else if (processors.size() == 1) {
            return processors.get(0);
        }
        return new Pipeline(processors);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange original, AsyncCallback callback) {
        Iterator<Processor> processors = getProcessors().iterator();
        Exchange nextExchange = original;
        boolean first = true;
        while (true) {
            boolean exceptionHandled = hasExceptionBeenHandled(nextExchange);
            if (nextExchange.isFailed() || exceptionHandled) {
                // The Exchange.EXCEPTION_HANDLED_PROPERTY property is only set if satisfactory handling was done 
                //  by the error handler.  It's still an exception, the exchange still failed.
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Message exchange has failed so breaking out of pipeline: "" + nextExchange
                              + "" exception: "" + nextExchange.getException() + "" fault: ""
                              + nextExchange.getFault(false)
                              + (exceptionHandled ? "" handled by the error handler"" : """"));
                }
                break;
            }
            if (!processors.hasNext()) {
                break;
            }
            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
            if (first) {
                first = false;
            } else {
                nextExchange = createNextExchange(processor, nextExchange);
            }
            boolean sync = process(original, nextExchange, callback, processors, processor);
            // Continue processing the pipeline synchronously ...
            if (!sync) {
                // The pipeline will be completed async...
                return false;
            }
        }
        // If we get here then the pipeline was processed entirely
        // synchronously.
        if (LOG.isTraceEnabled()) {
            // logging nextExchange as it contains the exchange that might have altered the payload and since
            // we are logging the completion if will be confusing if we log the original instead
            // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots
            LOG.trace(""Processing compelete for exchangeId: "" + original.getExchangeId() + "" >>> "" + nextExchange);
        }
        ExchangeHelper.copyResults(original, nextExchange);
        callback.done(true);
        return true;
    }
    private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, AsyncProcessor processor) {
        if (LOG.isTraceEnabled()) {
            // this does the actual processing so log at trace level
            LOG.trace(""Processing exchangeId: "" + exchange.getExchangeId() + "" >>> "" + exchange);
        }
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                // We only have to handle async completion of the pipeline..
                if (sync) {
                    return;
                }
                // Continue processing the pipeline...
                Exchange nextExchange = exchange;
                while (processors.hasNext()) {
                    AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
                    boolean exceptionHandled = hasExceptionBeenHandled(nextExchange);
                    if (nextExchange.isFailed() || exceptionHandled) {
                        // The Exchange.EXCEPTION_HANDLED_PROPERTY property is only set if satisfactory handling was done
                        //  by the error handler.  It's still an exception, the exchange still failed.
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Message exchange has failed so breaking out of pipeline: "" + nextExchange
                                      + "" exception: "" + nextExchange.getException() + "" fault: ""
                                      + nextExchange.getFault(false)
                                      + (exceptionHandled ? "" handled by the error handler"" : """"));
                        }
                        break;
                    }
                    nextExchange = createNextExchange(processor, nextExchange);
                    sync = process(original, nextExchange, callback, processors, processor);
                    if (!sync) {
                        return;
                    }
                }
                ExchangeHelper.copyResults(original, nextExchange);
                callback.done(false);
            }
        });
    }
    private static boolean hasExceptionBeenHandled(Exchange nextExchange) {
        return Boolean.TRUE.equals(nextExchange.getProperty(Exchange.EXCEPTION_HANDLED_PROPERTY));
    }
    /**
     * Strategy method to create the next exchange from the previous exchange.
     * <p/>
     * Remember to copy the original exchange id otherwise correlation of ids in the log is a problem
     *
     * @param producer         the producer used to send to the endpoint
     * @param previousExchange the previous exchange
     * @return a new exchange
     */
    protected Exchange createNextExchange(Processor producer, Exchange previousExchange) {
        Exchange answer = previousExchange.newInstance();
        // we must use the same id as this is a snapshot strategy where Camel copies a snapshot
        // before processing the next step in the pipeline, so we have a snapshot of the exchange
        // just before. This snapshot is used if Camel should do redeliveries (re try) using
        // DeadLetterChannel. That is why it's important the id is the same, as it is the *same*
        // exchange being routed.
        answer.setExchangeId(previousExchange.getExchangeId());
        answer.getProperties().putAll(previousExchange.getProperties());
        // now lets set the input of the next exchange to the output of the
        // previous message if it is not null
        Message previousOut = previousExchange.getOut(false);
        Message in = answer.getIn();
        if (previousOut != null) {
            in.copyFrom(previousOut);
        } else {
            in.copyFrom(previousExchange.getIn());
        }
        return answer;
    }
    @Override
    public String toString() {
        return ""Pipeline"" + getProcessors();
    }
}
"
org.apache.camel.processor.PipelineConcurrentTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Random;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
/**
 * Unit test the pipeline in concurrent conditions.
 */
public class PipelineConcurrentTest extends ContextTestSupport {
    public void testConcurrentPipeline() throws Exception {
        int total = 10000;
        final int group = total / 20;
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(total);
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.afterPropertiesSet();
        for (int i = 0; i < 20; i++) {
            final int threadCount = i;
            executor.execute(new Runnable() {
                public void run() {
                    int start = threadCount * group;
                    for (int i = 0; i < group; i++) {
                        try {
                            // do some random sleep to simulate spread in user activity
                            Thread.sleep(new Random().nextInt(10));
                        } catch (InterruptedException e) {
                            // ignore
                        }
                        template.sendBody(""seda:in?size=10000"", """" + (start + i));
                    }
                }
            });
        }
        mock.assertIsSatisfied();
        mock.expectsNoDuplicates(body());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // to force any exceptions coming forward imeddiately
                errorHandler(noErrorHandler());
                from(""seda:in?size=10000"")
                    .thread(10)
                    .pipeline(""direct:do"", ""mock:result"");
                from(""direct:do"")
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            String body = exchange.getIn().getBody(String.class);
                            exchange.getOut().setBody(""Bye "" + body);
                        }
                    });
            }
        };
    }
}
"
org.apache.camel.processor.PipelineMEPTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for pipeline keeping the MEP (CAMEL-1233)
 *
 * @version $Revision: 733651 $
 */
public class PipelineMEPTest extends ContextTestSupport {
    public void testInOnly() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(3);
        Exchange exchange = context.getEndpoint(""direct:a"").createExchange(ExchangePattern.InOnly);
        exchange.getIn().setBody(1);
        Exchange out = template.send(""direct:a"", exchange);
        assertNotNull(out);
        assertEquals(ExchangePattern.InOnly, out.getPattern());
        assertMockEndpointsSatisfied();
        // should keep MEP as InOnly
        assertEquals(ExchangePattern.InOnly, mock.getExchanges().get(0).getPattern());
    }
    public void testInOut() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(3);
        Exchange exchange = context.getEndpoint(""direct:a"").createExchange(ExchangePattern.InOut);
        exchange.getIn().setBody(1);
        Exchange out = template.send(""direct:a"", exchange);
        assertNotNull(out);
        assertEquals(ExchangePattern.InOut, out.getPattern());
        assertMockEndpointsSatisfied();
        // should keep MEP as InOut
        assertEquals(ExchangePattern.InOut, mock.getExchanges().get(0).getPattern());
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor inProcessor = new Processor() {
            public void process(Exchange exchange) {
                Integer number = exchange.getIn().getBody(Integer.class);
                if (number == null) {
                    number = 0;
                }
                number = number + 1;
                exchange.getIn().setBody(number);
            }
        };
        final Processor outProcessor = new Processor() {
            public void process(Exchange exchange) {
                Integer number = exchange.getIn().getBody(Integer.class);
                if (number == null) {
                    number = 0;
                }
                number = number + 1;
                // this is a bit evil we let you set on OUT body even if the MEP is InOnly
                // however the result after the routing is correct using APIs to get the result
                // however the exchange will carry body IN and OUT when the route completes, as
                // we operate on the original exchange in this processor
                // (= we are the first node in the route after the from conumer)
                exchange.getOut().setBody(number);
            }
        };
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"")
                        .process(outProcessor)
                        // this pipeline is not really needed by to have some more routing in there to test with
                        .pipeline(""direct:x"", ""direct:y"")
                        .process(inProcessor)
                        .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.PipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 732393 $
 */
public class PipelineTest extends ContextTestSupport {
    /**
     * Simple processor the copies the in to the out and increments a counter.
     * Used to verify that the pipeline actually takes the output of one stage of 
     * the pipe and feeds it in as input into the next stage.
     */
    private final class InToOut implements Processor {
        public void process(Exchange exchange) throws Exception {            
            exchange.getOut(true).copyFrom(exchange.getIn());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getOut().setHeader(""copy-counter"", counter + 1);
        }
    }
    /**
     * Simple processor the copies the in to the fault and increments a counter.
     */
    private final class InToFault implements Processor {
        public void process(Exchange exchange) throws Exception {
            exchange.getFault(true).setBody(exchange.getIn().getBody());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getFault().setHeader(""copy-counter"", counter + 1);
        }
    }
    protected MockEndpoint resultEndpoint;
    public void testSendMessageThroughAPipeline() throws Exception {
        resultEndpoint.expectedBodiesReceived(4);
        Exchange results = template.request(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertEquals(""Result body"", 4, results.getOut().getBody());
    }
    public void testResultsReturned() throws Exception {
        Exchange exchange = template.request(""direct:b"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Hello World"");
            }
        });
        assertEquals(""Hello World"", exchange.getOut().getBody());
        assertEquals(3, exchange.getOut().getHeader(""copy-counter""));        
    }
    /**
     * Disabled for now until we figure out fault processing in the pipeline.
     * 
     * @throws Exception
     */
    public void testFaultStopsPipeline() throws Exception {
        Exchange exchange = template.request(""direct:c"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Fault Message"");
            }
        });
        // Check the fault..
        assertEquals(""Fault Message"", exchange.getFault().getBody());
        assertEquals(2, exchange.getFault().getHeader(""copy-counter""));        
        // Check the out Message.. It should have only been processed once.
        // since the fault should stop it from going to the next process.
        assertEquals(1, exchange.getOut().getHeader(""copy-counter""));                
    }
    public void testOnlyProperties() {
        Exchange exchange = template.request(""direct:b"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setHeader(""header"", ""headerValue"");
            }
        });
        assertEquals(""headerValue"", exchange.getOut().getHeader(""header""));
        assertEquals(3, exchange.getOut().getHeader(""copy-counter""));  
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                Integer number = exchange.getIn().getBody(Integer.class);
                if (number == null) {
                    number = 0;
                }
                number = number + 1;
                exchange.getOut().setBody(number);
            }
        };
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").pipeline(""direct:x"", ""direct:y"", ""direct:z"", ""mock:result"");
                // END SNIPPET: example
                from(""direct:x"").process(processor);
                from(""direct:y"").process(processor);
                from(""direct:z"").process(processor);
                // Create a route that uses the  InToOut processor 3 times. the copy-counter header should be == 3
                from(""direct:b"").process(new InToOut()).process(new InToOut()).process(new InToOut());
                // Create a route that uses the  InToFault processor.. the last InToOut will not be called since the Fault occurs before.
                from(""direct:c"").process(new InToOut()).process(new InToFault()).process(new InToOut());
            }
        };
    }
}
"
org.apache.camel.processor.ProceedProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A {@link Processor} which proceeds on an {@link Interceptor}
 *
 * @version $Revision: 640438 $
 */
public class ProceedProcessor implements Processor {
    private final Interceptor interceptor;
    public ProceedProcessor(Interceptor interceptor) {
        this.interceptor = interceptor;
    }
    public String toString() {
        return ""Proceed["" + interceptor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        interceptor.proceed(exchange);
    }
}
"
org.apache.camel.processor.RecipientList,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ProducerCache;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a>
 * pattern where the list of actual endpoints to send a message exchange to are
 * dependent on some dynamic expression.
 *
 * @version $Revision: 734353 $
 */
public class RecipientList extends ServiceSupport implements Processor {
    private final Expression<Exchange> expression;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();
    public RecipientList(Expression<Exchange> expression) {
        notNull(expression, ""expression"");
        this.expression = expression;
    }
    @Override
    public String toString() {
        return ""RecipientList["" + expression + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object receipientList = expression.evaluate(exchange);
        sendToRecipientList(exchange, receipientList);
    }
    /**
     * Sends the given exchange to the recipient list
     */
    public void sendToRecipientList(Exchange exchange, Object receipientList) throws Exception {
        Iterator iter = ObjectHelper.createIterator(receipientList);
        List<Processor> processors = new ArrayList<Processor>();
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, recipient);
            Producer<Exchange> producer = producerCache.getProducer(endpoint);
            processors.add(producer);
        }
        MulticastProcessor mp = new MulticastProcessor(processors, new UseLatestAggregationStrategy());
        mp.process(exchange);
    }
    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        // trim strings as end users might have added spaces between separators
        if (recipient instanceof String) {
            recipient = ((String)recipient).trim();
        }
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.processor.RecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class RecipientListTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(""answer"");
        y.expectedBodiesReceived(""answer"");
        z.expectedBodiesReceived(""answer"");
        sendBody();
        assertMockEndpointsSatisfied();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ""answer"", ""recipientListHeader"",
                ""mock:x,mock:y,mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").recipientList(
                        header(""recipientListHeader"").tokenize("",""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.RecipientListWithArrayHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class RecipientListWithArrayHeaderTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(""answer"");
        y.expectedBodiesReceived(""answer"");
        z.expectedBodiesReceived(""answer"");
        sendBody();
        assertMockEndpointsSatisfied();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ""answer"", ""recipientListHeader"",
                new String[] {""mock:x"", ""mock:y"", ""mock:z""});
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").recipientList(header(""recipientListHeader""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.RecipientListWithStringDelimitedHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 734609 $
 */
public class RecipientListWithStringDelimitedHeaderTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(""answer"");
        y.expectedBodiesReceived(""answer"");
        z.expectedBodiesReceived(""answer"");
        sendBody();
        assertMockEndpointsSatisfied();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ""answer"", ""myHeader"", ""mock:x, mock:y, mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").recipientList(header(""myHeader""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.RedeliveryPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import java.util.Random;
import org.apache.camel.model.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
// Code taken from the ActiveMQ codebase
/**
 * The policy used to decide how many times to redeliver and the time between
 * the redeliveries before being sent to a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 * <p>
 * The default values are:
 * <ul>
 *   <li>maximumRedeliveries = 5</li>
 *   <li>delay = 1000L (the initial delay)</li>
 *   <li>maximumRedeliveryDelay = 60 * 1000L</li>
 *   <li>backOffMultiplier = 2</li>
 *   <li>useExponentialBackOff = false</li>
 *   <li>collisionAvoidanceFactor = 0.15d</li>
 *   <li>useCollisionAvoidance = false</li>
 *   <li>retriesExhaustedLogLevel = LoggingLevel.ERROR</li>
 *   <li>retryAttemptedLogLevel = LoggingLevel.ERROR</li>
 * </ul>
 * <p/>
 * Setting the maximumRedeliveries to a negative value such as -1 will then always redeliver (unlimited).
 * Setting the maximumRedeliveries to 0 will disable redelivery.
 *
 * @version $Revision: 710133 $
 */
public class RedeliveryPolicy extends DelayPolicy {
    protected static transient Random randomNumberGenerator;
    private static final transient Log LOG = LogFactory.getLog(RedeliveryPolicy.class);
    protected int maximumRedeliveries = 5;
    protected long maximumRedeliveryDelay = 60 * 1000L;
    protected double backOffMultiplier = 2;
    protected boolean useExponentialBackOff;
    // +/-15% for a 30% spread -cgs
    protected double collisionAvoidanceFactor = 0.15d;
    protected boolean useCollisionAvoidance;
    protected LoggingLevel retriesExhaustedLogLevel = LoggingLevel.ERROR;
    protected LoggingLevel retryAttemptedLogLevel = LoggingLevel.ERROR;
    public RedeliveryPolicy() {
    }
    @Override
    public String toString() {
        return ""RedeliveryPolicy[maximumRedeliveries="" + maximumRedeliveries
            + "", initialRedeliveryDelay="" + delay
            + "", maximumRedeliveryDelay="" + maximumRedeliveryDelay
            + "", retriesExhaustedLogLevel="" + retriesExhaustedLogLevel
            + "", retryAttemptedLogLevel="" + retryAttemptedLogLevel
            + "", useExponentialBackOff=""  + useExponentialBackOff
            + "", backOffMultiplier="" + backOffMultiplier
            + "", useCollisionAvoidance="" + useCollisionAvoidance
            + "", collisionAvoidanceFactor="" + collisionAvoidanceFactor + ""]"";
    }
    public RedeliveryPolicy copy() {
        try {
            return (RedeliveryPolicy)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(""Could not clone: "" + e, e);
        }
    }
    /**
     * Returns true if the policy decides that the message exchange should be
     * redelivered
     */
    public boolean shouldRedeliver(int redeliveryCounter) {
        if (getMaximumRedeliveries() < 0) {
            return true;
        }
        // redeliver until we hit the max
        return redeliveryCounter <= getMaximumRedeliveries();
    }
    /**
     * Calculates the new redelivery delay based on the last one then sleeps for the necessary amount of time
     */
    public long sleep(long redeliveryDelay) {
        redeliveryDelay = getRedeliveryDelay(redeliveryDelay);
        if (redeliveryDelay > 0) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Sleeping for: "" + redeliveryDelay + "" millis until attempting redelivery"");
            }
            try {
                Thread.sleep(redeliveryDelay);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Thread interrupted: "" + e, e);
                }
            }
        }
        return redeliveryDelay;
    }
    public long getRedeliveryDelay(long previousDelay) {
        long redeliveryDelay;
        if (previousDelay == 0) {
            redeliveryDelay = delay;
        } else if (useExponentialBackOff && backOffMultiplier > 1) {
            redeliveryDelay = Math.round(backOffMultiplier * previousDelay);
        } else {
            redeliveryDelay = previousDelay;
        }
        if (useCollisionAvoidance) {
            /*
             * First random determines +/-, second random determines how far to
             * go in that direction. -cgs
             */
            Random random = getRandomNumberGenerator();
            double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor)
                              * random.nextDouble();
            redeliveryDelay += redeliveryDelay * variance;
        }
        if (maximumRedeliveryDelay > 0 && redeliveryDelay > maximumRedeliveryDelay) {
            redeliveryDelay = maximumRedeliveryDelay;
        }
        return redeliveryDelay;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     *
     * @deprecated use delay. Will be removed in Camel 2.0.
     */
    public RedeliveryPolicy initialRedeliveryDelay(long initialRedeliveryDelay) {
        setDelay(initialRedeliveryDelay);
        return this;
    }
    /**
     * Enables collision avoidance which adds some randomization to the backoff
     * timings to reduce contention probability
     */
    public RedeliveryPolicy useCollisionAvoidance() {
        setUseCollisionAvoidance(true);
        return this;
    }
    /**
     * Enables exponential backoff using the {@link #getBackOffMultiplier()} to
     * increase the time between retries
     */
    public RedeliveryPolicy useExponentialBackOff() {
        setUseExponentialBackOff(true);
        return this;
    }
    /**
     * Enables exponential backoff and sets the multiplier used to increase the
     * delay between redeliveries
     */
    public RedeliveryPolicy backOffMultiplier(double multiplier) {
        useExponentialBackOff();
        setBackOffMultiplier(multiplier);
        return this;
    }
    /**
     * Enables collision avoidance and sets the percentage used
     */
    public RedeliveryPolicy collisionAvoidancePercent(double collisionAvoidancePercent) {
        useCollisionAvoidance();
        setCollisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    /**
     * Sets the maximum redelivery delay if using exponential back off.
     * Use -1 if you wish to have no maximum
     */
    public RedeliveryPolicy maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    /**
     * Sets the logging level to use for log messages when retries have been exhausted.
     */
    public RedeliveryPolicy retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        return this;
    }    
    /**
     * Sets the logging level to use for log messages when retries are attempted.
     */    
    public RedeliveryPolicy retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        return this;
    }    
    // Properties
    // -------------------------------------------------------------------------
    public double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    /**
     * Sets the multiplier used to increase the delay between redeliveries if
     * {@link #setUseExponentialBackOff(boolean)} is enabled
     */
    public void setBackOffMultiplier(double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public short getCollisionAvoidancePercent() {
        return (short)Math.round(collisionAvoidanceFactor * 100);
    }
    /**
     * Sets the percentage used for collision avoidance if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidancePercent(double collisionAvoidancePercent) {
        this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d;
    }
    public double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    /**
     * Sets the factor used for collision avoidance if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    /**
     * @deprecated  use delay instead. Will be removed in Camel 2.0.
     */
    public long getInitialRedeliveryDelay() {
        return getDelay();
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     *
     * @deprecated use delay instead. Will be removed in Camel 2.0.
     */
    public void setInitialRedeliveryDelay(long initialRedeliveryDelay) {
        setDelay(initialRedeliveryDelay);
    }
    public int getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    /**
     * Sets the maximum number of times a message exchange will be redelivered.
     * Setting a negative value will retry forever.
     */
    public void setMaximumRedeliveries(int maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public long getMaximumRedeliveryDelay() {
        return maximumRedeliveryDelay;
    }
    /**
     * Sets the maximum redelivery delay if using exponential back off.
     * Use -1 if you wish to have no maximum
     */
    public void setMaximumRedeliveryDelay(long maximumRedeliveryDelay) {
        this.maximumRedeliveryDelay = maximumRedeliveryDelay;
    }
    public boolean isUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    /**
     * Enables/disables collision avoidance which adds some randomization to the
     * backoff timings to reduce contention probability
     */
    public void setUseCollisionAvoidance(boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public boolean isUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    /**
     * Enables/disables exponential backoff using the
     * {@link #getBackOffMultiplier()} to increase the time between retries
     */
    public void setUseExponentialBackOff(boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
    protected static synchronized Random getRandomNumberGenerator() {
        if (randomNumberGenerator == null) {
            randomNumberGenerator = new Random();
        }
        return randomNumberGenerator;
    }
    /**
     * Sets the logging level to use for log messages when retries have been exhausted.
     */    
    public void setRetriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        this.retriesExhaustedLogLevel = retriesExhaustedLogLevel;        
    }
    public LoggingLevel getRetriesExhaustedLogLevel() {
        return retriesExhaustedLogLevel;
    }
    /**
     * Sets the logging level to use for log messages when retries are attempted.
     */    
    public void setRetryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        this.retryAttemptedLogLevel = retryAttemptedLogLevel;
    }
    public LoggingLevel getRetryAttemptedLogLevel() {
        return retryAttemptedLogLevel;
    }
}
"
org.apache.camel.processor.RedeliveryPolicyPerExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 689379 $
 */
public class RedeliveryPolicyPerExceptionTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    public void testUsingCustomExceptionHandlerAndOneRedelivery() throws Exception {
        a.expectedMessageCount(1);
        sendBody(""direct:start"", ""a"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = a.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 2);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, true);
    }
    public void testUsingCustomExceptionHandlerWithNoRedeliveries() throws Exception {
        b.expectedMessageCount(1);
        sendBody(""direct:start"", ""b"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = b.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 0);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, false);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                if (""b"".equals(exchange.getIn().getBody())) {
                    throw new NullPointerException(""MyCustomException"");
                } else {
                    throw new IllegalArgumentException(""MyCustomException"");
                }
            }
        };
        return new RouteBuilder() {
            public void configure() {
                exception(IllegalArgumentException.class).maximumRedeliveries(2).to(""mock:a"");
                exception(NullPointerException.class).to(""mock:b"");
                from(""direct:start"").process(processor);
            }
        };
    }
}
"
org.apache.camel.processor.RemoveHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class RemoveHeaderTest extends ContextTestSupport {
    private MockEndpoint end;
    private MockEndpoint mid;
    private String headerName = ""foo"";
    private String expectedHeaderValue = ""bar"";
    public void testSetHeaderMidRouteThenRemove() throws Exception {
        mid.expectedMessageCount(1);
        end.expectedMessageCount(1);
        template.sendBody(""direct:start"", ""<blah/>"");
        // make sure we got the message
        assertMockEndpointsSatisfied();
        List<Exchange> midExchanges = mid.getExchanges();
        Exchange midExchange = midExchanges.get(0);
        String actualHeaderValue = midExchange.getIn().getHeader(headerName, String.class);
        assertEquals(expectedHeaderValue, actualHeaderValue);
        List<Exchange> endExchanges = end.getExchanges();
        Exchange endExchange = endExchanges.get(0);
        // header should be removed
        assertNull(endExchange.getIn().getHeader(headerName, String.class));        
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        end = getMockEndpoint(""mock:end"");
        mid = getMockEndpoint(""mock:mid"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                    setHeader(headerName).constant(expectedHeaderValue).to(""mock:mid"").
                    removeHeader(headerName).to(""mock:end"");
            }
        };
    }
}
"
org.apache.camel.processor.RemovePropertyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class RemovePropertyTest extends ContextTestSupport {
    private MockEndpoint end;
    private MockEndpoint mid;
    private String propertyName = ""foo"";
    private String expectedPropertyValue = ""bar"";
    public void testSetExchangePropertyMidRouteThenRemove() throws Exception {
        mid.expectedMessageCount(1);
        end.expectedMessageCount(1);
        template.sendBody(""direct:start"", ""<blah/>"");
        // make sure we got the message
        assertMockEndpointsSatisfied();
        List<Exchange> midExchanges = mid.getExchanges();
        Exchange midExchange = midExchanges.get(0);
        String actualPropertyValue = midExchange.getProperty(propertyName, String.class);
        assertEquals(expectedPropertyValue, actualPropertyValue);
        List<Exchange> endExchanges = end.getExchanges();
        Exchange endExchange = endExchanges.get(0);
        // property should be removed
        assertNull(endExchange.getProperty(propertyName, String.class));
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        end = getMockEndpoint(""mock:end"");
        mid = getMockEndpoint(""mock:mid"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                    setProperty(propertyName).constant(expectedPropertyValue).to(""mock:mid"").
                    removeProperty(propertyName).to(""mock:end"");
            }
        };
    }
}
"
org.apache.camel.processor.Resequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ExpressionListComparator;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
 * which can reorder messages within a batch.
 *
 * @version $Revision: 724629 $
 */
public class Resequencer extends BatchProcessor {
    public Resequencer(Processor processor, Expression expression) {
        this(processor, createSet(expression));
    }
    public Resequencer(Processor processor, List<Expression> expressions) {
        this(processor, createSet(expressions));
    }
    public Resequencer(Processor processor, Set<Exchange> collection) {
        super(processor, collection);
    }
    @Override
    public String toString() {
        return ""Resequencer[to: "" + getProcessor() + ""]"";
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected static Set<Exchange> createSet(Expression<Exchange> expression) {
        return createSet(new ExpressionComparator<Exchange>(expression));
    }
    protected static Set<Exchange> createSet(List<Expression> expressions) {
        if (expressions.size() == 1) {
            return createSet(expressions.get(0));
        }
        return createSet(new ExpressionListComparator(expressions));
    }
    protected static Set<Exchange> createSet(Comparator<? super Exchange> comparator) {
        return new TreeSet<Exchange>(comparator);
    }
}
"
org.apache.camel.processor.ResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.management.InstrumentationProcessor;
import org.apache.camel.management.JmxSystemPropertyKeys;
/**
 * @version $Revision: 697732 $
 */
public class ResequencerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Guillaume"", ""Hiram"", ""James"", ""Rob"");
        sendBodies(""direct:start"", ""Rob"", ""Hiram"", ""Guillaume"", ""James"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    @Override 
    protected void tearDown() throws Exception {
        super.tearDown();
        System.clearProperty(JmxSystemPropertyKeys.DISABLED);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(body()).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    public void testBatchResequencerTypeWithJmx() throws Exception {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""true"");
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
    }
    public void testBatchResequencerTypeWithoutJmx() throws Exception {
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        EventDrivenConsumerRoute consumerRoute =
            assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        DeadLetterChannel deadLetterChannel =
            assertIsInstanceOf(DeadLetterChannel.class, processor);
        Processor outputProcessor = deadLetterChannel.getOutput();
        InstrumentationProcessor interceptor =
                assertIsInstanceOf(InstrumentationProcessor.class, outputProcessor);
        outputProcessor = interceptor.getProcessor();
        assertIsInstanceOf(Resequencer.class, outputProcessor);
    }
}
"
org.apache.camel.processor.RoutingSlip,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ProducerCache;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.RoutingSlipType;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a <a href=""http://activemq.apache.org/camel/routing-slip.html"">Routing Slip</a>
 * pattern where the list of actual endpoints to send a message exchange to are
 * dependent on the value of a message header.
 */
public class RoutingSlip extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(RoutingSlip.class);
    private final String header;
    private final String uriDelimiter;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();
    public RoutingSlip(String header) {
        this(header, RoutingSlipType.DEFAULT_DELIMITER);
    }
    public RoutingSlip(String header, String uriDelimiter) {
        notNull(header, ""header"");
        notNull(uriDelimiter, ""uriDelimiter"");
        this.header = header;
        this.uriDelimiter = uriDelimiter;
    }
    @Override
    public String toString() {
        return ""RoutingSlip[header="" + header + "" uriDelimiter="" + uriDelimiter + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Message message = exchange.getIn();
        String[] recipients = recipients(message);
        Exchange current = exchange;
        for (String nextRecipient : recipients) {
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, nextRecipient);
            Producer<Exchange> producer = producerCache.getProducer(endpoint);
            Exchange ex = current.newInstance();
            updateRoutingSlip(current);
            copyOutToIn(ex, current);
            producer.process(ex);
            current = ex;
        }
        ExchangeHelper.copyResults(exchange, current);
    }
    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected void doStart() throws Exception {
    }
    private void updateRoutingSlip(Exchange current) {
        Message message = getResultMessage(current);
        message.setHeader(header, removeFirstElement(recipients(message)));
    }
    /**
     * Returns the outbound message if available. Otherwise return the inbound
     * message.
     */
    private Message getResultMessage(Exchange exchange) {
        Message message = exchange.getOut(false);
        // if this endpoint had no out (like a mock endpoint)
        // just take the in
        if (message == null) {
            message = exchange.getIn();
        }
        return message;
    }
    /**
     * Return the list of recipients defined in the routing slip in the
     * specified message.
     */
    private String[] recipients(Message message) {
        Object headerValue = message.getHeader(header);
        if (headerValue != null && !headerValue.equals("""")) {
            return headerValue.toString().split(uriDelimiter);
        }
        return new String[] {};
    }
    /**
     * Return a string representation of the element list with the first element
     * removed.
     */
    private String removeFirstElement(String[] elements) {
        CollectionStringBuffer updatedElements = new CollectionStringBuffer(uriDelimiter);
        for (int i = 1; i < elements.length; i++) {
            updatedElements.append(elements[i]);
        }
        return updatedElements.toString();
    }
    /**
     * Copy the outbound data in 'source' to the inbound data in 'result'.
     */
    private void copyOutToIn(Exchange result, Exchange source) {
        result.setException(source.getException());
        Message fault = source.getFault(false);
        if (fault != null) {
            result.getFault(true).copyFrom(fault);
        }
        result.setIn(getResultMessage(source));
        result.getProperties().clear();
        result.getProperties().putAll(source.getProperties());
    }
}
"
org.apache.camel.processor.SendProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Producer;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Processor for forwarding exchanges to an endpoint destination.
 *
 * @version $Revision: 725596 $
 */
public class SendProcessor extends ServiceSupport implements AsyncProcessor, Service {
    private static final transient Log LOG = LogFactory.getLog(SendProcessor.class);
    private Endpoint destination;
    private Producer producer;
    private AsyncProcessor processor;
    private ExchangePattern pattern;
    public SendProcessor(Endpoint destination) {
        if (destination == null) {
            throw new IllegalArgumentException(""Endpoint cannot be null!"");
        }
        this.destination = destination;
    }
    public SendProcessor(Endpoint destination, ExchangePattern pattern) {
        this(destination);
        this.pattern = pattern;
    }
    @Override
    public String toString() {
        return ""sendTo("" + destination + (pattern != null ? "" "" + pattern : """") + "")"";
    }
    public void process(Exchange exchange) throws Exception {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                throw new IllegalStateException(""No producer, this processor has not been started!"");
            }
        } else {
            configureExchange(exchange);
            producer.process(exchange);
        }
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                exchange.setException(new IllegalStateException(""No producer, this processor has not been started!""));
            }
            callback.done(true);
            return true;
        } else {
            configureExchange(exchange);
            return processor.process(exchange, callback);
        }
    }
    public Endpoint getDestination() {
        return destination;
    }
    protected void doStart() throws Exception {
        this.producer = destination.createProducer();
        this.producer.start();
        this.processor = AsyncProcessorTypeConverter.convert(producer);
    }
    protected void doStop() throws Exception {
        if (producer != null) {
            try {
                producer.stop();
            } finally {
                producer = null;
                processor = null;
            }
        }
    }
    protected void configureExchange(Exchange exchange) {
        if (pattern != null) {
            exchange.setPattern(pattern);
        }
    }
}
"
org.apache.camel.processor.SendToNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
/**
 * @version $Revision: 630568 $
 */
public class SendToNonExistingEndpointTest extends ContextTestSupport {
    public void testSendToNonExistingEndpoint() throws Exception {
        try {
            template.sendBody(""thisUriDoesNotExist"", ""<hello>world!</hello>"");
            fail(""Should have failed to send this message!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
}
"
org.apache.camel.processor.SetExchangePatternTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class SetExchangePatternTest extends ContextTestSupport {
    public void testInOut() throws Exception {
        assertMessageReceivedWithPattern(""direct:testInOut"", ExchangePattern.InOut);
    }
    public void testInOnly() throws Exception {
        assertMessageReceivedWithPattern(""direct:testInOnly"", ExchangePattern.InOnly);
    }
    public void testSetToInOnlyThenTo() throws Exception {
        assertMessageReceivedWithPattern(""direct:testSetToInOnlyThenTo"", ExchangePattern.InOnly);
    }
    public void testSetToInOutThenTo() throws Exception {
        assertMessageReceivedWithPattern(""direct:testSetToInOutThenTo"", ExchangePattern.InOut);
    }
    public void testToWithInOnlyParam() throws Exception {
        assertMessageReceivedWithPattern(""direct:testToWithInOnlyParam"", ExchangePattern.InOnly);
    }
    public void testToWithInOutParam() throws Exception {
        assertMessageReceivedWithPattern(""direct:testToWithInOutParam"", ExchangePattern.InOut);
    }
    public void testToWithRobustInOnlyParam() throws Exception {
        assertMessageReceivedWithPattern(""direct:testToWithRobustInOnlyParam"", ExchangePattern.RobustInOnly);
    }
    public void testSetExchangePatternInOnly() throws Exception {
        assertMessageReceivedWithPattern(""direct:testSetExchangePatternInOnly"", ExchangePattern.InOnly);
    }
    protected void assertMessageReceivedWithPattern(String sendUri, ExchangePattern expectedPattern) throws InterruptedException {
        ExchangePattern sendPattern;
        switch (expectedPattern) {
        case InOut:
            sendPattern = ExchangePattern.InOnly;
            break;
        case InOnly:
        case RobustInOnly:
            sendPattern = ExchangePattern.InOut;
            break;
        default:
            sendPattern = ExchangePattern.InOnly;
        }
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        String expectedBody = ""InOnlyMessage"";
        resultEndpoint.expectedBodiesReceived(expectedBody);
        template.sendBody(sendUri, sendPattern, expectedBody);
        resultEndpoint.assertIsSatisfied();
        ExchangePattern actualPattern = resultEndpoint.getExchanges().get(0).getPattern();
        assertEquals(""received exchange pattern"", actualPattern, expectedPattern);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
             // START SNIPPET: example
                // Send to an endpoint using InOut
                from(""direct:testInOut"").inOut(""mock:result"");
                // Send to an endpoint using InOut
                from(""direct:testInOnly"").inOnly(""mock:result"");
                // Set the exchange pattern to InOut, then send it from direct:inOnly to mock:result endpoint
                from(""direct:testSetToInOnlyThenTo"").inOnly().to(""mock:result"");
                from(""direct:testSetToInOutThenTo"").inOut().to(""mock:result"");
                // Or we can pass the pattern as a parameter to the to() method
                from(""direct:testToWithInOnlyParam"").to(ExchangePattern.InOnly, ""mock:result"");
                from(""direct:testToWithInOutParam"").to(ExchangePattern.InOut, ""mock:result"");
                from(""direct:testToWithRobustInOnlyParam"").to(ExchangePattern.RobustInOnly, ""mock:result"");
                // Set the exchange pattern to InOut, then send it on
                from(""direct:testSetExchangePatternInOnly"").setExchangePattern(ExchangePattern.InOnly).to(""mock:result"");
             // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SetHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class SetHeaderTest extends ContextTestSupport {
    protected String matchingBody = ""<person name='James' city='London'/>"";
    public void testSendMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(1);
        sendBody(""direct:start"", matchingBody);
        assertMockEndpointsSatisfied();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Object value = exchange.getIn().getHeader(""foo"");
        assertEquals(""foo header"", ""London"", value);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                Namespaces ns = new Namespaces(""foo"", ""urn:cheese"");
                from(""direct:start"").
                        unmarshal().string().
                        setHeader(""foo"").xpath(""/person[@name='James']/@city"", String.class).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SetHeaderUsingDslExpressionsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 697361 $
 */
public class SetHeaderUsingDslExpressionsTest extends ContextTestSupport {
    protected String body = ""<person name='James' city='London'/>"";
    protected MockEndpoint expected;
    public void testUseConstant() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").constant(""ABC"").
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisfied();
    }
    public void testUseConstantParameter() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"", constant(""ABC"")).
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisfied();
    }
    public void testUseExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").setHeader(""foo"").expression(new ExpressionAdapter() {
                    public Object evaluate(Exchange exchange) {
                        return ""ABC"";
                    }
                }).to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisfied();
    }
    public void testUseHeaderExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").header(""bar"").
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisfied();
    }
    public void testUseBodyExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").body().
                        to(""mock:result"");
            }
        });
        template.sendBody(""direct:start"", ""ABC"");
        assertMockEndpointsSatisfied();
    }
    public void testUseBodyAsTypeExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").body(String.class).
                        to(""mock:result"");
            }
        });
        template.sendBody(""direct:start"", ""ABC"".getBytes());
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        expected = getMockEndpoint(""mock:result"");
        expected.message(0).header(""foo"").isEqualTo(""ABC"");
    }
}
"
org.apache.camel.processor.SetOutBodyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/*
 * This tests whether the deprecated setOutBody method in ProcessorType behaves the
 * same as the new transform method.  
 */
public class SetOutBodyTest extends TransformProcessorTest {
    @SuppressWarnings(""deprecation"")
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").setOutBody(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SetPropertyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class SetPropertyTest extends ContextTestSupport {
    private MockEndpoint end;
    private String propertyName = ""foo"";
    private String expectedPropertyValue = ""bar"";
    public void testSetExchangePropertyMidRoute() throws Exception {
        end.expectedMessageCount(1);
        template.sendBody(""direct:start"", ""<blah/>"");
        // make sure we got the message
        assertMockEndpointsSatisfied();
        // lets get the property value
        List<Exchange> exchanges = end.getExchanges();
        Exchange exchange = exchanges.get(0);
        String actualPropertyValue = exchange.getProperty(propertyName, String.class);
        assertEquals(expectedPropertyValue, actualPropertyValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        end = getMockEndpoint(""mock:end"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                    setProperty(propertyName).constant(expectedPropertyValue).
                    to(""mock:end"");
            }
        };
    }
}
"
org.apache.camel.processor.SimulatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.jndi.JndiContext;
import static org.apache.camel.language.simple.SimpleLanguage.simple;
/**
 * @version $Revision: 676826 $
 */
public class SimulatorTest extends ContextTestSupport {
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""foo"", new MyBean(""foo""));
        answer.bind(""bar"", new MyBean(""bar""));
        return answer;
    }
    public void testReceivesFooResponse() throws Exception {
        assertRespondsWith(""foo"", ""Bye said foo"");
    }
    public void testReceivesBarResponse() throws Exception {
        assertRespondsWith(""bar"", ""Bye said bar"");
    }
    protected void assertRespondsWith(final String value, String containedText)
        throws InvalidPayloadException {
        Exchange response = template.request(""direct:a"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                Message in = exchange.getIn();
                in.setBody(""answer"");
                in.setHeader(""cheese"", value);
            }
        });
        assertNotNull(""Should receive a response!"", response);
        String text = ExchangeHelper.getMandatoryOutBody(response, String.class);
        assertStringContains(text, containedText);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").
                    recipientList(simple(""bean:${in.header.cheese}""));
                // END SNIPPET: example
            }
        };
    }
    public static class MyBean {
        private String value;
        public MyBean(String value) {
            this.value = value;
        }
        public String doSomething(String in) {
            return ""Bye said "" + value;
        }
    }
}
"
org.apache.camel.processor.Splitter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ThreadPoolExecutor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.util.CollectionHelper;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
 * where an expression is evaluated to iterate through each of the parts of a
 * message and then each part is then send to some endpoint.
 *
 * @version $Revision: 695502 $
 */
public class Splitter extends MulticastProcessor implements Processor {
    public static final String SPLIT_SIZE = ""org.apache.camel.splitSize"";
    public static final String SPLIT_COUNTER = ""org.apache.camel.splitCounter"";
    private final Expression expression;
    public Splitter(Expression expression, Processor destination, AggregationStrategy aggregationStrategy) {
        this(expression, destination, aggregationStrategy, false, null, false);
    }
    public Splitter(Expression expression, Processor destination,
            AggregationStrategy aggregationStrategy,
            boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor, boolean streaming) {
        super(Collections.singleton(destination), aggregationStrategy, parallelProcessing, threadPoolExecutor, streaming);
        this.expression = expression;
        notNull(expression, ""expression"");
        notNull(destination, ""destination"");
    }
    @Override
    public String toString() {
        return ""Splitter[on: "" + expression + "" to: "" + getProcessors().iterator().next() + "" aggregate: "" + getAggregationStrategy() + ""]"";
    }
    @Override
    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {
        Object value = expression.evaluate(exchange);
        if (isStreaming()) {
            return createProcessorExchangePairsIterable(exchange, value);
        } else {
            return createProcessorExchangePairsList(exchange, value);
        }
    }
    private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, Object value) {
        final Iterator iterator = ObjectHelper.createIterator(value);
        return new Iterable() {
            public Iterator iterator() {
                return new Iterator() {
                    public boolean hasNext() {
                        return iterator.hasNext();
                    }
                    public Object next() {
                        Object part = iterator.next();
                        Exchange newExchange = exchange.copy();
                        Message in = newExchange.getIn();
                        in.setBody(part);
                        return new ProcessorExchangePair(getProcessors().iterator().next(), newExchange);
                    }
                    public void remove() {
                        throw new UnsupportedOperationException(""remove is not supported by this iterator"");
                    }
                };
            }
        };
    }
    private Iterable<ProcessorExchangePair> createProcessorExchangePairsList(Exchange exchange, Object value) {
        List<ProcessorExchangePair> result;
        Integer collectionSize = CollectionHelper.size(value);
        if (collectionSize != null) {
            result = new ArrayList<ProcessorExchangePair>(collectionSize);
        } else {
            result = new ArrayList<ProcessorExchangePair>();
        }
        Iterator<Object> iter = ObjectHelper.createIterator(value);
        while (iter.hasNext()) {
            Object part = iter.next();
            Exchange newExchange = exchange.copy();
            Message in = newExchange.getIn();
            in.setBody(part);
            result.add(new ProcessorExchangePair(getProcessors().iterator().next(), newExchange));
        }
        return result;
    }
    @Override
    protected void updateNewExchange(Exchange exchange, int i, Iterable<ProcessorExchangePair> allPairs) {
        exchange.getIn().setHeader(SPLIT_COUNTER, i);
        if (allPairs instanceof Collection) {
            exchange.getIn().setHeader(SPLIT_SIZE, ((Collection) allPairs).size());
        }
    }
}
"
org.apache.camel.processor.SplitterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.apache.camel.CamelException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * @version $Revision: 732393 $
 */
public class SplitterTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedBodiesReceived(""James"", ""Guillaume"", ""Hiram"", ""Rob"");
        // InOnly
        template.send(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        for (int i = 0; i < 4; i++) {
            Exchange exchange = list.get(i);
            Message in = exchange.getIn();
            assertMessageHeader(in, Splitter.SPLIT_COUNTER, i);
            assertMessageHeader(in, Splitter.SPLIT_SIZE, 4);
        }
    }
    public void testSpliterWithAggregationStrategy() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedBodiesReceived(""James"", ""Guillaume"", ""Hiram"", ""Rob"", ""Roman"");
        Exchange result = template.request(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        Message out = result.getOut();
        assertEquals(""Roman"", out.getBody());
        assertMessageHeader(out, ""foo"", ""bar"");
        assertMessageHeader(out, Splitter.SPLIT_COUNTER, 4);
    }
    public void testEmptyBody() {
        Exchange result = template.request(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setHeader(""foo"", ""bar"");
            }
        });
        assertNull(result.getOut(false));
    }
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchangeParallel() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectsNoDuplicates(body());
        resultEndpoint.expectedMessageCount(4);
        // InOnly
        template.send(""direct:parallel"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Set<Integer> numbersFound = new TreeSet<Integer>();
        final String[] names = {""James"", ""Guillaume"", ""Hiram"", ""Rob""};
        for (int i = 0; i < 4; i++) {
            Exchange exchange = list.get(i);
            Message in = exchange.getIn();
            Integer splitCounter = in.getHeader(Splitter.SPLIT_COUNTER, Integer.class);
            numbersFound.add(splitCounter);
            assertEquals(names[splitCounter], in.getBody());
            assertMessageHeader(in, Splitter.SPLIT_SIZE, 4);
        }
        assertEquals(4, numbersFound.size());
    }
    public void testSpliterWithAggregationStrategyParallel() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(5);
        Exchange result = template.request(""direct:parallel"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        Message out = result.getOut();
        assertMessageHeader(out, ""foo"", ""bar"");
        assertEquals((Integer)5, result.getProperty(""aggregated"", Integer.class));
    }
    public void testSpliterWithAggregationStrategyParallelStreaming() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(5);
        resultEndpoint.expectedBodiesReceivedInAnyOrder(""James"", ""Guillaume"", ""Hiram"", ""Rob"", ""Roman"");
        Exchange result = template.request(""direct:parallel-streaming"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        Message out = result.getOut();
        assertMessageHeader(out, ""foo"", ""bar"");
        assertEquals((Integer)5, result.getProperty(""aggregated"", Integer.class));
    }
    public void testSplitterWithStreaming() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(5);
        resultEndpoint.expectedHeaderReceived(""foo"", ""bar"");
        template.request(""direct:streaming"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisfied();
        for (Exchange exchange : resultEndpoint.getReceivedExchanges()) {
            assertNotNull(exchange.getIn().getHeader(Splitter.SPLIT_COUNTER));
            //this header can not be set when streaming is used
            assertNull(exchange.getIn().getHeader(Splitter.SPLIT_SIZE));
        }
    }
    public void testSplitterWithException() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(4);
        resultEndpoint.expectedHeaderReceived(""foo"", ""bar"");
        MockEndpoint failedEndpoint = getMockEndpoint(""mock:failed"");
        failedEndpoint.expectedMessageCount(1);
        failedEndpoint.expectedHeaderReceived(""foo"", ""bar"");
        Exchange result = template.request(""direct:exception"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Exception"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertTrue(""The result exchange should have a camel exception"", result.getException() instanceof CamelException);
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                errorHandler(deadLetterChannel(""mock:failed"").maximumRedeliveries(0));
                from(""direct:seqential"").splitter(body().tokenize("",""), new UseLatestAggregationStrategy()).to(""mock:result"");
                from(""direct:parallel"").splitter(body().tokenize("",""), new MyAggregationStrategy(), true).to(""mock:result"");
                from(""direct:streaming"").splitter(body().tokenize("","")).streaming().to(""mock:result"");
                from(""direct:parallel-streaming"").splitter(body().tokenize("",""), new MyAggregationStrategy(), true).streaming().to(""mock:result"");
                from(""direct:exception"")
                    .splitter(body().tokenize("",""))
                    .aggregationStrategy(new MyAggregationStrategy())
                    .parallelProcessing(true).streaming()
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            String string = exchange.getIn().getBody(String.class);
                            if (""Exception"".equals(string)) {
                                throw new CamelException(""Just want to throw exception here"");
                            }
                        }                    
                    }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.SplitterWithCustomThreadPoolExecutorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.SplitterType;
public class SplitterWithCustomThreadPoolExecutorTest extends ContextTestSupport {
    protected ThreadPoolExecutor customThreadPoolExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
    public void testSplitterWithCustomThreadPoolExecutor() throws Exception {
        ThreadPoolExecutor threadPoolExecutor = getSplitter().getThreadPoolExecutor();
        // this should be sufficient as core pool size is the only thing I changed from the default
        assertTrue(threadPoolExecutor.getCorePoolSize() == customThreadPoolExecutor.getCorePoolSize());
        assertTrue(threadPoolExecutor.getMaximumPoolSize() == customThreadPoolExecutor.getMaximumPoolSize());
    }
    protected SplitterType getSplitter() {
        SplitterType result = null;
        List<RouteType> routeDefinitions = context.getRouteDefinitions();          
        for (RouteType routeType : routeDefinitions) {
            result = firstSplitterType(routeType.getOutputs());
            if (result != null) {
                break;
            }
        }
        return result;
    }    
    protected SplitterType firstSplitterType(List<ProcessorType<?>> outputs) {
        SplitterType result = null;
        for (ProcessorType processorType : outputs) {
            if (processorType instanceof SplitterType) {
                result = (SplitterType) processorType;
            } else {
                result = firstSplitterType(processorType.getOutputs());
            }
            if (result != null) {
                break;
            }
        }        
        return result;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:parallel-custom-pool"").splitter(body().tokenize("",""), true, customThreadPoolExecutor).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.StaticRecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
public class StaticRecipientListTest extends RecipientListTest {
    @Override
    protected void sendBody() {
        template.sendBody(""direct:a"", ""answer"");
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").to(""mock:x"", ""mock:y"", ""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.StreamResequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.LoggingExceptionHandler;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.processor.resequencer.ResequencerEngine;
import org.apache.camel.processor.resequencer.SequenceElementComparator;
import org.apache.camel.processor.resequencer.SequenceSender;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
/**
 * A resequencer that re-orders a (continuous) stream of {@link Exchange}s. The
 * algorithm implemented by {@link ResequencerEngine} is based on the detection
 * of gaps in a message stream rather than on a fixed batch size. Gap detection
 * in combination with timeouts removes the constraint of having to know the
 * number of messages of a sequence (i.e. the batch size) in advance.
 * <p>
 * Messages must contain a unique sequence number for which a predecessor and a
 * successor is known. For example a message with the sequence number 3 has a
 * predecessor message with the sequence number 2 and a successor message with
 * the sequence number 4. The message sequence 2,3,5 has a gap because the
 * sucessor of 3 is missing. The resequencer therefore has to retain message 5
 * until message 4 arrives (or a timeout occurs).
 * <p>
 * Instances of this class poll for {@link Exchange}s from a given
 * <code>endpoint</code>. Resequencing work and the delivery of messages to
 * the next <code>processor</code> is done within the single polling thread.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 724629 $
 * 
 * @see ResequencerEngine
 */
public class StreamResequencer extends ServiceSupport implements SequenceSender<Exchange>, Processor {
    private static final long DELIVERY_ATTEMPT_INTERVAL = 1000L;
    private ExceptionHandler exceptionHandler;
    private ResequencerEngine<Exchange> engine;
    private Processor processor;
    private Delivery delivery;
    private int capacity;
    /**
     * Creates a new {@link StreamResequencer} instance.
     * 
     * @param endpoint
     *            endpoint to poll exchanges from.
     * @param processor
     *            next processor that processes re-ordered exchanges.
     * @param comparator
     *            a sequence element comparator for exchanges.
     */
    public StreamResequencer(Processor processor, SequenceElementComparator<Exchange> comparator) {
        this.exceptionHandler = new LoggingExceptionHandler(getClass());
        this.engine = new ResequencerEngine<Exchange>(comparator);
        this.engine.setSequenceSender(this);
        this.processor = processor;
    }
    /**
     * Returns this resequencer's exception handler.
     * 
     * @return this resequencer's exception handler.
     */
    public ExceptionHandler getExceptionHandler() {
        return exceptionHandler;
    }
    /**
     * Returns the next processor.
     * 
     * @return the next processor.
     */
    public Processor getProcessor() {
        return processor;
    }
    /**
     * Returns this resequencer's capacity. The capacity is the maximum number
     * of exchanges that can be managed by this resequencer at a given point in
     * time. If the capacity if reached, polling from the endpoint will be
     * skipped for <code>timeout</code> milliseconds giving exchanges the
     * possibility to time out and to be delivered after the waiting period.
     * 
     * @return this resequencer's capacity.
     */
    public int getCapacity() {
        return capacity;
    }
    /**
     * Returns this resequencer's timeout. This sets the resequencer engine's
     * timeout via {@link ResequencerEngine#setTimeout(long)}. This value is
     * also used to define the polling timeout from the endpoint.
     * 
     * @return this resequencer's timeout.
     * (Processor) 
     * @see ResequencerEngine#setTimeout(long)
     */
    public long getTimeout() {
        return engine.getTimeout();
    }
    public void setCapacity(int capacity) {
        this.capacity = capacity;
    }
    public void setTimeout(long timeout) {
        engine.setTimeout(timeout);
    }
    @Override
    public String toString() {
        return ""StreamResequencer[to: "" + processor + ""]"";
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
        delivery = new Delivery();
        engine.start();
        delivery.start();
    }
    @Override
    protected void doStop() throws Exception {
        // let's stop everything in the reverse order
        // no need to stop the worker thread -- it will stop automatically when this service is stopped
        engine.stop();
        ServiceHelper.stopServices(processor);
    }
    /**
     * Sends the <code>exchange</code> to the next <code>processor</code>.
     * 
     * @param o
     *            exchange to send.
     */
    public void sendElement(Exchange o) throws Exception {
        processor.process(o);
    }
    public void process(Exchange exchange) throws Exception {
        while (engine.size() >= capacity) {
            Thread.sleep(getTimeout());
        }
        engine.insert(exchange);
        delivery.request();
    }
    private class Delivery extends Thread {
        private volatile boolean cancelRequested;
        public Delivery() {
            super(""Delivery Thread"");
        }
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(DELIVERY_ATTEMPT_INTERVAL);
                } catch (InterruptedException e) {
                    if (cancelRequested) {
                        return;
                    }
                }
                try {
                    engine.deliver();
                } catch (Exception e) {
                    exceptionHandler.handleException(e);
                }
            }
        }
        public void cancel() {
            cancelRequested = true;
            interrupt();
        }
        public void request() {
            interrupt();
        }
    }
}
"
org.apache.camel.processor.StreamResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.management.InstrumentationProcessor;
import org.apache.camel.management.JmxSystemPropertyKeys;
public class StreamResequencerTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    protected void sendBodyAndHeader(String endpointUri, final Object body,
                                   final String headerName, final Object headerValue) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(headerName, headerValue);
                in.setHeader(""testCase"", getName());
            }
        });
    }
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""msg1"", ""msg2"", ""msg3"", ""msg4"");
        sendBodyAndHeader(""direct:start"", ""msg4"", ""seqnum"", 4L);
        sendBodyAndHeader(""direct:start"", ""msg1"", ""seqnum"", 1L);
        sendBodyAndHeader(""direct:start"", ""msg3"", ""seqnum"", 3L);
        sendBodyAndHeader(""direct:start"", ""msg2"", ""seqnum"", 2L);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        enableJMX();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(header(""seqnum"")).stream().to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    public void testStreamResequencerTypeWithJmx() throws Exception {
        doTestStreamResequencerType();
    }
    public void testStreamResequencerTypeWithoutJmx() throws Exception {
        log.debug(""This will now fail"");
        disableJMX();
        doTestStreamResequencerType();
    }
    protected void doTestStreamResequencerType() throws Exception {
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        EventDrivenConsumerRoute consumerRoute =
            assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        DeadLetterChannel deadLetterChannel = assertIsInstanceOf(DeadLetterChannel.class, processor);
        Processor outputProcessor = deadLetterChannel.getOutput();
        if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
            InstrumentationProcessor interceptor =
                assertIsInstanceOf(InstrumentationProcessor.class, outputProcessor);
            outputProcessor = interceptor.getProcessor();
        }
        // we are not interested in any other delegate processors in the route (e.g. stream caching)
        while (outputProcessor instanceof DelegateProcessor) {
            outputProcessor = ((DelegateProcessor) outputProcessor).getProcessor();
        }
        assertIsInstanceOf(StreamResequencer.class, outputProcessor);
    }
}
"
org.apache.camel.processor.StreamSourceContentBasedRouterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.StringReader;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.converter.jaxp.StringSource;
/**
 * Test for handling a StreamSource in a content-based router with XPath predicates
 *
 * @version $Revision: 740263 $
 */
public class StreamSourceContentBasedRouterTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    public void testSendStreamSource() throws Exception {
        x.expectedMessageCount(1);
        y.expectedMessageCount(1);
        sendBody(""direct:start"", new StreamSource(new StringReader(""<message>xx</message>"")));
        sendBody(""direct:start"", new StreamSource(new StringReader(""<message>yy</message>"")));
        assertMockEndpointsSatisfied();
    }
    public void testSendStringSource() throws Exception {
        x.expectedMessageCount(1);
        y.expectedMessageCount(1);
        sendBody(""direct:start"", new StringSource(""<message>xx</message>""));
        sendBody(""direct:start"", new StringSource(""<message>yy</message>""));
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                  .when().xpath(""/message/text() = 'xx'"").to(""mock:x"")
                  .when().xpath(""/message/text() = 'yy'"").to(""mock:y"");
            }
        };
    }
}
"
org.apache.camel.processor.ThreadProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Service;
import org.apache.camel.util.AsyncProcessorHelper;
/**
 * A processor that forces async processing of the exchange using a thread pool.
 *
 * @version $Revision: 659491 $
 */
public class ThreadProcessor implements AsyncProcessor, Service {
    private ThreadPoolExecutor executor;
    private long stackSize;
    private ThreadGroup threadGroup;
    private int priority = Thread.NORM_PRIORITY;
    private boolean daemon = true;
    private String name = ""Thread Processor"";
    private BlockingQueue<Runnable> taskQueue;
    private long keepAliveTime;
    private int maxSize = 1;
    private int coreSize = 1;
    private final AtomicBoolean shutdown = new AtomicBoolean(true);
    private boolean callerRunsWhenRejected = true;
    class ProcessCall implements Runnable {
        private final Exchange exchange;
        private final AsyncCallback callback;
        public ProcessCall(Exchange exchange, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
        }
        public void run() {
            if (shutdown.get()) {
                exchange.setException(new RejectedExecutionException());
            }
            callback.done(false);
        }
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (shutdown.get()) {
            throw new IllegalStateException(""ThreadProcessor is not running."");
        }
        ProcessCall call = new ProcessCall(exchange, callback);
        try {
            executor.execute(call);
            return false;
        } catch (RejectedExecutionException e) {
            if (callerRunsWhenRejected) {
                if (shutdown.get()) {
                    exchange.setException(new RejectedExecutionException());
                } else {
                    callback.done(true);
                }
            } else {
                exchange.setException(e);
            }
            return true;
        }
    }
    public void start() throws Exception {
        shutdown.set(false);
        getExecutor();
    }
    public void stop() throws Exception {
        shutdown.set(true);
        executor.shutdown();
        executor.awaitTermination(0, TimeUnit.SECONDS);
    }
    public long getStackSize() {
        return stackSize;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public ThreadGroup getThreadGroup() {
        return threadGroup;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public long getKeepAliveTime() {
        return keepAliveTime;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public int getMaxSize() {
        return maxSize;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public int getCoreSize() {
        return coreSize;
    }
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public BlockingQueue<Runnable> getTaskQueue() {
        if (taskQueue == null) {
            taskQueue = new ArrayBlockingQueue<Runnable>(1000);
        }
        return taskQueue;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public ThreadPoolExecutor getExecutor() {
        if (executor == null) {
            executor = new ThreadPoolExecutor(getCoreSize(), getMaxSize(), getKeepAliveTime(), TimeUnit.MILLISECONDS, getTaskQueue(), new ThreadFactory() {
                public Thread newThread(Runnable runnable) {
                    Thread thread;
                    if (getStackSize() > 0) {
                        thread = new Thread(getThreadGroup(), runnable, getName(), getStackSize());
                    } else {
                        thread = new Thread(getThreadGroup(), runnable, getName());
                    }
                    thread.setDaemon(isDaemon());
                    thread.setPriority(getPriority());
                    return thread;
                }
            });
        }
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
    public boolean isCallerRunsWhenRejected() {
        return callerRunsWhenRejected;
    }
    public void setCallerRunsWhenRejected(boolean callerRunsWhenRejected) {
        this.callerRunsWhenRejected = callerRunsWhenRejected;
    }
}
"
org.apache.camel.processor.ThreadSetErrorHandlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test that verifies that thread does not allow add a error handler
 * as it will not kick in as expected by end-users.
 */
public class ThreadSetErrorHandlerTest extends ContextTestSupport {
    public void testNotAllowed() throws Exception {
        try {
            context.addRoutes(new RouteBuilder() {
                public void configure() throws Exception {
                    from(""direct:start"")
                        .thread(2)
                        // add error handler on thread is not allowed instead set on the parent (from)
                        .errorHandler(deadLetterChannel(""mock:error""))
                        .to(""mock:end"");
                }
            });
            fail(""Should have thrown IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
            // ok
        }
    }
}
"
org.apache.camel.processor.ThreadTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.spi.InterceptStrategy;
/**
 * @version $Revision: 742719 $
 */
public class ThreadTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    private CountDownLatch continueProcessing = new CountDownLatch(1);
    public void testSimpleAsyncThreadCase() throws Exception {
        // Send the exchange using the async completion interface.
        // This call returns before the exchange is completed.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        }, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                log.info(""Exchange completed."");
            }
        });
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release the processing latch..
        continueProcessing.countDown();
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testSimpleSyncThreadCase() throws Exception {
        // Release the processing latch in an async thread.
        releaseProcessingLatchIn(1000);
        // This call will block until the continueProcessing is released.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        });
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testQueuedUpExchangesCompleteOnShutdown() throws Exception {
        int exchangeCount = 10;
        final CountDownLatch completedExchanges = new CountDownLatch(exchangeCount);
        final Exchange exchanges[] = new Exchange[exchangeCount];
        for (int i = 0; i < exchangeCount; i++) {
            final int index = i;
            // Send the exchange using the async completion interface.
            // This call returns before the exchange is completed.
            exchanges[i] = template.send(""direct:a"", new Processor() {
                public void process(Exchange exchange) {
                    // now lets fire in a message
                    Message in = exchange.getIn();
                    in.setBody(1);
                }
            }, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    log.debug(""Completed: "" + index + "", exception: "" + exchanges[index].getException());
                    completedExchanges.countDown();
                }
            });
        }
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release it in a sec
        releaseProcessingLatchIn(1000);
        // Make sure we can shut down the context while there are
        // concurrent requests outstanding.
        stopCamelContext();
        // All exchanges should get completed..
        assertTrue(completedExchanges.await(5, TimeUnit.SECONDS));
    }
    protected void releaseProcessingLatchIn(final long delay) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Thread.sleep(delay);
                    continueProcessing.countDown();
                } catch (InterruptedException e) {
                }
            }
        }.start();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").thread(1).process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        continueProcessing.await();
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.Throttler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A <a href=""http://activemq.apache.org/camel/throttler.html"">Throttler</a>
 * will set a limit on the maximum number of message exchanges which can be sent
 * to a processor within a specific time period. <p/> This pattern can be
 * extremely useful if you have some external system which meters access; such
 * as only allowing 100 requests per second; or if huge load can cause a
 * particular systme to malfunction or to reduce its throughput you might want
 * to introduce some throttling.
 * 
 * @version $Revision: 731493 $
 */
public class Throttler extends DelayProcessorSupport {
    private long maximumRequestsPerPeriod;
    private long timePeriodMillis;
    private TimeSlot slot;
    public Throttler(Processor processor, long maximumRequestsPerPeriod) {
        this(processor, maximumRequestsPerPeriod, 1000);
    }
    public Throttler(Processor processor, long maximumRequestsPerPeriod, long timePeriodMillis) {
        super(processor);
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
        this.timePeriodMillis = timePeriodMillis;
    }
    @Override
    public String toString() {
        return ""Throttler[requests: "" + maximumRequestsPerPeriod + "" per: "" + timePeriodMillis + "" (ms) to: ""
               + getProcessor() + ""]"";
    }
    // Properties
    // -----------------------------------------------------------------------
    public long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    /**
     * Sets the maximum number of requests per time period
     */
    public void setMaximumRequestsPerPeriod(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    /**
     * Sets the time period during which the maximum number of requests apply
     */
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void delay(Exchange exchange) throws Exception {
        TimeSlot slot = nextSlot();
        if (!slot.isActive()) {
            waitUntil(slot.startTime, exchange);
        }
    }
    /*
     * Determine what the next available time slot is for handling an Exchange
     */
    protected synchronized TimeSlot nextSlot() {
        if (slot == null) {
            slot = new TimeSlot();
        }
        if (slot.isFull()) {
            slot = slot.next();
        }
        slot.assign();
        return slot;
    }
    /*
     * A time slot is capable of handling a number of exchanges within a certain period of time.
     */
    protected class TimeSlot {
        private long capacity = Throttler.this.maximumRequestsPerPeriod;
        private final long duration = Throttler.this.timePeriodMillis;
        private final long startTime;
        protected TimeSlot() {
            this(System.currentTimeMillis());
        }
        protected TimeSlot(long startTime) {
            this.startTime = startTime;
        }
        protected void assign() {
            capacity--;
        }
        /*
         * Start the next time slot either now or in the future
         * (no time slots are being created in the past)
         */
        protected TimeSlot next() {
            return new TimeSlot(Math.max(System.currentTimeMillis(), this.startTime + this.duration));
        }
        protected boolean isActive() {
            return startTime <= System.currentTimeMillis();
        }
        protected boolean isFull() {
            return capacity <= 0;
        }        
    }
}
"
org.apache.camel.processor.ThrottlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.Throttler.TimeSlot;
/**
 * @version $Revision: 731493 $
 */
public class ThrottlerTest extends ContextTestSupport {
    private static final int INTERVAL = 500;
    protected int messageCount = 6;
    public void testSendLotsOfMessagesButOnly3GetThrough() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(3);
        resultEndpoint.setResultWaitTime(1000);
        for (int i = 0; i < messageCount; i++) {
            template.sendBody(""seda:a"", ""<message>"" + i + ""</message>"");
        }
        // lets pause to give the requests time to be processed
        // to check that the throttle really does kick in
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendLotsOfMessagesSimultaneouslyButOnly3GetThrough() throws Exception {
        long start = System.currentTimeMillis();
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(messageCount);
        ExecutorService executor = Executors.newFixedThreadPool(messageCount);
        for (int i = 0; i < messageCount; i++) {
            executor.execute(new Runnable() {
                public void run() {
                    template.sendBody(""direct:a"", ""<message>payload</message>"");
                }                
            });
        }
        // let's wait for the exchanges to arrive
        resultEndpoint.assertIsSatisfied();
        // now assert that they have actually been throttled
        long minimumTime = (messageCount - 1) * INTERVAL;
        assertTrue(""Should take at least "" + minimumTime + ""ms"", System.currentTimeMillis() - start >= minimumTime);
    }
    public void testTimeSlotCalculus() throws Exception {
        Throttler throttler = new Throttler(null, 2, 1000);
        TimeSlot slot = throttler.nextSlot();
        // start a new time slot
        assertNotNull(slot);
        // make sure the same slot is used (2 exchanges per slot)
        assertSame(slot, throttler.nextSlot());
        assertTrue(slot.isFull());
        TimeSlot next = throttler.nextSlot();
        // now we should have a new slot that starts somewhere in the future
        assertNotSame(slot, next);
        assertFalse(next.isActive());
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").throttler(3).timePeriodMillis(10000).to(""mock:result"");
                // END SNIPPET: ex
                from(""direct:a"").throttler(1).timePeriodMillis(INTERVAL).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.ThroughputLogger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.text.NumberFormat;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Exchange;
import org.apache.camel.model.LoggingLevel;
import org.apache.commons.logging.Log;
/**
 * A logger for logging message throughput.
 *  
 * @version $Revision: 719456 $
 */
public class ThroughputLogger extends Logger {
    private int groupSize = 100;
    private long startTime;
    private long groupStartTime;
    private AtomicInteger receivedCounter = new AtomicInteger();
    private NumberFormat numberFormat = NumberFormat.getNumberInstance();
    private String action = ""Received"";
    private String logMessage;
    public ThroughputLogger() {
    }
    public ThroughputLogger(Log log) {
        super(log);
    }
    public ThroughputLogger(Log log, LoggingLevel level) {
        super(log, level);
    }
    public ThroughputLogger(String logName) {
        super(logName);
    }
    public ThroughputLogger(String logName, LoggingLevel level) {
        super(logName, level);
    }
    public ThroughputLogger(String logName, LoggingLevel level, int groupSize) {
        super(logName, level);
        setGroupSize(groupSize);
    }
    public ThroughputLogger(String logName, int groupSize) {
        super(logName);
        setGroupSize(groupSize);
    }
    public ThroughputLogger(int groupSize) {
        setGroupSize(groupSize);
    }
    @Override
    public void process(Exchange exchange) {
        if (startTime == 0) {
            startTime = System.currentTimeMillis();
        }
        int receivedCount = receivedCounter.incrementAndGet();
        if (receivedCount % groupSize == 0) {
            logMessage = createLogMessage(exchange, receivedCount);
            super.process(exchange);
        }
    }
    public int getGroupSize() {
        return groupSize;
    }
    public void setGroupSize(int groupSize) {
        if (groupSize == 0) {
            throw new IllegalArgumentException(""groupSize cannot be zero!"");
        }
        this.groupSize = groupSize;
    }
    public NumberFormat getNumberFormat() {
        return numberFormat;
    }
    public void setNumberFormat(NumberFormat numberFormat) {
        this.numberFormat = numberFormat;
    }
    public String getAction() {
        return action;
    }
    public void setAction(String action) {
        this.action = action;
    }
    @Override
    protected Object logMessage(Exchange exchange) {
        return logMessage;
    }
    protected String createLogMessage(Exchange exchange, int receivedCount) {
        long time = System.currentTimeMillis();
        if (groupStartTime == 0) {
            groupStartTime = startTime;
        }
        double rate = messagesPerSecond(groupSize, groupStartTime, time);
        double average = messagesPerSecond(receivedCount, startTime, time);
        long duration = time - groupStartTime;
        groupStartTime = time;
        return getAction() + "": "" + receivedCount + "" messages so far. Last group took: "" + duration
                + "" millis which is: "" + numberFormat.format(rate)
                + "" messages per second. average: "" + numberFormat.format(average);
    }
    // timeOneMessage = elapsed / messageCount
    // messagePerSend = 1000 / timeOneMessage
    protected double messagesPerSecond(long messageCount, long startTime, long endTime) {
        double rate = messageCount * 1000.0;
        rate /= endTime - startTime;
        return rate;
    }
}
"
org.apache.camel.processor.ThroughPutLoggerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import junit.framework.TestCase;
public class ThroughPutLoggerTest extends TestCase {
    public void testLogStringDurationIsNotZero() throws Exception {
        ThroughputLogger underTest = new ThroughputLogger(10);
        for (int i = 0; i < 25; i++) {
            underTest.process(null);
        }
        String message = (String) underTest.logMessage(null);
        assertTrue(""consumed 20 :"" + message, message.contains(""20""));
    }
}
"
org.apache.camel.processor.ThrowFaultProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
/**
 * The processor which implements the ThrowFault DSL
 */
public class ThrowFaultProcessor implements Processor {
    private Throwable fault;
    public ThrowFaultProcessor(Throwable fault) {
        this.fault = fault;
    }
    /**
     * Set the fault message in the exchange
     * @see org.apache.camel.Processor#process(org.apache.camel.Exchange)
     */
    public void process(Exchange exchange) throws Exception {
        Message message = exchange.getFault();
        message.setBody(fault);
    }
}
"
org.apache.camel.processor.TraceInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Tracer;
/**
 * @version $Revision: 699876 $
 */
public class TraceInterceptorTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testSendingSomeMessages() throws Exception {
        template.sendBodyAndHeader(""direct:start"", ""Hello London"", ""to"", ""James"");
        template.sendBodyAndHeader(""direct:start"", ""This is Copenhagen calling"", ""from"", ""Claus"");
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // add tracer as an interceptor so it will log the exchange executions at runtime
                // this can aid us to understand/see how the exchanges is routed etc.
                getContext().addInterceptStrategy(new Tracer());
                from(""direct:start"").
                        process(new Processor() {
                            public void process(Exchange exchange) throws Exception {
                                // do nothing
                            }
                            @Override
                            public String toString() {
                                return ""MyProcessor"";
                            }
                        }).
                        to(""mock:a"").
                        to(""mock:b"");
            }
        };
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.TraceInterceptorWithOutBodyTraceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.util.ExchangeHelper;
public class TraceInterceptorWithOutBodyTraceTest extends TraceInterceptorTest {
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: tracingOutExchanges
                Tracer tracer = new Tracer();
                tracer.setTraceOutExchanges(true);
                tracer.getFormatter().setShowOutBody(true);
                tracer.getFormatter().setShowOutBodyType(true);
                getContext().addInterceptStrategy(tracer);
                // END SNIPPET: tracingOutExchanges
                from(""direct:start"").
                    transform().body().
                    to(""mock:a"").
                    to(""mock:b"");
            }
        };
    }
}
"
org.apache.camel.processor.TracerConfigurationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.interceptor.Tracer;
/**
 * @version $Revision: 711235 $
 */
public class TracerConfigurationTest extends ContextTestSupport {
    public void testTracerConfiguration() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""Hello World"");
        template.sendBody(""direct:start"", ""Hello World"");
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                Tracer tracer = new Tracer();
                tracer.setLogLevel(LoggingLevel.FATAL);
                tracer.setLogName(""com.mycompany"");
                getContext().addInterceptStrategy(tracer);
                from(""direct:start"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.TransformProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A processor which sets the body on the OUT message with an expression
 */
public class TransformProcessor extends DelegateProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(TransformProcessor.class);
    private Expression expression;
    public TransformProcessor(Expression expression) {
        this.expression = expression;
    }
    public TransformProcessor(Expression expression, Processor childProcessor) {
        super(childProcessor);
        this.expression = expression;
    }
    public void process(Exchange exchange) throws Exception {
        Object newBody = expression.evaluate(exchange);
        exchange.getOut().setBody(newBody);
        // propagate headers
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        super.process(exchange);
    }
    @Override
    public String toString() {
        return ""transform("" + expression + "","" + processor + "")"";
    }
}
"
org.apache.camel.processor.TransformProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
public class TransformProcessorTest extends TransformViaDSLTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").transform(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TransformProcessorWithHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to verify that headers can be propogated with the transform DSL.
 */
public class TransformProcessorWithHeaderTest extends ContextTestSupport {
    public void testTransformPropogateHeaders() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        mock.expectedBodiesReceived(""London"");
        mock.expectedHeaderReceived(""foo"", ""bar"");
        template.sendBodyAndHeader(""direct:in"",
            ""<person name='James' city='London'/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"")
                    .transform().constant(""London"")
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.TransformTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class TransformTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) {
                        Message in = exchange.getIn();
                        in.setBody(in.getBody(String.class) + "" World!"");
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TransformViaDSLTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class TransformViaDSLTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").setBody(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TryProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * Implements try/catch/finally type processing
 *
 * @version $Revision: 695721 $
 */
public class TryProcessor extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(TryProcessor.class);
    private final Processor tryProcessor;
    private final List<CatchProcessor> catchClauses;
    private final Processor finallyProcessor;
    public TryProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {
        this.tryProcessor = tryProcessor;
        this.catchClauses = catchClauses;
        this.finallyProcessor = finallyProcessor;
    }
    public String toString() {
        String finallyText = (finallyProcessor == null) ? """" : "" Finally {"" + finallyProcessor + ""}"";
        return ""Try {"" + tryProcessor + ""} "" + catchClauses + finallyText;
    }
    public void process(Exchange exchange) throws Exception {
        Throwable e = null;
        try {
            tryProcessor.process(exchange);
            e = exchange.getException();
            // Ignore it if it was handled by the dead letter channel.
            if (e != null && DeadLetterChannel.isFailureHandled(exchange)) {
                e = null;
            }
        } catch (Throwable ex) {
            e = ex;
            exchange.setException(e);
        }
        Exception unexpected = null;
        try {
            if (e != null) {
                LOG.info(""Caught exception while processing exchange."", e);
                handleException(exchange, e);
            }
        } catch (Exception ex) {
            unexpected = ex;
        } catch (Throwable ex) {
            unexpected = wrapRuntimeCamelException(ex);
        } finally {
            try {
                processFinally(exchange);
            } catch (Exception ex) {
                unexpected = ex;
            } catch (Throwable ex) {
                unexpected = wrapRuntimeCamelException(ex);
            }
            if (unexpected != null) {
                LOG.warn(""Caught exception inside processFinally clause."", unexpected);
                throw unexpected;
            }
        }
        if (unexpected != null) {
            LOG.warn(""Caught exception inside handle clause."", unexpected);
            throw unexpected;
        }
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void handleException(Exchange exchange, Throwable e) throws Throwable {
        for (CatchProcessor catchClause : catchClauses) {
            if (catchClause.catches(e)) {
                // lets attach the exception to the exchange
                Exchange localExchange = exchange.copy();
                localExchange.getIn().setHeader(""caught.exception"", e);
                // give the rest of the pipeline another chance
                localExchange.setException(null);
                // do not catch any exception here, let it propagate up
                catchClause.process(localExchange);
                localExchange.getIn().removeHeader(""caught.exception"");
                ExchangeHelper.copyResults(exchange, localExchange);
                return;
            }
        }
    }
    protected void processFinally(Exchange exchange) throws Throwable {
        if (finallyProcessor != null) {
            Throwable lastException = exchange.getException();
            exchange.setException(null);
            // do not catch any exception here, let it propagate up
            finallyProcessor.process(exchange);
            if (exchange.getException() == null) {
                exchange.setException(lastException);
            }
        }
    }
}
"
org.apache.camel.processor.TryProcessorHandleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for try .. handle routing (CAMEL-564).
 */
public class TryProcessorHandleTest extends ContextTestSupport {
    private boolean handled;
    public void test() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        sendBody(""direct:start"", ""<test>Hello World!</test>"");
        assertTrue(""Should have been handled"", handled);
        mock.expectedMessageCount(0);
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(new ProcessorFail())
                        .to(""mock:result"")
                    .handle(Exception.class)
                      .process(new ProcessorHandle())
                    .end();
            }
        };
    }
    private class ProcessorFail implements Processor {
        public void process(Exchange exchange) throws Exception {
            throw new IllegalStateException(""Force to fail"");
        }
    }
    private class ProcessorHandle implements Processor {
        public void process(Exchange exchange) throws Exception {
            handled = true;
            assertEquals(""Should not be marked as failed"", false, exchange.isFailed());
            Exception e = (Exception)exchange.getIn().getHeader(""caught.exception"");
            assertNotNull(""There should be an exception"", e);
            assertTrue(e instanceof IllegalStateException);
            assertEquals(""Force to fail"", e.getMessage());
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultUnitOfWork;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/** 
 * Handles calling the UnitOfWork.done() method when processing of an exchange
 * is complete.
 */
public final class UnitOfWorkProcessor extends DelegateAsyncProcessor {
    public UnitOfWorkProcessor(AsyncProcessor processor) {
        super(processor);
    }
    @Override
    public String toString() {
        return ""UnitOfWrok("" + processor + "")"";
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (exchange.getUnitOfWork() == null) {
            // If there is no existing UoW, then we should start one and
            // terminate it once processing is completed for the exchange.
            final DefaultUnitOfWork uow = new DefaultUnitOfWork();
            exchange.setUnitOfWork(uow);
            try {
                uow.start();
            } catch (Exception e) {
                throw wrapRuntimeCamelException(e);
            }
            // return the process code where we do stop and cleanup
            return processor.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Order here matters. We need to complete the callbacks
                    // since they will likely update the exchange with 
                    // some final results.
                    callback.done(sync);
                    exchange.getUnitOfWork().done(exchange);
                    try {
                        uow.stop();
                    } catch (Exception e) {
                        throw wrapRuntimeCamelException(e);
                    }
                    exchange.setUnitOfWork(null);
                }
            });
        } else {
            // There was an existing UoW, so we should just pass through..
            // so that the guy the initiated the UoW can terminate it.
            return processor.process(exchange, callback);
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.Synchronization;
/**
 * @version $Revision: 583549 $
 */
public class UnitOfWorkTest extends ContextTestSupport {
    protected Synchronization synchronization;
    protected Exchange completed;
    protected Exchange failed;
    protected String uri = ""direct:foo"";
    protected CountDownLatch doneLatch = new CountDownLatch(1);
    public void testSuccess() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have failed"", failed);
        assertNotNull(""Should have received completed notification"", completed);
        log.info(""Received completed: "" + completed);
    }
    public void testFail() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    public void testException() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    @Override
    protected void setUp() throws Exception {
        synchronization = new Synchronization() {
            public void onComplete(Exchange exchange) {
                completed = exchange;
                doneLatch.countDown();
            }
            public void onFailure(Exchange exchange) {
                failed = exchange;
                doneLatch.countDown();
            }
        };
        super.setUp();
    }
    protected void sendMessage() throws InterruptedException {
        template.send(uri, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:async"").thread(1).to(""direct:foo"");
                from(""direct:foo"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        log.info(""Received: "" + exchange);
                        exchange.getUnitOfWork().addSynchronization(synchronization);
                        String name = getName();
                        if (name.equals(""testFail"")) {
                            log.info(""Failing test!"");
                            exchange.getFault(true).setBody(""testFail() should always fail with a fault!"");
                        } else if (name.equals(""testException"")) {
                            log.info(""Throwing exception!"");
                            throw new Exception(""Failing test!"");
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.UnitOfWorkWithAsyncFlowTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
/**
 * @version $Revision: 640438 $
 */
public class UnitOfWorkWithAsyncFlowTest extends UnitOfWorkTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""direct:async"";
        super.setUp();
    }
}
"
org.apache.camel.processor.UnmarshalProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * Unmarshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 684500 $
 */
public class UnmarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public UnmarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        InputStream stream = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        try {
            // lets setup the out message before we invoke the dataFormat
            // so that it can mutate it if necessary
            Message out = exchange.getOut(true);
            out.copyFrom(exchange.getIn());
            Object result = dataFormat.unmarshal(exchange, stream);
            out.setBody(result);
        } finally {
            if (stream != null) {
                stream.close();
            }
        }
    }
}
"
org.apache.camel.processor.ValidatingProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.validation.SchemaValidationException;
import org.apache.camel.processor.validation.ValidatingProcessor;
/**
 * Unit test of ValidatingProcessor.
 */
public class ValidatingProcessorTest extends ContextTestSupport {
    private ValidatingProcessor validating;
    @Override
    protected void setUp() throws Exception {
        validating = new ValidatingProcessor();
        validating.setSchemaFile(new File(""src/test/resources/org/apache/camel/processor/ValidatingProcessor.xsd"").getAbsoluteFile());
        super.setUp();
    }
    public void testValidMessage() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:valid"");
        mock.expectedMessageCount(1);
        String xml = ""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>""
            + ""<user xmlns=\""http://foo.com/bar\"">""
            + ""  <id>1</id>""
            + ""  <username>davsclaus</username>""
            + ""</user>"";
        template.sendBody(""direct:start"", xml);
        assertMockEndpointsSatisfied();
    }
    public void testInvalidMessage() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:invalid"");
        mock.expectedMessageCount(1);
        String xml = ""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>""
            + ""<user xmlns=\""http://foo.com/bar\"">""
            + ""  <username>someone</username>""
            + ""</user>"";
        try {
            template.sendBody(""direct:start"", xml);
            fail(""Should have thrown a RuntimeCamelException"");
        } catch (RuntimeCamelException e) {
            assertTrue(e.getCause() instanceof SchemaValidationException);
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                    process(validating).
                    to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationFinallyBlockNoCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * No catch blocks but handle all should work
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationFinallyBlockNoCatchTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        allEndpoint.expectedMessageCount(1);
        try {
            template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    public void testInvalidMessage() throws Exception {
        validEndpoint.expectedMessageCount(0);
        // allEndpoint receives 1 + 5 messages, ordinary (1 attempt) and redelivery (5 attempts) is involved
        allEndpoint.expectedMessageCount(1 + 5);
        try {
            template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.finallyBlock().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationFinallyBlockTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * Test finallyBlock
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationFinallyBlockTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.handle(ValidationException.class).to(""mock:invalid"");
                tryType.finallyBlock().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.Builder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 695104 $
 */
public class ValidationTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        Object result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisfied();
        assertEquals(""validResult"", result);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        try {
            template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    public void testinvalidThenValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(2);
        invalidEndpoint.expectedMessageCount(1);
        try {
            template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"",  ""notMatchedHeaderValue"");
        } catch (RuntimeCamelException e) {
            // expected
        }
        Object result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"",   ""bar"");
        assertEquals(""validResult"", result);
        result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"",   ""bar"");
        assertEquals(""validResult"", result);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
        validEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setOutBody(Builder.constant(""validResult"")));
        invalidEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setOutBody(Builder.constant(""invalidResult"")));
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                        tryBlock().
                        process(validator).
                        to(""mock:valid"").
                        handle(ValidationException.class).to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithErrorInHandleAndFinallyBlockTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
public class ValidationWithErrorInHandleAndFinallyBlockTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .errorHandler(noErrorHandler())
                    .tryBlock()
                        .process(validator)
                    .handle(ValidationException.class)
                        .process(validator)
                    .finallyBlock()
                        .choice()
                        .when(header(""foo"").isEqualTo(""bar""))
                        .to(""mock:valid"")
                        .otherwise()
                        .to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class ValidationWithExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        process(validator).
                        to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithFinallyBlockPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithFinallyBlockPipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator)
                        .setHeader(""valid"", constant(true))
                    .handle(ValidationException.class)
                        .setHeader(""valid"", constant(false))
                    .finallyBlock()
                        .setBody(body())
                        .choice()
                        .when(header(""valid"").isEqualTo(true))
                        .to(""mock:valid"")
                        .otherwise()
                        .to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithHandlePipelineAndExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithHandlePipelineAndExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").tryBlock().process(validator).to(""mock:valid"").handle(
                        ValidationException.class).process(validator);
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithHandlePipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithHandlePipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator).to(""mock:valid"")
                    .handle(ValidationException.class)
                        .tryBlock()
                            .process(validator).to(""mock:valid"")
                        .handle(ValidationException.class)
                            .pipeline(""direct:a"", ""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithInFlowExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 647890 $
 */
public class ValidationWithInFlowExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        exception(ValidationException.class).to(""mock:invalid"").
                        end().
                        process(validator).
                        to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithMultipleHandlesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithMultipleHandlesTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator)
                    .handle(ValidationException.class)
                        .setHeader(""xxx"", constant(""yyy""))
                    .end()
                    .tryBlock()
                        .process(validator).to(""mock:valid"")
                    .handle(ValidationException.class)
                        .pipeline(""direct:a"", ""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithNestedFinallyBlockPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithNestedFinallyBlockPipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .to(""direct:embedded"")
                    .handle(ValidationException.class)
                        .to(""mock:invalid"");
                from(""direct:embedded"")
                    .errorHandler(noErrorHandler())
                    .tryBlock()
                        .process(validator)
                        .to(""mock:valid"")
                    .finallyBlock()
                        .setHeader(""valid"", constant(false))
                    .end();
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithTryCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class ValidationWithTryCatchTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        try {
                            validator.process(exchange);
                            template.send(""mock:valid"", exchange);
                        } catch (ValidationException e) {
                            template.send(""mock:invalid"", exchange);
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.WireTapTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
public class WireTapTest extends ContextTestSupport {
    protected MockEndpoint tap;
    protected MockEndpoint result;
    public void testSend() throws Exception {
        String body = ""<body/>"";
        tap.expectedBodiesReceived(body);
        result.expectedBodiesReceived(body);
        expectsMessageCount(1, tap, result);
        template.sendBody(""direct:start"", body);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        tap = getMockEndpoint(""mock:tap"");
        result = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").multicast().to(""mock:tap"", ""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.XPathChoiceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 697361 $
 */
public class XPathChoiceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendToFirstWhen() throws Exception {
        String body = ""<body id='a'/>"";
        x.expectedBodiesReceived(body);
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisfied();
    }
    public void testSendToSecondWhen() throws Exception {
        String body = ""<body id='b'/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""cheese"", body);
        assertMockEndpointsSatisfied();
    }
    public void testSendToOtherwiseClause() throws Exception {
        String body = ""<body id='c'/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""somethingUndefined"", body);
        assertMockEndpointsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                        .when().xpath(""/body[@id='a']"").setHeader(""name"", constant(""a"")).to(""mock:x"")
                        .when().xpath(""/body[@id='b']"").to(""mock:y"")
                        .otherwise().to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.XPathFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 697361 $
 */
public class XPathFilterTest extends ContextTestSupport {
    protected String matchingBody = ""<person name='James' city='London'/>"";
    protected String notMatchingBody = ""<person name='Hiram' city='Tampa'/>"";
    public void testSendMatchingMessage() throws Exception {
        getMockEndpoint(""mock:result"").expectedBodiesReceived(matchingBody);
        sendBody(""direct:start"", matchingBody);
        assertMockEndpointsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        getMockEndpoint(""mock:result"").expectedMessageCount(0);
        sendBody(""direct:start"", notMatchingBody);
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").
                        filter().xpath(""/person[@name='James']"").
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespaceBuilderFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class XPathWithNamespaceBuilderFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                // lets define the namespaces we'll need in our filters
                Namespaces ns = new Namespaces(""c"", ""http://acme.com/cheese"")
                        .add(""xsd"", ""http://www.w3.org/2001/XMLSchema"");
                // now lets create an xpath based Message Filter
                from(""direct:start"").
                        filter(ns.xpath(""/c:person[@name='James']"")).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespacesFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class XPathWithNamespacesFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                Namespaces ns = new Namespaces(""c"", ""http://acme.com/cheese"");
                from(""direct:start"").filter().
                        xpath(""/c:person[@name='James']"", ns).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.aggregate.AggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.Collection;
import java.util.Iterator;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A {@link Collection} which aggregates exchanges together,
 * using a correlation {@link Expression} and a {@link AggregationStrategy}.
 * <p/>
 * The Default Implementation will group messages based on the correlation expression.
 * Other implementations could for instance just add all exchanges as a batch.
 *
 * @version $Revision: 706111 $
 */
public interface AggregationCollection extends Collection<Exchange> {
    /**
     * Gets the correlation expression
     */
    Expression<Exchange> getCorrelationExpression();
    /**
     * Sets the correlation expression to be used
     */
    void setCorrelationExpression(Expression<Exchange> correlationExpression);
    /**
     * Gets the aggregation strategy
     */
    AggregationStrategy getAggregationStrategy();
    /**
     * Sets the aggregation strategy to be used
     */
    void setAggregationStrategy(AggregationStrategy aggregationStrategy);
    /**
     * Adds the given exchange to this collection
     */
    boolean add(Exchange exchange);
    /**
     * Gets the iterator to iterate this collection.
     */
    Iterator<Exchange> iterator();
    /**
     * Gets the size of this collection
     */
    int size();
    /**
     * Clears this colleciton
     */
    void clear();
    /**
     * A strategy method allowing derived classes such as {@link PredicateAggregationCollection}
     * to check to see if the aggregation has completed
     */
    void onAggregation(Object correlationKey, Exchange newExchange);
}
"
org.apache.camel.processor.aggregate.AggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * A strategy for aggregating two exchanges together into a single exchange.
 * Possible implementations include performing some kind of combining or delta
 * processing, such as adding line items together into an invoice or just using
 * the newest exchange and removing old exchanges such as for state tracking or
 * market data prices; where old values are of little use.
 * 
 * @version $Revision: 630568 $
 */
public interface AggregationStrategy {
    /**
     * Aggregates an old and new exchange together to create a single combined
     * exchange
     *
     * @param oldExchange the oldest exchange
     * @param newExchange the newest exchange
     * @return a combined composite of the two exchanges
     */
    Exchange aggregate(Exchange oldExchange, Exchange newExchange);
}
"
org.apache.camel.processor.aggregate.DefaultAggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.AbstractCollection;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Collection} which aggregates exchanges together using a correlation
 * expression so that there is only a single message exchange sent for a single
 * correlation key.
 *
 * @version $Revision: 734887 $
 */
public class DefaultAggregationCollection extends AbstractCollection<Exchange> implements AggregationCollection {
    private static final transient Log LOG = LogFactory.getLog(DefaultAggregationCollection.class);
    private Expression<Exchange> correlationExpression;
    private AggregationStrategy aggregationStrategy;
    private Map<Object, Exchange> map = new LinkedHashMap<Object, Exchange>();
    public DefaultAggregationCollection() {
    }
    public DefaultAggregationCollection(Expression<Exchange> correlationExpression, AggregationStrategy aggregationStrategy) {
        this.correlationExpression = correlationExpression;
        this.aggregationStrategy = aggregationStrategy;
    }
    protected Map<Object, Exchange> getMap() {
        return map;
    }
    @Override
    public boolean add(Exchange exchange) {
        Object correlationKey = correlationExpression.evaluate(exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""evaluated expression: "" + correlationExpression + "" as CorrelationKey: "" + correlationKey);
        }
        Exchange oldExchange = map.get(correlationKey);
        Exchange newExchange = exchange;
        if (oldExchange != null) {
            Integer count = oldExchange.getProperty(Exchange.AGGREGATED_COUNT, Integer.class);
            if (count == null) {
                count = 1;
            }
            count++;
            newExchange = aggregationStrategy.aggregate(oldExchange, newExchange);
            newExchange.setProperty(Exchange.AGGREGATED_COUNT, count);
        }
        // the strategy may just update the old exchange and return it
        if (newExchange != oldExchange) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""put exchange:"" + newExchange + "" for key:""  + correlationKey);
            }
            if (oldExchange == null) {
                newExchange.setProperty(Exchange.AGGREGATED_COUNT, Integer.valueOf(1));
            }
            map.put(correlationKey, newExchange);
        }
        onAggregation(correlationKey, newExchange);
        return true;
    }
    public Iterator<Exchange> iterator() {
        return map.values().iterator();
    }
    public int size() {
        return map.size();
    }
    @Override
    public void clear() {
        map.clear();
    }
    public void onAggregation(Object correlationKey, Exchange newExchange) {
    }
    public Expression<Exchange> getCorrelationExpression() {
        return correlationExpression;
    }
    public void setCorrelationExpression(Expression<Exchange> correlationExpression) {
        this.correlationExpression = correlationExpression;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
}
"
org.apache.camel.processor.aggregate.PredicateAggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * An aggregator collection which uses a predicate to decide when an aggregation is completed for
 * a particular correlation key
 *
 * @version $Revision: 702404 $
 */
public class PredicateAggregationCollection extends DefaultAggregationCollection {
    private Predicate aggregationCompletedPredicate;
    private List<Exchange> collection = new ArrayList<Exchange>();
    public PredicateAggregationCollection(Expression<Exchange> correlationExpression, AggregationStrategy aggregationStrategy, Predicate aggregationCompletedPredicate) {
        super(correlationExpression, aggregationStrategy);
        this.aggregationCompletedPredicate = aggregationCompletedPredicate;
    }
    @Override
    public void onAggregation(Object correlationKey, Exchange newExchange) {
        if (aggregationCompletedPredicate.matches(newExchange)) {
            // this exchange has now aggregated so lets add it to the collection of things to send
            super.getMap().remove(correlationKey);
            collection.add(newExchange);
        }
    }
    @Override
    public Iterator<Exchange> iterator() {
        return collection.iterator();
    }
    @Override
    public int size() {
        return collection.size();
    }
    @Override
    public void clear() {
        collection.clear();
        super.clear();
    }
}
"
org.apache.camel.processor.aggregate.UseLatestAggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * An {@link AggregationStrategy} which just uses the latest exchange which is useful
 * for status messages where old status messages have no real value. Another example is things
 * like market data prices, where old stock prices are not that relevant, only the current price is.
 *
 * @version $Revision: 727409 $
 */
public class UseLatestAggregationStrategy implements AggregationStrategy {
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        newExchange.setException(checkException(oldExchange, newExchange));
        return newExchange;
    }
    protected Throwable checkException(Exchange oldExchange, Exchange newExchange) {
        return newExchange.getException() != null
                ? newExchange.getException()
                : oldExchange.getException();
    }
}
"
org.apache.camel.processor.aggregator.AggregatorAndOnExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.CamelException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.PredicateAggregationCollection;
/**
 * Unit test inspired by user forum.
 */
public class AggregatorAndOnExceptionTest extends ContextTestSupport {
    public void testAggregateAndOnException() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""Bye World"");
        template.sendBodyAndHeader(""seda:start"", ""Hello World"", ""id"", 123);
        template.sendBodyAndHeader(""seda:start"", ""Bye World"", ""id"", 123);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                errorHandler(deadLetterChannel(""mock:error""));
                onException(CamelException.class).maximumRedeliveries(2);
                from(""seda:start"")
                    .aggregator(new PredicateAggregationCollection(header(""id""),
                        new AggregationStrategy() {
                            public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
                                return newExchange;
                            }
                        },
                        header(Exchange.AGGREGATED_COUNT).isEqualTo(2)))
                    .batchTimeout(500L)
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.aggregator.AggregatorBatchOptionsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for the batch size options on aggregator.
 */
public class AggregatorBatchOptionsTest extends ContextTestSupport {
    public boolean isUseRouteBuilder() {
        return false;
    }
    public void testAggregateOutBatchSize() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // aggregated by header id
                    // as we have not configured more on the aggregator it will default to aggregate the
                    // latest exchange only
                    .aggregator().header(""id"")
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    // batch size in is the limit of number of exchanges received, so when we have received 100
                    // exchanges then whatever we have in the collection will be sent
                    .batchSize(100)
                    // limit the out batch size to 3 so when we have aggregated 3 exchanges
                    // and we reach this limit then the exchanges is send
                    .outBatchSize(3)
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        });
        startCamelContext();
        // START SNIPPET: e2
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMinimumMessageCount(4);
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""Message 1a"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2a"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1b"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2b"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1c"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3a"", ""id"", ""3"");
        // when we send message 4 then we will reach the collection batch size limit and the
        // exchanges above is the ones we have aggregated in the first batch
        template.sendBodyAndHeader(""direct:start"", ""Message 4"", ""id"", ""4"");
        assertMockEndpointsSatisfied();
        // first batch
        assertEquals(""Message 1c"", result.getExchanges().get(0).getIn().getBody());
        assertEquals(""Message 2b"", result.getExchanges().get(1).getIn().getBody());
        assertEquals(""Message 3a"", result.getExchanges().get(2).getIn().getBody());
        // second batch
        assertEquals(""Message 4"", result.getExchanges().get(3).getIn().getBody());
        // END SNIPPET: e2
    }
    public void testAggregateBatchSize() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e3
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // aggregated by header id
                    // as we have not configured more on the aggregator it will default to aggregate the
                    // latest exchange only
                    .aggregator().header(""id"")
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    // batch size in is the limit of number of exchanges received, so when we have received 5
                    // exchanges then whatever we have in the collection will be sent
                    .batchSize(5)
                    .to(""mock:result"");
                // END SNIPPET: e3
            }
        });
        startCamelContext();
        // START SNIPPET: e4
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMinimumMessageCount(5);
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""Message 1a"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2a"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1b"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2b"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1c"", ""id"", ""1"");
        // need a little sleep between batches
        Thread.sleep(10);
        // when we sent the next message we have reached the in batch size limit and the current
        // aggregated exchanges will be sent
        template.sendBodyAndHeader(""direct:start"", ""Message 3a"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 4"", ""id"", ""4"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3b"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3c"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1d"", ""id"", ""1"");
        assertMockEndpointsSatisfied();
        // first batch
        assertEquals(""Message 1c"", result.getExchanges().get(0).getIn().getBody());
        assertEquals(""Message 2b"", result.getExchanges().get(1).getIn().getBody());
        // second batch
        assertEquals(""Message 3c"", result.getExchanges().get(2).getIn().getBody());
        assertEquals(""Message 4"", result.getExchanges().get(3).getIn().getBody());
        assertEquals(""Message 1d"", result.getExchanges().get(4).getIn().getBody());
        // END SNIPPET: e4
    }
    public void testAggregateBatchTimeout() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e5
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // aggregated by header id
                    // as we have not configured more on the aggregator it will default to aggregate the
                    // latest exchange only
                    .aggregator().header(""id"")
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    .to(""mock:result"");
                // END SNIPPET: e5
            }
        });
        startCamelContext();
        // START SNIPPET: e6
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMinimumMessageCount(6);
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""Message 1a"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2a"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1b"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2b"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1c"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3a"", ""id"", ""3"");
        Thread.sleep(600L);
        // these messages are not aggregated in the first batch as the timeout should have accoured
        template.sendBodyAndHeader(""direct:start"", ""Message 4"", ""id"", ""4"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3b"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3c"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1d"", ""id"", ""1"");
        assertMockEndpointsSatisfied();
        // first batch
        assertEquals(""Message 1c"", result.getExchanges().get(0).getIn().getBody());
        assertEquals(""Message 2b"", result.getExchanges().get(1).getIn().getBody());
        assertEquals(""Message 3a"", result.getExchanges().get(2).getIn().getBody());
        // second batch
        assertEquals(""Message 4"", result.getExchanges().get(3).getIn().getBody());
        assertEquals(""Message 3c"", result.getExchanges().get(4).getIn().getBody());
        assertEquals(""Message 1d"", result.getExchanges().get(5).getIn().getBody());
        // END SNIPPET: e6
    }
}
"
org.apache.camel.processor.aggregator.AggregatorTimerAndTracerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.interceptor.Tracer;
/**
 * Unit test with timer, splitter, aggregator and tracer.
 */
public class AggregatorTimerAndTracerTest extends ContextTestSupport {
    public void testAggregatorTimerAndTracer() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                getContext().addInterceptStrategy(new Tracer());
                from(""timer://kickoff?period=9999910000"").
                    setHeader(""id"").constant(""foo"").setBody().constant(""a b c"").
                    splitter(body().tokenize("" "")).to(""seda:splitted"");
                from(""seda:splitted"").
                    aggregator(header(""id"")).
                    to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.aggregator.AlbertoAggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.AggregatorType;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 702853 $
 */
public class AlbertoAggregatorTest extends ContextTestSupport {
    private static final String SURNAME_HEADER = ""surname"";
    private static final String TYPE_HEADER = ""type"";
    private static final String BROTHERS_TYPE = ""brothers"";
    private Log log = LogFactory.getLog(this.getClass());
    public void testAggregator() throws Exception {
        String allNames = ""Harpo Marx,Fiodor Karamazov,Chico Marx,Ivan Karamazov,Groucho Marx,Alexei Karamazov,Dimitri Karamazov"";
        List<String> marxBrothers = new ArrayList<String>();
        marxBrothers.add(""Harpo"");
        marxBrothers.add(""Chico"");
        marxBrothers.add(""Groucho"");
        List<String> karamazovBrothers = new ArrayList<String>();
        karamazovBrothers.add(""Fiodor"");
        karamazovBrothers.add(""Ivan"");
        karamazovBrothers.add(""Alexei"");
        karamazovBrothers.add(""Dimitri"");
        Map<String, List> allBrothers = new HashMap<String, List>();
        allBrothers.put(""Marx"", marxBrothers);
        allBrothers.put(""Karamazov"", karamazovBrothers);
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.expectedBodiesReceived(allBrothers);
        ProducerTemplate template = context.createProducerTemplate();
        template.sendBody(""direct:start"", allNames);
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            AggregationStrategy surnameAggregator = new AggregationStrategy() {
                public Exchange aggregate(Exchange oldExchange,
                        Exchange newExchange) {
                    debugIn(""Surname Aggregator"", oldExchange, newExchange);
                    Message oldIn = oldExchange.getIn();
                    Message newIn = newExchange.getIn();
                    List<String> brothers = null;
                    if (oldIn.getBody() instanceof List) {
                        brothers = oldIn.getBody(List.class);
                        brothers.add(newIn.getBody(String.class));
                    } else {
                        brothers = new ArrayList<String>();
                        brothers.add(oldIn.getBody(String.class));
                        brothers.add(newIn.getBody(String.class));
                        oldExchange.getIn().setBody(brothers);
                    } // else
                    debugOut(""Surname Aggregator"", oldExchange);
                    return oldExchange;
                }
            };
            AggregationStrategy brothersAggregator = new AggregationStrategy() {
                public Exchange aggregate(Exchange oldExchange,
                        Exchange newExchange) {
                    debugIn(""Brothers Aggregator"", oldExchange, newExchange);
                    Message oldIn = oldExchange.getIn();
                    Message newIn = newExchange.getIn();
                    Map<String, List> brothers = null;
                    if (oldIn.getBody() instanceof Map) {
                        brothers = oldIn.getBody(Map.class);
                        brothers.put(newIn.getHeader(SURNAME_HEADER,
                                String.class), newIn.getBody(List.class));
                    } else {
                        brothers = new HashMap<String, List>();
                        brothers.put(oldIn.getHeader(SURNAME_HEADER, String.class),
                                oldIn.getBody(List.class));
                        brothers.put(newIn.getHeader(SURNAME_HEADER,
                                String.class), newIn.getBody(List.class));
                        oldExchange.getIn().setBody(brothers);
                    } // else
                    debugOut(""Brothers Aggregator"", oldExchange);
                    return oldExchange;
                }
            };
            private void debugIn(String stringId, Exchange oldExchange,
                    Exchange newExchange) {
                log.debug(stringId + "" old headers in: ""
                        + oldExchange.getIn().getHeaders());
                log.debug(stringId + "" old body in: ""
                        + oldExchange.getIn().getBody());
                log.debug(stringId + "" new headers in: ""
                        + newExchange.getIn().getHeaders());
                log.debug(stringId + "" new body in: ""
                        + newExchange.getIn().getBody());
            }
            private void debugOut(String stringId, Exchange exchange) {
                log.debug(stringId + "" old headers out: ""
                        + exchange.getIn().getHeaders());
                log.debug(stringId + "" old body out: ""
                        + exchange.getIn().getBody());
            }
            @Override
            public void configure() throws Exception {
                from(""direct:start"")
                        // Separate people
                        .splitter(bodyAs(String.class).tokenize("","")).process(
                            // Split the name, erase the surname and put it in a
                            // header
                            new Processor() {
                                public void process(Exchange exchange) throws Exception {
                                    String[] parts = exchange.getIn()
                                            .getBody(String.class).split(
                                            "" "");
                                    exchange.getIn().setBody(parts[0]);
                                    exchange.getIn().setHeader(
                                            SURNAME_HEADER, parts[1]);
                                } // process
                            }) // Processor
                        .to(""direct:joinSurnames"");
                from(""direct:joinSurnames"")
                        .aggregator(header(SURNAME_HEADER),
                                surnameAggregator).setHeader(TYPE_HEADER,
                        constant(BROTHERS_TYPE)).to(""direct:joinBrothers"");
                // Join all brothers lists and remove surname and type headers
                AggregatorType agg =
                        from(""direct:joinBrothers"").aggregator(header(TYPE_HEADER),
                                brothersAggregator);
                agg.setBatchTimeout(2000L);
                agg.removeHeader(SURNAME_HEADER)
                        .removeHeader(TYPE_HEADER)
                        .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.aggregator.CustomAggregationCollectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
/**
 * Unit test for using our own aggregation collection.
 */
public class CustomAggregationCollectionTest extends ContextTestSupport {
    public void testCustomAggregationCollection() throws Exception {
        // START SNIPPET: e2
        MockEndpoint result = getMockEndpoint(""mock:result"");
        // we expect 5 messages since our custom aggregation collection just gets it all
        // but returns them in reverse order
        result.expectedMessageCount(5);
        result.expectedBodiesReceived(""190"", ""200"", ""130"", ""150"", ""100"");
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""100"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""150"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""130"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""200"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""190"", ""id"", ""1"");
        assertMockEndpointsSatisfied();
        // END SNIPPET: e2
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // use our own collection for aggregation
                    .aggregator(new MyReverseAggregationCollection())
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        };
    }
}
"
org.apache.camel.processor.aggregator.CustomAggregationStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationStrategy;
/**
 * Unit test for using our own aggregation strategy.
 */
public class CustomAggregationStrategyTest extends ContextTestSupport {
    public void testCustomAggregationStrategy() throws Exception {
        // START SNIPPET: e2
        MockEndpoint result = getMockEndpoint(""mock:result"");
        // we expect to find the two winners with the highest bid
        result.expectedMessageCount(2);
        result.expectedBodiesReceived(""200"", ""150"");
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""100"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""150"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""130"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""200"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""190"", ""id"", ""1"");
        assertMockEndpointsSatisfied();
        // END SNIPPET: e2
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // aggregated by header id and use our own strategy how to aggregate
                    .aggregator(new MyAggregationStrategy()).header(""id"")
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        };
    }
    // START SNIPPET: e3
    private static class MyAggregationStrategy implements AggregationStrategy {
        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
            int oldPrice = oldExchange.getIn().getBody(Integer.class);
            int newPrice = newExchange.getIn().getBody(Integer.class);
            // return the ""winner"" that has the highest price
            return newPrice > oldPrice ? newExchange : oldExchange;
        }
    }
    // END SNIPPET: e3
}
"
org.apache.camel.processor.aggregator.DefaultAggregatorCollectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for DefaultAggregatorCollection.
 */
public class DefaultAggregatorCollectionTest extends ContextTestSupport {
    public void testDefaultAggregateCollection() throws Exception {
        // START SNIPPET: e2
        MockEndpoint result = getMockEndpoint(""mock:result"");
        // we expect 4 messages grouped by the latest message only
        result.expectedMessageCount(4);
        result.expectedBodiesReceived(""Message 1d"", ""Message 2b"", ""Message 3c"", ""Message 4"");
        result.message(0).property(Exchange.AGGREGATED_COUNT).isEqualTo(4);
        result.message(1).property(Exchange.AGGREGATED_COUNT).isEqualTo(2);
        result.message(2).property(Exchange.AGGREGATED_COUNT).isEqualTo(3);
        result.message(3).property(Exchange.AGGREGATED_COUNT).isEqualTo(1);
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""Message 1a"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2a"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3a"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1b"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3b"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1c"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3c"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2b"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1d"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 4"", ""id"", ""4"");
        assertMockEndpointsSatisfied();
        // END SNIPPET: e2
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // aggregated by header id
                    // as we have not configured more on the aggregator it will default to aggregate the
                    // latest exchange only
                    .aggregator().header(""id"")
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        };
    }
}
"
org.apache.camel.processor.aggregator.MyReverseAggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
//START SNIPPET: e1
class MyReverseAggregationCollection extends AbstractCollection<Exchange> implements AggregationCollection {
    private List<Exchange> collection = new ArrayList<Exchange>();
    private Expression correlation;
    private AggregationStrategy strategy;
    public Expression getCorrelationExpression() {
        return correlation;
    }
    public void setCorrelationExpression(Expression correlationExpression) {
        this.correlation = correlationExpression;
    }
    public AggregationStrategy getAggregationStrategy() {
        return strategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.strategy = aggregationStrategy;
    }
    public boolean add(Exchange exchange) {
        return collection.add(exchange);
    }
    public Iterator<Exchange> iterator() {
        // demonstrate the we can do something with this collection, so we reverse it
        Collections.reverse(collection);
        return collection.iterator();
    }
    public int size() {
        return collection.size();
    }
    public void clear() {
        collection.clear();
    }
    public void onAggregation(Object correlationKey, Exchange newExchange) {
        add(newExchange);
    }
}
//END SNIPPET: e1
"
org.apache.camel.processor.aggregator.PredicateAggregatorCollectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.PredicateAggregationCollection;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * Unit test for PredicateAggregatorCollection.
 */
public class PredicateAggregatorCollectionTest extends ContextTestSupport {
    public void testPredicateAggregateCollection() throws Exception {
        // START SNIPPET: e2
        MockEndpoint result = getMockEndpoint(""mock:result"");
        // we only expect two messages as they have reached the completed predicate
        // that we want 3 messages that has the same header id
        result.expectedMessageCount(2);
        result.expectedBodiesReceived(""Message 1c"", ""Message 3c"");
        // then we sent all the message at once
        template.sendBodyAndHeader(""direct:start"", ""Message 1a"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2a"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3a"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1b"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3b"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1c"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 3c"", ""id"", ""3"");
        template.sendBodyAndHeader(""direct:start"", ""Message 2b"", ""id"", ""2"");
        template.sendBodyAndHeader(""direct:start"", ""Message 1d"", ""id"", ""1"");
        template.sendBodyAndHeader(""direct:start"", ""Message 4"", ""id"", ""4"");
        assertMockEndpointsSatisfied();
        // END SNIPPET: e2
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: e1
                // create the aggregation collection we will use.
                // - we will correlate the received message based on the id header
                // - as we will just keep the latest message we use the latest strategy
                // - and finally we stop aggregate if we receive 2 or more messages
                AggregationCollection ag = new PredicateAggregationCollection(header(""id""),
                    new UseLatestAggregationStrategy(),
                    header(Exchange.AGGREGATED_COUNT).isEqualTo(3));
                // our route is aggregating from the direct queue and sending the response to the mock
                from(""direct:start"")
                    // we use the collection based aggregator we already have configured
                    .aggregator(ag)
                    // wait for 0.5 seconds to aggregate
                    .batchTimeout(500L)
                    .to(""mock:result"");
                // END SNIPPET: e1
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.CustomExceptionPolicyStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.Map;
import org.apache.camel.CamelException;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.ExceptionType;
/**
 * Unit test with a user plugged in exception policy to use instead of default.
 */
public class CustomExceptionPolicyStrategyTest extends ContextTestSupport {
    private static final String MESSAGE_INFO = ""messageInfo"";
    private static final String ERROR_QUEUE = ""mock:error"";
    public static class MyPolicyException extends Exception {
    }
    // START SNIPPET e2
    public static class MyPolicy implements ExceptionPolicyStrategy {
        public ExceptionType getExceptionPolicy(Map<ExceptionPolicyKey, ExceptionType> exceptionPolicices,
                                                Exchange exchange,
                                                Throwable exception) {
            // This is just an example that always forces the exception type configured
            // with MyPolicyException to win.
            return exceptionPolicices.get(ExceptionPolicyKey.newInstance(MyPolicyException.class));
        }
    }
    // END SNIPPET e2
    public void testCustomPolicy() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm my policy exception"");
        try {
            template.sendBody(""direct:a"", ""Hello Camel"");
        } catch (Exception e) {
            // expected
        }
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            // START SNIPPET e1
            public void configure() throws Exception {
                // configure the error handler to use my policy instead of the default from Camel
                errorHandler(deadLetterChannel().exceptionPolicyStrategy(new MyPolicy()));
                exception(MyPolicyException.class)
                    .maximumRedeliveries(1)
                    .setHeader(MESSAGE_INFO, constant(""Damm my policy exception""))
                    .to(ERROR_QUEUE);
                exception(CamelException.class)
                    .maximumRedeliveries(3)
                    .setHeader(MESSAGE_INFO, constant(""Damm a Camel exception""))
                    .to(ERROR_QUEUE);
                // END SNIPPET e1
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String s = exchange.getIn().getBody(String.class);
                        if (""Hello Camel"".equals(s)) {
                            throw new CamelExchangeException(""Forced for testing"", exchange);
                        }
                        exchange.getOut().setBody(""Hello World"");
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default strategy used in Camel to resolve the {@link org.apache.camel.model.ExceptionType} that should
 * handle the thrown exception.
 * <p/>
 * <b>Selection strategy:</b>
 * <br/>This strategy applies the following rules:
 * <ul>
 * <li>Will walk the exception hieracy from bottom upwards till the thrown exception, meaning that the most outer caused
 * by is selected first, ending with the thrown exception itself</li>
 * <li>The exception type must be configured with an Exception that is an instance of the thrown exception, this
 * is tested using the {@link #filter(org.apache.camel.model.ExceptionType, Class, Throwable)} method. </li>
 * <li>If the exception type has exactly the thrown exception then its selected as its an exact match</li>
 * <li>Otherwise the type that has an exception that is the closests super of the thrown exception is selected
 * (recurring up the exception hierarchy)</li>
 * </ul>
 * <p/>
 * <b>Fine grained matching:</b>
 * <br/> If the {@link ExceptionType} has a when defined with an expression the type is also matches against
 * the current exchange using the {@link #matchesWhen(org.apache.camel.model.ExceptionType, org.apache.camel.Exchange)}
 * method. This can be used to for more fine grained matching, so you can e.g. define multiple sets of
 * exception types with the same exception class(es) but have a predicate attached to select which to select at runtime.
 */
public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy {
    private static final transient Log LOG = LogFactory.getLog(DefaultExceptionPolicyStrategy.class);
    public ExceptionType getExceptionPolicy(Map<ExceptionPolicyKey, ExceptionType> exceptionPolicices, Exchange exchange,
                                            Throwable exception) {
        // recursive up the tree using the iterator
        Iterator<Throwable> it = createExceptionIterator(exception); 
        while (it.hasNext()) {
            ExceptionType type = findMatchedExceptionPolicy(exceptionPolicices, exchange, it.next());
            if (type != null) {
                return type;
            }
        }
        // no type found
        return null;
    }
    private ExceptionType findMatchedExceptionPolicy(Map<ExceptionPolicyKey, ExceptionType> exceptionPolicices, Exchange exchange,
                                               Throwable exception) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finding best suited exception policy for thrown exception "" + exception.getClass().getName());
        }
        // the goal is to find the exception with the same/closet inheritance level as the target exception being thrown
        int targetLevel = getInheritanceLevel(exception.getClass());
        // candidate is the best candidate found so far to return
        ExceptionType candidate = null;
        // difference in inheritance level between the current candidate and the thrown exception (target level)
        int candidateDiff = Integer.MAX_VALUE;
        // loop through all the entries and find the best candidates to use
        Set<Map.Entry<ExceptionPolicyKey, ExceptionType>> entries = exceptionPolicices.entrySet();
        for (Map.Entry<ExceptionPolicyKey, ExceptionType> entry : entries) {
            Class clazz = entry.getKey().getExceptionClass();
            ExceptionType type = entry.getValue();
            if (filter(type, clazz, exception)) {
                // must match
                if (!matchesWhen(type, exchange)) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""The type did not match when: "" + type);
                    }
                    continue;
                }
                // exact match then break
                if (clazz.equals(exception.getClass())) {
                    candidate = type;
                    break;
                }
                // not an exact match so find the best candidate
                int level = getInheritanceLevel(clazz);
                int diff = targetLevel - level;
                if (diff < candidateDiff) {
                    // replace with a much better candidate
                    candidate = type;
                    candidateDiff = diff;
                }
            }
        }
        if (LOG.isDebugEnabled()) {
            if (candidate != null) {
                LOG.debug(""Using "" + candidate + "" as the exception policy"");
            } else {
                LOG.debug(""No candidate found to be used as exception policy"");
            }
        }
        return candidate;
    }
    /**
     * Strategy to filter the given type exception class with the thrown exception
     *
     * @param type           the exception type
     * @param exceptionClass the current exception class for testing
     * @param exception      the thrown exception
     * @return <tt>true</tt> if the to current exception class is a candidate, <tt>false</tt> to skip it.
     */
    protected boolean filter(ExceptionType type, Class exceptionClass, Throwable exception) {
        // must be instance of check to ensure that the exceptionClass is one type of the thrown exception
        return exceptionClass.isInstance(exception);
    }
    /**
     * Strategy method for matching the exception type with the current exchange.
     * <p/>
     * This default implementation will match as:
     * <ul>
     * <li>Always true if no when predicate on the exception type
     * <li>Otherwise the when predicate is matches against the current exchange
     * </ul>
     *
     * @param type     the exception type
     * @param exchange the current {@link Exchange}
     * @return <tt>true</tt> if matched, <tt>false</tt> otherwise.
     */
    protected boolean matchesWhen(ExceptionType type, Exchange exchange) {
        if (type.getOnWhen() == null || type.getOnWhen().getExpression() == null) {
            // if no predicate then it's always a match
            return true;
        }
        return type.getOnWhen().getExpression().matches(exchange);
    }
    /**
     * Strategy method creating the iterator to walk the exception in the order Camel should use
     * for find the {@link ExceptionType} should be used.
     * <p/>
     * The default iterator will walk from the bottom upwards
     * (the last caused by going upwards to the exception)
     *
     * @param exception  the exception
     * @return the iterator
     */
    protected Iterator<Throwable> createExceptionIterator(Throwable exception) {
        return new ExceptionIterator(exception);
    }
    private static int getInheritanceLevel(Class clazz) {
        if (clazz == null || ""java.lang.Object"".equals(clazz.getName())) {
            return 0;
        }
        return 1 + getInheritanceLevel(clazz.getSuperclass());
    }
    private class ExceptionIterator implements Iterator<Throwable> {
        private List<Throwable> tree = new ArrayList<Throwable>();
        private Iterator<Throwable> it;
        public ExceptionIterator(Throwable exception) {
            Throwable current = exception;
            // spool to the bottom of the caused by tree
            while (current != null) {
                tree.add(current);
                current = current.getCause();
            }
            // reverse tree so we go from bottom to top
            Collections.reverse(tree);
            it = tree.iterator();
        }
        public boolean hasNext() {
            return it.hasNext();
        }
        public Throwable next() {
            return it.next();
        }
        public void remove() {
            it.remove();
        }
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.ConnectException;
import java.net.SocketException;
import java.util.HashMap;
import junit.framework.TestCase;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.ValidationException;
import org.apache.camel.model.ExceptionType;
/**
 * Unit test for DefaultExceptionPolicy 
 */
public class DefaultExceptionPolicyStrategyTest extends TestCase {
    private DefaultExceptionPolicyStrategy strategy;
    private HashMap<ExceptionPolicyKey, ExceptionType> policies;
    private ExceptionType type1;
    private ExceptionType type2;
    private ExceptionType type3;
    private void setupPolicies() {
        strategy = new DefaultExceptionPolicyStrategy();
        policies = new HashMap<ExceptionPolicyKey, ExceptionType>();
        type1 = new ExceptionType(CamelExchangeException.class);
        type2 = new ExceptionType(Exception.class);
        type3 = new ExceptionType(IOException.class);
        policies.put(ExceptionPolicyKey.newInstance(CamelExchangeException.class), type1);
        policies.put(ExceptionPolicyKey.newInstance(Exception.class), type2);
        policies.put(ExceptionPolicyKey.newInstance(IOException.class), type3);
    }
    private void setupPoliciesNoTopLevelException() {
        // without the top level exception that can be used as fallback
        strategy = new DefaultExceptionPolicyStrategy();
        policies = new HashMap<ExceptionPolicyKey, ExceptionType>();
        type1 = new ExceptionType(CamelExchangeException.class);
        type3 = new ExceptionType(IOException.class);
        policies.put(ExceptionPolicyKey.newInstance(CamelExchangeException.class), type1);
        policies.put(ExceptionPolicyKey.newInstance(IOException.class), type3);
    }
    public void testDirectMatch1() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new CamelExchangeException("""", null));
        assertEquals(type1, result);
    }
    public void testDirectMatch2() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new Exception(""""));
        assertEquals(type2, result);
    }
    public void testDirectMatch3() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new IOException(""""));
        assertEquals(type3, result);
    }
    public void testClosetMatch3() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ConnectException(""""));
        assertEquals(type3, result);
        result = strategy.getExceptionPolicy(policies, null, new SocketException(""""));
        assertEquals(type3, result);
        result = strategy.getExceptionPolicy(policies, null, new FileNotFoundException());
        assertEquals(type3, result);
    }
    public void testClosetMatch2() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ClassCastException(""""));
        assertEquals(type2, result);
        result = strategy.getExceptionPolicy(policies, null, new NumberFormatException(""""));
        assertEquals(type2, result);
        result = strategy.getExceptionPolicy(policies, null, new NullPointerException());
        assertEquals(type2, result);
    }
    public void testClosetMatch1() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ValidationException(null, """"));
        assertEquals(type1, result);
        result = strategy.getExceptionPolicy(policies, null, new ExchangeTimedOutException(null, 0));
        assertEquals(type1, result);
    }
    public void testNoMatch1ThenMatchingJustException() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new AlreadyStoppedException());
        assertEquals(type2, result);
    }
    public void testNoMatch1ThenNull() {
        setupPoliciesNoTopLevelException();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new AlreadyStoppedException());
        assertNull(""Should not find an exception policy to use"", result);
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategyUsingOnlyWhenTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for the when expression on the exception type.
 */
public class DefaultExceptionPolicyStrategyUsingOnlyWhenTest extends ContextTestSupport {
    private static final String ERROR_QUEUE = ""mock:error"";
    private static final String ERROR_USER_QUEUE = ""mock:usererror"";
    public static class MyUserException extends Exception {
        public MyUserException(String message) {
            super(message);
        }
    }
    public void testNoWhen() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        try {
            template.sendBody(""direct:a"", ""Hello Camel"");
            fail(""Should have thrown an Exception"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    public void testWithWhen() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_USER_QUEUE);
        mock.expectedMessageCount(1);
        try {
            template.sendBodyAndHeader(""direct:a"", ""Hello Camel"", ""user"", ""admin"");
            fail(""Should have thrown an Exception"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                errorHandler(deadLetterChannel(ERROR_QUEUE).maximumRedeliveries(0));
                onException(MyUserException.class).onWhen(header(""user"").isNotNull())
                    .maximumRedeliveries(1)
                    .to(ERROR_USER_QUEUE);
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String s = exchange.getIn().getBody(String.class);
                        if (""Hello Camel"".equals(s)) {
                            throw new MyUserException(""Forced for testing"");
                        }
                        exchange.getOut().setBody(""Hello World"");
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategyUsingWhenTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for the when expression on the exception type.
 */
public class DefaultExceptionPolicyStrategyUsingWhenTest extends ContextTestSupport {
    private static final String ERROR_QUEUE = ""mock:error"";
    private static final String ERROR_USER_QUEUE = ""mock:usererror"";
    public static class MyUserException extends Exception {
        public MyUserException(String message) {
            super(message);
        }
    }
    public void testNoWhen() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        try {
            template.sendBody(""direct:a"", ""Hello Camel"");
            fail(""Should have thrown an Exception"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    public void testWithWhen() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_USER_QUEUE);
        mock.expectedMessageCount(1);
        try {
            template.sendBodyAndHeader(""direct:a"", ""Hello Camel"", ""user"", ""admin"");
            fail(""Should have thrown an Exception"");
        } catch (Exception e) {
            // expected
        }
        assertMockEndpointsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            // START SNIPPET e1
            public void configure() throws Exception {
                // here we define our onException to catch MyUserException when
                // there is a header[user] on the exchange that is not null
                onException(MyUserException.class).onWhen(header(""user"").isNotNull())
                    .maximumRedeliveries(1)
                    .to(ERROR_USER_QUEUE);
                // here we define onException to catch MyUserException as a kind
                // of fallback when the above did not match.
                // Noitce: The order how we have defined these onException is
                // important as Camel will resolve in the same order as they
                // have been defined
                onException(MyUserException.class)
                    .maximumRedeliveries(2)
                    .to(ERROR_QUEUE);
                // END SNIPPET e1
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String s = exchange.getIn().getBody(String.class);
                        if (""Hello Camel"".equals(s)) {
                            throw new MyUserException(""Forced for testing"");
                        }
                        exchange.getOut().setBody(""Hello World"");
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import org.apache.camel.model.WhenType;
/**
 * Exception policy key is a compound key for storing:
 * <b>exception class</b> + <b>when</b> => <b>exception type</b>.
 * <p/>
 * This is used by Camel to store the onException types configued that has or has not predicates attached (when).
 */
public final class ExceptionPolicyKey {
    private final Class exceptionClass;
    private final WhenType when;
    public ExceptionPolicyKey(Class exceptionClass, WhenType when) {
        this.exceptionClass = exceptionClass;
        this.when = when;
    }
    public Class getExceptionClass() {
        return exceptionClass;
    }
    public WhenType getWhen() {
        return when;
    }
    public static ExceptionPolicyKey newInstance(Class exceptionClass) {
        return new ExceptionPolicyKey(exceptionClass, null);
    }
    public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenType when) {
        return new ExceptionPolicyKey(exceptionClass, when);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ExceptionPolicyKey that = (ExceptionPolicyKey) o;
        if (!exceptionClass.equals(that.exceptionClass)) {
            return false;
        }
        if (when != null ? !when.equals(that.when) : that.when != null) {
            return false;
        }
        return true;
    }
    @Override
    public int hashCode() {
        int result = exceptionClass.hashCode();
        result = 31 * result + (when != null ? when.hashCode() : 0);
        return result;
    }
    @Override
    public String toString() {
        return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
    }
}
"
org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
/**
 * A strategy to determine which {@link org.apache.camel.model.ExceptionType} should handle the thrown
 * exception.
 *
 * @see org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy DefaultExceptionPolicy
 */
public interface ExceptionPolicyStrategy {
    /**
     * Resolves the {@link org.apache.camel.model.ExceptionType} that should handle the thrown exception.
     *
     * @param exceptionPolicices the configured exception policies to resolve from
     * @param exchange           the exchange
     * @param exception          the exception that was thrown
     * @return the resolved exception type to handle this exception, <tt>null</tt> if none found.
     */
    ExceptionType getExceptionPolicy(Map<ExceptionPolicyKey, ExceptionType> exceptionPolicices, Exchange exchange,
                                            Throwable exception);
}
"
org.apache.camel.processor.idempotent.IdempotentConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExpressionHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent
 * Consumer</a> pattern.
 * 
 * @version $Revision: 630568 $
 */
public class IdempotentConsumer extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(IdempotentConsumer.class);
    private Expression<Exchange> messageIdExpression;
    private Processor nextProcessor;
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumer(Expression<Exchange> messageIdExpression,
                              MessageIdRepository messageIdRepository, Processor nextProcessor) {
        this.messageIdExpression = messageIdExpression;
        this.messageIdRepository = messageIdRepository;
        this.nextProcessor = nextProcessor;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer[expression="" + messageIdExpression + "", repository="" + messageIdRepository
               + "", processor="" + nextProcessor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        String messageId = ExpressionHelper.evaluateAsString(messageIdExpression, exchange);
        if (messageId == null) {
            throw new NoMessageIdException(exchange, messageIdExpression);
        }
        if (!messageIdRepository.contains(messageId)) {
            nextProcessor.process(exchange);
        } else {
            onDuplicateMessage(exchange, messageId);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public Expression<Exchange> getMessageIdExpression() {
        return messageIdExpression;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public Processor getNextProcessor() {
        return nextProcessor;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(nextProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(nextProcessor);
    }
    /**
     * A strategy method to allow derived classes to overload the behaviour of
     * processing a duplicate message
     * 
     * @param exchange the exchange
     * @param messageId the message ID of this exchange
     */
    protected void onDuplicateMessage(Exchange exchange, String messageId) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Ignoring duplicate message with id: "" + messageId + "" for exchange: "" + exchange);
        }
    }
}
"
org.apache.camel.processor.idempotent.MemoryMessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.util.LRUCache;
/**
 * A memory based implementation of {@link MessageIdRepository}. Care should be
 * taken to use a suitable underlying {@link Map} to avoid this class being a
 * memory leak
 * 
 * @version $Revision: 664441 $
 */
public class MemoryMessageIdRepository implements MessageIdRepository {
    private final Map cache;
    public MemoryMessageIdRepository(Map set) {
        this.cache = set;
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based repository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository() {
        return memoryMessageIdRepository(new HashMap());
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based repository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository(int cacheSize) {
        return memoryMessageIdRepository(new LRUCache(cacheSize));
    }
    /**
     * Creates a new MemoryMessageIdRepository using the given {@link Map} to
     * use to store the processed Message ID objects. Warning be careful of the
     * implementation of Map you use as if you are not careful it could be a
     * memory leak.
     */
    public static MessageIdRepository memoryMessageIdRepository(Map cache) {
        return new MemoryMessageIdRepository(cache);
    }
    public boolean contains(String messageId) {
        synchronized (cache) {
            if (cache.containsKey(messageId)) {
                return true;
            } else {
                cache.put(messageId, messageId);
                return false;
            }
        }
    }
}
"
org.apache.camel.processor.idempotent.MessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
/**
 * Access to a repository of Message IDs to implement the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 630568 $
 */
public interface MessageIdRepository {
    /**
     * Returns true if this messageId has been processed before
     * otherwise this messageId is added to the repository and false is returned.
     *
     * @param messageId the String ID of the message
     * @return true if the message has been processed succesfully before otherwise false
     */
    boolean contains(String messageId);
}
"
org.apache.camel.processor.idempotent.NoMessageIdException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if no message ID could be found on a message which is to be used with the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 630568 $
 */
public class NoMessageIdException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Expression expression;
    public NoMessageIdException(Exchange exchange, Expression expression) {
        super(""No message ID could be found using expression: "" + expression + "" on message exchange: "" + exchange);
        this.exchange = exchange;
        this.expression = expression;
    }
    /**
     * The exchange which caused this failure
     */
    public Exchange getExchange() {
        return exchange;
    }
    /**
     * The expression which was used
     */
    public Expression getExpression() {
        return expression;
    }
}
"
org.apache.camel.processor.interceptor.Breakpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * @version $Revision: 662301 $
 */
public class Breakpoint {
    public void waitForBreakpoint(Exchange exchange) {
        // TODO
    }
}
"
org.apache.camel.processor.interceptor.Debugger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An interceptor strategy for debugging and tracing routes
 *
 * @version $Revision: 682597 $
 */
public class Debugger implements InterceptStrategy {
    private static final transient Log LOG = LogFactory.getLog(Debugger.class);
    private int exchangeBufferSize = -1;
    private Map<String, DebugInterceptor> interceptors = new HashMap<String, DebugInterceptor>();
    private boolean logExchanges = true;
    private boolean enabled = true;
    private Tracer tracer = new Tracer();
    /**
     * A helper method to return the debugger instance for a given {@link CamelContext} if one is enabled
     *
     * @param context the camel context the debugger is connected to
     * @return the debugger or null if none can be found
     */
    public static Debugger getDebugger(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            List<InterceptStrategy> list = defaultCamelContext.getInterceptStrategies();
            for (InterceptStrategy interceptStrategy : list) {
                if (interceptStrategy instanceof Debugger) {
                    return (Debugger)interceptStrategy;
                }
            }
        }
        return null;
    }
    public DebugInterceptor getInterceptor(String id) {
        return interceptors.get(id);
    }
    /**
     * Returns the list of exchanges sent to the given node in the DSL
     */
    public List<Exchange> getExchanges(String id) {
        DebugInterceptor interceptor = getInterceptor(id);
        if (interceptor == null) {
            return null;
        } else {
            return interceptor.getExchanges();
        }
    }
    public void setEnable(boolean flag) {
        enabled = flag;
        tracer.setEnabled(flag);
        for (DebugInterceptor interceptor : interceptors.values()) {
            interceptor.setEnabled(flag);
        }
    }
    public boolean isEnabled() {
        return enabled;
    }
    /**
     * Returns the breakpoint object for the given node in the DSL
     */
    public Breakpoint getBreakpoint(String id) {
        DebugInterceptor interceptor = getInterceptor(id);
        if (interceptor == null) {
            return null;
        } else {
            return interceptor.getBreakpoint();
        }
    }
    public TraceFormatter getTraceFormatter() {
        return tracer.getFormatter();
    }
    public void setTraceFormatter(TraceFormatter formatter) {
        tracer.setFormatter(formatter);
    }
    public void setLogExchanges(boolean flag) {
        logExchanges = flag;
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
        String id = processorType.idOrCreate();
        if (logExchanges) {
            TraceInterceptor  traceInterceptor = new TraceInterceptor(processorType, target, tracer);
            target = traceInterceptor;
        }
        DebugInterceptor interceptor = new DebugInterceptor(processorType, target, createExchangeList(), createExceptionsList());
        interceptors.put(id, interceptor);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Adding "" + id + "" interceptor: "" + interceptor);
        }
        return interceptor;
    }
    protected List<Exchange> createExchangeList() {
        if (exchangeBufferSize == 0) {
            return null;
        } else if (exchangeBufferSize > 0) {
            // TODO lets create a non blocking fixed size queue
            return new ArrayList<Exchange>();
        } else {
            return new ArrayList<Exchange>();
        }
    }
    protected List<ExceptionEvent> createExceptionsList() {
        // TODO allow some kinda LRU based fixed size list to be used?
        return new ArrayList<ExceptionEvent>();
    }
}
"
org.apache.camel.processor.interceptor.DebugInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.DelegateProcessor;
/**
 * An interceptor for debugging and tracing routes
 *
 * @version $Revision: 682255 $
 */
public class DebugInterceptor extends DelegateProcessor {
    private final ProcessorType node;
    private final List<Exchange> exchanges;
    private final List<ExceptionEvent> exceptions;
    private Predicate traceFilter;
    private Breakpoint breakpoint = new Breakpoint();
    private boolean traceExceptions = true;
    private boolean enabled = true;
    public DebugInterceptor(ProcessorType node, Processor target, List<Exchange> exchanges, List<ExceptionEvent> exceptions) {
        super(target);
        this.node = node;
        this.exchanges = exchanges;
        this.exceptions = exceptions;
    }
    @Override
    public String toString() {
        return ""DebugInterceptor["" + node + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        if (isEnabled()) {
            checkForBreakpoint(exchange);
            addTraceExchange(exchange);
        }
        try {
            super.proceed(exchange);
        } catch (Exception e) {
            onException(exchange, e);
            throw e;
        } catch (Error e) {
            onException(exchange, e);
            throw e;
        }
    }
    public ProcessorType getNode() {
        return node;
    }
    public boolean isEnabled() {
        return enabled;
    }
    public void setEnabled(boolean flag) {
        enabled = flag;
    }
    public List<Exchange> getExchanges() {
        return exchanges;
    }
    public List<ExceptionEvent> getExceptions() {
        return exceptions;
    }
    public Breakpoint getBreakpoint() {
        return breakpoint;
    }
    public Predicate getTraceFilter() {
        return traceFilter;
    }
    public void setTraceFilter(Predicate traceFilter) {
        this.traceFilter = traceFilter;
    }
    public boolean isTraceExceptions() {
        return traceExceptions;
    }
    public void setTraceExceptions(boolean traceExceptions) {
        this.traceExceptions = traceExceptions;
    }
    /**
     * Stategy method to wait for a breakpoint if one is set
     */
    protected void checkForBreakpoint(Exchange exchange) {
        breakpoint.waitForBreakpoint(exchange);
    }
    /**
     * Fired when an exception is thrown when processing the underlying processor
     */
    protected void onException(Exchange exchange, Throwable e) {
        if (shouldTraceExceptionEvents(exchange, e))  {
            exceptions.add(new ExceptionEvent(this, exchange, e));
        }
    }
    private boolean shouldTraceExceptionEvents(Exchange exchange, Throwable e) {
        return isTraceExceptions() && isEnabled();
    }
    /**
     * Strategy method to store the exchange in a trace log if it is enabled
     */
    protected void addTraceExchange(Exchange exchange) {
        if (shouldTraceExchange(exchange)) {
            exchanges.add(copyExchange(exchange));
        }
    }
    protected Exchange copyExchange(Exchange previousExchange) {
        Exchange answer = previousExchange.newInstance();
        answer.getProperties().putAll(previousExchange.getProperties());
        answer.getIn().copyFrom(previousExchange.getIn());
        // only copy the out if its defined
        Message previousOut = previousExchange.getOut(false);
        if (previousOut != null) {
            answer.getOut().copyFrom(previousOut);
        }
        return answer;
    }
    /**
     * Returns true if the given exchange should be logged in the trace list
     */
    protected boolean shouldTraceExchange(Exchange exchange) {
        return traceFilter == null || traceFilter.matches(exchange);
    }
}
"
org.apache.camel.processor.interceptor.Delayer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
/**
 * An interceptor strategy for delaying routes.
 */
public class Delayer implements InterceptStrategy {
    private boolean enabled = true;
    private long delay;
    public Delayer() {
    }
    public Delayer(long delay) {
        this.delay = delay;
    }
    /**
     * A helper method to return the Delayer instance for a given {@link org.apache.camel.CamelContext} if one is enabled
     *
     * @param context the camel context the delayer is connected to
     * @return the delayer or null if none can be found
     */
    public static DelayInterceptor getDelayer(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            List<InterceptStrategy> list = defaultCamelContext.getInterceptStrategies();
            for (InterceptStrategy interceptStrategy : list) {
                if (interceptStrategy instanceof DelayInterceptor) {
                    return (DelayInterceptor)interceptStrategy;
                }
            }
        }
        return null;
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target)
        throws Exception {
        DelayInterceptor delayer = new DelayInterceptor(processorType, target, this);
        return delayer;
    }
    public boolean isEnabled() {
        return enabled;
    }
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
}
"
org.apache.camel.processor.interceptor.DelayInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.DelayProcessorSupport;
/**
 * An interceptor for delaying routes.
 */
public class DelayInterceptor extends DelayProcessorSupport {
    private final ProcessorType node;
    private Delayer delayer;
    public DelayInterceptor(ProcessorType node, Processor target, Delayer delayer) {
        super(target);
        this.node = node;
        this.delayer = delayer;
    }
    @Override
    public String toString() {
        return ""DelayInterceptor[delay: "" + delayer.getDelay() + "" on: "" + node + ""]"";
    }
    public void delay(Exchange exchange) throws Exception {
        if (delayer.isEnabled()) {
            long time = currentSystemTime() + delayer.getDelay();
            waitUntil(time, exchange);
        }
    }
}
"
org.apache.camel.processor.interceptor.ExceptionEvent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * Represents an exception that occurred when processing an exchange
 *
 * @version $Revision: 673954 $
 */
public class ExceptionEvent {
    private final DebugInterceptor interceptor;
    private final Exchange exchange;
    private final Throwable exception;
    public ExceptionEvent(DebugInterceptor interceptor, Exchange exchange, Throwable exception) {
        this.interceptor = interceptor;
        this.exchange = exchange;
        this.exception = exception;
    }
    public Throwable getException() {
        return exception;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public DebugInterceptor getInterceptor() {
        return interceptor;
    }
}
"
org.apache.camel.processor.interceptor.ExchangeFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * A plugin used to turn an {@link Exchange} into a String
 * so it can be logged to a file
 *
 * @version $Revision: 696610 $
 */
public interface ExchangeFormatter {
    /**
     * Generates a string representation of the exchange
     */
    Object format(Exchange exchange);
}
"
org.apache.camel.processor.interceptor.SimulateFromEndpointUsingInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.InterceptStrategy;
/**
 * Using a interceptor to simulate setting the fromEndpointUri (we added in Camel 2.0)
 * from Camel 1.x.
 */
public class SimulateFromEndpointUsingInterceptorTest extends ContextTestSupport {
    public void testSimulateFromEndpointUri() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        mock.message(0).property(""fromEndpointUri"").equals(""direct:start"");
        template.sendBody(""direct:start"", ""Hello World"");
        assertMockEndpointsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                context.addInterceptStrategy(new MyFromEndpointInterceptor());
                from(""direct:start"").to(""log:foo"").to(""mock:result"");
            }
        };
    }
    /**
     * Interceptor strategy that is weaven in the route above and also a delegate processor so
     * we can continue processing the original Exchange after we have decorated and added the
     * from endpoint uri.
     */
    private final class MyFromEndpointInterceptor extends DelegateProcessor implements InterceptStrategy {
        private ProcessorType node;
        private MyFromEndpointInterceptor() {
        }
        private MyFromEndpointInterceptor(ProcessorType node, Processor target) {
            super(target);
            this.node = node;
        }
        public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
            return new MyFromEndpointInterceptor(processorType, target);
        }
        public void process(Exchange exchange) throws Exception {
            // compuate and set from endpoint uri
            if (exchange.getProperty(""fromEndpointUri"") == null) {
                ProcessorType parent = node.getParent();
                if (parent instanceof RouteType) {
                    RouteType rt = (RouteType)parent;
                    // note assumes that we only have one input (that is very common anyway)
                    String fromEndpointUri = rt.getInputs().get(0).getEndpoint().getEndpointUri();
                    exchange.setProperty(""fromEndpointUri"", fromEndpointUri);
                }
            }
            // must invoke the target to continue the routing
            getProcessor().process(exchange);
        }
    }
}
"
org.apache.camel.processor.interceptor.StreamCaching,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * {@link InterceptStrategy} implementation to configure stream caching on a RouteContext
 */
public final class StreamCaching implements InterceptStrategy {
    /*
     * Hide constructor -- instances will be created through static enable() methods
     */
    private StreamCaching() {
        super();
    }
    /**
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
        return new StreamCachingInterceptor(target);
    }
    /**
     * Enable stream caching for a RouteContext
     * 
     * @param context the route context
     */
    public static void enable(RouteContext context) {
        for (InterceptStrategy strategy : context.getInterceptStrategies()) {
            if (strategy instanceof StreamCaching) {
                return;
            }
        }
        context.addInterceptStrategy(new StreamCaching());
    }
}
"
org.apache.camel.processor.interceptor.StreamCachingInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.InterceptorType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.MessageHelper;
/**
 * {@link DelegateProcessor} that converts a message into a re-readable format
 */
public class StreamCachingInterceptor extends DelegateProcessor implements AsyncProcessor {
    public StreamCachingInterceptor() {
        super();
    }
    public StreamCachingInterceptor(Processor processor) {
        this();
        setProcessor(processor);
    }
    @Override
    public String toString() {
        return ""StreamCachingInterceptor("" + processor + "")"";
    }
    /**
     * Remove the {@link StreamCachingInterceptor} type of interceptor from the given list of interceptors
     *
     * @param interceptors the list of interceptors
     */
    public static void noStreamCaching(List<InterceptorType> interceptors) {
        for (int i = 0; i < interceptors.size(); i++) {
            InterceptorType interceptor = interceptors.get(i);
            if (interceptor instanceof InterceptorRef
                && ((InterceptorRef)interceptor).getInterceptor() instanceof StreamCachingInterceptor) {
                interceptors.remove(interceptor);
            }
        }
    }
    @Override
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        try {
            StreamCache newBody = exchange.getIn().getBody(StreamCache.class);
            if (newBody != null) {
                exchange.getIn().setBody(newBody);
            }
            MessageHelper.resetStreamCache(exchange.getIn());
        } catch (NoTypeConversionAvailableException ex) {
            // ignore if in is not of StreamCache type
        }
        return proceed(exchange, callback);
    } 
    public boolean proceed(Exchange exchange, AsyncCallback callback) {
        if (getProcessor() instanceof AsyncProcessor) {
            return ((AsyncProcessor) getProcessor()).process(exchange, callback);
        } else {
            try {
                processor.process(exchange);
            } catch (Throwable e) {
                exchange.setException(e);
            }
            // false means processing of the exchange asynchronously,
            callback.done(true);
            return true;
        }
    }
}
"
org.apache.camel.processor.interceptor.StreamCachingInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.StringReader;
import java.util.LinkedList;
import java.util.List;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.converter.jaxp.BytesSource;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.InterceptorType;
import org.apache.camel.processor.DelegateProcessor;
public class StreamCachingInterceptorTest extends ContextTestSupport {
    private static final String MESSAGE = ""<hello>world!</hello>"";
    private static final String BODY_TYPE = ""body.type"";
    private MockEndpoint a;
    private MockEndpoint b;
    private final XmlConverter converter = new XmlConverter();
    public void testConvertStreamSourceWithRouteBuilderStreamCaching() throws Exception {
        a.expectedMessageCount(1);
        StreamSource message = new StreamSource(new StringReader(MESSAGE));
        template.sendBody(""direct:a"", message);
        assertMockEndpointsSatisfied();
        assertTrue(a.assertExchangeReceived(0).getIn().getBody() instanceof StreamCache);
    }
    public void testNoConversionForOtherXmlSourceTypes() throws Exception {
        a.expectedMessageCount(3);
        send(converter.toDOMSource(MESSAGE));
        send(new StringSource(MESSAGE));
        send(new BytesSource(MESSAGE.getBytes()));
        assertMockEndpointsSatisfied();
        for (Exchange exchange : a.getExchanges()) {
            assertFalse(exchange.getIn().getHeader(BODY_TYPE, Class.class).toString() + "" shouldn't have been converted to StreamCache"", 
                        exchange.getIn().getBody() instanceof StreamCache);
        }        
    }
    private void send(Source source) {
        template.sendBodyAndHeader(""direct:a"", source, BODY_TYPE, source.getClass());
    }
    public void testConvertStreamSourceWithRouteOnlyStreamCaching() throws Exception {
        b.expectedMessageCount(1);
        StreamSource message = new StreamSource(new StringReader(MESSAGE));
        template.sendBody(""direct:b"", message);
        assertMockEndpointsSatisfied();
        assertTrue(b.assertExchangeReceived(0).getIn().getBody() instanceof StreamCache);
        assertEquals(b.assertExchangeReceived(0).getIn().getBody(String.class), MESSAGE);
    }
    public void testConvertInputStreamWithRouteBuilderStreamCaching() throws Exception {
        a.expectedMessageCount(1);
        InputStream message = new ByteArrayInputStream(MESSAGE.getBytes());
        template.sendBody(""direct:a"", message);
        assertMockEndpointsSatisfied();
        assertTrue(a.assertExchangeReceived(0).getIn().getBody() instanceof StreamCache);
        assertEquals(a.assertExchangeReceived(0).getIn().getBody(String.class), MESSAGE);
    }
    public void testIgnoreAlreadyRereadable() throws Exception {
        a.expectedMessageCount(1);
        template.sendBody(""direct:a"", MESSAGE);
        assertMockEndpointsSatisfied();
        assertTrue(a.assertExchangeReceived(0).getIn().getBody() instanceof String);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                //Stream caching for a single route...
                from(""direct:a"").streamCaching().to(""mock:a"");
                //... or for all the following routes in this builder
                streamCaching();
                from(""direct:b"").to(""mock:b"");
            }
        };
    }
    public void testNoStreamCaching() throws Exception {
        List<InterceptorType> interceptors = new LinkedList<InterceptorType>();
        InterceptorRef streamCache = new InterceptorRef(new StreamCachingInterceptor());
        interceptors.add(streamCache);
        interceptors.add(new InterceptorRef(new DelegateProcessor()));
        StreamCachingInterceptor.noStreamCaching(interceptors);
        assertEquals(1, interceptors.size());
        assertFalse(interceptors.contains(streamCache));
    }
}
"
org.apache.camel.processor.interceptor.StreamCachingTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Test cases for {@link StreamCaching}
 */
public class StreamCachingTest extends ContextTestSupport {
    /**
     * Tests enabling stream caching on a {@link RouteContext}
     */
    public void testEnableOnRouteContext() throws Exception {
        RouteContext rc = new DefaultRouteContext(super.context);
        StreamCaching.enable(rc);
        assertStrategyEnabled(""Enabling StreamCaching should add it to the intercept strategies"", rc);
        StreamCaching.enable(rc);
        assertStrategyEnabled(""Enabling it again should not add a second instance"", rc);
    }
    /*
     * Assert that the strategy is enabled exactly one time
     */
    private void assertStrategyEnabled(String message, RouteContext rc) {
        int count = 0;
        for (InterceptStrategy strategy : rc.getInterceptStrategies()) {
            if (strategy instanceof StreamCaching) {
                count++;
            }
        }
        assertEquals(message, 1, count);
    }
}
"
org.apache.camel.processor.interceptor.TraceFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 733817 $
 */
public class TraceFormatter {
    private int breadCrumbLength;
    private int nodeLength;
    private boolean showBreadCrumb = true;
    private boolean showNode = true;
    private boolean showExchangeId;
    private boolean showShortExchangeId;
    private boolean showExchangePattern = true;
    private boolean showProperties = true;
    private boolean showHeaders = true;
    private boolean showBody = true;
    private boolean showBodyType = true;
    private boolean showOutBody;
    private boolean showOutBodyType;
    private boolean showException = true;
    public Object format(TraceInterceptor interceptor, Exchange exchange) {
        Message in = exchange.getIn();
        // false because we don't want to introduce side effects
        Message out = exchange.getOut(false); 
        Throwable exception = exchange.getException();
        StringBuilder sb = new StringBuilder();
        sb.append(getExchangeAndNode(interceptor, exchange));
        if (showExchangePattern) {
            sb.append("", Pattern:"").append(exchange.getPattern()).append("" "");
        }
        // only show properties if we have any
        if (showProperties && !exchange.getProperties().isEmpty()) {
            sb.append("", Properties:"").append(exchange.getProperties()).append("" "");
        }
        // only show headers if we have any
        if (showHeaders && !in.getHeaders().isEmpty()) {
            sb.append("", Headers:"").append(in.getHeaders()).append("" "");
        }
        if (showBodyType) {
            sb.append("", BodyType:"").append(getBodyTypeAsString(in)).append("" "");
        }
        if (showBody) {
            sb.append("", Body:"").append(getBodyAsString(in)).append("" "");
        }
        if (showOutBodyType && out != null) {
            sb.append("", OutBodyType:"").append(getBodyTypeAsString(out)).append("" "");
        }
        if (showOutBody && out != null) {
            sb.append("", OutBody:"").append(getBodyAsString(out)).append("" "");
        }        
        if (showException && exception != null) {
            sb.append("", Exception:"").append(exception);
        }
        return sb.toString();
    }
    public boolean isShowBody() {
        return showBody;
    }
    public void setShowBody(boolean showBody) {
        this.showBody = showBody;
    }
    public boolean isShowBodyType() {
        return showBodyType;
    }
    public void setShowBodyType(boolean showBodyType) {
        this.showBodyType = showBodyType;
    }
    public void setShowOutBody(boolean showOutBody) {
        this.showOutBody = showOutBody;
    }
    public boolean isShowOutBody() {
        return showOutBody;
    }    
    public void setShowOutBodyType(boolean showOutBodyType) {
        this.showOutBodyType = showOutBodyType;
    }
    public boolean isShowOutBodyType() {
        return showOutBodyType;
    }    
    public boolean isShowBreadCrumb() {
        return showBreadCrumb;
    }
    public void setShowBreadCrumb(boolean showBreadCrumb) {
        this.showBreadCrumb = showBreadCrumb;
    }
    public boolean isShowExchangeId() {
        return showExchangeId;
    }
    public void setShowExchangeId(boolean showExchangeId) {
        this.showExchangeId = showExchangeId;
    }
    public boolean isShowHeaders() {
        return showHeaders;
    }
    public void setShowHeaders(boolean showHeaders) {
        this.showHeaders = showHeaders;
    }
    public boolean isShowProperties() {
        return showProperties;
    }
    public void setShowProperties(boolean showProperties) {
        this.showProperties = showProperties;
    }
    public boolean isShowNode() {
        return showNode;
    }
    public void setShowNode(boolean showNode) {
        this.showNode = showNode;
    }
    public boolean isShowExchangePattern() {
        return showExchangePattern;
    }
    public void setShowExchangePattern(boolean showExchangePattern) {
        this.showExchangePattern = showExchangePattern;
    }
    public boolean isShowException() {
        return showException;
    }
    public void setShowException(boolean showException) {
        this.showException = showException;
    }
    public int getBreadCrumbLength() {
        return breadCrumbLength;
    }
    public void setBreadCrumbLength(int breadCrumbLength) {
        this.breadCrumbLength = breadCrumbLength;
    }
    public boolean isShowShortExchangeId() {
        return showShortExchangeId;
    }
    public void setShowShortExchangeId(boolean showShortExchangeId) {
        this.showShortExchangeId = showShortExchangeId;
    }
    public int getNodeLength() {
        return nodeLength;
    }
    public void setNodeLength(int nodeLength) {
        this.nodeLength = nodeLength;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Object getBreadCrumbID(Exchange exchange) {
        UnitOfWork unitOfWork = exchange.getUnitOfWork();
        return unitOfWork.getId();
    }
    protected Object getBodyAsString(Message in) {
        if (in == null) {
            return null;
        }
        StreamCache newBody = null;
        try {
            newBody = in.getBody(StreamCache.class);
            if (newBody != null) {
                in.setBody(newBody);
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore, in not of StreamCache type
        }
        Object answer = null;
        try {
            answer = in.getBody(String.class);
        } catch (NoTypeConversionAvailableException ex) {
            answer = in.getBody();
        }
        if (newBody != null) {
            // Reset the InputStreamCache
            newBody.reset();
        }
        return answer;
    }
    protected Object getBodyTypeAsString(Message message) {
        if (message == null) {
            return null;
        }
        String answer = ObjectHelper.classCanonicalName(message.getBody());
        if (answer != null && answer.startsWith(""java.lang."")) {
            return answer.substring(10);
        }
        return answer;
    }
    protected String getNodeMessage(TraceInterceptor interceptor) {
        String message = interceptor.getNode().getShortName() + ""("" + interceptor.getNode().getLabel() + "")"";
        if (nodeLength > 0) {
            return String.format(""%1$-"" + nodeLength + ""."" + nodeLength + ""s"", message);
        } else {
            return message;
        }
    }
    /**
     * Returns the exchange id and node, ordered based on whether this was a trace of
     * an exchange coming out of or into a processing step. For example, 
     * <br/><tt>transform(body) -> ID-mojo/39713-1225468755256/2-0</tt>
     * <br/>or
     * <br/><tt>ID-mojo/39713-1225468755256/2-0 -> transform(body)</tt>
     */
    protected String getExchangeAndNode(TraceInterceptor interceptor, Exchange exchange) {
        String id = """";
        String node = """";
        String result;
        if (!showBreadCrumb && !showExchangeId && !showShortExchangeId && !showNode) {
            return """";
        }
        if (showBreadCrumb) {
            id = getBreadCrumbID(exchange).toString();
        } else if (showExchangeId || showShortExchangeId) {
            id = getBreadCrumbID(exchange).toString();
            if (showShortExchangeId) {
                // skip hostname for short exchange id
                id = id.substring(id.indexOf(""/"") + 1);
            }
        }
        if (showNode) {
            node = getNodeMessage(interceptor);
        }
        if (interceptor.shouldTraceOutExchanges() && exchange.getOut(false) != null) {
            result = node.trim() + "" -> "" + id.trim();
        } else {
            result = id.trim() + "" -> "" + node.trim();
        }
        if (breadCrumbLength > 0) {
            // we want to ensure text coming after this is aligned for readability
            return String.format(""%1$-"" + breadCrumbLength + ""."" + breadCrumbLength + ""s"", result).trim();
        } else {
            return result.trim();
        }
    }
}
"
org.apache.camel.processor.interceptor.TraceInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.commons.logging.LogFactory;
/**
 * An interceptor for debugging and tracing routes
 *
 * @version $Revision: 710133 $
 */
public class TraceInterceptor extends DelegateProcessor implements ExchangeFormatter {
    private Logger logger;
    private final ProcessorType node;
    private final Tracer tracer;
    private TraceFormatter formatter;
    public TraceInterceptor(ProcessorType node, Processor target, TraceFormatter formatter, Tracer tracer) {
        super(target);
        this.tracer = tracer;
        this.node = node;
        this.formatter = formatter;
        // set logger to use
        if (tracer.getLogName() != null) {
            logger = new Logger(LogFactory.getLog(tracer.getLogName()), this);
        } else {
            // use default logger
            logger = new Logger(LogFactory.getLog(TraceInterceptor.class), this);
        }
        // set logging level if provided
        if (tracer.getLogLevel() != null) {
            logger.setLevel(tracer.getLogLevel());
        }
        if (tracer.getFormatter() != null) {
            this.formatter = tracer.getFormatter();
        }
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TraceInterceptor(ProcessorType node, Processor target, TraceFormatter formatter) {
        this(node, target, formatter, new Tracer());
    }
    public TraceInterceptor(ProcessorType node, Processor target, Tracer tracer) {
        this(node, target, null, tracer);
    }
    @Override
    public String toString() {
        return ""TraceInterceptor["" + node + ""]"";
    }
    public void process(final Exchange exchange) throws Exception {
        try {
            if (shouldLogNode(node) && shouldLogExchange(exchange)) {
                logExchange(exchange);
            }
            super.proceed(exchange);
            if (tracer.isTraceOutExchanges() && shouldLogNode(node) && shouldLogExchange(exchange)) {
                logExchange(exchange);
            }            
        } catch (Exception e) {
            if (shouldLogException(exchange)) {
                logException(exchange, e);
            }
            throw e;
        }
    }
    public Object format(Exchange exchange) {
        return formatter.format(this, exchange);
    }
    // Properties
    //-------------------------------------------------------------------------
    public ProcessorType getNode() {
        return node;
    }
    public Logger getLogger() {
        return logger;
    }
    public TraceFormatter getFormatter() {
        return formatter;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void logExchange(Exchange exchange) {
        logger.process(exchange);
    }
    protected void logException(Exchange exchange, Throwable throwable) {
        if (tracer.isTraceExceptions()) {
            logger.process(exchange, throwable);
        }
    }
    /**
     * Returns true if the given exchange should be logged in the trace list
     */
    protected boolean shouldLogExchange(Exchange exchange) {
        return (tracer == null || tracer.isEnabled())
            && (tracer.getTraceFilter() == null || tracer.getTraceFilter().matches(exchange));
    }
    /**
     * Returns true if the given exchange should be logged when an exception was thrown
     */
    protected boolean shouldLogException(Exchange exchange) {
        return tracer.isTraceExceptions();
    }
    /**
     * Returns whether exchanges coming out of processors should be traced
     */   
    public boolean shouldTraceOutExchanges() {
        return tracer.isTraceOutExchanges();
    }
    /**
     * Returns true if the given node should be logged in the trace list
     */
    protected boolean shouldLogNode(ProcessorType node) {
        if (node == null) {
            return false;
        }
        if (!tracer.isTraceInterceptors() && (node instanceof InterceptStrategy || node instanceof InterceptorRef)) {
            return false;
        }
        return true;
    }
}
"
org.apache.camel.processor.interceptor.TraceInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.easymock.classextension.EasyMock;
public class TraceInterceptorTest extends ContextTestSupport {
    private TraceFormatter formatter;
    private Tracer tracer;
    @Override
    protected void setUp() throws Exception {
        formatter = EasyMock.createMock(TraceFormatter.class);
        tracer = new Tracer();
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                tracer.setFormatter(formatter);
                getContext().addInterceptStrategy(tracer);
                from(""direct:a"").to(""mock:a"");
            }
        };
    }
    public void testTracerInterceptor() throws Exception {
        EasyMock.reset(formatter);
        formatter.format(EasyMock.isA(TraceInterceptor.class), EasyMock.isA(Exchange.class));
        EasyMock.expectLastCall().andReturn(""Test"").atLeastOnce();
        EasyMock.replay(formatter);
        template.sendBody(""direct:a"", ""<hello>world!</hello>"");
        EasyMock.verify(formatter);
    }
    public void testTracerDisabledInterceptor() throws Exception {
        tracer.setEnabled(false);
        try {
            testTracerInterceptor();
            fail(""The tracer should not work"");
        } catch (Throwable ex) {
            assertTrue(""ex should AssertionError"", ex instanceof AssertionError);
        }
    }
}
"
org.apache.camel.processor.interceptor.Tracer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
/**
 * An interceptor strategy for tracing routes
 *
 * @version $Revision: 719456 $
 */
public class Tracer implements InterceptStrategy {
    private TraceFormatter formatter = new TraceFormatter();
    private boolean enabled = true;
    private String logName;
    private LoggingLevel logLevel;
    private Predicate<Exchange> traceFilter;
    private boolean traceInterceptors;
    private boolean traceExceptions = true;
    private boolean traceOutExchanges;
    /**
     * A helper method to return the Tracer instance for a given {@link CamelContext} if one is enabled
     *
     * @param context the camel context the tracer is connected to
     * @return the tracer or null if none can be found
     */
    public static Tracer getTracer(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            List<InterceptStrategy> list = defaultCamelContext.getInterceptStrategies();
            for (InterceptStrategy interceptStrategy : list) {
                if (interceptStrategy instanceof Tracer) {
                    return (Tracer)interceptStrategy;
                }
            }
        }
        return null;
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
        // Force the creation of an id, otherwise the id is not available when the trace formatter is
        // outputting trace information
        String id = processorType.idOrCreate();
        return new TraceInterceptor(processorType, target, this);
    }
    public TraceFormatter getFormatter() {
        return formatter;
    }
    public void setFormatter(TraceFormatter formatter) {
        this.formatter = formatter;
    }
    public void setEnabled(boolean flag) {
        enabled = flag;
    }
    public boolean isEnabled() {
        return enabled;
    }
    public boolean isTraceInterceptors() {
        return traceInterceptors;
    }
    /**
     * Sets whether interceptors should be traced or not
     */
    public void setTraceInterceptors(boolean traceInterceptors) {
        this.traceInterceptors = traceInterceptors;
    }
    public Predicate getTraceFilter() {
        return traceFilter;
    }
    /**
     * Sets a predicate to be used as filter when tracing
     */
    public void setTraceFilter(Predicate traceFilter) {
        this.traceFilter = traceFilter;
    }
    public LoggingLevel getLogLevel() {
        return logLevel;
    }
    /**
     * Sets the logging level to output tracing. Will use <tt>INFO</tt> level by default.
     */
    public void setLogLevel(LoggingLevel logLevel) {
        this.logLevel = logLevel;
    }
    public boolean isTraceExceptions() {
        return traceExceptions;
    }
    /**
     * Sets whether thrown exceptions should be traced
     */
    public void setTraceExceptions(boolean traceExceptions) {
        this.traceExceptions = traceExceptions;
    }
    public String getLogName() {
        return logName;
    }
    /**
     * Sets the logging name to use.
     * Will default use <tt>org.apache.camel.processor.interceptor.TraceInterceptor<tt>.
     */
    public void setLogName(String logName) {
        this.logName = logName;
    }
    /**
     * Sets whether exchanges coming out of processors should be traced
     */    
    public void setTraceOutExchanges(boolean traceOutExchanges) {
        this.traceOutExchanges = traceOutExchanges;
    }
    public boolean isTraceOutExchanges() {
        return traceOutExchanges;
    }
}
"
org.apache.camel.processor.loadbalancer.LoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Processor;
/**
 * A strategy for load balancing across a number of {@link Processor} instances
 *
 * @version $Revision: 724684 $
 */
public interface LoadBalancer extends AsyncProcessor {
    /**
     * Adds a new processor to the load balancer
     *
     * @param processor the processor to be added to the load balancer
     */
    void addProcessor(Processor processor);
    /**
     * Removes the given processor from the load balancer
     *
     * @param processor the processor to be removed from the load balancer
     */
    void removeProcessor(Processor processor);
    /**
     * Returns the current processors available to this load balancer
     *
     * @return the processors available
     */
    List<Processor> getProcessors();
}
"
org.apache.camel.processor.loadbalancer.LoadBalancerConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * Represents a consumer which on starting registers itself with a {@link LoadBalancer} and on closing unregisters
 * itself with a load balancer
 *
 * @version $Revision: 640438 $
 */
public class LoadBalancerConsumer extends DefaultConsumer<Exchange> {
    private final LoadBalancer loadBalancer;
    public LoadBalancerConsumer(Endpoint endpoint, Processor processor, LoadBalancer loadBalancer) {
        super(endpoint, processor);
        this.loadBalancer = loadBalancer;
    }
    @Override
    protected void doStart() throws Exception {
        loadBalancer.addProcessor(getProcessor());
    }
    @Override
    protected void doStop() throws Exception {
        loadBalancer.removeProcessor(getProcessor());
    }
}
"
org.apache.camel.processor.loadbalancer.LoadBalancerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * A default base class for a {@link LoadBalancer} implementation
 *
 * @version $Revision: 630568 $
 */
public abstract class LoadBalancerSupport extends ServiceSupport implements LoadBalancer {
    private List<Processor> processors = new CopyOnWriteArrayList<Processor>();
    public void addProcessor(Processor processor) {
        processors.add(processor);
    }
    public void removeProcessor(Processor processor) {
        processors.remove(processor);
    }
    public List<Processor> getProcessors() {
        return processors;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);        
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);       
    }
}
"
org.apache.camel.processor.loadbalancer.QueueLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A base class for {@link LoadBalancer} implementations which choose a single
 * destination for each exchange (rather like JMS Queues)
 * 
 * @version $Revision: 724684 $
 */
public abstract class QueueLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        if (list.isEmpty()) {
            throw new IllegalStateException(""No processors available to process "" + exchange);
        }
        Processor processor = chooseProcessor(list, exchange);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
        } else {
            processor.process(exchange);
        }
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        boolean sync = false;
        List<Processor> list = getProcessors();
        if (list.isEmpty()) {
            throw new IllegalStateException(""No processors available to process "" + exchange);
        }
        Processor processor = chooseProcessor(list, exchange);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
        } else {
            if (processor instanceof AsyncProcessor) {
                AsyncProcessor asyncProcessor = (AsyncProcessor)processor;
                sync = asyncProcessor.process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        // Only handle the async case...
                        if (sync) {
                            return;
                        } else {
                            callback.done(sync);                        
                        }
                    }
                });                
            } else {
                try {
                    processor.process(exchange);
                } catch (Exception ex) {
                    exchange.setException(ex);
                }
                callback.done(false);                
            }            
        }
        return sync;
    }
    protected abstract Processor chooseProcessor(List<Processor> processors, Exchange exchange);
}
"
org.apache.camel.processor.loadbalancer.RandomLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the random load balancing policy
 *
 * @version $Revision: 630568 $
 */
public class RandomLoadBalancer extends QueueLoadBalancer {
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        while (true) {
            int index = (int) Math.round(Math.random() * size);
            if (index < size) {
                return processors.get(index);
            }
        }
    }
}
"
org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the round robin load balancing policy
 *
 * @version $Revision: 630568 $
 */
public class RoundRobinLoadBalancer extends QueueLoadBalancer {
    private int counter = -1;
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        if (++counter >= size) {
            counter = 0;
        }
        return processors.get(counter);
    }
}
"
org.apache.camel.processor.loadbalancer.StickyLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
/**
 * Implements a sticky load balancer using an {@link Expression} to calculate
 * a correlation key to perform the sticky load balancing; rather like jsessionid in the web
 * or JMSXGroupID in JMS.
 *
 * @version $Revision: 659849 $
 */
public class StickyLoadBalancer extends QueueLoadBalancer {
    private Expression<Exchange> correlationExpression;
    private QueueLoadBalancer loadBalancer;
    private int numberOfHashGroups = 64 * 1024;
    private final Map<Object, Processor> stickyMap = new HashMap<Object, Processor>();
    public StickyLoadBalancer() {
        this.loadBalancer = new RoundRobinLoadBalancer();
    }
    public StickyLoadBalancer(Expression<Exchange> correlationExpression) {
        this(correlationExpression, new RoundRobinLoadBalancer());
    }
    public StickyLoadBalancer(Expression<Exchange> correlationExpression, QueueLoadBalancer loadBalancer) {
        this.correlationExpression = correlationExpression;
        this.loadBalancer = loadBalancer;
    }
    public void setCorrelationExpression(Expression<Exchange> correlationExpression) {
        this.correlationExpression = correlationExpression;
    }
    public void setLoadBalancer(QueueLoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        Object value = correlationExpression.evaluate(exchange);
        Object key = getStickyKey(value);
        Processor processor;
        synchronized (stickyMap) {
            processor = stickyMap.get(key);
            if (processor == null) {
                processor = loadBalancer.chooseProcessor(processors, exchange);
                stickyMap.put(key, processor);
            }
        }
        return processor;
    }
    @Override
    public void removeProcessor(Processor processor) {
        synchronized (stickyMap) {
            Iterator<Map.Entry<Object, Processor>> iter = stickyMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<Object, Processor> entry = iter.next();
                if (processor.equals(entry.getValue())) {
                    iter.remove();
                }
            }
        }
        super.removeProcessor(processor);
    }
    // Properties
    //-------------------------------------------------------------------------
    public int getNumberOfHashGroups() {
        return numberOfHashGroups;
    }
    public void setNumberOfHashGroups(int numberOfHashGroups) {
        this.numberOfHashGroups = numberOfHashGroups;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * A strategy to create the key for the sticky load balancing map.
     * The default implementation uses the hash code of the value
     * then modulos by the numberOfHashGroups to avoid the sticky map getting too big
     *
     * @param value the correlation value
     * @return the key to be used in the sticky map
     */
    protected Object getStickyKey(Object value) {
        int hashCode = 37;
        if (value != null) {
            hashCode = value.hashCode();
        }
        if (numberOfHashGroups > 0) {
            hashCode = hashCode % numberOfHashGroups;
        }
        return hashCode;
    }
}
"
org.apache.camel.processor.loadbalancer.TopicLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A {@link LoadBalancer} implementations which sends to all destinations
 * (rather like JMS Topics). 
 * 
 * @version $Revision: 736571 $
 *
 */
public class TopicLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        for (Processor processor : list) {
            Exchange copy = copyExchangeStrategy(processor, exchange);
            processor.process(copy);
        }
    }
    /**
     * Strategy method to copy the exchange before sending to another endpoint.
     * Derived classes such as the {@link org.apache.camel.processor.Pipeline Pipeline}
     * will not clone the exchange
     * 
     * @param processor the processor that will send the exchange
     * @param exchange  the exchange
     * @return the current exchange if no copying is required such as for a
     *         pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {
        return exchange.copy();
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        List<Processor> list = getProcessors();
        for (Processor processor : list) {
            Exchange copy = copyExchangeStrategy(processor, exchange);
            try {
                processor.process(copy);
            } catch (Exception ex) {
                // We don't handle the exception here
            }
        }
        callback.done(false);
        return false;
    }
}
"
org.apache.camel.processor.resequencer.DefaultExchangeComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * Compares elements of an {@link Exchange} sequence by comparing
 * <code>long</code> values returned by this comaprator's
 * <code>expression</code>. The expression is set during route definition
 * e.g.
 * 
 * <pre>
 *    ...resequencer(header(&quot;seqnum&quot;)).stream()...
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630591 $
 */
public class DefaultExchangeComparator implements ExpressionResultComparator<Exchange> {
    private Expression<Exchange> expression;
    public Expression<Exchange> getExpression() {
        return expression;
    }
    public void setExpression(Expression<Exchange> expression) {
        this.expression = expression;
    }
    @SuppressWarnings(""unchecked"")
    public void setExpressions(List<Expression> expressions) {
        if (expressions.isEmpty()) {
            throw new IllegalArgumentException(
                    ""Expression required to resolve sequence number"");
        } else if (expressions.size() > 1) {
            throw new IllegalArgumentException(
                    ""More than one expression currently not supported"");
        }
        expression = expressions.get(0);
    }
    public boolean predecessor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n1 == (n2 - 1L);
    }
    public boolean successor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n2 == (n1 - 1L);
    }
    public int compare(Exchange o1, Exchange o2) {
        Long n1 = getSequenceNumber(o1);
        Long n2 = getSequenceNumber(o2);
        return n1.compareTo(n2);
    }
    private long getSequenceNumber(Exchange exchange) {
        return (Long)expression.evaluate(exchange);
    }
}
"
org.apache.camel.processor.resequencer.Element,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A container for objects to be resequenced. This container can be scheduled
 * for timing out. Non-scheduled objects or already timed-out objects are ready
 * for being released by the {@link ResequencerEngine}.
 * 
 * @author Martin Krasser
 */
class Element<E> implements TimeoutHandler {
    /**
     * The contained object.
     */
    private E object;
    /**
     * Not <code>null</code> if this element is currently beeing scheduled for
     * timing out.
     */
    private Timeout timeout;
    /**
     * Creates a new container instance.
     * 
     * @param object contained object.
     */
    public Element(E object) {
        this.object = object;
    }
    /**
     * Returns the contained object.
     * 
     * @return the contained object.
     */
    public E getObject() {
        return object;
    }
    /**
     * Returns <code>true</code> if this element is currently scheduled for
     * timing out.
     * 
     * @return <code>true</code> if scheduled or <code>false</code> if not
     *         scheduled or already timed-out.
     */
    public synchronized boolean scheduled() {
        return timeout != null;
    }
    /**
     * Schedules the given timeout task. Before this methods calls the
     * {@link Timeout#schedule()} method it sets this element as timeout
     * listener.
     * 
     * @param t a timeout task.
     */
    public synchronized void schedule(Timeout t) {
        this.timeout = t;
        this.timeout.setTimeoutHandler(this);
        this.timeout.schedule();
    }
    /**
     * Cancels the scheduled timeout for this element. If this element is not
     * scheduled or has already timed-out this method has no effect.
     */
    public synchronized void cancel() {
        if (timeout != null) {
            timeout.cancel();
        }
        timeout(null);
    }
    /**
     * Marks this element as timed-out.
     * 
     * @param t timeout task that caused the notification.
     */
    public synchronized void timeout(Timeout t) {
        this.timeout = null;
    }
}
"
org.apache.camel.processor.resequencer.ElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A strategy for comparing {@link Element} instances. This strategy uses
 * another {@link SequenceElementComparator} instance for comparing elements
 * contained by {@link Element} instances.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
class ElementComparator<E> implements SequenceElementComparator<Element<E>> {
    /**
     * A sequence element comparator this comparator delegates to.
     */
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new element comparator instance.
     * 
     * @param comparator a sequence element comparator this comparator delegates
     *        to.
     */
    public ElementComparator(SequenceElementComparator<E> comparator) {
        this.comparator = comparator;
    }
    /**
     * @see SequenceElementComparator#predecessor(java.lang.Object, java.lang.Object)
     */
    public boolean predecessor(Element<E> o1, Element<E> o2) {
        return comparator.predecessor(o1.getObject(), o2.getObject());
    }
    /**
     * @see SequenceElementComparator#successor(java.lang.Object, java.lang.Object)
     */
    public boolean successor(Element<E> o1, Element<E> o2) {
        return comparator.successor(o1.getObject(), o2.getObject());
    }
    /**
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    public int compare(Element<E> o1, Element<E> o2) {
        return comparator.compare(o1.getObject(), o2.getObject());
    }
}
"
org.apache.camel.processor.resequencer.ExpressionResultComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A {@link SequenceElementComparator} that compares {@link Exchange}s based on
 * the result of an expression evaluation.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630591 $
 */
public interface ExpressionResultComparator<E extends Exchange> extends SequenceElementComparator<E> {
    /**
     * Sets the list expressions used for comparing {@link Exchange}s.
     * 
     * @param expressions a list of {@link Expression} objects.
     */
    void setExpressions(List<Expression> expressions);
}
"
org.apache.camel.processor.resequencer.IntegerComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
public class IntegerComparator implements SequenceElementComparator<Integer> {
    public boolean predecessor(Integer o1, Integer o2) {
        return o1.intValue() == (o2.intValue() - 1);
    }
    public boolean successor(Integer o1, Integer o2) {
        return o2.intValue() == (o1.intValue() - 1);
    }
    public int compare(Integer o1, Integer o2) {
        return o1.compareTo(o2);
    }
}
"
org.apache.camel.processor.resequencer.ResequencerEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Timer;
/**
 * Resequences elements based on a given {@link SequenceElementComparator}.
 * This resequencer is designed for resequencing element streams. Stream-based
 * resequencing has the advantage that the number of elements to be resequenced
 * need not be known in advance. Resequenced elements are delivered via a
 * {@link SequenceSender}.
 * <p>
 * The resequencer's behaviour for a given comparator is controlled by the
 * <code>timeout</code> property. This is the timeout (in milliseconds) for a
 * given element managed by this resequencer. An out-of-sequence element can
 * only be marked as <i>ready-for-delivery</i> if it either times out or if it
 * has an immediate predecessor (in that case it is in-sequence). If an
 * immediate predecessor of a waiting element arrives the timeout task for the
 * waiting element will be cancelled (which marks it as <i>ready-for-delivery</i>).
 * <p>
 * If the maximum out-of-sequence time difference between elements within a
 * stream is known, the <code>timeout</code> value should be set to this
 * value. In this case it is guaranteed that all elements of a stream will be
 * delivered in sequence via the {@link SequenceSender}. The lower the
 * <code>timeout</code> value is compared to the out-of-sequence time
 * difference between elements within a stream the higher the probability is for
 * out-of-sequence elements delivered by this resequencer. Delivery of elements
 * must be explicitly triggered by applications using the {@link #deliver()} or
 * {@link #deliverNext()} methods. Only elements that are <i>ready-for-delivery</i>
 * are delivered by these methods. The longer an application waits to trigger a
 * delivery the more elements may become <i>ready-for-delivery</i>.
 * <p>
 * The resequencer remembers the last-delivered element. If an element arrives
 * which is the immediate successor of the last-delivered element it is
 * <i>ready-for-delivery</i> immediately. After delivery the last-delivered
 * element is adjusted accordingly. If the last-delivered element is
 * <code>null</code> i.e. the resequencer was newly created the first arriving
 * element needs <code>timeout</code> milliseconds in any case for becoming
 * <i>ready-for-delivery</i>.
 * <p>
 *
 * @author Martin Krasser
 *
 * @version $Revision: 710133 $
 */
public class ResequencerEngine<E> {
    /**
     * The element that most recently hash been delivered or <code>null</code>
     * if no element has been delivered yet.
     */
    private Element<E> lastDelivered;
    /**
     * Minimum amount of time to wait for out-of-sequence elements.
     */
    private long timeout;
    /**
     * A sequence of elements for sorting purposes.
     */
    private Sequence<Element<E>> sequence;
    /**
     * A timer for scheduling timeout notifications.
     */
    private Timer timer;
    /**
     * A strategy for sending sequence elements.
     */
    private SequenceSender<E> sequenceSender;
    /**
     * Creates a new resequencer instance with a default timeout of 2000
     * milliseconds.
     *
     * @param comparator a sequence element comparator.
     */
    public ResequencerEngine(SequenceElementComparator<E> comparator) {
        this.sequence = createSequence(comparator);
        this.timeout = 2000L;
        this.lastDelivered = null;
    }
    public void start() {
        timer = new Timer(""Stream Resequencer Timer"");
    }
    /**
     * Stops this resequencer (i.e. this resequencer's {@link Timer} instance).
     */
    public void stop() {
        timer.cancel();
    }
    /**
     * Returns the number of elements currently maintained by this resequencer.
     *
     * @return the number of elements currently maintained by this resequencer.
     */
    public synchronized int size() {
        return sequence.size();
    }
    /**
     * Returns this resequencer's timeout value.
     *
     * @return the timeout in milliseconds.
     */
    public long getTimeout() {
        return timeout;
    }
    /**
     * Sets this sequencer's timeout value.
     *
     * @param timeout the timeout in milliseconds.
     */
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    /**
     * Returns the sequence sender.
     *
     * @return the sequence sender.
     */
    public SequenceSender<E> getSequenceSender() {
        return sequenceSender;
    }
    /**
     * Sets the sequence sender.
     *
     * @param sequenceSender a sequence element sender.
     */
    public void setSequenceSender(SequenceSender<E> sequenceSender) {
        this.sequenceSender = sequenceSender;
    }
    /**
     * Returns the last delivered element.
     *
     * @return the last delivered element or <code>null</code> if no delivery
     *         has been made yet.
     */
    E getLastDelivered() {
        if (lastDelivered == null) {
            return null;
        }
        return lastDelivered.getObject();
    }
    /**
     * Sets the last delivered element. This is for testing purposes only.
     *
     * @param o an element.
     */
    void setLastDelivered(E o) {
        lastDelivered = new Element<E>(o);
    }
    /**
     * Inserts the given element into this resequencer. If the element is not
     * ready for immediate delivery and has no immediate presecessor then it is
     * scheduled for timing out. After being timed out it is ready for delivery.
     *
     * @param o an element.
     */
    public synchronized void insert(E o) {
        // wrap object into internal element
        Element<E> element = new Element<E>(o);
        // add element to sequence in proper order
        sequence.add(element);
        Element<E> successor = sequence.successor(element);
        // check if there is an immediate successor and cancel
        // timer task (no need to wait any more for timeout)
        if (successor != null) {
            successor.cancel();
        }
        // start delivery if current element is successor of last delivered element
        if (successorOfLastDelivered(element)) {
            // nothing to schedule
        } else if (sequence.predecessor(element) != null) {
            // nothing to schedule
        } else {
            element.schedule(defineTimeout());
        }
    }
    /**
     * Delivers all elements which are currently ready to deliver.
     *
     * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.
     *
     * @see ResequencerEngine#deliverNext() 
     */
    public synchronized void deliver() throws Exception {
        while (deliverNext()) {
            // do nothing here
        }
    }
    /**
     * Attempts to deliver a single element from the head of the resequencer
     * queue (sequence). Only elements which have not been scheduled for timing
     * out or which already timed out can be delivered. Elements are deliveref via
     * {@link SequenceSender#sendElement(Object)}.
     *
     * @return <code>true</code> if the element has been delivered
     *         <code>false</code> otherwise.
     *
     * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.
     *
     */
    public boolean deliverNext() throws Exception {
        if (sequence.size() == 0) {
            return false;
        }
        // inspect element with lowest sequence value
        Element<E> element = sequence.first();
        // if element is scheduled do not deliver and return
        if (element.scheduled()) {
            return false;
        }
        // remove deliverable element from sequence
        sequence.remove(element);
        // set the delivered element to last delivered element
        lastDelivered = element;
        // deliver the sequence element
        sequenceSender.sendElement(element.getObject());
        // element has been delivered
        return true;
    }
    /**
     * Returns <code>true</code> if the given element is the immediate
     * successor of the last delivered element.
     *
     * @param element an element.
     * @return <code>true</code> if the given element is the immediate
     *         successor of the last delivered element.
     */
    private boolean successorOfLastDelivered(Element<E> element) {
        if (lastDelivered == null) {
            return false;
        }
        if (sequence.comparator().successor(element, lastDelivered)) {
            return true;
        }
        return false;
    }
    /**
     * Creates a timeout task based on the timeout setting of this resequencer.
     *
     * @return a new timeout task.
     */
    private Timeout defineTimeout() {
        return new Timeout(timer, timeout);
    }
    private static <E> Sequence<Element<E>> createSequence(SequenceElementComparator<E> comparator) {
        return new Sequence<Element<E>>(new ElementComparator<E>(comparator));
    }
}
"
org.apache.camel.processor.resequencer.ResequencerEngineSync,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * Synchronization facade for {@link ResequencerEngine} for testing purposes
 * only. This facade is used for both exclusion purposes and for visibility of
 * changes performed by different threads in unit tests. This facade is <i>not</i>
 * needed in {@link ResequencerEngine} applications because it is expected that
 * resequencing is performed by a single thread.
 * 
 * @author Martin Krasser
 */
public class ResequencerEngineSync<E> {
    private ResequencerEngine<E> resequencer;
    public ResequencerEngineSync(ResequencerEngine<E> resequencer) {
        this.resequencer = resequencer;
    }
    public synchronized void stop() {
        resequencer.stop();
    }
    public synchronized int size() {
        return resequencer.size();
    }
    public synchronized long getTimeout() {
        return resequencer.getTimeout();
    }
    public synchronized void setTimeout(long timeout) {
        resequencer.setTimeout(timeout);
    }
    public synchronized SequenceSender<E> getSequenceSender() {
        return resequencer.getSequenceSender();
    }
    public synchronized void setSequenceSender(SequenceSender<E> sequenceSender) {
        resequencer.setSequenceSender(sequenceSender);
    }
    synchronized E getLastDelivered() {
        return resequencer.getLastDelivered();
    }
    synchronized void setLastDelivered(E o) {
        resequencer.setLastDelivered(o);
    }
    public synchronized void insert(E o) {
        resequencer.insert(o);
    }
    public synchronized void deliver() throws Exception {
        resequencer.deliver();
    }
    public synchronized boolean deliverNext() throws Exception {
        return resequencer.deliverNext();
    }
}
"
org.apache.camel.processor.resequencer.ResequencerEngineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import junit.framework.TestCase;
public class ResequencerEngineTest extends TestCase {
    private static final boolean IGNORE_LOAD_TESTS = true;
    private ResequencerEngineSync<Integer> resequencer;
    private ResequencerRunner<Integer> runner;
    private SequenceBuffer<Integer> buffer;
    public void setUp() throws Exception {
    }
    public void tearDown() throws Exception {
        if (runner != null) {
            runner.cancel();
        }
        if (resequencer != null) {
            resequencer.stop();
        }
    }
    public void testTimeout1() throws Exception {
        initResequencer(500, 10);
        resequencer.insert(4);
        assertNull(buffer.poll(250));
        assertEquals((Integer)4, buffer.take());
        assertEquals((Integer)4, resequencer.getLastDelivered());
    }
    public void testTimeout2() throws Exception {
        initResequencer(500, 10);
        resequencer.setLastDelivered(2);
        resequencer.insert(4);
        assertNull(buffer.poll(250));
        assertEquals((Integer)4, buffer.take());
        assertEquals((Integer)4, resequencer.getLastDelivered());
    }
    public void testTimeout3() throws Exception {
        initResequencer(500, 10);
        resequencer.setLastDelivered(3);
        resequencer.insert(4);
        assertEquals((Integer)4, buffer.poll(250));
        assertEquals((Integer)4, resequencer.getLastDelivered());
    }
    public void testTimout4() throws Exception {
        initResequencer(500, 10);
        resequencer.setLastDelivered(2);
        resequencer.insert(4);
        resequencer.insert(3);
        assertEquals((Integer)3, buffer.poll(125));
        assertEquals((Integer)4, buffer.poll(125));
        assertEquals((Integer)4, resequencer.getLastDelivered());
    }
    public void testRandom() throws Exception {
        if (IGNORE_LOAD_TESTS) {
            return;
        }
        int input = 1000;
        initResequencer(1000, 1000);
        List<Integer> list = new LinkedList<Integer>();
        for (int i = 0; i < input; i++) {
            list.add(i);
        }
        Random random = new Random(System.currentTimeMillis());
        System.out.println(""Input sequence:"");
        long millis = System.currentTimeMillis();
        for (int i = input; i > 0; i--) {
            int r = random.nextInt(i);
            int next = list.remove(r);
            System.out.print(next + "" "");
            resequencer.insert(next); 
        }
        System.out.println(""\nOutput sequence:"");
        for (int i = 0; i < input; i++) {
            System.out.print(buffer.take() + "" "");
        }
        millis = System.currentTimeMillis() - millis;
        System.out.println(""\nDuration = "" + millis + "" ms"");
    }
    public void testReverse1() throws Exception {
        if (IGNORE_LOAD_TESTS) {
            return;
        }
        testReverse(10);
    }
    public void testReverse2() throws Exception {
        if (IGNORE_LOAD_TESTS) {
            return;
        }
        testReverse(100);
    }
    private void testReverse(int capacity) throws Exception {
        initResequencer(1, capacity);
        for (int i = 99; i >= 0; i--) {
            resequencer.insert(i);
        }
        System.out.println(""\nOutput sequence:"");
        for (int i = 0; i < 100; i++) {
            System.out.print(buffer.take() + "" "");
        }
    }
    private void initResequencer(long timeout, int capacity) {
        ResequencerEngine<Integer> engine;
        buffer = new SequenceBuffer<Integer>();
        engine = new ResequencerEngine<Integer>(new IntegerComparator());
        engine.setSequenceSender(buffer);
        engine.setTimeout(timeout);
        engine.start();
        resequencer = new ResequencerEngineSync<Integer>(engine);
        runner = new ResequencerRunner<Integer>(resequencer, 50);
        runner.start();
    }
}
"
org.apache.camel.processor.resequencer.ResequencerRunner,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
public class ResequencerRunner<E> extends Thread {
    private ResequencerEngineSync<E> resequencer;
    private long interval;
    private boolean cancelRequested;
    public ResequencerRunner(ResequencerEngineSync<E> resequencer, long interval) {
        this.resequencer = resequencer;
        this.interval = interval;
        this.cancelRequested = false;
    }
    @Override
    public void run() {
        while (!cancelRequested()) {
            try {
                Thread.sleep(interval);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                resequencer.deliver();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        // TODO Auto-generated method stub
        super.run();
    }
    public synchronized void cancel() {
        this.cancelRequested = true;
    }
    private synchronized boolean cancelRequested() {
        return cancelRequested;
    }
}
"
org.apache.camel.processor.resequencer.Sequence,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.TreeSet;
/**
 * A sorted set of elements with additional methods for obtaining immediate
 * successors and immediate predecessors of a given element in the sequence.
 * Successors and predecessors are calculated by using a
 * {@link SequenceElementComparator}.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
public class Sequence<E> extends TreeSet<E> {
    private static final long serialVersionUID = 5647393631147741711L;
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new {@link Sequence} instance.
     * 
     * @param comparator a strategy for comparing elements of this sequence.
     */
    public Sequence(SequenceElementComparator<E> comparator) {
        super(comparator);
        this.comparator = comparator;
    }
    /**
     * Returns the immediate predecessor of the given element in this sequence
     * or <code>null</code> if no predecessor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E predecessor(E e) {
        E elem = lower(e);
        if (elem == null) {
            return null;
        }
        if (comparator.predecessor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns the immediate successor of the given element in this sequence
     * or <code>null</code> if no successor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E successor(E e) {
        E elem = higher(e);
        if (elem == null) {
            return null;
        }
        if (comparator.successor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns this sequence's comparator.
     * 
     * @return this sequence's comparator.
     */
    public SequenceElementComparator<E> comparator() {
        return comparator;
    }
    /**
     * Returns the next higher element in the sequence to the given element. If
     * the given element doesn't exist or if it is the last element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E higher(E e) {
        boolean found = false;
        for (E current : this) {
            if (found) {
                return current;
            }
            if (comparator.compare(e, current) == 0) {
                found = true;
            }
        }
        return null;
    }
    /**
     * Returns the next lower element in the sequence to the given element. If
     * the given element doesn't exist or if it is the first element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E lower(E e) {
        E last = null;
        for (E current : this) {
            if (comparator.compare(e, current) == 0) {
                return last;
            }
            last = current;
        }
        return last;
    }
}
"
org.apache.camel.processor.resequencer.SequenceBuffer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
public class SequenceBuffer<E> implements SequenceSender<E> {
    private BlockingQueue<E> queue;
    public SequenceBuffer() {
        this.queue = new LinkedBlockingQueue<E>();
    }
    public int size() {
        return queue.size();
    }
    public E take() throws InterruptedException {
        return queue.take();
    }
    public E poll(long timeout) throws InterruptedException {
        return queue.poll(timeout, TimeUnit.MILLISECONDS);
    }
    public void sendElement(E o) throws Exception {
        queue.put(o);
    }
}
"
org.apache.camel.processor.resequencer.SequenceElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Comparator;
/**
 * A strategy for comparing elements of a sequence.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
public interface SequenceElementComparator<E> extends Comparator<E> {
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate predecessor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean predecessor(E o1, E o2);
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate successor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean successor(E o1, E o2);
}
"
org.apache.camel.processor.resequencer.SequenceSender,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
  * An interface used by the {@link ResequencerEngine#deliver()} and
  * {@link ResequencerEngine#deliverNext()} methods to send out re-ordered
  * elements.
  *
  * @author Martin Krasser
  *
  * @version $Revision: 698416 $
  */
public interface SequenceSender<E> {
    /**
     * Sends the given element.
     *
     * @param o a re-ordered element.
     * @throws Exception if delivery fails.
     */
    void sendElement(E o) throws Exception;
}
"
org.apache.camel.processor.resequencer.SequenceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import junit.framework.TestCase;
public class SequenceTest extends TestCase {
    private TestObject e1;
    private TestObject e2;
    private TestObject e3;
    private Sequence<TestObject> set;
    public void setUp() throws Exception {
        e1 = new TestObject(3);
        e2 = new TestObject(4);
        e3 = new TestObject(7);
        set = new Sequence<TestObject>(new TestComparator());
        set.add(e3);
        set.add(e1);
        set.add(e2);
    }
    public void tearDown() throws Exception {
    }
    public void testPredecessor() {
        assertEquals(e1, set.predecessor(e2));
        assertEquals(null, set.predecessor(e1));
        assertEquals(null, set.predecessor(e3));
    }
    public void testSuccessor() {
        assertEquals(e2, set.successor(e1));
        assertEquals(null, set.successor(e2));
        assertEquals(null, set.successor(e3));
    }
}
"
org.apache.camel.processor.resequencer.TestComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
public class TestComparator implements SequenceElementComparator<TestObject> {
    public boolean predecessor(TestObject o1, TestObject o2) {
        return (o2.getValue() - 1) == o1.getValue();
    }
    public boolean successor(TestObject o1, TestObject o2) {
        return (o1.getValue() - 1) == o2.getValue();
    }
    public int compare(TestObject o1, TestObject o2) {
        return Integer.valueOf(o1.getValue()).compareTo(o2.getValue());
    }
}
"
org.apache.camel.processor.resequencer.TestComparatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import junit.framework.TestCase;
public class TestComparatorTest extends TestCase {
    private TestComparator c;
    private TestObject e1;
    private TestObject e2;
    private TestObject e3;
    public void setUp() {
        c = new TestComparator();
        e1 = new TestObject(3);
        e2 = new TestObject(4);
        e3 = new TestObject(7);
    }
    public void tearDown() throws Exception {
    }
    public void testPredecessor() {
        assertTrue(c.predecessor(e1, e2));
        assertFalse(c.predecessor(e2, e1));
        assertFalse(c.predecessor(e1, e3));
        assertFalse(c.predecessor(e3, e1));
        assertFalse(c.predecessor(e3, e3));
    }
    public void testSuccessor() {
        assertTrue(c.successor(e2, e1));
        assertFalse(c.successor(e1, e2));
        assertFalse(c.successor(e3, e1));
        assertFalse(c.successor(e1, e3));
        assertFalse(c.successor(e3, e3));
    }
    public void testCompare() {
        assertTrue(c.compare(e1, e2) < 0);
        assertTrue(c.compare(e2, e1) > 0);
        assertTrue(c.compare(e1, e3) < 0);
        assertTrue(c.compare(e3, e1) > 0);
        assertTrue(c.compare(e3, e3) == 0);
    }
}
"
org.apache.camel.processor.resequencer.TestObject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
public class TestObject {
    private int value;
    public TestObject(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
    @Override
    public String toString() {
        return Integer.toString(value);
    }
}
"
org.apache.camel.processor.resequencer.Timeout,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Timer;
import java.util.TimerTask;
/**
 * A timer task that notifies handlers about scheduled timeouts.
 * 
 * @see Timer
 * @see TimerTask
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
public class Timeout extends TimerTask {
    private TimeoutHandler timeoutHandler;
    private Timer timer;
    private long timeout;
    /**
     * Creates a new timeout task using the given {@link Timer} instance and
     * timeout value. The task is not scheduled immediately. It will be
     * scheduled by calling this task's {@link #schedule()} method.
     * 
     * @param timer
     *            a timer
     * @param timeout
     *            a timeout value.
     */
    public Timeout(Timer timer, long timeout) {
        this.timeout = timeout;
        this.timer = timer;
    }
    /**
     * Returns the timeout handler that has been registered for notification.
     * 
     * @return the timeout handler.
     */
    public TimeoutHandler getTimeoutHandlers() {
        return timeoutHandler;
    }
    /**
     * Sets a timeout handler for receiving timeout notifications.
     * 
     * @param timeoutHandler
     *            a timeout handler.
     */
    public void setTimeoutHandler(TimeoutHandler timeoutHandler) {
        this.timeoutHandler = timeoutHandler;
    }
    /**
     * Schedules this timeout task.
     */
    public void schedule() {
        timer.schedule(this, timeout);
    }
    /**
     * Notifies the timeout handler about the scheduled timeout.
     */
    @Override
    public void run() {
        timeoutHandler.timeout(this);
    }
}
"
org.apache.camel.processor.resequencer.TimeoutHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * Implemented by classes that handle timeout notifications.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 697732 $
 */
public interface TimeoutHandler {
    /**
     * Handles a timeout notification.
     * 
     * @param timeout the timer task that caused this timeout notification.
     */
    void timeout(Timeout timeout);
}
"
org.apache.camel.processor.routingslip.DummyExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class DummyExchange extends DefaultExchange {
    public DummyExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public DummyExchange(DummyExchange dummyExchange) {
        super(dummyExchange);
    }
    @Override
    public Exchange newInstance() {
        return new DummyExchange(this);
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipDataModificationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Headers;
import org.apache.camel.OutHeaders;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class RoutingSlipDataModificationTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    private static final transient Log LOG = LogFactory.getLog(RoutingSlipDataModificationTest.class);
    protected MyBean myBean = new MyBean();
    public void testModificationOfDataAlongRoute()
        throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        x.expectedBodiesReceived(ANSWER);
        y.expectedBodiesReceived(ANSWER + ANSWER);
        sendBody();
        assertMockEndpointsSatisfied();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:x,bean:myBean?method=modifyData"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").routingSlip(ROUTING_SLIP_HEADER).to(""mock:y"");
                // END SNIPPET: example
            }
        };
    }
    public static class MyBean {
        public MyBean() {
        }
        public String modifyData(@Body String body) {
            return body + body;
        }
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class RoutingSlipTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    public void testUpdatingOfRoutingSlipAllDefaults()
        throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(ROUTING_SLIP_HEADER, ""mock:y,mock:z"");
        y.expectedHeaderReceived(ROUTING_SLIP_HEADER, ""mock:z"");
        z.expectedHeaderReceived(ROUTING_SLIP_HEADER, """");
        sendBody(""direct:a"", ROUTING_SLIP_HEADER, "","");
        assertMockEndpointsSatisfied();
    }
    public void testUpdatingOfRoutingSlipHeaderSet() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:y,mock:z"");
        y.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:z"");
        z.expectedHeaderReceived(""aRoutingSlipHeader"", """");
        sendBody(""direct:b"", ""aRoutingSlipHeader"", "","");
        assertMockEndpointsSatisfied();
    }
    public void testUpdatingOfRoutingSlipHeaderAndDelimiterSet() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:y#mock:z"");
        y.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:z"");
        z.expectedHeaderReceived(""aRoutingSlipHeader"", """");
        sendBody(""direct:c"", ""aRoutingSlipHeader"", ""#"");
        assertMockEndpointsSatisfied();
    }
    public void testMessagePassingThrough() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBody(""direct:a"", ROUTING_SLIP_HEADER, "","");
        assertMockEndpointsSatisfied();
    }
    public void testEmptyRoutingSlip() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBodyWithEmptyRoutingSlip();
        assertMockEndpointsSatisfied();
    }
    public void testNoRoutingSlip() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBodyWithNoRoutingSlip();
        assertMockEndpointsSatisfied();
    }
    protected void sendBody(String endpoint, String header, String delimiter) {
        template.sendBodyAndHeader(endpoint, ANSWER, header,
               ""mock:x"" + delimiter + ""mock:y"" + delimiter + ""mock:z"");
    }
    protected void sendBodyWithEmptyRoutingSlip() {
        template.sendBodyAndHeader(""direct:a"", ANSWER, ROUTING_SLIP_HEADER, """");
    }
    protected void sendBodyWithNoRoutingSlip() {
        template.sendBody(""direct:a"", ANSWER);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: e1
                from(""direct:a"").routingSlip().to(""mock:end"");
                // END SNIPPET: e1
                // START SNIPPET: e2
                from(""direct:b"").routingSlip(""aRoutingSlipHeader"");
                // END SNIPPET: e2
                // START SNIPPET: e3
                from(""direct:c"").routingSlip(""aRoutingSlipHeader"", ""#"");
                // END SNIPPET: e3
            }
        };
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import java.util.concurrent.TimeUnit;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
public class RoutingSlipWithExceptionTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    protected MyBean myBean = new MyBean();
    private MockEndpoint endEndpoint;
    private MockEndpoint exceptionEndpoint;
    private MockEndpoint exceptionSettingEndpoint;
    public void testNoException() throws Exception {
        endEndpoint.expectedMessageCount(1);
        exceptionEndpoint.expectedMessageCount(0);
        sendRoutingSlipWithNoExceptionThrowingComponent();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionThrowingComponentFirstInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionThrowingComponentFirstInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionThrowingComponentSecondInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionThrowingComponentSecondInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionSettingComponentFirstInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionSettingComponentFirstInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionSettingComponentSecondInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionSettingComponentSecondInList();
        assertEndpointsSatisfied();
    }
    private void assertEndpointsSatisfied() throws InterruptedException {
        MockEndpoint.assertIsSatisfied(5, TimeUnit.SECONDS, endEndpoint, exceptionEndpoint);
    }
    protected void sendRoutingSlipWithExceptionThrowingComponentFirstInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""myBean?method=throwException,mock:x"");
    }
    protected void sendRoutingSlipWithExceptionThrowingComponentSecondInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a,myBean?method=throwException"");
    }
    protected void sendRoutingSlipWithNoExceptionThrowingComponent() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a"");
    }
    protected void sendRoutingSlipWithExceptionSettingComponentFirstInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:exceptionSetting,mock:a"");
    }
    protected void sendRoutingSlipWithExceptionSettingComponentSecondInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a,mock:exceptionSetting"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        endEndpoint = resolveMandatoryEndpoint(""mock:noexception"", MockEndpoint.class);
        exceptionEndpoint = resolveMandatoryEndpoint(""mock:exception"", MockEndpoint.class);
        exceptionSettingEndpoint = resolveMandatoryEndpoint(""mock:exceptionSetting"", MockEndpoint.class);
        exceptionSettingEndpoint.whenAnyExchangeReceived(new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setException(new Exception(""Throw me!""));
            }
        });
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                    tryBlock().
                        routingSlip().to(""mock:noexception"").
                        handle(Exception.class).
                    to(""mock:exception"");
            }
        };
    }
    public static class MyBean {
        public MyBean() {
        }
        public void throwException() throws Exception {
            throw new Exception(""Throw me!"");
        }
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipWithNonStandardExchangeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class RoutingSlipWithNonStandardExchangeTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    public void testRoutingSlipPreservesDifferentExchange()
        throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:z"");
        end.expectedMessageCount(1);
        sendBody(""direct:a"", ROUTING_SLIP_HEADER, "","");
        assertMockEndpointsSatisfied();
        List<Exchange> exchanges = end.getExchanges();
        Exchange exchange = exchanges.get(0);
        assertIsInstanceOf(DummyExchange.class, exchange);
    }
    protected void sendBody(String endpoint, String header, String delimiter) {
        DummyExchange exchange = new DummyExchange(context, ExchangePattern.InOut);
        Message in = exchange.getIn();
        in.setHeader(header, ""mock:y"" + delimiter + ""mock:z"");
        in.setBody(ANSWER);        
        template.send(endpoint, exchange);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {    
                // START SNIPPET: e1
                from(""direct:a"").routingSlip();
                // END SNIPPET: e1
            }
        };
    }
}
"
org.apache.camel.processor.validation.DefaultValidationErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.ArrayList;
import java.util.List;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A default error handler which just stores all the errors so they can be reported or transformed.
 *
 * @version $Revision: 684301 $
 */
public class DefaultValidationErrorHandler implements ValidatorErrorHandler {
    private static final transient Log LOG = LogFactory.getLog(DefaultValidationErrorHandler.class);
    private List<SAXParseException> warnings = new ArrayList<SAXParseException>();
    private List<SAXParseException> errors = new ArrayList<SAXParseException>();
    private List<SAXParseException> fatalErrors = new ArrayList<SAXParseException>();
    public void warning(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""warning: "" + e, e);
        }
        warnings.add(e);
    }
    public void error(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""error: "" + e, e);
        }
        errors.add(e);
    }
    public void fatalError(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""fatalError: "" + e, e);
        }
        fatalErrors.add(e);
    }
    public void reset() {
        warnings.clear();
        errors.clear();
        fatalErrors.clear();
    }
    public boolean isValid() {
        return errors.isEmpty() && fatalErrors.isEmpty();
    }
    public void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
    public void handleErrors(Exchange exchange, Object schema) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
}
"
org.apache.camel.processor.validation.NoXmlBodyValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * An exception found if no XML body is available on the inbound message
 *
 * @version $Revision: 630591 $
 */
public class NoXmlBodyValidationException extends ValidationException {
    public NoXmlBodyValidationException(Exchange exchange) {
        super(exchange, ""No XML body could be found on the input message"" + exchange);
    }
}
"
org.apache.camel.processor.validation.SchemaValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.List;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * A Schema validation exception occurred
 * 
 * @version $Revision: 630591 $
 */
public class SchemaValidationException extends ValidationException {
    private final Object schema;
    private final List<SAXParseException> fatalErrors;
    private final List<SAXParseException> errors;
    private final List<SAXParseException> warnings;
    public SchemaValidationException(Exchange exchange, Object schema, List<SAXParseException> fatalErrors,
                                     List<SAXParseException> errors, List<SAXParseException> warnings) {
        super(exchange, message(schema, fatalErrors, errors, warnings));
        this.schema = schema;
        this.fatalErrors = fatalErrors;
        this.errors = errors;
        this.warnings = warnings;
    }
    /**
     * Returns the schema that failed
     * 
     * @return the schema that failed
     */
    public Object getSchema() {
        return schema;
    }
    /**
     * Returns the validation errors
     * 
     * @return the validation errors
     */
    public List<SAXParseException> getErrors() {
        return errors;
    }
    /**
     * Returns the fatal validation errors
     * 
     * @return the fatal validation errors
     */
    public List<SAXParseException> getFatalErrors() {
        return fatalErrors;
    }
    /**
     * Returns the validation warnings
     * 
     * @return the validation warnings
     */
    public List<SAXParseException> getWarnings() {
        return warnings;
    }
    protected static String message(Object schema, List<SAXParseException> fatalErrors,
                                    List<SAXParseException> errors, List<SAXParseException> warnings) {
        StringBuffer buffer = new StringBuffer(""Validation failed for: "" + schema);
        if (!fatalErrors.isEmpty()) {
            buffer.append("" fatal errors: "");
            buffer.append(fatalErrors);
        }
        if (!errors.isEmpty()) {
            buffer.append("" errors: "");
            buffer.append(errors);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.processor.validation.ValidatingProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import org.xml.sax.SAXException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A processor which validates the XML version of the inbound message body
 * against some schema either in XSD or RelaxNG
 * 
 * @version $Revision: 684301 $
 */
public class ValidatingProcessor implements Processor {
    // for lazy creation of the Schema
    private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;
    private Schema schema;
    private Source schemaSource;
    private SchemaFactory schemaFactory;
    private URL schemaUrl;
    private File schemaFile;
    private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler();
    public void process(Exchange exchange) throws Exception {
        Schema schema = getSchema();
        Validator validator = schema.newValidator();
        Source source = exchange.getIn().getBody(DOMSource.class);
        if (source == null) {
            throw new NoXmlBodyValidationException(exchange);
        }
        // create a new errorHandler and set it on the validator
        // must be a local instance to avoid problems with concurrency (to be thread safe)
        ValidatorErrorHandler handler = errorHandler.getClass().newInstance();
        validator.setErrorHandler(handler);
        DOMResult result = new DOMResult();
        validator.validate(source, result);
        handler.handleErrors(exchange, schema, result);
    }
    // Properties
    // -----------------------------------------------------------------------
    public Schema getSchema() throws IOException, SAXException {
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public String getSchemaLanguage() {
        return schemaLanguage;
    }
    public void setSchemaLanguage(String schemaLanguage) {
        this.schemaLanguage = schemaLanguage;
    }
    public Source getSchemaSource() throws IOException {
        if (schemaSource == null) {
            schemaSource = createSchemaSource();
        }
        return schemaSource;
    }
    public void setSchemaSource(Source schemaSource) {
        this.schemaSource = schemaSource;
    }
    public URL getSchemaUrl() {
        return schemaUrl;
    }
    public void setSchemaUrl(URL schemaUrl) {
        this.schemaUrl = schemaUrl;
    }
    public File getSchemaFile() {
        return schemaFile;
    }
    public void setSchemaFile(File schemaFile) {
        this.schemaFile = schemaFile;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = createSchemaFactory();
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public ValidatorErrorHandler getErrorHandler() {
        return errorHandler;
    }
    public void setErrorHandler(ValidatorErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected SchemaFactory createSchemaFactory() {
        return SchemaFactory.newInstance(schemaLanguage);
    }
    protected Source createSchemaSource() throws IOException {
        throw new IllegalArgumentException(""You must specify a schema, ""
                                           + ""schemaFile, schemaSource or schemaUrl property"");
    }
    protected Schema createSchema() throws SAXException, IOException {
        SchemaFactory factory = getSchemaFactory();
        URL url = getSchemaUrl();
        if (url != null) {
            return factory.newSchema(url);
        }
        File file = getSchemaFile();
        if (file != null) {
            return factory.newSchema(file);
        }
        return factory.newSchema(getSchemaSource());
    }
}
"
org.apache.camel.processor.validation.ValidatorErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.xml.sax.ErrorHandler;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * Validator error handler.
 *
 * @version $Revision: 659760 $
 */
public interface ValidatorErrorHandler extends ErrorHandler {
    /**
     * Resets any state within this error handler
     */
    void reset();
    /**
     * Process any errors which may have occurred during validation
     *
     * @param exchange the exchange
     * @param schema   the schema
     * @param result   the result
     */
    void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException;
}
"
org.apache.camel.spi.BrowsableEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
/**
 * An optional interface an {@link Endpoint} may choose to implement which allows it to
 * expose a way of browsing the exchanges available.
 *
 * @version $Revision: 688279 $
 */
public interface BrowsableEndpoint<T extends Exchange> extends Endpoint<T> {
    /**
     * Return the exchanges available on this endpoint
     *
     * @return the exchanges on this endpoint
     */
    List<Exchange> getExchanges();
}
"
org.apache.camel.spi.ComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
/**
 * Represents a resolver of components from a URI to be able to auto-load them using some
 * discovery mechanism like {@link org.apache.camel.impl.DefaultComponentResolver}
 *
 * @version $Revision: 659849 $
 */
public interface ComponentResolver<E extends Exchange> {
    /**
     * Attempts to resolve the component for the given URI
     *
     * @param name the component name to resolve
     * @param context the context to load the component if it can be resolved
     * @return the component which is added to the context or null if it can not be resolved
     * @throws Exception is thrown if the the component could not be loaded
     */
    Component<E> resolveComponent(String name, CamelContext context) throws Exception;
}
"
org.apache.camel.spi.DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
/**
 * Represents a
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * used to marshal objects to and from streams
 * such as Java Serialization or using JAXB2 to encode/decode objects using XML
 * or using SOAP encoding.
 *
 * @version $Revision: 688279 $
 */
public interface DataFormat {
    /**
     * Marshals the object to the given Stream.
     *
     * @param exchange  the current exchange
     * @param graph     the object to be marshalled
     * @param stream    the output stream to write the marshalled rersult to
     * @throws Exception can be thrown
     */
    void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception;
    /**
     * Unmarshals the given stream into an object.
     * <p/>
     * <b>Notice:</b> The result is set as body on the exchange OUT message.
     * It is possible to mutate the OUT message provided in the given exchange parameter.
     * For instance adding headers to the OUT message will be preserved.
     *
     * @param exchange    the current exchange
     * @param stream      the input stream with the object to be unmarshalled
     * @return            the unmarshalled object
     * @throws Exception can be thrown
     */
    Object unmarshal(Exchange exchange, InputStream stream) throws Exception;
}
"
org.apache.camel.spi.ErrorHandlerWrappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
/**
 * The purpose of this interface is to allow an implementation to
 * provide custom logic to wrap a processor with error handler
 *
 * @version $Revision: 688279 $
 */
public interface ErrorHandlerWrappingStrategy {
    /**
     * This method is invoked by
     * {@link ProcessorType#wrapProcessor(RouteContext, Processor)}
     * to give the implementor an opportunity to wrap the target processor
     * in a route.
     *
     * @param routeContext the route context
     * @param processorType the object that invokes this method
     * @param target the processor to be wrapped
     * @return processor wrapped with an interceptor or not wrapped
     * @throws Exception can be thrown
     */
    Processor wrapProcessorInErrorHandler(RouteContext routeContext, ProcessorType processorType,
                                          Processor target) throws Exception;
}
"
org.apache.camel.spi.ExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A Strategy pattern for handling exceptions; particularly in asynchronous processes such as consumers
 *
 * @version $Revision: 630568 $
 */
public interface ExceptionHandler {
    /**
     * Handles the given exception
     *
     * @param exception the exception
     */
    void handleException(Throwable exception);
}
"
org.apache.camel.spi.ExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * This converter is capable of converting from an exchange to another type
 *
 * @version $Revision: 688279 $
 */
public interface ExchangeConverter {
    /**
     * Converts the given exchange to the new type
     *
     * @param type  the new class type
     * @param exchange the exchange to converter
     * @param <T> the new type
     * @return  the converted exchange
     */
     <T> T  convertTo(Class<T> type, Exchange exchange);
}
"
org.apache.camel.spi.HeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
 /**
  * Interface to allow plug-able implementation to filter header
  * to and from Camel message.
  * 
  * @since 1.5
  * @version $Revision: 688279 $
  */
public interface HeaderFilterStrategy {
    /**
     * Applies filtering logic to Camel Message header that is
     * going to be copied to target message such as CXF and JMS message.
     * It returns true if the filtering logics return a match.  Otherwise,
     * it returns false.  A match means the header should be excluded.
     * 
     * @param headerName  the header name
     * @param headerValue the header value
     * @return <tt>true</tt> if this header should be filtered out.
     */
    boolean applyFilterToCamelHeaders(String headerName, Object headerValue);
    /**
     * Applies filtering logic to an external message header such 
     * as CXF and JMS message that is going to be copied to Camel
     * message header.
     * It returns true if the filtering logics return a match.  Otherwise,
     * it returns false.  A match means the header should be excluded.
     *  
     * @param headerName  the header name
     * @param headerValue the header value
     * @return <tt>true</tt> if this header should be filtered out.
     */
    boolean applyFilterToExternalHeaders(String headerName, Object headerValue);
}
"
org.apache.camel.spi.Injector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A pluggable strategy for creating and possibly dependency injecting objects
 * which could be implemented using straight forward reflection or using Spring
 * or Guice to perform dependency injection.
 * 
 * @version $Revision: 659798 $
 */
public interface Injector {
    /**
     * Instantiates a new instance of the given type possibly injecting values
     * into the object in the process
     * 
     * @param type the type of object to create
     * @return a newly created instance
     */
    <T> T newInstance(Class<T> type);
}
"
org.apache.camel.spi.InstrumentationAgent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import org.apache.camel.Service;
/**
 * Camel JMX service agent
 */
public interface InstrumentationAgent extends Service {
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     *
     * @param obj  the object to register
     * @param name the name
     * @throws JMException is thrown if the registration failed
     */
    void register(Object obj, ObjectName name) throws JMException;
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     *
     * @param obj  the object to register
     * @param name the name
     * @param forceRegistration if set to <tt>true</tt>, then object will be registered despite
     * existing object is already registered with the name.
     * @throws JMException is thrown if the registration failed
     */
    void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException;
    /**
     * Unregisters object based upon registered name
     *
     * @param name the name
     * @throws JMException is thrown if the unregistration failed
     */
    void unregister(ObjectName name) throws JMException;
    /**
     * Get the MBeanServer which hosts managed objects.
     * <p/>
     * <b>Notice:</b> If the JMXEnabled configuration is not set to <tt>true</tt>,
     * this method will return <tt>null</tt>.
     * 
     * @return the MBeanServer
     */
    MBeanServer getMBeanServer();
    /**
     * Get domain name for Camel MBeans.
     * <p/>
     * <b>Notice:</b> That this can be different that the default domain name of the MBean Server.
     * 
     * @return domain name
     */
    String getMBeanObjectDomainName();
}
"
org.apache.camel.spi.InterceptStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
 /**
  * The purpose of this interface is to allow an implementation to wrap
  * processors in a route with interceptors.  For example, a possible
  * usecase is to gather performance statistics at the processor's level.
  *
  * @version $Revision: 679971 $
  */
public interface InterceptStrategy {
    /**
     * This method is invoked by
     * {@link ProcessorType#wrapProcessor(RouteContext, Processor)}
     * to give the implementor an opportunity to wrap the target processor
     * in a route.
     *
     * @param processorType the object that invokes this method
     * @param target the processor to be wrapped
     * @return processor wrapped with an interceptor or not wrapped
     * @throws Exception can be thrown
     */
    Processor wrapProcessorInInterceptors(ProcessorType processorType,
            Processor target) throws Exception;
}
"
org.apache.camel.spi.Language,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * Represents a language to be used for {@link Expression} or {@link Predicate} instances
 *
 * @version $Revision: 688279 $
 */
public interface Language {
    /**
     * Creates a predicate based on the given string input
     *
     * @param expression  the expression
     * @return the created predicate
     */
    Predicate<Exchange> createPredicate(String expression);
    /**
     * Creates an expression based on the given string input
     *
     * @param expression  the expression as a string input
     * @return the created expression
     */
    Expression<Exchange> createExpression(String expression);
}
"
org.apache.camel.spi.LanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
/**
 * A pluggable strategy for resolving different languages in a loosely coupled manner
 * 
 * @version $Revision: 688279 $
 */
public interface LanguageResolver {
    /**
     * Resolves the given language.
     *
     * @param name    the name of the langauge
     * @param context the camel context
     * @return the resolved language
     */
    Language resolveLanguage(String name, CamelContext context);
}
"
org.apache.camel.spi.LifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
/**
 * Strategy for lifecycle notifications.
 */
public interface LifecycleStrategy {
    /**
     * Notification on starting a {@link CamelContext}.
     *
     * @param context the camel context
     */
    void onContextStart(CamelContext context);
    /**
     * Notification on adding an {@link Endpoint}.
     *
     * @param endpoint the added endpoint
     */
    void onEndpointAdd(Endpoint<? extends Exchange> endpoint);
    /**
     * Notification on adding a {@link Service}.
     *
     * @param context the camel context
     * @param service the added service
     */
    void onServiceAdd(CamelContext context, Service service);
    /**
     * Notification on adding {@link Route}(s).
     *
     * @param routes the added routes
     */
    void onRoutesAdd(Collection<Route> routes);
    /**
     * Notification on adding {@link RouteContext}(s).
     *
     * @param routeContext the added route context
     */
    void onRouteContextCreate(RouteContext routeContext);
}
"
org.apache.camel.spi.NamespaceAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.Map;
/**
 * Represents an object which is aware of the namespaces in which its used such as
 * XPath and XQuery type expressions so that the current namespace context can be injected
 *
 * @version $Revision: 640438 $
 */
public interface NamespaceAware {
    /**
     * Injects the XML Namespaces of prefix -> uri mappings
     *
     * @param namespaces the XML namespaces with the key of prefixes and the value the URIs
     */
    void setNamespaces(Map<String, String> namespaces);
}
"
org.apache.camel.spi.Policy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
/**
 * A strategy capable of applying interceptors to a processor
 *
 * @version $Revision: 630568 $
 */
public interface Policy<E> {
    /**
     * Wraps any applicable interceptors around the given processor
     *
     * @param processor the processor to be intercepted
     * @return either the original processor or a processor wrapped in one or more interceptors
     */
    Processor wrap(Processor processor);
}
"
org.apache.camel.spi.Provider,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A provider of newly constructed objects
 *
 * @version $Revision: 688279 $
 */
public interface Provider<T> {
    /**
     * Returns the newly constructed instance
     *
     * @return the newly constructed instance
     */
    T get();
}
"
org.apache.camel.spi.Registry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * Represents a service registry which may be implemented via a Spring ApplicationContext,
 * via JNDI, a simple Map or the OSGI Service Registry
 *
 * @version $Revision: 630568 $
 */
public interface Registry {
    /**
     * Looks up a service in the registry, returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @param type the type of the required service
     * @return the service from the registry or null if it could not be found
     */
    <T> T lookup(String name, Class<T> type);
    /**
     * Looks up a service in the registry based purely on name,
     * returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @return the service from the registry or null if it could not be found
     */
    Object lookup(String name);
}
"
org.apache.camel.spi.RouteContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.Processor;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatType;
/**
 * The context used to activate new routing rules
 *
 * @version $Revision: 695550 $
 */
public interface RouteContext {
    /**
     * Gets the endpoint
     *
     * @return the endpoint
     */
    Endpoint<? extends Exchange> getEndpoint();
    /**
     * Gets the from type
     *
     * @return the from type
     */
    FromType getFrom();
    /**
     * Get the route type
     *
     * @return the route type
     */
    RouteType getRoute();
    /**
     * Gets the camel context
     *
     * @return the camel context
     */
    CamelContext getCamelContext();
    /**
     * Creates a processor
     *
     * @param node  the node
     * @return the created processor
     * @throws Exception can be thrown
     */
    Processor createProcessor(ProcessorType node) throws Exception;
    /**
     * Resolves an endpoint from the URI
     *
     * @param uri the URI
     * @return the resolved endpoint
     */
    Endpoint<? extends Exchange> resolveEndpoint(String uri);
    /**
     * Resolves an endpoint from either a URI or a named reference
     *
     * @param uri  the URI or
     * @param ref  the named reference
     * @return the resolved endpoint
     */
    Endpoint<? extends Exchange> resolveEndpoint(String uri, String ref);
    /**
     * lookup an object by name and type
     *
     * @param name  the name to lookup
     * @param type  the expected type
     * @return the found object
     */
    <T> T lookup(String name, Class<T> type);
    /**
     * Lets complete the route creation, creating a single event driven route
     * for the current from endpoint with any processors required
     */
    void commit();
    /**
     * Adds an event driven processor
     *
     * @param processor the processor
     */
    void addEventDrivenProcessor(Processor processor);
    /**
     * Intercepts with the given interceptor
     *
     * @param interceptor the interceptor
     */
    void intercept(Intercept interceptor);
    /**
     * Creates a proceed processor
     *
     * @return the created proceed processor
     */
    Processor createProceedProcessor();
    /**
     * This method retrieves the InterceptStrategy instances this route context.
     *
     * @return the strategy
     */
    List<InterceptStrategy> getInterceptStrategies();
    /**
     * This method sets the InterceptStrategy instances on this route context.
     *
     * @param interceptStrategies the strategies
     */
    void setInterceptStrategies(List<InterceptStrategy> interceptStrategies);
    /**
     * Adds a InterceptStrategy to this route context
     *
     * @param interceptStrategy the strategy
     */
    void addInterceptStrategy(InterceptStrategy interceptStrategy);
    /**
     * This method retrieves the ErrorHandlerWrappingStrategy.
     *
     * @return the strategy
     */
    ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy();
    /**
     * This method sets the ErrorHandlerWrappingStrategy.
     *
     * @param strategy the strategy
     */
    void setErrorHandlerWrappingStrategy(ErrorHandlerWrappingStrategy strategy);
    /**
     * If this flag is true, {@link ProcessorType#addRoutes(RouteContext, java.util.Collection)}
     * will not add processor to addEventDrivenProcessor to the RouteContext and it
     * will prevent from adding an EventDrivenRoute.
     *
     * @param value the flag
     */
    void setIsRouteAdded(boolean value);
    /**
     * Returns the isRouteAdded flag
     * 
     * @return the flag
     */
    boolean isRouteAdded();
    /**
     * Get a DataFormatType by ref name
     *
     * @param ref  the ref name to lookup
     * @return the found object
     */
    DataFormatType getDataFormat(String ref);
}
"
org.apache.camel.spi.Synchronization,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Provides a hook for custom {@link Processor} or {@link Component} instances to respond to
 * completed or failed processing of an {@link Exchange} rather like Spring's
 * <a href=""http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/
 * support/TransactionSynchronization.html"">TransactionSynchronization</a>
 *
 * @version $Revision: 699876 $
 */
public interface Synchronization {
    /**
     * Called when the processing of the message exchange is complete
     *
     * @param exchange the exchange being processed
     */
    void onComplete(Exchange exchange);
    /**
     * Called when the processing of the message exchange has failed for some reason.
     * The exception which caused the problem is in {@link Exchange#getException()} and
     * there could be a fault message via {@link Exchange#getFault()}
     *
     * @param exchange the exchange being processed
     */
    void onFailure(Exchange exchange);
}
"
org.apache.camel.spi.TypeConverterAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.TypeConverter;
/**
 * An interface for an object which is interested in being injected with the root {@link TypeConverter}
 * such as for implementing a fallback type converter
 *
 * @see org.apache.camel.impl.converter.DefaultTypeConverter#addFallbackConverter(TypeConverter)
 *         DefaultTypeConverter.addFallbackConverter
 * @version $Revision: 688279 $
 */
public interface TypeConverterAware {
    /**
     * Injects the root type converter.
     *
     * @param parentTypeConverter the root type converter
     */
    void setTypeConverter(TypeConverter parentTypeConverter);
}
"
org.apache.camel.spi.UnitOfWork,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * An object representing the unit of work processing an {@link Exchange}
 * which allows the use of {@link Synchronization} hooks. This object might map one-to-one with
 * a transaction in JPA or Spring; or might not.
 *
 * @version $Revision: 688279 $
 */
public interface UnitOfWork {
    /**
     * Adds a synchronization hook
     *
     * @param synchronization  the hook
     */
    void addSynchronization(Synchronization synchronization);
    /**
     * Removes a synchronization hook
     *
     * @param synchronization  the hook
     */
    void removeSynchronization(Synchronization synchronization);
    /**
     * Invoked when this unit of work has been completed, whether it has failed or completed
     *
     * @param exchange the current exchange
     */
    void done(Exchange exchange);
    /**
     * Returns the unique ID of this unit of work, lazily creating one if it does not yet have one
     * 
     * @return the unique ID
     */
    String getId();
}
"
org.apache.camel.util.AsyncProcessorHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
/**
 * Helper methods for AsyncProcessor objects.
 */
public final class AsyncProcessorHelper {
    private AsyncProcessorHelper() {
        // utility class
    }
    /**
     * Calls the async version of the processor's process method and waits
     * for it to complete before returning. This can be used by AsyncProcessor
     * objects to implement their sync version of the process method.
     */
    public static void process(AsyncProcessor processor, Exchange exchange) throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        boolean sync = processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                if (!sync) {
                    latch.countDown();
                }
            }
        });
        if (!sync) {
            latch.await();
        }
    }
}
"
org.apache.camel.util.CamelContextHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.Registry;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A number of helper methods
 *
 * @version $Revision: 707731 $
 */
public final class CamelContextHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CamelContextHelper() {
    }
    /**
     * Returns the mandatory endpoint for the given URI or the
     * {@link org.apache.camel.NoSuchEndpointException} is thrown
     */
    public static Endpoint getMandatoryEndpoint(CamelContext camelContext, String uri)
        throws NoSuchEndpointException {
        Endpoint endpoint = camelContext.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        } else {
            return endpoint;
        }
    }
    public static String getEndpointKey(String uri, Endpoint ep) {
        return ep.isSingleton() ? uri : (""Ox"" + Integer.toHexString(ep.hashCode()) + "":"" + uri);
    }
    /**
     * Returns the mandatory endpoint for the given URI and type or the
     * {@link org.apache.camel.NoSuchEndpointException} is thrown
     */
    public static <T extends Endpoint> T getMandatoryEndpoint(CamelContext camelContext, String uri, Class<T> type) {
        Endpoint endpoint = getMandatoryEndpoint(camelContext, uri);
        return ObjectHelper.cast(type, endpoint);
    }
    /**
     * Returns a list of all endpoints of the given type
     *
     * @param camelContext the camel context
     * @param type the type of the endpoints requested
     * @return a list which may be empty of all the endpoint instances of the
     *         given type
     */    
    public <T> List<T> getEndpoints(CamelContext camelContext, Class<T> type) {
        return getEndpointsImpl(camelContext, type, false);
    }        
    /**
     * Returns a list of all singleton endpoints of the given type
     *
     * @param camelContext the camel context
     * @param type the type of the endpoints requested
     * @return a list which may be empty of all the endpoint instances of the
     *         given type
     */
    public static <T> List<T> getSingletonEndpoints(CamelContext camelContext, Class<T> type) {
        return getEndpointsImpl(camelContext, type, true);
    }
    /**
     * Returns a list of all singleton or regular endpoints of the given type
     */
    private static <T> List<T> getEndpointsImpl(CamelContext camelContext, Class<T> type, boolean singleton) {
        List<T> answer = new ArrayList<T>();
        Collection<Endpoint> endpoints = singleton ? camelContext.getSingletonEndpoints() : camelContext.getEndpoints();
        for (Endpoint endpoint : endpoints) {
            if (type.isInstance(endpoint)) {
                T value = type.cast(endpoint);
                answer.add(value);
            }
        }
        return answer;
    }          
    /**
     * Converts the given value to the requested type
     */
    public static <T> T convertTo(CamelContext context, Class<T> type, Object value) {
        notNull(context, ""camelContext"");
        return context.getTypeConverter().convertTo(type, value);
    }
    /**
     * Converts the given value to the specified type throwing an {@link IllegalArgumentException}
     * if the value could not be converted to a non null value
     */
    public static <T> T mandatoryConvertTo(CamelContext context, Class<T> type, Object value) {
        T answer = convertTo(context, type, value);
        if (answer == null) {
            throw new IllegalArgumentException(""Value "" + value + "" converted to "" + type.getName() + "" cannot be null"");
        }
        return answer;
    }
    /**
     * Creates a new instance of the given type using the {@link Injector} on the given
     * {@link CamelContext}
     */
    public static <T> T newInstance(CamelContext context, Class<T> beanType) {
        return context.getInjector().newInstance(beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static Object lookup(CamelContext context, String name) {
        return context.getRegistry().lookup(name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static <T> T lookup(CamelContext context, String name, Class<T> beanType) {
        return context.getRegistry().lookup(name, beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext} or throws
     */
    public static Object mandatoryLookup(CamelContext context, String name) {
        Object answer = lookup(context, name);
        notNull(answer, ""registry entry called "" + name);
        return answer;
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static <T> T mandatoryLookup(CamelContext context, String name, Class<T> beanType) {
        T answer = lookup(context, name, beanType);
        notNull(answer, ""registry entry called "" + name + "" of type "" + beanType.getName());
        return answer;
    }
    /**
     * Resolves the given language name into a {@link Language} or throws an exception if it could not be converted
     */
    public static Language resolveMandatoryLanguage(CamelContext camelContext, String languageName) {
        notNull(camelContext, ""camelContext"");
        notNull(languageName, ""languageName"");
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Could not resolve language: "" + languageName);
        }
        return language;
    }
    /**
     * Resolves the mandatory language name and expression text into a {@link Expression} instance
     * throwing an exception if it could not be created
     */
    public static Expression resolveMandatoryExpression(CamelContext camelContext, String languageName, String expressionText) {
        notNull(expressionText, ""expressionText"");
        Language language = resolveMandatoryLanguage(camelContext, languageName);
        Expression<Exchange> expression = language.createExpression(expressionText);
        if (expression == null) {
            throw new IllegalArgumentException(""Could not create expression: "" + expressionText + "" with language: "" + language);
        }
        return expression;
    }
    /**
     * Evaluates the @EndpointInject annotation using the given context
     */
    public static Endpoint getEndpointInjection(CamelContext camelContext, String uri, String name, String injectionPointName, boolean mandatory) {
        Endpoint endpoint = null;
        if (isNotNullAndNonEmpty(uri)) {
            endpoint = camelContext.getEndpoint(uri);
        } else {
            if (isNullOrBlank(name)) {
                name = injectionPointName;
            }
            if (mandatory) {
                endpoint = mandatoryLookup(camelContext, name, Endpoint.class);
            } else {
                endpoint = lookup(camelContext, name, Endpoint.class);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.util.CollectionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.w3c.dom.NodeList;
/**
 * A number of helper methods for working with collections
 *
 * @version $Revision: 723967 $
 */
public final class CollectionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionHelper() {
    }
    /**
     * Returns the size of the collection if it can be determined to be a collection
     *
     * @param value the collection
     * @return the size, or <tt>null</tt> if not a collection
     */
    public static Integer size(Object value) {
        if (value != null) {
            if (value instanceof Collection) {
                Collection collection = (Collection)value;
                return collection.size();
            } else if (value instanceof Map) {
                Map map = (Map)value;
                return map.size();
            } else if (value instanceof Object[]) {
                Object[] array = (Object[])value;
                return array.length;
            } else if (value.getClass().isArray()) {
                return Array.getLength(value);
            } else if (value instanceof NodeList) {
                NodeList nodeList = (NodeList)value;
                return nodeList.getLength();
            }
        }
        return null;
    }
    /**
     * Sets the value of the entry in the map for the given key, though if the
     * map already contains a value for the given key then the value is appended
     * to a list of values.
     *
     * @param map the map to add the entry to
     * @param key the key in the map
     * @param value the value to put in the map
     */
    public static void appendValue(Map map, Object key, Object value) {
        Object oldValue = map.get(key);
        if (oldValue != null) {
            List list;
            if (oldValue instanceof List) {
                list = (List)oldValue;
            } else {
                list = new ArrayList();
                list.add(oldValue);
            }
            list.add(value);
        } else {
            map.put(key, value);
        }
    }
    /**
     * Filters the given list to skip instanceof filter objects.
     * 
     * @param list  the list
     * @param filters  objects to skip
     * @return a new list without the filtered objects
     */
    public static List filterList(List list, Object... filters) {
        List answer = new ArrayList();
        for (Object o : list) {
            for (Object filter : filters) {
                if (!o.getClass().isInstance(filter)) {
                    answer.add(o);
                }
            }
        }
        return answer;
    }
}
"
org.apache.camel.util.CollectionStringBuffer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * A little helper class for converting a collection of values to a (usually comma separated) string.
 *
 * @version $Revision: 640438 $
 */
public class CollectionStringBuffer {
    private StringBuffer buffer = new StringBuffer();
    private String separator;
    private boolean first = true;
    public CollectionStringBuffer() {
        this("", "");
    }
    public CollectionStringBuffer(String separator) {
        this.separator = separator;
    }
    @Override
    public String toString() {
        return buffer.toString();
    }
    public void append(Object value) {
        if (first) {
            first = false;
        } else {
            buffer.append(separator);
        }
        buffer.append(value);
    }
    public String getSeparator() {
        return separator;
    }
    public void setSeparator(String separator) {
        this.separator = separator;
    }
}
"
org.apache.camel.util.DefaultTimeoutMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Default implementation of the {@link TimeoutMap}.
 *
 * @version $Revision: 660275 $
 */
public class DefaultTimeoutMap implements TimeoutMap, Runnable {
    private static final transient Log LOG = LogFactory.getLog(DefaultTimeoutMap.class);
    private final Map map = new HashMap();
    private SortedSet index = new TreeSet();
    private ScheduledExecutorService executor;
    private long purgePollTime;
    public DefaultTimeoutMap() {
        this(null, 1000L);
    }
    public DefaultTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis) {
        this.executor = executor;
        this.purgePollTime = requestMapPollTimeMillis;
        schedulePoll();
    }
    public Object get(Object key) {
        TimeoutMapEntry entry = null;
        synchronized (map) {
            entry = (TimeoutMapEntry) map.get(key);
            if (entry == null) {
                return null;
            }
            index.remove(entry);
            updateExpireTime(entry);
            index.add(entry);
        }
        return entry.getValue();
    }
    public void put(Object key, Object value, long timeoutMillis) {
        TimeoutMapEntry entry = new TimeoutMapEntry(key, value, timeoutMillis);
        synchronized (map) {
            Object oldValue = map.put(key, entry);
            if (oldValue != null) {
                index.remove(oldValue);
            }
            updateExpireTime(entry);
            index.add(entry);
        }
    }
    public void remove(Object id) {
        synchronized (map) {
            TimeoutMapEntry entry = (TimeoutMapEntry) map.remove(id);
            if (entry != null) {
                index.remove(entry);
            }
        }
    }
    public Object[] getKeys() {
        Object[] keys = null;
        synchronized (map) {
            Set keySet = map.keySet();
            keys = new Object[keySet.size()];
            keySet.toArray(keys);
        }
        return keys;
    }
    public int size() {
        synchronized (map) {
            return map.size();
        }
    }
    /**
     * The timer task which purges old requests and schedules another poll
     */
    public void run() {
        purge();
        schedulePoll();
    }
    public void purge() {
        long now = currentTime();
        synchronized (map) {
            for (Iterator iter = index.iterator(); iter.hasNext();) {
                TimeoutMapEntry entry = (TimeoutMapEntry) iter.next();
                if (entry == null) {
                    break;
                }
                if (entry.getExpireTime() < now) {
                    if (isValidForEviction(entry)) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Evicting inactive request for correlationID: "" + entry);
                        }
                        map.remove(entry.getKey());
                        iter.remove();
                    }
                } else {
                    break;
                }
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getPurgePollTime() {
        return purgePollTime;
    }
    /**
     * Sets the next purge poll time in milliseconds
     */
    public void setPurgePollTime(long purgePollTime) {
        this.purgePollTime = purgePollTime;
    }
    public ScheduledExecutorService getExecutor() {
        return executor;
    }
    /**
     * Sets the executor used to schedule purge events of inactive requests
     */
    public void setExecutor(ScheduledExecutorService executor) {
        this.executor = executor;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * lets schedule each time to allow folks to change the time at runtime
     */
    protected void schedulePoll() {
        if (executor != null) {
            executor.schedule(this, purgePollTime, TimeUnit.MILLISECONDS);
        }
    }
    /**
     * A hook to allow derivations to avoid evicting the current entry
     */
    protected boolean isValidForEviction(TimeoutMapEntry entry) {
        return true;
    }
    protected void updateExpireTime(TimeoutMapEntry entry) {
        long now = currentTime();
        entry.setExpireTime(entry.getTimeout() + now);
    }
    protected long currentTime() {
        return System.currentTimeMillis();
    }
}
"
org.apache.camel.util.EndpointHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some helper methods for working with {@link Endpoint} instances
 *
 * @version $Revision: 640438 $
 */
public final class EndpointHelper {
    private static final transient Log LOG = LogFactory.getLog(EndpointHelper.class);
    private EndpointHelper() {
        //Utility Class
    }
    /**
     * Creates a {@link PollingConsumer} and polls all pending messages on the endpoint
     * and invokes the given {@link Processor} to process each {@link Exchange} and then closes
     * down the consumer and throws any exceptions thrown.
     *
     * @param endpoint
     * @param processor
     */
    public static void pollEndpoint(Endpoint endpoint, Processor processor, long timeout) throws Exception {
        PollingConsumer consumer = endpoint.createPollingConsumer();
        try {
            consumer.start();
            while (true) {
                Exchange exchange = consumer.receive(timeout);
                if (exchange == null) {
                    break;
                } else {
                    processor.process(exchange);
                }
            }
        } finally {
            try {
                consumer.stop();
            } catch (Exception e) {
                LOG.warn(""Failed to stop PollingConsumer: "" + e, e);
            }
        }
    }
    /**
     * Creates a {@link PollingConsumer} and polls all pending messages on the
     * endpoint and invokes the given {@link Processor} to process each
     * {@link Exchange} and then closes down the consumer and throws any
     * exceptions thrown.
     *
     * @param endpoint
     * @param processor
     */
    public static void pollEndpoint(Endpoint endpoint, Processor processor) throws Exception {
        pollEndpoint(endpoint, processor, 1000L);
    }
}
"
org.apache.camel.util.ExchangeHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.InvalidTypeException;
import org.apache.camel.Message;
import org.apache.camel.NoSuchBeanException;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.NoSuchHeaderException;
import org.apache.camel.NoSuchPropertyException;
import org.apache.camel.NoTypeConversionAvailableException;
/**
 * Some helper methods for working with {@link Exchange} objects
 *
 * @version $Revision: 732393 $
 */
public final class ExchangeHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExchangeHelper() {
    }
    /**
     * Extracts the exchange property of the given name and type; if it is not present then the
     * default value will be used
     *
     * @param exchange the message exchange
     * @param propertyName the name of the property on the exchange
     * @param type the expected type of the property
     * @param defaultValue the default value to be used if the property name does not exist or could not be
     * converted to the given type
     * @return the property value as the given type or the defaultValue if it could not be found or converted
     */
    public static <T> T getExchangeProperty(Exchange exchange, String propertyName, Class<T> type, T defaultValue) {
        T answer = exchange.getProperty(propertyName, type);
        if (answer == null) {
            return defaultValue;
        }
        return answer;
    }
    /**
     * Attempts to resolve the endpoint for the given value
     *
     * @param exchange the message exchange being processed
     * @param value the value which can be an {@link Endpoint} or an object
     *                which provides a String representation of an endpoint via
     *                {@link #toString()}
     *
     * @return the endpoint
     * @throws NoSuchEndpointException if the endpoint cannot be resolved
     */
    @SuppressWarnings({""unchecked"" })
    public static <E extends Exchange> Endpoint<E> resolveEndpoint(E exchange, Object value)
        throws NoSuchEndpointException {
        Endpoint<E> endpoint;
        if (value instanceof Endpoint) {
            endpoint = (Endpoint<E>)value;
        } else {
            String uri = value.toString();
            endpoint = CamelContextHelper.getMandatoryEndpoint(exchange.getContext(), uri);
        }
        return endpoint;
    }
    public static <T> T getMandatoryProperty(Exchange exchange, String propertyName, Class<T> type)
        throws NoSuchPropertyException {
        try {
            T result = exchange.getProperty(propertyName, type);
            if (result != null) {
                return result;
            }
        } catch (NoTypeConversionAvailableException ex) {
            // will throw NoSuchPropertyException below
        }
        throw new NoSuchPropertyException(exchange, propertyName, type);
    }
    public static <T> T getMandatoryHeader(Exchange exchange, String propertyName, Class<T> type)
        throws NoSuchHeaderException {
        T answer = exchange.getIn().getHeader(propertyName, type);
        if (answer == null) {
            throw new NoSuchHeaderException(exchange, propertyName, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryInBody(Exchange exchange) throws InvalidPayloadException {
        Object answer = exchange.getIn().getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryInBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        T answer = exchange.getIn().getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloadException {
        Message out = exchange.getOut();
        Object answer = out.getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class, out);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryOutBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        Message out = exchange.getOut();
        T answer = out.getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type, out);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type or throws an exception
     */
    public static <T> T convertToMandatoryType(Exchange exchange, Class<T> type, Object value)
        throws InvalidTypeException {
        T answer = convertToType(exchange, type, value);
        if (answer == null) {
            throw new InvalidTypeException(exchange, value, type);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type returning null if it could
     * not be converted
     */
    public static <T> T convertToType(Exchange exchange, Class<T> type, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(type, exchange, value);
    }
    /**
     * Copies the results of a message exchange from the source exchange to the result exchange
     * which will copy the out and fault message contents and the exception
     *
     * @param result the result exchange which will have the output and error state added
     * @param source the source exchange which is not modified
     */
    public static void copyResults(Exchange result, Exchange source) {
        if (result != source) {
            result.setException(source.getException());
            Message fault = source.getFault(false);
            if (fault != null) {
                result.getFault(true).copyFrom(fault);
            }
            Message out = source.getOut(false);
            if (out != null) {
                result.getOut(true).copyFrom(out);
            } else {
                // no results so lets copy the last input
                // as the final processor on a pipeline might not
                // have created any OUT; such as a mock:endpoint
                // so lets assume the last IN is the OUT
                if (result.getPattern().isOutCapable()) {
                    // only set OUT if its OUT capable
                    result.getOut(true).copyFrom(source.getIn());
                } else {
                    // if not replace IN instead to keep the MEP
                    result.getIn().copyFrom(source.getIn());
                }
            }
            result.getProperties().clear();
            result.getProperties().putAll(source.getProperties());
        }
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support IN messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * IN messages
     */
    public static boolean isInCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isInCapable();
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support OUT messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * OUT messages
     */
    public static boolean isOutCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isOutCapable();
    }
    /**
     * Creates a new instance of the given type from the injector
     */
    public static <T> T newInstance(Exchange exchange, Class<T> type) {
        return exchange.getContext().getInjector().newInstance(type);
    }
    /**
     * Creates a Map of the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @return a Map populated with the require dvariables
     */
    public static Map createVariableMap(Exchange exchange) {
        Map answer = new HashMap();
        populateVariableMap(exchange, answer);
        return answer;
    }
    /**
     * Populates the Map with the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @param map      the map to populate
     */
    public static void populateVariableMap(Exchange exchange, Map map) {
        map.put(""exchange"", exchange);
        Message in = exchange.getIn();
        map.put(""in"", in);
        map.put(""request"", in);
        map.put(""headers"", in.getHeaders());
        map.put(""body"", in.getBody());
        if (isOutCapable(exchange)) {
            Message out = exchange.getOut(true);
            map.put(""out"", out);
            map.put(""response"", out);
        }
        map.put(""camelContext"", exchange.getContext());
    }
    /**
     * Returns the MIME content type on the input message or null if one is not defined
     */
    public static String getContentType(Exchange exchange) {
        return exchange.getIn().getHeader(""Content-Type"", String.class);
    }
    /**
     * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found
     */
    public static Object lookupMandatoryBean(Exchange exchange, String name) {
        Object value = lookupBean(exchange, name);
        if (value == null) {
            throw new NoSuchBeanException(name);
        }
        return value;
    }
    /**
     * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found
     */
    public static <T> T lookupMandatoryBean(Exchange exchange, String name, Class<T> type) {
        T value = lookupBean(exchange, name, type);
        if (value == null) {
            throw new NoSuchBeanException(name);
        }
        return value;
    }
    /**
     * Performs a lookup in the registry of the bean name
     */
    public static Object lookupBean(Exchange exchange, String name) {
        return exchange.getContext().getRegistry().lookup(name);
    }
    /**
     * Performs a lookup in the registry of the bean name and type
     */
    public static <T> T lookupBean(Exchange exchange, String name, Class<T> type) {
        return exchange.getContext().getRegistry().lookup(name, type);
    }
}
"
org.apache.camel.util.ExchangeHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.Exchange;
import org.apache.camel.NoSuchPropertyException;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 630591 $
 */
public class ExchangeHelperTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(ExchangeHelperTest.class);
    protected Exchange exchange;
    public void testValidProperty() throws Exception {
        String value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", String.class);
        assertEquals(""foo property"", ""123"", value);
    }
    public void testMissingProperty() throws Exception {
        try {
            String value = ExchangeHelper.getMandatoryProperty(exchange, ""bar"", String.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    public void testPropertyOfIncompatibleType() throws Exception {
        try {
            List value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", List.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    @Override
    protected void setUp() throws Exception {
        exchange = new DefaultExchange(new DefaultCamelContext());
        exchange.setProperty(""foo"", 123);
    }
}
"
org.apache.camel.util.ExpressionComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link Comparator} which takes an {@link Expression} which is evaluated
 * on each exchange to compare
 *  
 * @version $Revision: 630591 $
 */
public class ExpressionComparator<E extends Exchange> implements Comparator<E> {
    private final Expression<E> expression;
    public ExpressionComparator(Expression<E> expression) {
        this.expression = expression;
    }
    public int compare(E e1, E e2) {
        Object o1 = expression.evaluate(e1);
        Object o2 = expression.evaluate(e2);
        return ObjectHelper.compare(o1, o2);
    }
}
"
org.apache.camel.util.ExpressionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A collection of helper methods for working with expressions.
 *
 * @version $Revision: 687515 $
 */
public final class ExpressionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionHelper() {
    }
    /**
     * Evaluates the given expression on the exchange as a String value
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the result of the evaluation as a string.
     */
    public static <E extends Exchange> String evaluateAsString(Expression<E> expression, E exchange) {
        return evaluateAsType(expression, exchange, String.class);
    }
    /**
     * Evaluates the given expression on the exchange, converting the result to
     * the given type
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @param resultType the type of the result that is required
     * @return the result of the evaluation as the specified type.
     */
    public static <T, E extends Exchange> T evaluateAsType(Expression<E> expression, E exchange,
                                                           Class<T> resultType) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(resultType, exchange, value);
    }
}
"
org.apache.camel.util.ExpressionListComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link java.util.Comparator} which takes a list of
 * {@link org.apache.camel.Expression} objects which is evaluated
 * on each exchange to compare them
 *
 * @version $Revision: 630591 $
 */
public class ExpressionListComparator implements Comparator<Exchange> {
    private final List<Expression> expressions;
    public ExpressionListComparator(List<Expression> expressions) {
        this.expressions = expressions;
    }
    public int compare(Exchange e1, Exchange e2) {
        for (Expression expression : expressions) {
            Object o1 = expression.evaluate(e1);
            Object o2 = expression.evaluate(e2);
            int answer = ObjectHelper.compare(o1, o2);
            if (answer != 0) {
                return answer;
            }
        }
        return 0;
    }
}
"
org.apache.camel.util.FactoryFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.spi.Injector;
/**
 * Finder to find factories from the resource classpath, usually <b>META-INF/services/org/apache/camel/</b>.
 */
public class FactoryFinder {
    protected final ConcurrentHashMap<String, Class> classMap = new ConcurrentHashMap<String, Class>();
    private final String path;    
    public FactoryFinder() {
        this(""META-INF/services/org/apache/camel/"");
    }
    public FactoryFinder(String path) {
        this.path = path;
    }
    /**
     * Creates a new instance of the given key
     *
     * @param key is the key to add to the path to find a text file containing
     *            the factory name
     * @return a newly created instance
     */
    public Object newInstance(String key) throws IllegalAccessException, InstantiationException, IOException,
        ClassNotFoundException {
        return newInstance(key, (String)null);
    }
    public Object newInstance(String key, String propertyPrefix) throws IllegalAccessException,
        InstantiationException, IOException, ClassNotFoundException {
        Class clazz = findClass(key, propertyPrefix);
        return clazz.newInstance();
    }
    public Object newInstance(String key, Injector injector) throws IOException, ClassNotFoundException {
        return newInstance(key, injector, (String)null);
    }
    public Object newInstance(String key, Injector injector, String propertyPrefix) throws IOException,
        ClassNotFoundException {
        Class<?> type = findClass(key, propertyPrefix);
        return injector.newInstance(type);
    }
    public <T> T newInstance(String key, Injector injector, Class<T> expectedType) throws IOException,
        ClassNotFoundException {
        return newInstance(key, injector, null, expectedType);
    }
    public <T> T newInstance(String key, Injector injector, String propertyPrefix, Class<T> expectedType)
        throws IOException, ClassNotFoundException {
        Class<?> type = findClass(key, propertyPrefix);
        Object value = injector.newInstance(type);
        if (expectedType.isInstance(value)) {
            return expectedType.cast(value);
        } else {
            throw new ClassCastException(""Not instanceof "" + expectedType.getName() + "" value: "" + value);
        }
    }
    public <T> List<T> newInstances(String key, Injector injector, Class<T> type) throws IOException,
        ClassNotFoundException {
        List<Class> list = findClasses(key);
        List<T> answer = new ArrayList<T>(list.size());
        answer.add(newInstance(key, injector, type));
        return answer;
    }
    public Class findClass(String key) throws ClassNotFoundException, IOException {
        return findClass(key, null);
    }
    public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
        if (propertyPrefix == null) {
            propertyPrefix = """";
        }
        Class clazz = (Class)classMap.get(propertyPrefix + key);
        if (clazz == null) {
            clazz = newInstance(doFindFactoryProperties(key), propertyPrefix);
            if (clazz != null) {
                classMap.put(propertyPrefix + key, clazz);
            }
        }
        return clazz;
    }
    public List<Class> findClasses(String key) throws ClassNotFoundException, IOException {
        return findClasses(key, null);
    }
    public List<Class> findClasses(String key, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        // TODO change to support finding multiple classes on the classpath!
        Class type = findClass(key, propertyPrefix);
        return Collections.singletonList(type);
    }
    public String getPath() {
        return path;
    }
    private Class newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        String className = properties.getProperty(propertyPrefix + ""class"");
        if (className == null) {
            throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
        }
        return ObjectHelper.loadClass(className);
    }
    private Properties doFindFactoryProperties(String key) throws IOException {
        String uri = path + key;
        InputStream in = ObjectHelper.loadResourceAsStream(uri);
        if (in == null) {
            throw new NoFactoryAvailableException(uri);
        }
        // lets load the file
        BufferedInputStream reader = null;
        try {
            reader = new BufferedInputStream(in);
            Properties properties = new Properties();
            properties.load(reader);
            return properties;
        } finally {
            ObjectHelper.close(reader, key, null);
            ObjectHelper.close(in, key, null);
        }
    }
}
"
org.apache.camel.util.IntrospectionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.TypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Helper for introspections of beans.
 */
public final class IntrospectionSupport {
    private static final transient Log LOG = LogFactory.getLog(IntrospectionSupport.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private IntrospectionSupport() {
    }
    public static boolean getProperties(Object target, Map props, String optionPrefix) {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        if (optionPrefix == null) {
            optionPrefix = """";
        }
        Class clazz = target.getClass();
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            String name = method.getName();
            Class type = method.getReturnType();
            Class params[] = method.getParameterTypes();
            if (name.startsWith(""get"") && params.length == 0 && type != null && isSettableType(type)) {
                try {
                    Object value = method.invoke(target);
                    if (value == null) {
                        continue;
                    }
                    String strValue = convertToString(value, type);
                    if (strValue == null) {
                        continue;
                    }
                    name = name.substring(3, 4).toLowerCase() + name.substring(4);
                    props.put(optionPrefix + name, strValue);
                    rc = true;
                } catch (Throwable ignore) {
                    // ignore
                }
            }
        }
        return rc;
    }
    public static Object getProperty(Object target, String prop) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (prop == null) {
            throw new IllegalArgumentException(""prop was null."");
        }
        prop = prop.substring(0, 1).toUpperCase() + prop.substring(1);
        Class clazz = target.getClass();
        Method method = getPropertyGetter(clazz, prop);
        return method.invoke(target);
    }
    public static Method getPropertyGetter(Class type, String propertyName) throws NoSuchMethodException {
        Method method = type.getMethod(""get"" + ObjectHelper.capitalize(propertyName));
        return method;
    }
    public static boolean setProperties(Object target, Map props, String optionPrefix) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                if (setProperty(target, name, value)) {
                    iter.remove();
                    rc = true;
                }
            }
        }
        return rc;
    }
    public static Map extractProperties(Map props, String optionPrefix) {
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        HashMap rc = new HashMap(props.size());
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                rc.put(name, value);
                iter.remove();
            }
        }
        return rc;
    }
    public static boolean setProperties(TypeConverter typeConverter, Object target, Map props) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            if (setProperty(typeConverter, target, (String)entry.getKey(), entry.getValue())) {
                iter.remove();
                rc = true;
            }
        }
        return rc;
    }
    public static boolean setProperties(Object target, Map props) throws Exception {
        return setProperties(null, target, props);
    }
    public static boolean setProperty(TypeConverter typeConverter, Object target, String name, Object value) throws Exception {
        try {
            Class clazz = target.getClass();
            // find candidates of setter methods as there can be overloaded setters
            Set<Method> setters = findSetterMethods(typeConverter, clazz, name, value);
            if (setters.isEmpty()) {
                return false;
            }
            // loop and execute the best setter method
            Exception typeConvertionFailed = null;
            for (Method setter : setters) {
                // If the type is null or it matches the needed type, just use the value directly
                if (value == null || setter.getParameterTypes()[0].isAssignableFrom(value.getClass())) {
                    setter.invoke(target, value);
                    return true;
                } else {
                    // We need to convert it
                    try {
                        // ignore exceptions as there could be another setter method where we could type convert successfully
                        Object convertedValue = convert(typeConverter, setter.getParameterTypes()[0], value);
                        setter.invoke(target, convertedValue);
                        return true;
                    } catch (NoTypeConversionAvailableException e) {
                        typeConvertionFailed = e;
                    } catch (IllegalArgumentException e) {
                        typeConvertionFailed = e;
                    }
                    LOG.trace(""Setter \"""" + setter + ""\"" with parameter type \""""
                              + setter.getParameterTypes()[0] + ""\"" could not be used for type conertions of "" + value);
                }
            }
            // we did not find a setter method to use, and if we did try to use a type converter then throw
            // this kind of exception as the caused by will hint this error
            if (typeConvertionFailed != null) {
                throw new IllegalArgumentException(""Could not find a suitable setter for property: "" + name
                        + "" as there isn't a setter method with same type: "" + value.getClass().getCanonicalName()
                        + "" nor type convertion possbile: "" + typeConvertionFailed.getMessage());
            } else {
                return false;
            }
        } catch (InvocationTargetException e) {
            // lets unwrap the exception
            Throwable throwable = e.getCause();
            if (throwable instanceof Exception) {
                Exception exception = (Exception)throwable;
                throw exception;
            } else {
                Error error = (Error)throwable;
                throw error;
            }
        }
    }
    public static boolean setProperty(Object target, String name, Object value) throws Exception {
        return setProperty(null, target, name, value);
    }
    private static Object convert(TypeConverter typeConverter, Class type, Object value) throws URISyntaxException {
        if (typeConverter != null) {
            return typeConverter.convertTo(type, value);
        }
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setAsText(value.toString());
            return editor.getValue();
        }
        if (type == URI.class) {
            return new URI(value.toString());
        }
        return null;
    }
    private static String convertToString(Object value, Class type) throws URISyntaxException {
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setValue(value);
            return editor.getAsText();
        }
        if (type == URI.class) {
            return value.toString();
        }
        return null;
    }
    private static Set<Method> findSetterMethods(TypeConverter typeConverter, Class clazz, String name, Object value) {
        Set<Method> candidates = new LinkedHashSet<Method>();
        // Build the method name.
        name = ""set"" + ObjectHelper.capitalize(name);
        while (clazz != Object.class) {
            // Since Object.class.isInstance all the objects,
            // Here we just make sure it will be add to the bottom of the set.
            Method objectSetMethod = null;
            Method[] methods = clazz.getMethods();
            for (Method method : methods) {
                Class params[] = method.getParameterTypes();
                if (method.getName().equals(name) && params.length == 1) {
                    Class paramType = params[0];
                    if (paramType.equals(Object.class)) {                        
                        objectSetMethod = method;
                    } else if (typeConverter != null || isSettableType(paramType) || paramType.isInstance(value)) {
                        candidates.add(method);
                    }
                }
            }
            if (objectSetMethod != null) {
                candidates.add(objectSetMethod);
            }
            clazz = clazz.getSuperclass();
        }
        if (candidates.isEmpty()) {
            return candidates;
        } else if (candidates.size() == 1) {
            // only one
            return candidates;
        } else {
            // find the best match if possible
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Found "" + candidates.size() + "" suitable setter methods for setting "" + name);
            }
            // prefer to use the one with the same instance if any exists
            for (Method method : candidates) {                               
                if (method.getParameterTypes()[0].isInstance(value)) {
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Method "" + method + "" is the best candidate as it has parameter with same instance type"");
                    }
                    // retain only this method in the answer
                    candidates.clear();
                    candidates.add(method);
                    return candidates;
                }
            }
            // fallback to return what we have found as candidates so far
            return candidates;
        }
    }
    private static boolean isSettableType(Class clazz) {
        if (PropertyEditorManager.findEditor(clazz) != null) {
            return true;
        }
        if (clazz == URI.class) {
            return true;
        }
        if (clazz == Boolean.class) {
            return true;
        }
        return false;
    }
    public static String toString(Object target) {
        return toString(target, Object.class);
    }
    public static String toString(Object target, Class stopClass) {
        LinkedHashMap map = new LinkedHashMap();
        addFields(target, target.getClass(), stopClass, map);
        StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
        buffer.append("" {"");
        Set entrySet = map.entrySet();
        boolean first = true;
        for (Iterator iter = entrySet.iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            if (first) {
                first = false;
            } else {
                buffer.append("", "");
            }
            buffer.append(entry.getKey());
            buffer.append("" = "");
            appendToString(buffer, entry.getValue());
        }
        buffer.append(""}"");
        return buffer.toString();
    }
    protected static void appendToString(StringBuffer buffer, Object value) {
        // if (value instanceof ActiveMQDestination) {
        // ActiveMQDestination destination = (ActiveMQDestination) value;
        // buffer.append(destination.getQualifiedName());
        // }
        // else {
        buffer.append(value);
        // }
    }
    public static String simpleName(Class clazz) {
        String name = clazz.getName();
        int p = name.lastIndexOf(""."");
        if (p >= 0) {
            name = name.substring(p + 1);
        }
        return name;
    }
    private static void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
        if (startClass != stopClass) {
            addFields(target, startClass.getSuperclass(), stopClass, map);
        }
        Field[] fields = startClass.getDeclaredFields();
        for (Field field : fields) {
            if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())
                || Modifier.isPrivate(field.getModifiers())) {
                continue;
            }
            try {
                field.setAccessible(true);
                Object o = field.get(target);
                if (o != null && o.getClass().isArray()) {
                    try {
                        o = Arrays.asList((Object[])o);
                    } catch (Throwable e) {
                        // ignore
                    }
                }
                map.put(field.getName(), o);
            } catch (Throwable e) {
                LOG.debug(""Error adding fields"", e);
            }
        }
    }
}
"
org.apache.camel.util.IntrospectionSupportTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.util.jndi.ExampleBean;
/**
 * Unit test for IntrospectionSupport 
 */
public class IntrospectionSupportTest extends ContextTestSupport {
    public void testOverloadSetterChooseStringSetter() throws Exception {
        MyOverloadedBean overloadedBean = new MyOverloadedBean();
        IntrospectionSupport.setProperty(context.getTypeConverter(), overloadedBean, ""bean"", ""James"");
        assertEquals(""James"", overloadedBean.getName());
    }
    public void testOverloadSetterChooseBeanSetter() throws Exception {
        MyOverloadedBean overloadedBean = new MyOverloadedBean();
        ExampleBean bean = new ExampleBean();
        bean.setName(""Claus"");
        IntrospectionSupport.setProperty(context.getTypeConverter(), overloadedBean, ""bean"", bean);
        assertEquals(""Claus"", overloadedBean.getName());
    }
    public void testOverloadSetterChooseUsingTypeConverter() throws Exception {
        MyOverloadedBean overloadedBean = new MyOverloadedBean();
        Object value = ""Willem"".getBytes();
        // should use byte[] -> String type converter and call the setBean(String) setter method 
        IntrospectionSupport.setProperty(context.getTypeConverter(), overloadedBean, ""bean"", value);
        assertEquals(""Willem"", overloadedBean.getName());
    }
    public class MyOverloadedBean {
        private ExampleBean bean;
        public void setBean(ExampleBean bean) {
            this.bean = bean;
        }
        public void setBean(String name) {
            bean = new ExampleBean();
            bean.setName(name);
        }
        public String getName() {
            return bean.getName();
        }
    }
}
"
org.apache.camel.util.IOHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * IO helper class.
 *
 * @version $Revision: 659836 $
 */
public final class IOHelper {
    private IOHelper() {
        //Utility Class
    }
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(Throwable cause) {
        return createIOException(cause.getMessage(), cause);
    }
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(String message, Throwable cause) {
        IOException answer = new IOException(message);
        answer.initCause(cause);
        return answer;
    }
}
"
org.apache.camel.util.LRUCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.LinkedHashMap;
import java.util.Map;
/**
 * A Least Recently Used Cache
 *
 * @version $Revision: 655284 $
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final long serialVersionUID = -342098639681884413L;
    private int maxCacheSize = 10000;
    public LRUCache(int maximumCacheSize) {
        this(maximumCacheSize, maximumCacheSize, 0.75f, true);
    }
    /**
     * Constructs an empty <tt>LRUCache</tt> instance with the
     * specified initial capacity, maximumCacheSize,load factor and ordering mode.
     *
     * @param initialCapacity  the initial capacity.
     * @param maximumCacheSize
     * @param loadFactor       the load factor.
     * @param accessOrder      the ordering mode - <tt>true</tt> for
     *                         access-order, <tt>false</tt> for insertion-order.
     * @throws IllegalArgumentException if the initial capacity is negative
     *                                  or the load factor is non positive.
     */
    public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor, accessOrder);
        this.maxCacheSize = maximumCacheSize;
    }
    /**
     * Returns the maxCacheSize.
     */
    public int getMaxCacheSize() {
        return maxCacheSize;
    }
    protected boolean removeEldestEntry(Map.Entry entry) {
        return size() > maxCacheSize;
    }
}
"
org.apache.camel.util.MainSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.xml.bind.JAXBException;
import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.interceptor.Debugger;
import org.apache.camel.view.ModelFileGenerator;
import org.apache.camel.view.RouteDotGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 735424 $
 */
public abstract class MainSupport extends ServiceSupport {
    protected static final Log LOG = LogFactory.getLog(MainSupport.class);
    protected String dotOutputDir;
    private List<Option> options = new ArrayList<Option>();
    private CountDownLatch latch = new CountDownLatch(1);
    private AtomicBoolean completed = new AtomicBoolean(false);
    private long duration = -1;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;    
    private String routesOutputFile;
    private boolean aggregateDot;
    private boolean debug;
    private boolean trace;
    private List<RouteBuilder> routeBuilders = new ArrayList<RouteBuilder>();
    private List<CamelContext> camelContexts = new ArrayList<CamelContext>();
    private ProducerTemplate camelTemplate;
    protected MainSupport() {
        addOption(new Option(""h"", ""help"", ""Displays the help screen"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                showOptions();
                completed();
            }
        });
        addOption(new ParameterOption(""o"", ""outdir"",
                ""Sets the DOT output directory where the visual representations of the routes are generated"",
                ""dot"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setDotOutputDir(parameter);
            }
        });
        addOption(new ParameterOption(""ad"", ""aggregate-dot"",
                ""Aggregates all routes (in addition to individual route generation) into one context to create one monolithic DOT file for visual representations the entire system."",
                ""aggregate-dot"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setAggregateDot(""true"".equals(parameter));
            }
        });
        addOption(new ParameterOption(""d"", ""duration"",
                ""Sets the time duration that the applicaiton will run for, by default in milliseconds. You can use '10s' for 10 seconds etc"",
                ""duration"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                String value = parameter.toUpperCase();
                if (value.endsWith(""S"")) {
                    value = value.substring(0, value.length() - 1);
                    setTimeUnit(TimeUnit.SECONDS);
                }
                setDuration(Integer.parseInt(value));
            }
        });
        addOption(new Option(""x"", ""debug"", ""Enables the debugger"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                enableDebug();
            }
        });
        addOption(new Option(""t"", ""trace"", ""Enables tracing"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                enableTrace();
            }
        });
        addOption(new ParameterOption(""out"", ""output"", ""Output all routes to the specified XML file"", ""filename"") {
            protected void doProcess(String arg, String parameter,
                    LinkedList<String> remainingArgs) {
                setRoutesOutputFile(parameter);
            }
        });
    }
    /**
     * Runs this process with the given arguments
     */
    public void run() {
        if (!completed.get()) {
            try {
                start();
                waitUntilCompleted();
                stop();
            } catch (Exception e) {
                LOG.error(""Failed: "" + e, e);
            }
        }
    }
    /**
     * Marks this process as being completed
     */
    public void completed() {
        completed.set(true);
        latch.countDown();
    }
    /**
     * Displays the command line options
     */
    public void showOptions() {
        showOptionsHeader();
        for (Option option : options) {
            System.out.println(option.getInformation());
        }
    }
    /**
     * Parses the command line arguments
     */
    public void parseArguments(String[] arguments) {
        LinkedList<String> args = new LinkedList<String>(Arrays.asList(arguments));
        boolean valid = true;
        while (!args.isEmpty()) {
            String arg = args.removeFirst();
            boolean handled = false;
            for (Option option : options) {
                if (option.processOption(arg, args)) {
                    handled = true;
                    break;
                }
            }
            if (!handled) {
                System.out.println(""Unknown option: "" + arg);
                System.out.println();
                valid = false;
                break;
            }
        }
        if (!valid) {
            showOptions();
            completed();
        }
    }
    public void addOption(Option option) {
        options.add(option);
    }
    public long getDuration() {
        return duration;
    }
    /**
     * Sets the duration to run the application for in milliseconds until it
     * should be terminated. Defaults to -1. Any value <= 0 will run forever.
     */
    public void setDuration(long duration) {
        this.duration = duration;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    /**
     * Sets the time unit duration
     */
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public String getDotOutputDir() {
        return dotOutputDir;
    }
    /**
     * Sets the output directory of the generated DOT Files to show the visual
     * representation of the routes. A null value disables the dot file
     * generation
     */
    public void setDotOutputDir(String dotOutputDir) {
        this.dotOutputDir = dotOutputDir;
    }
    public void setAggregateDot(boolean aggregateDot) {
        this.aggregateDot = aggregateDot;
    }
    public boolean isAggregateDot() {
        return aggregateDot;
    }
    public boolean isDebug() {
        return debug;
    }
    public void enableDebug() {
        this.debug = true;
    }
    public boolean isTrace() {
        return trace;
    }
    public void enableTrace() {
        this.trace = true;
    }
    public void setRoutesOutputFile(String routesOutputFile) {
        this.routesOutputFile = routesOutputFile;
    }
    public String getRoutesOutputFile() {
        return routesOutputFile;
    }
    /**
     * Returns the currently active debugger if one is enabled
     *
     * @return the current debugger or null if none is active
     * @see #enableDebug()
     */
    public Debugger getDebugger() {
        for (CamelContext camelContext : camelContexts) {
            Debugger debugger = Debugger.getDebugger(camelContext);
            if (debugger != null) {
                return debugger;
            }
        }
        return null;
    }
    protected void doStop() throws Exception {
        LOG.info(""Apache Camel "" + getVersion() + "" stopping"");
        // call completed to properly stop as we count down the waiting latch
        completed();
    }
    protected void doStart() throws Exception {
        LOG.info(""Apache Camel "" + getVersion() + "" starting"");
    }
    protected void waitUntilCompleted() {
        while (!completed.get()) {
            try {
                if (duration > 0) {
                    TimeUnit unit = getTimeUnit();
                    LOG.info(""Waiting for: "" + duration + "" "" + unit);
                    latch.await(duration, unit);
                    completed.set(true);
                } else {
                    latch.await();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    /**
     * Parses the command line arguments then runs the program
     */
    public void run(String[] args) {
        parseArguments(args);
        run();
    }
    /**
     * Displays the header message for the command line options
     */
    public void showOptionsHeader() {
        System.out.println(""Apache Camel Runner takes the following options"");
        System.out.println();
    }
    public List<CamelContext> getCamelContexts() {
        return camelContexts;
    }
    public List<RouteBuilder> getRouteBuilders() {
        return routeBuilders;
    }
    public void setRouteBuilders(List<RouteBuilder> routeBuilders) {
        this.routeBuilders = routeBuilders;
    }
    public List<RouteType> getRouteDefinitions() {
        List<RouteType> answer = new ArrayList<RouteType>();
        for (CamelContext camelContext : camelContexts) {
            answer.addAll(camelContext.getRouteDefinitions());
        }
        return answer;
    }
    /**
     * Returns a {@link org.apache.camel.ProducerTemplate} from the Spring {@link org.springframework.context.ApplicationContext} instances
     * or lazily creates a new one dynamically
     */
    public ProducerTemplate getCamelTemplate() {
        if (camelTemplate == null) {
            camelTemplate = findOrCreateCamelTemplate();
        }
        return camelTemplate;
    }
    protected abstract ProducerTemplate findOrCreateCamelTemplate();
    protected abstract Map<String, CamelContext> getCamelContextMap();
    protected void postProcessContext() throws Exception {
        Map<String, CamelContext> map = getCamelContextMap();
        Set<Map.Entry<String, CamelContext>> entries = map.entrySet();
        int size = entries.size();
        for (Map.Entry<String, CamelContext> entry : entries) {
            String name = entry.getKey();
            CamelContext camelContext = entry.getValue();
            camelContexts.add(camelContext);
            generateDot(name, camelContext, size);
            postProcesCamelContext(camelContext);
        }
        if (isAggregateDot()) {
            generateDot(""aggregate"", aggregateCamelContext(), 1);
        }
        if (!"""".equals(getRoutesOutputFile())) {
            outputRoutesToFile();
        }
    }
    protected void outputRoutesToFile() throws IOException, JAXBException {
        if (ObjectHelper.isNotNullAndNonEmpty(getRoutesOutputFile())) {
            LOG.info(""Generating routes as XML in the file named: "" + getRoutesOutputFile());
            ModelFileGenerator generator = createModelFileGenerator();
            generator.marshalRoutesUsingJaxb(getRoutesOutputFile(), getRouteDefinitions());
        }
    }
    protected abstract ModelFileGenerator createModelFileGenerator() throws JAXBException;
    protected void generateDot(String name, CamelContext camelContext, int size) throws IOException {
        String outputDir = dotOutputDir;
        if (ObjectHelper.isNotNullAndNonEmpty(outputDir)) {
            if (size > 1) {
                outputDir += ""/"" + name;
            }
            RouteDotGenerator generator = new RouteDotGenerator(outputDir);
            LOG.info(""Generating DOT file for routes: "" + outputDir + "" for: "" + camelContext + "" with name: "" + name);
            generator.drawRoutes(camelContext);
        }
    }
    /**
     * Used for aggregate dot generation, generate a single camel context containing all of the available contexts
     */
    private CamelContext aggregateCamelContext() throws Exception {
        if (camelContexts.size() == 1) {
            return camelContexts.get(0);
        } else {
            DefaultCamelContext answer = new DefaultCamelContext();
            for (CamelContext camelContext : camelContexts) {
                answer.addRouteDefinitions(camelContext.getRouteDefinitions());
            }
            return answer;
        }
    }
    protected void postProcesCamelContext(CamelContext camelContext) throws Exception {
        for (RouteBuilder routeBuilder : routeBuilders) {
            camelContext.addRoutes(routeBuilder);
        }
    }
    public void addRouteBuilder(RouteBuilder routeBuilder) {
        getRouteBuilders().add(routeBuilder);
    }
    public abstract class Option {
        private String abbreviation;
        private String fullName;
        private String description;
        protected Option(String abbreviation, String fullName, String description) {
            this.abbreviation = ""-"" + abbreviation;
            this.fullName = ""-"" + fullName;
            this.description = description;
        }
        public boolean processOption(String arg, LinkedList<String> remainingArgs) {
            if (arg.equalsIgnoreCase(abbreviation) || fullName.startsWith(arg)) {
                doProcess(arg, remainingArgs);
                return true;
            }
            return false;
        }
        public String getAbbreviation() {
            return abbreviation;
        }
        public String getDescription() {
            return description;
        }
        public String getFullName() {
            return fullName;
        }
        public String getInformation() {
            return ""  "" + getAbbreviation() + "" or "" + getFullName() + "" = "" + getDescription();
        }
        protected abstract void doProcess(String arg, LinkedList<String> remainingArgs);
    }
    public abstract class ParameterOption extends Option {
        private String parameterName;
        protected ParameterOption(String abbreviation, String fullName, String description,
                String parameterName) {
            super(abbreviation, fullName, description);
            this.parameterName = parameterName;
        }
        protected void doProcess(String arg, LinkedList<String> remainingArgs) {
            if (remainingArgs.isEmpty()) {
                System.err.println(""Expected fileName for "");
                showOptions();
                completed();
            } else {
                String parameter = remainingArgs.removeFirst();
                doProcess(arg, parameter, remainingArgs);
            }
        }
        public String getInformation() {
            return ""  "" + getAbbreviation() + "" or "" + getFullName()
                    + "" <"" + parameterName + ""> = "" + getDescription();
        }
        protected abstract void doProcess(String arg, String parameter, LinkedList<String> remainingArgs);
    }
}
"
org.apache.camel.util.MessageHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.converter.stream.StreamCache;
/**
 * Some helper methods when working with {@link org.apache.camel.Message}.
 *
 * @version $Revision: 740251 $
 */
public final class MessageHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private MessageHelper() {
    }
    /**
     * Extracts the given body and returns it as a String, that
     * can be used for logging etc.
     * <p/>
     * Will handle stream based bodies wrapped in StreamCache.
     *
     * @param message  the message with the body
     * @return the body as String, can return <tt>null</null> if no body
     */
    public static String extractBodyAsString(Message message) {
        if (message == null) {
            return null;
        }
        StreamCache newBody = null;
        try {
            newBody = message.getBody(StreamCache.class);
            if (newBody != null) {
                message.setBody(newBody);
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore, in not of StreamCache type
        }
        Object answer;
        try {
            answer = message.getBody(String.class);
        } catch (NoTypeConversionAvailableException ex) {
            answer = message.getBody();
        }
        if (newBody != null) {
            // Reset the InputStreamCache
            newBody.reset();
        }
        return answer != null ? answer.toString() : null;
    }
    /**
     * Gets the given body class type name as a String.
     * <p/>
     * Will skip java.lang. for the build in Java types.
     *
     * @param message  the message with the body
     * @return the body typename as String, can return <tt>null</null> if no body
     */
    public static String getBodyTypeName(Message message) {
        if (message == null) {
            return null;
        }
        String answer = ObjectHelper.classCanonicalName(message.getBody());
        if (answer != null && answer.startsWith(""java.lang."")) {
            return answer.substring(10);
        }
        return answer;
    }
    /**
     * If the message body contains a {@link StreamCache} instance, reset the cache to 
     * enable reading from it again.
     * 
     * @param message the message for which to reset the body
     */
    public static void resetStreamCache(Message message) {
        if (message == null) {
            return;
        }
        if (message.getBody() instanceof StreamCache) {
            ((StreamCache) message.getBody()).reset();
        }
    }
}
"
org.apache.camel.util.MessageHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
import org.apache.camel.Message;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.impl.DefaultMessage;
/**
 * Test cases for {@link MessageHelper}
 */
public class MessageHelperTest extends TestCase {
    private Message message;
    @Override
    protected void setUp() throws Exception {
        message = new DefaultMessage();
    }
    /*
     * Tests the {@link MessageHelper#resetStreamCache(Message)} method
     */
    public void testResetStreamCache() throws Exception {
        // should not throw exceptions when Message or message body is null
        MessageHelper.resetStreamCache((Message) null);
        MessageHelper.resetStreamCache(message);
        // handle StreamCache
        final ValueHolder<Boolean> reset = new ValueHolder<Boolean>(Boolean.FALSE);
        message.setBody(new StreamCache() {
            public void reset() {
                reset.set(Boolean.TRUE);
            }
        });
        MessageHelper.resetStreamCache(message);
        assertTrue(""Should have reset the stream cache"", reset.get());
    }
}
"
org.apache.camel.util.NoFactoryAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * Thrown if no factory resource is available for the given URI
 *
 * @version $Revision: 630591 $
 */
public class NoFactoryAvailableException extends IOException {
    private final String uri;
    public NoFactoryAvailableException(String uri) {
        super(""Could not find factory class for resource: "" + uri);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.util.ObjectHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A number of useful helper methods for working with Objects
 *
 * @version $Revision: 739202 $
 */
public final class ObjectHelper {
    private static final transient Log LOG = LogFactory.getLog(ObjectHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectHelper() {
    }
    /**
     * @deprecated use the equal method instead. Will be removed in Camel 2.0.
     *
     * @see #equal(Object, Object)
     */
    @Deprecated
    public static boolean equals(Object a, Object b) {
        return equal(a, b);
    }
    /**
     * A helper method for comparing objects for equality while handling nulls
     */
    public static boolean equal(Object a, Object b) {
        if (a == b) {
            return true;
        }
        if (a instanceof byte[] && b instanceof byte[]) {
            return equalByteArray((byte[]) a, (byte[]) b);
        }
        return a != null && b != null && a.equals(b);
    }
    /**
     * A helper method for comparing byte arrays for equality while handling nulls
     */
    public static boolean equalByteArray(byte[] a, byte[] b) {
        if (a == b) {
            return true;
        }
        // loop and compare each byte
        if (a != null && b != null && a.length == b.length) {
            for (int i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    return false;
                }
            }
            // all bytes are equal
            return true;
        }
        return false;
    }
    /**
     * Returns true if the given object is equal to any of the expected value
     */
    public static boolean isEqualToAny(Object object, Object... values) {
        for (Object value : values) {
            if (equal(object, value)) {
                return true;
            }
        }
        return false;
    }
    /**
     * A helper method for performing an ordered comparison on the objects
     * handling nulls and objects which do not handle sorting gracefully
     */
    public static int compare(Object a, Object b) {
        if (a == b) {
            return 0;
        }
        if (a == null) {
            return -1;
        }
        if (b == null) {
            return 1;
        }
        if (a instanceof Comparable) {
            Comparable comparable = (Comparable)a;
            return comparable.compareTo(b);
        } else {
            int answer = a.getClass().getName().compareTo(b.getClass().getName());
            if (answer == 0) {
                answer = a.hashCode() - b.hashCode();
            }
            return answer;
        }
    }
    public static Boolean toBoolean(Object value) {
        if (value instanceof Boolean) {
            return (Boolean)value;
        }
        if (value instanceof String) {
            return ""true"".equalsIgnoreCase(value.toString()) ? Boolean.TRUE : Boolean.FALSE;
        }
        if (value instanceof Integer) {
            return (Integer)value > 0 ? Boolean.TRUE : Boolean.FALSE;
        }
        return null;
    }
    /**
     * Asserts whether the value is <b>not</b> <tt>null</tt>
     *
     * @param value  the value to test
     * @param name   the key that resolved the value
     * @throws IllegalArgumentException is thrown if assertion fails
     */
    public static void notNull(Object value, String name) {
        if (value == null) {
            throw new IllegalArgumentException(name + "" must be specified"");
        }
    }
    /**
     * Asserts whether the value is <b>not</b> <tt>null</tt>
     *
     * @param value  the value to test
     * @param on     additional description to indicate where this problem occured (appended as toString())
     * @param name   the key that resolved the value
     * @throws IllegalArgumentException is thrown if assertion fails
     */
    public static void notNull(Object value, String name, Object on) {
        if (on == null) {
            notNull(value, name);
        } else if (value == null) {
            throw new IllegalArgumentException(name + "" must be specified on: "" + on);
        }
    }
    /**
     * Asserts whether the string is <b>not</b> empty.
     *
     * @param value  the string to test
     * @param name   the key that resolved the value
     * @throws IllegalArgumentException is thrown if assertion fails
     */
    public static void notEmpty(String value, String name) {
        if (isEmpty(value)) {
            throw new IllegalArgumentException(name + "" must be specified and not empty"");
        }
    }
    /**
     * Asserts whether the string is <b>not</b> empty.
     *
     * @param value  the string to test
     * @param on     additional description to indicate where this problem occured (appended as toString())
     * @param name   the key that resolved the value
     * @throws IllegalArgumentException is thrown if assertion fails
     */
    public static void notEmpty(String value, String name, Object on) {
        if (on == null) {
            notNull(value, name);
        } else if (isEmpty(value)) {
            throw new IllegalArgumentException(name + "" must be specified and not empty on: "" + on);
        }
    }
    public static String[] splitOnCharacter(String value, String needle, int count) {
        String rc[] = new String[count];
        rc[0] = value;
        for (int i = 1; i < count; i++) {
            String v = rc[i - 1];
            int p = v.indexOf(needle);
            if (p < 0) {
                return rc;
            }
            rc[i - 1] = v.substring(0, p);
            rc[i] = v.substring(p + 1);
        }
        return rc;
    }
    /**
     * Removes any starting characters on the given text which match the given
     * character
     *
     * @param text the string
     * @param ch the initial characters to remove
     * @return either the original string or the new substring
     */
    public static String removeStartingCharacters(String text, char ch) {
        int idx = 0;
        while (text.charAt(idx) == ch) {
            idx++;
        }
        if (idx > 0) {
            return text.substring(idx);
        }
        return text;
    }
    public static String capitalize(String text) {
        if (text == null) {
            return null;
        }
        int length = text.length();
        if (length == 0) {
            return text;
        }
        String answer = text.substring(0, 1).toUpperCase();
        if (length > 1) {
            answer += text.substring(1, length);
        }
        return answer;
    }
    /**
     * Returns true if the collection contains the specified value
     */
    @SuppressWarnings(""unchecked"")
    public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection)collectionOrArray;
            return collection.contains(value);
        } else if (collectionOrArray instanceof String && value instanceof String) {
            String str = (String) collectionOrArray;
            String subStr = (String) value;
            return str.contains(subStr);
        } else {
            Iterator iter = createIterator(collectionOrArray);
            while (iter.hasNext()) {
                if (equal(value, iter.next())) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Creates an iterator over the value if the value is a collection, an
     * Object[] or a primitive type array; otherwise to simplify the caller's
     * code, we just create a singleton collection iterator over a single value
     */
    @SuppressWarnings(""unchecked"")
    public static Iterator createIterator(Object value) {
        if (value == null) {
            return Collections.EMPTY_LIST.iterator();
        } else if (value instanceof Iterator) {
            return (Iterator) value;
        } else if (value instanceof Collection) {
            Collection collection = (Collection)value;
            return collection.iterator();
        } else if (value.getClass().isArray()) {
            // TODO we should handle primitive array types?
            List<Object> list = Arrays.asList((Object[]) value);
            return list.iterator();
        } else if (value instanceof NodeList) {
            // lets iterate through DOM results after performing XPaths
            final NodeList nodeList = (NodeList) value;
            return new Iterator<Node>() {
                int idx = -1;
                public boolean hasNext() {
                    return ++idx < nodeList.getLength();
                }
                public Node next() {
                    return nodeList.item(idx);
                }
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            };
        } else if (value instanceof String) {
            Scanner scanner = new Scanner((String)value);
            // use comma as delimiter for String values
            scanner.useDelimiter("","");
            return scanner;
        } else {
            return Collections.singletonList(value).iterator();
        }
    }
    /**
     * Returns the predicate matching boolean on a {@link List} result set where
     * if the first element is a boolean its value is used otherwise this method
     * returns true if the collection is not empty
     *
     * @return <tt>true</tt> if the first element is a boolean and its value is true or
     *          if the list is non empty
     */
    public static boolean matches(List list) {
        if (!list.isEmpty()) {
            Object value = list.get(0);
            if (value instanceof Boolean) {
                Boolean flag = (Boolean)value;
                return flag.booleanValue();
            } else {
                // lets assume non-empty results are true
                return true;
            }
        }
        return false;
    }
    /**
     * @deprecated will be removed in Camel 2.0 - use isNotEmpty() instead
     */
    public static boolean isNotNullAndNonEmpty(String text) {
        return isNotEmpty(text);
    }
    /**
     * @deprecated will be removed in Camel 2.0 - use isEmpty() instead
     */
    public static boolean isNullOrBlank(String text) {
        return isEmpty(text);
    }
    /**
     * Tests whether the value is <tt>null</tt> or an empty string.
     *
     * @param value  the value, if its a String it will be tested for text length as well
     * @return true if empty
     */
    public static boolean isEmpty(Object value) {
        return !isNotEmpty(value);
    }
    /**
     * Tests whether the value is <b>not</b> <tt>null</tt> or an empty string.
     *
     * @param value  the value, if its a String it will be tested for text length as well
     * @return true if <b>not</b> empty
     */
    public static boolean isNotEmpty(Object value) {
        if (value == null) {
            return false;
        } else if (value instanceof String) {
            String text = (String) value;
            return text.trim().length() > 0;
        } else {
            return true;
        }
    }
    /**
     * A helper method to access a system property, catching any security
     * exceptions
     *
     * @param name the name of the system property required
     * @param defaultValue the default value to use if the property is not
     *                available or a security exception prevents access
     * @return the system property value or the default value if the property is
     *         not available or security does not allow its access
     */
    public static String getSystemProperty(String name, String defaultValue) {
        try {
            return System.getProperty(name, defaultValue);
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Caught security exception accessing system property: "" + name + "". Reason: "" + e,
                          e);
            }
            return defaultValue;
        }
    }
    /**
     * A helper method to access a boolean system property, catching any security
     * exceptions
     *
     * @param name the name of the system property required
     * @param defaultValue the default value to use if the property is not
     *                available or a security exception prevents access
     * @return the boolean representation of the system property value 
     *         or the default value if the property is not available or 
     *         security does not allow its access
     */
    public static boolean getSystemProperty(String name, Boolean defaultValue) {
        String result = getSystemProperty(name, defaultValue.toString());
        return Boolean.parseBoolean(result);
    }    
    /**
     * Returns the type name of the given type or null if the type variable is
     * null
     */
    public static String name(Class type) {
        return type != null ? type.getName() : null;
    }
    /**
     * Returns the type name of the given value
     */
    public static String className(Object value) {
        return name(value != null ? value.getClass() : null);
    }
    /**
     * Returns the canonical type name of the given value
     */
    public static String classCanonicalName(Object value) {
        if (value != null) {
            return value.getClass().getCanonicalName();
        } else {
            return null;
        }
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the class loader used to load this class
     *
     * @param name the name of the class to load
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name) {
        return loadClass(name, ObjectHelper.class.getClassLoader());
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the given class loader
     *
     * @param name the name of the class to load
     * @param loader the class loader to use after the thread context class
     *                loader
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name, ClassLoader loader) {
        // try context class loader first
        Class clazz = doLoadClass(name, Thread.currentThread().getContextClassLoader());
        if (clazz == null) {
            // then the provided loader
            clazz = doLoadClass(name, loader);
        }
        if (clazz == null) {
            // and fallback to the loader the loaded the ObjectHelper class
            clazz = doLoadClass(name, ObjectHelper.class.getClassLoader());
        }
        if (clazz == null) {
            LOG.warn(""Could not find class: "" + name);
        }
        return clazz;
    }
    /**
     * Loads the given class with the provided classloader (may be null).
     * Will ignore any class not found and return null.
     *
     * @param name    the name of the class to load
     * @param loader  a provided loader (may be null)
     * @return the class, or null if it could not be loaded
     */
    private static Class<?> doLoadClass(String name, ClassLoader loader) {
        ObjectHelper.notEmpty(name, ""name"");
        if (loader == null) {
            return null;
        }
        try {
            return loader.loadClass(name);
        } catch (ClassNotFoundException e) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Can not load class: "" + name + "" using classloader: "" + loader, e);
            }
        }
        return null;
    }
    /**
     * Attempts to load the given resource as a stream using the thread context class
     * loader or the class loader used to load this class
     *
     * @param name the name of the resource to load
     * @return the stream or null if it could not be loaded
     */
    public static InputStream loadResourceAsStream(String name) {
        InputStream in = null;
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if (contextClassLoader != null) {
            in = contextClassLoader.getResourceAsStream(name);
        }
        if (in == null) {
            in = ObjectHelper.class.getClassLoader().getResourceAsStream(name);
        }
        return in;
    }
    /**
     * A helper method to invoke a method via reflection and wrap any exceptions
     * as {@link RuntimeCamelException} instances
     *
     * @param method the method to invoke
     * @param instance the object instance (or null for static methods)
     * @param parameters the parameters to the method
     * @return the result of the method invocation
     */
    public static Object invokeMethod(Method method, Object instance, Object... parameters) {
        try {
            return method.invoke(instance, parameters);
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeCamelException(e.getCause());
        }
    }
    /**
     * Returns a list of methods which are annotated with the given annotation
     *
     * @param type the type to reflect on
     * @param annotationType the annotation type
     * @return a list of the methods found
     */
    public static List<Method> findMethodsWithAnnotation(Class<?> type,
            Class<? extends Annotation> annotationType) {
        return findMethodsWithAnnotation(type, annotationType, false);
    }
    /**
     * Returns a list of methods which are annotated with the given annotation
     *
     * @param type the type to reflect on
     * @param annotationType the annotation type
     * @param checkMetaAnnotations check for meta annotations
     * @return a list of the methods found
     */
    public static List<Method> findMethodsWithAnnotation(Class<?> type,
            Class<? extends Annotation> annotationType, boolean checkMetaAnnotations) {
        List<Method> answer = new ArrayList<Method>();
        do {
            Method[] methods = type.getDeclaredMethods();
            for (Method method : methods) {
                if (hasAnnotation(method, annotationType, checkMetaAnnotations)) {
                    answer.add(method);
                }
            }
            type = type.getSuperclass();
        } while (type != null);
        return answer;
    }
    /**
     * Checks if a Class or Method are annotated with the given annotation
     *
     * @param elem the Class or Method to reflect on
     * @param annotationType the annotation type
     * @param checkMetaAnnotations check for meta annotations
     * @return true if annotations is present
     */
    public static boolean hasAnnotation(AnnotatedElement elem, 
            Class<? extends Annotation> annotationType, boolean checkMetaAnnotations) {
        if (elem.isAnnotationPresent(annotationType)) {
            return true;
        }
        if (checkMetaAnnotations) {
            for (Annotation a : elem.getAnnotations()) {
                for (Annotation meta : a.annotationType().getAnnotations()) {
                    if (meta.annotationType().getName().equals(annotationType.getName())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Turns the given object arrays into a meaningful string
     *
     * @param objects an array of objects or null
     * @return a meaningful string
     */
    public static String asString(Object[] objects) {
        if (objects == null) {
            return ""null"";
        } else {
            StringBuffer buffer = new StringBuffer(""{"");
            int counter = 0;
            for (Object object : objects) {
                if (counter++ > 0) {
                    buffer.append("", "");
                }
                String text = (object == null) ? ""null"" : object.toString();
                buffer.append(text);
            }
            buffer.append(""}"");
            return buffer.toString();
        }
    }
    /**
     * Returns true if a class is assignable from another class like the
     * {@link Class#isAssignableFrom(Class)} method but which also includes
     * coercion between primitive types to deal with Java 5 primitive type
     * wrapping
     */
    public static boolean isAssignableFrom(Class a, Class b) {
        a = convertPrimitiveTypeToWrapperType(a);
        b = convertPrimitiveTypeToWrapperType(b);
        return a.isAssignableFrom(b);
    }
    /**
     * Converts primitive types such as int to its wrapper type like
     * {@link Integer}
     */
    public static Class convertPrimitiveTypeToWrapperType(Class type) {
        Class rc = type;
        if (type.isPrimitive()) {
            if (type == int.class) {
                rc = Integer.class;
            } else if (type == long.class) {
                rc = Long.class;
            } else if (type == double.class) {
                rc = Double.class;
            } else if (type == float.class) {
                rc = Float.class;
            } else if (type == short.class) {
                rc = Short.class;
            } else if (type == byte.class) {
                rc = Byte.class;
            // TODO: Why is boolean disabled
/*
            } else if (type == boolean.class) {
                rc = Boolean.class;
*/
            }
        }
        return rc;
    }
    /**
     * Helper method to return the default character set name
     */
    public static String getDefaultCharacterSet() {
        return Charset.defaultCharset().name();
    }
    /**
     * Returns the Java Bean property name of the given method, if it is a setter
     */
    public static String getPropertyName(Method method) {
        String propertyName = method.getName();
        if (propertyName.startsWith(""set"") && method.getParameterTypes().length == 1) {
            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);
        }
        return propertyName;
    }
    /**
     * Returns true if the given collection of annotations matches the given type
     */
    public static boolean hasAnnotation(Annotation[] annotations, Class<?> type) {
        for (Annotation annotation : annotations) {
            if (type.isInstance(annotation)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Closes the given resource if it is available, logging any closing exceptions to the given log
     *
     * @param closeable the object to close
     * @param name the name of the resource
     * @param log the log to use when reporting closure warnings
     */
    public static void close(Closeable closeable, String name, Log log) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                if (log != null) {
                    log.warn(""Could not close: "" + name + "". Reason: "" + e, e);
                }
            }
        }
    }
    /**
     * Converts the given value to the required type or throw a meaningful exception
     */
    public static <T> T cast(Class<T> toType, Object value) {
        if (toType == boolean.class) {
            return (T)cast(Boolean.class, value);
        } else if (toType.isPrimitive()) {
            Class newType = convertPrimitiveTypeToWrapperType(toType);
            if (newType != toType) {
                return (T)cast(newType, value);
            }
        }
        try {
            return toType.cast(value);
        } catch (ClassCastException e) {
            throw new IllegalArgumentException(""Failed to convert: "" + value + "" to type: ""
                                               + toType.getName() + "" due to: "" + e, e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<T> type) {
        try {
            return type.newInstance();
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<?> actualType, Class<T> expectedType) {
        try {
            Object value = actualType.newInstance();
            return cast(expectedType, value);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException();
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Returns true if the given name is a valid java identifier
     */
    public static boolean isJavaIdentifier(String name) {
        if (name == null) {
            return false;
        }
        int size = name.length();
        if (size < 1) {
            return false;
        }
        if (Character.isJavaIdentifierStart(name.charAt(0))) {
            for (int i = 1; i < size; i++) {
                if (!Character.isJavaIdentifierPart(name.charAt(i))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Returns the type of the given object or null if the value is null
     */
    public static Object type(Object bean) {
        return bean != null ? bean.getClass() : null;
    }
    /**
     * Evaluate the value as a predicate which attempts to convert the value to
     * a boolean otherwise true is returned if the value is not null
     */
    public static boolean evaluateValuePredicate(Object value) {
        if (value instanceof Boolean) {
            Boolean aBoolean = (Boolean)value;
            return aBoolean.booleanValue();
        } else if (value instanceof String) {
            if (""true"".equals(value)) {
                return true;
            } else if (""false"".equals(value)) {
                return false;
            }
        }
        return value != null;
    }
    /**
     * Wraps the caused exception in a {@link RuntimeCamelException} if its not already such an exception.
     *
     * @param e  the caused exception
     * @return  the wrapper exception
     */
    public static RuntimeCamelException wrapRuntimeCamelException(Throwable e) {
        if (e instanceof RuntimeCamelException) {
            // don't double wrap if already a RuntimeCamelException
            return (RuntimeCamelException) e;
        } else {
            return new RuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.util.ObjectHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import junit.framework.TestCase;
/**
 * @version $Revision: 734353 $
 */
public class ObjectHelperTest extends TestCase {
    public void testRemoveInitialCharacters() throws Exception {
        assertEquals(ObjectHelper.removeStartingCharacters(""foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""/foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""//foo"", '/'), ""foo"");
    }
    public void testGetPropertyName() throws Exception {
        Method method = getClass().getMethod(""setCheese"", String.class);
        assertNotNull(""should have found a method!"", method);
        String name = ObjectHelper.getPropertyName(method);
        assertEquals(""Property name"", ""cheese"", name);
    }
    public void setCheese(String cheese) {
        // used in the above unit test
    }
    public void testContains() throws Exception {
        String[] array = {""foo"", ""bar""};
        Collection<String> collection = Arrays.asList(array);
        assertTrue(ObjectHelper.contains(array, ""foo""));
        assertTrue(ObjectHelper.contains(collection, ""foo""));
        assertTrue(ObjectHelper.contains(""foo"", ""foo""));
        assertFalse(ObjectHelper.contains(array, ""xyz""));
        assertFalse(ObjectHelper.contains(collection, ""xyz""));
        assertFalse(ObjectHelper.contains(""foo"", ""xyz""));
    }
    public void testEqual() {
        assertTrue(ObjectHelper.equal(null, null));
        assertTrue(ObjectHelper.equal("""", """"));
        assertTrue(ObjectHelper.equal("" "", "" ""));
        assertTrue(ObjectHelper.equal(""Hello"", ""Hello""));
        assertTrue(ObjectHelper.equal(123, 123));
        assertTrue(ObjectHelper.equal(true, true));
        assertFalse(ObjectHelper.equal(null, """"));
        assertFalse(ObjectHelper.equal("""", null));
        assertFalse(ObjectHelper.equal("" "", ""    ""));
        assertFalse(ObjectHelper.equal(""Hello"", ""World""));
        assertFalse(ObjectHelper.equal(true, false));
        assertFalse(ObjectHelper.equal(new Object(), new Object()));
        byte[] a = new byte[] {40, 50, 60};
        byte[] b = new byte[] {40, 50, 60};
        assertTrue(ObjectHelper.equal(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[] {40, 50, 60, 70};
        assertFalse(ObjectHelper.equal(a, b));
    }
    public void testEqualByteArray() {
        assertTrue(ObjectHelper.equalByteArray(""Hello"".getBytes(), ""Hello"".getBytes()));
        assertFalse(ObjectHelper.equalByteArray(""Hello"".getBytes(), ""World"".getBytes()));
        assertTrue(ObjectHelper.equalByteArray(""Hello Thai Elephant \u0E08"".getBytes(), ""Hello Thai Elephant \u0E08"".getBytes()));
        assertTrue(ObjectHelper.equalByteArray(null, null));
        byte[] empty = new byte[0];
        assertTrue(ObjectHelper.equalByteArray(empty, empty));
        byte[] a = new byte[] {40, 50, 60};
        byte[] b = new byte[] {40, 50, 60};
        assertTrue(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[] {40, 50, 60, 70};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60, 70};
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[0];
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[0];
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = null;
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = null;
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = null;
        b = null;
        assertTrue(ObjectHelper.equalByteArray(a, b));
    }
    public void testCreateIterator() {
        List<String> list = new ArrayList<String>();
        Iterator<String> iterator = list.iterator();
        assertSame(""Should return the same iterator"", iterator, ObjectHelper.createIterator(iterator));
    }
    public void testCreateIteratorWithStringAndCommaSeparator() {
        String s = ""a,b,c"";
        Iterator it = ObjectHelper.createIterator(s);
        assertEquals(""a"", it.next());
        assertEquals(""b"", it.next());
        assertEquals(""c"", it.next());
    }
}
"
org.apache.camel.util.PackageHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some helper methods for working with Java packages and versioning.
 *
 * @version $Revision: 664624 $
 */
public final class PackageHelper {
    private static final transient Log LOG = LogFactory.getLog(PackageHelper.class);
    private PackageHelper() {
        // Utility Class
    }
    /**
     * Returns true if the version number of the given package name can be found and is greater than or equal to the minimum version.
     *
     * For package names which include multiple dots, the dots are removed. So for example a spring version of 2.5.1 is converted to
     * 2.51 so you can assert that its >= 2.51 (so above 2.50 and less than 2.52 etc).
     *
     * @param packageName the Java package name to compare
     * @param minimumVersion the minimum version number
     * @return true if the package name can be determined and if its greater than or equal to the minimum value
     */
    public static boolean isValidVersion(String packageName, double minimumVersion) {
        try {
            Package spring = Package.getPackage(packageName);
            String value = spring.getImplementationVersion();
            if (value != null) {
                // lets remove any extra dots in the string...
                int idx = value.indexOf('.');
                if (idx >= 0) {
                    StringBuffer buffer = new StringBuffer(value.substring(0, ++idx));
                    int i = idx;
                    for (int size = value.length(); i < size; i++) {
                        char ch = value.charAt(i);
                        if (Character.isDigit(ch)) {
                            buffer.append(ch);
                        }
                    }
                    value = buffer.toString();
                }
                double number = Double.parseDouble(value);
                return number >= minimumVersion;
            }
        } catch (Exception e) {
            LOG.debug(""Failed to find out "" + packageName + "" version: "" + e, e);
        }
        return true;
    }
}
"
org.apache.camel.util.ReflectionInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.spi.Injector;
/**
 * A simple implementation of {@link Injector} which just uses reflection to
 * instantiate new objects using their zero argument constructor. For more
 * complex implementations try the Spring or Guice implementations.
 * 
 * @version $Revision: 659638 $
 */
public class ReflectionInjector implements Injector {
    public <T> T newInstance(Class<T> type) {
        return ObjectHelper.newInstance(type);
    }
}
"
org.apache.camel.util.ResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * <p>
 * ResolverUtil is used to locate classes that are available in the/a class path
 * and meet arbitrary conditions. The two most common conditions are that a
 * class implements/extends another class, or that is it annotated with a
 * specific annotation. However, through the use of the {@link Test} class it is
 * possible to search using arbitrary conditions.
 * </p>
 * <p/>
 * <p>
 * A ClassLoader is used to locate all locations (directories and jar files) in
 * the class path that contain classes within certain packages, and then to load
 * those classes and check them. By default the ClassLoader returned by
 * {@code Thread.currentThread().getContextClassLoader()} is used, but this can
 * be overridden by calling {@link #setClassLoaders(Set)} prior to
 * invoking any of the {@code find()} methods.
 * </p>
 * <p/>
 * <p>
 * General searches are initiated by calling the
 * {@link #find(ResolverUtil.Test, String)} ()} method and supplying a package
 * name and a Test instance. This will cause the named package <b>and all
 * sub-packages</b> to be scanned for classes that meet the test. There are
 * also utility methods for the common use cases of scanning multiple packages
 * for extensions of particular classes, or classes annotated with a specific
 * annotation.
 * </p>
 * <p/>
 * <p>
 * The standard usage pattern for the ResolverUtil class is as follows:
 * </p>
 * <p/>
 * <pre>
 * resolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();
 * resolver.findImplementation(ActionBean.class, pkg1, pkg2);
 * resolver.find(new CustomTest(), pkg1);
 * resolver.find(new CustomTest(), pkg2);
 * collection&lt;ActionBean&gt; beans = resolver.getClasses();
 * </pre>
 *
 * @author Tim Fennell
 */
public class ResolverUtil<T> {
    protected static final transient Log LOG = LogFactory.getLog(ResolverUtil.class);
    /**
     * A simple interface that specifies how to test classes to determine if
     * they are to be included in the results produced by the ResolverUtil.
     */
    public static interface Test {
        /**
         * Will be called repeatedly with candidate classes. Must return True if
         * a class is to be included in the results, false otherwise.
         */
        boolean matches(Class type);
    }
    /**
     * A Test that checks to see if each class is assignable to the provided
     * class. Note that this test will match the parent type itself if it is
     * presented for matching.
     */
    public static class IsA implements Test {
        private Class parent;
        /**
         * Constructs an IsA test using the supplied Class as the parent
         * class/interface.
         */
        public IsA(Class parentType) {
            this.parent = parentType;
        }
        /**
         * Returns true if type is assignable to the parent type supplied in the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && parent.isAssignableFrom(type);
        }
        @Override
        public String toString() {
            return ""is assignable to "" + parent.getSimpleName();
        }
    }
    /**
     * A Test that checks to see if each class is annotated with a specific
     * annotation. If it is, then the test returns true, otherwise false.
     */
    public static class AnnotatedWith implements Test {
        private Class<? extends Annotation> annotation;
        private boolean checkMetaAnnotations;
        /**
         * Constructs an AnnotatedWith test for the specified annotation type.
         */
        public AnnotatedWith(Class<? extends Annotation> annotation) {
            this(annotation, false);
        }
        /**
         * Constructs an AnnotatedWith test for the specified annotation type.
         */
        public AnnotatedWith(Class<? extends Annotation> annotation, boolean checkMetaAnnotations) {
            this.annotation = annotation;
            this.checkMetaAnnotations = checkMetaAnnotations;
        }
        /**
         * Returns true if the type is annotated with the class provided to the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && ObjectHelper.hasAnnotation(type, annotation, checkMetaAnnotations);
        }
        @Override
        public String toString() {
            return ""annotated with @"" + annotation.getSimpleName();
        }
    }
    /**
     * The set of matches being accumulated.
     */
    private Set<Class<? extends T>> matches = new HashSet<Class<? extends T>>();
    /**
     * The ClassLoader to use when looking for classes. If null then the
     * ClassLoader returned by Thread.currentThread().getContextClassLoader()
     * will be used.
     */
    private Set<ClassLoader> classLoaders;
    /**
     * Provides access to the classes discovered so far. If no calls have been
     * made to any of the {@code find()} methods, this set will be empty.
     *
     * @return the set of classes that have been discovered.
     */
    public Set<Class<? extends T>> getClasses() {
        return matches;
    }
    /**
     * Returns the classloaders that will be used for scanning for classes. If no
     * explicit ClassLoader has been set by the calling, the context class
     * loader will and the one that has loaded this class ResolverUtil be used.
     *
     * @return the ClassLoader instances that will be used to scan for classes
     */
    public Set<ClassLoader> getClassLoaders() {
        if (classLoaders == null) {
            classLoaders = new HashSet<ClassLoader>();
            ClassLoader ccl = Thread.currentThread().getContextClassLoader();
            if (ccl != null) {
                classLoaders.add(ccl);
            }
            classLoaders.add(ResolverUtil.class.getClassLoader());
        }
        return classLoaders;
    }
    /**
     * Sets the ClassLoader instances that should be used when scanning for
     * classes. If none is set then the context classloader will be used.
     *
     * @param classLoaders a ClassLoader to use when scanning for classes
     */
    public void setClassLoaders(Set<ClassLoader> classLoaders) {
        this.classLoaders = classLoaders;
    }
    /**
     * Attempts to discover classes that are assignable to the type provided. In
     * the case that an interface is provided this method will collect
     * implementations. In the case of a non-interface class, subclasses will be
     * collected. Accumulated classes can be accessed by calling
     * {@link #getClasses()}.
     *
     * @param parent       the class of interface to find subclasses or
     *                     implementations of
     * @param packageNames one or more package names to scan (including
     *                     subpackages) for classes
     */
    public void findImplementations(Class parent, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Searching for implementations of "" + parent.getName() + "" in packages: "" + Arrays
                .asList(packageNames));
        }
        Test test = new IsA(parent);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found: "" + getClasses());
        }
    }
    /**
     * Attempts to discover classes that are annotated with to the annotation.
     * Accumulated classes can be accessed by calling {@link #getClasses()}.
     *
     * @param annotation   the annotation that should be present on matching
     *                     classes
     * @param packageNames one or more package names to scan (including
     *                     subpackages) for classes
     */
    public void findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Searching for annotations of "" + annotation.getName() + "" in packages: "" + Arrays
                .asList(packageNames));
        }
        Test test = new AnnotatedWith(annotation, true);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found: "" + getClasses());
        }
    }
    /**
     * Scans for classes starting at the package provided and descending into
     * subpackages. Each class is offered up to the Test as it is discovered,
     * and if the Test returns true the class is retained. Accumulated classes
     * can be fetched by calling {@link #getClasses()}.
     *
     * @param test        an instance of {@link Test} that will be used to filter
     *                    classes
     * @param packageName the name of the package from which to start scanning
     *                    for classes, e.g. {@code net.sourceforge.stripes}
     */
    public void find(Test test, String packageName) {
        packageName = packageName.replace('.', '/');
        Set<ClassLoader> set = getClassLoaders();
        LOG.debug(""Using only regular classloaders"");
        for (ClassLoader classLoader : set) {            
            find(test, packageName, classLoader);            
        }
    }
    /**
     * Tries to find the reosurce in the package using the class loader.
     * <p/>
     * Will handle both plain URL based classloaders and OSGi bundle loaders.
     *
     * @param test what to find
     * @param packageName the package to search in
     * @param loader the class loader     
     */
    protected void find(Test test, String packageName, ClassLoader loader) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Searching for: "" + test + "" in package: "" + packageName + "" using classloader: ""
                    + loader.getClass().getName());
        }        
        Enumeration<URL> urls;
        try {
            urls = getResources(loader, packageName);
            if (!urls.hasMoreElements()) {
                LOG.trace(""No URLs returned by classloader"");
            }
        } catch (IOException ioe) {
            LOG.warn(""Could not read package: "" + packageName, ioe);
            return;
        }
        while (urls.hasMoreElements()) {
            URL url = null;
            try {
                url = urls.nextElement();
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""URL from classloader: "" + url);
                }
                String urlPath = url.getFile();
                urlPath = URLDecoder.decode(urlPath, ""UTF-8"");
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Decoded urlPath: "" + urlPath);
                }
                // If it's a file in a directory, trim the stupid file: spec
                if (urlPath.startsWith(""file:"")) {
                    urlPath = urlPath.substring(5);
                }
                // osgi bundles should be skipped
                if (url.toString().startsWith(""bundle:"") || urlPath.startsWith(""bundle:"")) {
                    LOG.trace(""It's a virtual osgi bundle, skipping"");
                    continue;
                }
                // Else it's in a JAR, grab the path to the jar
                if (urlPath.indexOf('!') > 0) {
                    urlPath = urlPath.substring(0, urlPath.indexOf('!'));
                }
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
                }
                File file = new File(urlPath);
                if (file.isDirectory()) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Loading from directory: "" + file);
                    }
                    loadImplementationsInDirectory(test, packageName, file);
                } else {
                    InputStream stream;
                    if (urlPath.startsWith(""http:"")) {
                        // load resources using http such as java webstart
                        LOG.debug(""The current jar is accessed via http"");
                        URL urlStream = new URL(urlPath);
                        URLConnection con = urlStream.openConnection();
                        // disable cache mainly to avoid jar file locking on Windows
                        con.setUseCaches(false);
                        stream = con.getInputStream();
                    } else {
                        stream = new FileInputStream(file);
                    }
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Loading from jar: "" + file);
                    }
                    loadImplementationsInJar(test, packageName, stream, urlPath);
                }
            } catch (IOException ioe) {
                LOG.warn(""Could not read entries in url: "" + url, ioe);
            }
        }
    }
    /**
     * Strategy to get the resources by the given classloader.
     * <p/>
     * Notice that in WebSphere platforms there is a {@link org.apache.camel.util.WebSphereResolverUtil}
     * to take care of WebSphere's odditiy of resource loading.
     *
     * @param loader  the classloader
     * @param packageName   the packagename for the package to load
     * @return  URL's for the given package
     * @throws IOException is thrown by the classloader
     */
    protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Getting resource URL for package: "" + packageName + "" with classloader: "" + loader);
        }
        return loader.getResources(packageName);
    }
    /**
     * Finds matches in a physical directory on a filesystem. Examines all files
     * within a directory - if the File object is not a directory, and ends with
     * <i>.class</i> the file is loaded and tested to see if it is acceptable
     * according to the Test. Operates recursively to find classes within a
     * folder structure matching the package structure.
     *
     * @param test     a Test used to filter the classes that are discovered
     * @param parent   the package name up to this directory in the package
     *                 hierarchy. E.g. if /classes is in the classpath and we wish to
     *                 examine files in /classes/org/apache then the values of
     *                 <i>parent</i> would be <i>org/apache</i>
     * @param location a File object representing a directory
     */
    private void loadImplementationsInDirectory(Test test, String parent, File location) {
        File[] files = location.listFiles();
        StringBuilder builder = null;
        for (File file : files) {
            builder = new StringBuilder(100);
            String name = file.getName();
            if (name != null) {
                name = name.trim();
                builder.append(parent).append(""/"").append(name);
                String packageOrClass = parent == null ? name : builder.toString();
                if (file.isDirectory()) {
                    loadImplementationsInDirectory(test, packageOrClass, file);
                } else if (name.endsWith("".class"")) {
                    addIfMatching(test, packageOrClass);
                }
            }
        }
    }
    /**
     * Finds matching classes within a jar files that contains a folder
     * structure matching the package structure. If the File is not a JarFile or
     * does not exist a warning will be logged, but no error will be raised.
     *
     * @param test    a Test used to filter the classes that are discovered
     * @param parent  the parent package under which classes must be in order to
     *                be considered
     * @param jarfile the jar file to be examined for classes
     * @param stream  the inputstream of the jar file to be examined for classes
     * @param urlPath the url of the jar file to be examined for classes
     */
    private void loadImplementationsInJar(Test test, String parent, InputStream stream, String urlPath) {
        JarInputStream jarStream = null;
        try {
            jarStream = new JarInputStream(stream);
            JarEntry entry;
            while ((entry = jarStream.getNextJarEntry()) != null) {
                String name = entry.getName();
                if (name != null) {
                    name = name.trim();
                    if (!entry.isDirectory() && name.startsWith(parent) && name.endsWith("".class"")) {
                        addIfMatching(test, name);
                    }
                }
            }
        } catch (IOException ioe) {
            LOG.error(""Could not search jar file '"" + urlPath + ""' for classes matching criteria: "" + test
                + "" due to an IOException: "" + ioe.getMessage(), ioe);
        } finally {
            ObjectHelper.close(jarStream, urlPath, LOG);
        }
    }
    /**
     * Add the class designated by the fully qualified class name provided to
     * the set of resolved classes if and only if it is approved by the Test
     * supplied.
     *
     * @param test the test used to determine if the class matches
     * @param fqn  the fully qualified name of a class
     */
    protected void addIfMatching(Test test, String fqn) {
        try {
            String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            Set<ClassLoader> set = getClassLoaders();
            boolean found = false;
            for (ClassLoader classLoader : set) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Testing for class "" + externalName + "" matches criteria ["" + test + ""]"");
                }
                try {
                    Class type = classLoader.loadClass(externalName);
                    if (test.matches(type)) {
                        if (LOG.isTraceEnabled()) {
                            LOG.trace(""Found class: "" + type + "" in classloader: "" + classLoader);
                        }
                        matches.add((Class<T>)type);
                    }
                    found = true;
                    break;
                } catch (ClassNotFoundException e) {
                    LOG.debug(""Could not find class '"" + fqn + ""' in classloader: "" + classLoader
                        + "". Reason: "" + e, e);
                } catch (NoClassDefFoundError e) {
                    LOG.debug(""Could not find the class defintion '"" + fqn + ""' in classloader: "" + classLoader
                              + "". Reason: "" + e, e);
                }
            }
            if (!found) {
                LOG.warn(""Could not find class '"" + fqn + ""' in any classloaders: "" + set);
            }
        } catch (Throwable t) {
            LOG.warn(""Could not examine class '"" + fqn + ""' due to a "" + t.getClass().getName()
                + "" with message: "" + t.getMessage(), t);
        }
    }
}
"
org.apache.camel.util.ServiceHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Collection;
import org.apache.camel.Service;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A collection of helper methods for working with {@link Service} objects
 *
 * @version $Revision: 640438 $
 */
public final class ServiceHelper {
    private static final transient Log LOG = LogFactory.getLog(ServiceHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ServiceHelper() {
    }
    public static void startService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.start();
        } else if (value instanceof Collection) {
            startServices((Collection)value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Object... services) throws Exception {
        for (Object value : services) {
            startService(value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Collection services) throws Exception {
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                service.start();
            }
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Object... services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
    public static void stopService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.stop();
        } else if (value instanceof Collection) {
            stopServices((Collection)value);
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Collection services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
}
"
org.apache.camel.util.SystemHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A helper class for various {@link System} related methods
 *
 * @version $Revision: 673954 $
 */
public final class SystemHelper {
    private static final transient Log LOG = LogFactory.getLog(SystemHelper.class);
    private SystemHelper() {
        // Helper class
    }
    /**
     * Looks up the given system property name returning null if any exceptions occur
     */
    public static String getSystemProperty(String name) {
        try {
            return System.getProperty(name);
        } catch (Exception e) {
            LOG.debug(""Caught exception looking for system property: "" + name + "" exception: "" + e, e);
            return null;
        }
    }
    /**
     * Looks up the given system property boolean value. Returns false if the system property doesn't exist.
     */
    public static boolean isSystemProperty(String name) {
        String text = getSystemProperty(name);
        return ObjectConverter.toBool(text);
    }
}
"
org.apache.camel.util.Time,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Date;
import java.util.concurrent.TimeUnit;
/**
 * A helper class for working with times in various units
 * 
 * @version $Revision: 630591 $
 */
public class Time {
    private long number;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    public Time(long number, TimeUnit timeUnit) {
        this.number = number;
        this.timeUnit = timeUnit;
    }
    public static Time millis(long value) {
        return new Time(value, TimeUnit.MILLISECONDS);
    }
    public static Time micros(long value) {
        return new Time(value, TimeUnit.MICROSECONDS);
    }
    public static Time nanos(long value) {
        return new Time(value, TimeUnit.NANOSECONDS);
    }
    public static Time seconds(long value) {
        return new Time(value, TimeUnit.SECONDS);
    }
    public static Time minutes(long value) {
        return new Time(minutesAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time hours(long value) {
        return new Time(hoursAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time days(long value) {
        return new Time(daysAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public long toMillis() {
        return timeUnit.toMillis(number);
    }
    public Date toDate() {
        return new Date(toMillis());
    }
    public long getNumber() {
        return number;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    protected static long minutesAsSeconds(long value) {
        return value * 60;
    }
    protected static long hoursAsSeconds(long value) {
        return minutesAsSeconds(value) * 60;
    }
    protected static long daysAsSeconds(long value) {
        return hoursAsSeconds(value) * 24;
    }
}
"
org.apache.camel.util.TimeoutMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * Represents a thread safe map of values which timeout after a period of
 * inactivity.
 *
 * @version $Revision: 659798 $
 */
public interface TimeoutMap extends Runnable {
    /**
     * Looks up the value in the map by the given key.
     *
     * @param key the key of the value to search for
     * @return the value for the given key or null if it is not present (or has timed out)
     */
    Object get(Object key);
    /**
     * Returns a copy of the keys in the map
     */
    Object[] getKeys();
    /**
     * Returns the size of the map
     */
    int size();
    /**
     * Adds the key value pair into the map such that some time after the given
     * timeout the entry will be evicted
     */
    void put(Object key, Object value, long timeoutMillis);
    /**
     * Removes the object with the given key
     *
     * @param key  key for the object to remove
     */
    void remove(Object key);
    /**
     * Purges any old entries from the map
     */
    void purge();
}
"
org.apache.camel.util.TimeoutMapEntry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Map;
/**
 * Represents an entry in a {@link TimeoutMap}
 *
 * @version $Revision: 640438 $
 */
public class TimeoutMapEntry implements Comparable, Map.Entry {
    private Object key;
    private Object value;
    private long timeout;
    private long expireTime;
    public TimeoutMapEntry(Object id, Object handler, long timeout) {
        this.key = id;
        this.value = handler;
        this.timeout = timeout;
    }
    public Object getKey() {
        return key;
    }
    public long getExpireTime() {
        return expireTime;
    }
    public void setExpireTime(long expireTime) {
        this.expireTime = expireTime;
    }
    public Object getValue() {
        return value;
    }
    public Object setValue(Object value) {
        Object oldValue = value;
        this.value = value;
        return oldValue;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public int compareTo(Object that) {
        if (this == that) {
            return 0;
        }
        if (that instanceof TimeoutMapEntry) {
            return compareTo((TimeoutMapEntry) that);
        }
        return 1;
    }
    public int compareTo(TimeoutMapEntry that) {
        long diff = this.expireTime - that.expireTime;
        if (diff > 0) {
            return 1;
        } else if (diff < 0) {
            return -1;
        }
        return this.key.hashCode() - that.key.hashCode();
    }
    public String toString() {
        return ""Entry for key: "" + key;
    }
}
"
org.apache.camel.util.UnsafeCharactersEncoderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
public class UnsafeCharactersEncoderTest extends TestCase {
    public void testQnameEncoder() {
        String afterEncoding = ""%7Bhttp://www.example.com/test%7DServiceName"";
        String beforeEncoding = ""{http://www.example.com/test}ServiceName"";
        String result = UnsafeUriCharactersEncoder.encode(beforeEncoding);
        assertEquals(""Get the wrong encoding result"", result, afterEncoding);
    }
    public void testNoEncoding() {
        String noEncoding = ""http://www.example.com"";
        String result = UnsafeUriCharactersEncoder.encode(noEncoding);
        assertEquals(""Get the wrong encoding result"", result, noEncoding);
    }
}
"
org.apache.camel.util.UnsafeUriCharactersEncoder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.util.BitSet;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Encoder for unsafe URI characters.
 */
public final class UnsafeUriCharactersEncoder {
    private static BitSet unsafeCharacters;
    private static final transient Log LOG = LogFactory.getLog(UnsafeUriCharactersEncoder.class);
    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',
                                              'D', 'E', 'F'};
    static {
        unsafeCharacters = new BitSet(256);
        unsafeCharacters.set(' ');
        unsafeCharacters.set('""');
        unsafeCharacters.set('<');
        unsafeCharacters.set('>');
        unsafeCharacters.set('#');
        unsafeCharacters.set('%');
        unsafeCharacters.set('{');
        unsafeCharacters.set('}');
        unsafeCharacters.set('|');
        unsafeCharacters.set('\\');
        unsafeCharacters.set('^');
        unsafeCharacters.set('~');
        unsafeCharacters.set('[');
        unsafeCharacters.set(']');
        unsafeCharacters.set('`');
    }
    private UnsafeUriCharactersEncoder() {
        // util class
    }
    public static String encode(String s) {
        int n = s.length();
        if (n == 0) {
            return s;
        }
        try {
            // First check whether we actually need to encode
            byte[] bytes = s.getBytes(""UTF8"");
            for (int i = 0;;) {
                if (unsafeCharacters.get(bytes[i])) {
                    break;
                }
                if (++i >= bytes.length) {
                    return s;
                }
            }
            // okay there are some unsafe characters so we do need to encode
            StringBuffer sb = new StringBuffer();
            for (byte b : bytes) {
                if (unsafeCharacters.get(b)) {
                    appendEscape(sb, b);
                } else {
                    sb.append((char)b);
                }
            }
            return sb.toString();
        } catch (UnsupportedEncodingException e) {
            LOG.error(""Can't encoding the uri: "", e);
            return null;
        }
    }
    private static void appendEscape(StringBuffer sb, byte b) {
        sb.append('%');
        sb.append(HEX_DIGITS[(b >> 4) & 0x0f]);
        sb.append(HEX_DIGITS[(b >> 0) & 0x0f]);
    }
}
"
org.apache.camel.util.URISupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
/**
 * URI utilities.
 *
 * @version $Revision: 663882 $
 */
public class URISupport {
    /**
     * Holder to get parts of the URI.
     */
    public static class CompositeData {
        public String host;
        String scheme;
        String path;
        URI components[];
        Map parameters;
        String fragment;
        public URI[] getComponents() {
            return components;
        }
        public String getFragment() {
            return fragment;
        }
        public Map getParameters() {
            return parameters;
        }
        public String getScheme() {
            return scheme;
        }
        public String getPath() {
            return path;
        }
        public String getHost() {
            return host;
        }
        public URI toURI() throws URISyntaxException {
            StringBuffer sb = new StringBuffer();
            if (scheme != null) {
                sb.append(scheme);
                sb.append(':');
            }
            if (host != null && host.length() != 0) {
                sb.append(host);
            } else {
                sb.append('(');
                for (int i = 0; i < components.length; i++) {
                    if (i != 0) {
                        sb.append(',');
                    }
                    sb.append(components[i].toString());
                }
                sb.append(')');
            }
            if (path != null) {
                sb.append('/');
                sb.append(path);
            }
            if (!parameters.isEmpty()) {
                sb.append(""?"");
                sb.append(createQueryString(parameters));
            }
            if (fragment != null) {
                sb.append(""#"");
                sb.append(fragment);
            }
            return new URI(sb.toString());
        }
    }
    public static Map parseQuery(String uri) throws URISyntaxException {
        try {
            Map rc = new HashMap();
            if (uri != null) {
                String[] parameters = uri.split(""&"");
                for (String parameter : parameters) {
                    int p = parameter.indexOf(""="");
                    if (p >= 0) {
                        String name = URLDecoder.decode(parameter.substring(0, p), ""UTF-8"");
                        String value = URLDecoder.decode(parameter.substring(p + 1), ""UTF-8"");
                        rc.put(name, value);
                    } else {
                        rc.put(parameter, null);
                    }
                }
            }
            return rc;
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    public static Map parseParameters(URI uri) throws URISyntaxException {
        String query = uri.getQuery();
        if (query == null) {
            String schemeSpecificPart = uri.getSchemeSpecificPart();
            int idx = schemeSpecificPart.lastIndexOf('?');
            if (idx < 0) {
                return Collections.EMPTY_MAP;
            } else {
                query = schemeSpecificPart.substring(idx + 1);
            }
        } else {
            query = stripPrefix(query, ""?"");
        }
        return parseQuery(query);
    }
    /**
     * Removes any URI query from the given uri
     */
    public static URI removeQuery(URI uri) throws URISyntaxException {
        return createURIWithQuery(uri, null);
    }
    /**
     * Creates a URI with the given query
     */
    public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
        return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(),
                       query, uri.getFragment());
    }
    public static CompositeData parseComposite(URI uri) throws URISyntaxException {
        CompositeData rc = new CompositeData();
        rc.scheme = uri.getScheme();
        String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"").trim();
        parseComposite(uri, rc, ssp);
        rc.fragment = uri.getFragment();
        return rc;
    }
    private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
        String componentString;
        String params;
        if (!checkParenthesis(ssp)) {
            throw new URISyntaxException(uri.toString(), ""Not a matching number of '(' and ')' parenthesis"");
        }
        int p;
        int intialParen = ssp.indexOf(""("");
        if (intialParen == 0) {
            rc.host = ssp.substring(0, intialParen);
            p = rc.host.indexOf(""/"");
            if (p >= 0) {
                rc.path = rc.host.substring(p);
                rc.host = rc.host.substring(0, p);
            }
            p = ssp.lastIndexOf("")"");
            componentString = ssp.substring(intialParen + 1, p);
            params = ssp.substring(p + 1).trim();
        } else {
            componentString = ssp;
            params = """";
        }
        String components[] = splitComponents(componentString);
        rc.components = new URI[components.length];
        for (int i = 0; i < components.length; i++) {
            rc.components[i] = new URI(components[i].trim());
        }
        p = params.indexOf(""?"");
        if (p >= 0) {
            if (p > 0) {
                rc.path = stripPrefix(params.substring(0, p), ""/"");
            }
            rc.parameters = parseQuery(params.substring(p + 1));
        } else {
            if (params.length() > 0) {
                rc.path = stripPrefix(params, ""/"");
            }
            rc.parameters = Collections.EMPTY_MAP;
        }
    }
    private static String[] splitComponents(String str) {
        ArrayList l = new ArrayList();
        int last = 0;
        int depth = 0;
        char chars[] = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]) {
            case '(':
                depth++;
                break;
            case ')':
                depth--;
                break;
            case ',':
                if (depth == 0) {
                    String s = str.substring(last, i);
                    l.add(s);
                    last = i + 1;
                }
                break;
            default:
            }
        }
        String s = str.substring(last);
        if (s.length() != 0) {
            l.add(s);
        }
        String rc[] = new String[l.size()];
        l.toArray(rc);
        return rc;
    }
    public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }
    public static URI stripScheme(URI uri) throws URISyntaxException {
        return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), ""//""));
    }
    public static String createQueryString(Map options) throws URISyntaxException {
        try {
            if (options.size() > 0) {
                StringBuffer rc = new StringBuffer();
                boolean first = true;
                for (Iterator iter = options.keySet().iterator(); iter.hasNext();) {
                    if (first) {
                        first = false;
                    } else {
                        rc.append(""&"");
                    }
                    String key = (String)iter.next();
                    String value = (String)options.get(key);
                    rc.append(URLEncoder.encode(key, ""UTF-8""));
                    rc.append(""="");
                    rc.append(URLEncoder.encode(value, ""UTF-8""));
                }
                return rc.toString();
            } else {
                return """";
            }
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    /**
     * Creates a URI from the original URI and the remaining parameters
     */
    public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
        String s = createQueryString(params);
        if (s.length() == 0) {
            s = null;
        }
        return createURIWithQuery(originalURI, s);
    }
    public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
        return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr
            .getPath(), bindAddr.getQuery(), bindAddr.getFragment());
    }
    public static boolean checkParenthesis(String str) {
        boolean result = true;
        if (str != null) {
            int open = 0;
            int closed = 0;
            int i = 0;
            while ((i = str.indexOf('(', i)) >= 0) {
                i++;
                open++;
            }
            i = 0;
            while ((i = str.indexOf(')', i)) >= 0) {
                i++;
                closed++;
            }
            result = open == closed;
        }
        return result;
    }
    /**
     * @deprecated this method will be removed in Camel 2.0.
     */
    @Deprecated
    public int indexOfParenthesisMatch(String str) {
        int result = -1;
        return result;
    }
}
"
org.apache.camel.util.UuidGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.util.logging.Level;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Generator for Globally unique Strings.
 */
public class UuidGenerator {
    private static final transient Log LOG = LogFactory.getLog(UuidGenerator.class); 
    private static final String UNIQUE_STUB;
    private static int instanceCount;
    private static String hostName;
    private String seed;
    private long sequence;
    static {
        String stub = """";
        boolean canAccessSystemProps = true;
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        } catch (SecurityException se) {
            canAccessSystemProps = false;
        }
        if (canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
                ServerSocket ss = new ServerSocket(0);
                stub = ""/"" + ss.getLocalPort() + ""-"" + System.currentTimeMillis() + ""/"";
                Thread.sleep(100);
                ss.close();
            } catch (Exception ioe) {
                LOG.warn(""Could not generate unique stub"", ioe);
            }
        } else {
            hostName = ""localhost"";
            stub = ""-1-"" + System.currentTimeMillis() + ""-"";
        }
        UNIQUE_STUB = stub;
    }
    public UuidGenerator(String prefix) {
        synchronized (UNIQUE_STUB) {
            this.seed = prefix + UNIQUE_STUB + (instanceCount++) + ""-"";
        }
    }
    public UuidGenerator() {
        this(""ID-"" + hostName);
    }
    /**
     * As we have to find the hostname as a side-affect of generating a unique
     * stub, we allow it's easy retrevial here
     * 
     * @return the local host name
     */
    public static String getHostName() {
        return hostName;
    }
    /**
     * Generate a unqiue id
     */
    public synchronized String generateId() {
        return this.seed + (this.sequence++);
    }
    /**
     * Generate a unique ID - that is friendly for a URL or file system
     * 
     * @return a unique id
     */
    public String generateSanitizedId() {
        return generateSanitizedId(generateId());
    }
    /**
     * Ensures that the id is friendly for a URL or file system
     *
     * @param id the unique id
     * @return the id as file friendly id
     */
    public static String generateSanitizedId(String id) {
        id = id.replace(':', '-');
        id = id.replace('_', '-');
        id = id.replace('.', '-');
        return id;
    }
}
"
org.apache.camel.util.UuidGeneratorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
/**
 * Unit test for UuidGenerator
 */
public class UuidGeneratorTest extends TestCase {
    private UuidGenerator generator;
    protected void setUp() throws Exception {
        generator = new UuidGenerator(""unittest"");
    }
    public void testUniqueId() {
        assertNotSame(""Should generate unique ids"", generator.generateId(), generator.generateId());
    }
    public void testSimpleSanitizedId() {
        String out = UuidGenerator.generateSanitizedId(""hello"");
        assertTrue(""Should not contain : "", out.indexOf(':') == -1);
        assertTrue(""Should not contain . "", out.indexOf('.') == -1);
    }
    public void testNotFileFriendlySimpleSanitizedId() {
        String out = UuidGenerator.generateSanitizedId(""c:\\helloworld"");
        assertTrue(""Should not contain : "", out.indexOf(':') == -1);
        assertTrue(""Should not contain . "", out.indexOf('.') == -1);
    }
}
"
org.apache.camel.util.ValueHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * Holder object for a given value.
 */
public class ValueHolder<V> {
    private V value;
    public ValueHolder() {
    }
    public ValueHolder(V val) {
        value = val;
    }
    public V get() {
        return value;
    }
    public void set(V val) {
        value = val;
    }
}
"
org.apache.camel.util.WebSphereResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;
/**
 * WebSphere specific resolver util to handle loading annotated resources in JAR files.
 */
public class WebSphereResolverUtil extends ResolverUtil {
    private String resourcePath;
    /**
     * Constructor.
     *
     * @param resourcePath  the fixed resource path to use for fetching camel jars in WebSphere.
     */
    public WebSphereResolverUtil(String resourcePath) {
        this.resourcePath = resourcePath;
    }
    /**
     * Is the classloader from IBM and thus the WebSphere platform?
     *
     * @param loader  the classloader
     * @return  <tt>true</tt> if IBM classloader, <tt>false</tt> otherwise.
     */
    public static boolean isWebSphereClassLoader(ClassLoader loader) {
        return loader.getClass().getName().startsWith(""com.ibm"");
    }
    /**
     * Overloaded to handle specific problem with getting resources on the IBM WebSphere platform.
     * <p/>
     * WebSphere can <b>not</b> load resources if the resource to load is a folder name, such as a
     * packagename, you have to explicit name a resource that is a file.
     *
     * @param loader  the classloader
     * @param packageName   the packagename for the package to load
     * @return  URL's for the given package
     * @throws IOException is thrown by the classloader
     */
    @Override
    protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {
        // try super first, just in vase
        Enumeration<URL> enumeration = super.getResources(loader, packageName);
        if (!enumeration.hasMoreElements()) {
            LOG.trace(""Using WebSphere workaround to load the camel jars with the annotated converters."");
            // Special WebSphere trick to load a file that exists in the JAR and then let it go from there.
            // The trick is that we just need the URL's for the .jars that contains the type
            // converters that is annotated. So by searching for this resource WebSphere is able to find
            // it and return the URL to the .jar file with the resource. Then the default ResolverUtil
            // can take it from there and find the classes that are annotated.
            enumeration = loader.getResources(resourcePath);
        }
        return enumeration;
    }
}
"
org.apache.camel.util.concurrent.AtomicExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.concurrent;
import java.util.concurrent.atomic.AtomicReference;
import org.apache.camel.Exchange;
/**
 * Convenience class for holding an {@link Exchange} in a thread-safe way
 */
@SuppressWarnings(""serial"")
public class AtomicExchange extends AtomicReference<Exchange> {
}
"
org.apache.camel.util.concurrent.CountingLatch,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.concurrent;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
/**
 * An alternative to a {@link CountDownLatch} -- this implementation also supports incrementing
 * the latch count while counting down.  It can also be used to count up to 0 from a negative integer.
 */
public class CountingLatch {
    @SuppressWarnings(""serial"")
    private final class Sync extends AbstractQueuedSynchronizer {
        private Sync() {
            super();
        }
        int getCount() {
            return getState();
        }
        public int tryAcquireShared(int acquires) {
            return getState() == 0 ? 1 : -1;
        }
        public boolean tryReleaseShared(int delta) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                int nextc = c + delta;
                if (compareAndSetState(c, nextc)) {
                    return nextc == 0;
                }
            }
        }
    }
    private final Sync sync;
    /**
     * Create a new counting latch (starting count is 0)
     */
    public CountingLatch() {
        super();
        this.sync = new Sync();
    }
    /**
     * Get the current count
     */
    public int getCount() {
        return sync.getCount();
    }
    /**
     * Increment the count with 1
     */
    public void increment() {
        sync.releaseShared(+1);
    }
    /**
     * Decrement the count with 1
     */
    public void decrement() {
        sync.releaseShared(-1);
    }
    /**
     * Await the latch reaching the count of 0
     *
     * @throws InterruptedException if the threads gets interrupted while waiting
     */
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    /**
     * Wait for a given timeout while checking if the latch reached the count of 0
     *
     * @param timeout the value of the timeout
     * @param unit the unit in which the timeout is expressed
     * @return <code>true</code> if the latch has reached the count of 0 in the given time
     * @throws InterruptedException if the thread gets interrupted while waiting
     */
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
}
"
org.apache.camel.util.concurrent.CountingLatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.concurrent;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import junit.framework.TestCase;
/**
 * Test case for {@link CountingLatch}
 */
public class CountingLatchTest extends TestCase {
    private static final int COUNT = 4;
    private CountingLatch latch;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        latch = new CountingLatch();
    }
    /**
     * Test for counting down with the latch (similar to {@link CountDownLatch}
     */
    public void testCountDown() throws Exception {
        for (int i = 0; i < COUNT; i++) {
            latch.increment();
        }
        Thread thread = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < COUNT; i++) {
                    sleep();
                    latch.decrement();
                }
            }
        });
        thread.start();
        assertFalse(""We can't be done in 100 ms"", latch.await(100, TimeUnit.MILLISECONDS));
        // but we can block until we are done
        assertLatchDone();
    }
    /**
     * Test for counting up with the latch
     */
    public void testCountUp() throws Exception {
        for (int i = 0; i < COUNT; i++) {
            latch.decrement();
        }
        Thread thread = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < COUNT; i++) {
                    sleep();
                    latch.increment();
                }
            }
        });
        thread.start();
        assertFalse(""We can't be done in 100 ms"", latch.await(100, TimeUnit.MILLISECONDS));
        // but we can block until we are done
        assertLatchDone();
    }
    /**
     * Test for two threads that are simultaneously incrementing and decrementing the latch
     */
    public void testCountDownAndUp() throws Exception {
        Thread up = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < COUNT; i++) {
                    latch.increment();
                }
            }
        });
        Thread down = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < COUNT; i++) {
                    latch.increment();
                    latch.decrement();
                    sleep();
                    latch.decrement();
                }
            }
        });
        up.start();
        down.start();        
        assertLatchDone();
    }
    /**
     * Await the latch and assert the count is 0 when it does return
     * @throws InterruptedException
     */
    private void assertLatchDone() throws InterruptedException {
        latch.await();
        assertEquals(""The latch has been released, so the count should be 0 now"", 0, latch.getCount());
    }
    /**
     * Helper method do a little nap
     */
    private void sleep() {
        try {
            Thread.sleep(75);
        } catch (InterruptedException e) {
            fail(""Thread shouldn't get interrupted -- "" + e.getMessage());
        }
    }
}
"
org.apache.camel.util.jndi.CamelInitialContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.spi.InitialContextFactory;
/**
 * A factory of the Camel InitialContext which allows a Map to be used to create a
 * JNDI context.
 *
 * @version $Revision: 656978 $
 */
public class CamelInitialContextFactory implements InitialContextFactory {
    /**
     * Creates a new context with the given environment.
     *
     * @param  environment  the environment, must not be <tt>null</tt>
     * @return the created context.
     * @throws NamingException is thrown if creation failed.
     */
    public Context getInitialContext(Hashtable environment) throws NamingException {
        try {
            return new JndiContext(environment);
        } catch (NamingException e) {
            throw e;
        } catch (Exception e) {
            NamingException exception = new NamingException(e.getMessage());
            exception.initCause(e);
            throw exception;
        }
    }
}
"
org.apache.camel.util.jndi.ExampleBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
/**
 * @version $Revision: 630568 $
 */
public class ExampleBean {
    private String name;
    private double price;
    public String toString() {
        return ""ExampleBean[name: "" + name + "" price: "" + price + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }
}
"
org.apache.camel.util.jndi.JndiContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import javax.naming.Binding;
import javax.naming.CompositeName;
import javax.naming.Context;
import javax.naming.LinkRef;
import javax.naming.Name;
import javax.naming.NameClassPair;
import javax.naming.NameNotFoundException;
import javax.naming.NameParser;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.NotContextException;
import javax.naming.OperationNotSupportedException;
import javax.naming.Reference;
import javax.naming.spi.NamingManager;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ReflectionInjector;
/**
 * A default JNDI context
 *
 * @version $Revision: 659638 $ $Date: 2008-05-23 15:37:19 -0400 (Fri, 23 May 2008) $
 */
public class JndiContext implements Context, Serializable {
    public static final String SEPARATOR = ""/"";
    protected static final NameParser NAME_PARSER = new NameParser() {
        public Name parse(String name) throws NamingException {
            return new CompositeName(name);
        }
    };
    protected static final Injector INJETOR = new ReflectionInjector();
    private static final long serialVersionUID = -5754338187296859149L;
    private final Hashtable environment; // environment for this context
    private final Map bindings; // bindings at my level
    private final Map treeBindings; // all bindings under me
    private boolean frozen;
    private String nameInNamespace = """";
    public JndiContext() throws Exception {
        this(new Hashtable());
    }
    public JndiContext(Hashtable env) throws Exception {
        this(env, createBindingsMapFromEnvironment(env));
    }
    public JndiContext(Hashtable environment, Map bindings) {
        if (environment == null) {
            this.environment = new Hashtable();
        } else {
            this.environment = new Hashtable(environment);
        }
        this.bindings = bindings;
        treeBindings = new HashMap();
    }
    public JndiContext(Hashtable environment, Map bindings, String nameInNamespace) {
        this(environment, bindings);
        this.nameInNamespace = nameInNamespace;
    }
    protected JndiContext(JndiContext clone, Hashtable env) {
        this.bindings = clone.bindings;
        this.treeBindings = clone.treeBindings;
        this.environment = new Hashtable(env);
    }
    protected JndiContext(JndiContext clone, Hashtable env, String nameInNamespace) {
        this(clone, env);
        this.nameInNamespace = nameInNamespace;
    }
    /**
     * A helper method to create the JNDI bindings from the input environment
     * properties using $foo.class to point to a class name with $foo.* being
     * properties set on the injected bean
     */
    public static Map createBindingsMapFromEnvironment(Hashtable env) throws Exception {
        Map answer = new HashMap(env);
        for (Object object : env.entrySet()) {
            Map.Entry entry = (Map.Entry)object;
            Object key = entry.getKey();
            Object value = entry.getValue();
            if (key instanceof String && value instanceof String) {
                String keyText = (String)key;
                String valueText = (String)value;
                if (keyText.endsWith("".class"")) {
                    Class<?> type = ObjectHelper.loadClass(valueText);
                    if (type != null) {
                        String newEntry = keyText.substring(0, keyText.length() - "".class"".length());
                        Object bean = createBean(type, answer, newEntry + ""."");
                        if (bean != null) {
                            answer.put(newEntry, bean);
                        }
                    }
                }
            }
        }
        return answer;
    }
    public void freeze() {
        frozen = true;
    }
    boolean isFrozen() {
        return frozen;
    }
    /**
     * internalBind is intended for use only during setup or possibly by
     * suitably synchronized superclasses. It binds every possible lookup into a
     * map in each context. To do this, each context strips off one name segment
     * and if necessary creates a new context for it. Then it asks that context
     * to bind the remaining name. It returns a map containing all the bindings
     * from the next context, plus the context it just created (if it in fact
     * created it). (the names are suitably extended by the segment originally
     * lopped off).
     */
    protected Map internalBind(String name, Object value) throws NamingException {
        assert name != null && name.length() > 0;
        assert !frozen;
        Map newBindings = new HashMap();
        int pos = name.indexOf('/');
        if (pos == -1) {
            if (treeBindings.put(name, value) != null) {
                throw new NamingException(""Something already bound at "" + name);
            }
            bindings.put(name, value);
            newBindings.put(name, value);
        } else {
            String segment = name.substring(0, pos);
            assert segment != null;
            assert !segment.equals("""");
            Object o = treeBindings.get(segment);
            if (o == null) {
                o = newContext();
                treeBindings.put(segment, o);
                bindings.put(segment, o);
                newBindings.put(segment, o);
            } else if (!(o instanceof JndiContext)) {
                throw new NamingException(""Something already bound where a subcontext should go"");
            }
            JndiContext defaultContext = (JndiContext)o;
            String remainder = name.substring(pos + 1);
            Map subBindings = defaultContext.internalBind(remainder, value);
            for (Iterator iterator = subBindings.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry entry = (Map.Entry)iterator.next();
                String subName = segment + ""/"" + (String)entry.getKey();
                Object bound = entry.getValue();
                treeBindings.put(subName, bound);
                newBindings.put(subName, bound);
            }
        }
        return newBindings;
    }
    protected JndiContext newContext() {
        try {
            return new JndiContext();
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public Object addToEnvironment(String propName, Object propVal) throws NamingException {
        return environment.put(propName, propVal);
    }
    public Hashtable getEnvironment() throws NamingException {
        return (Hashtable)environment.clone();
    }
    public Object removeFromEnvironment(String propName) throws NamingException {
        return environment.remove(propName);
    }
    public Object lookup(String name) throws NamingException {
        if (name.length() == 0) {
            return this;
        }
        Object result = treeBindings.get(name);
        if (result == null) {
            result = bindings.get(name);
        }
        if (result == null) {
            int pos = name.indexOf(':');
            if (pos > 0) {
                String scheme = name.substring(0, pos);
                Context ctx = NamingManager.getURLContext(scheme, environment);
                if (ctx == null) {
                    throw new NamingException(""scheme "" + scheme + "" not recognized"");
                }
                return ctx.lookup(name);
            } else {
                // Split out the first name of the path
                // and look for it in the bindings map.
                CompositeName path = new CompositeName(name);
                if (path.size() == 0) {
                    return this;
                } else {
                    String first = path.get(0);
                    Object value = bindings.get(first);
                    if (value == null) {
                        throw new NameNotFoundException(name);
                    } else if (value instanceof Context && path.size() > 1) {
                        Context subContext = (Context)value;
                        value = subContext.lookup(path.getSuffix(1));
                    }
                    return value;
                }
            }
        }
        if (result instanceof LinkRef) {
            LinkRef ref = (LinkRef)result;
            result = lookup(ref.getLinkName());
        }
        if (result instanceof Reference) {
            try {
                result = NamingManager.getObjectInstance(result, null, null, this.environment);
            } catch (NamingException e) {
                throw e;
            } catch (Exception e) {
                throw (NamingException)new NamingException(""could not look up : "" + name).initCause(e);
            }
        }
        if (result instanceof JndiContext) {
            String prefix = getNameInNamespace();
            if (prefix.length() > 0) {
                prefix = prefix + SEPARATOR;
            }
            result = new JndiContext((JndiContext)result, environment, prefix + name);
        }
        return result;
    }
    public Object lookup(Name name) throws NamingException {
        return lookup(name.toString());
    }
    public Object lookupLink(String name) throws NamingException {
        return lookup(name);
    }
    public Name composeName(Name name, Name prefix) throws NamingException {
        Name result = (Name)prefix.clone();
        result.addAll(name);
        return result;
    }
    public String composeName(String name, String prefix) throws NamingException {
        CompositeName result = new CompositeName(prefix);
        result.addAll(new CompositeName(name));
        return result.toString();
    }
    public NamingEnumeration list(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).list("""");
        } else {
            throw new NotContextException();
        }
    }
    public NamingEnumeration listBindings(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListBindingEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).listBindings("""");
        } else {
            throw new NotContextException();
        }
    }
    public Object lookupLink(Name name) throws NamingException {
        return lookupLink(name.toString());
    }
    public NamingEnumeration list(Name name) throws NamingException {
        return list(name.toString());
    }
    public NamingEnumeration listBindings(Name name) throws NamingException {
        return listBindings(name.toString());
    }
    public void bind(Name name, Object value) throws NamingException {
        bind(name.toString(), value);
    }
    public void bind(String name, Object value) throws NamingException {
        if (isFrozen()) {
            throw new OperationNotSupportedException();
        } else {
            internalBind(name, value);
        }
    }
    public void close() throws NamingException {
        // ignore
    }
    public Context createSubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public Context createSubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public String getNameInNamespace() throws NamingException {
        return nameInNamespace;
    }
    public NameParser getNameParser(Name name) throws NamingException {
        return NAME_PARSER;
    }
    public NameParser getNameParser(String name) throws NamingException {
        return NAME_PARSER;
    }
    public void rebind(Name name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rebind(String name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rename(Name oldName, Name newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void rename(String oldName, String newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(String name) throws NamingException {
        bindings.remove(name);
        treeBindings.remove(name);
    }
    private abstract class LocalNamingEnumeration implements NamingEnumeration {
        private Iterator i = bindings.entrySet().iterator();
        public boolean hasMore() throws NamingException {
            return i.hasNext();
        }
        public boolean hasMoreElements() {
            return i.hasNext();
        }
        protected Map.Entry getNext() {
            return (Map.Entry)i.next();
        }
        public void close() throws NamingException {
        }
    }
    private class ListEnumeration extends LocalNamingEnumeration {
        ListEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new NameClassPair((String)entry.getKey(), entry.getValue().getClass().getName());
        }
    }
    private class ListBindingEnumeration extends LocalNamingEnumeration {
        ListBindingEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new Binding((String)entry.getKey(), entry.getValue());
        }
    }
    protected static Object createBean(Class<?> type, Map properties, String prefix) throws Exception {
        Object value = INJETOR.newInstance(type);
        IntrospectionSupport.setProperties(value, properties, prefix);
        return value;
    }
}
"
org.apache.camel.util.jndi.JndiTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.camel.TestSupport;
/**
 * @version $Revision: 630568 $
 */
public class JndiTest extends TestSupport {
    protected Context context;
    public static Context createInitialContext() throws Exception {
        InputStream in = JndiTest.class.getClassLoader().getResourceAsStream(""jndi-example.properties"");
        assertNotNull(""Cannot find jndi-example.properties on the classpath!"", in);
        Properties properties = new Properties();
        properties.load(in);
        return new InitialContext(new Hashtable(properties));
    }
    public void testLookupOfSimpleName() throws Exception {
        Object value = assertLookup(""foo"");
        assertEquals(""foo"", ""bar"", value);
    }
    public void testLookupOfTypedObject() throws Exception {
        Object value = assertLookup(""example"");
        ExampleBean bean = assertIsInstanceOf(ExampleBean.class, value);
        assertEquals(""Bean.name"", ""James"", bean.getName());
        assertEquals(""Bean.price"", 2.34, bean.getPrice());
        log.info(""Found bean: "" + bean);
    }
    protected Object assertLookup(String name) throws NamingException {
        Object value = context.lookup(name);
        assertNotNull(""Should have found JNDI entry: "" + name + "" in context: "" + context, value);
        return value;
    }
    protected void setUp() throws Exception {
        super.setUp();
        context = createInitialContext();
    }
}
"
org.apache.camel.view.DotViewTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.XPathBuilder;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 707553 $
 */
public class DotViewTest extends ContextTestSupport {
    protected String outputDirectory = ""target/site/cameldoc"";
    public void testGenerateFiles() throws Exception {
        RouteDotGenerator generator = new RouteDotGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context.addRoutes(new MulticastRoute());
        context.addRoutes(new PipelineRoute());
        context.addRoutes(new FromToRoute());
        context.addRoutes(new ChoiceRoute());
        context.addRoutes(new FilterRoute());
        context.addRoutes(new ComplexRoute());
    }
    static class MulticastRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:multicast.in"").
                    multicast().to(""seda:multicast.out1"", ""seda:multicast.out2"", ""seda:multicast.out3"");
        }
    }
    static class PipelineRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:pipeline.in"").to(""seda:pipeline.out1"", ""seda:pipeline.out2"", ""seda:pipeline.out3"");
        }
    }
    static class FromToRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:foo"").to(""seda:bar"");
        }
    }
    static class ChoiceRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/foo/xyz?noop=true"").
                choice().
                  when(xpath(""/person/city = 'London'"")).to(""file:target/messages/uk"").
                  otherwise().to(""file:target/messages/others"");
        }
    }
    static class FilterRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/foo/bar?noop=true"").filter(header(""foo"").isEqualTo(""bar""))
                .to(""file:target/xyz?noop=true"");
        }
    }
    static class ComplexRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/xyz?noop=true"").filter(header(""foo"").isEqualTo(""bar""))
                .recipientList(header(""bar"")).splitter(XPathBuilder.xpath(""/invoice/lineItems"")).throttler(3)
                .to(""mock:result"");
        }
    }
}
"
org.apache.camel.view.GraphGeneratorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.ToType;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public abstract class GraphGeneratorSupport {
    private static final transient Log LOG = LogFactory.getLog(RouteDotGenerator.class);
    protected String dir;
    protected int clusterCounter;
    protected String extension;
    //private String imagePrefix = ""http://www.enterpriseintegrationpatterns.com/img/"";
    private String imagePrefix = ""http://activemq.apache.org/camel/images/eip/"";
    private Map<Object, NodeData> nodeMap = new HashMap<Object, NodeData>();
    private boolean makeParentDirs = true;
    private Map<String, List<RouteType>> routeGroupMap;
    protected GraphGeneratorSupport(String dir, String extension) {
        this.dir = dir;
        this.extension = extension;
    }
    public String getDir() {
        return dir;
    }
    /**
     * Sets the destination directory in which to create the diagrams
     */
    public void setDir(String dir) {
        this.dir = dir;
    }
    public void drawRoutes(CamelContext context) throws IOException {
        File parent = new File(dir);
        if (makeParentDirs) {
            parent.mkdirs();
        }
        List<RouteType> routes = context.getRouteDefinitions();
        routeGroupMap = createRouteGroupMap(routes);
        // generate the global file
        generateFile(parent, ""routes"" + extension, routeGroupMap);
        if (routeGroupMap.size() >= 1) {
            Set<Map.Entry<String, List<RouteType>>> entries = routeGroupMap.entrySet();
            for (Map.Entry<String, List<RouteType>> entry : entries) {
                Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
                String group = entry.getKey();
                map.put(group, entry.getValue());
                // generate the file containing just the routes in this group
                generateFile(parent, group + extension, map);
            }
        }
    }
    private void generateFile(File parent, String fileName, Map<String, List<RouteType>> map) throws IOException {
        nodeMap.clear();
        clusterCounter = 0;
        PrintWriter writer = new PrintWriter(new FileWriter(new File(parent, fileName)));
        try {
            generateFile(writer, map);
        } finally {
            writer.close();
        }
    }
    protected abstract void generateFile(PrintWriter writer, Map<String, List<RouteType>> map);
    protected boolean isMulticastNode(ProcessorType node) {
        return node instanceof MulticastType || node instanceof ChoiceType;
    }
    protected String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(getLabel(expression));
        }
        return buffer.toString();
    }
    protected String getLabel(ExpressionType expression) {
        if (expression != null) {
            return expression.getLabel();
        }
        return """";
    }
    protected NodeData getNodeData(Object node) {
        Object key = node;
        if (node instanceof FromType) {
            FromType fromType = (FromType)node;
            key = fromType.getUriOrRef();
        } else if (node instanceof ToType) {
            ToType toType = (ToType)node;
            key = toType.getUriOrRef();
        }
        NodeData answer = nodeMap.get(key);
        if (answer == null) {
            String id = ""node"" + (nodeMap.size() + 1);
            answer = new NodeData(id, node, imagePrefix);
            nodeMap.put(key, answer);
        }
        return answer;
    }
    protected Map<String, List<RouteType>> createRouteGroupMap(List<RouteType> routes) {
        Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
        for (RouteType route : routes) {
            String group = route.getGroup();
            if (group == null) {
                group = ""Camel Routes"";
            }
            List<RouteType> list = map.get(group);
            if (list == null) {
                list = new ArrayList<RouteType>();
                map.put(group, list);
            }
            list.add(route);
        }
        return map;
    }
}
"
org.apache.camel.view.ModelFileGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.List;
import java.util.Properties;
import javax.xml.bind.Binder;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.RuntimeTransformException;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.RoutesType;
import org.apache.camel.util.ObjectHelper;
public class ModelFileGenerator {
    private static final String DEFAULT_ROOT_ELEMENT_NAME = ""routes"";
    private final JAXBContext jaxbContext;
    private Binder<Node> binder;
    public ModelFileGenerator(JAXBContext jaxbContext) {
        this.jaxbContext = jaxbContext;
    }
    /**
     * Write the specified 'routeTypes' to 'fileName' as XML using JAXB.
     */
    public void marshalRoutesUsingJaxb(String fileName, List<RouteType> routeTypes) throws IOException {
        OutputStream outputStream = outputStream(fileName);
        try {
            XmlConverter converter = converter();
            Document doc = converter.createDocument();
            Element root = doc.createElement(rootElementName());
            root.setAttribute(""xmlns"", Namespaces.DEFAULT_NAMESPACE);
            doc.appendChild(root);
            for (RouteType routeType : routeTypes) {
                addJaxbElementToNode(root, routeType);
            }
            Result result = new StreamResult(new OutputStreamWriter(outputStream, XmlConverter.defaultCharset));
            copyToResult(converter, doc, result);
        } catch (ParserConfigurationException e) {
            throw new RuntimeTransformException(e);
        } catch (TransformerException e) {
            throw new RuntimeTransformException(e);
        } finally {
            outputStream.close();
        }
    }
    /**
     * Returns a configured XmlConverter
     */
    private XmlConverter converter() {
        XmlConverter converter = new XmlConverter();
        TransformerFactory transformerFactory = converter.getTransformerFactory();
        transformerFactory.setAttribute(""indent-number"", new Integer(2));
        return converter;
    }
    /**
     * Copies the given input Document into the required result using the provided converter.
     */
    private void copyToResult(XmlConverter converter, Document doc, Result result) throws TransformerException {
        Properties outputProperties = converter.defaultOutputProperties();
        outputProperties.put(OutputKeys.OMIT_XML_DECLARATION, ""no"");
        outputProperties.put(OutputKeys.INDENT, ""yes"");
        converter.toResult(converter.toSource(doc), result, outputProperties);
    }
    /**
     * Convert the specified object into XML and add it as a child of 'node' using JAXB.
     */
    private void addJaxbElementToNode(Node node, Object jaxbElement) {
        try {
            if (binder == null) {
                binder = jaxbContext.createBinder();
            }
            binder.marshal(jaxbElement, node);
        } catch (JAXBException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Return the root element name for the list of routes.
     */
    private String rootElementName() {
        XmlRootElement annotation = (RoutesType.class).getAnnotation(XmlRootElement.class);
        if (annotation != null) {
            String elementName = annotation.name();
            if (ObjectHelper.isNotNullAndNonEmpty(elementName)) {
                return elementName;
            }
        }
        return DEFAULT_ROOT_ELEMENT_NAME;
    }
    /**
     * returns an output stream for the filename specified.
     */
    private OutputStream outputStream(String fileName) throws FileNotFoundException {
        File file = new File(fileName);
        if (!file.exists()) {
            File parentFile = file.getParentFile();
            if (parentFile != null) {
                parentFile.mkdirs();
            }
        }
        return new FileOutputStream(file);
    }
}
"
org.apache.camel.view.NodeData,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.model.AggregatorType;
import org.apache.camel.model.BeanRef;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FilterType;
import org.apache.camel.model.FromType;
import org.apache.camel.model.OtherwiseType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RecipientListType;
import org.apache.camel.model.ResequencerType;
import org.apache.camel.model.RoutingSlipType;
import org.apache.camel.model.SplitterType;
import org.apache.camel.model.ToType;
import org.apache.camel.model.WhenType;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * Represents a node in the EIP diagram tree
 *
 * @version $Revision: 707553 $
 */
public class NodeData {
    public String id;
    public String image;
    public String label;
    public String shape;
    public String edgeLabel;
    public String tooltop;
    public String nodeType;
    public boolean nodeWritten;
    public String url;
    public List<ProcessorType> outputs;
    public String association = ""property"";
    private final String imagePrefix;
    public NodeData(String id, Object node, String imagePrefix) {
        this.id = id;
        this.imagePrefix = imagePrefix;
        if (node instanceof ProcessorType) {
            ProcessorType processorType = (ProcessorType)node;
            this.edgeLabel = processorType.getLabel();
        }
        if (node instanceof FromType) {
            FromType fromType = (FromType)node;
            this.tooltop = fromType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        } else if (node instanceof ToType) {
            ToType toType = (ToType)node;
            this.tooltop = toType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        } else if (node instanceof FilterType) {
            this.image = imagePrefix + ""MessageFilterIcon.png"";
            this.label = ""Filter"";
            this.nodeType = ""Message Filter"";
        } else if (node instanceof WhenType) {
            this.image = imagePrefix + ""MessageFilterIcon.png"";
            this.nodeType = ""When Filter"";
            this.label = ""When"";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
        } else if (node instanceof OtherwiseType) {
            this.nodeType = ""Otherwise"";
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
            this.tooltop = ""Otherwise"";
        } else if (node instanceof ChoiceType) {
            this.image = imagePrefix + ""ContentBasedRouterIcon.png"";
            this.nodeType = ""Content Based Router"";
            this.label = ""Choice"";
            this.edgeLabel = """";
            ChoiceType choice = (ChoiceType)node;
            List<ProcessorType> outputs = new ArrayList<ProcessorType>(choice.getWhenClauses());
            if (choice.getOtherwise() != null) {
                outputs.add(choice.getOtherwise());
            }
            this.outputs = outputs;
        } else if (node instanceof RecipientListType) {
            this.image = imagePrefix + ""RecipientListIcon.png"";
            this.nodeType = ""Recipient List"";
        } else if (node instanceof RoutingSlipType) {
            this.image = imagePrefix + ""RoutingTableIcon.png"";
            this.nodeType = ""Routing Slip"";
            this.url = ""http://activemq.apache.org/camel/routing-slip.html"";
            this.tooltop = ((RoutingSlipType) node).getHeaderName();
        } else if (node instanceof SplitterType) {
            this.image = imagePrefix + ""SplitterIcon.png"";
            this.nodeType = ""Splitter"";
        } else if (node instanceof AggregatorType) {
            this.image = imagePrefix + ""AggregatorIcon.png"";
            this.nodeType = ""Aggregator"";
        } else if (node instanceof ResequencerType) {
            this.image = imagePrefix + ""ResequencerIcon.png"";
            this.nodeType = ""Resequencer"";
        } else if (node instanceof BeanRef) {
            BeanRef beanRef = (BeanRef) node;
            // TODO
            //this.image = imagePrefix + ""Bean.png"";
            this.nodeType = ""Bean Ref"";
            this.label = beanRef.getLabel() + "" Bean""; 
            this.shape = ""box"";
        }
        // lets auto-default as many values as we can
        if (isNullOrBlank(this.nodeType) && node != null) {
            // TODO we could add this to the model?
            String name = node.getClass().getName();
            int idx = name.lastIndexOf('.');
            if (idx > 0) {
                name = name.substring(idx + 1);
            }
            if (name.endsWith(""Type"")) {
                name = name.substring(0, name.length() - 4);
            }
            this.nodeType = insertSpacesBetweenCamelCase(name);
        }
        if (this.label == null) {
            if (isNullOrBlank(this.image)) {
                this.label = this.nodeType;
                this.shape = ""box"";
            } else if (isNotNullAndNonEmpty(this.edgeLabel)) {
                this.label = """";
            } else {
                this.label = node.toString();
            }
        }
        if (isNullOrBlank(this.tooltop)) {
            if (isNotNullAndNonEmpty(this.nodeType)) {
                String description = isNotNullAndNonEmpty(this.edgeLabel) ? this.edgeLabel : this.label;
                this.tooltop = this.nodeType + "": "" + description;
            } else {
                this.tooltop = this.label;
            }
        }
        if (isNullOrBlank(this.url) && isNotNullAndNonEmpty(this.nodeType)) {
            this.url = ""http://activemq.apache.org/camel/"" + this.nodeType.toLowerCase().replace(' ', '-')
                       + "".html"";
        }
        if (node instanceof ProcessorType && this.outputs == null) {
            ProcessorType processorType = (ProcessorType)node;
            this.outputs = processorType.getOutputs();
        }
    }
    protected String removeQueryString(String text) {
        int idx = text.indexOf(""?"");
        if (idx <= 0) {
            return text;
        } else {
            return text.substring(0, idx);
        }
    }
    /**
     * Lets insert a space before each upper case letter after a lowercase
     */
    public static String insertSpacesBetweenCamelCase(String name) {
        boolean lastCharacterLowerCase = false;
        StringBuffer buffer = new StringBuffer();
        int i = 0;
        for (int size = name.length(); i < size; i++) {
            char ch = name.charAt(i);
            if (Character.isUpperCase(ch)) {
                if (lastCharacterLowerCase) {
                    buffer.append(' ');
                }
                lastCharacterLowerCase = false;
            } else {
                lastCharacterLowerCase = true;
            }
            buffer.append(ch);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.view.RouteDotGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.PipelineType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.ToType;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
/**
 * A <a href=""http://www.graphviz.org/"">DOT</a> file creator plugin which
 * creates a DOT file showing the current routes
 *
 * @version $Revision: 708078 $
 */
public class RouteDotGenerator extends GraphGeneratorSupport {
    public RouteDotGenerator(String dir) {
        super(dir, "".dot"");
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        if (group != null) {
            writer.println(""subgraph cluster_"" + (clusterCounter++) + "" {"");
            writer.println(""label = \"""" + group + ""\"";"");
            writer.println(""color = grey;"");
            writer.println(""style = \""dashed\"";"");
            writer.println(""URL = \"""" + group + "".html\"";"");
            writer.println();
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            for (FromType input : inputs) {
                printRoute(writer, route, input);
            }
            writer.println();
        }
        if (group != null) {
            writer.println(""}"");
            writer.println();
        }
    }
    protected String escapeNodeId(String text) {
        return text.replace('.', '_').replace(""$"", ""_"");
    }
    protected void printRoute(PrintWriter writer, final RouteType route, FromType input) {
        NodeData nodeData = getNodeData(input);
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        NodeData from = nodeData;
        for (ProcessorType output : route.getOutputs()) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType || node instanceof InterceptorRef) {
            // no need for a multicast or interceptor node
            List<ProcessorType> outputs = node.getOutputs();
            boolean isPipeline = isPipeline(node);
            for (ProcessorType output : outputs) {
                NodeData out = printNode(writer, fromData, output);
                // if in pipeline then we should move the from node to the next in the pipeline
                if (isPipeline) {
                    fromData = out;
                }
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(fromData.id);
            writer.print("" -> "");
            writer.print(toData.id);
            writer.println("" ["");
            String label = fromData.edgeLabel;
            if (isNotNullAndNonEmpty(label)) {
                writer.println(""label = \"""" + label + ""\"""");
            }
            writer.println(""];"");
        }
        // now lets write any children
        //List<ProcessorType> outputs = node.getOutputs();
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(data.id);
            writer.println("" ["");
            writer.println(""label = \"""" + data.label + ""\"""");
            writer.println(""tooltip = \"""" + data.tooltop + ""\"""");
            if (data.url != null) {
                writer.println(""URL = \"""" + data.url + ""\"""");
            }
            String image = data.image;
            if (image != null) {
                writer.println(""shapefile = \"""" + image + ""\"""");
                writer.println(""peripheries=0"");
            }
            String shape = data.shape;
            if (shape == null && image != null) {
                shape = ""custom"";
            }
            if (shape != null) {
                writer.println(""shape = \"""" + shape + ""\"""");
            }
            writer.println(""];"");
            writer.println();
        }
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""digraph CamelRoutes {"");
        writer.println();
        writer.println(""node [style = \""rounded,filled\"", fillcolor = yellow, ""
                + ""fontname=\""Helvetica-Oblique\""];"");
        writer.println();
        printRoutes(writer, map);
        writer.println(""}"");
    }
    /**
     * Is the given node a pipeline
     */
    private static boolean isPipeline(ProcessorType node) {
        if (node instanceof MulticastType) {
            return false;
        }
        if (node instanceof PipelineType) {
            return true;
        }
        if (node.getOutputs().size() > 1) {
            // is pipeline if there is more than 1 output and they are all To types
            for (Object type : node.getOutputs()) {
                if (!(type instanceof ToType)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
}
"
org.apache.camel.view.RouteDotGeneratorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import junit.framework.TestCase;
/**
 * @version $Revision: 640438 $
 */
public class RouteDotGeneratorTest extends TestCase {
    public void testInsertSpacesBetweenCamelCase() throws Exception {
        String value = NodeData.insertSpacesBetweenCamelCase(""FooBarType"");
        assertEquals(""Converted value"", ""Foo Bar Type"", value);
    }
}
"
org.apache.camel.view.XmlGraphGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * @version $Revision: 640438 $
 */
public class XmlGraphGenerator extends GraphGeneratorSupport {
    private boolean addUrl = true;
    public XmlGraphGenerator(String dir) {
        super(dir, "".xml"");
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""<?xml version='1.0' encoding='UTF-8'?>"");
        writer.println(""<Graph>"");
        writer.println();
        if (map.size() > 0) {
            writer.println(""<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>"");
        }
        printRoutes(writer, map);
        writer.println();
        writer.println(""</Graph>"");
    }
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        group = encode(group);
        if (group != null) {
            int idx = group.lastIndexOf('.');
            String name = group;
            if (idx > 0 && idx < group.length() - 1) {
                name = group.substring(idx + 1);
            }
            writer.println(""<Node id='"" + group + ""' name='"" + name + ""' description='"" + group + ""' nodeType='group'/>"");
            writer.println(""<Edge fromID='root' toID='"" + group + ""'/>"");
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            boolean first = true;
            for (FromType input : inputs) {
                NodeData nodeData = getNodeData(input);
                if (first) {
                    first = false;
                    if (group != null) {
                        writer.println(""<Edge fromID='"" + group + ""' toID='"" + encode(nodeData.id) + ""'/>"");
                    }
                }
                printRoute(writer, route, nodeData);
            }
            writer.println();
        }
    }
    protected void printRoute(PrintWriter writer, final RouteType route, NodeData nodeData) {
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        NodeData from = nodeData;
        for (ProcessorType output : route.getOutputs()) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType) {
            // no need for a multicast node
            List<ProcessorType> outputs = node.getOutputs();
            for (ProcessorType output : outputs) {
                printNode(writer, fromData, output);
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(""<Edge fromID=\"""");
            writer.print(encode(fromData.id));
            writer.print(""\"" toID=\"""");
            writer.print(encode(toData.id));
            String association = toData.edgeLabel;
            if (isNullOrBlank(association)) {
                writer.print(""\"" association=\"""");
                writer.print(encode(association));
            }
            writer.println(""\""/>"");
        }
        // now lets write any children
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(""<Node id=\"""");
            writer.print(encode(data.id));
            writer.print(""\"" name=\"""");
            String name = data.label;
            if (isNullOrBlank(name)) {
                name = data.tooltop;
            }
            writer.print(encode(name));
            writer.print(""\"" nodeType=\"""");
            String nodeType = data.image;
            if (isNullOrBlank(nodeType)) {
                nodeType = data.shape;
                if (isNullOrBlank(nodeType)) {
                    nodeType = ""node"";
                }
            }
            writer.print(encode(nodeType));
            writer.print(""\"" description=\"""");
            writer.print(encode(data.tooltop));
            if (addUrl) {
                writer.print(""\"" url=\"""");
                writer.print(encode(data.url));
            }
            writer.println(""\""/>"");
        }
    }
    protected String encode(String text) {
        if (text == null) {
            return """";
        }
        return text.replaceAll(""\"""", ""&quot;"").replaceAll(""<"", ""&lt;"").
                replaceAll("">"", ""&gt;"").replaceAll(""&"", ""&amp;"");
    }
}
"
org.apache.camel.view.XmlGraphTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
/**
 * @version $Revision: 640438 $
 */
public class XmlGraphTest extends DotViewTest {
    @Override
    public void testGenerateFiles() throws Exception {
        XmlGraphGenerator generator = new XmlGraphGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
}
"
org.apache.camel.component.cxf.CxfComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Component</a>
 * @version $Revision$
 */
public class CxfComponent extends DefaultComponent<CxfExchange> implements HeaderFilterStrategyAware {
    private HeaderFilterStrategy headerFilterStrategy = new CxfHeaderFilterStrategy();
    public CxfComponent() {
    }
    public CxfComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        // Now we need to add the address, endpoint name, WSDL url or the SEI to build up an endpoint
        CxfEndpoint result = new CxfEndpoint(uri, remaining, this);
        setProperties(result, parameters);
        // We can check the endpoint integration here
        return result;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.impl.DefaultExchangeFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
/**
 * A default {@link ExchangeFormatter} which just uses the {@link org.apache.camel.Exchange} <tt>toString()</tt> method
 *
 * @version $Revision$
 */
public class DefaultExchangeFormatter implements ExchangeFormatter {
    protected static final DefaultExchangeFormatter INSTANCE = new DefaultExchangeFormatter();
    public static DefaultExchangeFormatter getInstance() {
        return INSTANCE;
    }
    public Object format(Exchange exchange) {
        return exchange;
    }
}
"
org.apache.camel.component.jetty.JettyHttpComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.component.http.CamelServlet;
import org.apache.camel.component.http.HttpComponent;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpEndpoint;
import org.apache.camel.component.http.HttpExchange;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
import org.apache.commons.httpclient.params.HttpClientParams;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mortbay.jetty.Connector;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.handler.ContextHandlerCollection;
import org.mortbay.jetty.nio.SelectChannelConnector;
import org.mortbay.jetty.security.SslSocketConnector;
import org.mortbay.jetty.servlet.Context;
import org.mortbay.jetty.servlet.HashSessionIdManager;
import org.mortbay.jetty.servlet.HashSessionManager;
import org.mortbay.jetty.servlet.ServletHolder;
import org.mortbay.jetty.servlet.SessionHandler;
/**
 * An HttpComponent which starts an embedded Jetty for to handle consuming from
 * the http endpoints.
 *
 * @version $Revision$
 */
public class JettyHttpComponent extends HttpComponent {
    class ConnectorRef {
        Connector connector;
        CamelServlet servlet;
        int refCount;
        public ConnectorRef(Connector connector, CamelServlet servlet) {
            this.connector = connector;
            this.servlet = servlet;
            increment();
        }
        public int increment() {
            return ++refCount;
        }
        public int decrement() {
            return --refCount;
        }
    }
    private static final transient Log LOG = LogFactory.getLog(JettyHttpComponent.class);
    protected Server server;
    protected HashMap<String, ConnectorRef> connectors = new HashMap<String, ConnectorRef>();    
    protected String sslKeyPassword;
    protected String sslPassword;
    protected String sslKeystore;
    protected SslSocketConnector sslSocketConnector;
    @Override
    protected Endpoint<HttpExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        uri = uri.startsWith(""jetty:"") ? remaining : uri;
        HttpClientParams params = new HttpClientParams();
        IntrospectionSupport.setProperties(params, parameters, ""httpClient."");   
        configureParameters(parameters);
        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options
        URI httpUri = URISupport.createRemainingURI(new URI(uri), parameters);
        uri = httpUri.toString();
        JettyHttpEndpoint result = new JettyHttpEndpoint(this, uri, httpUri, params, getHttpConnectionManager(), httpClientConfigurer);
        if (httpBinding != null) {
            result.setBinding(httpBinding);
        }
        setProperties(result, parameters);
        return result;
    }
    /**
     * Connects the URL specified on the endpoint to the specified processor.
     *
     * @throws Exception
     */
    @Override
    public void connect(HttpConsumer consumer) throws Exception {
        // Make sure that there is a connector for the requested endpoint.
        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();
        String connectorKey = getConnectorKey(endpoint);
        synchronized (connectors) {
            ConnectorRef connectorRef = connectors.get(connectorKey);
            if (connectorRef == null) {
                Connector connector;
                if (""https"".equals(endpoint.getProtocol())) {
                    connector = getSslSocketConnector();
                } else {
                    connector = new SelectChannelConnector();
                }
                connector.setPort(endpoint.getPort());
                connector.setHost(endpoint.getHttpUri().getHost());
                if (""localhost"".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {
                    LOG.warn(""You use localhost interface! It means that no external connections will be available. Don't you want to use 0.0.0.0 instead (all network interfaces)?"");
                }
                getServer().addConnector(connector);
                connectorRef = new ConnectorRef(connector, createServletForConnector(connector));
                connector.start();
                connectors.put(connectorKey, connectorRef);
            } else {
                // ref track the connector
                connectorRef.increment();
            }
            // check the session support
            if (endpoint.isSessionSupport()) {
                enableSessionSupport();
            }
            connectorRef.servlet.connect(consumer);
        }
    }
    private void enableSessionSupport() throws Exception {
        Context context = (Context)getServer().getChildHandlerByClass(Context.class);
        if (context.getSessionHandler() == null) {
            SessionHandler sessionHandler = new SessionHandler();
            context.setSessionHandler(sessionHandler);
            if (context.isStarted()) {
                // restart the context
                context.stop();
                context.start();
            }
        }
    }
    /**
     * Disconnects the URL specified on the endpoint from the specified
     * processor.
     */
    @Override
    public void disconnect(HttpConsumer consumer) throws Exception {
        // If the connector is not needed anymore then stop it
        HttpEndpoint endpoint = consumer.getEndpoint();
        String connectorKey = getConnectorKey(endpoint);
        synchronized (connectors) {
            ConnectorRef connectorRef = connectors.get(connectorKey);
            if (connectorRef != null) {
                connectorRef.servlet.disconnect(consumer);
                if (connectorRef.decrement() == 0) {
                    getServer().removeConnector(connectorRef.connector);
                    connectorRef.connector.stop();
                    connectors.remove(connectorKey);
                }
            }
        }
    }
    private String getConnectorKey(HttpEndpoint endpoint) {
        return endpoint.getProtocol() + "":"" + endpoint.getHttpUri().getHost() + "":"" + endpoint.getPort();
    }
    // Properties
    // -------------------------------------------------------------------------
    public Server getServer() throws Exception {
        if (server == null) {
            server = createServer();
        }
        return server;
    }
    public void setServer(Server server) {
        this.server = server;
    }
    public String getSslKeyPassword() {
        return sslKeyPassword;
    }
    public void setSslKeyPassword(String sslKeyPassword) {
        this.sslKeyPassword = sslKeyPassword;
    }
    public String getSslPassword() {
        return sslPassword;
    }
    public void setSslPassword(String sslPassword) {
        this.sslPassword = sslPassword;
    }
    public void setKeystore(String sslKeystore) {
        this.sslKeystore = sslKeystore;
    }
    public String getKeystore() {
        return sslKeystore;
    }
    public synchronized SslSocketConnector getSslSocketConnector() {
        if (sslSocketConnector == null) {
            sslSocketConnector = new SslSocketConnector();
            // with default null values, jetty ssl system properties
            // and console will be read by jetty implementation
            sslSocketConnector.setPassword(sslPassword);
            sslSocketConnector.setKeyPassword(sslKeyPassword);
            if (sslKeystore != null) {
                sslSocketConnector.setKeystore(sslKeystore);
            }
        }
        return sslSocketConnector;
    }
    public void setSslSocketConnector(SslSocketConnector connector) {
        sslSocketConnector = connector;
    }
    protected CamelServlet createServletForConnector(Connector connector) throws Exception {
        CamelServlet camelServlet = new CamelContinuationServlet();
        Context context = new Context(server, ""/"", Context.NO_SECURITY | Context.NO_SESSIONS);
        context.setConnectorNames(new String[] {connector.getName()});
        ServletHolder holder = new ServletHolder();
        holder.setServlet(camelServlet);
        context.addServlet(holder, ""/*"");
        connector.start();
        context.start();
        return camelServlet;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected Server createServer() throws Exception {
        Server server = new Server();
        ContextHandlerCollection collection = new ContextHandlerCollection();
        collection.setServer(server);
        server.addHandler(collection);
        server.start();
        return server;
    }
    @Override
    protected void doStop() throws Exception {
        for (ConnectorRef connectorRef : connectors.values()) {
            connectorRef.connector.stop();            
        }
        connectors.clear();
        if (server != null) {
            server.stop();
        }
        super.doStop();
    }
}
"
org.apache.camel.language.simple.SimpleLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.language.IllegalSyntaxException;
import org.apache.camel.util.ObjectHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/simple.html"">simple language</a>
 * which maps simple property style notations to access headers and bodies.
 * Examples of supported expressions are:
 * <ul>
 * <li>id to access the inbound message Id</li>
 * <li>in.body or body to access the inbound body</li>
 * <li>out.body to access the inbound body</li>
 * <li>in.header.foo or header.foo to access an inbound header called 'foo'</li>
 * <li>out.header.foo to access an outbound header called 'foo'</li>
 * <li>property.foo to access the exchange property called 'foo'</li>
 * <li>sys.foo to access the system property called 'foo'</li>
 * <li>date:&lt;command&gt;:&lt;pattern&gt; for date formatting using the {@link java.text.SimpleDateFormat} patterns.
 *     Supported commands are: <tt>now</tt> for current timestamp,
 *     <tt>in.header.xxx</tt> or <tt>header.xxx</tt> to use the Date object in the in header.
 *     <tt>out.header.xxx</tt> to use the Date object in the out header.
 * </li>
 * <li>bean:&lt;bean expression&gt; to invoke a bean using the
 * {@link org.apache.camel.language.bean.BeanLanguage BeanLanguage}</li>
 * </ul>
 *
 * @version $Revision$
 */
public class SimpleLanguage extends AbstractSimpleLanguage {
    public static Expression simple(String expression) {
        SimpleLanguage language = new SimpleLanguage();
        return language.createExpression(expression);
    }
    protected Expression<Exchange> createSimpleExpression(String expression) {
        if (ObjectHelper.isEqualToAny(expression, ""body"", ""in.body"")) {
            return ExpressionBuilder.bodyExpression();
        } else if (ObjectHelper.equal(expression, ""out.body"")) {
            return ExpressionBuilder.outBodyExpression();
        } else if (ObjectHelper.equal(expression, ""id"")) {
            return ExpressionBuilder.messageIdExpression();
        }
        // in header expression
        String remainder = ifStartsWithReturnRemainder(""in.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""header."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""headers."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""in.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.headerExpression(remainder);
        }
        // out header expression
        remainder = ifStartsWithReturnRemainder(""out.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""out.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.outHeaderExpression(remainder);
        }
        // property
        remainder = ifStartsWithReturnRemainder(""property."", expression);
        if (remainder != null) {
            return ExpressionBuilder.propertyExpression(remainder);
        }
        // system property
        remainder = ifStartsWithReturnRemainder(""sys."", expression);
        if (remainder != null) {
            return ExpressionBuilder.systemProperty(remainder);
        }
        // date: prefix
        remainder = ifStartsWithReturnRemainder(""date:"", expression);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length != 2) {
                throw new IllegalSyntaxException(this, expression + "" ${date:command:pattern} is the correct syntax."");
            }
            String command = parts[0];
            String pattern = parts[1];
            return ExpressionBuilder.dateExpression(command, pattern);
        }
        // bean: prefix
        remainder = ifStartsWithReturnRemainder(""bean:"", expression);
        if (remainder != null) {
            return ExpressionBuilder.beanExpression(remainder);
        }
        throw new IllegalSyntaxException(this, expression);
    }
}
"
org.apache.camel.component.file.FileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
/**
 * Represents a strategy for marking that a file is processed.
 *
 * @version $Revision$
 */
public interface FileProcessStrategy {
    /**
     * Called when work is about to begin on this file. This method may attempt to acquire some file lock before
     * returning true; returning false if the file lock could not be obtained so that the file should be ignored.
     *
     * @param endpoint  the endpoint
     * @param exchange  the exchange
     * @param file      the file
     * @return true if the file can be processed (such as if a file lock could be obtained)
     * @throws Exception can be thrown in case of errors
     */
    boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
    /**
     * Releases any file locks and possibly deletes or moves the file after successful processing
     *
     * @param endpoint  the endpoint
     * @param exchange  the exchange
     * @param file      the file
     * @throws Exception can be thrown in case of errors
     */
    void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
    /**
     * Releases any file locks and possibly deletes or moves the file after unsuccessful processing
     *
     * @param endpoint  the endpoint
     * @param exchange  the exchange
     * @param file      the file
     */
    void rollback(FileEndpoint endpoint, FileExchange exchange, File file);
}
"
org.apache.camel.component.restlet.RestletConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
/**
 * Constants for Restlet component
 * 
 * @version $Revision$
 */
public final class RestletConstants {
    public static final String LOGIN = ""org.apache.camel.restlet.auth.login"";
    public static final String PASSWORD = ""org.apache.camel.restlet.auth.password"";
    public static final String MEDIA_TYPE = ""org.apache.camel.restlet.mediaType"";
    public static final String RESPONSE_CODE = ""org.apache.camel.restlet.responseCode"";
    public static final String QUERY_STRING = ""org.apache.camel.restlet.queryString"";
    private RestletConstants() {
    }
}
"
org.apache.camel.impl.DefaultLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Default implementation of the lifecycle strategy.
 */
public class DefaultLifecycleStrategy implements LifecycleStrategy {
    public void onContextStart(CamelContext context) {
        // do nothing
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        // do nothing
    }
    public void onServiceAdd(CamelContext context, Service service) {
        // do nothing
    }
    public void onRoutesAdd(Collection<Route> routes) {
        // do nothing
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        RouteType routeType = routeContext.getRoute();
        if (routeType.getInputs() != null && !routeType.getInputs().isEmpty()) {
            // configure the outputs
            List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>(routeType.getOutputs());
            // clearing the outputs
            routeType.clearOutput();
            // add the output configure the outputs with the routeType
            for (ProcessorType<?> processorType : outputs) {
                routeType.addOutput(processorType);
            }
        }
    }
}
"
org.apache.camel.RecipientList,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Indicates that this method is to be used as a 
 * <a href=""http://activemq.apache.org/camel/recipient-list.html"">Dynamic Recipient List</a> routing the incoming message
 * to one or more endpoints.
 *
 * When a message {@link org.apache.camel.Exchange} is received from an {@link org.apache.camel.Endpoint} then the
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 * mechanism is used to map the incoming {@link org.apache.camel.Message} to the method parameters.
 *
 * The return value of the method is then converted to either a {@link java.util.Collection} or array of objects where each
 * element is converted to an {@link Endpoint} or a {@link String}, or if it is not a collection/array then it is converted
 * to an {@link Endpoint} or {@link String}.
 *
 * Then for each endpoint or URI the message is forwarded a separate copy.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface RecipientList {
}"
org.apache.camel.language.groovy.CamelGroovyMethods,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.Closure;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FilterType;
import org.apache.camel.model.ProcessorType;
/**
 * @version $Revision$
 */
public final class CamelGroovyMethods {
    private CamelGroovyMethods() {
        // Utility Class
    }
    public static FilterType filter(ProcessorType self, Closure filter) {
        return self.filter(toExpression(filter));
    }
    public static ChoiceType when(ChoiceType self, Closure filter) {
        return self.when(toExpression(filter));
    }
    public static ExpressionSupport toExpression(final Closure filter) {
        return new ExpressionSupport<Exchange>() {
            protected String assertionFailureMessage(Exchange exchange) {
                return filter.toString();
            }
            public Object evaluate(Exchange exchange) {
                return filter.call(exchange);
            }
            @Override
            public String toString() {
                return ""Groovy["" + filter + ""]"";
            }
        };
    }
}
"
org.apache.camel.language.simple.FileExpressionBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.language.IllegalSyntaxException;
import org.apache.camel.language.constant.ConstantLanguage;
/**
 * A helper class for working with <a href=""http://activemq.apache.org/camel/expression.html"">expressions</a> based
 * on files.
 * <p/>
 * This expression expects the headers from the {@link FileLanguage} on the <b>IN</b> message.
 *
 * @see org.apache.camel.language.simple.FileLanguage
 */
public final class FileExpressionBuilder {
    private FileExpressionBuilder() {
        // Helper class
    }
    public static <E extends Exchange> Expression<E> fileNameExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFileName"", String.class);
            }
            @Override
            public String toString() {
                return ""file:name"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> fileNameNoExtensionExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String name = exchange.getIn().getHeader(""CamelFileName"", String.class);
                if (name.lastIndexOf(""."") != -1) {
                    return name.substring(0, name.lastIndexOf('.'));
                } else {
                    // name does not have extension
                    return name;
                }
            }
            @Override
            public String toString() {
                return ""file:name.noext"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> fileParentExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFileParent"", String.class);
            }
            @Override
            public String toString() {
                return ""file:parent"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> filePathExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFilePath"", String.class);
            }
            @Override
            public String toString() {
                return ""file:path"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> fileAbsolutePathExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFileAbsolutePath"", String.class);
            }
            @Override
            public String toString() {
                return ""file:absolute.path"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> fileCanoicalPathExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFileCanonicalPath"", String.class);
            }
            @Override
            public String toString() {
                return ""file:canonical.path"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> fileSizeExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeader(""CamelFileLength"", Long.class);
            }
            @Override
            public String toString() {
                return ""file:length"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> dateExpression(final String command, final String pattern) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                if (""file"".equals(command)) {
                    Date date = exchange.getIn().getHeader(""CamelFileLastModified"", Date.class);
                    if (date != null) {
                        SimpleDateFormat df = new SimpleDateFormat(pattern);
                        return df.format(date);
                    } else {
                        return null;
                    }
                }
                // must call evaluate to return the nested language evaluate when evaluating
                // stacked expressions
                return ExpressionBuilder.dateExpression(command, pattern).evaluate(exchange);
            }
            @Override
            public String toString() {
                return ""date("" + command + "":"" + pattern + "")"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> simpleExpression(final String simple) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                // must call evaluate to return the nested language evaluate when evaluating
                // stacked expressions
                try {
                    return SimpleLanguage.simple(simple).evaluate(exchange);
                } catch (IllegalSyntaxException e) {
                    // fallback to constant so end users can enter a fixed filename
                    return ConstantLanguage.constant(simple).evaluate(exchange);
                }
            }
            @Override
            public String toString() {
                return ""simple("" + simple + "")"";
            }
        };
    }
}
"
org.apache.camel.component.file.remote.RemoteFileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.net.ftp.FTPClientConfig;
public class RemoteFileComponent extends DefaultComponent<RemoteFileExchange> {
    private RemoteFileConfiguration configuration;
    public RemoteFileComponent() {
        this.configuration = new RemoteFileConfiguration();
    }
    public RemoteFileComponent(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
    public RemoteFileComponent(CamelContext context) {
        super(context);
        this.configuration = new RemoteFileConfiguration();
    }
    public String toString() {
        return ""RemoteFileComponent"";
    }
    public static RemoteFileComponent remoteFileComponent() {
        return new RemoteFileComponent();
    }
    protected RemoteFileEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        RemoteFileConfiguration config = getConfiguration().copy();
        // get the base uri part before the options as they can be non URI valid such as the expression using $ chars
        // and the URI constructor will regard $ as an illegal character and we dont want to enforce end users to
        // to espace the $ for the expression (file language)
        String baseUri = uri;
        if (uri.indexOf(""?"") != -1) {
            baseUri = uri.substring(0, uri.indexOf(""?""));
        }
        config.configure(new URI(baseUri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final RemoteFileEndpoint endpoint;
        if (""ftp"".equals(config.getProtocol())) {
            endpoint = new FtpEndpoint(uri, this, config);
        } else if (""sftp"".equals(config.getProtocol())) {
            endpoint = new SftpEndpoint(uri, this, config);
        } else {
            throw new RuntimeCamelException(""Unsupported protocol: "" + config.getProtocol());
        }
        configureFTPClientConfig(parameters, endpoint);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    private void configureFTPClientConfig(Map parameters, RemoteFileEndpoint endpoint) {
        // lookup client config in registry if provided
        String ref = getAndRemoveParameter(parameters, ""ftpClientConfig"", String.class);
        if (ref != null) {
            FTPClientConfig ftpClientConfig = this.getCamelContext().getRegistry().lookup(ref, FTPClientConfig.class);
            if (ftpClientConfig == null) {
                throw new IllegalArgumentException(""FTPClientConfig "" + ref + "" not found in registry."");
            }
            endpoint.getConfiguration().setFtpClientConfig(ftpClientConfig);
        }
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.jmx.JMXEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.MBeanServer;
import javax.management.Notification;
import javax.management.ObjectName;
import javax.management.monitor.CounterMonitor;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMXEndpoint for monitoring JMX attributs using {@link CounterMonitor}.
 *
 * @version $Revision$
 */
public class JMXEndpoint extends DefaultEndpoint<JMXExchange> {
    private static final transient Log LOG = LogFactory.getLog(JMXEndpoint.class);
    private String name;
    private ObjectName ourName;
    private String observedObjectName;
    private String attributeName;
    private long granularityPeriod = 5000;
    private Number threshold;
    private Number offset;
    private MBeanServer mbeanServer;
    private CounterMonitor counterMonitor = new CounterMonitor();
    protected JMXEndpoint(String endpointUri, JMXComponent component) {
        super(endpointUri, component);
        observedObjectName = endpointUri;
    }
    public JMXEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<JMXExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""Producer not supported"");
    }
    public Consumer<JMXExchange> createConsumer(Processor proc) throws Exception {
        ObjectName observedName = new ObjectName(observedObjectName);
        if (name == null) {
            String type = observedName.getKeyProperty(""type"");
            type = type != null ? type : ""UNKNOWN"";
            name = mbeanServer.getDefaultDomain() + "":type=CounterMonitor_"" + type;
        }
        JMXConsumer result = new JMXConsumer(this, proc);
        ourName = new ObjectName(name);
        counterMonitor.setNotify(true);
        counterMonitor.addObservedObject(observedName);
        counterMonitor.setObservedAttribute(attributeName);
        counterMonitor.setGranularityPeriod(granularityPeriod);
        counterMonitor.setDifferenceMode(false);
        counterMonitor.setInitThreshold(threshold);
        counterMonitor.setOffset(offset);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Registering and adding notification listener for ["" + counterMonitor + ""] with name ["" + ourName + ""]"");
        }
        mbeanServer.registerMBean(counterMonitor, ourName);
        // TODO: How do we remove the listener?
        mbeanServer.addNotificationListener(ourName, result, null, new Object());
        return result;
    }
    public boolean isSingleton() {
        return true;
    }
    public JMXExchange createExchange(Notification notification) {
        return new JMXExchange(getCamelContext(), getExchangePattern(), notification);
    }
    public JMXExchange createExchange() {
        return new JMXExchange(getCamelContext(), getExchangePattern(), null);
    }
    public JMXExchange createExchange(ExchangePattern pattern) {
        return new JMXExchange(getCamelContext(), pattern, null);
    }
    public String getAttributeName() {
        return attributeName;
    }
    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }
    public long getGranularityPeriod() {
        return granularityPeriod;
    }
    public void setGranularityPeriod(long granularityPeriod) {
        this.granularityPeriod = granularityPeriod;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Number getOffset() {
        return offset;
    }
    public void setOffset(Number offset) {
        this.offset = offset;
    }
    public Number getThreshold() {
        return threshold;
    }
    public void setThreshold(Number threshold) {
        this.threshold = threshold;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.component.file.remote.SftpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.UserInfo;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
public class SftpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    protected final transient Log log = LogFactory.getLog(getClass());
    public SftpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public SftpEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public SftpProducer createProducer() throws Exception {
        return new SftpProducer(this, createSession());
    }
    public SftpConsumer createConsumer(Processor processor) throws Exception {
        final SftpConsumer consumer = new SftpConsumer(this, processor, createSession());
        configureConsumer(consumer);
        return consumer;
    }
    protected Session createSession() throws JSchException {
        final JSch jsch = new JSch();
        String privateKeyFile = getConfiguration().getPrivateKeyFile();
        if (isNotNullAndNonEmpty(privateKeyFile)) {
            log.debug(""Using private keyfile: "" + privateKeyFile);
            String privateKeyFilePassphrase = getConfiguration().getPrivateKeyFilePassphrase(); 
            if (isNotNullAndNonEmpty(privateKeyFilePassphrase)) {
                jsch.addIdentity(privateKeyFile, privateKeyFilePassphrase);
            } else {
                jsch.addIdentity(privateKeyFile);
            }
        }
        String knownHostsFile = getConfiguration().getKnownHosts();
        if (isNotNullAndNonEmpty(knownHostsFile)) {
            log.debug(""Using knownHosts: "" + knownHostsFile);
            jsch.setKnownHosts(knownHostsFile);
        }
        final Session session = jsch.getSession(getConfiguration().getUsername(), getConfiguration().getHost(), getConfiguration().getPort());
        session.setUserInfo(new UserInfo() {
            public String getPassphrase() {
                return null;
            }
            public String getPassword() {
                return getConfiguration().getPassword();
            }
            public boolean promptPassword(String string) {
                return true;
            }
            public boolean promptPassphrase(String string) {
                return true;
            }           
            public boolean promptYesNo(String string) {
                log.error(string);
                // Return 'false' indicating modification of the hosts file is disabled.
                return false;
            }
            public void showMessage(String string) {
            }
        });
        return session;
    }
    public ChannelSftp createChannelSftp(Session session) throws JSchException {
        final ChannelSftp channel = (ChannelSftp) session.openChannel(""sftp"");
        return channel;
    }
}
"
org.apache.camel.component.bean.DefaultAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * Default implementation of the {@link AnnotationExpressionFactory}.
 *
 * @version $Revision$
 */
public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory {
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String languageName = languageAnnotation.language();
        if (languageName == null) {
            throw new IllegalArgumentException(""Cannot determine the language from the annotation: "" + annotation);
        }
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Cannot find the language: "" + languageName + "" on the classpath"");
        }
        String expression = getExpressionFromAnnotation(annotation);
        return language.createExpression(expression);
    }
    protected String getExpressionFromAnnotation(Annotation annotation) {
        // lets try the 'value()' method
        try {
            Method method = annotation.getClass().getMethod(""value"");
            Object value = ObjectHelper.invokeMethod(method, annotation);
            if (value == null) {
                throw new IllegalArgumentException(""Cannot determine the expression from the annotation: "" + annotation);
            }
            return value.toString();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(""Cannot determine the expression of the annotation: "" + annotation + "" as it does not have an value() method"");
        }
    }
}
"
org.apache.camel.impl.converter.AsyncProcessorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.TypeConverter;
import org.apache.camel.processor.DelegateProcessor;
/**
 * A simple converter that can convert any {@link Processor} to an {@link AsyncProcessor}.
 * Processing will still occur synchronously but it will provide the required
 * notifications that the caller expects.
 *
 * @version $Revision$
 */
public class AsyncProcessorTypeConverter implements TypeConverter {
    private static final class ProcessorToAsyncProcessorBridge extends DelegateProcessor implements AsyncProcessor {
        private ProcessorToAsyncProcessorBridge(Processor processor) {
            super(processor);
        }
        public boolean process(Exchange exchange, AsyncCallback callback) {
            try {
                processor.process(exchange);
            } catch (Throwable e) {
                exchange.setException(e);
            }
            // false means processing of the exchange asynchronously,
            callback.done(true);
            return true;
        }
    }
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(AsyncProcessor.class)) {
                if (value instanceof AsyncProcessor) {
                    return toType.cast(value);
                } else if (value instanceof Processor) {
                    // Provide an async bridge to the regular processor.
                    final Processor processor = (Processor)value;
                    return toType.cast(new ProcessorToAsyncProcessorBridge(processor));
                }
            }
        }
        return null;
    }
    public <T> T convertTo(Class<T> toType, Exchange exchange, Object value) {
        return convertTo(toType, value);
    }
    public static AsyncProcessor convert(Processor value) {
        if (value instanceof AsyncProcessor) {
            return (AsyncProcessor)value;
        }
        return new ProcessorToAsyncProcessorBridge(value);
    }
}
"
org.apache.camel.component.irc.IrcBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
public class IrcBinding {
    public Object extractBodyFromIrc(IrcExchange exchange, IrcMessage message) {
        String type = message.getMessageType();
        String text = message.getMessage();
        if (text != null) {
            return text;
        } else {
            return type;
        }
    }
}
"
org.apache.camel.bam.processor.ProcessContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.ProcessRules;
/**
 * @version $Revision$
 */
public class ProcessContext {
    private Exchange exchange;
    private ProcessRules processRules;
    private ActivityRules activityRules;
    private ProcessInstance processInstance;
    private ActivityState activityState;
    public ProcessContext(Exchange exchange, ActivityRules activityRules, ActivityState activityState) {
        this.exchange = exchange;
        this.activityRules = activityRules;
        this.activityState = activityState;
        this.processRules = activityRules.getProcessRules();
        this.processInstance = activityState.getProcessInstance();
    }
    public ActivityRules getActivity() {
        return activityRules;
    }
    public void setActivity(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public ActivityState getActivityState() {
        return activityState;
    }
    public void setActivityState(ActivityState activityState) {
        this.activityState = activityState;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public ProcessRules getProcessDefinition() {
        return processRules;
    }
    public void setProcessDefinition(ProcessRules processRules) {
        this.processRules = processRules;
    }
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
    }
    public ActivityState getActivityState(ActivityRules activityRules) {
        return getProcessInstance().getActivityState(activityRules);
    }
    /**
     * Called when the activity is started which may end up creating some timers
     * for dependent actions
     */
    public void onStarted(ActivityState activityState) {
        /** TODO */
    }
    /**
     * Called when the activity is completed which may end up creating some timers
     * for dependent actions
     */
    public void onCompleted(ActivityState activityState) {
        /** TODO */
    }
}
"
org.apache.camel.RuntimeCamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Base class for all Camel unchecked exceptions.
 *
 * @version $Revision$
 */
public class RuntimeCamelException extends RuntimeException {
    private static final long serialVersionUID = 8046489554418284257L;
    public RuntimeCamelException() {
    }
    public RuntimeCamelException(String message) {
        super(message);
    }
    public RuntimeCamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeCamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.impl.converter.ArrayTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 *
 * @version $Revision$
 */
public class ArrayTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isArray()) {
            if (value instanceof Collection) {
                Collection collection = (Collection)value;
                Object array = Array.newInstance(type.getComponentType(), collection.size());
                if (array instanceof Object[]) {
                    collection.toArray((Object[])array);
                } else {
                    int index = 0;
                    for (Object element : collection) {
                        Array.set(array, index++, element);
                    }
                }
                return (T)array;
            } else if (value != null && value.getClass().isArray()) {
                int size = Array.getLength(value);
                Object answer = Array.newInstance(type.getComponentType(), size);
                for (int i = 0; i < size; i++) {
                    Array.set(answer, i, Array.get(value, i));
                }
                return (T)answer;
            }
        } else if (Collection.class.isAssignableFrom(type)) {
            if (value != null) {
                if (value instanceof Object[]) {
                    return (T)Arrays.asList((Object[])value);
                } else if (value.getClass().isArray()) {
                    int size = Array.getLength(value);
                    List answer = new ArrayList(size);
                    for (int i = 0; i < size; i++) {
                        answer.add(Array.get(value, i));
                    }
                    return (T)answer;
                }
            }
        }
        return null;
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        return convertTo(type, value);
    }
}
"
org.apache.camel.component.direct.DirectEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a direct endpoint that synchronously invokes the consumers of the
 * endpoint when a producer sends a message to it.
 *
 * @version $Revision$
 */
public class DirectEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private static final transient Log LOG = LogFactory.getLog(DirectEndpoint.class);
    private boolean allowMultipleConsumers = true;
    private final CopyOnWriteArrayList<DefaultConsumer<E>> consumers = new CopyOnWriteArrayList<DefaultConsumer<E>>();
    public DirectEndpoint(String uri, DirectComponent<E> component) {
        super(uri, component);
    }
    public DirectEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer createProducer() throws Exception {
        return new DirectProducer<E>(this);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        return new DefaultConsumer<E>(this, processor) {
            @Override
            public void start() throws Exception {
                if (!allowMultipleConsumers && !consumers.isEmpty()) {
                    throw new IllegalStateException(""Endpoint "" + getEndpointUri() + "" only allows 1 active consumer but you attempted to start a 2nd consumer."");
                }
                consumers.add(this);
                super.start();
            }
            @Override
            public void stop() throws Exception {
                super.stop();
                consumers.remove(this);
            }
        };
    }
    public boolean isAllowMultipleConsumers() {
        return allowMultipleConsumers;
    }
    public void setAllowMultipleConsumers(boolean allowMutlipleConsumers) {
        this.allowMultipleConsumers = allowMutlipleConsumers;
    }
    public boolean isSingleton() {
        return true;
    }
    public List<DefaultConsumer<E>> getConsumers() {
        return consumers;
    }
}
"
org.apache.camel.component.xquery.XQuery,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
/**
 * An annotation for injection of an XQuery expressions into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""xquery"", factory = XQueryAnnotationExpressionFactory.class)
public @interface XQuery {
    String value();
    NamespacePrefix[] namespaces() default {
    @NamespacePrefix(prefix = ""soap"", uri = ""http://www.w3.org/2003/05/soap-envelope""),
    @NamespacePrefix(prefix = ""xsd"", uri = ""http://www.w3.org/2001/XMLSchema"")};
}
"
org.apache.camel.builder.NoErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * A builder to disable the use of an error handler so that any exceptions are thrown.
 * This not recommended in general, the
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a> should be used
 * if you are unsure; however it can be useful sometimes to disable an error handler inside a complex route
 * so that exceptions bubble up to the parent {@link Processor}
 *
 * @version $Revision$
 */
public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    public ErrorHandlerBuilder copy() {
        return this;
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) {
        return processor;
    }
}
"
org.apache.camel.component.mina.MinaPayloadHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.Exchange;
/**
 * Helper to get and set the correct payload when transfering data using camel-mina.
 * Always use this helper instead of direct access on the exchange object.
 * <p/>
 * This helper ensures that we can also transfer exchange objects over the wire using the
 * <tt>exchangePayload=true</tt> option.
 *
 * @see org.apache.camel.component.mina.MinaPayloadHolder
 * @version $Revision$
 */
public final class MinaPayloadHelper {
    private MinaPayloadHelper() {
        //Utility Class
    }
    public static Object getIn(MinaEndpoint endpoint, Exchange exchange) {
        if (endpoint.isTransferExchange()) {
            // we should transfer the entire exchange over the wire (includes in/out)
            return MinaPayloadHolder.marshal(exchange);
        } else {
            // normal transfer using the body only
            return exchange.getIn().getBody();
        }
    }
    public static Object getOut(MinaEndpoint endpoint, Exchange exchange) {
        if (endpoint.isTransferExchange()) {
            // we should transfer the entire exchange over the wire (includes in/out)
            return MinaPayloadHolder.marshal(exchange);
        } else {
            // normal transfer using the body only
            return exchange.getOut().getBody();
        }
    }
    public static void setIn(Exchange exchange, Object payload) {
        if (payload instanceof MinaPayloadHolder) {
            MinaPayloadHolder.unmarshal(exchange, (MinaPayloadHolder) payload);
        } else {
            // normal transfer using the body only
            exchange.getIn().setBody(payload);
        }
    }
    public static void setOut(Exchange exchange, Object payload) {
        if (payload instanceof MinaPayloadHolder) {
            MinaPayloadHolder.unmarshal(exchange, (MinaPayloadHolder) payload);
        } else {
            // normal transfer using the body only and preserve the headers
            exchange.getOut().setHeaders(exchange.getIn().getHeaders());
            exchange.getOut().setBody(payload);
        }
    }
}
"
org.apache.camel.ProducerTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
/**
 * Template (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link Message} instances in an
 * {@link Exchange} to an {@link Endpoint}.
 * <p/>
 * <b>All</b> methods throws {@link RuntimeCamelException} if processing of
 * the {@link Exchange} failed and an Exception occured. The <tt>getCause</tt>
 * method on {@link RuntimeCamelException} returns the wrapper original caused
 * exception.
 * <p/>
 * All the send<b>Body</b> methods will return the content according to this strategy
 * <ul>
 *   <li>throws {@link RuntimeCamelException} as stated above</li>
 *   <li>The <tt>fault.body</tt> if there is a fault message set and its not <tt>null</tt></li>
 *   <li>Either <tt>IN</tt> or <tt>OUT</tt> body according to the message exchange pattern. If the pattern is
 *   Out capable then the <tt>OUT</tt> body is returned, otherwise <tt>IN</tt>.
 * </ul>
 * <p/>
 * <b>Important note on usage:</b> See this
 * <a href=""http://activemq.apache.org/camel/why-does-camel-use-too-many-threads-with-producertemplate.html"">FAQ entry</a>
 * before using.
 *
 * @version $Revision$
 */
public interface ProducerTemplate<E extends Exchange> extends Service {
    /**
     * Sends the exchange to the default endpoint
     *
     * @param exchange the exchange to send
     * @return the returned exchange
     */
    E send(E exchange);
    /**
     * Sends an exchange to the default endpoint using a supplied processor
     *
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     * @return the returned exchange
     */
    E send(Processor processor);
    /**
     * Sends the body to the default endpoint and returns the result content
     *
     * @param body the payload to send
     * @return the result (see class javadoc)
     */
    Object sendBody(Object body);
    /**
     * Sends the body to the default endpoint with a specified header and header
     * value
     *
     * @param body        the payload to send
     * @param header      the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeader(Object body, String header, Object headerValue);
    /**
     * Sends the body to the default endpoint with the specified headers and
     * header values
     *
     * @param body the payload to send
     * @param headers      the headers
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeaders(Object body, Map<String, Object> headers);
    // Allow sending to arbitrary endpoints
    // -----------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param exchange    the exchange to send
     * @return the returned exchange
     */
    E send(String endpointUri, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     * @return the returned exchange
     */
    E send(String endpointUri, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param pattern     the message {@link ExchangePattern} such as
     *                    {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     * @return the returned exchange
     */
    E send(String endpointUri, ExchangePattern pattern, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange.
     * @param callback    the callback will be called when the exchange is completed.
     * @return the returned exchange
     */
    E send(String endpointUri, Processor processor, AsyncCallback callback);
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     * @return the returned exchange
     */
    E send(Endpoint<E> endpoint, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     * @return the returned exchange
     */
    E send(Endpoint<E> endpoint, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param pattern   the message {@link ExchangePattern} such as
     *                  {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     * @return the returned exchange
     */
    E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange.
     * @param callback  the callback will be called when the exchange is completed.
     * @return the returned exchange
     */
    E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint   the endpoint to send the exchange to
     * @param body       the payload
     * @return the result (see class javadoc)
     */
    Object sendBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpointUri   the endpoint URI to send the exchange to
     * @param body          the payload
     * @return the result (see class javadoc)
     */
    Object sendBody(String endpointUri, Object body);
    /**
     * Send the body to an endpoint with the given {@link ExchangePattern}
     * returning any result output body
     *
     * @param endpoint      the endpoint to send the exchange to
     * @param body          the payload
     * @param pattern       the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @return the result (see class javadoc)
     */
    Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpointUri   the endpoint URI to send the exchange to
     * @param pattern       the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body          the payload
     * @return the result (see class javadoc)
     */
    Object sendBody(String endpointUri, ExchangePattern pattern, Object body);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload to send
     * @param header the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeader(String endpointUri, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param body the payload to send
     * @param header the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeader(Endpoint<E> endpoint, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload to send
     * @param header the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeader(Endpoint<E> endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload to send
     * @param header the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpoint the endpoint URI to send to
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeaders(Endpoint<E> endpoint, Object body, Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpointUri the endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeaders(String endpointUri, ExchangePattern pattern, Object body,
                              Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpoint the endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object sendBodyAndHeaders(Endpoint<E> endpoint, ExchangePattern pattern, Object body,
                              Map<String, Object> headers);
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    /**
     * Sends an exchange to an endpoint using a supplied processor
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint  the Endpoint to send to
     * @param processor the processor which will populate the exchange before sending
     * @return the result (see class javadoc)
     */
    E request(Endpoint<E> endpoint, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param processor the processor which will populate the exchange before sending
     * @return the result (see class javadoc)
     */
    Exchange request(String endpointUri, Processor processor);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint the Endpoint to send to
     * @param body     the payload
     * @return the result (see class javadoc)
     */
    Object requestBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload
     * @return the result (see class javadoc)
     */
    Object requestBody(String endpointUri, Object body);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint    the Endpoint to send to
     * @param body        the payload
     * @param header      the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload
     * @param header      the header name
     * @param headerValue the header value
     * @return the result (see class javadoc)
     */
    Object requestBodyAndHeader(String endpointUri, Object body, String header, Object headerValue);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object requestBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint the endpoint URI to send to
     * @param body the payload to send
     * @param headers headers
     * @return the result (see class javadoc)
     */
    Object requestBodyAndHeaders(Endpoint<E> endpoint, Object body, Map<String, Object> headers);
}
"
org.apache.camel.component.cxf.CxfSoapConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.OutputStream;
import javax.xml.transform.Source;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.component.cxf.util.NullConduit;
import org.apache.camel.component.cxf.util.NullDestinationFactory;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.Bus;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.interceptor.InterceptorChain;
import org.apache.cxf.interceptor.OutgoingChainInterceptor;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.transport.MessageObserver;
/**
 * A CXF based SOAP consumer (client).
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapConsumer implements Consumer {
    private static final Log LOG = LogFactory.getLog(CxfSoapConsumer.class);
    private final CxfSoapEndpoint endpoint;
    private final Consumer consumer;
    private MessageObserver inMessageObserver;
    private Server server;
    public CxfSoapConsumer(CxfSoapEndpoint endpoint, Processor processor) throws Exception {
        this.endpoint = endpoint;
        Processor soapProcessor = new AsyncProcessorDecorator(processor,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerOut(exchange);
                    }
                });
        this.consumer = endpoint.getInnerEndpoint().createConsumer(soapProcessor);
        Class sei = null; 
        if (ObjectHelper.isNotEmpty(endpoint.getServiceClass())) {
            sei = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
        }
        ServerFactoryBean sfb = CxfEndpointUtils.getServerFactoryBean(sei);
        sfb.setWsdlURL(endpoint.getWsdl().getURL().toString());
        if (endpoint.getServiceName() != null) {
            sfb.setServiceName(endpoint.getServiceName());
        }
        if (endpoint.getEndpointName() != null) {
            sfb.setEndpointName(endpoint.getEndpointName());
        }
        // we do not need use the destination here
        sfb.setDestinationFactory(new NullDestinationFactory());
        sfb.setStart(false);
        server = sfb.create();
    }
    public void start() throws Exception {
        server.start();
        inMessageObserver = server.getDestination().getMessageObserver();
        consumer.start();
    }
    public void stop() throws Exception {
        server.stop();
        consumer.stop();
    }
    protected Bus getBus() {
        return endpoint.getBus();
    }
    protected void processSoapConsumerIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerIn: "" + exchange);
        org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(
                endpoint.getHeaderFilterStrategy(), exchange, false);
        org.apache.cxf.message.Exchange cxfExchange = inMessage.getExchange();
        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, server.getEndpoint());
        cxfExchange.put(Bus.class, getBus());
        cxfExchange.setConduit(new NullConduit());
        // get the message input stream, deal with the exchange in message
        inMessageObserver.onMessage(inMessage);
        exchange.getIn().setBody(inMessage.getContent(Source.class));
        //TODO copy the right header information
        exchange.getIn().setHeaders(inMessage);
    }
    protected void processSoapConsumerOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerOut: "" + exchange);
        // TODO check if the message is one-way message
        // Get the method name from the soap endpoint
        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(
                endpoint.getHeaderFilterStrategy(), exchange, false);
        org.apache.cxf.message.Exchange cxfExchange = outMessage.getExchange();
        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);
        outMessage.setInterceptorChain(chain);
        chain.doIntercept(outMessage);
        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
        exchange.getOut().setBody(outputStream.getInputStream());
    }
}
"
org.apache.camel.converter.xmlbeans.XmlBeansDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.xmlbeans;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
import org.apache.xmlbeans.XmlObject;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using XmlBeans to marshal to and from XML
 *
 * @version $Revision$
 */
public class XmlBeansDataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object body, OutputStream stream) throws Exception {
        XmlObject object = ExchangeHelper.convertToMandatoryType(exchange, XmlObject.class, body);
        object.save(stream);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        return XmlObject.Factory.parse(stream);
    }
}
"
org.apache.camel.component.file.FileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.language.simple.FileLanguage;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For producing files.
 *
 * @version $Revision$
 */
public class FileProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(FileProducer.class);
    private FileEndpoint endpoint;
    public FileProducer(FileEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    /**
     * @deprecated will be removed in Camel 2.0.
     */
    public FileEndpoint getEndpoint() {
        return endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        FileExchange fileExchange = endpoint.createExchange(exchange);
        process(fileExchange);
        ExchangeHelper.copyResults(exchange, fileExchange);
    }
    public void process(FileExchange exchange) throws Exception {
        boolean fileSource = exchange.getIn().getBody() instanceof File;
        File target = createFileName(exchange.getIn());
        buildDirectory(target);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to write to: "" + target + "" from exchange: "" + exchange);
        }
        if (fileSource) {
            File source = ExchangeHelper.getMandatoryInBody(exchange, File.class);
            writeFileByFile(source, target);
        } else {
            InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
            writeFileByStream(in, target);
        }
    }
    private void writeFileByFile(File source, File target) throws IOException {
        FileChannel in = new FileInputStream(source).getChannel();
        FileChannel out = null;
        try {
            out = prepareOutputFileChannel(target, out);
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Using FileChannel to transfer from: "" + in + "" to: "" + out);
            }
            in.transferTo(0, in.size(), out);
        } finally {
            ObjectHelper.close(in, source.getName(), LOG);
            ObjectHelper.close(out, source.getName(), LOG);
        }
    }
    private void writeFileByStream(InputStream in, File target) throws IOException {
        FileChannel out = null;
        try {
            out = prepareOutputFileChannel(target, out);
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Using InputStream to transfer from: "" + in + "" to: "" + out);
            }
            int size = endpoint.getBufferSize();
            byte[] buffer = new byte[size];
            ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
            while (true) {
                int count = in.read(buffer);
                if (count <= 0) {
                    break;
                } else if (count < size) {
                    byteBuffer = ByteBuffer.wrap(buffer, 0, count);
                    out.write(byteBuffer);
                    break;
                } else {
                    out.write(byteBuffer);
                    byteBuffer.clear();
                }
            }
        } finally {
            ObjectHelper.close(in, target.getName(), LOG);
            ObjectHelper.close(out, target.getName(), LOG);
        }
    }
    /**
     * Creates and prepares the output file channel. Will position itself in correct position if eg. it should append
     * or override any existing content.
     */
    private FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {
        if (endpoint.isAppend()) {
            out = new RandomAccessFile(target, ""rw"").getChannel();
            out = out.position(out.size());
        } else {
            out = new FileOutputStream(target).getChannel();
        }
        return out;
    }
    protected File createFileName(Message message) {
        File answer;
        String name = null;
        if (!endpoint.isIgnoreFileNameHeader()) {
            name = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        }
        // expression support
        Expression expression = endpoint.getExpression();
        if (name != null) {
            // the header name can be an expression too, that should override whatever configured on the endpoint
            if (name.indexOf(""${"") > -1) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(FileComponent.HEADER_FILE_NAME + "" contains a FileLanguage expression: "" + name);
                }
                expression = FileLanguage.file(name);
            }
        }
        if (expression != null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Filename evaluated as expression: "" + expression);
            }
            Object result = expression.evaluate(message.getExchange());
            name = message.getExchange().getContext().getTypeConverter().convertTo(String.class, result);
        }
        File endpointFile = endpoint.getFile();
        if (endpointFile.isDirectory()) {
            if (name != null) {
                answer = new File(endpointFile, name);
                if (answer.isDirectory()) {
                    answer = new File(answer, endpoint.getGeneratedFileName(message));
                }
            } else {
                answer = new File(endpointFile, endpoint.getGeneratedFileName(message));
            }
        } else {
            if (name == null) {
                answer = endpointFile;
            } else {
                answer = new File(endpointFile, name);
            }
        }
        // lets store the name we really used in the header, so end-users can retrieve it
        message.setHeader(FileComponent.HEADER_FILE_NAME_PRODUCED, answer.getAbsolutePath());
        return answer;
    }
    private void buildDirectory(File file) {
        String dirName = file.getAbsolutePath();
        int index = dirName.lastIndexOf(File.separatorChar);
        if (index > 0) {
            dirName = dirName.substring(0, index);
            File dir = new File(dirName);
            dir.mkdirs();
        }
    }
}
"
org.apache.camel.component.jhc.AsyncHttpRequestHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpRequestHandler;
public interface AsyncHttpRequestHandler extends HttpRequestHandler {
    void handle(HttpRequest request, HttpContext context, AsyncResponseHandler handler) throws HttpException,
        IOException;
}
"
org.apache.camel.component.bean.DefaultParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.builder.ExpressionBuilder;
/**
 * Represents the strategy used to figure out how to map a message exchange to a POJO method invocation
 *
 * @version $Revision$
 */
public class DefaultParameterMappingStrategy implements ParameterMappingStrategy {
    private Map<Class, Expression> parameterTypeToExpressionMap = new ConcurrentHashMap<Class, Expression>();
    public DefaultParameterMappingStrategy() {
        loadDefaultRegistry();
    }
    public synchronized Expression getDefaultParameterTypeExpression(Class parameterType) {
        Expression expression = parameterTypeToExpressionMap.get(parameterType);
        return expression;
    }
    /**
     * Adds a default parameter type mapping to an expression
     */
    public synchronized void addParameterMapping(Class parameterType, Expression expression) {
        parameterTypeToExpressionMap.put(parameterType, expression);
    }
    /**
     * Creates an invocation on the given POJO using annotations to decide which method to invoke
     * and to figure out which parameters to use
     */
/*
    public MethodInvocation createInvocation(Object pojo,
                                             BeanInfo beanInfo,
                                             Exchange messageExchange,
                                             Endpoint pojoEndpoint) throws RuntimeCamelException {
        return beanInfo.createInvocation(pojo, messageExchange);
    }
*/
    public void loadDefaultRegistry() {
        addParameterMapping(Exchange.class, ExpressionBuilder.exchangeExpression());
        addParameterMapping(Message.class, ExpressionBuilder.inMessageExpression());
    }
}
"
org.apache.camel.CamelExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception caused by a specific message {@link Exchange}
 *
 * @version $Revision$
 */
public class CamelExchangeException extends CamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public CamelExchangeException(String message, Exchange exchange) {
        super(createMessage(message, exchange));
        this.exchange = exchange;
    }
    public CamelExchangeException(String message, Exchange exchange, Throwable cause) {
        super(createMessage(message, exchange), cause);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
    protected static String createMessage(String message, Exchange exchange) {
        return message + "" on the exchange: "" + exchange;
    }
}
"
org.apache.camel.component.xquery.XQueryComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery Component</a>
 * for performing transforming messages
 *
 * @version $Revision$
 */
public class XQueryComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Resource resource = resolveMandatoryResource(remaining);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        XQueryBuilder xslt = XQueryBuilder.xquery(resource.getURL());
        configureXslt(xslt, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, xslt);
    }
    protected void configureXslt(XQueryBuilder xQueryBuilder, String uri, String remaining, Map parameters) throws Exception {
        setProperties(xQueryBuilder, parameters);
    }
}
"
org.apache.camel.spring.handler.LazyLoadingBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link BeanDefinitionParser} which lazy loads the type on which it creates to allow the schema to be loosly coupled
 * with the camel jars.
 *
 * @version $Revision$
 */
public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser {
    private String className;
    private String moduleName;
    public LazyLoadingBeanDefinitionParser(String className, String moduleName) {
        this.className = className;
        this.moduleName = moduleName;
    }
    @Override
    protected Class loadType() {
        Class<?> answer = ObjectHelper.loadClass(className, getClass().getClassLoader());
        if (answer == null) {
            throw new IllegalArgumentException(""Class: "" + className + "" could not be found. You need to add Camel module: "" + moduleName + "" to your classpath"");
        }
        return answer;
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClient,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.transport.MessageObserver;
/**
 * Just deal with the PayLoadMessage and RawMessage
 *
 */
public class CxfClient extends ClientImpl {
    private static final Logger LOG = LogUtils.getL7dLogger(CxfClient.class);
    public CxfClient(Bus b, Endpoint e) {
        super(b, e);
    }
    public Object dispatch(Map<Class, Object> params,
                           Map<String, Object> context,
                           Exchange exchange) throws Exception {
        Object retval = null;
        InvokingContext invokingContext = exchange.get(InvokingContext.class);
        ObjectHelper.notNull(invokingContext, ""invokingContext"");
        // get InBound binding operation info from the exchange object
        BindingOperationInfo inBoundOp = exchange.get(BindingOperationInfo.class);
        BindingOperationInfo outBoundOp = null;
        if (inBoundOp != null) {
            //Get the BindingOperationInfo for the outbound binding.
            BindingInfo bi = getEndpoint().getEndpointInfo().getBinding();
            outBoundOp = bi.getOperation(inBoundOp.getOperationInfo().getName());
            if (outBoundOp != null
                && inBoundOp.isUnwrapped()) {
                outBoundOp = outBoundOp.getUnwrappedOperation();
            }
        }
        retval = invokeWithMessageStream(outBoundOp, params, context, invokingContext);
        return retval;
    }
    @SuppressWarnings(""unchecked"")
    public Object invokeWithMessageStream(BindingOperationInfo bi,
                                          Map<Class, Object> param,
                                          Map<String, Object> context,
                                          InvokingContext invokingContext) throws Exception {
        Object retval = null;
        Map<String, Object> requestContext = null;
        Map<String, Object> responseContext = null;
        if (null != context) {
            requestContext = (Map<String, Object>) context.get(REQUEST_CONTEXT);
            responseContext = (Map<String, Object>) context.get(RESPONSE_CONTEXT);
        }
        Exchange exchange = new ExchangeImpl();
        // put the message Observer to call the CxfClient onMessage()
        exchange.put(InvokingContext.class, invokingContext);
        if (bi != null) {
            //Set The InputMessage
            exchange.put(BindingMessageInfo.class, bi.getInput());
            exchange.setOneWay(bi.getOperationInfo().isOneWay());
        }
        Message message = prepareMessage(exchange, requestContext, param, invokingContext);
        // add the invocation context
        message.put(Message.INVOCATION_CONTEXT, context);
        // add the endpoint props to the message
        Endpoint ep = getEndpoint();
        // the ep should not be null , just in case if it set to be null
        if (ep != null) {
            message.putAll(ep);
        }
        setExchangeProperties(exchange, ep, bi);
        PhaseInterceptorChain chain = setupInterceptorChain(getEndpoint());
        message.setInterceptorChain(chain);
        modifyChain(chain, requestContext);
        chain.setFaultObserver(outFaultObserver);
        // setup conduit selector
        prepareConduitSelector(message);
        modifyChain(chain, null);
        // execute chain
        chain.doIntercept(message);
        //it will close all the stream in the message, so we do not call it
        //getConduitSelector().complete(exchange);
        // Check to see if there is a Fault from the outgoing chain
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Exception in outgoing chain: "" + ex.toString());
            }
            throw ex;
        }
        if (!exchange.isOneWay()) {
            synchronized (exchange) {
                waitResponse(exchange);
            }
            ex = getException(exchange);
            if (ex != null) {
                if (LOG.isLoggable(Level.FINE)) {
                    LOG.fine(""Exception in incoming chain: "" + ex.toString());
                }
                throw ex;
            }
            retval = invokingContext.getResponseObject(exchange, responseContext);
        }
        return retval;
    }
    protected void waitResponse(Exchange exchange) {
        int remaining = synchronousTimeout;
        while (!Boolean.TRUE.equals(exchange.get(FINISHED)) && remaining > 0) {
            long start = System.currentTimeMillis();
            try {
                exchange.wait(remaining);
            } catch (InterruptedException ex) {
                // ignore
            }
            long end = System.currentTimeMillis();
            remaining -= (int)(end - start);
        }
        if (!Boolean.TRUE.equals(exchange.get(FINISHED))) {
            LogUtils.log(LOG, Level.WARNING, ""RESPONSE_TIMEOUT"",
                exchange.get(OperationInfo.class).getName().toString());
        }
    }
    private Message prepareMessage(Exchange exchange, Map<String, Object> requestContext,
            Map<Class, Object> param, InvokingContext invokingContext) {
        Message message = getEndpoint().getBinding().createMessage();
        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
        message.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        // setup the message context
        if (requestContext != null) {
            message.putAll(requestContext);
        }
        if (param != null) {
            invokingContext.setRequestOutMessageContent(message, param);
        }
        if (null != requestContext) {
            exchange.putAll(requestContext);
        }
        exchange.setOutMessage(message);
        return message;
    }
}
"
org.apache.camel.component.cxf.transport.spring.CamelConduitDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.apache.camel.component.cxf.transport.CamelConduit;
public class CamelConduitDefinitionParser extends AbstractCamelContextBeanDefinitionParser {
    public CamelConduitDefinitionParser() {
        super();
        setBeanClass(CamelConduit.class);
    }
}
"
org.apache.camel.component.bean.RegistryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * An implementation of a {@link BeanHolder} which will look up a bean from the registry and act as a cache of its metadata
 *
 * @version $Revision$
 */
public class RegistryBean implements BeanHolder {
    private final CamelContext context;
    private final String name;
    private final Registry registry;
    private Processor processor;
    private BeanInfo beanInfo;
    private Object bean;
    private ParameterMappingStrategy parameterMappingStrategy;
    public RegistryBean(CamelContext context, String name) {
        this.context = context;
        this.name = name;
        this.registry = context.getRegistry();
    }
    public RegistryBean(CamelContext context, String name, ParameterMappingStrategy parameterMappingStrategy) {
        this(context, name);
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    @Override
    public String toString() {
        return ""bean: "" + name;
    }
    public ConstantBeanHolder createCacheHolder() throws Exception {
        return new ConstantBeanHolder(getBean(), getBeanInfo());
    }
    public Object getBean() throws Exception {
        Object value = lookupBean();
        if (value == null) {
            throw new NoBeanAvailableException(name);
        }
        if (value != bean) {
            bean = value;
            processor = null;
            if (!ObjectHelper.equal(ObjectHelper.type(bean), ObjectHelper.type(value))) {
                beanInfo = null;
            }
        }
        return value;
    }
    public Processor getProcessor() {
        if (processor == null && bean != null) {
            try {
                processor = CamelContextHelper.convertTo(context, Processor.class, bean);
            } catch (NoTypeConversionAvailableException ex) {
                // ignore
            }
        }
        return processor;
    }
    public BeanInfo getBeanInfo() {
        if (beanInfo == null && bean != null) {
            this.beanInfo = createBeanInfo();
        }
        return beanInfo;
    }
    public String getName() {
        return name;
    }
    public Registry getRegistry() {
        return registry;
    }
    public CamelContext getContext() {
        return context;
    }
    public ParameterMappingStrategy getParameterMappingStrategy() {
        if (parameterMappingStrategy == null) {
            parameterMappingStrategy = createParameterMappingStrategy();
        }
        return parameterMappingStrategy;
    }
    public void setParameterMappingStrategy(ParameterMappingStrategy parameterMappingStrategy) {
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected BeanInfo createBeanInfo() {
        return new BeanInfo(context, bean.getClass(), getParameterMappingStrategy());
    }
    protected ParameterMappingStrategy createParameterMappingStrategy() {
        return BeanInfo.createParameterMappingStrategy(context);
    }
    protected Object lookupBean() throws Exception {
        return registry.lookup(name);
    }
}
"
org.apache.camel.language.Constant,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject a constant expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""constant"")
public @interface Constant {
    String value();
}
"
org.apache.camel.component.mail.MailProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.internet.MimeMessage;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;
/**
 * A Producer to send messages using JavaMail.
 *  
 * @version $Revision$
 */
public class MailProducer extends DefaultProducer<MailExchange> {
    private static final transient Log LOG = LogFactory.getLog(MailProducer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSender sender;
    public MailProducer(MailEndpoint endpoint, JavaMailSender sender) {
        super(endpoint);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    public void process(final Exchange exchange) {
        sender.send(new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                endpoint.getBinding().populateMailMessage(endpoint, mimeMessage, exchange);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending MimeMessage: "" + MailUtils.dumpMessage(mimeMessage));
                }
            }
        });
    }
}
"
org.apache.camel.component.cxf.util.NullDestinationFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import org.apache.cxf.binding.AbstractBindingFactory;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
public class NullDestinationFactory implements DestinationFactory {
    public Destination getDestination(EndpointInfo ei) throws IOException {
        // setup the endpoint information
        ei.setAddress(""local://"" + ei.getService().getName().toString() + ""/"" + ei.getName().getLocalPart());
        // working as the dispatch mode, the binding factory will not add interceptor
        ei.getBinding().setProperty(AbstractBindingFactory.DATABINDING_DISABLED, Boolean.TRUE);
        // do nothing here , just creating a null destination to store the observer
        return new NullDestination();
    }
    public List<String> getTransportIds() {
        return null;
    }
    public Set<String> getUriPrefixes() {
        return null;
    }
}
"
org.apache.camel.component.cxf.CxfSoapComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">SOAP Component</a>
 *
 * @version $Revision$
 */
public class CxfSoapComponent extends DefaultComponent implements HeaderFilterStrategyAware {
    private HeaderFilterStrategy headerFilterStrategy;
    public CxfSoapComponent() {
        setHeaderFilterStrategy(new CxfHeaderFilterStrategy());
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Map soapProps = IntrospectionSupport.extractProperties(parameters, ""soap."");
        if (parameters.size() > 0) {
            remaining += ""?"" + URISupport.createQueryString(parameters);
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(getCamelContext(), remaining);
        CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint(endpoint, getHeaderFilterStrategy());
        setProperties(soapEndpoint, soapProps);
        soapEndpoint.init();
        return soapEndpoint;
    }
    @Override
    protected boolean useIntrospectionOnEndpoint() {
        return false;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.dataformat.hl7.HL7Converter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.hl7;
import ca.uhn.hl7v2.HL7Exception;
import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.parser.Parser;
import ca.uhn.hl7v2.parser.PipeParser;
import org.apache.camel.Converter;
/**
 * HL7 converters.
 */
@Converter
public final class HL7Converter {
    private HL7Converter() {
        // Helper class
    }
    @Converter
    public static String toString(Message message) throws HL7Exception {
        Parser parser = new PipeParser();
        String encoded = parser.encode(message);
        return encoded;
    }
    @Converter
    public static Message toMessage(String body) throws HL7Exception {
        // replace \n with \r as HL7 uses 0x0d = \r as segment terminators and HAPI only parses with \r
        body = body.replace('\n', '\r');
        Parser parser = new PipeParser();
        Message message = parser.parse(body);
        return message;
    }
}
"
org.apache.camel.builder.RouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.Route;
import org.apache.camel.Routes;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.InterceptType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.RoutesType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
/**
 * A <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a> which is
 * used to build {@link Route} instances in a {@link CamelContext} for smart routing.
 *
 * @version $Revision$
 */
public abstract class RouteBuilder extends BuilderSupport implements Routes {
    private AtomicBoolean initialized = new AtomicBoolean(false);
    private RoutesType routeCollection = new RoutesType();
    private List<Route> routes = new ArrayList<Route>();
    public RouteBuilder() {
        this(null);
    }
    public RouteBuilder(CamelContext context) {
        super(context);
    }
    @Override
    public String toString() {
        return routeCollection.toString();
    }
    /**
     * Called on initialization to to build the required destinationBuilders
     */
    public abstract void configure() throws Exception;
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType answer = routeCollection.from(uri);
        configureRoute(answer);
        return answer;
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType answer = routeCollection.from(endpoint);
        configureRoute(answer);
        return answer;
    }
    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for
     *                all child routes
     * @return the current builder with the error handler configured
     */
    public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     *
     * @param value the flag as to whether error handlers should be inherited or not
     * @return the current builder
     */
    public RouteBuilder inheritErrorHandler(boolean value) {
        routeCollection.setInheritErrorHandlerFlag(value);
        return this;
    }
    /**
     * Adds the given interceptor to this route
     */
    public RouteBuilder intercept(DelegateProcessor interceptor) {
        routeCollection.intercept(interceptor);
        return this;
    }
    /**
     * Adds a route for an interceptor; use the {@link ProcessorType#proceed()} method
     * to continue processing the underlying route being intercepted.
     */
    public InterceptType intercept() {
        return routeCollection.intercept();
    }
    /**
     * Applies a route for an interceptor if the given predicate is true
     * otherwise the interceptor route is not applied
     */
    public ChoiceType intercept(Predicate predicate) {
        return routeCollection.intercept(predicate);
    }
    /**
     * Adds an exception handler route for the given exception type
     */
    public ExceptionType onException(Class exceptionType) {
        return routeCollection.onException(exceptionType);
    }
    /**
     * Adds an exception handler route for the given exception types
     */
    public ExceptionType onException(Class... exceptions) {
        ExceptionType last = null;
        for (Class ex : exceptions) {
            last = last == null ? onException(ex) : last.onException(ex);
        }
        return last != null ? last : onException(Exception.class);
    }
    /**
     * Adds an exception handler route for the given exception type
     *
     * @deprecated Please use {@link #onException(Class)} instead. Will be removed in Camel 2.0.
     */
    public ExceptionType exception(Class exceptionType) {
        return onException(exceptionType);
    }    
    // Properties
    // -----------------------------------------------------------------------
    public CamelContext getContext() {
        CamelContext context = super.getContext();
        if (context == null) {
            context = createContainer();
            setContext(context);
        }
        return context;
    }
    /**
     * Uses {@link org.apache.camel.CamelContext#getRoutes()} to return the routes in the context.
     */
    public List<Route> getRouteList() throws Exception {
        checkInitialized();
        return routes;
    }
    @Override
    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        super.setInheritErrorHandler(inheritErrorHandler);
        routeCollection.setInheritErrorHandlerFlag(inheritErrorHandler);
    }
    @Override
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        super.setErrorHandlerBuilder(errorHandlerBuilder);
        routeCollection.setErrorHandlerBuilder(getErrorHandlerBuilder());
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void checkInitialized() throws Exception {
        if (initialized.compareAndSet(false, true)) {
            // Set the CamelContext ErrorHandler here
            CamelContext camelContext = getContext();
            if (camelContext.getErrorHandlerBuilder() != null) {
                setErrorHandlerBuilder(camelContext.getErrorHandlerBuilder());
            }
            configure();
            populateRoutes(routes);
        }
    }
    protected void populateRoutes(List<Route> routes) throws Exception {
        CamelContext camelContext = getContext();
        if (camelContext == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        routeCollection.setCamelContext(camelContext);
        camelContext.addRouteDefinitions(routeCollection.getRoutes());
    }
    public void setRouteCollection(RoutesType routeCollection) {
        this.routeCollection = routeCollection;
    }
    public RoutesType getRouteCollection() {
        return this.routeCollection;
    }
    /**
     * Completely disable stream caching for all routes being defined in the same RouteBuilder after this.
     */
    public void noStreamCaching() {
        StreamCachingInterceptor.noStreamCaching(routeCollection.getInterceptors());
    }
    /**
     * Enable stream caching for all routes being defined in the same RouteBuilder after this call.
     */
    public void streamCaching() {
        routeCollection.intercept(new StreamCachingInterceptor());
    }
    /**
     * Factory method
     */
    protected CamelContext createContainer() {
        return new DefaultCamelContext();
    }
    protected void configureRoute(RouteType route) {
        route.setGroup(getClass().getName());
    }
    protected void addRoutes(Routes routes) throws Exception {
        getContext().addRoutes(routes);
    }
}
"
org.apache.camel.component.jpa.JpaProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Iterator;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultProducer;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public class JpaProducer extends DefaultProducer<Exchange> {
    private final TransactionStrategy template;
    private final JpaEndpoint endpoint;
    private final Expression<Exchange> expression;
    public JpaProducer(JpaEndpoint endpoint, Expression<Exchange> expression) {
        super(endpoint);
        this.endpoint = endpoint;
        this.expression = expression;
        this.template = endpoint.createTransactionStrategy();
    }
    public void process(Exchange exchange) {
        final Object values = expression.evaluate(exchange);
        if (values != null) {
            template.execute(new JpaCallback() {
                public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                    Iterator iter = ObjectConverter.iterator(values);
                    while (iter.hasNext()) {
                        Object value = iter.next();
                        entityManager.persist(value);
                    }
                    if (endpoint.isFlushOnSend()) {
                        entityManager.flush();
                    }
                    return null;
                }
            });
        }
        exchange.setProperty(""CamelJpaValue"", values);
    }
}
"
org.apache.camel.component.stream.StreamMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import org.apache.camel.impl.DefaultMessage;
/**
 * @deprecated Camel Stream uses a DefaultMessage to contain the body. Will be removed in Camel 2.0
 */
public class StreamMessage extends DefaultMessage {
    private Object o;
    public StreamMessage(Object o) {
        this.o = o;
    }
    @Override
    protected Object createBody() {
        return o;
    }
    @Override
    public Object getBody() {
        return o;
    }
    @Override
    public String toString() {
        return o.toString();
    }
}
"
org.apache.camel.component.mail.MailConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import org.apache.camel.RuntimeCamelException;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * Represents the configuration data for communicating over email
 *
 * @version $Revision$
 */
public class MailConfiguration implements Cloneable {
    public static final String DEFAULT_FOLDER_NAME = ""INBOX"";
    public static final String DEFAULT_FROM = ""camel@localhost"";
    public static final long DEFAULT_CONNECTION_TIMEOUT = 30000L;
    private Properties javaMailProperties;
    private String protocol;
    private String host;
    private int port = -1;
    private String username;
    private String password;
    private Session session;
    private String defaultEncoding;
    private String from = DEFAULT_FROM;
    private String folderName = DEFAULT_FOLDER_NAME;
    private boolean deleteProcessedMessages;
    private boolean ignoreUriScheme;
    private boolean processOnlyUnseenMessages = true;
    private Map<Message.RecipientType, String> recipients = new HashMap<Message.RecipientType, String>();
    private String destination;
    private int fetchSize = -1;
    private boolean debugMode;
    private long connectionTimeout = DEFAULT_CONNECTION_TIMEOUT;
    private boolean dummyTrustManager;
    private String contentType = ""text/plain"";
    public MailConfiguration() {
    }
    /**
     * Returns a copy of this configuration
     */
    public MailConfiguration copy() {
        try {
            return (MailConfiguration) clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void configure(URI uri) {
        String value = uri.getHost();
        if (value != null) {
            setHost(value);
        }
        if (!isIgnoreUriScheme()) {
            String scheme = uri.getScheme();
            if (scheme != null) {
                setProtocol(scheme);
            }
        }
        String userInfo = uri.getUserInfo();
        if (userInfo != null) {
            setUsername(userInfo);
        }
        int port = uri.getPort();
        if (port > 0) {
            setPort(port);
        } else if (port <= 0 && this.port <= 0) {
            // resolve default port if no port number was provided, and not already configured with a port number
            setPort(MailUtils.getDefaultPortForProtocol(uri.getScheme()));
        }
    }
    protected JavaMailSenderImpl createJavaMailSender() {
        JavaMailSenderImpl answer = new JavaMailSenderImpl();
        // sets the debug mode of the underlying mail framework
        answer.getSession().setDebug(debugMode);
        if (javaMailProperties != null) {
            answer.setJavaMailProperties(javaMailProperties);
        } else {
            // set default properties if none provided
            answer.setJavaMailProperties(createJavaMailProperties());
        }
        if (defaultEncoding != null) {
            answer.setDefaultEncoding(defaultEncoding);
        }
        if (host != null) {
            answer.setHost(host);
        }
        if (port >= 0) {
            answer.setPort(port);
        }
        if (password != null) {
            answer.setPassword(password);
        }
        if (protocol != null) {
            answer.setProtocol(protocol);
        }
        if (session != null) {
            answer.setSession(session);
        } else {
            // use our authenticator that does no live user interaction but returns the already configured username and password
            Session session = Session.getDefaultInstance(answer.getJavaMailProperties(), getAuthenticator());
            answer.setSession(session);
        }
        if (username != null) {
            answer.setUsername(username);
        }
        return answer;
    }
    private Properties createJavaMailProperties() {
        // clone the system properties and set the java mail properties
        Properties properties = (Properties)System.getProperties().clone();
        properties.put(""mail."" + protocol + "".connectiontimeout"", connectionTimeout);
        properties.put(""mail."" + protocol + "".timeout"", connectionTimeout);
        properties.put(""mail."" + protocol + "".host"", host);
        properties.put(""mail."" + protocol + "".port"", """" + port);
        if (username != null) {
            properties.put(""mail."" + protocol + "".user"", username);
            properties.put(""mail.user"", username);
            properties.put(""mail."" + protocol + "".auth"", ""true"");
        } else {
            properties.put(""mail."" + protocol + "".auth"", ""false"");
        }
        properties.put(""mail."" + protocol + "".rsetbeforequit"", ""true"");
        properties.put(""mail.transport.protocol"", protocol);
        properties.put(""mail.store.protocol"", protocol);
        properties.put(""mail.host"", host);
        if (debugMode) {
            // add more debug for the SSL communication as well
            properties.put(""javax.net.debug"", ""all"");
        }
        if (dummyTrustManager && isSecureProtocol()) {
            // set the custom SSL properties
            properties.put(""mail."" + protocol + "".socketFactory.class"", ""org.apache.camel.component.mail.security.DummySSLSocketFactory"");
            properties.put(""mail."" + protocol + "".socketFactory.fallback"", ""false"");
            properties.put(""mail."" + protocol + "".socketFactory.port"", """" + port);
        }
        return properties;
    }
    /**
     * Is the used protocol to be secure or not
     */
    public boolean isSecureProtocol() {
        return this.protocol.equalsIgnoreCase(""smtps"") || this.protocol.equalsIgnoreCase(""pop3s"")
               || this.protocol.equalsIgnoreCase(""imaps"");
    }
    /**
     * Returns an authenticator object for use in sessions
     */
    public Authenticator getAuthenticator() {
        return new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(getUsername(), getPassword());
            }
        };
    }
    public String getMailStoreLogInformation() {
        String ssl = """";
        if (isSecureProtocol()) {
            ssl = ""(SSL enabled"" + (dummyTrustManager ? "" using DummyTrustManager)"" : "")"");
        }
        return protocol + ""//"" + host + "":"" + port + ssl + "", folder="" + folderName;
    }
    // Properties
    // -------------------------------------------------------------------------
    public String getDefaultEncoding() {
        return defaultEncoding;
    }
    public void setDefaultEncoding(String defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public Properties getJavaMailProperties() {
        return javaMailProperties;
    }
    public void setJavaMailProperties(Properties javaMailProperties) {
        this.javaMailProperties = javaMailProperties;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public Session getSession() {
        return session;
    }
    public void setSession(Session session) {
        this.session = session;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
        if (destination == null) {
            // set default destination to username@host for backwards compatibility
            // can be overridden by URI parameters
            String address = username;
            if (address.indexOf(""@"") == -1) {
                address += ""@"" + host;
            }
            destination = address;
        }
    }
    /**
     * Gets the destination (recipient <tt>To</tt> email address).
     *
     * @deprecated use {@link #getRecipients()}
     */
    public String getDestination() {
        return destination;
    }
    /**
     * Sets the destination (recipient <tt>To</tt> email address).
     *
     * @deprecated use {@link #setTo(String)}
     */
    public void setDestination(String destination) {
        this.destination = destination;
    }
    public String getFrom() {
        return from;
    }
    public void setFrom(String from) {
        this.from = from;
    }
    public boolean isDeleteProcessedMessages() {
        return deleteProcessedMessages;
    }
    public void setDeleteProcessedMessages(boolean deleteProcessedMessages) {
        this.deleteProcessedMessages = deleteProcessedMessages;
    }
    public String getFolderName() {
        return folderName;
    }
    public void setFolderName(String folderName) {
        this.folderName = folderName;
    }
    public boolean isIgnoreUriScheme() {
        return ignoreUriScheme;
    }
    public void setIgnoreUriScheme(boolean ignoreUriScheme) {
        this.ignoreUriScheme = ignoreUriScheme;
    }
    public boolean isProcessOnlyUnseenMessages() {
        return processOnlyUnseenMessages;
    }
    public void setProcessOnlyUnseenMessages(boolean processOnlyUnseenMessages) {
        this.processOnlyUnseenMessages = processOnlyUnseenMessages;
    }
    /**
     * Sets the <tt>To</tt> email address. Separate multiple email addresses with comma.
     */
    public void setTo(String address) {
        recipients.put(Message.RecipientType.TO, address);
    }
    /**
     * Sets the <tt>CC</tt> email address. Separate multiple email addresses with comma.
     */
    public void setCC(String address) {
        recipients.put(Message.RecipientType.CC, address);
    }
    /**
     * Sets the <tt>BCC</tt> email address. Separate multiple email addresses with comma.
     */
    public void setBCC(String address) {
        recipients.put(Message.RecipientType.BCC, address);
    }
    public Map<Message.RecipientType, String> getRecipients() {
        return recipients;
    }
    public int getFetchSize() {
        return fetchSize;
    }
    public void setFetchSize(int fetchSize) {
        this.fetchSize = fetchSize;
    }
    public boolean isDebugMode() {
        return debugMode;
    }
    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }
    public long getConnectionTimeout() {
        return connectionTimeout;
    }
    public void setConnectionTimeout(long connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }
    public boolean isDummyTrustManager() {
        return dummyTrustManager;
    }
    public void setDummyTrustManager(boolean dummyTrustManager) {
        this.dummyTrustManager = dummyTrustManager;
    }
    public String getContentType() {
        return contentType;
    }
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
}
"
org.apache.camel.component.jms.JmsTemporaryQueueEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 * for working with a {@link TemporaryQueue}
 *
 * @version $Revision$
 */
// TODO need to be really careful to always use the same Connection otherwise the destination goes stale
public class JmsTemporaryQueueEndpoint extends JmsQueueEndpoint implements DestinationEndpoint {
    private Destination jmsDestination;
    public JmsTemporaryQueueEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration) {
        super(uri, component, destination, configuration);
    }
    public JmsTemporaryQueueEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration, QueueBrowseStrategy queueBrowseStrategy) {
        super(uri, component, destination, configuration, queueBrowseStrategy);
    }
    public JmsTemporaryQueueEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination);
    }
    /**
     * This endpoint is a singleton so that the temporary destination instances are shared across all
     * producers and consumers of the same endpoint URI
     *
     * @return true
     */
    public boolean isSingleton() {
        return true;
    }
    public synchronized Destination getJmsDestination(Session session) throws JMSException {
        if (jmsDestination == null) {
            jmsDestination = createJmsDestination(session);
        }
        return jmsDestination;
    }
    protected Destination createJmsDestination(Session session) throws JMSException {
        return session.createTemporaryQueue();
    }
}
"
org.apache.camel.component.mina.MinaHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
import org.apache.mina.common.IoSession;
import org.apache.mina.common.WriteFuture;
/**
 * Helper class used internally by camel-mina using Apache MINA.
 */
public final class MinaHelper {
    private MinaHelper() {
        //Utility Class
    }
    /**
     * Writes the given body to MINA session. Will wait until the body has been written.
     *
     * @param session   the MINA session
     * @param body      the body to write (send)
     * @param exchange  the mina exchange used for error reporting
     * @throws CamelExchangeException is thrown if the body could not be written for some reasons
     *                                (eg remote connection is closed etc.)
     */
    public static void writeBody(IoSession session, Object body, Exchange exchange) throws CamelExchangeException {
        // the write operation is asynchronous. Use WriteFuture to wait until the session has been written
        WriteFuture future = session.write(body);
        future.join();
        if (!future.isWritten()) {
            throw new CamelExchangeException(""Could not write body"", exchange);
        }
    }
}
"
org.apache.camel.FailedToCreateProducerException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if Camel failed to create a producer for a given endpoint.
 *
 * @version $Revision$
 */
public class FailedToCreateProducerException extends RuntimeCamelException {
    private final Endpoint endpoint;
    public FailedToCreateProducerException(Endpoint endpoint, Throwable cause) {
        super(""Failed to create Producer for endpoint: "" + endpoint + "". Reason: "" + cause, cause);
        this.endpoint = endpoint;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.TypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A pluggable strategy to be able to convert objects <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">to different
 * types</a> such as to and from String, InputStream/OutputStream,
 * Reader/Writer, Document, byte[], ByteBuffer etc
 * 
 * @version $Revision$
 */
public interface TypeConverter {
    /**
     * Converts the value to the specified type
     * 
     * @param type the requested type
     * @param value the value to be converted
     * @return the converted value
     * @throws {@link NoTypeConversionAvailableException} if conversion not possible
     */
    <T> T convertTo(Class<T> type, Object value);
    /**
     * Converts the value to the specified type in the context of an exchange
     * <p/>
     * Used when conversion requires extra information from the current
     * exchange (such as encoding).
     *
     * @param type the requested type
     * @param exchange the current exchange
     * @param value the value to be converted
     * @return the converted value
     * @throws {@link NoTypeConversionAvailableException} if conversion not possible
     */
    <T> T convertTo(Class<T> type, Exchange exchange, Object value);
}
"
org.apache.camel.impl.converter.StaticMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which invokes a static method to convert from a type to another type
 *
 * @version $Revision$
 */
public class StaticMethodTypeConverter implements TypeConverter {
    private final Method method;
    private final boolean useExchange;
    public StaticMethodTypeConverter(Method method) {
        this.method = method;
        this.useExchange = method.getParameterTypes().length == 2;
    }
    @Override
    public String toString() {
        return ""StaticMethodTypeConverter: "" + method;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        return convertTo(type, null, value);
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        return useExchange ? (T)ObjectHelper.invokeMethod(method, null, value, exchange)
            : (T)ObjectHelper.invokeMethod(method, null, value);
    }
}
"
org.apache.camel.component.dataset.DataSet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Exchange;
/**
 * Represents a strategy for testing endpoints with canned data.
 *
 * @version $Revision$
 */
public interface DataSet {
    String INDEX_HEADER = ""camelDataSetIndex"";
    /**
     * Populates a message exchange when using the DataSet as a source of messages
     *
     * @param exchange
     */
    void populateMessage(Exchange exchange, long messageIndex) throws Exception;
    /**
     * Returns the size of the dataset
     */
    long getSize();
    /**
     * Asserts that the expected message has been received for the given index
     */
    void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception;
    /**
     * Returns the number of messages which should be received before reporting on the progress of the test
     */
    long getReportCount();
}
"
org.apache.camel.component.atom.AtomPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Feed;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Consumer to poll atom feeds and return the full feed.
 *
 * @version $Revision$
 */
public class AtomPollingConsumer extends AtomConsumerSupport {
    public AtomPollingConsumer(AtomEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    protected void poll() throws Exception {
        Document<Feed> document = AtomUtils.parseDocument(endpoint.getAtomUri());
        Feed feed = document.getRoot();
        Exchange exchange = endpoint.createExchange(feed);
        getProcessor().process(exchange);
    }
}
"
org.apache.camel.bam.processor.JpaBamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.lang.reflect.Method;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A base class for JPA based BAM which can use any entity to store the process
 * instance information which allows derived classes to specialise the process
 * instance entity.
 *
 * @version $Revision$
 */
public class JpaBamProcessorSupport<T> extends BamProcessorSupport<T> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessorSupport.class);
    private static final Lock LOCK = new ReentrantLock(); // lock used for concurrency issues
    private ActivityRules activityRules;
    private JpaTemplate template;
    private String findByKeyQuery;
    private String keyPropertyName = ""correlationKey"";
    private boolean correlationKeyIsPrimary = true;
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template,
                                  Expression<Exchange> correlationKeyExpression, ActivityRules activityRules,
                                  Class<T> entitytype) {
        super(transactionTemplate, correlationKeyExpression, entitytype);
        this.activityRules = activityRules;
        this.template = template;
    }
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template,
                                  Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, correlationKeyExpression);
        this.activityRules = activityRules;
        this.template = template;
    }
    public String getFindByKeyQuery() {
        if (findByKeyQuery == null) {
            findByKeyQuery = createFindByKeyQuery();
        }
        return findByKeyQuery;
    }
    public void setFindByKeyQuery(String findByKeyQuery) {
        this.findByKeyQuery = findByKeyQuery;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public void setActivityRules(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public String getKeyPropertyName() {
        return keyPropertyName;
    }
    public void setKeyPropertyName(String keyPropertyName) {
        this.keyPropertyName = keyPropertyName;
    }
    public JpaTemplate getTemplate() {
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    public boolean isCorrelationKeyIsPrimary() {
        return correlationKeyIsPrimary;
    }
    public void setCorrelationKeyIsPrimary(boolean correlationKeyIsPrimary) {
        this.correlationKeyIsPrimary = correlationKeyIsPrimary;
    }
    // Implementatiom methods
    // -----------------------------------------------------------------------
    protected T loadEntity(Exchange exchange, Object key) throws Exception {
        LOCK.lock();
        try {
            T entity = findEntityByCorrelationKey(key);
            if (entity == null) {
                entity = createEntity(exchange, key);
                setKeyProperty(entity, key);
                ProcessDefinition definition = ProcessDefinition
                    .getRefreshedProcessDefinition(template, getActivityRules().getProcessRules()
                        .getProcessDefinition());
                setProcessDefinitionProperty(entity, definition);
                template.persist(entity);
                // Now we must flush to avoid concurrent updates clashing trying to
                // insert the same row
                LOG.debug(""About to flush on entity: "" + entity + "" with key: "" + key);
                template.flush();
            }
            return entity;
        } finally {
            LOCK.unlock();
        }
    }
    protected T findEntityByCorrelationKey(Object key) {
        if (isCorrelationKeyIsPrimary()) {
            return template.find(getEntityType(), key);
        } else {
            List<T> list = template.find(getFindByKeyQuery(), key);
            if (list.isEmpty()) {
                return null;
            } else {
                return list.get(0);
            }
        }
    }
    protected Class getKeyType() {
        try {
            Method getter = IntrospectionSupport.getPropertyGetter(getEntityType(), getKeyPropertyName());
            return getter.getReturnType();
        } catch (NoSuchMethodException e) {
            LOG.warn(""no such getter for: "" + getKeyPropertyName() + "" on "" + getEntityType() + "". Reason: ""
                     + e, e);
            return null;
        }
    }
    /**
     * Sets the key property on the new entity
     */
    protected void setKeyProperty(T entity, Object key) throws Exception {
        IntrospectionSupport.setProperty(entity, getKeyPropertyName(), key);
    }
    protected void setProcessDefinitionProperty(T entity, ProcessDefinition processDefinition)
        throws Exception {
        IntrospectionSupport.setProperty(entity, ""processDefinition"", processDefinition);
    }
    /**
     * Create a new instance of the entity for the given key
     */
    protected T createEntity(Exchange exchange, Object key) {
        return (T)exchange.getContext().getInjector().newInstance(getEntityType());
    }
    protected void processEntity(Exchange exchange, T entity) throws Exception {
        if (entity instanceof Processor) {
            Processor processor = (Processor)entity;
            processor.process(exchange);
        } else {
            // TODO add other extension points - eg. passing in Activity
            throw new IllegalArgumentException(""No processor defined for this route"");
        }
    }
    protected String createFindByKeyQuery() {
        return ""select x from "" + getEntityType().getName() + "" x where x."" + getKeyPropertyName() + "" = ?1"";
    }
}
"
org.apache.camel.component.dataset.DataSetComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
/**
 * Component for <a href=""http://activemq.apache.org/camel/dataset.html"">DataSet</a>.
 *
 * @version $Revision$
 */
public class DataSetComponent extends DefaultComponent<Exchange> {
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        DataSet dataSet = CamelContextHelper.mandatoryLookup(getCamelContext(), remaining, DataSet.class);
        return new DataSetEndpoint(uri, this, dataSet);
    }
}"
org.apache.camel.builder.xml.DomResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link DomResultHandler}
 *
 * @version $Revision$
 */
public class DomResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new DomResultHandler();
    }
}
"
org.apache.camel.component.bean.MethodInfoCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.Method;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.util.LRUCache;
/**
 * Represents a cache of MethodInfo objects to avoid the expense of introspection for each invocation of a method
 * via a proxy
 *
 * @version $Revision$
 */
public class MethodInfoCache {
    private final CamelContext camelContext;
    private Map<Method, MethodInfo> methodCache;
    private Map<Class, BeanInfo> classCache;
    public MethodInfoCache(CamelContext camelContext) {
        this(camelContext, 1000, 10000);
    }
    public MethodInfoCache(CamelContext camelContext, int classCacheSize, int methodCacheSize) {
        this(camelContext, createLruCache(classCacheSize), createLruCache(methodCacheSize));
    }
    public MethodInfoCache(CamelContext camelContext, Map<Class, BeanInfo> classCache, Map<Method, MethodInfo> methodCache) {
        this.camelContext = camelContext;
        this.classCache = classCache;
        this.methodCache = methodCache;
    }
    public synchronized MethodInfo getMethodInfo(Method method) {
        MethodInfo answer = methodCache.get(method);
        if (answer == null) {
            answer = createMethodInfo(method);
            methodCache.put(method, answer);
        }
        return answer;
    }
    protected  MethodInfo createMethodInfo(Method method) {
        Class<?> declaringClass = method.getDeclaringClass();
        BeanInfo info = getBeanInfo(declaringClass);
        return info.getMethodInfo(method);
    }
    protected synchronized BeanInfo getBeanInfo(Class<?> declaringClass) {
        BeanInfo beanInfo = classCache.get(declaringClass);
        if (beanInfo == null) {
            beanInfo = createBeanInfo(declaringClass);
            classCache.put(declaringClass, beanInfo);
        }
        return beanInfo;
    }
    protected BeanInfo createBeanInfo(Class<?> declaringClass) {
        return new BeanInfo(camelContext, declaringClass);
    }
    protected static Map createLruCache(int size) {
        return new LRUCache(size);
    }
}
"
org.apache.camel.component.quartz.QuartzMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.quartz.JobExecutionContext;
import org.quartz.Trigger;
/**
 * @version $Revision$
 */
public class QuartzMessage extends DefaultMessage {
    private final JobExecutionContext jobExecutionContext;
    public QuartzMessage(QuartzExchange exchange, JobExecutionContext jobExecutionContext) {
        this.jobExecutionContext = jobExecutionContext;
        setExchange(exchange);
        if (jobExecutionContext != null) {
            setBody(jobExecutionContext.getJobDetail());
        }
    }
    public JobExecutionContext getJobExecutionContext() {
        return jobExecutionContext;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        if (jobExecutionContext != null) {
            map.put(""calendar"", jobExecutionContext.getCalendar());
            map.put(""fireTime"", jobExecutionContext.getFireTime());
            map.put(""jobDetail"", jobExecutionContext.getJobDetail());
            map.put(""jobInstance"", jobExecutionContext.getJobInstance());
            map.put(""jobRunTime"", jobExecutionContext.getJobRunTime());
            map.put(""mergedJobDataMap"", jobExecutionContext.getMergedJobDataMap());
            map.put(""nextFireTime"", jobExecutionContext.getNextFireTime());
            map.put(""previousFireTime"", jobExecutionContext.getPreviousFireTime());
            map.put(""refireCount"", jobExecutionContext.getRefireCount());
            map.put(""result"", jobExecutionContext.getResult());
            map.put(""scheduledFireTime"", jobExecutionContext.getScheduledFireTime());
            map.put(""scheduler"", jobExecutionContext.getScheduler());
            Trigger trigger = jobExecutionContext.getTrigger();
            map.put(""trigger"", trigger);
            map.put(""triggerName"", trigger.getName());
            map.put(""triggerGroup"", trigger.getGroup());
        }
    }
}
"
org.apache.camel.component.mina.MinaExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.mina.common.IoSession;
/**
 * A {@link Exchange} for Apache MINA.
 * 
 * @version $Revision$
 */
public class MinaExchange extends DefaultExchange {
    private IoSession session;
    public MinaExchange(CamelContext camelContext, ExchangePattern pattern, IoSession session) {
        super(camelContext, pattern);
        this.session = session;
    }
    public MinaExchange(DefaultExchange parent, IoSession session) {
        super(parent);
        this.session = session;
    }
    /**
     * The associated Mina session, is <b>only</b> available for {@link MinaConsumer}.
     * 
     * @return the Mina session.
     */
    public IoSession getSession() {
        return session;
    }
    @Override
    public Exchange newInstance() {
        return new MinaExchange(this, getSession());
    }
}
"
org.apache.camel.component.jpa.DefaultTransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.orm.jpa.JpaCallback;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * @version $Revision$
 */
public class DefaultTransactionStrategy extends ServiceSupport implements TransactionStrategy {
    private EntityManagerFactory entityManagerFactory;
    private EntityManager entityManager;
    public DefaultTransactionStrategy(EntityManagerFactory entityManagerFactory) {
        notNull(entityManagerFactory, ""entityManagerFactory"");
        this.entityManagerFactory = entityManagerFactory;
    }
    public DefaultTransactionStrategy(EntityManager entityManager) {
        notNull(entityManager, ""entityManager"");
        this.entityManager = entityManager;
    }
    public Object execute(JpaCallback callback) {
        EntityManager em = getEntityManager();
        EntityTransaction transaction = em.getTransaction();
        transaction.begin();
        try {
            Object answer = callback.doInJpa(em);
            transaction.commit();
            return answer;
        } catch (RuntimeException e) {
            if (transaction != null) {
                transaction.rollback();
            }
            throw e;
        }
    }
    public EntityManager getEntityManager() {
        if (entityManager == null) {
            entityManager = entityManagerFactory.createEntityManager();
        }
        return entityManager;
    }
    protected void doStart() throws Exception {
        // force lazy construction
        getEntityManager();
    }
    protected void doStop() throws Exception {
        if (entityManager != null) {
            entityManager.close();
        }
    }
}
"
org.apache.camel.language.simple.AbstractSimpleLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.spi.Language;
/**
 * Abstract base class for Simple languages.
 */
public abstract class AbstractSimpleLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        if (expression.indexOf(""${"") >= 0) {
            return createComplexExpression(expression);
        }
        return createSimpleExpression(expression);
    }
    protected Expression<Exchange> createComplexExpression(String expression) {
        List<Expression> results = new ArrayList<Expression>();
        int pivot = 0;
        int size = expression.length();
        while (pivot < size) {
            int idx = expression.indexOf(""${"", pivot);
            if (idx < 0) {
                results.add(createConstantExpression(expression, pivot, size));
                break;
            } else {
                if (pivot < idx) {
                    results.add(createConstantExpression(expression, pivot, idx));
                }
                pivot = idx + 2;
                int endIdx = expression.indexOf(""}"", pivot);
                if (endIdx < 0) {
                    throw new IllegalArgumentException(""Expecting } but found end of string for simple expression: "" + expression);
                }
                String simpleText = expression.substring(pivot, endIdx);
                Expression simpleExpression = createSimpleExpression(simpleText);
                results.add(simpleExpression);
                pivot = endIdx + 1;
            }
        }
        return ExpressionBuilder.concatExpression(results, expression);
    }
    protected Expression createConstantExpression(String expression, int start, int end) {
        return ExpressionBuilder.constantExpression(expression.substring(start, end));
    }
    /**
     * Creates the simple expression based on the extracted content from the ${ } place holders
     *
     * @param expression  the content between ${ and }
     * @return the expression
     */
    protected abstract <E extends Exchange> Expression<Exchange> createSimpleExpression(String expression);
    protected String ifStartsWithReturnRemainder(String prefix, String text) {
        if (text.startsWith(prefix)) {
            String remainder = text.substring(prefix.length());
            if (remainder.length() > 0) {
                return remainder;
            }
        }
        return null;
    }
}
"
org.apache.camel.language.Simple,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject a simple expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""simple"")
public @interface Simple {
    String value();
}"
org.apache.camel.impl.DefaultComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default implementation of {@link ComponentResolver} which tries to find
 * components by using the URI scheme prefix and searching for a file of the URI
 * scheme name in the <b>META-INF/services/org/apache/camel/component/</b>
 * directory on the classpath.
 *
 * @version $Revision$
 */
public class DefaultComponentResolver<E extends Exchange> implements ComponentResolver<E> {
    protected static final FactoryFinder COMPONENT_FACTORY =
            new FactoryFinder(""META-INF/services/org/apache/camel/component/"");
    private static final transient Log LOG = LogFactory.getLog(DefaultComponentResolver.class);
    public Component<E> resolveComponent(String name, CamelContext context) {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found component: "" + name + "" in registry: "" + bean);
            }
        } catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component) bean;
            }
            // we do not throw the exception here and try to auto create a component
        }
        Class type;
        try {
            type = COMPONENT_FACTORY.findClass(name);
        } catch (NoFactoryAvailableException e) {
            return null;
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Component registered for scheme : ""
                    + name, e);
        }
        if (type == null) {
            return null;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found component: "" + name + "" via type: "" + type.getName() + "" via "" + COMPONENT_FACTORY.getPath() + name);
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component<E>) context.getInjector().newInstance(type);
        } else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: ""
                    + type.getName());
        }
    }
}
"
org.apache.camel.component.xmpp.XmppPrivateChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.Chat;
import org.jivesoftware.smack.ChatManager;
import org.jivesoftware.smack.MessageListener;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppPrivateChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppPrivateChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String participant;
    public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {
        super(endpoint);
        this.endpoint = endpoint;
        this.participant = participant;
        if (participant == null) {
            throw new IllegalArgumentException(""No participant property specified"");
        }
    }
    public void process(Exchange exchange) {
        String threadId = exchange.getExchangeId();
        try {
            ChatManager chatManager = endpoint.getConnection().getChatManager();
            Chat chat = chatManager.getThreadChat(threadId);
            if (chat == null) {
                chat = chatManager.createChat(getParticipant(), threadId, new MessageListener() {
                    public void processMessage(Chat chat, Message message) {
                        // not here to do conversation
                    }
                });
            }
            // TODO it would be nice if we could reuse the message from the exchange
            Message message = new Message();
            message.setTo(participant);
            message.setThread(threadId);
            message.setType(Message.Type.normal);
            endpoint.getBinding().populateXmppMessage(message, exchange);
            if (LOG.isDebugEnabled()) {
                LOG.debug("">>>> message: "" + message.getBody());
            }
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public String getParticipant() {
        return participant;
    }
}
"
org.apache.camel.spring.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The classes for working with Camel and Spring along with the primary factory beans.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.spring;
"
org.apache.camel.component.ResourceBasedEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Component;
import org.apache.camel.Processor;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * A useful base class for endpoints which depend on a resource
 * such as things like Velocity or XQuery based components.
 *
 * @version $Revision$
 */
public abstract class ResourceBasedEndpoint extends ProcessorEndpoint {
    protected final transient Log log = LogFactory.getLog(getClass());
    private final String resourceUri;
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    private Resource resource;
    private boolean contentCache;
    private byte[] buffer;
    public ResourceBasedEndpoint(String endpointUri, Component component, String resourceUri, Processor processor) {
        super(endpointUri, component, processor);
        this.resourceUri = resourceUri;
    }
    protected ResourceBasedEndpoint(String endpointUri, Processor processor, String resourceUri) {
        super(endpointUri, processor);
        this.resourceUri = resourceUri;
    }
    public Resource getResource() {
        if (resource == null) {
            if (log.isDebugEnabled()) {
                log.debug(""Loading resource: "" + resourceUri + "" using: "" + getResourceLoader());
            }
            resource = getResourceLoader().getResource(resourceUri);
            if (resource == null) {
                throw new IllegalArgumentException(""Could not find resource for URI: "" + resourceUri + "" using: "" + getResourceLoader());
            }
        }
        return resource;
    }
    public boolean isContentCache() {
        return contentCache;
    }
    /**
     * Sets wether to use resource content cache or not - default is <tt>false</tt>.
     *
     * @see #getResourceAsInputStream()
     */
    public void setContentCache(boolean contentCache) {
        this.contentCache = contentCache;
    }
    /**
     * Gets the resource as an input stream considering the cache flag as well.
     * <p/>
     * If cache is enabled then the resource content is cached in an internal buffer and this content is
     * returned to avoid loading the resource over and over again.
     *
     * @return  the input stream
     * @throws IOException is thrown if error loading the content of the resource to the local cache buffer
     */
    public InputStream getResourceAsInputStream() throws IOException {
        if (resource == null) {
            // get the resource if not already done
            resource = getResource();
        }
        if (contentCache) {
            synchronized (resource) {
                if (buffer == null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Reading resource: "" + resourceUri + "" into the content cache"");
                    }
                    buffer = IOConverter.toBytes(resource.getInputStream());
                }
            }
            if (log.isDebugEnabled()) {
                log.debug(""Using resource: "" + resourceUri + "" from the content cache"");
            }
            return new ByteArrayInputStream(buffer);
        }
        return resource.getInputStream();
    }
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
    public String getResourceUri() {
        return resourceUri;
    }
}"
org.apache.camel.impl.DefaultPollingEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
/**
 * A base class for an endpoint which the default consumer mode is to use a {@link PollingConsumer}
 *
 * @version $Revision$
 */
public abstract class DefaultPollingEndpoint<E extends Exchange> extends ScheduledPollEndpoint<E>  {
    protected DefaultPollingEndpoint() {
    }
    protected DefaultPollingEndpoint(String endpointUri) {
        super(endpointUri);
    }
    protected DefaultPollingEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected DefaultPollingEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        DefaultScheduledPollConsumer result = new DefaultScheduledPollConsumer(this, processor);
        configureConsumer(result);
        return result;
    }
}
"
org.apache.camel.converter.jaxb.JaxbDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.IOHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a> ({@link DataFormat})
 * using JAXB2 to marshal to and from XML
 *
 * @version $Revision$
 */
public class JaxbDataFormat implements DataFormat {
    private JAXBContext context;
    private String contextPath;
    private boolean prettyPrint = true;
    private boolean ignoreJAXBElement = true;
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;
    public JaxbDataFormat() {
    }
    public JaxbDataFormat(JAXBContext context) {
        this.context = context;
    }
    public JaxbDataFormat(String contextPath) {
        this.contextPath = contextPath;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        try {
            getMarshaller().marshal(graph, stream);
        } catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        try {
            Object answer = getUnmarshaller().unmarshal(stream);
            if (answer instanceof JAXBElement && isIgnoreJAXBElement()) {
                answer = ((JAXBElement)answer).getValue();
            }
            return answer;
        } catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }    
    // Properties
    // -------------------------------------------------------------------------
    public boolean isIgnoreJAXBElement() {        
        return ignoreJAXBElement;
    }
    public void setIgnoreJAXBElement(boolean flag) {
        ignoreJAXBElement = flag;
    }
    public JAXBContext getContext() throws JAXBException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(JAXBContext context) {
        this.context = context;
    }
    public String getContextPath() {
        return contextPath;
    }
    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }
    public Marshaller getMarshaller() throws JAXBException {
        if (marshaller == null) {
            marshaller = getContext().createMarshaller();
        }
        return marshaller;
    }
    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public Unmarshaller getUnmarshaller() throws JAXBException {
        if (unmarshaller == null) {
            unmarshaller = getContext().createUnmarshaller();
        }
        return unmarshaller;
    }
    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }
    protected JAXBContext createContext() throws JAXBException {
        if (contextPath != null) {
            return JAXBContext.newInstance(contextPath);
        } else {
            return JAXBContext.newInstance();
        }
    }
}
"
org.apache.camel.component.jcr.JcrProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import javax.jcr.LoginException;
import javax.jcr.Node;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
public class JcrProducer extends DefaultProducer<DefaultExchange> {
    public JcrProducer(JcrEndpoint jcrEndpoint) throws LoginException,
            RepositoryException {
        super(jcrEndpoint);
    }
    public void process(Exchange exchange) throws Exception {
        Session session = openSession();
        try {
            Node base = getBaseNode(session);
            Node node = base.addNode(getNodeName(exchange));
            TypeConverter converter = exchange.getContext().getTypeConverter();
            for (String key : exchange.getProperties().keySet()) {
                Value value = converter.convertTo(Value.class, 
                    exchange, exchange.getProperty(key));
                node.setProperty(key, value);
            }
            node.addMixin(""mix:referenceable"");
            session.save();
            exchange.getOut().setBody(node.getUUID());
        } finally {
            if (session != null && session.isLive()) {
                session.logout();
            }
        }
    }
    private String getNodeName(Exchange exchange) {
        if (exchange.getProperty(JcrComponent.NODE_NAME) != null) {
            return exchange.getProperty(JcrComponent.NODE_NAME).toString();
        }
        return exchange.getExchangeId();
    }
    private Node getBaseNode(Session session) throws Exception {
        Node baseNode = session.getRootNode();
        for (String node : getJcrEndpoint().getBase().split(""/"")) {
            baseNode = baseNode.addNode(node);
        }
        return baseNode;
    }
    protected Session openSession() throws LoginException, RepositoryException {
        return getJcrEndpoint().getRepository().login(getJcrEndpoint().getCredentials());
    }
    private JcrEndpoint getJcrEndpoint() {
        JcrEndpoint endpoint = (JcrEndpoint) getEndpoint();
        return endpoint;
    }
}
"
org.apache.camel.converter.jaxb.StringHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""header"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class StringHeader extends HeaderType {
    @XmlAttribute(name = ""value"", required = true)
    private String text;
    public StringHeader() {
    }
    public StringHeader(String name, String text) {
        super(name);
        this.text = text;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    public Object getValue() {
        return getText();
    }
    public void setValue(Object value) {
        if (value instanceof String) {
            setText((String) value);
        } else {
            throw new IllegalArgumentException(""Value must be a String"");
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import org.w3c.dom.Element;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.StaxUtils;
public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public PayloadContentRedirectInterceptor() {
        super(Phase.POST_STREAM);
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        // check the fault from the message
        Throwable ex = message.getContent(Throwable.class);
        if (ex != null) {
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                throw new Fault(ex);
            }
        }
        XMLStreamWriter out = message.getContent(XMLStreamWriter.class);
        List<Element> in = message.get(List.class);
        try {
            for (Element el : in) {
                StaxUtils.writeElement(el, out, false, true);
            }
        } catch (XMLStreamException e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.bam.TimeExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.TemporalRule;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.equal;
/**
 * @version $Revision$
 */
public abstract class TimeExpression {
    private ActivityRules activityRules;
    private ActivityBuilder builder;
    private ActivityLifecycle lifecycle;
    public TimeExpression(ActivityBuilder builder, ActivityLifecycle lifecycle) {
        this.lifecycle = lifecycle;
        this.builder = builder;
        this.activityRules = builder.getActivityRules();
    }
    public boolean isActivityLifecycle(ActivityRules activityRules, ActivityLifecycle lifecycle) {
        return equal(activityRules, this.activityRules) && equal(lifecycle, this.lifecycle);
    }
    /**
     * Creates a new temporal rule on this expression and the other expression
     */
    public TemporalRule after(TimeExpression expression) {
        TemporalRule rule = new TemporalRule(expression, this);
        rule.getSecond().getActivityRules().addRule(rule);
        return rule;
    }
    public Date evaluate(ProcessInstance processInstance) {
        ActivityState state = processInstance.getActivityState(activityRules);
        if (state != null) {
            return evaluate(processInstance, state);
        }
        return null;
    }
    public abstract Date evaluate(ProcessInstance instance, ActivityState state);
    // Properties
    //-------------------------------------------------------------------------
    public ActivityBuilder getBuilder() {
        return builder;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ActivityLifecycle getLifecycle() {
        return lifecycle;
    }
    public ActivityState getActivityState(ProcessInstance instance) {
        return instance.getActivityState(activityRules);
    }
    public ActivityState getOrCreateActivityState(ProcessInstance instance) {
        return instance.getOrCreateActivityState(activityRules);
    }
}
"
org.apache.camel.component.log.LogComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.ThroughputLogger;
import org.apache.camel.util.IntrospectionSupport;
/**
 * The <a href=""http://activemq.apache.org/camel/log.html"">Log Component</a>
 * to log message exchanges to the underlying logging mechanism.
 *
 * @version $Revision$
 */
public class LogComponent extends DefaultComponent<Exchange> {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        LoggingLevel level = getLoggingLevel(parameters);
        Integer groupSize = getAndRemoveParameter(parameters, ""groupSize"", Integer.class);
        Logger logger;
        if (groupSize != null) {
            logger = new ThroughputLogger(remaining, level, ObjectConverter.toInteger(groupSize));
        } else {
            LogFormatter formatter = new LogFormatter();
            IntrospectionSupport.setProperties(formatter, parameters);
            logger = new Logger(remaining);
            logger.setLevel(level);
            logger.setFormatter(formatter);
        }
        return new ProcessorEndpoint(uri, this, logger);
    }
    /**
     * Gets the logging level, will default to use INFO if no level parameter provided.
     */
    protected LoggingLevel getLoggingLevel(Map parameters) {
        String levelText = getAndRemoveParameter(parameters, ""level"", String.class, ""INFO"");
        return LoggingLevel.valueOf(levelText.toUpperCase());
    }
}
"
org.apache.camel.spring.spi.SpringInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Injector;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * A Spring implementation of {@link Injector} allowing Spring to be used to dependency inject newly created POJOs
 *
 * @version $Revision$
 */
public class SpringInjector implements Injector {
    private final ConfigurableApplicationContext applicationContext;
    private int autowireMode = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
    private boolean dependencyCheck;
    public SpringInjector(ConfigurableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T newInstance(Class<T> type) {
        // TODO support annotations for mandatory injection points?
        Object value = applicationContext.getBeanFactory().createBean(type, autowireMode, dependencyCheck);
        return type.cast(value);
    }
    public int getAutowireMode() {
        return autowireMode;
    }
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }
    public boolean isDependencyCheck() {
        return dependencyCheck;
    }
    public void setDependencyCheck(boolean dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }
}
"
org.apache.camel.component.jms.JmsConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.QueueSender;
import javax.jms.Session;
import javax.jms.TopicPublisher;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.PackageHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.JmsException;
import org.springframework.jms.connection.JmsResourceHolder;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.SessionCallback;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer102;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.util.Assert;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
/**
 * @version $Revision$
 */
public class JmsConfiguration implements Cloneable {
    public static final String QUEUE_PREFIX = ""queue:"";
    public static final String TOPIC_PREFIX = ""topic:"";
    public static final String TEMP_QUEUE_PREFIX = ""temp:queue:"";
    public static final String TEMP_TOPIC_PREFIX = ""temp:topic:"";
    protected static final String TRANSACTED = ""TRANSACTED"";
    protected static final String CLIENT_ACKNOWLEDGE = ""CLIENT_ACKNOWLEDGE"";
    protected static final String AUTO_ACKNOWLEDGE = ""AUTO_ACKNOWLEDGE"";
    protected static final String DUPS_OK_ACKNOWLEDGE = ""DUPS_OK_ACKNOWLEDGE"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT = ""component"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT = ""endpoint"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_PRODUCER = ""producer"";
    private static final transient Log LOG = LogFactory.getLog(JmsConfiguration.class);
    private JmsOperations jmsOperations;
    private DestinationResolver destinationResolver;
    private ConnectionFactory connectionFactory;
    private ConnectionFactory templateConnectionFactory;
    private ConnectionFactory listenerConnectionFactory;
    private int acknowledgementMode = -1;
    private String acknowledgementModeName;
    // Used to configure the spring Container
    private ExceptionListener exceptionListener;
    private ConsumerType consumerType = ConsumerType.Default;
    private boolean autoStartup = true;
    private boolean acceptMessagesWhileStopping;
    private String clientId;
    private String durableSubscriptionName;
    private boolean subscriptionDurable;
    private boolean exposeListenerSession = true;
    private TaskExecutor taskExecutor;
    private boolean pubSubNoLocal;
    private int concurrentConsumers = 1;
    private int maxMessagesPerTask = 1;
    private ServerSessionFactory serverSessionFactory;
    private int cacheLevel = -1;
    private String cacheLevelName;
    private long recoveryInterval = -1;
    private long receiveTimeout = -1;
    private long requestTimeout = 20000L;
    private int idleTaskExecutionLimit = 1;
    private int maxConcurrentConsumers = 1;
    // JmsTemplate only
    private boolean useVersion102;
    private Boolean explicitQosEnabled;
    private boolean deliveryPersistent = true;
    private boolean replyToDeliveryPersistent = true;
    private long timeToLive = -1;
    private MessageConverter messageConverter;
    private boolean messageIdEnabled = true;
    private boolean messageTimestampEnabled = true;
    private int priority = -1;
    // Transaction related configuration
    private boolean transacted;
    private boolean transactedInOut;
    private PlatformTransactionManager transactionManager;
    private String transactionName;
    private int transactionTimeout = -1;
    private boolean preserveMessageQos;
    private long requestMapPurgePollTimeMillis = 1000L;
    private boolean disableReplyTo;
    private boolean eagerLoadingOfProperties;
    // Always make a JMS message copy when it's passed to Producer
    private boolean alwaysCopyMessage;
    private boolean useMessageIDAsCorrelationID;
    private JmsProviderMetadata providerMetadata = new JmsProviderMetadata();
    private JmsOperations metadataJmsOperations;
    // defines the component created temporary replyTo destination sharing strategy:
    // possible values are: ""component"", ""endpoint"", ""producer""
    // component - a single temp queue is shared among all producers for a given component instance
    // endpoint - a single temp queue is shared among all producers for a given endpoint instance
    // producer - a single temp queue is created per producer
    private String replyToTempDestinationAffinity = REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT;
    private String replyToDestination;
    private String replyToDestinationSelectorName;
    public JmsConfiguration() {
    }
    public JmsConfiguration(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    /**
     * Returns a copy of this configuration
     */
    public JmsConfiguration copy() {
        try {
            return (JmsConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public static interface MessageSentCallback {
        void sent(Message message);
    }
    public static class CamelJmsTemplate extends JmsTemplate {
        private JmsConfiguration config;
        public CamelJmsTemplate(JmsConfiguration config, ConnectionFactory connectionFactory) {
            super(connectionFactory);
            this.config = config;
        }
        public void send(final String destinationName,
                         final MessageCreator messageCreator,
                         final MessageSentCallback callback) throws JmsException {
            execute(new SessionCallback() {
                public Object doInJms(Session session) throws JMSException {
                    Destination destination = resolveDestinationName(session, destinationName);
                    Assert.notNull(messageCreator, ""MessageCreator must not be null"");
                    MessageProducer producer = createProducer(session, destination);
                    Message message = null;
                    try {
                        message = messageCreator.createMessage(session);
                        if (logger.isDebugEnabled()) {
                            logger.debug(""Sending created message: "" + message);
                        }
                        doSend(producer, message);
                        // Check commit - avoid commit call within a JTA transaction.
                        if (session.getTransacted() && isSessionLocallyTransacted(session)) {
                            // Transacted session created by this template -> commit.
                            JmsUtils.commitIfNecessary(session);
                        }
                    } finally {
                        JmsUtils.closeMessageProducer(producer);
                    }
                    if (message != null && callback != null) {
                        callback.sent(message);
                    }
                    return null;
                }
            }, false);
        }
        /**
         * Override so we can support preserving the Qos settings that have
         * been set on the message.
         */
        @Override
        protected void doSend(MessageProducer producer, Message message) throws JMSException {
            if (config.isPreserveMessageQos()) {
                long ttl = message.getJMSExpiration();
                if (ttl != 0) {
                    ttl = ttl - System.currentTimeMillis();
                    // Message had expired.. so set the ttl as small as
                    // possible
                    if (ttl <= 0) {
                        ttl = 1;
                    }
                }
                producer.send(message, message.getJMSDeliveryMode(), message.getJMSPriority(), ttl);
            } else {
                super.doSend(producer, message);
            }
        }
    }
    public static class CamelJmsTeemplate102 extends JmsTemplate102 {
        private JmsConfiguration config;
        public CamelJmsTeemplate102(JmsConfiguration config, ConnectionFactory connectionFactory, boolean pubSubDomain) {
            super(connectionFactory, pubSubDomain);
            this.config = config;
        }
        public void send(final String destinationName,
                final MessageCreator messageCreator,
                final MessageSentCallback callback) throws JmsException {
            execute(new SessionCallback() {
                public Object doInJms(Session session) throws JMSException {
                    Destination destination = resolveDestinationName(session, destinationName);
                    Assert.notNull(messageCreator, ""MessageCreator must not be null"");
                    MessageProducer producer = createProducer(session, destination);
                    Message message = null;
                    try {
                        message = messageCreator.createMessage(session);
                        if (logger.isDebugEnabled()) {
                            logger.debug(""Sending created message: "" + message);
                        }
                        doSend(producer, message);
                        // Check commit - avoid commit call within a JTA
                        // transaction.
                        if (session.getTransacted() && isSessionLocallyTransacted(session)) {
                            // Transacted session created by this template ->
                            // commit.
                            JmsUtils.commitIfNecessary(session);
                        }
                    } finally {
                        JmsUtils.closeMessageProducer(producer);
                    }
                    if (message != null && callback != null) {
                        callback.sent(message);
                    }
                    return null;
                }
            }, false);
        }
        /**
         * Override so we can support preserving the Qos settings that have
         * been set on the message.
         */
        @Override
        protected void doSend(MessageProducer producer, Message message) throws JMSException {
            if (config.isPreserveMessageQos()) {
                long ttl = message.getJMSExpiration();
                if (ttl != 0) {
                    ttl = ttl - System.currentTimeMillis();
                    // Message had expired.. so set the ttl as small as
                    // possible
                    if (ttl <= 0) {
                        ttl = 1;
                    }
                }
                if (isPubSubDomain()) {
                    ((TopicPublisher) producer).publish(message, message.getJMSDeliveryMode(),
                                                        message.getJMSPriority(), ttl);
                } else {
                    ((QueueSender) producer).send(message, message.getJMSDeliveryMode(),
                                                  message.getJMSPriority(), ttl);
                }
            } else {
                super.doSend(producer, message);
            }
        }
    }
    /**
     * Creates a {@link JmsOperations} object used for request/response using a request
     * timeout value
     */
    public JmsOperations createInOutTemplate(JmsEndpoint endpoint, boolean pubSubDomain, String destination, long requestTimeout) {
        JmsOperations answer = createInOnlyTemplate(endpoint, pubSubDomain, destination);
        if (answer instanceof JmsTemplate && requestTimeout > 0) {
            JmsTemplate jmsTemplate = (JmsTemplate)answer;
            jmsTemplate.setExplicitQosEnabled(true);
            jmsTemplate.setTimeToLive(requestTimeout);
            jmsTemplate.setSessionTransacted(isTransactedInOut());
            if (isTransactedInOut()) {
                jmsTemplate.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
            } else {
                if (acknowledgementMode >= 0) {
                    jmsTemplate.setSessionAcknowledgeMode(acknowledgementMode);
                } else if (acknowledgementModeName != null) {
                    jmsTemplate.setSessionAcknowledgeModeName(acknowledgementModeName);
                } else {
                    // default to AUTO
                    jmsTemplate.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
                }
            }
        }
        return answer;
    }
    /**
     * Creates a {@link JmsOperations} object used for one way messaging
     */
    public JmsOperations createInOnlyTemplate(JmsEndpoint endpoint, boolean pubSubDomain, String destination) {
        if (jmsOperations != null) {
            return jmsOperations;
        }
        ConnectionFactory factory = getTemplateConnectionFactory();
        JmsTemplate template = useVersion102
            ? new CamelJmsTeemplate102(this, factory, pubSubDomain)
            : new CamelJmsTemplate(this, factory);
        template.setPubSubDomain(pubSubDomain);
        if (destinationResolver != null) {
            template.setDestinationResolver(destinationResolver);
            if (endpoint instanceof DestinationEndpoint) {
                LOG.debug(""You are overloading the destinationResolver property on a DestinationEndpoint; are you sure you want to do that?"");
            }
        } else if (endpoint instanceof DestinationEndpoint) {
            DestinationEndpoint destinationEndpoint = (DestinationEndpoint) endpoint;
            template.setDestinationResolver(createDestinationResolver(destinationEndpoint));
        }
        template.setDefaultDestinationName(destination);
        template.setExplicitQosEnabled(isExplicitQosEnabled());
        template.setDeliveryPersistent(deliveryPersistent);
        if (messageConverter != null) {
            template.setMessageConverter(messageConverter);
        }
        template.setMessageIdEnabled(messageIdEnabled);
        template.setMessageTimestampEnabled(messageTimestampEnabled);
        if (priority >= 0) {
            template.setPriority(priority);
        }
        template.setPubSubNoLocal(pubSubNoLocal);
        if (receiveTimeout >= 0) {
            template.setReceiveTimeout(receiveTimeout);
        }
        if (timeToLive >= 0) {
            template.setTimeToLive(timeToLive);
        }
        template.setSessionTransacted(transacted);
        if (transacted) {
            template.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            // This is here for completeness, but the template should not get
            // used
            // for receiving messages.
            if (acknowledgementMode >= 0) {
                template.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                template.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        return template;
    }
    public AbstractMessageListenerContainer createMessageListenerContainer(JmsEndpoint endpoint) {
        AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation();
        configureMessageListenerContainer(container, endpoint);
        return container;
    }
    // Properties
    // -------------------------------------------------------------------------
    public ConnectionFactory getConnectionFactory() {
        if (connectionFactory == null) {
            connectionFactory = createConnectionFactory();
        }
        return connectionFactory;
    }
    /**
     * Sets the default connection factory to be used if a connection factory is
     * not specified for either
     * {@link #setTemplateConnectionFactory(ConnectionFactory)} or
     * {@link #setListenerConnectionFactory(ConnectionFactory)}
     *
     * @param connectionFactory the default connection factory to use
     */
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    public ConnectionFactory getListenerConnectionFactory() {
        if (listenerConnectionFactory == null) {
            listenerConnectionFactory = createListenerConnectionFactory();
        }
        return listenerConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for consuming messages via the
     * {@link #createMessageListenerContainer(JmsEndpoint)}
     *
     * @param listenerConnectionFactory the connection factory to use for
     *                consuming messages
     */
    public void setListenerConnectionFactory(ConnectionFactory listenerConnectionFactory) {
        this.listenerConnectionFactory = listenerConnectionFactory;
    }
    public ConnectionFactory getTemplateConnectionFactory() {
        if (templateConnectionFactory == null) {
            templateConnectionFactory = createTemplateConnectionFactory();
        }
        return templateConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for sending messages via the
     * {@link JmsTemplate} via {@link #createInOnlyTemplate(JmsEndpoint,boolean, String)}
     *
     * @param templateConnectionFactory the connection factory for sending
     *                messages
     */
    public void setTemplateConnectionFactory(ConnectionFactory templateConnectionFactory) {
        this.templateConnectionFactory = templateConnectionFactory;
    }
    public boolean isUseVersion102() {
        return useVersion102;
    }
    public void setUseVersion102(boolean useVersion102) {
        this.useVersion102 = useVersion102;
    }
    public boolean isAutoStartup() {
        return autoStartup;
    }
    public void setAutoStartup(boolean autoStartup) {
        this.autoStartup = autoStartup;
    }
    public boolean isAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }
    public String getClientId() {
        return clientId;
    }
    public void setClientId(String consumerClientId) {
        this.clientId = consumerClientId;
    }
    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }
    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }
    public boolean isSubscriptionDurable() {
        return subscriptionDurable;
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }
    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        this.acknowledgementModeName = consumerAcknowledgementMode;
        this.acknowledgementMode = -1;
    }
    public boolean isExposeListenerSession() {
        return exposeListenerSession;
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }
    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }
    public boolean isPubSubNoLocal() {
        return pubSubNoLocal;
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }
    public int getConcurrentConsumers() {
        return concurrentConsumers;
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }
    public int getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }
    public ServerSessionFactory getServerSessionFactory() {
        return serverSessionFactory;
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        this.serverSessionFactory = serverSessionFactory;
    }
    public int getCacheLevel() {
        return cacheLevel;
    }
    public void setCacheLevel(int cacheLevel) {
        this.cacheLevel = cacheLevel;
    }
    public String getCacheLevelName() {
        return cacheLevelName;
    }
    public void setCacheLevelName(String cacheName) {
        this.cacheLevelName = cacheName;
    }
    public long getRecoveryInterval() {
        return recoveryInterval;
    }
    public void setRecoveryInterval(long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }
    public long getReceiveTimeout() {
        return receiveTimeout;
    }
    public void setReceiveTimeout(long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public String getTransactionName() {
        return transactionName;
    }
    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }
    public int getTransactionTimeout() {
        return transactionTimeout;
    }
    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }
    public int getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }
    public int getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }
    public boolean isExplicitQosEnabled() {
        return explicitQosEnabled != null ? explicitQosEnabled : false;
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }
    public boolean isDeliveryPersistent() {
        return deliveryPersistent;
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
        configuredQoS();
    }
    public boolean isReplyToDeliveryPersistent() {
        return replyToDeliveryPersistent;
    }
    public void setReplyToDeliveryPersistent(boolean replyToDeliveryPersistent) {
        this.replyToDeliveryPersistent = replyToDeliveryPersistent;
    }
    public long getTimeToLive() {
        return timeToLive;
    }
    public void setTimeToLive(long timeToLive) {
        this.timeToLive = timeToLive;
        configuredQoS();
    }
    public MessageConverter getMessageConverter() {
        return messageConverter;
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }
    public boolean isMessageIdEnabled() {
        return messageIdEnabled;
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }
    public boolean isMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
        configuredQoS();
    }
    public ConsumerType getConsumerType() {
        return consumerType;
    }
    public void setConsumerType(ConsumerType consumerType) {
        this.consumerType = consumerType;
    }
    public int getAcknowledgementMode() {
        return acknowledgementMode;
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        this.acknowledgementMode = consumerAcknowledgementMode;
        this.acknowledgementModeName = null;
    }
    public boolean isTransacted() {
        return transacted;
    }
    public void setTransacted(boolean consumerTransacted) {
        this.transacted = consumerTransacted;
    }
    /**
     * Should InOut operations (request reply) default to using transacted mode?
     *
     * By default this is false as you need to commit the outgoing request before you can consume the input
     *
     * @return
     */
    public boolean isTransactedInOut() {
        return transactedInOut;
    }
    public void setTransactedInOut(boolean transactedInOut) {
        this.transactedInOut = transactedInOut;
    }
    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }
    /**
     * Enables eager loading of JMS properties as soon as a message is loaded
     * which generally is inefficient as the JMS properties may not be required
     * but sometimes can catch early any issues with the underlying JMS provider
     * and the use of JMS properties
     *
     * @param eagerLoadingOfProperties whether or not to enable eager loading of
     *                JMS properties on inbound messages
     */
    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }
    public boolean isDisableReplyTo() {
        return disableReplyTo;
    }
    /**
     * Disables the use of the JMSReplyTo header for consumers so that inbound
     * messages are treated as InOnly rather than InOut requests.
     *
     * @param disableReplyTo whether or not to disable the use of JMSReplyTo
     *                header indicating an InOut
     */
    public void setDisableReplyTo(boolean disableReplyTo) {
        this.disableReplyTo = disableReplyTo;
    }
    /**
     * Set to true if you want to send message using the QoS settings specified
     * on the message. Normally the QoS settings used are the one configured on
     * this Object.
     */
    public void setPreserveMessageQos(boolean preserveMessageQos) {
        this.preserveMessageQos = preserveMessageQos;
    }
    public JmsOperations getJmsOperations() {
        return jmsOperations;
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        this.jmsOperations = jmsOperations;
    }
    public DestinationResolver getDestinationResolver() {
        return destinationResolver;
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        this.destinationResolver = destinationResolver;
    }
    public long getRequestMapPurgePollTimeMillis() {
        return requestMapPurgePollTimeMillis;
    }
    /**
     * Sets the frequency that the requestMap for InOut exchanges is purged for
     * timed out message exchanges
     */
    public void setRequestMapPurgePollTimeMillis(long requestMapPurgePollTimeMillis) {
        this.requestMapPurgePollTimeMillis = requestMapPurgePollTimeMillis;
    }
    public JmsProviderMetadata getProviderMetadata() {
        return providerMetadata;
    }
    /**
     * Allows the provider metadata to be explicitly configured. Typically this is not required
     * and Camel will auto-detect the provider metadata from the underlying provider.
     */
    public void setProviderMetadata(JmsProviderMetadata providerMetadata) {
        this.providerMetadata = providerMetadata;
    }
    public JmsOperations getMetadataJmsOperations(JmsEndpoint endpoint) {
        if (metadataJmsOperations == null) {
            metadataJmsOperations = getJmsOperations();
            if (metadataJmsOperations == null) {
                metadataJmsOperations = createInOnlyTemplate(endpoint, false, null);
            }
        }
        return metadataJmsOperations;
    }
    /**
     * Sets the {@link JmsOperations} used to deduce the {@link JmsProviderMetadata} details which if none
     * is customized one is lazily created on demand
     */
    public void setMetadataJmsOperations(JmsOperations metadataJmsOperations) {
        this.metadataJmsOperations = metadataJmsOperations;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public static DestinationResolver createDestinationResolver(final DestinationEndpoint destinationEndpoint) {
        return new DestinationResolver() {
            public Destination resolveDestinationName(Session session, String destinationName, boolean pubSubDomain) throws JMSException {
                return destinationEndpoint.getJmsDestination(session);
            }
        };
    }
    protected void configureMessageListenerContainer(AbstractMessageListenerContainer container,
                                                     JmsEndpoint endpoint) {
        container.setConnectionFactory(getListenerConnectionFactory());
        if (endpoint instanceof DestinationEndpoint) {
            container.setDestinationResolver(createDestinationResolver((DestinationEndpoint) endpoint));
        } else if (destinationResolver != null) {
            container.setDestinationResolver(destinationResolver);
        }
        if (autoStartup) {
            container.setAutoStartup(true);
        }
        if (clientId != null) {
            container.setClientId(clientId);
        }
        container.setSubscriptionDurable(subscriptionDurable);
        if (durableSubscriptionName != null) {
            container.setDurableSubscriptionName(durableSubscriptionName);
        }
        // lets default to durable subscription if the subscriber name and
        // client ID are specified (as there's
        // no reason to specify them if not! :)
        if (durableSubscriptionName != null && clientId != null) {
            container.setSubscriptionDurable(true);
        }
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
        container.setExposeListenerSession(exposeListenerSession);
        container.setSessionTransacted(transacted);
        if (transacted) {
            container.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            if (acknowledgementMode >= 0) {
                container.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                container.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        if (endpoint.getSelector() != null && endpoint.getSelector().length() != 0) {
            container.setMessageSelector(endpoint.getSelector());
        }
        if (container instanceof DefaultMessageListenerContainer) {
            // this includes DefaultMessageListenerContainer102
            DefaultMessageListenerContainer listenerContainer = (DefaultMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            if (cacheLevel >= 0) {
                listenerContainer.setCacheLevel(cacheLevel);
            } else if (cacheLevelName != null) {
                listenerContainer.setCacheLevelName(cacheLevelName);
            } else {
                listenerContainer.setCacheLevel(defaultCacheLevel(endpoint));
            }
            if (idleTaskExecutionLimit >= 0) {
                listenerContainer.setIdleTaskExecutionLimit(idleTaskExecutionLimit);
            }
            if (maxConcurrentConsumers >= 0) {
                listenerContainer.setMaxConcurrentConsumers(maxConcurrentConsumers);
            }
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (receiveTimeout >= 0) {
                listenerContainer.setReceiveTimeout(receiveTimeout);
            }
            if (recoveryInterval >= 0) {
                listenerContainer.setRecoveryInterval(recoveryInterval);
            }
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
            PlatformTransactionManager tm = getTransactionManager();
            if (tm != null && transacted) {
                listenerContainer.setTransactionManager(tm);
            } else if (transacted) {
                throw new IllegalArgumentException(""Property transacted is enabled but a transactionManager was not injected!"");
            }
            if (transactionName != null) {
                listenerContainer.setTransactionName(transactionName);
            }
            if (transactionTimeout >= 0) {
                listenerContainer.setTransactionTimeout(transactionTimeout);
            }
        } else if (container instanceof ServerSessionMessageListenerContainer) {
            // this includes ServerSessionMessageListenerContainer102
            ServerSessionMessageListenerContainer listenerContainer = (ServerSessionMessageListenerContainer)container;
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            if (serverSessionFactory != null) {
                listenerContainer.setServerSessionFactory(serverSessionFactory);
            }
        } else if (container instanceof SimpleMessageListenerContainer) {
            // this includes SimpleMessageListenerContainer102
            SimpleMessageListenerContainer listenerContainer = (SimpleMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
        }
    }
    public void configure(EndpointMessageListener listener) {
        if (isDisableReplyTo()) {
            listener.setDisableReplyTo(true);
        }
        if (isEagerLoadingOfProperties()) {
            listener.setEagerLoadingOfProperties(true);
        }
        // TODO: REVISIT: We really ought to change the model and let JmsProducer
        // and JmsConsumer have their own JmsConfiguration instance
        // This way producer's and consumer's QoS can differ and be
        // independently configured
        JmsOperations operations = listener.getTemplate();
        if (operations instanceof JmsTemplate) {
            JmsTemplate template = (JmsTemplate)operations;
            template.setDeliveryPersistent(isReplyToDeliveryPersistent());
        }
    }
    public AbstractMessageListenerContainer chooseMessageListenerContainerImplementation() {
        // TODO we could allow a spring container to auto-inject these objects?
        switch (consumerType) {
        case Simple:
            return isUseVersion102()
                ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
        case ServerSessionPool:
            return isUseVersion102()
                ? new ServerSessionMessageListenerContainer102()
                : new ServerSessionMessageListenerContainer();
        case Default:
            return isUseVersion102()
                ? new DefaultMessageListenerContainer102() : new DefaultMessageListenerContainer();
        default:
            throw new IllegalArgumentException(""Unknown consumer type: "" + consumerType);
        }
    }
    /**
     * Defaults the JMS cache level if none is explicitly specified. Note that
     * due to this <a
     * href=""http://opensource.atlassian.com/projects/spring/browse/SPR-3890"">Spring
     * Bug</a> we cannot use CACHE_CONSUMER by default (which we should do as
     * its most efficient) unless the spring version is 2.5.1 or later. Instead
     * we use CACHE_CONNECTION - part from for non-durable topics which must use
     * CACHE_CONSUMER to avoid missing messages (due to the consumer being
     * created and destroyed per message).
     *
     * @param endpoint the endpoint
     * @return the cacne level
     */
    protected int defaultCacheLevel(JmsEndpoint endpoint) {
        // if we are on a new enough spring version we can assume CACHE_CONSUMER
        if (PackageHelper.isValidVersion(""org.springframework.jms"", 2.51D)) {
            return DefaultMessageListenerContainer.CACHE_CONSUMER;
        } else {
            if (endpoint.isPubSubDomain() && !isSubscriptionDurable()) {
                // we must cache the consumer or we will miss messages
                // see https://issues.apache.org/activemq/browse/CAMEL-253
                return DefaultMessageListenerContainer.CACHE_CONSUMER;
            } else {
                // to enable consuming and sending with a single JMS session (to
                // avoid XA) we can only use CACHE_CONNECTION
                // due to this bug :
                // http://opensource.atlassian.com/projects/spring/browse/SPR-3890
                return DefaultMessageListenerContainer.CACHE_CONNECTION;
            }
        }
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createConnectionFactory() {
        ObjectHelper.notNull(connectionFactory, ""connectionFactory"");
        return null;
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createListenerConnectionFactory() {
        return getConnectionFactory();
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createTemplateConnectionFactory() {
        return getConnectionFactory();
    }
    public boolean isPreserveMessageQos() {
        return preserveMessageQos;
    }
    /**
     * When one of the QoS properties are configured such as {@link #setDeliveryPersistent(boolean)},
     * {@link #setPriority(int)} or {@link #setTimeToLive(long)} then we should auto default the
     * setting of {@link #setExplicitQosEnabled(boolean)} if its not been configured yet
     */
    protected void configuredQoS() {
        if (explicitQosEnabled == null) {
            explicitQosEnabled = true;
        }
    }
    public boolean isAlwaysCopyMessage() {
        return alwaysCopyMessage;
    }
    public void setAlwaysCopyMessage(boolean alwaysCopyMessage) {
        this.alwaysCopyMessage = alwaysCopyMessage;
    }
    public boolean isUseMessageIDAsCorrelationID() {
        return useMessageIDAsCorrelationID;
    }
    public void setUseMessageIDAsCorrelationID(boolean useMessageIDAsCorrelationID) {
        this.useMessageIDAsCorrelationID = useMessageIDAsCorrelationID;
    }
    public String getReplyToTempDestinationAffinity() {
        return replyToTempDestinationAffinity;
    }
    public void setReplyToTempDestinationAffinity(
            String replyToTempDestinationAffinity) {
        this.replyToTempDestinationAffinity = replyToTempDestinationAffinity;
    }
    public long getRequestTimeout() {
        return requestTimeout;
    }
    /**
     * Sets the timeout in milliseconds which requests should timeout after
     */
    public void setRequestTimeout(long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }
    public String getReplyTo() {
        return replyToDestination;
    }
    public void setReplyTo(String replyToDestination) {
        if (!replyToDestination.startsWith(QUEUE_PREFIX)) {
            throw new IllegalArgumentException(""ReplyTo destination value has to be of type queue; ""
                                              + ""e.g: \""queue:replyQueue\"""");
        }
        this.replyToDestination =
            removeStartingCharacters(replyToDestination.substring(QUEUE_PREFIX.length()), '/');
    }
    public String getReplyToDestinationSelectorName() {
        return replyToDestinationSelectorName;
    }
    public void setReplyToDestinationSelectorName(String replyToDestinationSelectorName) {
        this.replyToDestinationSelectorName = replyToDestinationSelectorName;
        // in case of consumer -> producer and a named replyTo correlation selector
        // message passthough is impossible as we need to set the value of selector into
        // outgoing message, which would be read-only if passthough were to remain enabled
        if (replyToDestinationSelectorName != null) {
            setAlwaysCopyMessage(true);
        }
    }
}
"
org.apache.camel.component.file.FileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.impl.DefaultMessage;
/**
 * A {@link org.apache.camel.Message Message} for File
 *
 * @version $Revision$
 */
public class FileMessage extends DefaultMessage {
    private File file;
    public FileMessage() {
        this(new File("".""));
    }
    public FileMessage(File file) {
        this.file = file;
    }
    @Override
    public String toString() {
        return ""FileMessage: "" + file;
    }
    @Override
    public FileExchange getExchange() {
        return (FileExchange)super.getExchange();
    }
    public File getFile() {
        return file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    @Override
    public FileMessage newInstance() {
        return new FileMessage();
    }
    @Override
    protected Object createBody() {
        return file;
    }
}
"
org.apache.camel.component.timer.TimerEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Date;
import java.util.Timer;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * Represents a timer endpoint that can generate periodic inbound PojoExchanges.
 *
 * @version $Revision$
 */
public class TimerEndpoint extends DefaultEndpoint<Exchange> {
    private String timerName;
    private Date time;
    private long period = 1000;
    private long delay;
    private boolean fixedRate;
    private boolean daemon = true;
    private Timer timer;
    public TimerEndpoint(String fullURI, TimerComponent component, String timerName) {
        super(fullURI, component);
        this.timer = component.getTimer(this);
        this.timerName = timerName;
    }
    public TimerEndpoint(String endpointUri, Timer timer) {
        this(endpointUri);
        this.timer = timer;
    }
    public TimerEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        throw new RuntimeCamelException(""Cannot produce to a TimerEndpoint: "" + getEndpointUri());
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new TimerConsumer(this, processor);
    }
    public String getTimerName() {
        if (timerName == null) {
            timerName = getEndpointUri();
        }
        return timerName;
    }
    public void setTimerName(String timerName) {
        this.timerName = timerName;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public boolean isFixedRate() {
        return fixedRate;
    }
    public void setFixedRate(boolean fixedRate) {
        this.fixedRate = fixedRate;
    }
    public long getPeriod() {
        return period;
    }
    public void setPeriod(long period) {
        this.period = period;
    }
    public Date getTime() {
        return time;
    }
    public void setTime(Date time) {
        this.time = time;
    }
    public boolean isSingleton() {
        return true;
    }
    public Timer getTimer() {
        if (timer == null) {
            timer = new Timer();
        }
        return timer;
    }
    public void setTimer(Timer timer) {
        this.timer = timer;
    }
}
"
org.apache.camel.component.jpa.JpaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Map;
import javax.persistence.EntityManagerFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.ObjectHelper;
/**
 * A JPA Component
 *
 * @version $Revision$
 */
public class JpaComponent extends DefaultComponent<Exchange> {
    private EntityManagerFactory entityManagerFactory;
    public Component resolveComponent(CamelContext container, String uri) throws Exception {
        return null;
    }
    // Properties
    //-------------------------------------------------------------------------
    public EntityManagerFactory getEntityManagerFactory() {
        return entityManagerFactory;
    }
    public void setEntityManagerFactory(EntityManagerFactory entityManagerFactory) {
        this.entityManagerFactory = entityManagerFactory;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String path, Map options) throws Exception {
        JpaEndpoint endpoint = new JpaEndpoint(uri, this);
        // lets interpret the next string as a class
        if (path != null) {
            Class<?> type = ObjectHelper.loadClass(path);
            if (type != null) {
                endpoint.setEntityType(type);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.ExchangePattern,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.HashMap;
import java.util.Map;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlType;
/**
 * Represents the kind of message exchange pattern
 *
 * @version $Revision$
 */
@XmlType
@XmlEnum(String.class)
public enum ExchangePattern {
    InOnly, RobustInOnly, InOut, InOptionalOut, OutOnly, RobustOutOnly, OutIn, OutOptionalIn;
    protected static final Map<String, ExchangePattern> MAP = new HashMap<String, ExchangePattern>();
    /**
     * Returns the WSDL URI for this message exchange pattern
     */
    public String getWsdlUri() {
        switch (this) {
        case InOnly:
            return ""http://www.w3.org/ns/wsdl/in-only"";
        case InOptionalOut:
            return ""http://www.w3.org/ns/wsdl/in-optional-out"";
        case InOut:
            return ""http://www.w3.org/ns/wsdl/in-out"";
        case OutIn:
            return ""http://www.w3.org/ns/wsdl/out-in"";
        case OutOnly:
            return ""http://www.w3.org/ns/wsdl/out-only"";
        case OutOptionalIn:
            return ""http://www.w3.org/ns/wsdl/out-optional_in"";
        case RobustInOnly:
            return ""http://www.w3.org/ns/wsdl/robust-in-only"";
        case RobustOutOnly:
            return ""http://www.w3.org/ns/wsdl/robust-out-only"";
        default:
            throw new IllegalArgumentException(""Unknown message exchange pattern: "" + this);
        }
    }
    /**
     * Return true if there can be an IN message
     */
    public boolean isInCapable() {
        switch (this) {
        case OutOnly:
        case RobustOutOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Return true if there can be an OUT message
     */
    public boolean isOutCapable() {
        switch (this) {
        case InOnly:
        case RobustInOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Return true if there can be a FAULT message
     */
    public boolean isFaultCapable() {
        switch (this) {
        case InOnly:
        case OutOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Converts the WSDL URI into a {@link ExchangePattern} instance
     */
    public static ExchangePattern fromWsdlUri(String wsdlUri) {
        return MAP.get(wsdlUri);
    }
    public static ExchangePattern asEnum(String value) {
        try {
            return valueOf(value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Unknown message exchange pattern: "" + value);
        }
    }
    static {
        for (ExchangePattern mep : values()) {
            String uri = mep.getWsdlUri();
            MAP.put(uri, mep);
            String name = uri.substring(uri.lastIndexOf('/') + 1);
            MAP.put(""http://www.w3.org/2004/08/wsdl/"" + name, mep);
            MAP.put(""http://www.w3.org/2006/01/wsdl/"" + name, mep);
        }
    }
}
"
org.apache.camel.component.cxf.CxfSoapEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import javax.wsdl.Definition;
import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.xml.WSDLReader;
import javax.xml.namespace.QName;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.helpers.DOMUtils;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
/**
 * A CXF based SOAP endpoint which wraps an existing
 * endpoint with SOAP processing.
 */
public class CxfSoapEndpoint implements Endpoint {
    private final Endpoint endpoint;
    private Resource wsdl;
    private String serviceClass;
    private org.w3c.dom.Document description;
    private Definition definition;
    private QName serviceName;
    private QName endpointName;
    private Bus bus;
    private HeaderFilterStrategy headerFilterStrategy;
    public CxfSoapEndpoint(Endpoint endpoint) {
        this(endpoint, new CxfHeaderFilterStrategy());
    }
    public CxfSoapEndpoint(Endpoint endpoint, HeaderFilterStrategy headerFilterStrategy) {
        this.endpoint = endpoint;
        this.headerFilterStrategy = headerFilterStrategy;
    }
    protected Endpoint getInnerEndpoint() {
        return endpoint;
    }
    public boolean isSingleton() {
        return endpoint.isSingleton();
    }
    public String getEndpointUri() {
        return endpoint.getEndpointUri();
    }
    public Exchange createExchange() {
        return endpoint.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return endpoint.createExchange(exchange);
    }
    public CamelContext getCamelContext() {
        return endpoint.getCamelContext();
    }
    public Producer createProducer() throws Exception {
        return new CxfSoapProducer(this);
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new CxfSoapConsumer(this, processor);
    }
    public PollingConsumer createPollingConsumer() throws Exception {
        throw new UnsupportedOperationException();
    }
    public void configureProperties(Map options) {
    }
    public Resource getWsdl() {
        return wsdl;
    }
    public void setWsdl(Resource wsdl) {
        this.wsdl = wsdl;
    }
    public void setServiceClass(String serviceClass) {
        this.serviceClass = serviceClass;
    }
    public String getServiceClass() {
        return serviceClass;
    }
    public void setServiceName(String serviceName) {
        this.serviceName = QName.valueOf(serviceName);
    }
    public void setEndpointName(String endpointName) {
        this.endpointName = QName.valueOf(endpointName);
    }
    public QName getEndpointName() {
        return endpointName;
    }
    public void init() throws Exception {
        Assert.notNull(wsdl, ""soap.wsdl parameter must be set on the uri"");
        if (serviceName == null) {
            description = DOMUtils.readXml(wsdl.getInputStream());
            WSDLFactory wsdlFactory = WSDLFactory.newInstance();
            WSDLReader reader = wsdlFactory.newWSDLReader();
            reader.setFeature(""javax.wsdl.verbose"", false);
            definition = reader.readWSDL(wsdl.getURL().toString(), description);
            serviceName = (QName) definition.getServices().keySet().iterator().next();
        }
    }
    protected Bus getBus() {
        if (bus == null) {
            bus = BusFactory.newInstance().createBus();
        }
        return bus;
    }
    public Definition getDefinition() {
        return definition;
    }
    public QName getServiceName() {
        return serviceName;
    }
    public void setCamelContext(CamelContext context) {
        endpoint.setCamelContext(context);
    }
    @Deprecated
    public CamelContext getContext() {
        return getCamelContext();
    }
    @Deprecated
    public void setContext(CamelContext context) {
        setCamelContext(context);
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public boolean isLenientProperties() {
        return false;
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import java.util.List;
import org.apache.cxf.frontend.AbstractWSDLBasedEndpointFactory;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
/**
 *
 */
public class CxfEndpointBean extends AbstractWSDLBasedEndpointFactory {
    private List handlers;
    public CxfEndpointBean() {
        this(new ReflectionServiceFactoryBean());
    }
    public CxfEndpointBean(ReflectionServiceFactoryBean factory) {
        setServiceFactory(factory);
    }
    public List getHandlers() {
        return handlers;
    }
    public void setHandlers(List handlers) {
        this.handlers = handlers;
    }
}
"
org.apache.camel.impl.DefaultProducerTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link org.apache.camel.Message} instances in an
 * {@link org.apache.camel.Exchange} to an {@link org.apache.camel.Endpoint}.
 *
 * @version $Revision$
 */
public class DefaultProducerTemplate<E extends Exchange> extends ServiceSupport implements ProducerTemplate<E> {
    private CamelContext context;
    private final ProducerCache<E> producerCache = new ProducerCache<E>();
    private boolean useEndpointCache = true;
    private final Map<String, Endpoint<E>> endpointCache = new HashMap<String, Endpoint<E>>();
    private Endpoint<E> defaultEndpoint;
    public DefaultProducerTemplate(CamelContext context) {
        this.context = context;
    }
    public DefaultProducerTemplate(CamelContext context, Endpoint defaultEndpoint) {
        this(context);
        this.defaultEndpoint = defaultEndpoint;
    }
    public static DefaultProducerTemplate newInstance(CamelContext camelContext, String defaultEndpointUri) {
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, defaultEndpointUri);
        return new DefaultProducerTemplate(camelContext, endpoint);
    }
    public E send(String endpointUri, E exchange) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, exchange);
    }
    public E send(String endpointUri, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor);
    }
    public E send(String endpointUri, Processor processor, AsyncCallback callback) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor, callback);
    }
    public E send(String endpointUri, ExchangePattern pattern, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, pattern, processor);
    }
    public E send(Endpoint<E> endpoint, E exchange) {
        E convertedExchange = exchange;
        producerCache.send(endpoint, convertedExchange);
        return convertedExchange;
    }
    public E send(Endpoint<E> endpoint, Processor processor) {
        return producerCache.send(endpoint, processor);
    }
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        return producerCache.send(endpoint, processor, callback);
    }
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
        return producerCache.send(endpoint, pattern, processor);
    }
    public Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body) {
        E result = send(endpoint, pattern, createSetBodyProcessor(body));
        return extractResultBody(result, pattern);
    }
    public Object sendBody(Endpoint<E> endpoint, Object body) {
        E result = send(endpoint, createSetBodyProcessor(body));
        return extractResultBody(result);
    }
    public Object sendBody(String endpointUri, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, body);
    }
    public Object sendBody(String endpointUri, ExchangePattern pattern, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, pattern, body);
    }
    public Object sendBodyAndHeader(String endpointUri, final Object body, final String header,
            final Object headerValue) {
        return sendBodyAndHeader(resolveMandatoryEndpoint(endpointUri), body, header, headerValue);
    }
    public Object sendBodyAndHeader(Endpoint<E> endpoint, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result);
    }
    public Object sendBodyAndHeader(Endpoint<E> endpoint, ExchangePattern pattern, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result, pattern);
    }
    public Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result, pattern);
    }
    public Object sendBodyAndHeaders(String endpointUri, final Object body, final Map<String, Object> headers) {
        return sendBodyAndHeaders(resolveMandatoryEndpoint(endpointUri), body, headers);
    }
    public Object sendBodyAndHeaders(Endpoint<E> endpoint, final Object body, final Map<String, Object> headers) {
        E result = send(endpoint, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                for (Map.Entry<String, Object> header : headers.entrySet()) {
                    in.setHeader(header.getKey(), header.getValue());
                }
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }
    public Object sendBodyAndHeaders(String endpointUri, ExchangePattern pattern, Object body, Map<String, Object> headers) {
        return sendBodyAndHeaders(resolveMandatoryEndpoint(endpointUri), pattern, body, headers);
    }
    public Object sendBodyAndHeaders(Endpoint<E> endpoint, ExchangePattern pattern, final Object body, final Map<String, Object> headers) {
        E result = send(endpoint, pattern, new Processor() {
            public void process(Exchange exchange) throws Exception {
                Message in = exchange.getIn();
                for (Map.Entry<String, Object> header : headers.entrySet()) {
                    in.setHeader(header.getKey(), header.getValue());
                }
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    public E request(Endpoint<E> endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    public Object requestBody(Endpoint<E> endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    public Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    public E request(String endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    public Object requestBody(String endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    public Object requestBodyAndHeader(String endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    public Object requestBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers) {
        return requestBodyAndHeaders(resolveMandatoryEndpoint(endpointUri), body, headers);
    }
    public Object requestBodyAndHeaders(Endpoint<E> endpoint, final Object body, final Map<String, Object> headers) {
        return sendBodyAndHeaders(endpoint, ExchangePattern.InOut, body, headers);
    }
    // Methods using the default endpoint
    // -----------------------------------------------------------------------
    public Object sendBody(Object body) {
        return sendBody(getMandatoryDefaultEndpoint(), body);
    }
    public E send(E exchange) {
        return send(getMandatoryDefaultEndpoint(), exchange);
    }
    public E send(Processor processor) {
        return send(getMandatoryDefaultEndpoint(), processor);
    }
    public Object sendBodyAndHeader(Object body, String header, Object headerValue) {
        return sendBodyAndHeader(getMandatoryDefaultEndpoint(), body, header, headerValue);
    }
    public Object sendBodyAndHeaders(Object body, Map<String, Object> headers) {
        return sendBodyAndHeaders(getMandatoryDefaultEndpoint(), body, headers);
    }
    // Properties
    // -----------------------------------------------------------------------
    public Producer<E> getProducer(Endpoint<E> endpoint) {
        return producerCache.getProducer(endpoint);
    }
    public CamelContext getContext() {
        return context;
    }
    public Endpoint<E> getDefaultEndpoint() {
        return defaultEndpoint;
    }
    public void setDefaultEndpoint(Endpoint<E> defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
    /**
     * Sets the default endpoint to use if none is specified
     */
    public void setDefaultEndpointUri(String endpointUri) {
        setDefaultEndpoint(getContext().getEndpoint(endpointUri));
    }
    public boolean isUseEndpointCache() {
        return useEndpointCache;
    }
    public void setUseEndpointCache(boolean useEndpointCache) {
        this.useEndpointCache = useEndpointCache;
    }
    public <T extends Endpoint<?>> T getResolvedEndpoint(String endpointUri, Class<T> expectedClass) {
        Endpoint<?> e = null;
        synchronized (endpointCache) {
            e = endpointCache.get(endpointUri);
        }
        if (e != null && expectedClass.isAssignableFrom(e.getClass())) {
            return expectedClass.asSubclass(expectedClass).cast(e);
        }
        return null;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected Processor createBodyAndHeaderProcessor(final Object body, final String header, final Object headerValue) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setHeader(header, headerValue);
                in.setBody(body);
            }
        };
    }
    protected Processor createSetBodyProcessor(final Object body) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
            }
        };
    }
    protected Endpoint resolveMandatoryEndpoint(String endpointUri) {
        Endpoint endpoint = null;
        if (isUseEndpointCache()) {
            synchronized (endpointCache) {
                endpoint = endpointCache.get(endpointUri);
                if (endpoint == null) {
                    endpoint = context.getEndpoint(endpointUri);
                    if (endpoint != null) {
                        endpointCache.put(endpointUri, endpoint);
                    }
                }
            }
        } else {
            endpoint = context.getEndpoint(endpointUri);
        }
        if (endpoint == null) {
            throw new NoSuchEndpointException(endpointUri);
        }
        return endpoint;
    }
    protected Endpoint<E> getMandatoryDefaultEndpoint() {
        Endpoint<E> answer = getDefaultEndpoint();
        ObjectHelper.notNull(answer, ""defaultEndpoint"");
        return answer;
    }
    protected void doStart() throws Exception {
        producerCache.start();
    }
    protected void doStop() throws Exception {
        producerCache.stop();
        endpointCache.clear();
    }
    /**
     * Extracts the body from the given result.
     *
     * @param result   the result
     * @return  the result, can be <tt>null</tt>.
     */
    protected Object extractResultBody(E result) {
        return extractResultBody(result, null);
    }
    /**
     * Extracts the body from the given result.
     * <p/>
     * If the exchange pattern is provided it will try to honor it and retrive the body
     * from either IN or OUT according to the pattern.
     *
     * @param result   the result
     * @param pattern  exchange pattern if given, can be <tt>null</tt>
     * @return  the result, can be <tt>null</tt>.
     */
    protected Object extractResultBody(E result, ExchangePattern pattern) {
        Object answer = null;
        if (result != null) {
            // rethrow if there was an exception
            if (result.getException() != null) {
                throw wrapRuntimeCamelException(result.getException());
            }
            // result could have a fault message
            if (hasFaultMessage(result)) {
                return result.getFault().getBody();
            }
            // okay no fault then return the response according to the pattern
            // try to honor pattern if provided
            boolean notOut = pattern != null && !pattern.isOutCapable();
            boolean hasOut = result.getOut(false) != null;
            if (hasOut && !notOut) {
                answer = result.getOut().getBody();
            } else {
                answer = result.getIn().getBody();
            }
        }
        return answer;
    }
    protected boolean hasFaultMessage(E result) {
        Message faultMessage = result.getFault(false);
        if (faultMessage != null) {
            Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                return true;
            }
        }
        return false;
    }
}"
org.apache.camel.component.jmx.JMXComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import java.util.Map;
import javax.management.MBeanServer;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/jmx.html"">JMX Component</a>
 * for monitoring JMX attributes
 *
 * @version $Revision$
 */
public class JMXComponent extends DefaultComponent<JMXExchange> {
    private MBeanServer mbeanServer;
    public JMXComponent() {
    }
    public JMXComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<JMXExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        JMXEndpoint result = new JMXEndpoint(remaining, this);
        setProperties(result, parameters);
        result.setMbeanServer(getMbeanServer());
        return result;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.builder.BinaryPredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A useful base class for {@link Predicate} implementations
 * 
 * @version $Revision$
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {
    private final Expression<E> left;
    private final Expression<E> right;
    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        this.left = left;
        this.right = right;
    }
    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }
    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }
    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(text + assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }
    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);
    protected abstract String getOperationText();
    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <""
               + rightValue + "">"";
    }
}
"
org.apache.camel.ExpectedBodyTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if the body could not be converted to the required type
 * 
 * @version $Revision$
 */
public class ExpectedBodyTypeException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Class expectedBodyType;
    public ExpectedBodyTypeException(Exchange exchange, Class expectedBodyType) {
        super(""Could not extract IN message body as type: "" + expectedBodyType + "" body is: ""
              + exchange.getIn().getBody());
        this.exchange = exchange;
        this.expectedBodyType = expectedBodyType;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public Class getExpectedBodyType() {
        return expectedBodyType;
    }
}
"
org.apache.camel.component.mock.AssertionClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.builder.ValueBuilder;
import static org.apache.camel.builder.ExpressionBuilder.bodyExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
import static org.apache.camel.builder.ExpressionBuilder.propertyExpression;
/**
 * A builder of assertions on message exchanges
 *
 * @version $Revision$
 */
public abstract class AssertionClause implements Runnable {
    private List<Predicate<Exchange>> predicates = new ArrayList<Predicate<Exchange>>();
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Adds the given predicate to this assertion clause
     */
    public AssertionClause predicate(Predicate<Exchange> predicate) {
        addPredicate(predicate);
        return this;
    }
    public ExpressionClause<AssertionClause> predicate() {
        ExpressionClause<AssertionClause> clause = new ExpressionClause<AssertionClause>(this);
        addPredicate(clause);
        return clause;
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public ValueBuilder<Exchange> header(String name) {
        Expression<Exchange> expression = headerExpression(name);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for property on an exchange
     */
    public ValueBuilder<Exchange> property(String name) {
        Expression<Exchange> expression = propertyExpression(name);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public PredicateValueBuilder body() {
        Expression<Exchange> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder bodyAs(Class<T> type) {
        Expression<Exchange> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public PredicateValueBuilder outBody() {
        Expression<Exchange> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder outBody(Class<T> type) {
        Expression<Exchange> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Performs any assertions on the given exchange
     */
    protected void applyAssertionOn(MockEndpoint endpoint, int index, Exchange exchange) {
        for (Predicate<Exchange> predicate : predicates) {
            predicate.assertMatches(endpoint.getEndpointUri() + "" "", exchange);
        }
    }
    protected void addPredicate(Predicate<Exchange> predicate) {
        predicates.add(predicate);
    }
    /**
     * Public class needed for fluent builders
     */
    public class PredicateValueBuilder extends ValueBuilder<Exchange> {
        public PredicateValueBuilder(Expression<Exchange> expression) {
            super(expression);
        }
        protected Predicate<Exchange> onNewPredicate(Predicate<Exchange> predicate) {
            addPredicate(predicate);
            return predicate;
        }
    }
}
"
org.apache.camel.component.cxf.util.UriUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
public final class UriUtils {
    private UriUtils() {
        // not constructred
    }
    static URL getWsdlUrl(final URI uri) throws MalformedURLException {
        URL wsdlUrl = null;
        if (uri.getScheme().equals(CxfConstants.PROTOCOL_NAME_RES)) {       
            if (uri.getPath() != null) {
                String path = uri.isAbsolute() ? getRelativePath(uri) : uri.getPath();
                wsdlUrl = ClassLoaderUtils.getResource(path, UriUtils.class);
            }
        } else {
            wsdlUrl = new URL(uri.getScheme(), uri.getHost(), uri.getPort(), uri.getPath());
        }
        return wsdlUrl;
    }
    private static String getRelativePath(URI uri) {
        URI base = null;
        try {
            base = new URI(CxfConstants.PROTOCOL_NAME_RES, """", ""/"", """");
        } catch (URISyntaxException e) {
            // this shouldn't fail
            e.printStackTrace();
        }
        return base.relativize(uri).getPath();
    }
}
"
org.apache.camel.builder.xml.ResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import org.apache.camel.Message;
/**
 * A strategy for handling XSLT results
 *
 * @version $Revision$
 */
public interface ResultHandler {
    Result getResult();
    void setBody(Message in);
}
"
org.apache.camel.component.jhc.AsyncResponseHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
public interface AsyncResponseHandler {
    void sendResponse(HttpResponse response) throws IOException, HttpException;
}
"
org.apache.camel.component.cxf.transport.spring.CamelDestinationDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.apache.camel.component.cxf.transport.CamelDestination;
public class CamelDestinationDefinitionParser extends AbstractCamelContextBeanDefinitionParser {
    public CamelDestinationDefinitionParser() {
        super();
        setBeanClass(CamelDestination.class);
    }
}
"
org.apache.camel.component.bean.ConstantBeanHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.util.CamelContextHelper;
/**
 * A constant (singleton) bean implementation of {@link BeanHolder}
 *
 * @version $Revision$
 */
public class ConstantBeanHolder implements BeanHolder {
    private final Object bean;
    private Processor processor;
    private BeanInfo beanInfo;
    public ConstantBeanHolder(Object bean, BeanInfo beanInfo) {
        this.bean = bean;
        this.beanInfo = beanInfo;
        try {
            this.processor = CamelContextHelper.convertTo(beanInfo.getCamelContext(), Processor.class, bean);
        } catch (NoTypeConversionAvailableException ex) {
            this.processor = null;
        }
    }
    public ConstantBeanHolder(Object bean, CamelContext context) {
        this(bean, new BeanInfo(context, bean.getClass()));
    }
    public ConstantBeanHolder(Object bean, CamelContext context, ParameterMappingStrategy parameterMappingStrategy) {
        this(bean, new BeanInfo(context, bean.getClass(), parameterMappingStrategy));
    }
    @Override
    public String toString() {
        return bean.toString();
    }
    public Object getBean()  {
        return bean;
    }
    public Processor getProcessor() {
        return processor;
    }
    public BeanInfo getBeanInfo() {
        return beanInfo;
    }
}
"
org.apache.camel.impl.DefaultProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Producer;
/**
 * A default implementation of @{link Producer} for implementation inheritence
 *
 * @version $Revision$
 */
public abstract class DefaultProducer<E extends Exchange> extends ServiceSupport implements Producer<E> {
    private Endpoint<E> endpoint;
    public DefaultProducer(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""Producer["" + endpoint.getEndpointUri() + ""]"";
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public E createExchange() {
        return endpoint.createExchange();
    }
    public E createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public E createExchange(E exchange) {
        return endpoint.createExchange(exchange);
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.builder.ProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
/**
 * A builder of a number of different {@link Processor} implementations
 *
 * @version $Revision$
 */
public final class ProcessorBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProcessorBuilder() {
    }
    /**
     * Creates a processor which sets the body of the IN message to the value of the expression
     */
    public static Processor setBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getIn().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the OUT message to the value of the expression
     */
    public static Processor setOutBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getOut().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setOutBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the FAULT message to the value of the expression
     */
    public static Processor setFaultBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getFault().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setFaultBody("" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the IN message
     */
    public static Processor setHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getIn().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the OUT message
     */
    public static Processor setOutHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getOut().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setOutHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the FAULT message
     */
    public static Processor setFaultHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getFault().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setFaultHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the property on the exchange
     */
    public static Processor setProperty(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.setProperty(name, value);
            }
            @Override
            public String toString() {
                return ""setProperty("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Removes the header on the IN message
     */
    public static Processor removeHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the header on the FAULT message
     */
    public static Processor removeFaultHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getFault().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeFaultHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the property on the exchange
     */
    public static Processor removeProperty(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.removeProperty(name);
            }
            @Override
            public String toString() {
                return ""removeProperty("" + name +  "")"";
            }
        };
    }
    /**
     * Throws an exception
     */
    public static Processor throwException(final Exception ex) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                throw ex;
            }
            @Override
            public String toString() {
                return ""throwException("" + ex.toString() +  "")"";
            }
        };
    }
}
"
org.apache.camel.component.restlet.RestletBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import java.io.IOException;
import org.apache.camel.Exchange;
import org.restlet.data.Request;
import org.restlet.data.Response;
/**
 * Interface for converting between Camel message and Restlet message.
 * 
 * @version $Revision$
 */
public interface RestletBinding {
    /**
     * Populate Restlet request from Camel message
     *  
     * @param exchange message to be copied from 
     * @param response to be populated
     */
    void populateRestletResponseFromExchange(Exchange exchange,
            Response response);
    /**
     * Populate Camel message from Restlet request
     * 
     * @param request message to be copied from
     * @param exchange to be populated
     * @throws Exception 
     */
    void populateExchangeFromRestletRequest(Request request, 
            Exchange exchange) throws Exception;
    /**
     * Populate Restlet Request from Camel message
     * 
     * @param request to be populated
     * @param exchange message to be copied from
     */
    void populateRestletRequestFromExchange(Request request, Exchange exchange);
    /**
     * Populate Camel message from Restlet response
     * 
     * @param exchange to be populated
     * @param response message to be copied from
     * @throws IOException 
     */
    void populateExchangeFromRestletResponse(Exchange exchange,
            Response response) throws IOException;
}
"
org.apache.camel.impl.MessageSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.UuidGenerator;
/**
 * A base class for implementation inheritence providing the core
 * {@link Message} body handling features but letting the derived class deal
 * with headers.
 *
 * Unless a specific provider wishes to do something particularly clever with
 * headers you probably want to just derive from {@link DefaultMessage}
 *
 * @version $Revision$
 */
public abstract class MessageSupport implements Message {
    private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator();
    private Exchange exchange;
    private Object body;
    private String messageId;
    public Object getBody() {
        if (body == null) {
            body = createBody();
        }
        return body;
    }
    @SuppressWarnings({""unchecked"" })
    public <T> T getBody(Class<T> type) {
        return getBody(type, getBody());
    }
    protected <T> T getBody(Class<T> type, Object body) {
        Exchange e = getExchange();
        if (e != null) {
            CamelContext camelContext = e.getContext();
            if (camelContext != null) {
                TypeConverter converter = camelContext.getTypeConverter();
                try {
                    // lets first try converting the message itself first
                    // as for some types like InputStream v Reader its more efficient to do the transformation
                    // from the Message itself as its got efficient implementations of them, before trying the
                    // payload
                    return converter.convertTo(type, e, body);
                } catch (NoTypeConversionAvailableException ex) {
                    // ignore
                }
                return converter.convertTo(type, this);
            }
        }
        return (T)getBody();
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public <T> void setBody(Object value, Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            T v = e.getContext().getTypeConverter().convertTo(type, e, value);
            if (v != null) {
                value = v;
            }
        }
        setBody(value);
    }
    public Message copy() {
        Message answer = newInstance();
        answer.copyFrom(this);
        return answer;
    }
    public void copyFrom(Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
        getAttachments().putAll(that.getAttachments());
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    /**
     * Returns a new instance
     */
    public abstract Message newInstance();
    /**
     * A factory method to allow a provider to lazily create the message body
     * for inbound messages from other sources
     *
     * @return the value of the message body or null if there is no value
     *         available
     */
    protected Object createBody() {
        return null;
    }
    public String getMessageId() {
        if (messageId == null) {
            messageId = createMessageId();
        }
        return this.messageId;
    }
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
    /**
     * Lets allow implementations to auto-create a messageId
     */
    protected String createMessageId() {
        return DEFALT_ID_GENERATOR.generateId();
    }
}
"
org.apache.camel.component.file.strategy.FileExpressionRenamer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.Expression;
import org.apache.camel.component.file.FileExchange;
/**
 * File renamed using {@link Expression} to dynamically compute the file name.
 * <p/>
 * If most cases the {@link org.apache.camel.language.simple.FileLanguage FileLanguage} is used to
 * create the expressions.
 */
public class FileExpressionRenamer implements FileRenamer {
    private static final boolean ON_WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
    private Expression expression;
    public File renameFile(FileExchange exchange, File file) {
        if (expression == null) {
            throw new IllegalArgumentException(""Expression is not set"");
        }
        File parent = file.getParentFile();
        Object result = expression.evaluate(exchange);
        String name = exchange.getContext().getTypeConverter().convertTo(String.class, result);
        if (ON_WINDOWS && (name.indexOf("":"") >= 0 || name.startsWith(""//""))) {
            return new File(name);
        }
        return new File(parent, name);
    }
    public Expression getExpression() {
        return expression;
    }
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
}
"
org.apache.camel.component.jms.CamelMessageListener,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.MessageListener;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.impl.DefaultProducerTemplate;
import org.apache.camel.impl.ProducerTemplateProcessor;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A JMS {@link MessageListener} which converts an incoming JMS message into a Camel message {@link Exchange} then
 * processing it by Camel; either using a custom {@link Processor} or if you use one of the static <code>newInstance()</code>
 * methods such as {@link #newInstance(org.apache.camel.CamelContext, String)} or
 * {@link #newInstance(org.apache.camel.CamelContext, org.apache.camel.ProducerTemplate)}
 * you can send the message exchange into a Camel endpoint for processing.
 *
 * @version $Revision$
 */
public class CamelMessageListener implements MessageListener, Processor {
    private final CamelContext camelContext;
    private final Processor processor;
    private JmsBinding binding = new JmsBinding();
    private ExchangePattern pattern = ExchangePattern.InOnly;
    public CamelMessageListener(CamelContext camelContext, Processor processor) {
        this.camelContext = camelContext;
        this.processor = processor;
        ObjectHelper.notNull(processor, ""processor"");
    }
    /**
     * Creates a new CamelMessageListener which will invoke a Camel endpoint
     *
     * @param camelContext the context to use
     * @param endpointUri  the endpoint to invoke with the JMS message {@link Exchange}
     * @return a newly created JMS MessageListener
     */
    public static CamelMessageListener newInstance(CamelContext camelContext, String endpointUri) {
        DefaultProducerTemplate producerTemplate = DefaultProducerTemplate.newInstance(camelContext, endpointUri);
        return newInstance(camelContext, producerTemplate);
    }
    /**
     * Creates a new CamelMessageListener which will invoke the default Camel endpoint of the given
     * {@link ProducerTemplate}
     *
     * @param camelContext the context to use
     * @param producerTemplate  the template used to send the exchange
     * @return a newly created JMS MessageListener
     */
    public static CamelMessageListener newInstance(CamelContext camelContext, ProducerTemplate producerTemplate) {
        return new CamelMessageListener(camelContext, new ProducerTemplateProcessor(producerTemplate));
    }
    /**
     * Processes the incoming JMS message
     */
    public void onMessage(Message message) {
        try {
            Exchange exchange = createExchange(message);
            process(exchange);
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    /**
     * Processes the Camel message {@link Exchange}
     */
    public void process(Exchange exchange) throws Exception {
        ObjectHelper.notNull(exchange, ""exchange"");
        processor.process(exchange);
    }
    // Properties
    //-------------------------------------------------------------------------
    public JmsBinding getBinding() {
        return binding;
    }
    /**
     * Sets the JMS binding used to adapt the incoming JMS message into a Camel message {@link Exchange}
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public ExchangePattern getPattern() {
        return pattern;
    }
    /**
     * Sets the message exchange pattern that will be used on the Camel message {@link Exchange}
     */
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * Returns a newly created Camel message {@link Exchange} from an inbound JMS message
     */
    protected Exchange createExchange(Message message) {
        return new JmsExchange(camelContext, pattern, binding, message);
    }
}
"
org.apache.camel.component.xmpp.XmppEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Iterator;
import org.apache.camel.CamelException;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.AccountManager;
import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smackx.muc.MultiUserChat;
/**
 * A XMPP Endpoint
 *
 * @version $Revision:520964 $
 */
public class XmppEndpoint extends DefaultEndpoint<XmppExchange> {
    private static final transient Log LOG = LogFactory.getLog(XmppEndpoint.class);
    private XmppBinding binding;
    private XMPPConnection connection;
    private String host;
    private int port;
    private String user;
    private String password;
    private String resource = ""Camel"";
    private boolean login = true;
    private boolean createAccount;
    private String room;
    private String participant;
    private String nickname;
    private String serviceName;
    public XmppEndpoint(String uri, XmppComponent component) {
        super(uri, component);
        binding = new XmppBinding(component.getHeaderFilterStrategy());
    }
    public XmppEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<XmppExchange> createProducer() throws Exception {
        if (room != null) {
            return createGroupChatProducer();
        } else {
            if (participant == null) {
                throw new IllegalArgumentException(""No room or participant configured on this endpoint: ""
                                                   + this);
            }
            return createPrivateChatProducer(participant);
        }
    }
    public Producer<XmppExchange> createGroupChatProducer() throws Exception {
        return new XmppGroupChatProducer(this);
    }
    public Producer<XmppExchange> createPrivateChatProducer(String participant) throws Exception {
        return new XmppPrivateChatProducer(this, participant);
    }
    public Consumer<XmppExchange> createConsumer(Processor processor) throws Exception {
        return new XmppConsumer(this, processor);
    }
    @Override
    public XmppExchange createExchange(ExchangePattern pattern) {
        return new XmppExchange(getCamelContext(), pattern, getBinding());
    }
    public XmppExchange createExchange(Message message) {
        return new XmppExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public XmppBinding getBinding() {
        if (binding == null) {
            binding = new XmppBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from an XMPP
     * message
     */
    public void setBinding(XmppBinding binding) {
        this.binding = binding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getUser() {
        return user;
    }
    public void setUser(String user) {
        this.user = user;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getResource() {
        return resource;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public boolean isLogin() {
        return login;
    }
    public void setLogin(boolean login) {
        this.login = login;
    }
    public boolean isCreateAccount() {
        return createAccount;
    }
    public void setCreateAccount(boolean createAccount) {
        this.createAccount = createAccount;
    }
    public String getRoom() {
        return room;
    }
    public void setRoom(String room) {
        this.room = room;
    }
    public String getParticipant() {
        return participant;
    }
    public void setParticipant(String participant) {
        this.participant = participant;
    }
    public String getNickname() {
        return nickname != null ? nickname : getUser();
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public void setServiceName(String serviceName) {
        this.serviceName = serviceName;
    }
    public String getServiceName() {
        return serviceName;
    }    
    public XMPPConnection getConnection() throws XMPPException {
        if (connection == null) {
            connection = createConnection();
        }
        return connection;
    }
    public void setConnection(XMPPConnection connection) {
        this.connection = connection;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected XMPPConnection createConnection() throws XMPPException {
        XMPPConnection connection;
        if (port > 0) {            
            if (getServiceName() == null) {
                connection = new XMPPConnection(new ConnectionConfiguration(host, port));
            } else {
                connection = new XMPPConnection(new ConnectionConfiguration(host, port, getServiceName()));
            }
        } else {
            connection = new XMPPConnection(host);
        }
        connection.connect();
        if (login && !connection.isAuthenticated()) {
            if (user != null) {
                LOG.info(""Logging in to XMPP as user: "" + user + "" on connection: "" + connection);
                if (password == null) {
                    LOG.warn(""No password configured for user: "" + user);
                }
                if (createAccount) {
                    AccountManager accountManager = new AccountManager(connection);
                    accountManager.createAccount(user, password);
                }
                if (resource != null) {
                    connection.login(user, password, resource);
                } else {
                    connection.login(user, password);
                }
            } else {
                LOG.info(""Logging in anonymously to XMPP on connection: "" + connection);
                connection.loginAnonymously();
            }
            // presence is not needed to be sent after login
        }
        return connection;
    }
    /*
     * If there is no ""@"" symbol in the room, find the chat service JID and
     * return fully qualified JID for the room as room@conference.server.domain
     */
    public String resolveRoom() throws XMPPException, CamelException {
        if (room == null) {
            throw new IllegalArgumentException(""room is not specified"");
        }
        if (room.indexOf('@', 0) != -1) {
            return room;
        }
        XMPPConnection conn = getConnection();
        Iterator<String> iterator = MultiUserChat.getServiceNames(conn).iterator();
        if (!iterator.hasNext()) {
            throw new CamelException(""Can not find Multi User Chat service"");
        }
        String chatServer = iterator.next();
        if (LOG.isInfoEnabled()) {
            LOG.info(""Detected chat server: "" + chatServer);
        }
        return room + ""@"" + chatServer;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.AbstractCamelContextBeanDefinitionParaser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.StringUtils;
/**
 * This BeanDefinition paraser help to inject the camel context into the beans
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class AbstractCamelContextBeanDefinitionParaser extends AbstractSingleBeanDefinitionParser {
    private static final String DEFAULT_CAMEL_CONTEXT_NAME = ""camelContext"";
    private String getContextId(String contextId) {
        if (ObjectHelper.isNullOrBlank(contextId)) {
            //Set the contextId default value here
            return DEFAULT_CAMEL_CONTEXT_NAME;
        } else {
            return contextId;
        }
    }
    protected void mapToProperty(BeanDefinitionBuilder bean, String propertyName, String val) {
        if (ID_ATTRIBUTE.equals(propertyName)) {
            return;
        }
        if (StringUtils.hasText(val)) {
            if (val.startsWith(""#"")) {
                bean.addPropertyReference(propertyName, val.substring(1));
            } else {
                bean.addPropertyValue(propertyName, val);
            }
        }
    }
    protected void wireCamelContext(BeanDefinitionBuilder bean, String camelContextId) {
        bean.addPropertyReference(""camelContext"", camelContextId);
    }
    protected void parseAttributes(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        NamedNodeMap atts = element.getAttributes();
        for (int i = 0; i < atts.getLength(); i++) {
            Attr node = (Attr) atts.item(i);
            String val = node.getValue();
            String name = node.getLocalName();
            if (name.equals(""requestChannel"") || name.equals(""replyChannel"")) {
                bean.addPropertyReference(name, val);
            } else {
                mapToProperty(bean, name, val);
            }
        }
    }
    protected void parseCamelContext(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        NodeList children = element.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                String name = n.getLocalName();
                if (""camelContext"".equals(name)) {
                    // Parser the camel context
                    BeanDefinition bd = ctx.getDelegate().parseCustomElement((Element)n);
                    // Get the inner camel context id
                    String contextId = (String)bd.getPropertyValues().getPropertyValue(""id"").getValue();
                    wireCamelContext(bean, getContextId(contextId));
                } else if (""camelContextRef"".equals(name)) {
                    String contextId = n.getTextContent();
                    wireCamelContext(bean, getContextId(contextId));
                }
            }
        }
    }
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        parseAttributes(element, ctx, bean);
        parseCamelContext(element, ctx, bean);
    }
}
"
org.apache.camel.component.restlet.RestletEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import java.net.URI;
import java.util.Map;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.util.URISupport;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
import org.restlet.data.Method;
/**
 * Represents a <a href=""http://www.restlet.org/""> endpoint</a>
 *
 * @version $Revision$
 */
public class RestletEndpoint extends DefaultEndpoint {
    private static final int DEFAULT_PORT = 80;
    private static final String DEFAULT_PROTOCOL = ""http"";
    private static final String DEFAULT_HOST = ""localhost"";
    private Method restletMethod = Method.GET;
    private String protocol = DEFAULT_PROTOCOL;
    private String host = DEFAULT_HOST;
    private int port = DEFAULT_PORT;
    private String uriPattern;
    private RestletBinding restletBinding;
    private Map<String, String> realm;
    public RestletEndpoint(RestletComponent component, String remaining, 
            Map<String, String> parameters, RestletBinding restletBinding) throws Exception {
        super(remaining, component);
        this.restletBinding = restletBinding;
        URI u = new URI(UnsafeUriCharactersEncoder.encode(remaining));
        protocol = u.getScheme();
        uriPattern = u.getPath();
        if (parameters.size() > 0) {
            uriPattern = uriPattern + ""?"" + URISupport.createQueryString(parameters);
        }
        host = u.getHost();
        if (u.getPort() > 0) {
            port = u.getPort();
        }
    }
    public boolean isSingleton() {
        return true;
    }
    @Override 
    public boolean isLenientProperties() {
        // true to allow dynamic URI options to be configured and passed to external system.
        return true;
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new RestletConsumer(this, processor);
    }
    public Producer createProducer() throws Exception {
        return new RestletProducer(this);
    }
    /**
     * @param restletConsumer
     */
    public void connect(RestletConsumer restletConsumer) throws Exception {
        ((RestletComponent)getComponent()).connect(restletConsumer);
    }
    /**
     * @param restletConsumer
     */
    public void disconnect(RestletConsumer restletConsumer) throws Exception {
        ((RestletComponent)getComponent()).disconnect(restletConsumer);        
    }
    /**
     * @return the protocol
     */
    public String getProtocol() {
        return protocol;
    }
    /**
     * @return the host
     */
    public String getHost() {
        return host;
    }
    /**
     * @return the port
     */
    public int getPort() {
        return port;
    }
    /**
     * @return the uriPattern
     */
    public String getUriPattern() {
        return uriPattern;
    }
    /**
     * @return the restletBinding
     */
    public RestletBinding getRestletBinding() {
        return restletBinding;
    }
    /**
     * @param restletMethod the restletMethod to set
     */
    public void setRestletMethod(Method restletMethod) {
        this.restletMethod = restletMethod;
    }
    /**
     * @return the restletMethod
     */
    public Method getRestletMethod() {
        return restletMethod;
    }
    /**
     * @param realm
     */
    public void setRealm(Map<String, String> realm) {
        this.realm = realm;
    }
    /**
     * @return the realm
     */
    public Map<String, String> getRealm() {
        return realm;
    }
}
"
org.apache.camel.component.jhc.JhcHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
/**
 * 
 * @version $Revision$
 */
public class JhcHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
    public JhcHeaderFilterStrategy() {
        initialize();
    }
    protected void initialize() {
        // We could import filters from http component but that also means
        // a new dependency on camel-http
        getOutFilter().add(""content-length"");
        getOutFilter().add(""content-type"");
        getOutFilter().add(JhcProducer.HTTP_RESPONSE_CODE);
        setIsLowercase(true);
        // filter headers begin with ""org.apache.camel""
        setOutFilterPattern(""(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*"");   
    }
}
"
org.apache.camel.bam.ActivityLifecycle,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
/**
 * @version $Revision$
 */
public enum ActivityLifecycle {
    Started, Completed
}
"
org.apache.camel.component.cxf.util.Dummy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
// Dummy class for setting service class
public interface Dummy {
}
"
org.apache.camel.component.cxf.transport.spring.AbstractCamelContextBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.configuration.spring.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
public class AbstractCamelContextBeanDefinitionParser extends AbstractBeanDefinitionParser {
    private static final String DEFAULT_CAMEL_CONTEXT_NAME = ""camelContext"";
    private String getContextId(String contextId) {
        if (ObjectHelper.isEmpty(contextId)) {
            //Set the contextId default value here
            return DEFAULT_CAMEL_CONTEXT_NAME;
        } else {
            return contextId;
        }
    }
    protected void wireCamelContext(BeanDefinitionBuilder bean, String camelContextId) {
        bean.addPropertyReference(""camelContext"", camelContextId);
    }
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        // Parser the id attribute
        bean.setAbstract(true);
        NodeList children = element.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                String name = n.getLocalName();
                if (""camelContext"".equals(name)) {
                    // Parser the camel context
                    BeanDefinition bd = ctx.getDelegate().parseCustomElement((Element)n);
                    // Get the inner camel context id
                    String contextId = (String)bd.getPropertyValues().getPropertyValue(""id"").getValue();
                    wireCamelContext(bean, getContextId(contextId));
                } else if (""camelContextRef"".equals(name)) {
                    String contextId = n.getTextContent();
                    wireCamelContext(bean, getContextId(contextId));
                }
            }
        }
    }
}
"
org.apache.camel.component.xmpp.XmppGroupChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.SmackConfiguration;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smackx.muc.DiscussionHistory;
import org.jivesoftware.smackx.muc.MultiUserChat;
/**
 * @version $Revision$
 */
public class XmppGroupChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppGroupChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String room;
    private MultiUserChat chat;
    public XmppGroupChatProducer(XmppEndpoint endpoint) throws XMPPException, CamelException {
        super(endpoint);
        this.endpoint = endpoint;
        this.room = endpoint.resolveRoom();
        if (room == null) {
            throw new IllegalArgumentException(""No room property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(room);
        message.setFrom(endpoint.getUser());
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Sending XMPP message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        if (chat == null) {
            chat = new MultiUserChat(endpoint.getConnection(), room);
            DiscussionHistory history = new DiscussionHistory();
            history.setMaxChars(0); // we do not want any historical messages
            chat.join(this.endpoint.getNickname(), null, history, SmackConfiguration.getPacketReplyTimeout());
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        if (chat != null) {
            chat.leave();
            chat = null;
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public MultiUserChat getChat() {
        return chat;
    }
    public void setChat(MultiUserChat chat) {
        this.chat = chat;
    }
    public String getRoom() {
        return room;
    }
}
"
org.apache.camel.spring.util.SimpleRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.util.ObjectHelper;
/**
 * A simple {@link RouteBuilder} which can be configured directly with one or more from URIs, zero or more to URIs
 * and an optional bean processing step.
 *
 * @version $Revision$
 */
public class SimpleRouteBuilder extends RouteBuilder {
    private List<String> fromUris = new ArrayList<String>();
    private List<String> toUris = new ArrayList<String>();
    private Class beanType;
    private String beanClass;
    private String beanRef;
    private String beanMethod;
    public void configure() throws Exception {
        if (fromUris.isEmpty()) {
            throw new IllegalArgumentException(""the fromUris property must contain at least one valid URI"");
        }
        for (String fromUri : fromUris) {
            ProcessorType route = from(fromUri);
            addBeanCall(route);
            for (String toUri : toUris) {
                route = route.to(toUri);
            }
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public void setFromUri(String uri) {
        setFromUris(singletonList(uri));
    }
    public void setToUri(String uri) {
        setToUris(singletonList(uri));
    }
    public List<String> getFromUris() {
        return fromUris;
    }
    public void setFromUris(List<String> fromUris) {
        this.fromUris = fromUris;
    }
    public List<String> getToUris() {
        return toUris;
    }
    public void setToUris(List<String> toUris) {
        this.toUris = toUris;
    }
    public String getBeanClass() {
        return beanClass;
    }
    public void setBeanClass(String beanClass) {
        this.beanClass = beanClass;
    }
    public String getBeanRef() {
        return beanRef;
    }
    public void setBeanRef(String beanRef) {
        this.beanRef = beanRef;
    }
    public Class getBeanType() {
        if (beanType == null) {
            if (beanClass != null) {
                beanType = ObjectHelper.loadClass(beanClass, getClass().getClassLoader());
            }
        }
        return beanType;
    }
    public void setBeanType(Class beanType) {
        this.beanType = beanType;
    }
    public String getBeanMethod() {
        return beanMethod;
    }
    public void setBeanMethod(String beanMethod) {
        this.beanMethod = beanMethod;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void addBeanCall(ProcessorType route) {
        Class type = getBeanType();
        if (type != null) {
            if (beanMethod != null) {
                route = route.bean(type, beanMethod);
            } else {
                route = route.bean(type);
            }
        } else if (beanRef != null) {
            if (beanMethod != null) {
                route = route.beanRef(beanRef, beanMethod);
            } else {
                route = route.beanRef(beanRef);
            }
        }
    }
    protected List<String> singletonList(String value) {
        List<String> uris = new ArrayList<String>();
        uris.add(value);
        return uris;
    }
}
"
org.apache.camel.component.jpa.Consumed,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation to mark a method to be invoked when an entity bean has been succesfully processed
 * by a Camel consumer, so that it can be updated in some way to remove it from the query set.
 * <p/>
 * For example a method may be marked to set an active flag to false or to update some status value to the next step in a workflow
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD })
public @interface Consumed {
}
"
org.apache.camel.component.jms.JmsExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents an {@link Exchange} for working with JMS messages while exposing the inbound and outbound JMS {@link Message}
 * objects via {@link #getInMessage()} and {@link #getOutMessage()}
 *
 * @version $Revision:520964 $
 */
public class JmsExchange extends DefaultExchange {
    private JmsBinding binding;
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new JmsMessage(message));
    }
    public JmsExchange(DefaultExchange parent, JmsBinding binding) {
        super(parent);
        this.binding = binding;
    }
    @Override
    public JmsMessage getIn() {
        return (JmsMessage) super.getIn();
    }
    @Override
    public JmsMessage getOut() {
        return (JmsMessage) super.getOut();
    }
    @Override
    public JmsMessage getOut(boolean lazyCreate) {
        return (JmsMessage) super.getOut(lazyCreate);
    }
    @Override
    public JmsMessage getFault() {
        return (JmsMessage) super.getFault();
    }
    public JmsBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new JmsExchange(this, binding);
    }
    // Expose JMS APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying JMS In message
     *
     * @return the JMS In message
     */
    public Message getInMessage() {
        return getIn().getJmsMessage();
    }
    /**
     * Return the underlying JMS Out message
     *
     * @return the JMS out message
     */
    public Message getOutMessage() {
        return getOut().getJmsMessage();
    }
    /**
     * Return the underlying JMS Fault message
     *
     * @return the JMS fault message
     */
    public Message getFaultMessage() {
        return getFault().getJmsMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected JmsMessage createInMessage() {
        return new JmsMessage();
    }
    @Override
    protected JmsMessage createOutMessage() {
        return new JmsMessage();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new JmsMessage();
    }
}
"
org.apache.camel.converter.jaxp.DomConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.apache.camel.Converter;
/**
 * Converts from some DOM types to Java types
 *
 * @version $Revision$
 */
@Converter
public final class DomConverter {
    private DomConverter() {
        // Utility Class
    }
    @Converter
    public static String toString(NodeList nodeList) {
        StringBuffer buffer = new StringBuffer();
        append(buffer, nodeList);
        return buffer.toString();
    }
/*
    @Converter
    public static String toString(Node node) {
        StringBuffer buffer = new StringBuffer();
        append(buffer, node);
        return buffer.toString();
    }
*/
    protected static void append(StringBuffer buffer, NodeList nodeList) {
        int size = nodeList.getLength();
        for (int i = 0; i < size; i++) {
            append(buffer, nodeList.item(i));
        }
    }
    protected static void append(StringBuffer buffer, Node node) {
        if (node instanceof Text) {
            Text text = (Text) node;
            buffer.append(text.getTextContent());
        } else if (node instanceof Attr) {
            Attr attribute = (Attr) node;
            buffer.append(attribute.getTextContent());
        } else if (node instanceof Element) {
            Element element = (Element) node;
            append(buffer, element.getChildNodes());
        } else if (node instanceof Document) {
            Document doc = (Document) node;
            append(buffer, doc.getChildNodes());
        }
    }
}
"
org.apache.camel.component.stream.StreamComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Component providing streams connectivity
 */
public class StreamComponent extends DefaultComponent<Exchange> {
    // TODO: remove file and url support in this component. Will be removed in Camel 2.0
    // (Should use other components for such needs.)
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        return new StreamEndpoint(uri, this);
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.Map;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link SpringIntegrationEndpoint}. It holds the
 * list of named direct endpoints.
 *
 * @version $Revision$
 */
public class SpringIntegrationComponent extends DefaultComponent<SpringIntegrationExchange> {
    protected SpringIntegrationEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        SpringIntegrationEndpoint endpoint = new SpringIntegrationEndpoint(uri, remaining, this);
        setProperties(endpoint, parameters);
        return endpoint;
    }
}
"
org.apache.camel.builder.ValueBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * A builder of expressions or predicates based on values.
 * 
 * @version $Revision$
 */
public class ValueBuilder<E extends Exchange> implements Expression<E> {
    private Expression<E> expression;
    public ValueBuilder(Expression<E> expression) {
        this.expression = expression;
    }
    public Object evaluate(E exchange) {
        return expression.evaluate(exchange);
    }
    public Expression<E> getExpression() {
        return expression;
    }
    @Override
    public String toString() {
        return expression.toString();
    }
    // Predicate builders
    // -------------------------------------------------------------------------
    public Predicate<E> isNotEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isNotEqualTo(expression, right));
    }
    public Predicate<E> isEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isEqualTo(expression, right));
    }
    public Predicate<E> isLessThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThan(expression, right));
    }
    public Predicate<E> isLessThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(expression, right));
    }
    public Predicate<E> isGreaterThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThan(expression, right));
    }
    public Predicate<E> isGreaterThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(expression, right));
    }
    public Predicate<E> isInstanceOf(Class type) {
        return onNewPredicate(PredicateBuilder.isInstanceOf(expression, type));
    }
    /**
     * @deprecated use {@link #regex(String)}. Will be removed in Camel 2.0
     */
    public Predicate<E> matchesRegex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    public Predicate<E> isNull() {
        return onNewPredicate(PredicateBuilder.isNull(expression));
    }
    public Predicate<E> isNotNull() {
        return onNewPredicate(PredicateBuilder.isNotNull(expression));
    }
    /**
     * Create a predicate that the left hand expression contains the value of
     * the right hand expression
     * 
     * @param value the element which is compared to be contained within this
     *                expression
     * @return a predicate which evaluates to true if the given value expression
     *         is contained within this expression value
     */
    public Predicate<E> contains(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.contains(expression, right));
    }
    /**
     * Creates a predicate which is true if this expression matches the given
     * regular expression
     * 
     * @param regex the regular expression to match
     * @return a predicate which evaluates to true if the expression matches the
     *         regex
     */
    public Predicate<E> regex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    // Expression builders
    // -------------------------------------------------------------------------
    public ValueBuilder<E> tokenize() {
        return tokenize(""\n"");
    }
    public ValueBuilder<E> tokenize(String token) {
        Expression<E> newExp = ExpressionBuilder.tokenizeExpression(expression, token);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Tokenizes the string conversion of this expression using the given
     * regular expression
     */
    public ValueBuilder<E> regexTokenize(String regex) {
        Expression<E> newExp = ExpressionBuilder.regexTokenize(expression, regex);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, String replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, Expression<E> replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value to the given type using the registered type
     * converters
     * 
     * @param type the type to convert the value to
     * @return the current builder
     */
    public ValueBuilder<E> convertTo(Class type) {
        Expression<E> newExp = ExpressionBuilder.convertTo(expression, type);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value a String using the registered type converters
     * 
     * @return the current builder
     */
    public ValueBuilder<E> convertToString() {
        return convertTo(String.class);
    }
    /**
     * Appends the string evaluation of this expression with the given value
     * 
     * @param value the value or expression to append
     * @return the current builder
     */
    public ValueBuilder<E> append(Object value) {
        return new ValueBuilder<E>(ExpressionBuilder.append(expression, asExpression(value)));
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to allow derived classes to deal with the newly created
     * predicate in different ways
     */
    protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
        return predicate;
    }
    protected Expression<E> asExpression(Object value) {
        if (value instanceof Expression) {
            return (Expression<E>)value;
        } else {
            return ExpressionBuilder.constantExpression(value);
        }
    }
}
"
org.apache.camel.component.cxf.CxfConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * Constants used in this module
 *
 * @version $Revision$
 */
public interface CxfConstants {
    String METHOD = ""method"";
    String SERVICE_CLASS = ""serviceClass"";
    String DATA_FORMAT = ""dataFormat"";
    String SET_DEFAULT_BUS = ""setDefaultBus"";
    String WSDL_URL = ""wsdlURL"";
    String ADDRESS = ""address"";
    String SERVICE_NAME = ""serviceName"";
    String PORT_NAME = ""portName"";
    String SERVICE_LOCALNAME = ""serviceLocalName"";
    String SERVICE_NAMESPACE = ""serviceNamespace"";
    String PORT_LOCALNAME = ""endpointLocalName"";
    String PORT_NAMESPACE = ""endpointNamespace"";
    String PROTOCOL_NAME_RES = ""res"";
    String OPERATION_NAME = ""operationName"";
    String OPERATION_NAMESPACE = ""operationNameSpace"";
    String SPRING_CONTEXT_ENDPOINT = ""bean:"";
    String CAMEL_TRANSPORT_PREFIX = ""camel:"";
    String CXF_EXCHANGE = ""org.apache.cxf.message.exchange"";
    String CAMEL_EXCHANGE = ""org.apache.camel.exchange"";
}
"
org.apache.camel.impl.ProcessorPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeExchangeException;
import org.apache.camel.util.ServiceHelper;
/**
 * A simple implementation of {@link PollingConsumer} which just uses
 * a {@link Processor}. This implementation does not support timeout based
 * receive methods such as {@link #receive(long)}
 *
 * @version $Revision$
 */
public class ProcessorPollingConsumer extends PollingConsumerSupport {
    private Processor processor;
    public ProcessorPollingConsumer(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startService(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(processor);
    }
    public Exchange receive() {
        Exchange exchange = getEndpoint().createExchange();
        try {
            processor.process(exchange);
        } catch (Exception e) {
            throw new RuntimeExchangeException(e, exchange);
        }
        return exchange;
    }
    public Exchange receiveNoWait() {
        return receive();
    }
    public Exchange receive(long timeout) {
        return receive();
    }
}
"
org.apache.camel.component.bean.BeanProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which converts the inbound exchange to a method
 * invocation on a POJO
 *
 * @version $Revision$
 */
public class BeanProcessor extends ServiceSupport implements Processor {
    public static final String METHOD_NAME = ""org.apache.camel.MethodName"";
    public static final String MULTI_PARAMETER_ARRAY = ""org.apache.camel.MultiParameterArray"";
    private static final transient Log LOG = LogFactory.getLog(BeanProcessor.class);
    private boolean multiParameterArray;
    private Method methodObject;
    private String method;
    private BeanHolder beanHolder;
    public BeanProcessor(Object pojo, BeanInfo beanInfo) {
        this(new ConstantBeanHolder(pojo, beanInfo));
    }
    public BeanProcessor(Object pojo, CamelContext camelContext, ParameterMappingStrategy parameterMappingStrategy) {
        this(pojo, new BeanInfo(camelContext, pojo.getClass(), parameterMappingStrategy));
    }
    public BeanProcessor(Object pojo, CamelContext camelContext) {
        this(pojo, camelContext, BeanInfo.createParameterMappingStrategy(camelContext));
    }
    public BeanProcessor(BeanHolder beanHolder) {
        this.beanHolder = beanHolder;
    }
    @Override
    public String toString() {
        String description = methodObject != null ? "" "" + methodObject : """";
        return ""BeanProcessor["" + beanHolder + description + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object bean = beanHolder.getBean();
        exchange.setProperty(""org.apache.camel.bean.BeanHolder"", beanHolder);
        Processor processor = getProcessor();
        BeanInfo beanInfo = beanHolder.getBeanInfo();
        // do we have a custom adapter for this POJO to a Processor
        if (processor != null) {
            processor.process(exchange);
            return;
        }
        Message in = exchange.getIn();
        if (in.getHeader(MULTI_PARAMETER_ARRAY) == null) {
            in.setHeader(MULTI_PARAMETER_ARRAY, isMultiParameterArray());
        }
        try {
            BeanInvocation beanInvoke = in.getBody(BeanInvocation.class);
            if (beanInvoke != null) {
                beanInvoke.invoke(bean, exchange);
                return;
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore, body is not a BeanInvocation
        }
        boolean isExplicitMethod = false;
        String prevMethod = null;
        MethodInvocation invocation;
        if (methodObject != null) {
            invocation = beanInfo.createInvocation(methodObject, bean, exchange);
        } else {
            // we just override the bean's invocation method name here
            if (ObjectHelper.isNotNullAndNonEmpty(method)) {
                prevMethod = in.getHeader(METHOD_NAME, String.class);
                in.setHeader(METHOD_NAME, method);
                isExplicitMethod = true;
            }
            invocation = beanInfo.createInvocation(bean, exchange);
        }
        if (invocation == null) {
            throw new IllegalStateException(
                ""No method invocation could be created, no maching method could be found on: "" + bean);
        }
        try {
            Object value = invocation.proceed();
            if (value != null) {
                if (exchange.getPattern().isOutCapable()) {
                    // force out creating if not already created (as its lazy)
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Setting bean invocation result on the OUT message: "" + value);
                    }
                    exchange.getOut(true).setBody(value);
                } else {
                    // if not out then set it on the in
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Setting bean invocation result on the IN message: "" + value);
                    }
                    exchange.getIn().setBody(value);
                }
            }
        } catch (InvocationTargetException e) {
            // lets unwrap the exception
            Throwable throwable = e.getCause();
            if (throwable instanceof Exception) {
                Exception exception = (Exception)throwable;
                throw exception;
            } else {
                Error error = (Error)throwable;
                throw error;
            }
        } finally {
            if (isExplicitMethod) {
                in.setHeader(METHOD_NAME, prevMethod);
            }
        }
    }
    protected Processor getProcessor() {
        return beanHolder.getProcessor();
    }
    // Properties
    // -----------------------------------------------------------------------
    public Method getMethodObject() {
        return methodObject;
    }
    public void setMethodObject(Method methodObject) {
        this.methodObject = methodObject;
    }
    public String getMethod() {
        return method;
    }
    public boolean isMultiParameterArray() {
        return multiParameterArray;
    }
    public void setMultiParameterArray(boolean mpArray) {
        multiParameterArray = mpArray;
    }
    /**
     * Sets the method name to use
     */
    public void setMethod(String method) {
        this.method = method;
    }
    /**
     * Kept around for backwards compatibility, please use {@link #setMethod(String)}
     * in future instead.
     *
     * @deprecated use {@link #setMethod(String)}. Will be removed in Camel 2.0.
     */
    @Deprecated
    public void setMethodName(String method) {
        setMethod(method);
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startService(getProcessor());
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(getProcessor());
    }
}
"
org.apache.camel.component.seda.CollectionProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.Collection;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
/**
 * A simple {@link Producer} which just appends to a {@link Collection} the {@link Exchange} object.
 *
 * @version $Revision$
 */
public class CollectionProducer extends DefaultProducer implements AsyncProcessor {
    private final Collection<Exchange> queue;
    public CollectionProducer(Endpoint endpoint, Collection<Exchange> queue) {
        super(endpoint);
        this.queue = queue;
    }
    public void process(Exchange exchange) throws Exception {
        queue.add(exchange.copy());
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        queue.add(exchange.copy());
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.Message,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
import java.util.Set;
import javax.activation.DataHandler;
/**
 * Implements the <a
 * href=""http://activemq.apache.org/camel/message.html"">Message</a> pattern and
 * represents an inbound or outbound message as part of an {@link Exchange}
 *
 * @version $Revision$
 */
public interface Message {
    /**
     * Returns the id of the message
     *
     * @return the id of the message
     */
    String getMessageId();
    /**
     * Sets the id of the message
     *
     * @param messageId
     */
    void setMessageId(String messageId);
    /**
     * Returns the exchange this message is related to
     */
    Exchange getExchange();
    /**
     * Accesses a specific header
     *
     * @param name  name of header
     * @return object header associated with the name
     */
    Object getHeader(String name);
    /**
     * Returns a header associated with this message by name and specifying the
     * type required
     *
     * @param name the name of the header
     * @param type the type of the header
     * @return the value of the given header or null if there is no property for
     *         the given name or it cannot be converted to the given type
     */
    <T> T getHeader(String name, Class<T> type);
    /**
     * Sets a header on the message
     *
     * @param name of the header
     * @param value to associate with the name
     */
    void setHeader(String name, Object value);
    /**
     * Removes the named header from this message
     *
     * @param name
     * @return the old value of the header
     */
    Object removeHeader(String name);
    /**
     * Returns all of the headers associated with the message
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getHeaders();
    /**
     * Set all the headers associated with this message
     *
     * @param headers
     */
    void setHeaders(Map<String, Object> headers);
    /**
     * Returns the body of the message as a POJO
     *
     * @return the body of the message
     */
    Object getBody();
    /**
     * Returns the body as the specified type
     *
     * @param type the type that the body
     * @return the body of the message as the specified type
     */
    <T> T getBody(Class<T> type);
    /**
     * Sets the body of the message
     */
    void setBody(Object body);
    /**
     * Sets the body of the message as a specific type
     */
    <T> void setBody(Object body, Class<T> type);
    /**
     * Creates a copy of this message so that it can be used and possibly
     * modified further in another exchange
     *
     * @return a new message instance copied from this message
     */
    Message copy();
    /**
     * Copies the contents of the other message into this message
     */
    void copyFrom(Message message);
    /**
     * Returns the attachment specified by the id
     *
     * @param id        the id under which the attachment is stored
     * @return          the data handler for this attachment or null
     */
    DataHandler getAttachment(String id);
    /**
     * Returns a set of attachment names of the message
     *
     * @return  a set of attachment names
     */
    Set<String> getAttachmentNames();
    /**
     * Removes the attachment specified by the id
     *
     * @param id        the id of the attachment to remove
     */
    void removeAttachment(String id);
    /**
     * Adds an attachment to the message using the id
     *
     * @param id        the id to store the attachment under
     * @param content   the data handler for the attachment
     */
    void addAttachment(String id, DataHandler content);
    /**
     * Returns all attachments of the message
     *
     * @return  the attachments in a map or null
     */
    Map<String, DataHandler> getAttachments();
    /**
     * Set all the attachments associated with this message
     *
     * @param attachments
     */
    void setAttachments(Map<String, DataHandler> attachments);
    /**
     * Returns <tt>true</tt> if this message has any attachments.
     */
    boolean hasAttachments();
}
"
org.apache.camel.dataformat.xstream.XStreamDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.xstream;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.QNameMap;
import com.thoughtworks.xstream.io.xml.StaxReader;
import com.thoughtworks.xstream.io.xml.StaxWriter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.StaxConverter;
import org.apache.camel.spi.DataFormat;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using XStream to marshal to and from XML
 *
 * @version $Revision$
 */
public class XStreamDataFormat extends AbstractXStreamWrapper  {
    public XStreamDataFormat() {
        super();
    }
    public XStreamDataFormat(XStream xstream) {
        super(xstream);
    }
    /**
     * A factory method which takes a collection of types to be annotated
     */
    public static XStreamDataFormat processAnnotations(Iterable<Class<?>> types) {
        XStreamDataFormat answer = new XStreamDataFormat();
        XStream xstream = answer.getXStream();
        for (Class<?> type : types) {
            xstream.processAnnotations(type);
        }
        return answer;
    }
    /**
     * A factory method which takes a number of types to be annotated
     */
    public static XStreamDataFormat processAnnotations(Class<?>... types) {
        XStreamDataFormat answer = new XStreamDataFormat();
        XStream xstream = answer.getXStream();
        for (Class<?> type : types) {
            xstream.processAnnotations(type);
        }
        return answer;
    }    
    protected HierarchicalStreamWriter createHierarchicalStreamWriter(Exchange exchange, Object body, OutputStream stream) throws XMLStreamException {
        XMLStreamWriter xmlWriter = getStaxConverter().createXMLStreamWriter(stream);
        return new StaxWriter(new QNameMap(), xmlWriter);
    }
    protected HierarchicalStreamReader createHierarchicalStreamReader(Exchange exchange, InputStream stream) throws XMLStreamException {
        XMLStreamReader xmlReader = getStaxConverter().createXMLStreamReader(stream);
        return new StaxReader(new QNameMap(), xmlReader);
    }
}
"
org.apache.camel.builder.ConstantProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * A builder wrapping a {@link Processor}.
 *
 * @version $Revision$
 */
public class ConstantProcessorBuilder implements ProcessorFactory {
    private Processor processor;
    public ConstantProcessorBuilder(Processor processor) {
        this.processor = processor;
    }
    public Processor createProcessor() {
        return processor;
    }
}
"
org.apache.camel.component.restlet.RestletHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
/**
 * Default header filtering strategy for Restlet
 * 
 * @version $Revision$
 */
public class RestletHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
    public RestletHeaderFilterStrategy() {
        // No IN filters and copy all headers from Restlet to Camel
        // OUT filters (from Camel headers to Restlet headers)
        // filter headers used internally by this component
        getOutFilter().add(RestletConstants.LOGIN);
        getOutFilter().add(RestletConstants.PASSWORD);
    }
}
"
org.apache.camel.spring.spi.TransactionInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.processor.DelayPolicy;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * The <a href=""http://activemq.apache.org/camel/transactional-client.html"">Transactional Client</a>
 * EIP pattern.
 *
 * @version $Revision$
 */
public class TransactionInterceptor extends DelegateProcessor {
    public static final ExchangeProperty<Boolean> TRANSACTED =
        new ExchangeProperty<Boolean>(""transacted"", ""org.apache.camel.transacted"", Boolean.class);
    private static final transient Log LOG = LogFactory.getLog(TransactionInterceptor.class);
    private final TransactionTemplate transactionTemplate;
    private RedeliveryPolicy redeliveryPolicy;
    private DelayPolicy delayPolicy;
    public TransactionInterceptor(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    public TransactionInterceptor(Processor processor, TransactionTemplate transactionTemplate) {
        super(processor);
        this.transactionTemplate = transactionTemplate;
    }
    /**
     * @deprecated use DelayPolicy. Will be removed in Camel 2.0
     */
    public TransactionInterceptor(Processor processor, TransactionTemplate transactionTemplate, RedeliveryPolicy redeliveryPolicy) {
        this(processor, transactionTemplate);
        this.redeliveryPolicy = redeliveryPolicy;
        this.delayPolicy = redeliveryPolicy;
    }
    public TransactionInterceptor(Processor processor, TransactionTemplate transactionTemplate, DelayPolicy delayPolicy) {
        this(processor, transactionTemplate);
        this.delayPolicy = delayPolicy;
    }
    @Override
    public String toString() {
        return ""TransactionInterceptor:""
            + propagationBehaviorToString(transactionTemplate.getPropagationBehavior())
            + ""["" + getProcessor() + ""]"";
    }
    public void process(final Exchange exchange) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // wrapper exception to throw if the exchange failed
                // IMPORTANT: Must be a runtime exception to let Spring regard it as to do ""rollback""
                RuntimeCamelException rce = null;
                boolean activeTx = false;
                try {
                    // find out if there is an actual transaction alive, and thus we are in transacted mode
                    activeTx = TransactionSynchronizationManager.isActualTransactionActive();
                    if (!activeTx) {
                        activeTx = status.isNewTransaction() && !status.isCompleted();
                        if (!activeTx) {
                            if (DefaultTransactionStatus.class.isAssignableFrom(status.getClass())) {
                                DefaultTransactionStatus defStatus =
                                        DefaultTransactionStatus.class.cast(status);
                                activeTx = defStatus.hasTransaction() && !status.isCompleted();
                            }
                        }
                    }
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Is actual transaction active: "" + activeTx);
                    }
                    // okay mark the exchange as transacted, then the DeadLetterChannel or others know
                    // its a transacted exchange
                    if (activeTx) {
                        TRANSACTED.set(exchange, Boolean.TRUE);
                    }
                    // process the exchange
                    processNext(exchange);
                    // wrap if the exchange failed with an exception
                    if (exchange.getException() != null) {
                        rce = wrapRuntimeCamelException(exchange.getException());
                    }
                } catch (Exception e) {
                    rce = wrapRuntimeCamelException(e);
                }
                // rethrow exception if the exchange failed
                if (rce != null) {
                    // an exception occured so please sleep before we rethrow the exception
                    delayBeforeRedelivery();
                    if (activeTx) {
                        status.setRollbackOnly();
                        LOG.debug(""Setting transaction to rollbackOnly due to exception being thrown: "" + rce.getMessage());
                    }
                    throw rce;
                }
            }
        });
    }
    /**
     * Sleeps before the transaction is set as rollback and the caused exception is rethrown to let the
     * Spring TransactionManager handle the rollback.
     */
    protected void delayBeforeRedelivery() {
        long delay = 0;
        if (redeliveryPolicy != null) {
            delay = redeliveryPolicy.getDelay();
        } else if (delayPolicy != null) {
            delay = delayPolicy.getDelay();
        }
        if (delay > 0) {
            try {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sleeping for: "" + delay + "" millis until attempting redelivery"");
                }
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Thread interrupted: "" + e, e);
                }
            }
        }
    }
    /**
     * @deprecated use DelayPolicy. Will be removed in Camel 2.0
     */
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * @deprecated use DelayPolicy. Will be removed in Camel 2.0
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public DelayPolicy getDelayPolicy() {
        return delayPolicy;
    }
    public void setDelayPolicy(DelayPolicy delayPolicy) {
        this.delayPolicy = delayPolicy;
    }
    protected String propagationBehaviorToString(int propagationBehavior) {
        String rc;
        switch (propagationBehavior) {
        case TransactionDefinition.PROPAGATION_MANDATORY:
            rc = ""PROPAGATION_MANDATORY"";
            break;
        case TransactionDefinition.PROPAGATION_NESTED:
            rc = ""PROPAGATION_NESTED"";
            break;
        case TransactionDefinition.PROPAGATION_NEVER:
            rc = ""PROPAGATION_NEVER"";
            break;
        case TransactionDefinition.PROPAGATION_NOT_SUPPORTED:
            rc = ""PROPAGATION_NOT_SUPPORTED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRED:
            rc = ""PROPAGATION_REQUIRED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRES_NEW:
            rc = ""PROPAGATION_REQUIRES_NEW"";
            break;
        case TransactionDefinition.PROPAGATION_SUPPORTS:
            rc = ""PROPAGATION_SUPPORTS"";
            break;
        default:
            rc = ""UNKNOWN"";
        }
        return rc;
    }
}
"
org.apache.camel.component.jetty.JettyHttpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.net.URI;
import java.net.URISyntaxException;
import org.apache.camel.Consumer;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.http.HttpClientConfigurer;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpEndpoint;
import org.apache.camel.component.http.HttpExchange;
import org.apache.camel.component.http.HttpPollingConsumer;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.params.HttpClientParams;
/**
 * @version $Revision$
 */
public class JettyHttpEndpoint extends HttpEndpoint {
    private JettyHttpComponent component;
    private boolean sessionSupport;
    public JettyHttpEndpoint(JettyHttpComponent component, String uri, URI httpURL, HttpClientParams clientParams,
                             HttpConnectionManager httpConnectionManager, HttpClientConfigurer clientConfigurer) throws URISyntaxException {
        super(uri, component, httpURL, clientParams, httpConnectionManager, clientConfigurer);
        this.component = component;
    }
    @Override
    public Producer<HttpExchange> createProducer() throws Exception {
        return super.createProducer();
    }
    @Override
    public Consumer<HttpExchange> createConsumer(Processor processor) throws Exception {
        return new HttpConsumer(this, processor);
    }
    @Override
    public PollingConsumer<HttpExchange> createPollingConsumer() throws Exception {
        return new HttpPollingConsumer(this);
    }
    @Override
    public JettyHttpComponent getComponent() {
        return component;
    }
    public void setSessionSupport(boolean support) {
        sessionSupport = support;
    }
    public boolean isSessionSupport() {
        return sessionSupport;
    }
}
"
org.apache.camel.component.restlet.RestletComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.restlet.Component;
import org.restlet.Guard;
import org.restlet.Restlet;
import org.restlet.Server;
import org.restlet.data.ChallengeScheme;
import org.restlet.data.Method;
import org.restlet.data.Protocol;
/**
 * A Camel component embedded Restlet that produces and consumes exchanges.
 *
 * @version $Revision$
 */
public class RestletComponent extends DefaultComponent<Exchange> implements HeaderFilterStrategyAware {
    private static final Log LOG = LogFactory.getLog(RestletComponent.class);
    private Map<String, Server> servers = new HashMap<String, Server>();
    private Map<String, MethodBasedRouter> routers = new HashMap<String, MethodBasedRouter>();
    private Component component = new Component();
    private HeaderFilterStrategy headerFilterStrategy = new RestletHeaderFilterStrategy();
    @Override
    protected Endpoint createEndpoint(String uri, String remaining,
            Map parameters) throws Exception {
        RestletBinding restletBinding = null;
        // lookup binding in registry if provided
        String ref = getAndRemoveParameter(parameters, ""restletBindingRef"", String.class);
        if (ref != null) {
            restletBinding = CamelContextHelper.mandatoryLookup(getCamelContext(), 
                    ref, RestletBinding.class);
        }
        if (restletBinding == null) {
            restletBinding = new DefaultRestletBinding();
        }
        if (restletBinding instanceof HeaderFilterStrategyAware) {
            ((HeaderFilterStrategyAware)restletBinding).setHeaderFilterStrategy(headerFilterStrategy);
        }
        Map<String, String> realm = null;
        ref = getAndRemoveParameter(parameters, ""restletRealmRef"", String.class);
        if (ref != null) {
            realm = CamelContextHelper.mandatoryLookup(getCamelContext(), ref, Map.class);
        }
        Method method = getAndRemoveParameter(parameters, ""restletMethod"", Method.class);
        RestletEndpoint result = new RestletEndpoint(this, remaining, parameters, restletBinding);
        if (method != null) {
            result.setRestletMethod(method);
        }
        if (realm != null) {
            result.setRealm(realm);
        }
        return result;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        component.start();
    }
    @Override
    protected void doStop() throws Exception {
        component.stop();
        super.doStop();
    }
    public void connect(RestletConsumer consumer) throws Exception {
        RestletEndpoint endpoint = (RestletEndpoint)consumer.getEndpoint();
        addServerIfNeccessary(endpoint);
        MethodBasedRouter router = getMethodRouter(endpoint.getUriPattern());
        Map<String, String> realm = endpoint.getRealm();
        Restlet target = consumer.getRestlet();
        if (realm != null && realm.size() > 0) {
            Guard guard = new Guard(component.getContext().createChildContext(), 
                    ChallengeScheme.HTTP_BASIC, ""Camel-Restlet Endpoint Realm"");
            for (Map.Entry<String, String> entry : realm.entrySet()) {
                guard.getSecrets().put(entry.getKey(), entry.getValue().toCharArray());
            }
            guard.setNext(target);
            target = guard;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Target has been set to guard: "" + guard);
            }
        }
        router.addRoute(endpoint.getRestletMethod(), target);
        if (!router.hasBeenAttached()) {
            component.getDefaultHost().attach(endpoint.getUriPattern(), router);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Attached methodRouter uriPattern: "" + endpoint.getUriPattern());
            }
        }
        LOG.debug(""Attached restlet uriPattern: "" + endpoint.getUriPattern() + "" method: "" 
                + endpoint.getRestletMethod());
    }
    public void disconnect(RestletConsumer consumer) throws Exception {
        RestletEndpoint endpoint = (RestletEndpoint)consumer.getEndpoint();
        MethodBasedRouter router = getMethodRouter(endpoint.getUriPattern());
        router.removeRoute(endpoint.getRestletMethod());
        LOG.debug(""Detached restlet uriPattern: "" + endpoint.getUriPattern() + "" method: "" 
                + endpoint.getRestletMethod());
    }    
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        this.headerFilterStrategy = strategy;
    }
    private MethodBasedRouter getMethodRouter(String uriPattern) {
        synchronized (routers) {
            MethodBasedRouter result = routers.get(uriPattern);
            if (result == null) {
                result = new MethodBasedRouter(uriPattern);
                routers.put(uriPattern, result);
            }
            return result;
        }    
    }
    private void addServerIfNeccessary(RestletEndpoint endpoint) throws Exception {
        String key = buildKey(endpoint);
        Server server = null;
        synchronized (servers) {
            server = servers.get(key);
            if (server == null) {
                server = component.getServers().add(Protocol.valueOf(endpoint.getProtocol()), 
                        endpoint.getPort());
                servers.put(key, server);
                LOG.info(""Add server: "" + key);
                server.start();
            }
        }
    }
    private static String buildKey(RestletEndpoint endpoint) {
        return endpoint.getHost() + "":"" + endpoint.getPort();
    }
}
"
org.apache.camel.impl.converter.InstanceMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which instantiates an object
 * so that an instance method can be used as a type converter
 *
 * @version $Revision$
 */
public class InstanceMethodTypeConverter implements TypeConverter {
    private final CachingInjector injector;
    private final Method method;
    private final boolean useExchange;
    public InstanceMethodTypeConverter(CachingInjector injector, Method method) {
        this.injector = injector;
        this.method = method;
        this.useExchange = method.getParameterTypes().length == 2;
    }
    @Override
    public String toString() {
        return ""InstanceMethodTypeConverter: "" + method;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        return convertTo(type, null, value);
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        Object instance = injector.newInstance();
        if (instance == null) {
            throw new RuntimeCamelException(""Could not instantiate an instance of: "" + type.getName());
        }
        return useExchange
            ? (T)ObjectHelper.invokeMethod(method, instance, value, exchange) : (T)ObjectHelper
                .invokeMethod(method, instance, value);
    }
}
"
org.apache.camel.component.atom.AtomEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Date;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
import org.apache.camel.util.ObjectHelper;
/**
 * An <a href=""http://activemq.apache.org/camel/atom.html"">Atom Endpoint</a>.
 *
 * @version $Revision$
 */
public class AtomEndpoint extends DefaultPollingEndpoint<Exchange> {
    /**
     * Header key for the {@link org.apache.abdera.model.Feed} object is stored on the in message on the exchange.
     */
    public static final String HEADER_ATOM_FEED = ""org.apache.camel.component.atom.feed"";
    private String atomUri;
    private boolean splitEntries = true;
    private Date lastUpdate;
    private boolean filter = true;
    public AtomEndpoint(String endpointUri, AtomComponent component, String atomUri) {
        super(endpointUri, component);
        this.atomUri = atomUri;
        ObjectHelper.notNull(atomUri, ""atomUri property"");
    }
    public AtomEndpoint(String endpointUri, String atomUri) {
        this(endpointUri);
        this.atomUri = atomUri;
        ObjectHelper.notNull(atomUri, ""atomUri property"");
    }
    public AtomEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<Exchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""AtomProducer is not implemented"");
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        AtomConsumerSupport answer;
        if (isSplitEntries()) {
            answer = new AtomEntryPollingConsumer(this, processor, filter, lastUpdate);
        } else {
            answer = new AtomPollingConsumer(this, processor);
        }
        // ScheduledPollConsumer default delay is 500 millis and that is too often for polling a feed,
        // so we override with a new default value. End user can override this value by providing a consumer.delay parameter
        answer.setDelay(AtomConsumerSupport.DEFAULT_CONSUMER_DELAY);
        configureConsumer(answer);
        return answer;
    }
    /**
     * Creates an Exchange with the entries as the in body.
     *
     * @param feed   the atom feed
     * @return the created exchange
     */
    public Exchange createExchange(Feed feed) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(feed.getEntries());
        exchange.getIn().setHeader(HEADER_ATOM_FEED, feed);
        return exchange;
    }
    /**
     * Creates an Exchange with the given entry as the in body.
     *
     * @param feed   the atom feed
     * @param entry  the entry as the in body
     * @return the created exchange
     */
    public Exchange createExchange(Feed feed, Entry entry) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(entry);
        exchange.getIn().setHeader(HEADER_ATOM_FEED, feed);
        return exchange;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getAtomUri() {
        return atomUri;
    }
    public void setAtomUri(String atomUri) {
        this.atomUri = atomUri;
    }
    public boolean isSplitEntries() {
        return splitEntries;
    }
    /**
     * Sets whether or not entries should be sent individually or whether the entire
     * feed should be sent as a single message
     */
    public void setSplitEntries(boolean splitEntries) {
        this.splitEntries = splitEntries;
    }
    public Date getLastUpdate() {
        return lastUpdate;
    }
    /**
     * Sets the timestamp to be used for filtering entries from the atom feeds.
     * This options is only in conjunction with the splitEntries.
     */
    public void setLastUpdate(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
    public boolean isFilter() {
        return filter;
    }
    /**
     * Sets wether to use filtering or not of the entries.
     */
    public void setFilter(boolean filter) {
        this.filter = filter;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.apache.cxf.binding.xml.XMLConstants;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.staxutils.StaxUtils;
public class XMLMessageInInterceptor extends AbstractMessageInInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageInInterceptor.class);
    public XMLMessageInInterceptor() {
        super(Phase.READ);        
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(XMLMessage message) {
        XMLStreamReader xsr = message.getContent(XMLStreamReader.class);
        boolean isFault = false;
        try {
            if (StaxUtils.skipToStartOfElement(xsr)) {
                QName startQName = xsr.getName();
                isFault = XMLConstants.NS_XML_FORMAT.equals(startQName.getNamespaceURI())
                          && XMLFault.XML_FAULT_ROOT.equals(startQName.getLocalPart());
            }
        } catch (XMLStreamException xse) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", LOG));
        }
        return isFault;
    }
    protected BindingOperationInfo getBindingOperation(XMLMessage message, Document doc) {
        Exchange ex = message.getExchange();
        BindingInfo binding = ex.get(BindingInfo.class);
        if (binding == null) {
            Endpoint ep = ex.get(Endpoint.class);
            binding = ep.getEndpointInfo().getBinding();
        }
        //TODO if binding is null throw exception.
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : binding.getOperations()) {
            BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
            QName rootName = null;
            if (bmi != null) {
                XMLBindingMessageFormat msgFormat =
                    bmi.getExtensor(XMLBindingMessageFormat.class);
                if (msgFormat != null) {
                    rootName = msgFormat.getRootNode();
                } else {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        BindingOperationInfo match = null;
        if (boiList.size() > 1) {
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
            }
        } else if (!boiList.isEmpty()) {
            match = boiList.get(0);
        }
        return match; 
    }
    protected List<Element> getPartList(XMLMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        XMLBindingMessageFormat msgFormat =
            bmi.getExtensor(XMLBindingMessageFormat.class);
        if (msgFormat != null) {
            NodeList nodeList = rootNode.getChildNodes();
            for (int idx = 0; idx < nodeList.getLength(); idx++) {
                partList.add((Element)nodeList.item(idx));
            }
        } else {
            partList.add(rootNode);
        }
        return partList;
    }
}
"
org.apache.camel.component.atom.AtomConsumerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
/**
 * Base class for consuming Atom feeds.
 */
public abstract class AtomConsumerSupport extends ScheduledPollConsumer<Exchange> {
    public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L;
    protected final AtomEndpoint endpoint;
    public AtomConsumerSupport(AtomEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.channel.BeanFactoryChannelResolver;
import org.springframework.integration.channel.ChannelResolver;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.core.Message;
import org.springframework.integration.core.MessageChannel;
import org.springframework.integration.core.MessageHeaders;
import org.springframework.integration.message.MessageHandler;
/**
 * A producer of exchanges for the Spring Integration
 * Please specify the outputChannel in the endpoint url for this producer.
 * If the message pattern is inOut, the inputChannel property
 * should be set for receiving the response message.
 * @version $Revision$
 */
public class SpringIntegrationProducer extends DefaultProducer<SpringIntegrationExchange> implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(SpringIntegrationProducer.class);
    private SpringCamelContext context;
    private DirectChannel inputChannel;
    private MessageChannel outputChannel;
    private String outputChannelName;
    private ChannelResolver channelResolver;
    private SpringIntegrationEndpoint endpoint;
    public SpringIntegrationProducer(SpringIntegrationEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        context = (SpringCamelContext) endpoint.getCamelContext();
        if (context != null && endpoint.getMessageChannel() == null) {
            outputChannelName = endpoint.getDefaultChannel();
            channelResolver = new BeanFactoryChannelResolver(context.getApplicationContext());
            if (ObjectHelper.isNullOrBlank(outputChannelName)) {
                outputChannelName = endpoint.getInputChannel();
            }
            if (ObjectHelper.isNullOrBlank(outputChannelName)) {
                throw new RuntimeCamelException(""Can't find the right outputChannelName, ""
                                                + ""please check the endpoint uri outputChannel part!"");
            } else {
                outputChannel = channelResolver.resolveChannelName(outputChannelName);
            }
        } else {
            if (endpoint.getMessageChannel() != null) {
                outputChannel = endpoint.getMessageChannel();
            } else {
                throw new RuntimeCamelException(""Can't find the right message channel, please check your configuration."");
            }
        }
        if (endpoint.isInOut()) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
            // we need to setup right inputChannel for further processing
            if (ObjectHelper.isNullOrBlank(endpoint.getInputChannel())) {
                throw new RuntimeCamelException(""Can't find the right inputChannel, ""
                                                + ""please check the endpoint uri inputChannel part!"");
            } else {
                inputChannel = (DirectChannel)channelResolver.resolveChannelName(endpoint.getInputChannel());
            }
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);       
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        Map<String, Object> headers = new HashMap<String, Object>();
        if (exchange.getPattern().isOutCapable()) {
            headers.put(MessageHeaders.REPLY_CHANNEL , inputChannel);
            inputChannel.subscribe(new MessageHandler() {                
                public void handleMessage(Message<?> message) {                    
                    SpringIntegrationBinding.storeToCamelMessage(message, exchange.getOut());
                    callback.done(true);
                }
            });
        }
        org.springframework.integration.core.Message siOutmessage = SpringIntegrationBinding.createSpringIntegrationMessage(exchange, headers);
        outputChannel.send(siOutmessage);
        if (!exchange.getPattern().isOutCapable()) {
            callback.done(true);
        }
        return true;
    }
}
"
org.apache.camel.component.http.HttpComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.net.URI;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
import org.apache.commons.httpclient.params.HttpClientParams;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/http.html"">HTTP
 * Component</a>
 *
 * @version $Revision$
 */
public class HttpComponent extends DefaultComponent<HttpExchange> implements HeaderFilterStrategyAware {
    protected HttpClientConfigurer httpClientConfigurer;
    protected HttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager();
    protected HeaderFilterStrategy headerFilterStrategy;
    protected HttpBinding httpBinding;
    public HttpComponent() {
        this.setHeaderFilterStrategy(new HttpHeaderFilterStrategy());
    }
    /**
     * Connects the URL specified on the endpoint to the specified processor.
     *
     * @param  consumer the consumer
     * @throws Exception can be thrown
     */
    public void connect(HttpConsumer consumer) throws Exception {
    }
    /**
     * Disconnects the URL specified on the endpoint from the specified processor.
     *
     * @param  consumer the consumer
     * @throws Exception can be thrown
     */
    public void disconnect(HttpConsumer consumer) throws Exception {
    }
    /** 
     * Setting http binding and http client configurer according to the parameters
     * Also setting the BasicAuthenticationHttpClientConfigurer if the username 
     * and password option are not null.
     * 
     * @param parameters the map of parameters 
     * 
     */
    protected void configureParameters(Map parameters) {
        // lookup http binding in registry if provided
        String ref = getAndRemoveParameter(parameters, ""httpBindingRef"", String.class);
        if (ref != null) {
            httpBinding = CamelContextHelper.mandatoryLookup(getCamelContext(), ref, HttpBinding.class);
        }
        // check the user name and password for basic authentication
        String username = getAndRemoveParameter(parameters, ""username"", String.class);
        String password = getAndRemoveParameter(parameters, ""password"", String.class);
        if (username != null && password != null) {
            httpClientConfigurer = new BasicAuthenticationHttpClientConfigurer(username, password);
        }
        // lookup http client front configurer in the registry if provided
        ref = getAndRemoveParameter(parameters, ""httpClientConfigurerRef"", String.class);
        if (ref != null) {
            httpClientConfigurer = CamelContextHelper.mandatoryLookup(getCamelContext(), ref, HttpClientConfigurer.class);
        }
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        // http client can be configured from URI options
        HttpClientParams params = new HttpClientParams();
        IntrospectionSupport.setProperties(params, parameters, ""httpClient."");        
        configureParameters(parameters);
        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options
        URI httpUri = URISupport.createRemainingURI(new URI(uri), parameters);
        uri = httpUri.toString();
        // validate http uri that end-user did not duplicate the http part that can be a common error
        String part = httpUri.getSchemeSpecificPart();
        if (part != null) {
            part = part.toLowerCase();
            if (part.startsWith(""//http//"") || part.startsWith(""//https//"")) {
                throw new ResolveEndpointFailedException(uri,
                        ""The uri part is not configured correctly. You have duplicated the http(s) protocol."");
            }
        }
        HttpEndpoint endpoint = new HttpEndpoint(uri, this, httpUri, params, httpConnectionManager, httpClientConfigurer);
        if (httpBinding != null) {
            endpoint.setBinding(httpBinding);
        }
        return endpoint;
    }
    @Override
    protected boolean useIntrospectionOnEndpoint() {
        return false;
    }
    public HttpClientConfigurer getHttpClientConfigurer() {
        return httpClientConfigurer;
    }
    public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {
        this.httpClientConfigurer = httpClientConfigurer;
    }
    public HttpConnectionManager getHttpConnectionManager() {
        return httpConnectionManager;
    }
    public void setHttpConnectionManager(HttpConnectionManager httpConnectionManager) {
        this.httpConnectionManager = httpConnectionManager;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
    public HttpBinding getHttpBinding() {
        return httpBinding;
    }
    public void setHttpBinding(HttpBinding httpBinding) {
        this.httpBinding = httpBinding;
    }
}
"
org.apache.camel.bam.model.ProcessDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
/**
 * @version $Revision$
 */
@Entity
@Table(
    name = ""PROCESSDEFINITION"",
    uniqueConstraints = @UniqueConstraint(columnNames = {""name""})
)
public class ProcessDefinition extends EntitySupport {
    private static final transient Log LOG = LogFactory.getLog(ProcessDefinition.class);
    private String name;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public static ProcessDefinition getRefreshedProcessDefinition(JpaTemplate template, ProcessDefinition definition) {
        // TODO refresh doesn't tend to work - maybe its a spring thing?
        // template.refresh(definition);
        ObjectHelper.notNull(definition, ""definition"");
        Long id = definition.getId();
        if (id == null) {
            LOG.warn(""No primary key is available!"");
            return findOrCreateProcessDefinition(template, definition.getName());
        }
        definition = template.find(ProcessDefinition.class, id);
        return definition;
    }
    public static ProcessDefinition findOrCreateProcessDefinition(JpaTemplate template, String processName) {
        List<ProcessDefinition> list = template.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            template.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.bean.CamelInvocationHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Producer;
/**
 * An {@link java.lang.reflect.InvocationHandler} which invokes a
 * message exchange on a camel {@link Endpoint}
 *
 * @version $Revision$
 */
public class CamelInvocationHandler implements InvocationHandler {
    private final Endpoint endpoint;
    private final Producer producer;
    private final MethodInfoCache methodInfoCache;
    public CamelInvocationHandler(Endpoint endpoint, Producer producer, MethodInfoCache methodInfoCache) {
        this.endpoint = endpoint;
        this.producer = producer;
        this.methodInfoCache = methodInfoCache;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        BeanInvocation invocation = new BeanInvocation(method, args);
        ExchangePattern pattern = ExchangePattern.InOut;
        MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);
        if (methodInfo != null) {
            pattern = methodInfo.getPattern();
        }
        BeanExchange exchange = new BeanExchange(endpoint.getCamelContext(), pattern);
        exchange.setInvocation(invocation);
        producer.process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        if (pattern.isOutCapable()) {
            return exchange.getOut(true).getBody();
        } else {
            return null;
        }
    }
}
"
org.apache.camel.spring.util.MainRunner,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.name;
/**
 * A simple helper bean for running main classes from within the spring.xml
 * usually asynchronous in a background thread; which is useful for demos such
 * as running Swing programs in the same JVM.
 * 
 * @version $Revision$
 */
public class MainRunner implements InitializingBean, Runnable {
    private static final Log LOG = LogFactory.getLog(MainRunner.class);
    private Class main;
    private String[] args = {};
    private boolean asyncRun = true;
    private long delay;
    public String toString() {
        return ""MainRunner("" + name(main) + "" "" + Arrays.asList(getArgs()) + "")"";
    }
    public void run() {
        try {
            runMethodWithoutCatchingExceptions();
        } catch (NoSuchMethodException e) {
            LOG.error(""Class: "" + name(main) + "" does not have a main method: "" + e, e);
        } catch (IllegalAccessException e) {
            LOG.error(""Failed to run: "" + this + "". Reason: "" + e, e);
        } catch (InvocationTargetException e) {
            Throwable throwable = e.getTargetException();
            LOG.error(""Failed to run: "" + this + "". Reason: "" + throwable, throwable);
        }
    }
    public void runMethodWithoutCatchingExceptions() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        if (delay > 0) {
            try {
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                LOG.info(""Caught: "" + e, e);
            }
        }
        Method method = main.getMethod(""main"", String[].class);
        if (!Modifier.isStatic(method.getModifiers())) {
            throw new IllegalArgumentException(""The main method is not static!: "" + method);
        }
        Object[] arguments = {getArgs()};
        method.invoke(null, arguments);
    }
    public String[] getArgs() {
        return args;
    }
    public void setArgs(String[] args) {
        this.args = args;
    }
    public boolean isAsyncRun() {
        return asyncRun;
    }
    public void setAsyncRun(boolean asyncRun) {
        this.asyncRun = asyncRun;
    }
    public Class getMain() {
        return main;
    }
    public void setMain(Class main) {
        this.main = main;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public void afterPropertiesSet() throws Exception {
        if (main == null) {
            throw new IllegalArgumentException(""You must specify a main class!"");
        }
        if (isAsyncRun()) {
            Thread thread = new Thread(this, ""Thread for: "" + this);
            thread.start();
        } else {
            runMethodWithoutCatchingExceptions();
        }
    }
}
"
org.apache.camel.component.stringtemplate.StringTemplateEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stringtemplate;
import java.io.StringWriter;
import java.util.Map;
import org.antlr.stringtemplate.AutoIndentWriter;
import org.antlr.stringtemplate.StringTemplate;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.component.ResourceBasedEndpoint;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision$
 */
public class StringTemplateEndpoint extends ResourceBasedEndpoint {
    public StringTemplateEndpoint(String uri, StringTemplateComponent component, String resourceUri, Map parameters) {
        super(uri, component, resourceUri, null);
    }
    public StringTemplateEndpoint(String endpointUri, Processor processor, String resourceUri) {
        super(endpointUri, processor, resourceUri);
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
    @Override
    public ExchangePattern getExchangePattern() {
        return ExchangePattern.InOut;
    }
    @Override
    protected void onExchange(Exchange exchange) throws Exception {
        StringWriter buffer = new StringWriter();
        Map variableMap = ExchangeHelper.createVariableMap(exchange);
        // getResourceAsInputStream also considers the content cache
        String text = IOConverter.toString(getResourceAsInputStream());
        StringTemplate template = new StringTemplate(text);
        template.setAttributes(variableMap);
        if (log.isDebugEnabled()) {
            log.debug(""StringTemplate is writing using attributes: "" + variableMap);
        }
        template.write(new AutoIndentWriter(buffer));
        // now lets output the results to the exchange
        Message out = exchange.getOut(true);
        out.setBody(buffer.toString());
        out.setHeader(""org.apache.camel.stringtemplate.resource"", getResource());
    }
}"
org.apache.camel.impl.converter.EnumTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 *
 * @version $Revision$
 */
public class EnumTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isEnum() && value != null) {
            String text = value.toString();
            Method method = null;
            try {
                method = type.getMethod(""valueOf"", String.class);
            } catch (NoSuchMethodException e) {
                throw new RuntimeCamelException(""Could not find valueOf method on enum type: "" + type.getName());
            }
            return (T) ObjectHelper.invokeMethod(method, null, text);
        }
        return null;
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        // ignore exchange
        return convertTo(type, value);
    }
}"
org.apache.camel.component.direct.DirectComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link DirectEndpoint}. It holds the
 * list of named direct endpoints.
 *
 * @version $Revision$
 */
public class DirectComponent<E extends Exchange> extends DefaultComponent<E> {
    protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Endpoint<E> endpoint = new DirectEndpoint<E>(uri, this);
        setProperties(endpoint, parameters);
        return endpoint;
    }
}
"
org.apache.camel.impl.NoPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
/**
 * Represents an {@link Policy} which adds no interceptors.
 *
 * @version $Revision$
 */
public class NoPolicy<E> implements Policy<E> {
    public Processor wrap(Processor processor) {
        return processor;
    }
}
"
org.apache.camel.component.mail.MailConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Flags;
import javax.mail.Folder;
import javax.mail.FolderNotFoundException;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Store;
import javax.mail.search.FlagTerm;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * A {@link org.apache.camel.Consumer Consumer} which consumes messages from JavaMail using a
 * {@link javax.mail.Transport Transport} and dispatches them to the {@link Processor}
 *
 * @version $Revision$
 */
public class MailConsumer extends ScheduledPollConsumer<MailExchange> {
    public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L;
    private static final transient Log LOG = LogFactory.getLog(MailConsumer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSenderImpl sender;
    private Folder folder;
    private Store store;
    public MailConsumer(MailEndpoint endpoint, Processor processor, JavaMailSenderImpl sender) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        if (folder != null && folder.isOpen()) {
            folder.close(true);
        }
        if (store != null && store.isConnected()) {
            store.close();
        }
        super.doStop();
    }
    protected void poll() throws Exception {
        ensureIsConnected();
        if (store == null || folder == null) {
            throw new IllegalStateException(""MailConsumer did not connect properly to the MailStore: ""
                                            + endpoint.getConfiguration().getMailStoreLogInformation());
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Polling mailfolder: "" + endpoint.getConfiguration().getMailStoreLogInformation());
        }
        if (endpoint.getConfiguration().getFetchSize() == 0) {
            LOG.warn(""Fetch size is 0 meaning the configuration is set to poll no new messages at all. Camel will skip this poll."");
            return;
        }
        // ensure folder is open
        if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
        }
        try {
            int count = folder.getMessageCount();
            if (count > 0) {
                Message[] messages;
                // should we process all messages or only unseen messages
                if (endpoint.getConfiguration().isProcessOnlyUnseenMessages()) {
                    messages = folder.search(new FlagTerm(new Flags(Flags.Flag.SEEN), false));
                } else {
                    messages = folder.getMessages();
                }
                processMessages(messages);
            } else if (count == -1) {
                throw new MessagingException(""Folder: "" + folder.getFullName() + "" is closed"");
            }
        } finally {
            // need to ensure we release resources
            try {
                if (folder.isOpen()) {
                    folder.close(true);
                }
            } catch (MessagingException e) {
                // some mail servers will lock the folder so we ignore in this case (CAMEL-1263)
                LOG.debug(""Could not close mailbox folder: "" + folder.getName(), e);
            }
        }
    }
    protected void ensureIsConnected() throws MessagingException {
        MailConfiguration config = endpoint.getConfiguration();
        if (store == null || !store.isConnected()) {
            store = sender.getSession().getStore(config.getProtocol());
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connecting to MailStore "" + endpoint.getConfiguration().getMailStoreLogInformation());
            }
            store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword());
        }
        if (folder == null) {
            folder = store.getFolder(config.getFolderName());
            if (folder == null || !folder.exists()) {
                throw new FolderNotFoundException(folder, ""Folder not found or invalid: "" + config.getFolderName());
            }
        }
    }
    /**
     * Process all the messages
     */
    protected void processMessages(Message[] messages) throws Exception {
        int fetchSize = endpoint.getConfiguration().getFetchSize();
        int count = fetchSize == -1 ? messages.length : Math.min(fetchSize, messages.length);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Fetching "" + count + "" messages. Total "" + messages.length + "" messages."");
        }
        for (int i = 0; i < count; i++) {
            Message message = messages[i];
            if (!message.getFlags().contains(Flags.Flag.DELETED)) {
                processMessage(message);
                flagMessageProcessed(message);
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Skipping message as it was flagged as deleted: "" + MailUtils.dumpMessage(message));
                }
            }
        }
    }
    /**
     * Strategy to process the mail message.
     */
    protected void processMessage(Message message) throws Exception {
        MailExchange exchange = endpoint.createExchange(message);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Processing message: "" + MailUtils.dumpMessage(message));
        }
        getProcessor().process(exchange);
    }
    /**
     * Strategy to flag the message after being processed.
     */
    protected void flagMessageProcessed(Message message) throws MessagingException {
        if (endpoint.getConfiguration().isDeleteProcessedMessages()) {
            message.setFlag(Flags.Flag.DELETED, true);
        } else {
            message.setFlag(Flags.Flag.SEEN, true);
        }
    }
}
"
org.apache.camel.component.bean.BeanInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import org.apache.camel.Exchange;
import org.apache.camel.util.IOHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Invocation of beans that can handle being serialized.
 */
public class BeanInvocation implements Externalizable {
    private Object[] args;
    private MethodBean methodBean;
    private transient Method method;
    public BeanInvocation() {
    }
    public BeanInvocation(Method method, Object[] args) {
        this.method = method;
        this.args = args;
    }
    @Override
    public String toString() {
        Object list = null;
        if (args != null) {
            list = Arrays.asList(args);
        }
        return ""BeanInvocation "" + method + "" with "" + list + ""]"";
    }
    public Object[] getArgs() {
        return args;
    }
    public Method getMethod() {
        return method;
    }
    public void setMethod(Method method) {
        this.method = method;
    }
    public void setArgs(Object[] args) {
        this.args = args;
    }
    /**
     * This causes us to invoke the endpoint Pojo using reflection.
     *
     * @param pojo     the bean on which to perform this invocation
     * @param exchange the exchange carrying the method invocation
     */
    public void invoke(Object pojo, Exchange exchange) {
        try {
            Object response = getMethod().invoke(pojo, getArgs());
            exchange.getOut().setBody(response);
        } catch (InvocationTargetException e) {
            exchange.setException(e.getCause());
        } catch (RuntimeException e) {
            throw e;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
        methodBean = ObjectHelper.cast(MethodBean.class, objectInput.readObject());
        try {
            method = methodBean.getMethod();
        } catch (NoSuchMethodException e) {
            throw IOHelper.createIOException(e);
        }
        args = ObjectHelper.cast(Object[].class, objectInput.readObject());
    }
    public void writeExternal(ObjectOutput objectOutput) throws IOException {
        if (methodBean == null) {
            methodBean = new MethodBean(method);
        }
        objectOutput.writeObject(methodBean);
        objectOutput.writeObject(args);
    }
}
"
org.apache.camel.component.jms.JmsHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision$
 */
public class JmsHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
    public JmsHeaderFilterStrategy() {
        initialize();
    }
    protected void initialize() {
        // ignore provider specified JMS extension headers see page 39 of JMS 1.1 specification
        // added ""JMSXRecvTimestamp"" as a workaround for an Oracle bug/typo in AqjmsMessage
        getOutFilter().add(""JMSXUserID"");
        getOutFilter().add(""JMSXAppID"");
        getOutFilter().add(""JMSXDeliveryCount"");
        getOutFilter().add(""JMSXProducerTXID"");
        getOutFilter().add(""JMSXConsumerTXID"");
        getOutFilter().add(""JMSXRcvTimestamp"");
        getOutFilter().add(""JMSXRecvTimestamp"");
        getOutFilter().add(""JMSXState"");
    }
    @Override
    protected boolean extendedFilter(Direction direction, String key, Object value) {
        return Direction.OUT == direction
            && !ObjectHelper.isJavaIdentifier(JmsBinding.encodeToSafeJmsHeaderName(key));
    }
}
"
org.apache.camel.component.mock.MockComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.processor.ThroughputLogger;
/**
 * A factory of {@link MockEndpoint} instances
 *
 * @version $Revision$
 */
public class MockComponent extends DefaultComponent<Exchange> {
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        MockEndpoint endpoint = new MockEndpoint(uri, this);
        Integer value = getAndRemoveParameter(parameters, ""reportGroup"", Integer.class);
        if (value != null) {
            Processor reporter = new ThroughputLogger(""org.apache.camel.mock:"" + remaining, value);
            endpoint.setReporter(reporter);
        }
        return endpoint;
    }
}
"
org.apache.camel.component.xmpp.XmppExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents an {@link Exchange} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppExchange extends DefaultExchange {
    private XmppBinding binding;
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new XmppMessage(message));
    }
    public XmppExchange(DefaultExchange parent, XmppBinding binding) {
        super(parent);
        this.binding = binding;
    }
    public XmppMessage getIn() {
        return (XmppMessage) super.getIn();
    }
    @Override
    public XmppMessage getOut() {
        return (XmppMessage) super.getOut();
    }
    @Override
    public XmppMessage getOut(boolean lazyCreate) {
        return (XmppMessage) super.getOut(lazyCreate);
    }
    @Override
    public XmppMessage getFault() {
        return (XmppMessage) super.getFault();
    }
    public XmppBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new XmppExchange(this, binding);
    }
    // Expose the underlying XMPP APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying XMPP In message
     *
     * @return the XMPP In message
     */
    public Message getInMessage() {
        return getIn().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Out message
     *
     * @return the XMPP out message
     */
    public Message getOutMessage() {
        return getOut().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Fault message
     *
     * @return the XMPP fault message
     */
    public Message getFaultMessage() {
        return getOut().getXmppMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected XmppMessage createInMessage() {
        return new XmppMessage();
    }
    @Override
    protected XmppMessage createOutMessage() {
        return new XmppMessage();
    }
}
"
org.apache.camel.component.http.HttpHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
/**
 * @version $Revision$
 */
public class HttpHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
    public HttpHeaderFilterStrategy() {
        initialize();  
    }
    protected void initialize() {
        getOutFilter().add(""content-length"");
        getOutFilter().add(""content-type"");
        getOutFilter().add(HttpMethods.HTTP_METHOD);
        getOutFilter().add(HttpProducer.QUERY);
        getOutFilter().add(HttpProducer.HTTP_RESPONSE_CODE.toLowerCase());
        setIsLowercase(true);
        // filter headers begin with ""org.apache.camel""
        setOutFilterPattern(""(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*"");    
    }
}
"
org.apache.camel.impl.DefaultUnitOfWork,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Service;
import org.apache.camel.spi.Synchronization;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.UuidGenerator;
/**
 * The default implementation of {@link UnitOfWork}
 *
 * @version $Revision$
 */
public class DefaultUnitOfWork implements UnitOfWork, Service {
    private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator();
    private String id;
    private List<Synchronization> synchronizations;
    private List<AsyncCallback> asyncCallbacks;
    private CountDownLatch latch;
    public DefaultUnitOfWork() {
    }
    public void start() throws Exception {
    }
    public void stop() throws Exception {
        // need to clean up when we are stopping to not leak memory
        if (synchronizations != null) {
            synchronizations.clear();
        }
        if (asyncCallbacks != null) {
            asyncCallbacks.clear();
        }
    }
    public synchronized void addSynchronization(Synchronization synchronization) {
        if (synchronizations == null) {
            synchronizations = new ArrayList<Synchronization>();
        }
        synchronizations.add(synchronization);
    }
    public synchronized void removeSynchronization(Synchronization synchronization) {
        if (synchronizations != null) {
            synchronizations.remove(synchronization);
        }
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void reset() {
    }
    public void done(Exchange exchange) {
        if (synchronizations != null) {
            boolean failed = exchange.isFailed();
            for (Synchronization synchronization : synchronizations) {
                if (failed) {
                    synchronization.onFailure(exchange);
                } else {
                    synchronization.onComplete(exchange);
                }
            }
        }
    }
    public boolean isSynchronous() {
        return asyncCallbacks == null || asyncCallbacks.isEmpty();
    }
    public String getId() {
        if (id == null) {
            id = DEFAULT_ID_GENERATOR.generateId();
        }
        return id;
    }
    /**
     * Register some asynchronous processing step
     */
    /*
    public synchronized AsyncCallback addAsyncStep() {
        AsyncCallback answer = new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                latch.countDown();
            }
        };
        if (latch == null) {
            latch = new CountDownLatch(1);
        }
        else {
            // TODO increment latch!
        }
        if (asyncCallbacks == null) {
            asyncCallbacks = new ArrayList<AsyncCallback>();
        }
        asyncCallbacks.add(answer);
        return answer;
    }
    */
}
"
org.apache.camel.component.http.HttpBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.Message;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * A plugable strategy for configuring the http binding so reading request and writing response
 * can be customized using the Java Servlet API.
 * <p/>
 * This is used by the camel-jetty.
 *
 * @version $Revision$
 */
public interface HttpBinding {
    /**
     * Startegy to read the given request and bindings it to the given message.
     *
     * @param request  the request
     * @param message  the message to populate with data from request
     */
    void readRequest(HttpServletRequest request, HttpMessage message);
    /**
     * Parses the body from a {@link org.apache.camel.component.http.HttpMessage}
     *
     * @return the parsed body returned as either a {@link java.io.InputStream} or a {@link java.io.Reader}
     * depending on the {@link #setUseReaderForPayload(boolean)} property.
     * @throws java.io.IOException can be thrown
     */
    Object parseBody(HttpMessage httpMessage) throws IOException;
    /**
     * Writes the exchange to the servlet response.
     * <p/>
     * Default implementation will delegate to the following methods depending on the status of the exchange
     * <ul>
     *   <li>doWriteResponse - processing returns a OUT message </li>
     *   <li>doWriteFaultResponse - processing returns a fault message</li>
     *   <li>doWriteResponse - processing returns an exception and status code 500</li>
     * </ul>
     *
     * @param exchange the exchange
     * @param response the http response
     * @throws java.io.IOException can be thrown from http response
     */
    void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException;
    /**
     * Strategy method that writes the response to the http response stream when an exception occuerd
     *
     * @param exception  the exception occured
     * @param response   the http response
     * @throws java.io.IOException can be thrown from http response
     */
    void doWriteExceptionResponse(Throwable exception, HttpServletResponse response) throws IOException;
    /**
     * Strategy method that writes the response to the http response stream for a fault message
     *
     * @param message  the fault message
     * @param response   the http response
     * @throws java.io.IOException can be thrown from http response
     */
    void doWriteFaultResponse(Message message, HttpServletResponse response) throws IOException;
    /**
     * Strategy method that writes the response to the http response stream for an OUT message
     *
     * @param message  the OUT message
     * @param response   the http response
     * @throws java.io.IOException can be thrown from http response
     */
    void doWriteResponse(Message message, HttpServletResponse response) throws IOException;
    boolean isUseReaderForPayload();
    /**
     * Should the {@link javax.servlet.http.HttpServletRequest#getReader()} be exposed as the payload of input messages in the Camel
     * {@link org.apache.camel.Message#getBody()} or not. If false then the {@link javax.servlet.http.HttpServletRequest#getInputStream()} will be exposed.
     */
    void setUseReaderForPayload(boolean useReaderForPayload);
    HeaderFilterStrategy getHeaderFilterStrategy();
    /**
     * Sets the header filter stratety to use.
     * <p/>
     * Will default use {@link org.apache.camel.component.http.HttpHeaderFilterStrategy}
     */
    void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy);
}
"
org.apache.camel.component.amqp.AMQPComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.amqp;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.qpid.client.AMQConnectionFactory;
import org.apache.qpid.url.URLSyntaxException;
/**
 * @version $Revision$
 */
public class AMQPComponent extends JmsComponent {
    public AMQPComponent() {
        init();
    }
    public AMQPComponent(JmsConfiguration configuration) {
        super(configuration);
    }
    public AMQPComponent(CamelContext context) {
        super(context);
        init();
    }
    public AMQPComponent(AMQConnectionFactory connectionFactory) {
        setConnectionFactory(connectionFactory);
    }
    public static Component amqpComponent(String uri) throws URLSyntaxException {
        AMQConnectionFactory connectionFactory = new AMQConnectionFactory(uri);
        return new AMQPComponent(connectionFactory);
    }
    /**
     * Lets install the default connection factory
     */
    private void init() {
        AMQConnectionFactory connectionFactory = new AMQConnectionFactory();
        setConnectionFactory(connectionFactory);
    }
}
"
org.apache.camel.component.cxf.invoker.InvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.Map;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public interface InvokingContext {
    /**
     * This method is called when the router is preparing an outbound message
     * (orignated from the router's client) to be sent to the target CXF server.
     * It sets the content in the given (out) message object.
     */
    void setRequestOutMessageContent(Message message, Map<Class, Object> contents);
    /**
     * This method is call when the CxfClient receives a response from a CXF server and needs
     * to extract the response object from the message.
     */
    Object getResponseObject(Exchange exchange, Map<String, Object> responseContext);
    /**
     * This method is called when the routing interceptor has received a response message
     * from the target CXF server and needs to set the response in the outgoing message
     * that is to be sent to the client.
     */
    void setResponseContent(Message outMessage, Object resultPayload);
    /**
     * This method is called when the routing interceptor has intercepted a message from
     * the client and needs to extract the request content from the message.  It retreives
     * and receives the request content from the incoming message.
     */
    Map<Class, Object> getRequestContent(Message inMessage);
}
"
org.apache.camel.component.jdbc.JdbcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.sql.DataSource;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision$
 */
public class JdbcProducer extends DefaultProducer<DefaultExchange> {
    private static final transient Log LOG = LogFactory.getLog(JdbcProducer.class);
    private DataSource dataSource;
    private int readSize;
    public JdbcProducer(JdbcEndpoint endpoint, DataSource dataSource, int readSize) throws Exception {
        super(endpoint);
        this.dataSource = dataSource;
        this.readSize = readSize;
    }
    /**
     * Execute sql of exchange and set results on output
     */
    public void process(Exchange exchange) throws Exception {
        String sql = exchange.getIn().getBody(String.class);
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = dataSource.getConnection();
            stmt = conn.createStatement();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Executing JDBC statement: "" + sql);
            }
            if (stmt.execute(sql)) {
                rs = stmt.getResultSet();
                setResultSet(exchange, rs);
            } else {
                int updateCount = stmt.getUpdateCount();
                exchange.getOut().setHeader(""jdbc.updateCount"", updateCount);
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                LOG.warn(""Error closing JDBC resource: "" + e, e);
            }
        }
    }
    /**
     * Sets the result from the ResultSet to the Exchange as its OUT body.
     */
    protected void setResultSet(Exchange exchange, ResultSet rs) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        HashMap<String, Object> props = new HashMap<String, Object>();
        IntrospectionSupport.getProperties(meta, props, ""jdbc."");
        exchange.getOut().setHeaders(props);
        int count = meta.getColumnCount();
        List<HashMap<String, Object>> data = new ArrayList<HashMap<String, Object>>();
        int rowNumber = 0;
        while (rs.next() && (readSize == 0 || rowNumber < readSize)) {
            HashMap<String, Object> row = new HashMap<String, Object>();
            for (int i = 0; i < count; i++) {
                int columnNumber = i + 1;
                String columnName = meta.getColumnName(columnNumber);
                row.put(columnName, rs.getObject(columnName));
            }
            data.add(row);
            rowNumber++;
        }
        exchange.getOut().setBody(data);
    }
}
"
org.apache.camel.component.test.TestComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.test;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
/**
 * Test Component.
 *
 * @see org.apache.camel.component.test.TestEndpoint
 *
 * @version $Revision$
 */
public class TestComponent extends DefaultComponent<Exchange> {
    public Endpoint<Exchange> createEndpoint(String uri) throws Exception {
        // lets not use the normal parameter handling so that all parameters are sent to the nested endpoint
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
        URI u = new URI(UnsafeUriCharactersEncoder.encode(uri));
        String path = u.getSchemeSpecificPart();
        return createEndpoint(uri, path, new HashMap());
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(getCamelContext(), remaining);
        return new TestEndpoint(uri, this, endpoint);
    }
}"
org.apache.camel.component.quartz.QuartzConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision$
 */
public class QuartzConsumer extends DefaultConsumer<QuartzExchange> {
    public QuartzConsumer(QuartzEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    @Override
    public QuartzEndpoint getEndpoint() {
        return (QuartzEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getEndpoint().consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        getEndpoint().consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.component.cxf.invoker.PayloadMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.List;
import org.w3c.dom.Element;
import org.apache.cxf.binding.soap.SoapHeader;
public class PayloadMessage {
    private List<Element> payload;
    private List<SoapHeader> headers;
    public PayloadMessage(List<Element> payload, List<SoapHeader> headers) {
        this.payload = payload;
        this.headers = headers;
    }
    public List<Element> getPayload() {
        return payload;
    }
    public List<SoapHeader> getHeaders() {
        return headers;
    }
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""payload: "" + payload);
        buf.append("" headers: "" + headers);
        return buf.toString();
    }
}
"
org.apache.camel.component.jhc.AsyncBufferingHttpServiceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.ConnectionReuseStrategy;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.ProtocolVersion;
import org.apache.http.impl.DefaultConnectionReuseStrategy;
import org.apache.http.impl.DefaultHttpResponseFactory;
import org.apache.http.nio.NHttpServerConnection;
import org.apache.http.nio.util.ByteBufferAllocator;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.BasicHttpProcessor;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpProcessor;
import org.apache.http.protocol.HttpRequestHandler;
import org.apache.http.protocol.ResponseConnControl;
import org.apache.http.protocol.ResponseContent;
import org.apache.http.protocol.ResponseDate;
import org.apache.http.protocol.ResponseServer;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 11, 2007
 * Time: 6:57:34 PM
 * To change this template use File | Settings | File Templates.
 */
public class AsyncBufferingHttpServiceHandler extends BufferingHttpServiceHandler {
    public AsyncBufferingHttpServiceHandler(final HttpParams params) {
        super(createDefaultProcessor(),
              new DefaultHttpResponseFactory(),
              new DefaultConnectionReuseStrategy(),
              params);
    }
    public AsyncBufferingHttpServiceHandler(final HttpProcessor httpProcessor,
                                            final HttpResponseFactory responseFactory,
                                            final ConnectionReuseStrategy connStrategy,
                                            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, params);
    }
    public AsyncBufferingHttpServiceHandler(final HttpProcessor httpProcessor,
                                            final HttpResponseFactory responseFactory,
                                            final ConnectionReuseStrategy connStrategy,
                                            final ByteBufferAllocator allocator,
                                            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, allocator, params);
    }
    protected static HttpProcessor createDefaultProcessor() {
        BasicHttpProcessor httpproc = new BasicHttpProcessor();
        httpproc.addInterceptor(new ResponseDate());
        httpproc.addInterceptor(new ResponseServer());
        httpproc.addInterceptor(new ResponseContent());
        httpproc.addInterceptor(new ResponseConnControl());
        return httpproc;
    }
    protected void processRequest(
            final NHttpServerConnection conn,
            final HttpRequest request) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
        context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
        try {
            this.httpProcessor.process(request, context);
            HttpRequestHandler handler = null;
            if (handlerResolver != null) {
                String requestURI = request.getRequestLine().getUri();
                handler = handlerResolver.lookup(requestURI);
            }
            if (handler != null) {
                if (handler instanceof AsyncHttpRequestHandler) {
                    ((AsyncHttpRequestHandler)handler).handle(request, context, new AsyncResponseHandler() {
                        public void sendResponse(HttpResponse response) throws IOException, HttpException {
                            try {
                                AsyncBufferingHttpServiceHandler.this.sendResponse(conn, response);
                            } catch (HttpException ex) {
                                response = AsyncBufferingHttpServiceHandler.this.responseFactory.newHttpResponse(
                                    HttpVersion.HTTP_1_0, HttpStatus.SC_INTERNAL_SERVER_ERROR, conn.getContext());
                                response.setParams(AsyncBufferingHttpServiceHandler.this.params);
                                AsyncBufferingHttpServiceHandler.this.handleException(ex, response);
                                AsyncBufferingHttpServiceHandler.this.sendResponse(conn, response);
                            }
                        }
                    });
                } else { // just hanlder the request with sync request handler
                    HttpResponse response = this.responseFactory.newHttpResponse(
                        ver, HttpStatus.SC_OK, conn.getContext());
                    response.setParams(this.params);
                    context.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
                    handler.handle(request, response, context);
                    sendResponse(conn, response);
                }
            } else {
                // add the default handler here
                HttpResponse response = this.responseFactory.newHttpResponse(
                    ver, HttpStatus.SC_OK, conn.getContext());
                response.setStatusCode(HttpStatus.SC_NOT_IMPLEMENTED);
            }
        } catch (HttpException ex) {
            HttpResponse response = this.responseFactory.newHttpResponse(
                HttpVersion.HTTP_1_0, HttpStatus.SC_INTERNAL_SERVER_ERROR, context);
            response.setParams(this.params);
            handleException(ex, response);
            sendResponse(conn, response);
        }
    }
}
"
org.apache.camel.component.dataset.SimpleDataSet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Processor;
/**
 * A simple DataSet that allows a static payload to be used to create each message exchange
 * along with using a pluggable transformer to randomize the message.
 *
 * @version $Revision$
 */
public class SimpleDataSet extends DataSetSupport {
    private Object defaultBody = ""<hello>world!</hello>"";
    private Processor inputTransformer;
    public SimpleDataSet() {
    }
    public SimpleDataSet(int size) {
        super(size);
    }
    // Properties
    //-------------------------------------------------------------------------
    public Object getDefaultBody() {
        return defaultBody;
    }
    public void setDefaultBody(Object defaultBody) {
        this.defaultBody = defaultBody;
    }
    public Processor getInputTransformer() {
        return inputTransformer;
    }
    public void setInputTransformer(Processor inputTransformer) {
        this.inputTransformer = inputTransformer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * Creates the message body for a given message
     */
    protected Object createMessageBody(long messageIndex) {
        return getDefaultBody();
    }
}
"
org.apache.camel.impl.DefaultCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.naming.Context;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.Route;
import org.apache.camel.Routes;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Service;
import org.apache.camel.TypeConverter;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.management.InstrumentationLifecycleStrategy;
import org.apache.camel.management.JmxSystemPropertyKeys;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.processor.interceptor.Delayer;
import org.apache.camel.processor.interceptor.TraceFormatter;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ReflectionInjector;
import org.apache.camel.util.SystemHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
/**
 * Represents the context used to configure routes and the policies to use.
 *
 * @version $Revision$
 */
public class DefaultCamelContext extends ServiceSupport implements CamelContext, Service {
    private static final transient Log LOG = LogFactory.getLog(DefaultCamelContext.class);
    private static final String NAME_PREFIX = ""camel-"";
    private static int nameSuffix;
    private String name;
    private final Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
    private final Map<String, Component> components = new HashMap<String, Component>();
    private List<Route> routes;
    private List<Service> servicesToClose = new ArrayList<Service>();
    private TypeConverter typeConverter;
    private ExchangeConverter exchangeConverter;
    private Injector injector;
    private ComponentResolver componentResolver;
    private boolean autoCreateComponents = true;
    private LanguageResolver languageResolver = new DefaultLanguageResolver();
    private Registry registry;
    private LifecycleStrategy lifecycleStrategy;
    private List<RouteType> routeDefinitions = new ArrayList<RouteType>();
    private List<InterceptStrategy> interceptStrategies = new ArrayList<InterceptStrategy>();
    private Boolean trace;
    private Long delay;
    private ErrorHandlerBuilder errorHandlerBuilder;
    private Map<String, DataFormatType> dataFormats = new HashMap<String, DataFormatType>();
    private Class<? extends FactoryFinder> factoryFinderClass = FactoryFinder.class;
    public DefaultCamelContext() {
        name = NAME_PREFIX + ++nameSuffix;
        if (Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
            LOG.info(""JMX is disabled. Using DefaultLifecycleStrategy."");
            lifecycleStrategy = new DefaultLifecycleStrategy();
        } else {
            try {
                LOG.info(""JMX enabled. Using InstrumentationLifecycleStrategy."");
                lifecycleStrategy = new InstrumentationLifecycleStrategy();
            } catch (NoClassDefFoundError e) {
                // if we can't instantiate the JMX enabled strategy then fallback to default
                // could be because of missing .jars on the classpath
                LOG.warn(""Could not find needed classes for JMX lifecycle strategy.""
                    + "" Needed class is in spring-context.jar using Spring 2.5 or newer (""
                    + "" spring-jmx.jar using Spring 2.0.x).""
                    + "" NoClassDefFoundError: "" + e.getMessage());
            } catch (Exception e) {
                LOG.warn(""Could not create JMX lifecycle strategy, caused by: "" + e.getMessage());
            }
            // if not created then fallback to default
            if (lifecycleStrategy == null) {
                LOG.warn(""Not possible to use JMX lifecycle strategy. Using DefaultLifecycleStrategy instead."");
                lifecycleStrategy = new DefaultLifecycleStrategy();
            }
        }
    }
    /**
     * Creates the {@link CamelContext} using the given JNDI context as the
     * registry
     */
    public DefaultCamelContext(Context jndiContext) {
        this();
        setJndiContext(jndiContext);
    }
    /**
     * Creates the {@link CamelContext} using the given registry
     */
    public DefaultCamelContext(Registry registry) {
        this();
        this.registry = registry;
    }
    public String getName() {
        return name;
    }
    /**
     * Sets the name of the this context.
     */
    public void setName(String name) {
        this.name = name;
    }
    public void addComponent(String componentName, final Component component) {
        if (component == null) {
            throw new IllegalArgumentException(""Component cannot be null"");
        }
        synchronized (components) {
            if (components.containsKey(componentName)) {
                throw new IllegalArgumentException(""Component previously added: "" + componentName);
            }
            component.setCamelContext(this);
            components.put(componentName, component);
        }
    }
    public Component getComponent(String name) {
        // synchronize the look up and auto create so that 2 threads can't
        // concurrently auto create the same component.
        synchronized (components) {
            Component component = components.get(name);
            if (component == null && autoCreateComponents) {
                try {
                    component = getComponentResolver().resolveComponent(name, this);
                    if (component != null) {
                        addComponent(name, component);
                        if (isStarted()) {
                            // If the component is looked up after the context
                            // is started,
                            // lets start it up.
                            startServices(component);
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Could not auto create component: "" + name, e);
                }
            }
            return component;
        }
    }
    public <T extends Component> T getComponent(String name, Class<T> componentType) {
        Component component = getComponent(name);
        if (componentType.isInstance(component)) {
            return componentType.cast(component);
        } else {
            throw new IllegalArgumentException(""The component is not of type: "" + componentType + "" but is: ""
                    + component);
        }
    }
    public Component removeComponent(String componentName) {
        synchronized (components) {
            return components.remove(componentName);
        }
    }
    public Component getOrCreateComponent(String componentName, Callable<Component> factory) {
        synchronized (components) {
            Component component = components.get(componentName);
            if (component == null) {
                try {
                    component = factory.call();
                    if (component == null) {
                        throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                                + "" component, it returned null."");
                    }
                    components.put(componentName, component);
                    component.setCamelContext(this);
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                            + "" component"", e);
                }
            }
            return component;
        }
    }
    // Endpoint Management Methods
    // -----------------------------------------------------------------------
    public Collection<Endpoint> getEndpoints() {
        synchronized (endpoints) {
            return new ArrayList<Endpoint>(endpoints.values());
        }
    }
    public Collection<Endpoint> getEndpoints(String uri) {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        Collection<Endpoint> coll;
        synchronized (endpoints) {
            Endpoint ep = endpoints.get(uri);
            if (ep != null) {
                answer.add(ep);
                return answer;
            }
            coll = new ArrayList<Endpoint>(endpoints.values());
        }
        for (Endpoint ep : coll) {
            if (!ep.isSingleton() && uri.equals(ep.getEndpointUri())) {
                answer.add(ep);
            }
        }
        return answer;
    }
    public Collection<Endpoint> getSingletonEndpoints() {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        Collection<Endpoint> coll = getEndpoints();
        for (Endpoint ep : coll) {
            if (ep.isSingleton()) {
                answer.add(ep);
            }
        }
        return answer;
    }
    public Endpoint addEndpoint(String uri, Endpoint endpoint) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            startServices(endpoint);
            oldEndpoint = endpoints.remove(uri);
            endpoints.put(CamelContextHelper.getEndpointKey(uri, endpoint), endpoint);
            if (oldEndpoint != null) {
                stopServices(oldEndpoint);
            }
        }
        return oldEndpoint;
    }
    public Collection<Endpoint> removeEndpoints(String uri) throws Exception {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        synchronized (endpoints) {
            Endpoint oldEndpoint = endpoints.remove(uri);
            if (oldEndpoint != null) {
                answer.add(oldEndpoint);
                stopServices(oldEndpoint);
            } else {
                for (Map.Entry entry : endpoints.entrySet()) {
                    oldEndpoint = (Endpoint)entry.getValue();
                    if (!oldEndpoint.isSingleton() && uri.equals(oldEndpoint.getEndpointUri())) {
                        answer.add(oldEndpoint);
                        stopServices(oldEndpoint);
                        endpoints.remove(entry.getKey());
                    }
                }
            }
        }
        return answer;
    }
    public Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception {
        return addEndpoint(uri, endpoint);
    }
    public Endpoint removeSingletonEndpoint(String uri) throws Exception {
        Collection<Endpoint> answer = removeEndpoints(uri);
        return (Endpoint) (answer.size() > 0 ? answer.toArray()[0] : null);
    }
    public Endpoint getEndpoint(String uri) {
        Endpoint<?> answer;
        synchronized (endpoints) {
            answer = endpoints.get(uri);
            if (answer == null) {
                try {
                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] != null) {
                        String scheme = splitURI[0];
                        Component<?> component = getComponent(scheme);
                        // Ask the component to resolve the endpoint.
                        if (component != null) {
                            // Have the component create the endpoint if it can.
                            answer = component.createEndpoint(uri);
                            if (answer != null && LOG.isDebugEnabled()) {
                                LOG.debug(uri + "" converted to endpoint: "" + answer + "" by component: "" + component);
                            }
                        }
                    }
                    if (answer == null) {
                        answer = createEndpoint(uri);
                    }
                    // If it's a singleton then auto register it.
                    if (answer != null) {
                        addService(answer);
                        endpoints.put(CamelContextHelper.getEndpointKey(uri, answer), answer);
                        lifecycleStrategy.onEndpointAdd(answer);
                    }
                } catch (Exception e) {
                    LOG.debug(""Failed to resolve endpoint "" + uri + "". Reason: "" + e, e);
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }
        return answer;
    }
    public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
        Endpoint endpoint = getEndpoint(name);
        if (endpointType.isInstance(endpoint)) {
            return endpointType.cast(endpoint);
        } else {
            throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: ""
                    + endpoint);
        }
    }
    // Route Management Methods
    // -----------------------------------------------------------------------
    public List<Route> getRoutes() {
        if (routes == null) {
            routes = new ArrayList<Route>();
        }
        return routes;
    }
    public void setRoutes(List<Route> routes) {
        this.routes = routes;
        throw new UnsupportedOperationException(""overriding existing routes is not supported yet, use addRoutes instead"");
    }
    public void addRoutes(Collection<Route> routes) throws Exception {
        if (this.routes == null) {
            this.routes = new ArrayList<Route>();
        }
        if (routes != null) {
            this.routes.addAll(routes);
            lifecycleStrategy.onRoutesAdd(routes);
            if (shouldStartRoutes()) {
                startRoutes(routes);
            }
        }
    }
    public void addRoutes(Routes builder) throws Exception {
        // lets now add the routes from the builder
        builder.setContext(this);
        List<Route> routeList = builder.getRouteList();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Adding routes from: "" + builder + "" routes: "" + routeList);
        }
        addRoutes(routeList);
    }
    public void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception {
        this.routeDefinitions.addAll(routeDefinitions);
        if (shouldStartRoutes()) {
            startRouteDefinitions(routeDefinitions);
        }
    }
    /**
     * Adds a service, starting it so that it will be stopped with this context
     */
    public void addService(Object object) throws Exception {
        if (object instanceof Service) {
            Service service = (Service) object;
            getLifecycleStrategy().onServiceAdd(this, service);
            service.start();
            servicesToClose.add(service);
        }
    }
    // Helper methods
    // -----------------------------------------------------------------------
    public Language resolveLanguage(String language) {
        return getLanguageResolver().resolveLanguage(language, this);
    }
    // Properties
    // -----------------------------------------------------------------------
    public ExchangeConverter getExchangeConverter() {
        if (exchangeConverter == null) {
            exchangeConverter = createExchangeConverter();
        }
        return exchangeConverter;
    }
    public void setExchangeConverter(ExchangeConverter exchangeConverter) {
        this.exchangeConverter = exchangeConverter;
    }
    public TypeConverter getTypeConverter() {
        if (typeConverter == null) {
            typeConverter = createTypeConverter();
        }
        return typeConverter;
    }
    public void setTypeConverter(TypeConverter typeConverter) {
        this.typeConverter = typeConverter;
    }
    public Injector getInjector() {
        if (injector == null) {
            injector = createInjector();
        }
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    public ComponentResolver getComponentResolver() {
        if (componentResolver == null) {
            componentResolver = createComponentResolver();
        }
        return componentResolver;
    }
    public void setComponentResolver(ComponentResolver componentResolver) {
        this.componentResolver = componentResolver;
    }
    public LanguageResolver getLanguageResolver() {
        return languageResolver;
    }
    public void setLanguageResolver(LanguageResolver languageResolver) {
        this.languageResolver = languageResolver;
    }
    public boolean isAutoCreateComponents() {
        return autoCreateComponents;
    }
    public void setAutoCreateComponents(boolean autoCreateComponents) {
        this.autoCreateComponents = autoCreateComponents;
    }
    public Registry getRegistry() {
        if (registry == null) {
            registry = createRegistry();
        }
        return registry;
    }
    /**
     * Sets the registry to the given JNDI context
     *
     * @param jndiContext is the JNDI context to use as the registry
     *
     * @see #setRegistry(org.apache.camel.spi.Registry)
     */
    public void setJndiContext(Context jndiContext) {
        setRegistry(new JndiRegistry(jndiContext));
    }
    public void setRegistry(Registry registry) {
        this.registry = registry;
    }
    public LifecycleStrategy getLifecycleStrategy() {
        return lifecycleStrategy;
    }
    public void setLifecycleStrategy(LifecycleStrategy lifecycleStrategy) {
        this.lifecycleStrategy = lifecycleStrategy;
    }
    public List<RouteType> getRouteDefinitions() {
        return routeDefinitions;
    }
    public List<InterceptStrategy> getInterceptStrategies() {
        return interceptStrategies;
    }
    public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }
    public void addInterceptStrategy(InterceptStrategy interceptStrategy) {
        getInterceptStrategies().add(interceptStrategy);
    }
    /**
     * Returns true if tracing has been enabled or disabled via the {@link #setTrace(Boolean)} method
     * or it has not been specified then default to the <b>camel.trace</b> system property
     */
    public boolean getTrace() {
        final Boolean value = getTracing();
        if (value != null) {
            return value;
        } else {
            return SystemHelper.isSystemProperty(""camel.trace"");
        }
    }
    public Boolean getTracing() {
        return trace;
    }
    public void setTrace(Boolean trace) {
        this.trace = trace;
    }
    /**
     * Returns the delay in millis if delaying has been enabled or disabled via the {@link #setDelay(Long)} method
     * or it has not been specified then default to the <b>camel.delay</b> system property
     */
    public long getDelay() {
        final Long value = getDelaying();
        if (value != null) {
            return value;
        } else {
            String prop = SystemHelper.getSystemProperty(""camel.delay"");
            return prop != null ? Long.getLong(prop) : 0;
        }
    }
    public Long getDelaying() {
        return delay;
    }
    public void setDelay(Long delay) {
        this.delay = delay;
    }
    public <E extends Exchange> ProducerTemplate<E> createProducerTemplate() {
        return new DefaultProducerTemplate<E>(this);
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        return errorHandlerBuilder;
    }
    /**
     * Sets the default error handler builder which is inherited by the routes
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void doStart() throws Exception {
        LOG.info(""Apache Camel "" + getVersion() + "" (CamelContext:"" + getName() + "") is starting"");
        if (getTrace()) {
            // only add a new tracer if not already configued
            if (Tracer.getTracer(this) == null) {
                Tracer tracer = new Tracer();
                // lets see if we have a formatter if so use it
                TraceFormatter formatter = this.getRegistry().lookup(""traceFormatter"", TraceFormatter.class);
                if (formatter != null) {
                    tracer.setFormatter(formatter);
                }
                addInterceptStrategy(tracer);
            }
        }
        if (getDelay() > 0) {
            // only add a new delayer if not already configued
            if (Delayer.getDelayer(this) == null) {
                addInterceptStrategy(new Delayer(getDelay()));
            }
        }
        lifecycleStrategy.onContextStart(this);
        forceLazyInitialization();
        if (components != null) {
            for (Component component : components.values()) {
                startServices(component);
            }
        }
        startRouteDefinitions(routeDefinitions);
        startRoutes(routes);
        LOG.info(""Apache Camel "" + getVersion() + "" (CamelContext:"" + getName() + "") started"");
    }
    protected void startRouteDefinitions(Collection<RouteType> list) throws Exception {
        if (list != null) {
            Collection<Route> routes = new ArrayList<Route>();
            for (RouteType route : list) {
                route.addRoutes(this, routes);
            }
            addRoutes(routes);
        }
    }
    protected void doStop() throws Exception {
        stopServices(servicesToClose);
        if (components != null) {
            for (Component component : components.values()) {
                stopServices(component);
            }
        }
    }
    protected void startRoutes(Collection<Route> routeList) throws Exception {
        if (routeList != null) {
            for (Route<Exchange> route : routeList) {
                List<Service> services = route.getServicesForRoute();
                for (Service service : services) {
                    addService(service);
                }
            }
        }
    }
    /**
     * Lets force some lazy initialization to occur upfront before we start any
     * components and create routes
     */
    protected void forceLazyInitialization() {
        getExchangeConverter();
        getInjector();
        getLanguageResolver();
        getTypeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected ExchangeConverter createExchangeConverter() {
        return new DefaultExchangeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected TypeConverter createTypeConverter() {
        return new DefaultTypeConverter(getInjector());
    }
    /**
     * Lazily create a default implementation
     */
    protected Injector createInjector() {
        FactoryFinder finder = createFactoryFinder();
        try {
            return (Injector) finder.newInstance(""Injector"");
        } catch (NoFactoryAvailableException e) {
            // lets use the default
            return new ReflectionInjector();
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e);
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Lazily create a default implementation
     */
    protected ComponentResolver createComponentResolver() {
        return new DefaultComponentResolver();
    }
    /**
     * Lazily create a default implementation
     */
    protected Registry createRegistry() {
        return new JndiRegistry();
    }
    /**
     * A pluggable strategy to allow an endpoint to be created without requiring
     * a component to be its factory, such as for looking up the URI inside some
     * {@link Registry}
     *
     * @param uri the uri for the endpoint to be created
     * @return the newly created endpoint or null if it could not be resolved
     */
    protected Endpoint createEndpoint(String uri) {
        Object value = getRegistry().lookup(uri);
        if (value instanceof Endpoint) {
            return (Endpoint) value;
        } else if (value instanceof Processor) {
            return new ProcessorEndpoint(uri, this, (Processor) value);
        } else if (value != null) {
            return convertBeanToEndpoint(uri, value);
        }
        return null;
    }
    /**
     * Attempt to convert the bean from a {@link Registry} to an endpoint using
     * some kind of transformation or wrapper
     *
     * @param uri  the uri for the endpoint (and name in the registry)
     * @param bean the bean to be converted to an endpoint, which will be not null
     * @return a new endpoint
     */
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        throw new IllegalArgumentException(""uri: "" + uri + "" bean: "" + bean
                + "" could not be converted to an Endpoint"");
    }
    /**
     * Should we start newly added routes?
     */
    protected boolean shouldStartRoutes() {
        return isStarted() && !isStarting();
    }
    public void setDataFormats(Map<String, DataFormatType> dataFormats) {
        this.dataFormats = dataFormats;
    }
    public Map<String, DataFormatType> getDataFormats() {
        return dataFormats;
    }
    public void setFactoryFinderClass(Class<? extends FactoryFinder> finderClass) {
        factoryFinderClass = finderClass;
    }
    public FactoryFinder createFactoryFinder() {
        try {
            return factoryFinderClass.newInstance();
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public FactoryFinder createFactoryFinder(String path) {
        try {
            Constructor<? extends FactoryFinder> constructor;
            constructor = factoryFinderClass.getConstructor(String.class);
            return constructor.newInstance(path);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.component.bean.BeanExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Exchange for the bean component.
 *
 * @version $Revision$
 */
public class BeanExchange extends DefaultExchange {
    public BeanExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public BeanExchange(DefaultExchange parent) {
        super(parent);
    }
    public BeanInvocation getInvocation() {
        return getIn().getBody(BeanInvocation.class);
    }
    public void setInvocation(BeanInvocation invocation) {
        getIn().setBody(invocation);
    }
    @Override
    public Exchange newInstance() {
        return new BeanExchange(this);
    }
}
"
org.apache.camel.spring.CamelContextFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Routes;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultLifecycleStrategy;
import org.apache.camel.management.DefaultInstrumentationAgent;
import org.apache.camel.management.InstrumentationLifecycleStrategy;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.model.InterceptType;
import org.apache.camel.model.ProceedType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteBuilderRef;
import org.apache.camel.model.RouteContainer;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatsType;
import org.apache.camel.processor.interceptor.Debugger;
import org.apache.camel.processor.interceptor.Delayer;
import org.apache.camel.processor.interceptor.TraceFormatter;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.ResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A Spring {@link FactoryBean} to create and initialize a
 * {@link SpringCamelContext} and install routes either explicitly configured in
 * Spring XML or found by searching the classpath for Java classes which extend
 * {@link RouteBuilder} using the nested {@link #setPackages(String[])}.
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""camelContext"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer, FactoryBean, InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener {
    private static final Log LOG = LogFactory.getLog(CamelContextFactoryBean.class);
    @XmlAttribute(required = false)
    @Deprecated
    private Boolean useJmx = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Boolean autowireRouteBuilders = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Boolean trace;
    @XmlAttribute(required = false)
    private Long delay;
    @XmlAttribute(required = false)
    private String errorHandlerRef;
    @XmlAttribute(required = false)
    private Boolean shouldStartContext = Boolean.TRUE;
    @XmlElement(name = ""package"", required = false)
    private String[] packages = {};
    @XmlElement(name = ""jmxAgent"", type = CamelJMXAgentType.class, required = false)
    private CamelJMXAgentType camelJMXAgent;
    @XmlElements({
        @XmlElement(name = ""beanPostProcessor"", type = CamelBeanPostProcessor.class, required = false),
        @XmlElement(name = ""template"", type = CamelTemplateFactoryBean.class, required = false),
        @XmlElement(name = ""proxy"", type = CamelProxyFactoryType.class, required = false),
        @XmlElement(name = ""export"", type = CamelServiceExporterType.class, required = false)})
    private List beans;
    @XmlElement(name = ""routeBuilderRef"", required = false)
    private List<RouteBuilderRef> builderRefs = new ArrayList<RouteBuilderRef>();
    @XmlElement(name = ""endpoint"", required = false)
    private List<EndpointFactoryBean> endpoints;
    @XmlElement(name = ""dataFormats"", required = false)
    private DataFormatsType dataFormats;
    @XmlElement(name = ""intercept"", required = false)
    private List<InterceptType> intercepts = new ArrayList<InterceptType>();
    @XmlElement(name = ""route"", required = false)
    private List<RouteType> routes = new ArrayList<RouteType>();
    @XmlTransient
    private SpringCamelContext context;
    @XmlTransient
    private RouteBuilder routeBuilder;
    @XmlTransient
    private List<Routes> additionalBuilders = new ArrayList<Routes>();
    @XmlTransient
    private ApplicationContext applicationContext;
    @XmlTransient
    private ClassLoader contextClassLoaderOnStart;
    @XmlTransient
    private BeanPostProcessor beanPostProcessor;
    public CamelContextFactoryBean() {
        // Lets keep track of the class loader for when we actually do start things up
        contextClassLoaderOnStart = Thread.currentThread().getContextClassLoader();
    }
    public Object getObject() throws Exception {
        return getContext();
    }
    public Class getObjectType() {
        return SpringCamelContext.class;
    }
    public boolean isSingleton() {
        return true;
    }
    public ClassLoader getContextClassLoaderOnStart() {
        return contextClassLoaderOnStart;
    }
    public List<Routes> getAdditionalBuilders() {
        return additionalBuilders;
    }
    public void afterPropertiesSet() throws Exception {
        // TODO there should be a neater way to do this!
        Debugger debugger = getBeanForType(Debugger.class);
        if (debugger != null) {
            getContext().addInterceptStrategy(debugger);
        }
        Tracer tracer = getBeanForType(Tracer.class);
        if (tracer != null) {
            // use formatter if there is a TraceFormatter bean defined
            TraceFormatter formatter = getBeanForType(TraceFormatter.class);
            if (formatter != null) {
                tracer.setFormatter(formatter);
            }
            getContext().addInterceptStrategy(tracer);
        }
        Delayer delayer = getBeanForType(Delayer.class);
        if (delayer != null) {
            getContext().addInterceptStrategy(delayer);
        }
        // set the lifecycle strategy if defined
        LifecycleStrategy lifecycleStrategy = getBeanForType(LifecycleStrategy.class);
        if (lifecycleStrategy != null) {
            getContext().setLifecycleStrategy(lifecycleStrategy);
        }
        // set the strategy if defined
        Registry registry = getBeanForType(Registry.class);
        if (registry != null) {
            getContext().setRegistry(registry);
        }
        // Set the application context and camelContext for the beanPostProcessor
        if (beanPostProcessor != null) {
            if (beanPostProcessor instanceof ApplicationContextAware) {
                ((ApplicationContextAware)beanPostProcessor).setApplicationContext(applicationContext);
            }
            if (beanPostProcessor instanceof CamelBeanPostProcessor) {
                ((CamelBeanPostProcessor)beanPostProcessor).setCamelContext(getContext());
            }
        }
        // setup the intercepts
        for (RouteType route : routes) {
            for (InterceptType intercept : intercepts) {
                List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
                List<ProcessorType<?>> exceptionHandlers = new ArrayList<ProcessorType<?>>();
                for (ProcessorType output : route.getOutputs()) {
                    if (output instanceof ExceptionType) {
                        exceptionHandlers.add(output);
                    } else {
                        outputs.add(output);
                    }
                }
                // clearing the outputs
                route.clearOutput();
                // add exception handlers as top children
                route.getOutputs().addAll(exceptionHandlers);
                // add the interceptor
                InterceptType proxy = intercept.createProxy();
                route.addOutput(proxy);
                route.pushBlock(proxy.getProceed());
                int outputsSize = proxy.getOutputs().size();
                if (outputsSize > 0) {
                    ProcessorType processorType = proxy.getOutputs().get(outputsSize - 1);
                    if (processorType instanceof ProceedType) {
                        route.getOutputs().addAll(outputs);
                    }
                }
            }
        }
        if (dataFormats != null) {
            getContext().setDataFormats(dataFormats.asMap());
        }
        // lets force any lazy creation
        getContext().addRouteDefinitions(routes);
        if (!isJmxEnabled() || (camelJMXAgent != null && camelJMXAgent.isDisabled())) {
            LOG.debug(""JMXAgent disabled"");
            getContext().setLifecycleStrategy(new DefaultLifecycleStrategy());
        } else if (camelJMXAgent != null) {
            LOG.debug(""JMXAgent enabled"");
            if (lifecycleStrategy != null) {
                LOG.warn(""lifecycleStrategy will be overriden by InstrumentationLifecycleStrategy"");
            }
            DefaultInstrumentationAgent agent = new DefaultInstrumentationAgent();
            agent.setConnectorPort(camelJMXAgent.getConnectorPort());
            agent.setCreateConnector(camelJMXAgent.isCreateConnector());
            agent.setMBeanObjectDomainName(camelJMXAgent.getMbeanObjectDomainName());
            agent.setMBeanServerDefaultDomain(camelJMXAgent.getMbeanServerDefaultDomain());
            agent.setRegistryPort(camelJMXAgent.getRegistryPort());
            agent.setServiceUrlPath(camelJMXAgent.getServiceUrlPath());
            agent.setUsePlatformMBeanServer(camelJMXAgent.isUsePlatformMBeanServer());
            getContext().setLifecycleStrategy(new InstrumentationLifecycleStrategy(agent));
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found JAXB created routes: "" + getRoutes());
        }
        findRouteBuilders();
        installRoutes();
    }
    private <T> T getBeanForType(Class<T> clazz) {
        T bean = null;
        String[] names = getApplicationContext().getBeanNamesForType(clazz, true, true);
        if (names.length == 1) {
            bean = (T) getApplicationContext().getBean(names[0], clazz);
        }
        if (bean == null) {
            ApplicationContext parentContext = getApplicationContext().getParent();
            if (parentContext != null) {
                names = parentContext.getBeanNamesForType(clazz, true, true);
                if (names.length == 1) {
                    bean = (T) parentContext.getBean(names[0], clazz);
                }
            }
        }
        return bean;
    }
    public void destroy() throws Exception {
        getContext().stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing spring-event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initialized
            try {
                LOG.debug(""Starting the context now!"");
                getContext().start();
            } catch (Exception e) {
                throw wrapRuntimeCamelException(e);
            }
        }
        /*
         * if (context != null) { context.onApplicationEvent(event); }
         */
    }
    // Properties
    // -------------------------------------------------------------------------
    public SpringCamelContext getContext() throws Exception {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(SpringCamelContext context) {
        this.context = context;
    }
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public List<InterceptType> getIntercepts() {
        return intercepts;
    }
    public void setIntercepts(List<InterceptType> intercepts) {
        this.intercepts = intercepts;
    }
    public RouteBuilder getRouteBuilder() {
        return routeBuilder;
    }
    /**
     * Set a single {@link RouteBuilder} to be used to create the default routes
     * on startup
     */
    public void setRouteBuilder(RouteBuilder routeBuilder) {
        this.routeBuilder = routeBuilder;
    }
    /**
     * Set a collection of {@link RouteBuilder} instances to be used to create
     * the default routes on startup
     */
    public void setRouteBuilders(RouteBuilder[] builders) {
        for (RouteBuilder builder : builders) {
            additionalBuilders.add(builder);
        }
    }
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            throw new IllegalArgumentException(""No applicationContext has been injected!"");
        }
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String[] getPackages() {
        return packages;
    }
    /**
     * Sets the package names to be recursively searched for Java classes which
     * extend {@link RouteBuilder} to be auto-wired up to the
     * {@link SpringCamelContext} as a route. Note that classes are excluded if
     * they are specifically configured in the spring.xml
     *
     * @param packages the package names which are recursively searched
     */
    public void setPackages(String[] packages) {
        this.packages = packages;
    }
    public void setBeanPostProcessor(BeanPostProcessor postProcessor) {
        this.beanPostProcessor = postProcessor;
    }
    public BeanPostProcessor getBeanPostProcessor() {
        return beanPostProcessor;
    }
    /**
     * This method merely retrieves the value of the ""useJmx"" attribute and does
     * not consider the ""disabled"" flag in jmxAgent element.  The useJmx
     * attribute will be removed in 2.0.  Please the jmxAgent element instead.
     *
     * @deprecated Please the jmxAgent element instead. Will be removed in Camel 2.0.
     */
    public boolean isJmxEnabled() {
        return useJmx.booleanValue();
    }
    /**
     * @deprecated Please the jmxAgent element instead. Will be removed in Camel 2.0.
     */
    public Boolean getUseJmx() {
        return useJmx;
    }
    /**
     * @deprecated Please the jmxAgent element instead. Will be removed in Camel 2.0.
     */
    public void setUseJmx(Boolean useJmx) {
        this.useJmx = useJmx;
    }
    public void setCamelJMXAgent(CamelJMXAgentType agent) {
        camelJMXAgent = agent;
    }
    public Boolean getTrace() {
        return trace;
    }
    public void setTrace(Boolean trace) {
        this.trace = trace;
    }
    public Long getDelay() {
        return delay;
    }
    public void setDelay(Long delay) {
        this.delay = delay;
    }
    public CamelJMXAgentType getCamelJMXAgent() {
        return camelJMXAgent;
    }
    public List<RouteBuilderRef> getBuilderRefs() {
        return builderRefs;
    }
    public void setBuilderRefs(List<RouteBuilderRef> builderRefs) {
        this.builderRefs = builderRefs;
    }
    /**
     * If enabled this will force all {@link RouteBuilder} classes configured in the Spring
     * {@link ApplicationContext} to be registered automatically with this CamelContext.
     */
    public void setAutowireRouteBuilders(Boolean autowireRouteBuilders) {
        this.autowireRouteBuilders = autowireRouteBuilders;
    }
    public String getErrorHandlerRef() {
        return errorHandlerRef;
    }
    /**
     * Sets the name of the error handler object used to default the error handling strategy
     *
     * @param errorHandlerRef the Spring bean ref of the error handler
     */
    public void setErrorHandlerRef(String errorHandlerRef) {
        this.errorHandlerRef = errorHandlerRef;
    }
    public Boolean getShouldStartContext() {
        return shouldStartContext;
    }
    public void setShouldStartContext(Boolean shouldStartContext) {
        this.shouldStartContext = shouldStartContext;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Create the context
     */
    protected SpringCamelContext createContext() {
        SpringCamelContext ctx = new SpringCamelContext(getApplicationContext());
        ctx.setName(getId());
        if (trace != null) {
            ctx.setTrace(trace);
        }
        if (delay != null) {
            ctx.setDelay(delay);
        }
        if (errorHandlerRef != null) {
            ErrorHandlerBuilder errorHandlerBuilder = (ErrorHandlerBuilder) getApplicationContext().getBean(errorHandlerRef, ErrorHandlerBuilder.class);
            if (errorHandlerBuilder == null) {
                throw new IllegalArgumentException(""Could not find bean: "" + errorHandlerRef);
            }
            ctx.setErrorHandlerBuilder(errorHandlerBuilder);
        }
        if (shouldStartContext != null) {
            ctx.setShouldStartContext(shouldStartContext);
        }
        return ctx;
    }
    /**
     * Strategy to install all available routes into the context
     */
    protected void installRoutes() throws Exception {
        if (autowireRouteBuilders != null && autowireRouteBuilders.booleanValue()) {
            Map builders = getApplicationContext().getBeansOfType(RouteBuilder.class, true, true);
            if (builders != null) {
                for (Object builder : builders.values()) {
                    getContext().addRoutes((RouteBuilder) builder);
                }
            }
        }
        for (Routes routeBuilder : additionalBuilders) {
            getContext().addRoutes(routeBuilder);
        }
        if (routeBuilder != null) {
            getContext().addRoutes(routeBuilder);
        }
        // lets add route builders added from references
        if (builderRefs != null) {
            for (RouteBuilderRef builderRef : builderRefs) {
                RouteBuilder builder = builderRef.createRouteBuilder(getContext());
                getContext().addRoutes(builder);
            }
        }
    }
    /**
     * Strategy method to try find {@link RouteBuilder} instances on the
     * classpath
     */
    protected void findRouteBuilders() throws Exception, InstantiationException {
        if (getPackages() != null && getPackages().length > 0) {
            RouteBuilderFinder finder = new RouteBuilderFinder(getContext(), getPackages(), getContextClassLoaderOnStart(), getBeanPostProcessor(), createResolverUtil());
            finder.appendBuilders(getAdditionalBuilders());
        }
    }
    /**
     * The factory method for create the ResolverUtil
     * @return a new instance of ResolverUtil
     */
    protected ResolverUtil createResolverUtil() {
        return new ResolverUtil();
    }
    public void setDataFormats(DataFormatsType dataFormats) {
        this.dataFormats = dataFormats;
    }
    public DataFormatsType getDataFormats() {
        return dataFormats;
    }
}
"
org.apache.camel.dataformat.csv.CsvDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.csv;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVStrategy;
import org.apache.commons.csv.writer.CSVConfig;
import org.apache.commons.csv.writer.CSVField;
import org.apache.commons.csv.writer.CSVWriter;
/**
 * @version $Revision$
 */
public class CsvDataFormat implements DataFormat {
    private CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;
    private CSVConfig config = new CSVConfig();
    public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws Exception {
        Map map = ExchangeHelper.convertToMandatoryType(exchange, Map.class, object);
        OutputStreamWriter out = new OutputStreamWriter(outputStream);
        try {
            CSVConfig conf = getConfig();
            // lets add fields
            Set set = map.keySet();
            for (Object value : set) {
                if (value != null) {
                    String text = value.toString();
                    CSVField field = new CSVField(text);
                    conf.addField(field);
                }
            }
            CSVWriter writer = new CSVWriter(conf);
            writer.setWriter(out);
            writer.writeRecord(map);
        } finally {
            out.close();
        }
    }
    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {
        InputStreamReader in = new InputStreamReader(inputStream);
        try {
            CSVParser parser = new CSVParser(in, getStrategy());
            List<List<String>> list = new ArrayList<List<String>>();
            while (true) {
                String[] strings = parser.getLine();
                if (strings == null) {
                    break;
                }
                List<String> line = Arrays.asList(strings);
                list.add(line);
            }
            if (list.size() == 1) {
                return list.get(0);
            } else {
                return list;
            }
        } finally {
            in.close();
        }
    }
    public CSVConfig getConfig() {
        if (config == null) {
            config = createConfig();
        }
        return config;
    }
    public void setConfig(CSVConfig config) {
        this.config = config;
    }
    public CSVStrategy getStrategy() {
        return strategy;
    }
    public void setStrategy(CSVStrategy strategy) {
        this.strategy = strategy;
    }
    protected CSVConfig createConfig() {
        return new CSVConfig();
    }
}
"
org.apache.camel.component.jms.requestor.PersistentReplyToRequestor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.math.BigInteger;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
public class PersistentReplyToRequestor extends Requestor {
    private String replyToSelectorValue;
    public class DestinationResolverDelegate implements DestinationResolver {
        private DestinationResolver delegate;
        private Destination destination;
        public DestinationResolverDelegate(DestinationResolver delegate) {
            this.delegate = delegate;
        }
        public Destination resolveDestinationName(Session session, String destinationName,
                                                  boolean pubSubDomain) throws JMSException {
            synchronized (getOutterInstance()) {
                try {
                    if (destination == null) {
                        destination = delegate.resolveDestinationName(session, destinationName, pubSubDomain);
                        setReplyTo(destination);
                    }
                } finally {
                    getOutterInstance().notifyAll();
                }
            }
            return destination;
        }
    };
    public static interface MessageSelectorComposer {
        void addCorrelationID(String id);
        void removeCorrelationID(String id);
    }
    public static class CamelDefaultMessageListenerContainer102 extends DefaultMessageListenerContainer102
                                                                implements MessageSelectorComposer {
        MessageSelectorProvider provider = new MessageSelectorProvider();
        public void addCorrelationID(String id) {
            provider.addCorrelationID(id);
        }
        public void removeCorrelationID(String id) {
            provider.removeCorrelationID(id);
        }
        @Override
        public void setMessageSelector(String messageSelector) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String getMessageSelector() {
            return provider.get();
        }
    }
    public static class CamelDefaultMessageListenerContainer extends DefaultMessageListenerContainer
                                                             implements MessageSelectorComposer {
        MessageSelectorProvider provider = new MessageSelectorProvider();
        public void addCorrelationID(String id) {
            provider.addCorrelationID(id);
        }
        public void removeCorrelationID(String id) {
            provider.removeCorrelationID(id);
        }
        @Override
        public void setMessageSelector(String messageSelector) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String getMessageSelector() {
            return provider.get();
        }
    }
    public PersistentReplyToRequestor(JmsConfiguration configuration,
                                      ScheduledExecutorService executorService) {
        super(configuration, executorService);
    }
    @Override
    protected FutureHandler createFutureHandler(String correlationID) {
        boolean dynamicSelector = getConfiguration().getReplyToDestinationSelectorName() == null;
        if (dynamicSelector) {
            return new PersistentReplyToFutureHandler(this, correlationID);
        }
        return new FutureHandler();
    }
    @Override
    protected FutureHandler createFutureHandler(DeferredMessageSentCallback callback) {
        boolean dynamicSelector = getConfiguration().getReplyToDestinationSelectorName() == null;
        if (dynamicSelector) {
            return new PersistentReplyToFutureHandler(this, callback);
        }
        return new FutureHandler();
    }
    @Override
    public AbstractMessageListenerContainer createListenerContainer() {
        JmsConfiguration config = getConfiguration();
        String replyToSelectorName = getConfiguration().getReplyToDestinationSelectorName();
        AbstractMessageListenerContainer container =
            config.isUseVersion102()
                    ? (replyToSelectorName != null) ? new DefaultMessageListenerContainer102()
                           : new CamelDefaultMessageListenerContainer102()
                    : (replyToSelectorName != null) ? new DefaultMessageListenerContainer()
                           : new CamelDefaultMessageListenerContainer();
        container.setConnectionFactory(config.getListenerConnectionFactory());
        DestinationResolver resolver = config.getDestinationResolver();
        if (resolver == null) {
            resolver = container.getDestinationResolver();
        }
        container.setDestinationResolver(new DestinationResolverDelegate(resolver));
        container.setDestinationName(getConfiguration().getReplyTo());
        if (replyToSelectorName != null) {
            replyToSelectorValue = ""ID:"" + new BigInteger(24 * 8, new Random()).toString(16);
            container.setMessageSelector(replyToSelectorName + ""='"" + replyToSelectorValue + ""'"");
        } else {
            ((MessageSelectorComposer)container).addCorrelationID(""ID:"" + new BigInteger(24 * 8, new Random()).toString(16));
        }
        container.setAutoStartup(true);
        container.setMessageListener(this);
        container.setPubSubDomain(false);
        container.setSubscriptionDurable(false);
        ExceptionListener exceptionListener = config.getExceptionListener();
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setSessionTransacted(config.isTransacted());
        if (config.isTransacted()) {
            container.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            if (config.getAcknowledgementMode() >= 0) {
                container.setSessionAcknowledgeMode(config.getAcknowledgementMode());
            } else if (config.getAcknowledgementModeName() != null) {
                container.setSessionAcknowledgeModeName(config.getAcknowledgementModeName());
            }
        }
        if (container instanceof DefaultMessageListenerContainer) {
            DefaultMessageListenerContainer defContainer = (DefaultMessageListenerContainer)container;
            defContainer.setConcurrentConsumers(1);
            defContainer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION);
            if (config.getReceiveTimeout() >= 0) {
                defContainer.setReceiveTimeout(config.getReceiveTimeout());
            }
            if (config.getRecoveryInterval() >= 0) {
                defContainer.setRecoveryInterval(config.getRecoveryInterval());
            }
            TaskExecutor taskExecutor = config.getTaskExecutor();
            if (taskExecutor != null) {
                defContainer.setTaskExecutor(taskExecutor);
            }
            PlatformTransactionManager tm = config.getTransactionManager();
            if (tm != null) {
                defContainer.setTransactionManager(tm);
            } else if (config.isTransacted()) {
                throw new IllegalArgumentException(""Property transacted is enabled but a transactionManager was not injected!"");
            }
            if (config.getTransactionName() != null) {
                defContainer.setTransactionName(config.getTransactionName());
            }
            if (config.getTransactionTimeout() >= 0) {
                defContainer.setTransactionTimeout(config.getTransactionTimeout());
            }
        }
        return container;
    }
    @Override
    public void setReplyToSelectorHeader(org.apache.camel.Message in, Message jmsIn) throws JMSException {
        String replyToSelectorName = getConfiguration().getReplyToDestinationSelectorName();
        if (replyToSelectorValue != null) {
            in.setHeader(replyToSelectorName, replyToSelectorValue);
            jmsIn.setStringProperty(replyToSelectorName, replyToSelectorValue);
        }
    }
}
"
org.apache.camel.RuntimeTransformException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if a message transformation fails
 * 
 * @version $Revision$
 */
public class RuntimeTransformException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeTransformException(String message) {
        super(message);
    }
    public RuntimeTransformException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeTransformException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.impl.ProxyInstantiationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
/**
 * A proxy creation failed trying to create a proxy of a given type and on an given endpoint
 *
 * @version $Revision$
 */
public class ProxyInstantiationException extends RuntimeException {
    private final Class<?> type;
    private final Endpoint endpoint;
    public ProxyInstantiationException(Class<?> type, Endpoint endpoint, Throwable cause) {
        super(""Could not instantiate proxy of type "" + type.getName() + "" on endpoint "" + endpoint, cause);
        this.type = type;
        this.endpoint = endpoint;
    }
    public Class<?> getType() {
        return type;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.component.freemarker.FreemarkerComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.freemarker;
import java.util.Map;
import freemarker.cache.ClassTemplateLoader;
import freemarker.template.Configuration;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.springframework.core.io.Resource;
/**
 * Freemarker component.
 */
public class FreemarkerComponent extends DefaultComponent {
    private Configuration configuraiton;
    private Configuration noCacheConfiguration;
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        FreemarkerEndpoint endpoint = new FreemarkerEndpoint(uri, this, remaining, parameters);
        // should we use regular configuration or no cache (content cache is default true)
        Configuration config;
        boolean cache = (Boolean) getAndRemoveParameter(parameters, ""contentCache"", Boolean.class, Boolean.TRUE);
        if (cache) {
            config = getConfiguraiton();
        } else {
            config = getNoCacheConfiguration();
        }
        endpoint.setConfiguration(config);
        return endpoint;
    }
    public synchronized Configuration getConfiguraiton() {
        if (configuraiton == null) {
            configuraiton = new Configuration();
            // use class template loader using Spring Resource class and / as root in classpath
            configuraiton.setTemplateLoader(new ClassTemplateLoader(Resource.class, ""/""));
        }
        return (Configuration) configuraiton.clone();
    }
    public void setConfiguraiton(Configuration configuraiton) {
        this.configuraiton = configuraiton;
    }
    private synchronized Configuration getNoCacheConfiguration() {
        if (noCacheConfiguration == null) {
            // create a clone of the regular configuration
            noCacheConfiguration = (Configuration) getConfiguraiton().clone();
            // set this one to not use cache
            noCacheConfiguration.setCacheStorage(new NoCacheStorage());
        }
        return noCacheConfiguration;
    }
}
"
org.apache.camel.component.irc.IrcErrorLogger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.commons.logging.Log;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * A helper class which logs errors
 *
 * @version $Revision$
 */
public class IrcErrorLogger extends IRCEventAdapter {
    private Log log;
    public IrcErrorLogger(Log log) {
        this.log = log;
    }
    @Override
    public void onRegistered() {
        super.onRegistered();
        log.info(""onRegistered"");
    }
    @Override
    public void onDisconnected() {
        super.onDisconnected();
        log.info(""onDisconnected"");
    }
    @Override
    public void onMode(String string, IRCUser ircUser, IRCModeParser ircModeParser) {
        super.onMode(string, ircUser, ircModeParser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.ircModeParser = "" + ircModeParser);
    }
    @Override
    public void onMode(IRCUser ircUser, String string, String string1) {
        super.onMode(ircUser, string, string1);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.string1 = "" + string1);
    }
    @Override
    public void onPing(String string) {
        super.onPing(string);
        log.info(""onPing.string = "" + string);
    }
    @Override
    public void onError(String string) {
        log.info(""onError.string = "" + string);
    }
    @Override
    public void onError(int i, String string) {
        super.onError(i, string);
        log.error(""onError.i = "" + i);
        log.error(""onError.string = "" + string);
    }
    @Override
    public void unknown(String string, String string1, String string2, String string3) {
        super.unknown(string, string1, string2, string3);
        log.error(""unknown.string = "" + string);
        log.error(""unknown.string1 = "" + string1);
        log.error(""unknown.string2 = "" + string2);
        log.error(""unknown.string3 = "" + string3);
    }
}
"
org.apache.camel.component.cxf.transport.CamelConduit,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfSoapBinding;
import org.apache.camel.component.cxf.util.CxfHeaderHelper;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelConduit extends AbstractConduit implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-conduit"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelConduit.class);
    private CamelContext camelContext;
    private EndpointInfo endpointInfo;
    private String targetCamelEndpointUri;
    private ProducerTemplate<Exchange> camelTemplate;
    private Bus bus;
    private HeaderFilterStrategy headerFilterStrategy;
    public CamelConduit(CamelContext context, Bus b, EndpointInfo endpointInfo) {
        this(context, b, endpointInfo, null);
    }
    public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference) {
        this(context, b, epInfo, targetReference, null);
    }
    public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference,
            HeaderFilterStrategy headerFilterStrategy) {
        super(getTargetReference(epInfo, targetReference, b));
        String address = epInfo.getAddress();
        if (address != null) {
            targetCamelEndpointUri = address.substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());
            if (targetCamelEndpointUri.startsWith(""//"")) {
                targetCamelEndpointUri = targetCamelEndpointUri.substring(2);
            }
        }
        camelContext = context;
        endpointInfo = epInfo;
        bus = b;
        initConfig();
        this.headerFilterStrategy = headerFilterStrategy;
    }
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        if (camelContext == null) {
            getLogger().log(Level.INFO, ""No CamelContext injected, create a default one"");
            camelContext = new DefaultCamelContext();
        }
        return camelContext;
    }
    // prepare the message for send out , not actually send out the message
    public void prepare(Message message) throws IOException {
        getLogger().log(Level.FINE, ""CamelConduit send message"");
        message.setContent(OutputStream.class, new CamelOutputStream(message));
    }
    public void close() {
        getLogger().log(Level.FINE, ""CamelConduit closed "");
    }
    protected Logger getLogger() {
        return LOG;
    }
    public String getBeanName() {
        if (endpointInfo == null || endpointInfo.getName() == null) {
            return ""default"" + BASE_BEAN_NAME_SUFFIX;
        }
        return endpointInfo.getName().toString() + BASE_BEAN_NAME_SUFFIX;
    }
    private void initConfig() {
        // we could configure the camel context here
        if (bus != null) {
            Configurer configurer = bus.getExtension(Configurer.class);
            if (null != configurer) {
                configurer.configureBean(this);
            }
        }
    }
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {            
            camelTemplate = getCamelContext().createProducerTemplate();
        }
        return camelTemplate;
    }
    public void setCamelTemplate(ProducerTemplate<Exchange> template) {
        camelTemplate = template;
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message outMessage;
        private boolean isOneWay;
        public CamelOutputStream(Message m) {
            outMessage = m;
        }
        protected void doFlush() throws IOException {
            // do nothing here
        }
        protected void doClose() throws IOException {
            isOneWay = outMessage.getExchange().isOneWay();
            commitOutputMessage();
        }
        protected void onWrite() throws IOException {
            // do nothing here
        }
        private void commitOutputMessage() {
            ExchangePattern pattern;
            if (isOneWay) {
                pattern = ExchangePattern.InOnly;
            } else {
                pattern = ExchangePattern.InOut;
            }
            getLogger().log(Level.FINE, ""send the message to endpoint"" + targetCamelEndpointUri);
            // We could wait for the rely asynchronously
            org.apache.camel.Exchange exchange = getCamelTemplate().send(targetCamelEndpointUri, pattern, new Processor() {
                public void process(org.apache.camel.Exchange ex) throws IOException {
                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
                    // Send out the request message here, copy the protocolHeader back
                    CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, ex.getIn().getHeaders());
                    // TODO support different encoding
                    ex.getIn().setBody(outputStream.getBytes());
                    getLogger().log(Level.FINE, ""template sending request: "", ex.getIn());
                }
            });
            exchange.setProperty(CxfConstants.CXF_EXCHANGE, outMessage.getExchange());
            if (!isOneWay) {
                handleResponse(exchange);
            }
        }
        private void handleResponse(org.apache.camel.Exchange exchange) {
            org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(headerFilterStrategy,
                    exchange, true);
            incomingObserver.onMessage(inMessage);
        }
    }
    /**
     * Represented decoupled response endpoint.
     */
    protected class DecoupledDestination implements Destination {
        protected MessageObserver decoupledMessageObserver;
        private EndpointReferenceType address;
        DecoupledDestination(EndpointReferenceType ref, MessageObserver incomingObserver) {
            address = ref;
            decoupledMessageObserver = incomingObserver;
        }
        public EndpointReferenceType getAddress() {
            return address;
        }
        public Conduit getBackChannel(Message inMessage, Message partialResponse, EndpointReferenceType addr) throws IOException {
            // shouldn't be called on decoupled endpoint
            return null;
        }
        public void shutdown() {
        }
        public synchronized void setMessageObserver(MessageObserver observer) {
            decoupledMessageObserver = observer;
        }
        public synchronized MessageObserver getMessageObserver() {
            return decoupledMessageObserver;
        }
    }
}
"
org.apache.camel.component.xmpp.RuntimeXmppException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.jivesoftware.smack.XMPPException;
/**
 * A runtime exception thrown if sending or receiving from XMPP fails
 *
 * @version $Revision:520964 $
 */
public class RuntimeXmppException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeXmppException(XMPPException cause) {
        super(cause);
    }
    public RuntimeXmppException(String message, XMPPException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.builder.DeadLetterChannelBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.ErrorHandlerSupport;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
import org.apache.camel.processor.interceptor.StreamCaching;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A builder of a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 *
 * @version $Revision$
 */
public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport {
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    private Processor onRedelivery;
    private ExceptionPolicyStrategy exceptionPolicyStrategy = ErrorHandlerSupport.createDefaultExceptionPolicyStrategy();
    private ProcessorFactory deadLetterFactory;
    private Processor defaultDeadLetterEndpoint;
    private Expression defaultDeadLetterEndpointExpression;
    private String defaultDeadLetterEndpointUri = ""log:org.apache.camel.DeadLetterChannel?level=error"";
    private Logger logger = DeadLetterChannel.createDefaultLogger();
    public DeadLetterChannelBuilder() {
    }
    public DeadLetterChannelBuilder(Processor processor) {
        this(new ConstantProcessorBuilder(processor));
    }
    public DeadLetterChannelBuilder(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public ErrorHandlerBuilder copy() {
        DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder(deadLetterFactory);
        answer.setRedeliveryPolicy(getRedeliveryPolicy().copy());
        return answer;
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        Processor deadLetter = getDeadLetterFactory().createProcessor();
        DeadLetterChannel answer = new DeadLetterChannel(processor, deadLetter, onRedelivery, getRedeliveryPolicy(), getLogger(), getExceptionPolicyStrategy());
        StreamCaching.enable(routeContext);
        configure(answer);
        return answer;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    public DeadLetterChannelBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public DeadLetterChannelBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public DeadLetterChannelBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public DeadLetterChannelBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public DeadLetterChannelBuilder maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        getRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    public DeadLetterChannelBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public DeadLetterChannelBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    public DeadLetterChannelBuilder retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {
        getRedeliveryPolicy().setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        return this;
    }
    public DeadLetterChannelBuilder retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {
        getRedeliveryPolicy().setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        return this;
    }
    /**
     * Sets the logger used for caught exceptions
     */
    public DeadLetterChannelBuilder logger(Logger logger) {
        setLogger(logger);
        return this;
    }
    /**
     * Sets the logging level of exceptions caught
     */
    public DeadLetterChannelBuilder loggingLevel(LoggingLevel level) {
        getLogger().setLevel(level);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Log log) {
        getLogger().setLog(log);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(String log) {
        return log(LogFactory.getLog(log));
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Class log) {
        return log(LogFactory.getLog(log));
    }
    /**
     * Sets the exception policy to use
     */
    public DeadLetterChannelBuilder exceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        setExceptionPolicyStrategy(exceptionPolicyStrategy);
        return this;
    }
    /**
     * Sets a processor that should be processed <b>before</b> a redelivey attempt.
     * <p/>
     * Can be used to change the {@link org.apache.camel.Exchange} <b>before</b> its being redelivered.
     */
    public DeadLetterChannelBuilder onRedelivery(Processor processor) {
        setOnRedelivery(processor);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public ProcessorFactory getDeadLetterFactory() {
        if (deadLetterFactory == null) {
            deadLetterFactory = new ProcessorFactory() {
                public Processor createProcessor() {
                    return getDefaultDeadLetterEndpoint();
                }
            };
        }
        return deadLetterFactory;
    }
    /**
     * Sets the default dead letter queue factory
     */
    public void setDeadLetterFactory(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public Processor getDefaultDeadLetterEndpoint() {
        if (defaultDeadLetterEndpoint == null) {
            defaultDeadLetterEndpoint = new RecipientList(getDefaultDeadLetterEndpointExpression());
        }
        return defaultDeadLetterEndpoint;
    }
    /**
     * Sets the default dead letter endpoint used
     */
    public void setDefaultDeadLetterEndpoint(Processor defaultDeadLetterEndpoint) {
        this.defaultDeadLetterEndpoint = defaultDeadLetterEndpoint;
    }
    public Expression getDefaultDeadLetterEndpointExpression() {
        if (defaultDeadLetterEndpointExpression == null) {
            defaultDeadLetterEndpointExpression = ExpressionBuilder
                .constantExpression(getDefaultDeadLetterEndpointUri());
        }
        return defaultDeadLetterEndpointExpression;
    }
    /**
     * Sets the expression used to decide the dead letter channel endpoint for
     * an exchange if no factory is provided via
     * {@link #setDeadLetterFactory(ProcessorFactory)}
     */
    public void setDefaultDeadLetterEndpointExpression(Expression defaultDeadLetterEndpointExpression) {
        this.defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression;
    }
    public String getDefaultDeadLetterEndpointUri() {
        return defaultDeadLetterEndpointUri;
    }
    /**
     * Sets the default dead letter endpoint URI used if no factory is provided
     * via {@link #setDeadLetterFactory(ProcessorFactory)} and no expression is
     * provided via {@link #setDefaultDeadLetterEndpointExpression(Expression)}
     *
     * @param defaultDeadLetterEndpointUri the default URI if no deadletter
     *                factory or expression is provided
     */
    public void setDefaultDeadLetterEndpointUri(String defaultDeadLetterEndpointUri) {
        this.defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri;
    }
    public Logger getLogger() {
        return logger;
    }
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
    /**
     * Sets the exception policy strategy to use for resolving the {@link org.apache.camel.model.ExceptionType}
     * to use for a given thrown exception
     */
    public ExceptionPolicyStrategy getExceptionPolicyStrategy() {
        return exceptionPolicyStrategy;
    }
    public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        this.exceptionPolicyStrategy = exceptionPolicyStrategy;
    }
    public Processor getOnRedelivery() {
        return onRedelivery;
    }
    public void setOnRedelivery(Processor onRedelivery) {
        this.onRedelivery = onRedelivery;
    }
    @Override
    public String toString() {
        return ""DeadLetterChannelBuilder("" + (deadLetterFactory != null ? deadLetterFactory : defaultDeadLetterEndpoint) + "")"";
    }
}
"
org.apache.camel.component.cxf.CxfMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.impl.DefaultMessage;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.message.MessageImpl;
/**
 * An Apache CXF {@link Message} which provides access to the underlying CXF
 * features
 *
 * @version $Revision$
 */
public class CxfMessage extends DefaultMessage {
    private Message cxfMessage;
    public CxfMessage() {
        this(new MessageImpl());
    }
    public CxfMessage(Message cxfMessage) {
        if (cxfMessage == null) {
            this.cxfMessage = new MessageImpl();
        } else {
            this.cxfMessage = cxfMessage;
        }
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        if (that.getBody() instanceof Message) {
            setMessage((Message)that.getBody());
        }
        getHeaders().putAll(that.getHeaders());
        if (that instanceof CxfMessage) {
            CxfMessage orig = (CxfMessage) that;
            setMessage(orig.getMessage());
        }
    }
    @Override
    public String toString() {
        if (cxfMessage != null) {
            return ""CxfMessage: "" + cxfMessage;
        } else {
            return ""CxfMessage: "" + getBody();
        }
    }
    @Override
    public CxfExchange getExchange() {
        return (CxfExchange)super.getExchange();
    }
    /**
     * Returns the underlying CXF message
     *
     * @return the CXF message
     */
    public Message getMessage() {
        return cxfMessage;
    }
    public void setMessage(Message cxfMessage) {
        this.cxfMessage = cxfMessage;
    }
    @Override
    public CxfMessage newInstance() {
        return new CxfMessage();
    }
    @Override
    protected Object createBody() {
        return CxfBinding.extractBodyFromCxf(getExchange(), cxfMessage);
    }
    @Override
    public void setBody(Object body) {
        super.setBody(body);
        if (body instanceof Message) {
            setMessage((Message) body);
        }
    }
    public <T> T getBody(Class<T> type) {
        if (!(MessageContentsList.class.isAssignableFrom(type)) && getBody() instanceof MessageContentsList) {
            // if the body is the MessageContentsList then try to convert its payload
            // to make it easier for end-users to use camel-cxf
            MessageContentsList list = (MessageContentsList)getBody();
            for (int i = 0; i < list.size(); i++) {
                Object value = list.get(i);
                try {
                    T answer = getBody(type, value);
                    if (answer != null) {
                        return answer;
                    }
                } catch (NoTypeConversionAvailableException ex) {
                    // ignore
                }
            }
        }
        // default to super
        return super.getBody(type);
    }
}
"
org.apache.camel.component.timer.TimerComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link TimerEndpoint}.  It holds the
 * list of {@link TimerConsumer} objects that are started.
 *
 * @version $Revision$
 */
public class TimerComponent extends DefaultComponent<Exchange> {
    private Map<String, Timer> timers = new HashMap<String, Timer>();
    public Timer getTimer(TimerEndpoint endpoint) {
        String key = endpoint.getTimerName();
        if (!endpoint.isDaemon()) {
            key = ""nonDaemon:"" + key;
        }
        Timer answer = timers.get(key);
        if (answer == null) {
            answer = new Timer(endpoint.getTimerName(), endpoint.isDaemon());
            timers.put(key, answer);
        }
        return answer;
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        TimerEndpoint answer = new TimerEndpoint(uri, this, remaining);
        setProperties(answer, parameters);
        return answer;
    }
    @Override
    protected void doStop() throws Exception {
        Collection<Timer> collection = timers.values();
        for (Timer timer : collection) {
            timer.cancel();
        }
        timers.clear();
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
//import java.util.logging.Level;
//import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.interceptor.MessageSenderInterceptor;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor();
    private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor();
    public DOMOutInterceptor() {
        super(Phase.PREPARE_SEND);
        this.addBefore(MessageSenderInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"", 
                                                                   LOG, message.getClass().getName()));
        }        
    }
}
"
org.apache.camel.converter.jaxb.HeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.Message;
/**
 * Represents a JAXB2 representation of a Camel {@link Message} header
 *
 * @version $Revision$
 */
@XmlType(name = ""headerType"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public abstract class HeaderType {
    @XmlAttribute
    private String name;
    public HeaderType() {
    }
    protected HeaderType(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public abstract Object getValue();
    public abstract void setValue(Object value);
}"
org.apache.camel.component.seda.SedaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.ObjectHelper;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/queue.html"">Queue components</a> for
 * asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision$
 */
public class SedaEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private BlockingQueue<Exchange> queue;
    public SedaEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue) {
        super(endpointUri, component);
        this.queue = queue;
    }
    public SedaEndpoint(String uri, SedaComponent component, Map parameters) {
        this(uri, component, component.createQueue(uri, parameters));
    }
    public SedaEndpoint(String endpointUri, BlockingQueue<Exchange> queue) {
        super(endpointUri);
        ObjectHelper.notNull(queue, ""queue"");
        this.queue = queue;
    }
    public Producer createProducer() throws Exception {
        return new CollectionProducer(this, getQueue());
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new SedaConsumer(this, processor);
    }
    public BlockingQueue<Exchange> getQueue() {
        return queue;
    }
    public boolean isSingleton() {
        return true;
    }
    public List<Exchange> getExchanges() {
        return new ArrayList<Exchange>(getQueue());
    }
}
"
org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.staxutils.StaxUtils;
/**
 * This is the base class for message interceptors that intercepts message as DOM content
 * infers the BindingOperationInfo and then set the
 *
 */
public abstract class AbstractMessageInInterceptor<T extends Message>
       extends AbstractPhaseInterceptor<T> {
    public AbstractMessageInInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    /**
     * Infer the OperationInfo from the XML Document and get the list of
     * parts as DOM Element
     */
    public void handleMessage(T message) throws Fault {
        Logger logger = getLogger();
        if (isFaultMessage(message)) {
            message.getInterceptorChain().abort();
            Endpoint ep = message.getExchange().get(Endpoint.class);
            if (ep.getInFaultObserver() != null) {
                ep.getInFaultObserver().onMessage(message);
                return;
            }
            //Fault f = createFault(message, payloadEl);
            //message.setContent(Exception.class, f);
            //return;
        }
        Document document = createDOMMessage(message);
        //Document document = message.getContent(Document.class);
        Element payloadEl = (Element)document.getChildNodes().item(0);
        Exchange ex = message.getExchange();
        BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
        if (boi == null) {
            BindingInfo bi = ex.get(BindingInfo.class);
            if (bi == null) {
                Endpoint ep = ex.get(Endpoint.class);
                bi = ep.getEndpointInfo().getBinding();
                ex.put(BindingInfo.class, bi);
            }
            // handling inbound message
            if (logger.isLoggable(Level.INFO)) {
                logger.info(""AbstractRoutingMessageInInterceptor Infer BindingOperationInfo."");
            }
            boi = getBindingOperation(message, document);
            if (boi == null) {
                QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
                throw new Fault(new org.apache.cxf.common.i18n.Message(
                                ""REQ_NOT_UNDERSTOOD"", getLogger(), startQName));
            }
            if (boi != null) {
                ex.put(BindingOperationInfo.class, boi);
                ex.put(OperationInfo.class, boi.getOperationInfo());
                ex.setOneWay(boi.getOperationInfo().isOneWay());
                if (logger.isLoggable(Level.INFO)) {
                    logger.info(""DOMInInterceptor- BindingOperation is:"" + boi.getName());
                }
            }
        }
        BindingMessageInfo bmi = isRequestor(message) ?  boi.getOutput() : boi.getInput();
        List<Element> partList = getPartList(message, payloadEl, bmi);
        message.put(List.class, partList);
    }
    /**
     * This method is called to convert a incoming message format e.g Stax Stream
     * to a DOM Tree. Default Implementation converts Stax Stream to a DOM
     */
    protected Document createDOMMessage(T message) {
        Document doc = null;
        try {
            if (getLogger().isLoggable(Level.INFO)) {
                getLogger().info(""AbstractMessageInInterceptor Converting Stax Stream to DOM"");
            }
            XMLStreamReader xsr = message.getContent(XMLStreamReader.class);
            doc = StaxUtils.read(xsr);
        } catch (XMLStreamException xe) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", getLogger()), xe);
        }
        return doc;
    }
    protected abstract Logger getLogger();
    /**
     * This method is called on incoming to check if it is a fault.
     */
    protected abstract boolean isFaultMessage(T message);
    /**
     * This method is called when the routing message interceptor has received a inbound message
     * It infers the binding operation by matching the root Element with a binding operation
     * from the service model.
     */
    protected abstract BindingOperationInfo getBindingOperation(T inMessage, Document document);
    /**
     * This method is called when the routing message interceptor has intercepted a inbound
     * message as a DOM Content.  It retreives the message parts as DOM Element
     * and returns a List of Element.
     */
    protected abstract List<Element> getPartList(T inMessage, Element rootElement, BindingMessageInfo boi);
}
"
org.apache.camel.component.xmpp.XmppBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.jivesoftware.smack.packet.Message;
/**
 * A Strategy used to convert between a Camel {@link XmppExchange} and {@link XmppMessage} to and from a
 * XMPP {@link Message}
 *
 * @version $Revision$
 */
public class XmppBinding {
    private HeaderFilterStrategy headerFilterStrategy;
    public XmppBinding() {
        this.headerFilterStrategy = new DefaultHeaderFilterStrategy();
    }
    public XmppBinding(HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }
    /**
     * Populates the given XMPP message from the inbound exchange
     */
    public void populateXmppMessage(Message message, Exchange exchange) {
        message.setBody(exchange.getIn().getBody(String.class));
        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String name = entry.getKey();
            Object value = entry.getValue();
            // BUG?
            if (headerFilterStrategy != null
                    && !headerFilterStrategy.applyFilterToCamelHeaders(name, value)) {
                message.setProperty(name, value);
            }
        }
        String id = exchange.getExchangeId();
        if (id != null) {
            message.setProperty(""exchangeId"", id);
        }
    }
    /**
     * Extracts the body from the XMPP message
     */
    public Object extractBodyFromXmpp(XmppExchange exchange, Message message) {
        return message.getBody();
    }
    public Map<String, Object> extractHeadersFromXmpp(Message xmppMessage) {
        Map<String, Object> answer = new HashMap<String, Object>();
        for (String name : xmppMessage.getPropertyNames()) {
            Object value = xmppMessage.getProperty(name);
            if (headerFilterStrategy != null
                    && !headerFilterStrategy.applyFilterToExternalHeaders(name, value)) {
                answer.put(name, value);
            }
        }
        return answer;
    }
}
"
org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.converter;
import org.apache.camel.Converter;
import org.apache.camel.Endpoint;
import org.apache.camel.component.spring.integration.SpringIntegrationEndpoint;
import org.apache.camel.component.spring.integration.SpringIntegrationMessage;
import org.springframework.integration.core.MessageChannel;
import org.springframework.integration.core.MessageHeaders;
import org.springframework.integration.message.GenericMessage;
/**
 * The <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * for turning the Spring Integration types into Camel native type.
 *
 * @version $Revision$
 */
@Converter
public final class SpringIntegrationConverter {
    private SpringIntegrationConverter() {
        // Helper class
    }
    /**
     * @param Spring Integration MessageChannel
     * @return an Camel Endpoint
     * @throws Exception
     */
    @Converter
    public static Endpoint toEndpoint(final MessageChannel channel) throws Exception {
        if (channel == null) {
            throw new IllegalArgumentException(""The MessageChannel is null"");
        }
        Endpoint answer = new SpringIntegrationEndpoint(""URL"", channel, null);
        // check the channel
        return answer;
    }
    @SuppressWarnings(""unchecked"")
    @Converter
    public static org.springframework.integration.core.Message toSpringMessage(final org.apache.camel.Message camelMessage) throws Exception {
        if (camelMessage instanceof SpringIntegrationMessage) {
            SpringIntegrationMessage siMessage = (SpringIntegrationMessage)camelMessage;
            org.springframework.integration.core.Message message =  siMessage.getMessage();
            if (message != null) {
                return message;
            }
        }
        // Create a new spring message and copy the attributes and body from the camel message
        MessageHeaders messageHeaders = new MessageHeaders(camelMessage.getHeaders());
        return new GenericMessage(camelMessage.getBody(), messageHeaders);
    }
    @Converter
    public static org.apache.camel.Message toCamelMessage(final org.springframework.integration.core.Message springMessage) throws Exception {
        return new SpringIntegrationMessage(springMessage);
    }
}
"
org.apache.camel.component.jms.requestor.FutureHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import javax.jms.JMSException;
import javax.jms.Message;
/**
 * A {@link FutureTask} which implements {@link ReplyHandler}
 * so that it can be used as a handler for a correlation ID
 *
 * @version $Revision$
 */
public class FutureHandler extends FutureTask<Message> implements ReplyHandler {
    private static final Callable<Message> EMPTY_CALLABLE = new Callable<Message>() {
        public Message call() throws Exception {
            return null;
        }
    };
    public FutureHandler() {
        super(EMPTY_CALLABLE);
    }
    public synchronized void set(Message result) {
        super.set(result);
    }
    public boolean handle(Message message) throws JMSException {
        set(message);
        return true;
    }
}
"
org.apache.camel.osgi.OsgiAnnotationTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import org.apache.camel.impl.converter.AnnotationTypeConverterLoader;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.osgi.framework.BundleContext;
public class OsgiAnnotationTypeConverterLoader extends AnnotationTypeConverterLoader {
    private static final transient Log LOG = LogFactory.getLog(OsgiAnnotationTypeConverterLoader.class);
    public OsgiAnnotationTypeConverterLoader(BundleContext context) {
        super(new OsgiResolverUtil(context));
    }
    protected String[] findPackageNames() {
        return Activator.findTypeConverterPackageNames();
    }
}
"
org.apache.camel.Consume,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Subscribes a method to an {@link Endpoint} either via its
 * <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> or via the name of the endpoint reference
 * which is then resolved in a registry such as the Spring Application Context.
 *
 * When a message {@link Exchange} is received from the {@link Endpoint} then the
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 * mechanism is used to map the incoming {@link Message} to the method parameters.
 * 
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface Consume {
    String uri() default """";
    String ref() default """";
}
"
org.apache.camel.impl.ZipDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.InflaterInputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
public class ZipDataFormat implements DataFormat {
    private int compressionLevel;
    public ZipDataFormat() {
        this.compressionLevel = Deflater.BEST_SPEED;
    }
    public ZipDataFormat(int compressionLevel) {
        this.compressionLevel = compressionLevel;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream)
        throws Exception {
        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, graph);
        if (is == null) {
            throw new IllegalArgumentException(""Cannot get the inputstream for ZipDataFormat mashalling"");
        }
        DeflaterOutputStream zipOutput = new DeflaterOutputStream(stream, new Deflater(compressionLevel));
        try {
            IOConverter.copy(is, zipOutput);
        } finally {
            zipOutput.close();
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream)
        throws Exception {
        InputStream is = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        InflaterInputStream unzipInput = new InflaterInputStream(is);
        // Create an expandable byte array to hold the inflated data
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        IOConverter.copy(unzipInput, bos);
        return bos.toByteArray();
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClientFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import javax.xml.ws.soap.SOAPBinding;
import org.apache.cxf.BusException;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointException;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.jaxws.binding.soap.JaxWsSoapBindingConfiguration;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.factory.ServiceConstructionException;
public class CxfClientFactoryBean extends ClientFactoryBean {
    private boolean isJSR181Enabled;
    public CxfClientFactoryBean() {
        super();        
    }
    public void setJSR181Enabled(boolean enabled) {
        if (enabled) {
            setServiceFactory(new JaxWsServiceFactoryBean());            
        } else {
            setServiceFactory(new ReflectionServiceFactoryBean());
        }
        isJSR181Enabled = enabled;
    }
    @Override
    public void setBindingId(String bind) {
        super.setBindingId(bind);
        if (isJSR181Enabled) {
            if (SOAPBinding.SOAP11HTTP_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
            } else if (SOAPBinding.SOAP11HTTP_MTOM_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_MTOM_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
                ((JaxWsSoapBindingConfiguration)getBindingConfig()).setMtomEnabled(true);
            }
        }    
    }
    protected void createClient(Endpoint ep) {
        CxfClient client = new CxfClient(getBus(), ep);
        setClient(client);
    }
}
"
org.apache.camel.impl.converter.PropertyEditorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * Uses the {@link java.beans.PropertyEditor} conversion system to convert Objects to
 * and from String values.
 *
 * @version $Revision$
 */
public class PropertyEditorTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        // We can't convert null values since we can't figure out a property
        // editor for it.
        if (value == null) {
            return null;
        }
        if (value.getClass() == String.class) {
            // No conversion needed.
            if (toType == String.class) {
                return ObjectHelper.cast(toType, value);
            }
            PropertyEditor editor = PropertyEditorManager.findEditor(toType);
            if (editor != null) {
                editor.setAsText(value.toString());
                return ObjectHelper.cast(toType, editor.getValue());
            }
        } else if (toType == String.class) {
            PropertyEditor editor = PropertyEditorManager.findEditor(value.getClass());
            if (editor != null) {
                editor.setValue(value);
                return ObjectHelper.cast(toType, editor.getAsText());
            }
        }
        return null;
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        return convertTo(type, value);
    }
}
"
org.apache.camel.component.jms.RuntimeJmsException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class RuntimeJmsException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeJmsException(String message, JMSException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.restlet.RestletConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.restlet.Restlet;
import org.restlet.data.Request;
import org.restlet.data.Response;
/**
 * A Restlet consumer acts as a server to listen client requests.
 *
 * @version $Revision$
 */
public class RestletConsumer extends DefaultConsumer {
    private static final Log LOG = LogFactory.getLog(RestletConsumer.class);
    private Restlet restlet;
    public RestletConsumer(Endpoint endpoint, Processor processor) 
        throws Exception {
        super(endpoint, processor);
        restlet = new Restlet() {
            @Override
            public void handle(Request request, Response response) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Consumer restlet handle request method: "" + request.getMethod());
                }
                try {
                    Exchange exchange = getEndpoint().createExchange();
                    RestletBinding binding = ((RestletEndpoint)getEndpoint()).getRestletBinding();
                    binding.populateExchangeFromRestletRequest(request, exchange);
                    getProcessor().process(exchange);
                    binding.populateRestletResponseFromExchange(exchange, response);
                } catch (Exception e) {
                    throw new RuntimeCamelException(e);
                }
            }
        };
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ((RestletEndpoint)getEndpoint()).connect(this);
    }
    @Override
    public void doStop() throws Exception {
        ((RestletEndpoint)getEndpoint()).disconnect(this);
        super.doStop();
    }
    public Restlet getRestlet() {
        return restlet;
    }
}
"
org.apache.camel.component.jetty.CamelContinuationServlet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.AsyncCallback;
import org.apache.camel.component.http.CamelServlet;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpExchange;
import org.mortbay.util.ajax.Continuation;
import org.mortbay.util.ajax.ContinuationSupport;
/**
 * @version $Revision$
 */
public class CamelContinuationServlet extends CamelServlet {
    private static final long serialVersionUID = 1L;
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            // Is there a consumer registered for the request.
            HttpConsumer consumer = resolve(request);
            if (consumer == null) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            final Continuation continuation = ContinuationSupport.getContinuation(request, null);
            if (continuation.isNew()) {
                // Have the camel process the HTTP exchange.
                final HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);
                boolean sync = consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        if (sync) {
                            return;
                        }
                        continuation.setObject(exchange);
                        continuation.resume();
                    }
                });
                if (!sync) {
                    // Wait for the exchange to get processed.
                    // This might block until it completes or it might return via an exception and
                    // then this method is re-invoked once the the exchange has finished processing
                    continuation.suspend(0);
                }
                // HC: The getBinding() is interesting because it illustrates the
                // impedance miss-match between HTTP's stream oriented protocol, and
                // Camels more message oriented protocol exchanges.
                // now lets output to the response
                consumer.getBinding().writeResponse(exchange, response);
                return;
            }
            if (continuation.isResumed()) {
                HttpExchange exchange = (HttpExchange)continuation.getObject();
                // now lets output to the response
                consumer.getBinding().writeResponse(exchange, response);
                return;
            }
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
}
"
org.apache.camel.Property,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of a property of an {@link Exchange}
 *
 * @see Exchange#getProperty(String)  
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Property {
    String name();
}
"
org.apache.camel.language.ognl.OgnlLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Language} plugin
 *
 * @version $Revision$
 */
public class OgnlLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new OgnlExpression(this, expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new OgnlExpression(this, expression, Object.class);
    }
}
"
org.apache.camel.component.mina.MinaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import java.nio.charset.Charset;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoAcceptorConfig;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoConnectorConfig;
import org.apache.mina.common.IoSession;
/**
 * Endpoint for Camel MINA.
 *
 * @version $Revision$
 */
public class MinaEndpoint extends DefaultEndpoint<MinaExchange> {
    private static final long DEFAULT_TIMEOUT = 30000;
    private long timeout = DEFAULT_TIMEOUT;
    private final IoAcceptor acceptor;
    private final SocketAddress address;
    private final IoConnector connector;
    private final IoAcceptorConfig acceptorConfig;
    private final IoConnectorConfig connectorConfig;
    private final boolean lazySessionCreation;
    private final boolean transferExchange;
    private final boolean sync;
    private String charsetName;
    public MinaEndpoint(String endpointUri, MinaComponent component, SocketAddress address,
                        IoAcceptor acceptor, IoAcceptorConfig acceptorConfig, IoConnector connector,
                        IoConnectorConfig connectorConfig, boolean lazySessionCreation, long timeout,
                        boolean transferExchange, boolean sync) {
        super(endpointUri, component);
        this.address = address;
        this.acceptor = acceptor;
        this.acceptorConfig = acceptorConfig;
        this.connectorConfig = connectorConfig;
        this.connector = connector;
        this.lazySessionCreation = lazySessionCreation;
        if (timeout > 0) {
            // override default timeout if provided
            this.timeout = timeout;
        }
        this.transferExchange = transferExchange;
        this.sync = sync;
    }
    @SuppressWarnings({""unchecked""})
    public Producer<MinaExchange> createProducer() throws Exception {
        return new MinaProducer(this);
    }
    public Consumer<MinaExchange> createConsumer(Processor processor) throws Exception {
        return new MinaConsumer(this, processor);
    }
    @Override
    public MinaExchange createExchange(ExchangePattern pattern) {
        return new MinaExchange(getCamelContext(), pattern, null);
    }
    public MinaExchange createExchange(IoSession session, Object payload) {
        MinaExchange exchange = new MinaExchange(getCamelContext(), getExchangePattern(), session);
        MinaPayloadHelper.setIn(exchange, payload);
        return exchange;
    }
    // Properties
    // -------------------------------------------------------------------------
    public IoAcceptor getAcceptor() {
        return acceptor;
    }
    public SocketAddress getAddress() {
        return address;
    }
    public IoConnector getConnector() {
        return connector;
    }
    public boolean isLazySessionCreation() {
        return lazySessionCreation;
    }
    public IoAcceptorConfig getAcceptorConfig() {
        return acceptorConfig;
    }
    public IoConnectorConfig getConnectorConfig() {
        return connectorConfig;
    }
    public boolean isSingleton() {
        return true;
    }
    public long getTimeout() {
        return timeout;
    }
    public boolean isTransferExchange() {
        return transferExchange;
    }
    public boolean isSync() {
        return sync;
    }
    public void setCharsetName(String charset) {
        this.charsetName = charset;
    }
    public String getCharsetName() {
        return charsetName;
    }
}
"
org.apache.camel.language.bean.RuntimeBeanExpressionException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeExpressionException;
/**
 * Exception thrown if invocation of bean failed.
 *
 * @version $Revision$
 */
public class RuntimeBeanExpressionException extends RuntimeExpressionException {
    private final Exchange exchange;
    private final String bean;
    private final String method;
    public RuntimeBeanExpressionException(Exchange exchange, String bean, String method, Throwable e) {
        super(""Failed to invoke method: "" + method + "" on "" + bean + "" due to: "" + e, e);
        this.exchange = exchange;
        this.bean = bean;
        this.method = method;
    }
    public String getBean() {
        return bean;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public String getMethod() {
        return method;
    }
}
"
org.apache.camel.component.file.FileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.util.LRUCache;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For consuming files.
 *
 * @version $Revision$
 */
public class FileConsumer extends ScheduledPollConsumer<FileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FileConsumer.class);
    private FileEndpoint endpoint;
    private ConcurrentHashMap<File, File> filesBeingProcessed = new ConcurrentHashMap<File, File>();
    private ConcurrentHashMap<File, Long> fileSizes = new ConcurrentHashMap<File, Long>(new LRUCache(1000));
    private ConcurrentHashMap<File, Long> noopMap = new ConcurrentHashMap<File, Long>(new LRUCache(1000));
    // the options below is @deprecated and will be removed in Camel 2.0
    private long lastPollTime;
    private int unchangedDelay;
    private boolean unchangedSize;
    private boolean generateEmptyExchangeWhenIdle;
    private boolean alwaysConsume;
    private boolean recursive;
    private String regexPattern = """";
    private boolean exclusiveReadLock = true;
    public FileConsumer(final FileEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    protected synchronized void poll() throws Exception {
        // should be true the first time as its the top directory
        int rc = pollFileOrDirectory(endpoint.getFile(), true);
        // if no files consumes and using generateEmptyExchangeWhenIdle option then process an empty exchange 
        if (rc == 0 && generateEmptyExchangeWhenIdle) {
            final FileExchange exchange = endpoint.createExchange((File)null);
            getAsyncProcessor().process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                }
            });
        }
        lastPollTime = System.currentTimeMillis();
    }
    /**
     * Pools the given file or directory for files to process.
     *
     * @param fileOrDirectory  file or directory
     * @param processDir  recursive
     * @return the number of files processed or being processed async.
     */
    protected int pollFileOrDirectory(File fileOrDirectory, boolean processDir) {
        if (!fileOrDirectory.isDirectory()) {
            // process the file
            return pollFile(fileOrDirectory);
        } else if (processDir) {
            // directory that can be recursive
            int rc = 0;
            if (isValidFile(fileOrDirectory)) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Polling directory "" + fileOrDirectory);
                }
                File[] files = fileOrDirectory.listFiles();
                for (File file : files) {
                    rc += pollFileOrDirectory(file, isRecursive()); // self-recursion
                }
            }
            return rc;
        } else {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Skipping directory "" + fileOrDirectory);
            }
            return 0;
        }
    }
    /**
     * Polls the given file
     *
     * @param target  the file
     * @return returns 1 if the file was processed, 0 otherwise.
     */
    protected int pollFile(final File target) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Polling file: "" + target);
        }
        if (!target.exists()) {
            return 0;
        }
        if (!isValidFile(target)) {
            return 0;
        }
        // we only care about file modified times if we are not deleting/moving files
        if (!endpoint.isNoop()) {
            if (filesBeingProcessed.contains(target)) {
                return 1;
            }
            filesBeingProcessed.put(target, target);
        }
        final FileProcessStrategy processStrategy = endpoint.getFileStrategy();
        final FileExchange exchange = endpoint.createExchange(target);
        endpoint.configureMessage(target, exchange.getIn());
        try {
            // is we use excluse read then acquire the exclusive read (waiting until we got it)
            if (exclusiveReadLock) {
                acquireExclusiveReadLock(target);
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug(""About to process file: "" + target + "" using exchange: "" + exchange);
            }
            if (processStrategy.begin(endpoint, exchange, target)) {
                // Use the async processor interface so that processing of
                // the exchange can happen asynchronously
                getAsyncProcessor().process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        // must use file from exchange as it can be updated due the preMoveNamePrefix/preMoveNamePostfix options
                        final File file = exchange.getFile();
                        boolean failed = exchange.isFailed();
                        boolean handled = DeadLetterChannel.isFailureHandled(exchange);
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Done processing file: "" + file + "". Status is: "" + (failed ? ""failed: "" + failed + "", handled by failure processor: "" + handled : ""processed OK""));
                        }
                        boolean committed = false;
                        try {
                            if (!failed || handled) {
                                // commit the file strategy if there was no failure or already handled by the DeadLetterChannel
                                processStrategyCommit(processStrategy, exchange, file, handled);
                                committed = true;
                            } else {
                                // there was an exception but it was not handled by the DeadLetterChannel
                                handleException(exchange.getException());
                            }
                        } finally {
                            if (!committed) {
                                processStrategyRollback(processStrategy, exchange, file);
                            }
                            filesBeingProcessed.remove(file);
                        }
                    }
                });
            } else {
                LOG.warn(endpoint + "" can not process file: "" + target);
            }
        } catch (Throwable e) {
            handleException(e);
        }
        return 1;
    }
    /**
     * Acquires exclusive read lock to the given file. Will wait until the lock is granted.
     * After granting the read lock it is realeased, we just want to make sure that when we start
     * consuming the file its not currently in progress of being written by third party.
     */
    protected void acquireExclusiveReadLock(File file) throws IOException {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Waiting for exclusive read lock to file: "" + file);
        }
        // try to acquire rw lock on the file before we can consume it
        FileChannel channel = new RandomAccessFile(file, ""rw"").getChannel();
        try {
            FileLock lock = channel.lock();
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Acquired exclusive read lock: "" + lock + "" to file: "" + file);
            }
            // just release it now we dont want to hold it during the rest of the processing
            lock.release();
        } finally {
            // must close channel
            ObjectHelper.close(channel, ""FileConsumer during acquiring of exclusive read lock"", LOG);
        }
    }
    /**
     * Strategy when the file was processed and a commit should be executed.
     *
     * @param processStrategy   the strategy to perform the commit
     * @param exchange          the exchange
     * @param file              the file processed
     * @param failureHandled    is <tt>false</tt> if the exchange was processed succesfully, <tt>true</tt> if
     * an exception occured during processing but it was handled by the failure processor (usually the
     * DeadLetterChannel).
     */
    protected void processStrategyCommit(FileProcessStrategy processStrategy, FileExchange exchange,
                                         File file, boolean failureHandled) {
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Committing file strategy: "" + processStrategy + "" for file: "" + file + (failureHandled ? "" that was handled by the failure processor."" : """"));
            }
            processStrategy.commit(endpoint, exchange, file);
        } catch (Exception e) {
            LOG.warn(""Error committing file strategy: "" + processStrategy, e);
            handleException(e);
        }
    }
    /**
     * Strategy when the file was not processed and a rollback should be executed.
     *
     * @param processStrategy   the strategy to perform the commit
     * @param exchange          the exchange
     * @param file              the file processed
     */
    protected void processStrategyRollback(FileProcessStrategy processStrategy, FileExchange exchange, File file) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Rolling back file strategy: "" + processStrategy + "" for file: "" + file);
        }
        processStrategy.rollback(endpoint, exchange, file);
    }
    protected boolean isValidFile(File file) {
        boolean result = false;
        if (file != null && file.exists()) {
            // TODO: maybe use a configurable strategy instead of the hardcoded one based on last file change
            if (isMatched(file) && (alwaysConsume || isChanged(file))) {
                result = true;
            }
        }
        return result;
    }
    protected boolean isChanged(File file) {
        if (file == null) {
            // Sanity check
            return false;
        } else if (file.isDirectory()) {
            // Allow recursive polling to descend into this directory
            return true;
        } else {
            // @deprecated will be removed on Camel 2.0
            // the code below is kinda hard to maintain. We should strive to remove
            // this stuff in Camel 2.0 to keep this component simple and no surprises for end-users
            // this stuff is not persistent so restarting Camel will reset the state
            boolean lastModifiedCheck = false;
            long modifiedDuration = 0;
            if (getUnchangedDelay() > 0) {
                modifiedDuration = System.currentTimeMillis() - file.lastModified();
                lastModifiedCheck = modifiedDuration >= getUnchangedDelay();
            }
            long fileModified = file.lastModified();
            Long previousModified = noopMap.get(file);
            noopMap.put(file, fileModified);
            if (previousModified == null || fileModified > previousModified) {
                lastModifiedCheck = true;
            }
            boolean sizeCheck = false;
            long sizeDifference = 0;
            if (isUnchangedSize()) {
                Long value = fileSizes.get(file);
                if (value == null) {
                    sizeCheck = true;
                } else {
                    sizeCheck = file.length() != value;
                }
            }
            boolean answer = lastModifiedCheck || sizeCheck;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""file:"" + file + "" isChanged:"" + answer + "" "" + ""sizeCheck:"" + sizeCheck + ""(""
                          + sizeDifference + "") "" + ""lastModifiedCheck:"" + lastModifiedCheck + ""(""
                          + modifiedDuration + "")"");
            }
            if (isUnchangedSize()) {
                if (answer) {
                    fileSizes.put(file, file.length());
                } else {
                    fileSizes.remove(file);
                }
            }
            return answer;
        }
    }
    protected boolean isMatched(File file) {
        String name = file.getName();
        // folders/names starting with dot is always skipped (eg. ""."", "".camel"", "".camelLock"")
        if (name.startsWith(""."")) {
            return false;
        }
        // lock files should be skipped
        if (name.endsWith(FileEndpoint.DEFAULT_LOCK_FILE_POSTFIX)) {
            return false;
        }
        // directories so far is always regarded as matched (matching on the name is only for files)
        if (file.isDirectory()) {
            return true;
        }
        if (regexPattern != null && regexPattern.length() > 0) {
            if (!name.matches(regexPattern)) {
                return false;
            }
        }
        if (endpoint.getExcludedNamePrefix() != null) {
            if (name.startsWith(endpoint.getExcludedNamePrefix())) {
                return false;
            }
        }
        String[] prefixes = endpoint.getExcludedNamePrefixes();
        if (prefixes != null) {
            for (String prefix : prefixes) {
                if (name.startsWith(prefix)) {
                    return false;
                }
            }
        }
        if (endpoint.getExcludedNamePostfix() != null) {
            if (name.endsWith(endpoint.getExcludedNamePostfix())) {
                return false;
            }
        }
        String[] postfixes = endpoint.getExcludedNamePostfixes();
        if (postfixes != null) {
            for (String postfix : postfixes) {
                if (name.endsWith(postfix)) {
                    return false;
                }
            }
        }
        return true;
    }
    public boolean isRecursive() {
        return this.recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public String getRegexPattern() {
        return this.regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isGenerateEmptyExchangeWhenIdle() {
        return generateEmptyExchangeWhenIdle;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void setGenerateEmptyExchangeWhenIdle(boolean generateEmptyExchangeWhenIdle) {
        this.generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle;
    }
    public int getUnchangedDelay() {
        return unchangedDelay;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void setUnchangedDelay(int unchangedDelay) {
        this.unchangedDelay = unchangedDelay;
    }
    public boolean isUnchangedSize() {
        return unchangedSize;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void setUnchangedSize(boolean unchangedSize) {
        this.unchangedSize = unchangedSize;
    }
    public boolean isExclusiveReadLock() {
        return exclusiveReadLock;
    }
    public void setExclusiveReadLock(boolean exclusiveReadLock) {
        this.exclusiveReadLock = exclusiveReadLock;
    }
    public boolean isAlwaysConsume() {
        return alwaysConsume;
    }
    /**
     * @deprecated will be removed in Camel 2.0 (not needed when we get rid of last polltimestamp)
     */
    public void setAlwaysConsume(boolean alwaysConsume) {
        this.alwaysConsume = alwaysConsume;
    }
    public boolean isTimestamp() {
        return !alwaysConsume;
    }
    /**
     * @deprecated will be removed in Camel 2.0 (not needed when we get rid of last polltimestamp)
     */
    public void setTimestamp(boolean timestamp) {
        this.alwaysConsume = !timestamp;
    }
}
"
org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.interceptors.DOMInInterceptor;
import org.apache.camel.component.cxf.interceptors.DOMOutInterceptor;
import org.apache.camel.component.cxf.interceptors.FaultOutInterceptor;
import org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor;
import org.apache.cxf.Bus;
import org.apache.cxf.binding.Binding;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.phase.Phase;
/**
 * This feature just setting up the CXF endpoint interceptor for handling the
 * Message in PAYLOAD data format
 */
public class PayLoadDataFormatFeature extends AbstractDataFormatFeature {
    private static final Logger LOG = LogUtils.getL7dLogger(PayLoadDataFormatFeature.class);
    // filter the unused phase
    private static final String[] REMOVING_IN_PHASES = {Phase.UNMARSHAL, Phase.PRE_LOGICAL, Phase.PRE_LOGICAL_ENDING, Phase.POST_LOGICAL, Phase.POST_LOGICAL_ENDING };
    private static final String[] REMOVING_OUT_PHASES = {Phase.MARSHAL, Phase.MARSHAL_ENDING, Phase.PRE_LOGICAL, Phase.PRE_LOGICAL_ENDING, Phase.POST_LOGICAL, Phase.POST_LOGICAL_ENDING };
    @Override
    public void initialize(Client client, Bus bus) {
        removeInterceptorWhichIsInThePhases(client.getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getService().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getBinding().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getService().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getBinding().getOutInterceptors(), REMOVING_OUT_PHASES);
        addDataHandlingInterceptors(client.getEndpoint().getBinding());
        client.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    @Override
    public void initialize(Server server, Bus bus) {
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getService().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getBinding().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getService().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getBinding().getOutInterceptors(), REMOVING_OUT_PHASES);
        // set the invoker interceptor
        resetServiceInvokerInterceptor(server);
        addDataHandlingInterceptors(server.getEndpoint().getBinding());
        server.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    private void addDataHandlingInterceptors(Binding binding) {
        binding.getInInterceptors().add(new DOMInInterceptor());
        binding.getOutInterceptors().add(new DOMOutInterceptor());
        binding.getOutInterceptors().add(new PayloadContentRedirectInterceptor());
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.OutHeaders,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the headers of an outbound {@link Message}
 *
 * @see Message#getHeaders()
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface OutHeaders {
}"
org.apache.camel.component.http.HttpMethods,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.DeleteMethod;
import org.apache.commons.httpclient.methods.EntityEnclosingMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.HeadMethod;
import org.apache.commons.httpclient.methods.OptionsMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.PutMethod;
import org.apache.commons.httpclient.methods.TraceMethod;
public enum HttpMethods implements Expression<Exchange> {
    GET(GetMethod.class), POST(PostMethod.class), PUT(PutMethod.class), DELETE(DeleteMethod.class), HEAD(
        HeadMethod.class), OPTIONS(OptionsMethod.class), TRACE(TraceMethod.class);
    public static final String HTTP_METHOD = ""http.requestMethod"";
    final Class<? extends HttpMethod> clazz;
    final boolean entity;
    HttpMethods(Class<? extends HttpMethod> clazz) {
        this.clazz = clazz;
        entity = EntityEnclosingMethod.class.isAssignableFrom(clazz);
    }
    public HttpMethod createMethod(final String url) {
        try {
            return clazz.getDeclaredConstructor(String.class).newInstance(url);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public HttpMethod createMethod() {
        try {
            return clazz.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public final boolean isEntityEnclosing() {
        return entity;
    }
    public Object evaluate(Exchange exchange) {
        return ExpressionBuilder.constantExpression(name()).evaluate(exchange);
    }
}
"
org.apache.camel.NoTypeConversionAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception thrown if a value could not be converted to the required type
 *
 * @version $Revision$
 */
public class NoTypeConversionAvailableException extends RuntimeCamelException {
    private final Object value;
    private final Class type;
    public NoTypeConversionAvailableException(Object value, Class type) {
        super(""No type converter available to convert from type: "" + (value != null ? value.getClass() : null)
              + "" to the required type: "" + type.getCanonicalName() + "" with value "" + value);
        this.value = value;
        this.type = type;
    }
    /**
     * Returns the value which could not be converted
     */
    public Object getValue() {
        return value;
    }
    /**
     * Returns the required <tt>to</tt> type
     */
    public Class getType() {
        return type;
    }
    /**
     * Returns the required <tt>from</tt> type.
     * Returns <tt>null</tt> if the provided value was null.
     */
    public Class getFromType() {
        if (value != null) {
            return value.getClass();
        } else {
            return null;
        }
    }
}
"
org.apache.camel.component.jms.requestor.Requestor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.DefaultTimeoutMap;
import org.apache.camel.util.TimeoutMap;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.support.destination.DestinationResolver;
/**
 * @version $Revision$
 */
public class Requestor extends ServiceSupport implements MessageListener {
    private static final transient Log LOG = LogFactory.getLog(Requestor.class);
    private static UuidGenerator uuidGenerator;
    private final JmsConfiguration configuration;
    private ScheduledExecutorService executorService;
    private AbstractMessageListenerContainer listenerContainer;
    private TimeoutMap requestMap;
    private Map<JmsProducer, DeferredRequestReplyMap> producerDeferredRequestReplyMap;
    private TimeoutMap deferredRequestMap;
    private TimeoutMap deferredReplyMap;
    private Destination replyTo;
    private long maxRequestTimeout = -1;
    private long replyToResolverTimeout = 5000;
    public Requestor(JmsConfiguration configuration, ScheduledExecutorService executorService) {
        this.configuration = configuration;
        this.executorService = executorService;
        requestMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
        producerDeferredRequestReplyMap = new HashMap<JmsProducer, DeferredRequestReplyMap>();
        deferredRequestMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
        deferredReplyMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
    }
    public synchronized DeferredRequestReplyMap getDeferredRequestReplyMap(JmsProducer producer) {
        DeferredRequestReplyMap map = producerDeferredRequestReplyMap.get(producer);
        if (map == null) {
            map = new DeferredRequestReplyMap(this, producer, deferredRequestMap, deferredReplyMap);
            producerDeferredRequestReplyMap.put(producer, map);
            if (maxRequestTimeout == -1) {
                maxRequestTimeout = producer.getRequestTimeout();
            } else if (maxRequestTimeout < producer.getRequestTimeout()) {
                maxRequestTimeout = producer.getRequestTimeout();
            }
        }
        return map;
    }
    public synchronized void removeDeferredRequestReplyMap(JmsProducer producer) {
        DeferredRequestReplyMap map = producerDeferredRequestReplyMap.remove(producer);
        if (map == null) {
            // already removed;
            return;
        }
        if (maxRequestTimeout == producer.getRequestTimeout()) {
            long max = -1;
            for (Map.Entry<JmsProducer, DeferredRequestReplyMap> entry : producerDeferredRequestReplyMap.entrySet()) {
                if (max < entry.getKey().getRequestTimeout()) {
                    max = entry.getKey().getRequestTimeout();
                }
            }
            maxRequestTimeout = max;
        }
    }
    public synchronized long getMaxRequestTimeout() {
        return maxRequestTimeout;
    }
    public TimeoutMap getRequestMap() {
        return requestMap;
    }
    public TimeoutMap getDeferredRequestMap() {
        return deferredRequestMap;
    }
    public TimeoutMap getDeferredReplyMap() {
        return deferredReplyMap;
    }
    public FutureTask getReceiveFuture(String correlationID, long requestTimeout) {
        FutureHandler future = createFutureHandler(correlationID);
        requestMap.put(correlationID, future, requestTimeout);
        return future;
    }
    public FutureTask getReceiveFuture(DeferredMessageSentCallback callback) {
        FutureHandler future = createFutureHandler(callback);
        DeferredRequestReplyMap map = callback.getDeferredRequestReplyMap();
        map.put(callback, future);
        return future;
    }
    protected FutureHandler createFutureHandler(String correlationID) {
        return new FutureHandler();
    }
    protected FutureHandler createFutureHandler(DeferredMessageSentCallback callback) {
        return new FutureHandler();
    }
    public void onMessage(Message message) {
        try {
            String correlationID = message.getJMSCorrelationID();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Message correlationID: "" + correlationID);
            }
            if (correlationID == null) {
                LOG.warn(""Ignoring message with no correlationID! "" + message);
                return;
            }
            // lets notify the monitor for this response
            Object handler = requestMap.get(correlationID);
            if (handler != null && handler instanceof ReplyHandler) {
                ReplyHandler replyHandler = (ReplyHandler) handler;
                boolean complete = replyHandler.handle(message);
                if (complete) {
                    requestMap.remove(correlationID);
                }
            } else {
                DeferredRequestReplyMap.processDeferredRequests(
                        this, deferredRequestMap, deferredReplyMap,
                        correlationID, getMaxRequestTimeout(), message);
            }
        } catch (JMSException e) {
            throw new FailedToProcessResponse(message, e);
        }
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        if (listenerContainer == null) {
            listenerContainer = createListenerContainer();
        }
        return listenerContainer;
    }
    public void setListenerContainer(AbstractMessageListenerContainer listenerContainer) {
        this.listenerContainer = listenerContainer;
    }
    public Destination getReplyTo() {
        synchronized (this) {
            try {
                if (replyTo == null) {
                    wait(replyToResolverTimeout);
                }
            } catch (Throwable e) {
                // eat it
            }
        }
        return replyTo;
    }
    public void setReplyTo(Destination replyTo) {
        this.replyTo = replyTo;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        AbstractMessageListenerContainer container = getListenerContainer();
        container.afterPropertiesSet();
    }
    @Override
    protected void doStop() throws Exception {
        if (listenerContainer != null) {
            listenerContainer.stop();
            listenerContainer.destroy();
        }
    }
    protected Requestor getOutterInstance() {
        return this;
    }
    protected AbstractMessageListenerContainer createListenerContainer() {
        SimpleMessageListenerContainer answer = configuration.isUseVersion102()
            ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
        answer.setDestinationName(""temporary"");
        answer.setDestinationResolver(new DestinationResolver() {
            public Destination resolveDestinationName(Session session, String destinationName,
                                                      boolean pubSubDomain) throws JMSException {
                TemporaryQueue queue = null;
                synchronized (getOutterInstance()) {
                    try {
                        queue = session.createTemporaryQueue();
                        setReplyTo(queue);
                    } finally {
                        getOutterInstance().notifyAll();
                    }
                }
                return queue;
            }
        });
        answer.setAutoStartup(true);
        answer.setMessageListener(this);
        answer.setPubSubDomain(false);
        answer.setSubscriptionDurable(false);
        answer.setConcurrentConsumers(1);
        answer.setConnectionFactory(configuration.getConnectionFactory());
        String clientId = configuration.getClientId();
        if (clientId != null) {
            clientId += "".Requestor"";
            answer.setClientId(clientId);
        }
        TaskExecutor taskExecutor = configuration.getTaskExecutor();
        if (taskExecutor != null) {
            answer.setTaskExecutor(taskExecutor);
        }
        ExceptionListener exceptionListener = configuration.getExceptionListener();
        if (exceptionListener != null) {
            answer.setExceptionListener(exceptionListener);
        }
        return answer;
    }
    public static synchronized UuidGenerator getUuidGenerator() {
        if (uuidGenerator == null) {
            uuidGenerator = new UuidGenerator();
        }
        return uuidGenerator;
    }
    protected JmsConfiguration getConfiguration() {
        return configuration;
    }
    public void setReplyToSelectorHeader(org.apache.camel.Message in, Message jmsIn) throws JMSException {
        // complete
    }
}
"
org.apache.camel.component.ref.RefComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ref;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Component for lookup of existing endpoints bound in the {@link org.apache.camel.spi.Registry}.
 * <p/>
 * This component uses the <tt>ref:</tt> notation instead of the mostly common <tt>uri:</tt> notation. 
 */
public class RefComponent extends DefaultComponent<Exchange> {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        // lets remove the scheme from the URI
        int index = uri.indexOf("":"");
        String name = uri;
        if (index >= 0) {
            name = uri.substring(index + 1);
        }
        return lookupEndpoint(name, parameters);
    }
    /**
     * Looks up an endpoint for a given name.
     *
     * Derived classes could use this name as a logical name and look it up on some registry.
     *
     * The default implementation will look up the name in the registry of the {@link #getCamelContext()} property
     */
    protected Endpoint lookupEndpoint(String name, Map parameters) {
        return getCamelContext().getRegistry().lookup(name, Endpoint.class);
    }
}
"
org.apache.camel.converter.CamelConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
/**
 * Some useful converters for Camel APIs such as to convert a {@link Predicate} or {@link Expression}
 * to a {@link Processor}
 *
 * @version $Revision:$
 */
@Converter
public class CamelConverter {
    @Converter
    public Processor toProcessor(final Predicate<Exchange> predicate) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                boolean answer = predicate.matches(exchange);
                Message out = exchange.getOut();
                out.copyFrom(exchange.getIn());
                out.setBody(answer);
            }
        };
    }
    @Converter
    public Processor toProcessor(final Expression<Exchange> expresion) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object answer = expresion.evaluate(exchange);
                Message out = exchange.getOut();
                out.copyFrom(exchange.getIn());
                out.setBody(answer);
            }
        };
    }
}
"
org.apache.camel.spring.spi.SpringTransactionPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Wraps the processor in a Spring transaction
 *
 * @version $Revision$
 */
public class SpringTransactionPolicy<E> implements Policy<E> {
    private static final transient Log LOG = LogFactory.getLog(SpringTransactionPolicy.class);
    private TransactionTemplate template;
    private String propagationBehaviorName;
    private PlatformTransactionManager transactionManager;
    /**
     * Default constructor for easy spring configuration.
     */
    public SpringTransactionPolicy() {
    }
    public SpringTransactionPolicy(TransactionTemplate template) {
        this.template = template;
    }
    public Processor wrap(Processor processor) {
        final TransactionTemplate transactionTemplate = getTemplate();
        if (transactionTemplate == null) {
            LOG.warn(""No TransactionTemplate available so transactions will not be enabled!"");
            return processor;
        }
        TransactionInterceptor answer = new TransactionInterceptor(transactionTemplate);
        answer.setProcessor(processor);
        return answer;
    }
    public TransactionTemplate getTemplate() {
        if (template == null) {
            template = new TransactionTemplate(transactionManager);
            if (propagationBehaviorName != null) {
                template.setPropagationBehaviorName(propagationBehaviorName);
            }
        }
        return template;
    }
    public void setTemplate(TransactionTemplate template) {
        this.template = template;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setPropagationBehaviorName(String propagationBehaviorName) {
        this.propagationBehaviorName = propagationBehaviorName;
    }
    public String getPropagationBehaviorName() {
        return propagationBehaviorName;
    }
}
"
org.apache.camel.spring.SpringCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.Endpoint;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.event.EventComponent;
import org.apache.camel.component.event.EventEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Registry;
import org.apache.camel.spring.spi.ApplicationContextRegistry;
import org.apache.camel.spring.spi.SpringInjector;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A Spring aware implementation of {@link org.apache.camel.CamelContext} which
 * will automatically register itself with Springs lifecycle methods plus allows
 * spring to be used to customize a any <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * as well as supporting accessing components and beans via the Spring
 * {@link ApplicationContext}
 *
 * @version $Revision$
 */
public class SpringCamelContext extends DefaultCamelContext implements InitializingBean, DisposableBean,
    ApplicationContextAware, ApplicationListener {
    private static final transient Log LOG = LogFactory.getLog(SpringCamelContext.class);
    private ApplicationContext applicationContext;
    private EventEndpoint eventEndpoint;
    private boolean shouldStartContext =
        ObjectHelper.getSystemProperty(""shouldStartContext"", Boolean.TRUE); // start context by default
    public SpringCamelContext() {
    }
    public SpringCamelContext(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public static SpringCamelContext springCamelContext(ApplicationContext applicationContext)
        throws Exception {
        // lets try and look up a configured camel context in the context
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        if (names.length == 1) {
            return (SpringCamelContext)applicationContext.getBean(names[0], SpringCamelContext.class);
        }
        SpringCamelContext answer = new SpringCamelContext();
        answer.setApplicationContext(applicationContext);
        answer.afterPropertiesSet();
        return answer;
    }
    public static SpringCamelContext springCamelContext(String configLocations) throws Exception {
        return springCamelContext(new ClassPathXmlApplicationContext(configLocations));
    }
    public void afterPropertiesSet() throws Exception {
        maybeStart();
    }
    private void maybeStart() throws Exception {
        if (getShouldStartContext()) {
            LOG.debug(""Starting the CamelContext now that the ApplicationContext has started"");
            start();
        } else {
            LOG.debug(""Not starting the CamelContext since shouldStartContext property was false."");
        }
    }
    public void destroy() throws Exception {
        stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing spring-event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initialized
            try {
                maybeStart();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw wrapRuntimeCamelException(e);
            }
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            }
        } else {
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            } else {
                LOG.warn(""No spring-event endpoint enabled for: "" + event);
            }
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        if (applicationContext instanceof ConfigurableApplicationContext) {
            addComponent(""spring-event"", new EventComponent(applicationContext));
        }
    }
    public EventEndpoint getEventEndpoint() {
        return eventEndpoint;
    }
    public void setEventEndpoint(EventEndpoint eventEndpoint) {
        this.eventEndpoint = eventEndpoint;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        maybeDoStart();
    }
    protected void maybeDoStart() throws Exception {
        if (getShouldStartContext()) {
            super.doStart();
            if (eventEndpoint == null) {
                eventEndpoint = createEventEndpoint();
            }
        }
    }
    @Override
    protected Injector createInjector() {
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return new SpringInjector((ConfigurableApplicationContext)applicationContext);
        } else {
            LOG.warn(""Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: ""
                      + applicationContext);
            return super.createInjector();
        }
    }
    protected EventEndpoint createEventEndpoint() {
        EventEndpoint endpoint = getEndpoint(""spring-event:default"", EventEndpoint.class);
        return endpoint;
    }
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        // We will use the type convert to build the endpoint first
        try {
            Endpoint endpoint = getTypeConverter().convertTo(Endpoint.class, bean);
            if (endpoint != null) {
                endpoint.setCamelContext(this);
                return endpoint;
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore, handled below
        }
        return new ProcessorEndpoint(uri, this, new BeanProcessor(bean, this));
    }
    @Override
    protected Registry createRegistry() {
        return new ApplicationContextRegistry(getApplicationContext());
    }
    public void setShouldStartContext(boolean shouldStartContext) {
        this.shouldStartContext = shouldStartContext;
    }
    public boolean getShouldStartContext() {
        return shouldStartContext;
    }    
}
"
org.apache.camel.component.cxf.util.CxfHeaderHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.component.cxf.transport.CamelTransportConstants;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.message.Message;
/**
 * Utility class to propagate headers to and from CXF message.
 *
 * @version $Revision$
 */
public final class CxfHeaderHelper {
    /**
     * Utility class does not have public constructor
     */
    private CxfHeaderHelper() {
    }
    /**
     * Progagates Camel headers to CXF message.
     *
     * @param strategy header filter strategy
     * @param headers Camel header
     * @param message CXF meassage
     */
    public static void propagateCamelToCxf(HeaderFilterStrategy strategy,
            Map<String, Object> headers, Message message) {
        Map<String, List<String>> cxfHeaders =
            CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
        if (cxfHeaders == null) {
            cxfHeaders = new HashMap<String, List<String>>();
            message.put(Message.PROTOCOL_HEADERS, cxfHeaders);
        }
        for (Map.Entry<String, Object> entry : headers.entrySet()) {
            if (strategy != null
                    && !strategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {
                if (CamelTransportConstants.CONTENT_TYPE.equals(entry.getKey())) {
                    message.put(Message.CONTENT_TYPE, entry.getValue());
                } else if (Client.REQUEST_CONTEXT.equals(entry.getKey())
                            || Client.RESPONSE_CONTEXT.equals(entry.getKey())
                            || Message.RESPONSE_CODE.equals(entry.getKey())) {
                    message.put(entry.getKey(), entry.getValue());
                } else {
                    List<String> listValue = new ArrayList<String>();
                    listValue.add(entry.getValue().toString());
                    cxfHeaders.put(entry.getKey(), listValue);
                }
            }
        }
    }
    public static void propagateCxfToCamel(HeaderFilterStrategy strategy,
            Message message, Map<String, Object> headers) {
        if (strategy == null) {
            return;
        }
        Map<String, List<String>> cxfHeaders =
            CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
        if (cxfHeaders != null) {
            for (Map.Entry<String, List<String>> entry : cxfHeaders.entrySet()) {
                if (!strategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue())) {
                    headers.put(entry.getKey(), entry.getValue().get(0));
                }
            }
        }
        // propagate content type
        String key = Message.CONTENT_TYPE;
        Object value = message.get(key);
        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
            headers.put(CamelTransportConstants.CONTENT_TYPE, value);
        }
        // propagate request context
        key = Client.REQUEST_CONTEXT;
        value = message.get(key);        
        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
            headers.put(key, value);
        }
        // propagate response context
        key = Client.RESPONSE_CONTEXT;
        value = message.get(key);        
        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
            headers.put(key, value);
        }      
    }
}
"
org.apache.camel.InvalidHeaderTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @deprecated use {@link InvalidTypeException}. Will be removed in Camel 2.0.
 * @version $Revision$
 */
@Deprecated
public class InvalidHeaderTypeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    private final Object headerValue;
    public InvalidHeaderTypeException(Throwable cause, Object headerValue) {
        super(cause.getMessage() + "" headerValue is: "" + headerValue + "" of type: "" + typeName(headerValue),
              cause);
        this.headerValue = headerValue;
    }
    public InvalidHeaderTypeException(String message, Object headerValue) {
        super(message);
        this.headerValue = headerValue;
    }
    /**
     * Returns the actual header value
     */
    public Object getHeaderValue() {
        return headerValue;
    }
    protected static String typeName(Object headerValue) {
        return (headerValue != null) ? headerValue.getClass().getName() : ""null"";
    }
}
"
org.apache.camel.Exchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
import org.apache.camel.spi.UnitOfWork;
/**
 * The base message exchange interface providing access to the request, response
 * and fault {@link Message} instances. Different providers such as JMS, JBI,
 * CXF and HTTP can provide their own derived API to expose the underlying
 * transport semantics to avoid the leaky abstractions of generic APIs.
 *
 * @version $Revision$
 */
public interface Exchange {
    String CHARSET_NAME = ""org.apache.camel.Exchange.CharsetName"";
    String AGGREGATED_COUNT = ""org.apache.camel.Exchange.AggregatedCount"";
    String EXCEPTION_HANDLED_PROPERTY = ""CamelExceptionHandled"";
    /**
     * Returns the {@link ExchangePattern} (MEP) of this exchange.
     *
     * @return the message exchange pattern of this exchange
     */
    ExchangePattern getPattern();
    /**
     * Allows the {@link ExchangePattern} (MEP) of this exchange to be customized.
     *
     * This typically won't be required as an exchange can be created with a specific MEP
     * by calling {@link Endpoint#createExchange(ExchangePattern)} but it is here just in case
     * it is needed.
     *
     * @param pattern  the pattern 
     */
    void setPattern(ExchangePattern pattern);
    /**
     * Returns a property associated with this exchange by name
     *
     * @param name the name of the property
     * @return the value of the given header or null if there is no property for
     *         the given name
     */
    Object getProperty(String name);
    /**
     * Returns a property associated with this exchange by name and specifying
     * the type required
     *
     * @param name the name of the property
     * @param type the type of the property
     * @return the value of the given header or null if there is no property for
     *         the given name or null if it cannot be converted to the given
     *         type
     */
    <T> T getProperty(String name, Class<T> type);
    /**
     * Sets a property on the exchange
     *
     * @param name  of the property
     * @param value to associate with the name
     */
    void setProperty(String name, Object value);
    /**
     * Removes the given property on the exchange
     *
     * @param name of the property
     * @return the old value of the property
     */
    Object removeProperty(String name);
    /**
     * Returns all of the properties associated with the exchange
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getProperties();
    /**
     * Returns the inbound request message
     *
     * @return the message
     */
    Message getIn();
    /**
     * Sets the inbound message instance
     *
     * @param in the inbound message
     */
    void setIn(Message in);
    /**
     * Returns the outbound message, lazily creating one if one has not already
     * been associated with this exchange. If you want to inspect this property
     * but not force lazy creation then invoke the {@link #getOut(boolean)}
     * method passing in <tt>false</tt>
     *
     * @return the response
     */
    Message getOut();
    /**
     * Returns the outbound message; optionally lazily creating one if one has
     * not been associated with this exchange
     *
     * @param lazyCreate <tt>true</tt> will lazy create the out message
     * @return the response
     */
    Message getOut(boolean lazyCreate);
    /**
     * Sets the outbound message
     *
     * @param out the outbound message
     */
    void setOut(Message out);
    /**
     * Returns the fault message
     *
     * @return the fault
     */
    Message getFault();
    /**
     * Returns the fault message; optionally lazily creating one if one has
     * not been associated with this exchange
     *
     * @param lazyCreate <tt>true</tt> will lazy create the fault message
     * @return the fault
     */
    Message getFault(boolean lazyCreate);
    /**
     * Returns the exception associated with this exchange
     *
     * @return the exception (or null if no faults)
     */
    Throwable getException();
    /**
     * Sets the exception associated with this exchange
     *
     * @param e  the caused exception
     */
    void setException(Throwable e);
    /**
     * Returns true if this exchange failed due to either an exception or fault
     *
     * @return true if this exchange failed due to either an exception or fault
     * @see Exchange#getException()
     * @see Exchange#getFault()
     */
    boolean isFailed();
    /**
     * Returns true if this exchange is transacted
     */
    boolean isTransacted();
    /**
     * Returns the container so that a processor can resolve endpoints from URIs
     *
     * @return the container which owns this exchange
     */
    CamelContext getContext();
    /**
     * Creates a new exchange instance with empty messages, headers and properties
     */
    Exchange newInstance();
    /**
     * Creates a copy of the current message exchange so that it can be
     * forwarded to another destination
     */
    Exchange copy();
    /**
     * Copies the data into this exchange from the given exchange
     *
     * @param source is the source from which headers and messages will be copied
     */
    void copyFrom(Exchange source);
    /**
     * Returns the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    UnitOfWork getUnitOfWork();
    /**
     * Sets the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    void setUnitOfWork(UnitOfWork unitOfWork);
    /**
     * Returns the exchange id (unique)
     */
    String getExchangeId();
    /**
     * Set the exchange id
     */
    void setExchangeId(String id);
}
"
org.apache.camel.component.cxf.interceptors.FakeBindingOperationInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.Collection;
import java.util.Collections;
import org.apache.cxf.service.model.BindingFaultInfo;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.service.model.ServiceInfo;
/**
 * This class is used to provide the BindingOperationInfo for
 * the FaultOutInterceptor which serves for the RawMessage DataFormat
 *
 */
public class FakeBindingOperationInfo extends BindingOperationInfo {
    public FakeBindingOperationInfo() {
        super();
    }
    public boolean isUnwrapped() {
        return false;
    }
}
"
org.apache.camel.component.bean.BeanHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Processor;
/**
 * Object holder for a bean.
 *
 * @version $Revision$
 */
public interface BeanHolder {
    Object getBean() throws Exception;
    Processor getProcessor();
    BeanInfo getBeanInfo();
}
"
org.apache.camel.component.spring.integration.SpringIntegrationConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ServiceHelper;
import org.springframework.integration.channel.AbstractPollableChannel;
import org.springframework.integration.channel.BeanFactoryChannelResolver;
import org.springframework.integration.channel.ChannelResolver;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.core.Message;
import org.springframework.integration.core.MessageChannel;
import org.springframework.integration.message.MessageHandler;
/**
 * A consumer of exchanges for the Spring Integration
 * Please specify the inputChannel in the endpoint url for this consumer.
 * If the message pattern is inOut, the outputChannel property
 * should be set for the outgoing message.
 *
 * @version $Revision$
 */
public class SpringIntegrationConsumer  extends DefaultConsumer<SpringIntegrationExchange> implements MessageHandler {
    private SpringCamelContext context;
    private DirectChannel inputChannel;
    private MessageChannel outputChannel;
    private String inputChannelName;
    private ChannelResolver channelResolver;
    private SpringIntegrationEndpoint endpoint;
    public SpringIntegrationConsumer(SpringIntegrationEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        context = (SpringCamelContext) endpoint.getCamelContext();
        if (context != null && endpoint.getMessageChannel() == null) {
            channelResolver = new BeanFactoryChannelResolver(context.getApplicationContext());
            inputChannelName = endpoint.getDefaultChannel();
            if (ObjectHelper.isNullOrBlank(inputChannelName)) {
                inputChannelName = endpoint.getInputChannel();
            }
            if (!ObjectHelper.isNullOrBlank(inputChannelName)) {
                inputChannel = (DirectChannel) channelResolver.resolveChannelName(inputChannelName);
                ObjectHelper.notNull(inputChannel, ""The inputChannel with the name ["" + inputChannelName + ""]"");
            } else {
                throw new RuntimeCamelException(""Can't find the right inputChannelName, please check your configuration."");
            }
        } else {
            if (endpoint.getMessageChannel() != null) {
                inputChannel = (DirectChannel)endpoint.getMessageChannel();
            } else {
                throw new RuntimeCamelException(""Can't find the right message channel, please check your configuration."");
            }
        }
        if (endpoint.isInOut()) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        }
    }
    protected void doStop() throws Exception {
        inputChannel.unsubscribe(this);
        super.doStop();
    }
    protected void doStart() throws Exception {
        super.doStart();
        inputChannel.subscribe(this);
    }
    public void handleMessage(org.springframework.integration.core.Message<?> siInMessage) {        
        SpringIntegrationExchange  exchange = getEndpoint().createExchange();
        exchange.setIn(new SpringIntegrationMessage(siInMessage));
        try {
            getProcessor().process(exchange);
        } catch (Exception e) {
            //TODO need to find a way to deal with this exception
            throw ObjectHelper.wrapRuntimeCamelException(e);
        }
        if (endpoint.isInOut()) {
            // get the output channel from message header
            Object returnAddress = siInMessage.getHeaders().getReplyChannel();
            MessageChannel reply = null;
            if (returnAddress != null) {
                if (returnAddress instanceof String) {
                    reply = (MessageChannel)context.getApplicationContext().getBean((String)returnAddress);
                } else if (returnAddress instanceof MessageChannel) {
                    reply = (MessageChannel) returnAddress;
                }
            } else {
                if (outputChannel != null) {
                    // using the outputChannel
                    reply = outputChannel;
                } else {
                    if (ObjectHelper.isNullOrBlank(endpoint.getOutputChannel())) {
                        outputChannel = (MessageChannel) channelResolver.resolveChannelName(endpoint.getOutputChannel());
                        ObjectHelper.notNull(inputChannel, ""The outputChannel with the name ["" + endpoint.getOutputChannel() + ""]"");
                        reply = outputChannel;
                    } else {
                        throw new RuntimeCamelException(""Can't find the right outputChannelName"");
                    }
                }
            }
            // put the message back the outputChannel if we need
            org.springframework.integration.core.Message siOutMessage =
                SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut());
            reply.send(siOutMessage);
        }        
    }   
}
"
org.apache.camel.NoSuchHeaderException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.util.ExchangeHelper;
/**
 * An exception caused when a mandatory header is not available on a message
 * {@link Exchange}
 *
 * @see ExchangeHelper#getMandatoryHeader(Exchange, String, Class)
 *
 * @version $Revision$
 */
public class NoSuchHeaderException extends CamelExchangeException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String headerName;
    private final Class<?> type;
    public NoSuchHeaderException(Exchange exchange, String headerName, Class<?> type) {
        super(""No '"" + headerName + ""' header available of type: "" + type.getName()
              + reason(exchange, headerName), exchange);
        this.headerName = headerName;
        this.type = type;
    }
    public String getHeaderName() {
        return headerName;
    }
    public Class<?> getType() {
        return type;
    }
    protected static String reason(Exchange exchange, String propertyName) {
        Object value = exchange.getProperty(propertyName);
        return valueDescription(value);
    }
    static String valueDescription(Object value) {
        if (value == null) {
            return """";
        }
        return "" but has value: "" + value + "" of type: "" + value.getClass().getName();
    }
}"
org.apache.camel.spring.RouteBuilderFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Routes;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
/**
 * A helper class which will find all {@link RouteBuilder} instances on the classpath
 *
 * @version $Revision$
 */
public class RouteBuilderFinder {
    private static final transient Log LOG = LogFactory.getLog(RouteBuilderFinder.class);
    private final SpringCamelContext camelContext;
    private final String[] packages;
    private ResolverUtil resolver;
    private ApplicationContext applicationContext;    
    private BeanPostProcessor beanPostProcessor;
    public RouteBuilderFinder(SpringCamelContext camelContext, String[] packages, ClassLoader classLoader, BeanPostProcessor postProcessor, ResolverUtil resolverUtil) {
        this.camelContext = camelContext;
        this.applicationContext = camelContext.getApplicationContext();
        this.packages = packages;
        this.beanPostProcessor = postProcessor;
        this.resolver = resolverUtil;
        // lets add all the available class loaders just in case of weirdness
        // we could make this more strict once we've worked out all the gremlins
        // in servicemix-camel
        Set set = resolver.getClassLoaders();
        set.clear();
        set.add(classLoader);
/*
        set.add(classLoader);
        set.add(applicationContext.getClassLoader());
        set.add(getClass().getClassLoader());
*/
    }
    public String[] getPackages() {
        return packages;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    /**
     * Appends all the {@link RouteBuilder} instances that can be found on the classpath
     */
    public void appendBuilders(List<Routes> list) throws IllegalAccessException, InstantiationException {
        resolver.findImplementations(Routes.class, packages);
        Set<Class> classes = resolver.getClasses();
        for (Class aClass : classes) {
            if (shouldIgnoreBean(aClass)) {
                continue;
            }
            if (isValidClass(aClass)) {
                Routes builder = instantiateBuilder(aClass);
                if (beanPostProcessor != null) {
                    // Inject the annotated resource
                    beanPostProcessor.postProcessBeforeInitialization(builder, builder.toString());
                }
                list.add(builder);
            }
        }
    }
    public void destroy() throws Exception {
    }
    /**
     * Lets ignore beans that are not explicitly configured in the spring.xml
     */
    protected boolean shouldIgnoreBean(Class type) {
        Map beans = applicationContext.getBeansOfType(type, true, true);
        if (beans == null || beans.isEmpty()) {
            return false;
        }
        // TODO apply some filter?
        return true;
    }
    /**
     * Returns true if the object is non-abstract and supports a zero argument constructor
     */
    protected boolean isValidClass(Class type) {
        if (!Modifier.isAbstract(type.getModifiers()) && !type.isInterface()) {
            return true;
        }
        return false;
    }
    protected Routes instantiateBuilder(Class type) throws IllegalAccessException, InstantiationException {
        return (Routes) camelContext.getInjector().newInstance(type);
    }
}
"
org.apache.camel.bam.model.EntitySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
/**
 * A base class for persistent entities
 *
 * @version $Revision$
 */
public class EntitySupport {
    private Long id;
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String toString() {
        return getClass().getName() + ""["" + id + ""]"";
    }
}
"
org.apache.camel.component.http.HttpExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents a HTTP exchange which exposes the underlying HTTP abtractions via
 * {@link #getRequest()} and {@link #getResponse()}
 *
 * @version $Revision$
 */
public class HttpExchange extends DefaultExchange {
    private final HttpEndpoint endpoint;
    private HttpServletRequest request;
    private HttpServletResponse response;
    public HttpExchange(HttpEndpoint endpoint, ExchangePattern pattern) {
        super(endpoint.getCamelContext(), pattern);
        this.endpoint = endpoint;
    }
    public HttpExchange(HttpEndpoint endpoint, HttpServletRequest request, HttpServletResponse response) {
        this(endpoint, getPatternFromRequest(request));
        this.request = request;
        this.response = response;
        setIn(new HttpMessage(this, request));
    }
    /**
     * Returns the underlying Servlet request for inbound HTTP requests
     */
    public HttpServletRequest getRequest() {
        return request;
    }
    /**
     * Returns the underlying Servlet response for inbound HTTP requests
     */
    public HttpServletResponse getResponse() {
        return response;
    }
    public HttpEndpoint getEndpoint() {
        return endpoint;
    }
    protected static ExchangePattern getPatternFromRequest(HttpServletRequest request) {
        // TODO for now just default to InOut?
        return ExchangePattern.InOut;
    }
}
"
org.apache.camel.component.file.FileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.language.simple.FileLanguage;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/file.html"">File Endpoint</a> for
 * working with file systems
 *
 * @version $Revision$
 */
public class FileEndpoint extends ScheduledPollEndpoint<FileExchange> {
    public static final transient String DEFAULT_LOCK_FILE_POSTFIX = "".camelLock"";
    private static final transient Log LOG = LogFactory.getLog(FileEndpoint.class);
    private static final transient String DEFAULT_STRATEGYFACTORY_CLASS =
        ""org.apache.camel.component.file.strategy.FileProcessStrategyFactory"";
    private File file;
    private FileProcessStrategy fileProcessStrategy;
    private boolean autoCreate = true;
    private boolean lock = true;
    private boolean delete;
    private boolean noop;
    private boolean append = true;
    private String moveNamePrefix;
    private String moveNamePostfix;
    private String[] excludedNamePrefixes;
    private String[] excludedNamePostfixes;
    private String preMoveNamePrefix;
    private String preMoveNamePostfix;
    private String excludedNamePrefix;
    private String excludedNamePostfix;
    private int bufferSize = 128 * 1024;
    private boolean ignoreFileNameHeader;
    private Expression expression;
    private Expression preMoveExpression;
    protected FileEndpoint(File file, String endpointUri, FileComponent component) {
        super(endpointUri, component);
        this.file = file;
    }
    public FileEndpoint(String endpointUri, File file) {
        super(endpointUri);
        this.file = file;
    }
    public FileEndpoint(File file) {
        this.file = file;
    }
    public FileEndpoint() {
    }
    public Producer<FileExchange> createProducer() throws Exception {
        Producer<FileExchange> result = new FileProducer(this);
        return result;
    }
    public Consumer<FileExchange> createConsumer(Processor processor) throws Exception {
        Consumer<FileExchange> result = new FileConsumer(this, processor);
        if (isDelete() && (getMoveNamePrefix() != null || getMoveNamePostfix() != null || getExpression() != null)) {
            throw new IllegalArgumentException(""You cannot set delet and a moveNamePrefix, moveNamePostfix or expression option"");
        }
        configureConsumer(result);
        return result;
    }
    /**
     * Create a new exchange for communicating with this endpoint
     *
     * @param file  the file
     * @return the created exchange
     */
    public FileExchange createExchange(File file) {
        return new FileExchange(getCamelContext(), getExchangePattern(), file);
    }
    @Override
    public FileExchange createExchange() {
        return createExchange(getFile());
    }
    @Override
    public FileExchange createExchange(ExchangePattern pattern) {
        return new FileExchange(getCamelContext(), pattern, file);
    }
    /**
     * Return the file name that will be auto-generated for the given message if none is provided
     */
    public String getGeneratedFileName(Message message) {
        return getFileFriendlyMessageId(message.getMessageId());
    }
    /**
     * Configures the given message with the file which sets the body to the file object
     * and sets the {@link FileComponent#HEADER_FILE_NAME} header.
     */
    public void configureMessage(File file, Message message) {
        message.setBody(file);
        String relativePath = file.getPath().substring(getFile().getPath().length());
        if (relativePath.startsWith(File.separator) || relativePath.startsWith(""/"")) {
            relativePath = relativePath.substring(1);
        }
        message.setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
    }
    public File getFile() {
        ObjectHelper.notNull(file, ""file"");
        if (autoCreate && !file.exists()) {
            file.mkdirs();
        }
        return file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    public boolean isSingleton() {
        return true;
    }
    public boolean isAutoCreate() {
        return this.autoCreate;
    }
    public void setAutoCreate(boolean autoCreate) {
        this.autoCreate = autoCreate;
    }
    public FileProcessStrategy getFileStrategy() {
        if (fileProcessStrategy == null) {
            fileProcessStrategy = createFileStrategy();
            LOG.debug(""Using file process strategy: "" + fileProcessStrategy);
        }
        return fileProcessStrategy;
    }
    /**
     * Sets the strategy to be used when the file has been processed such as
     * deleting or renaming it etc.
     *
     * @param fileProcessStrategy the new strategy to use
     */
    public void setFileStrategy(FileProcessStrategy fileProcessStrategy) {
        this.fileProcessStrategy = fileProcessStrategy;
    }
    public boolean isDelete() {
        return delete;
    }
    public void setDelete(boolean delete) {
        this.delete = delete;
    }
    public boolean isLock() {
        return lock;
    }
    public void setLock(boolean lock) {
        this.lock = lock;
    }
    public String getMoveNamePostfix() {
        return moveNamePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example to rename all
     * the files from <tt>*</tt> to <tt>*.done</tt> set this value to <tt>.done</tt>
     */
    public void setMoveNamePostfix(String moveNamePostfix) {
        this.moveNamePostfix = moveNamePostfix;
    }
    public String getMoveNamePrefix() {
        return moveNamePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example to move
     * processed files into a hidden directory called <tt>.camel</tt> set this value to
     * <tt>.camel/</tt>
     */
    public void setMoveNamePrefix(String moveNamePrefix) {
        this.moveNamePrefix = moveNamePrefix;
    }
    public String[] getExcludedNamePrefixes() {
        return excludedNamePrefixes;
    }
    /**
     * Sets the excluded file name prefixes, such as <tt>"".""</tt> for hidden files which
     * are excluded by default
     *
     * @deprecated use ExcludedNamePrefix. Will be removed in Camel 2.0.
     */
    public void setExcludedNamePrefixes(String[] excludedNamePrefixes) {
        this.excludedNamePrefixes = excludedNamePrefixes;
    }
    public String[] getExcludedNamePostfixes() {
        return excludedNamePostfixes;
    }
    /**
     * Sets the excluded file name postfixes, such as {@link FileEndpoint#DEFAULT_LOCK_FILE_POSTFIX}
     * to ignore lock files by default.
     *
     * @deprecated use ExcludedNamePostfix. Will be removed in Camel 2.0.
     */
    public void setExcludedNamePostfixes(String[] excludedNamePostfixes) {
        this.excludedNamePostfixes = excludedNamePostfixes;
    }
    public String getPreMoveNamePrefix() {
        return preMoveNamePrefix;
    }
    public void setPreMoveNamePrefix(String preMoveNamePrefix) {
        this.preMoveNamePrefix = preMoveNamePrefix;
    }
    /**
     * Sets the name prefix appended to pre moved files. For example to move
     * files before processing into a inprogress directory called <tt>.inprogress</tt> set this value to
     * <tt>.inprogress/</tt>
     */
    public String getPreMoveNamePostfix() {
        return preMoveNamePostfix;
    }
    /**
     * Sets the name postfix appended to pre moved files. For example to rename
     * files before processing from <tt>*</tt> to <tt>*.inprogress</tt> set this value to <tt>.inprogress</tt>
     */
    public void setPreMoveNamePostfix(String preMoveNamePostfix) {
        this.preMoveNamePostfix = preMoveNamePostfix;
    }
    public boolean isNoop() {
        return noop;
    }
    /**
     * If set to true then the default {@link FileProcessStrategy} will be to use the
     * {@link org.apache.camel.component.file.strategy.NoOpFileProcessStrategy NoOpFileProcessStrategy}
     * to not move or copy processed files
     */
    public void setNoop(boolean noop) {
        this.noop = noop;
    }
    public boolean isAppend() {
        return append;
    }
    /**
     * When writing do we append to the end of the file, or replace it?
     * The default is to append
     */
    public void setAppend(boolean append) {
        this.append = append;
    }
    public int getBufferSize() {
        return bufferSize;
    }
    /**
     * Sets the buffer size used to read/write files
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }
    public boolean isIgnoreFileNameHeader() {
        return ignoreFileNameHeader;
    }
    /**
     * If this flag is enabled then producers will ignore the {@link FileComponent#HEADER_FILE_NAME}
     * header and generate a new dynamic file
     */
    public void setIgnoreFileNameHeader(boolean ignoreFileNameHeader) {
        this.ignoreFileNameHeader = ignoreFileNameHeader;
    }
    public String getExcludedNamePrefix() {
        return excludedNamePrefix;
    }
    public void setExcludedNamePrefix(String excludedNamePrefix) {
        this.excludedNamePrefix = excludedNamePrefix;
    }
    public String getExcludedNamePostfix() {
        return excludedNamePostfix;
    }
    public void setExcludedNamePostfix(String excludedNamePostfix) {
        this.excludedNamePostfix = excludedNamePostfix;
    }
    public Expression getExpression() {
        return expression;
    }
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
    /**
     * Sets the expression based on {@link FileLanguage}
     */
    public void setExpression(String fileLanguageExpression) {
        this.expression = FileLanguage.file(fileLanguageExpression);
    }
    public Expression getPreMoveExpression() {
        return preMoveExpression;
    }
    public void setPreMoveExpression(Expression expression) {
        this.preMoveExpression = expression;
    }
    /**
     * Sets the pre move expression based on {@link FileLanguage}
     */
    public void setPreMoveExpression(String fileLanguageExpression) {
        this.preMoveExpression = FileLanguage.file(fileLanguageExpression);
    }
    /**
     * A strategy method to lazily create the file strategy
     */
    protected FileProcessStrategy createFileStrategy() {
        Class<?> factory = null;
        try {
            FactoryFinder finder = getCamelContext().createFactoryFinder(""META-INF/services/org/apache/camel/component/"");
            factory = finder.findClass(""file"", ""strategy.factory."");
        } catch (ClassNotFoundException e) {
            LOG.debug(""'strategy.factory.class' not found"", e);
        } catch (IOException e) {
            LOG.debug(""No strategy factory defined in 'META-INF/services/org/apache/camel/component/file'"", e);
        }
        if (factory == null) {
            // use default
            factory = ObjectHelper.loadClass(DEFAULT_STRATEGYFACTORY_CLASS);
            if (factory == null) {
                throw new TypeNotPresentException(""FileProcessStrategyFactory class not found"", null);
            }
        }
        try {
            Method factoryMethod = factory.getMethod(""createFileProcessStrategy"", Map.class);
            return (FileProcessStrategy) ObjectHelper.invokeMethod(factoryMethod, null, getParamsAsMap());
        } catch (NoSuchMethodException e) {
            throw new TypeNotPresentException(factory.getSimpleName()
                + "".createFileProcessStrategy(Properties params) method not found"", e);
        }
    }
    protected Map<String, Object> getParamsAsMap() {
        Map<String, Object> params = new HashMap<String, Object>();
        if (isNoop()) {
            params.put(""noop"", Boolean.toString(true));
        }
        if (isDelete()) {
            params.put(""delete"", Boolean.toString(true));
        }
        if (isAppend()) {
            params.put(""append"", Boolean.toString(true));
        }
        if (isLock()) {
            params.put(""lock"", Boolean.toString(true));
        }
        if (moveNamePrefix != null) {
            params.put(""moveNamePrefix"", moveNamePrefix);
        }
        if (moveNamePostfix != null) {
            params.put(""moveNamePostfix"", moveNamePostfix);
        }
        if (preMoveNamePrefix != null) {
            params.put(""preMoveNamePrefix"", preMoveNamePrefix);
        }
        if (preMoveNamePostfix != null) {
            params.put(""preMoveNamePostfix"", preMoveNamePostfix);
        }
        if (expression != null) {
            params.put(""expression"", expression);
        }
        if (preMoveExpression != null) {
            params.put(""preMoveExpression"", preMoveExpression);
        }
        return params;
    }
    @Override
    protected String createEndpointUri() {
        return ""file://"" + getFile().getAbsolutePath();
    }
    protected String getFileFriendlyMessageId(String id) {
        return UuidGenerator.generateSanitizedId(id);
    }
}
"
org.apache.camel.management.InstrumentationInterceptStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Map;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
/**
 * This strategy class wraps targeted processors with a
 * {@link InstrumentationProcessor}. Each InstrumentationProcessor has an
 * embedded {@link PerformanceCounter} for monitoring performance metrics.
 * <p/>
 * This class looks up a map to determine which PerformanceCounter should go into the
 * InstrumentationProcessor for any particular target processor.
 *
 * @version $Revision$
 */
public class InstrumentationInterceptStrategy implements InterceptStrategy {
    private Map<ProcessorType, PerformanceCounter> counterMap;
    public InstrumentationInterceptStrategy(Map<ProcessorType, PerformanceCounter> counterMap) {
        this.counterMap = counterMap;
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType,
            Processor target) throws Exception {
        Processor retval = target;
        PerformanceCounter counter = counterMap.get(processorType);
        if (counter != null) {
            InstrumentationProcessor wrapper = new InstrumentationProcessor(counter);
            wrapper.setProcessor(target);
            retval = wrapper;
        }
        return retval;
    }
}
"
org.apache.camel.component.cxf.invoker.RawMessageInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.InputStream;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public class RawMessageInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = LogUtils.getL7dLogger(RawMessageInvokingContext.class);
    public RawMessageInvokingContext() {
    }
    public void setRequestOutMessageContent(Message message, Map<Class, Object> contents) {
        Set entries = contents.keySet();
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            Object obj = iter.next();
            if (obj instanceof Class) {
                message.setContent((Class<?>)obj, contents.get((Class<?>)obj));
            }
        }
    }
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        return getResponseObject(exchange.getInMessage(), responseContext, InputStream.class);
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        LOG.info(""Set content: "" + resultPayload);
        outMessage.setContent(InputStream.class, resultPayload);
        //loggerTheMessage(outMessage, ""Out Message"");
    }
    public Map<Class, Object> getRequestContent(Message inMessage) {
        //loggerTheMessage(inMessage, ""In Message"");
        IdentityHashMap<Class, Object> contents = new IdentityHashMap<Class, Object>();
        Set set = inMessage.getContentFormats();
        Iterator iter = set.iterator();
        while (iter.hasNext()) {
            Object obj = iter.next();
            if (obj instanceof Class) {
                contents.put((Class<?>)obj, inMessage.getContent((Class<?>)obj));
            }
        }
        return contents;
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.component.cxf.CxfConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import javax.xml.ws.WebServiceProvider;
import org.apache.camel.Processor;
import org.apache.camel.component.cxf.feature.MessageDataFormatFeature;
import org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.bus.spring.SpringBusFactory;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.configuration.spring.ConfigurerImpl;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;
/**
 * A consumer of exchanges for a service in CXF
 *
 * @version $Revision$
 */
public class CxfConsumer extends DefaultConsumer<CxfExchange> {
    private CxfEndpoint endpoint;
    private Server server;
    public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {
        super(endpoint, processor);
        Bus bus = null;
        this.endpoint = endpoint;
        boolean isWebServiceProvider = false;
        if (endpoint.getApplicationContext() != null) {            
            if (endpoint.getCxfEndpointBean() != null) {
                bus = endpoint.getCxfEndpointBean().getBus();
            } else {
                SpringBusFactory busFactory = new SpringBusFactory(endpoint.getApplicationContext());
                bus = busFactory.createBus();
            }
            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {
                BusFactory.setDefaultBus(bus);
            }
        } else {
            // now we just use the default bus here
            bus = BusFactory.getDefaultBus();
        }
        Class serviceClass = CxfEndpointUtils.getServiceClass(endpoint);
        ServerFactoryBean svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);
        isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass,
                                                              WebServiceProvider.class);
        if (endpoint.isSpringContextEndpoint()) {
            endpoint.configure(svrBean);
        } else { // setup the serverFactoryBean with the URI parameters
            svrBean.setAddress(endpoint.getAddress());                       
            if (endpoint.getWsdlURL() != null) {
                svrBean.setWsdlURL(endpoint.getWsdlURL());
            }
        }
        svrBean.setServiceClass(serviceClass);
        if (CxfEndpointUtils.getServiceName(endpoint) != null) {
            svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));
        }
        if (CxfEndpointUtils.getServiceName(endpoint) != null) {
            svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));
        }
        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        svrBean.setInvoker(new CamelInvoker(this));
        // apply feature here
        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {
            if (dataFormat.equals(DataFormat.PAYLOAD)) {
                svrBean.getFeatures().add(new PayLoadDataFormatFeature());
                // adding the logging feature here for debug
                //features.add(new LoggingFeature());
            } else if (dataFormat.equals(DataFormat.MESSAGE)) {
                svrBean.getFeatures().add(new MessageDataFormatFeature());
                //features.add(new LoggingFeature());
            }
        }
        svrBean.setBus(bus);
        svrBean.setStart(false);
        server = svrBean.create();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        server.start();       
    }
    @Override
    protected void doStop() throws Exception {
        server.stop();
        super.doStop();
    }
    public CxfEndpoint getEndpoint() {
        return endpoint;
    }
    public Server getServer() {
        return server;
    }
}
"
org.apache.camel.component.atom.UpdatedDateFilter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Date;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Filters out all entries which occur before the last time of the entry we saw (assuming
 * entries arrive sorted in order).
 *
 * @version $Revision$
 */
public class UpdatedDateFilter implements EntryFilter {
    private static final transient Log LOG = LogFactory.getLog(UpdatedDateFilter.class);
    private Date lastUpdate;
    public UpdatedDateFilter(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
    public boolean isValidEntry(AtomEndpoint endpoint, Document<Feed> feed, Entry entry) {
        Date updated = entry.getUpdated();
        if (updated == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""No updated time for entry so assuming its valid: entry=["" + entry + ""]"");
            }
            return true;
        }
        if (lastUpdate != null) {
            if (lastUpdate.after(updated)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Entry is older than lastupdate=["" + lastUpdate
                        + ""], no valid entry=["" + entry + ""]"");
                }
                return false;
            }
        }
        lastUpdate = updated;
        return true;
    }
}
"
org.apache.camel.builder.script.Python,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of Python expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""python"")
public @interface Python {
    String value();
}"
org.apache.camel.component.stream.StreamEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.nio.charset.Charset;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class StreamEndpoint extends DefaultEndpoint<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamEndpoint.class);
    private String uri;
    private String file;
    private String url;
    private long delay;
    private String encoding;
    public StreamEndpoint(String endpointUri, Component component) throws Exception {
        super(endpointUri, component);
        this.uri = endpointUri;
    }
    public StreamEndpoint(String endpointUri) {
        super(endpointUri);
        this.uri = endpointUri;
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new StreamConsumer(this, processor, uri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new StreamProducer(this, uri);
    }
    public boolean isSingleton() {
        return true;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getFile() {
        return file;
    }
    /**
     * @deprecated use camel-file component. Will be removed in Camel 2.0
     */
    public void setFile(String file) {
        this.file = file;
    }
    public String getUrl() {
        return url;
    }
    /**
     * @deprecated use camel-jetty or camel-http component. Will be removed in Camel 2.0
     */
    public void setUrl(String url) {
        this.url = url;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public String getEncoding() {
        return encoding;
    }
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    // Implementations
    //-------------------------------------------------------------------------
    Charset getCharset() {
        if (encoding == null) {
            encoding = Charset.defaultCharset().name();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""No encoding parameter using default charset: "" + encoding);
            }
        }
        if (!Charset.isSupported(encoding)) {
            throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported"");
        }
        return Charset.forName(encoding);
    }
}
"
org.apache.camel.EndpointInject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.spi.Registry;
/**
 * Used to indicate an injection point of an {@link Endpoint}, {@link Producer} or
 * {@link ProducerTemplate} into a POJO.
 *
 * A <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an endpoint
 * can be specified on this annotation, or a name can be specified which is resolved in the
 * {@link Registry} such as in your Spring ApplicationContext.
 *
 * If no name or uri is specified then the name is defaulted from the field, property or method name.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface EndpointInject {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.impl.ProcessorEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
/**
 * An endpoint which allows exchanges to be sent into it which just invokes a
 * given {@link Processor}. This component does not support the use of
 * consumers.
 *
 * @version $Revision$
 */
public class ProcessorEndpoint extends DefaultPollingEndpoint<Exchange> {
    private Processor processor;
    protected ProcessorEndpoint() {
    }
    protected ProcessorEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public ProcessorEndpoint(String endpointUri, CamelContext context, Processor processor) {
        super(endpointUri, context);
        this.processor = processor;
    }
    public ProcessorEndpoint(String endpointUri, Component component, Processor processor) {
        super(endpointUri, component);
        this.processor = processor;
    }
    public ProcessorEndpoint(String endpointUri, Processor processor) {
        super(endpointUri);
        this.processor = processor;
    }
    protected ProcessorEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    @Override
    public PollingConsumer<Exchange> createPollingConsumer() throws Exception {
        return new ProcessorPollingConsumer(this, getProcessor());
    }
    public Processor getProcessor() throws Exception {
        if (processor == null) {
            processor = createProcessor();
        }
        return processor;
    }
    protected Processor createProcessor() throws Exception {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    protected void onExchange(Exchange exchange) throws Exception {
        getProcessor().process(exchange);
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.impl.ScheduledPollConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any consumer which is polling based
 * 
 * @version $Revision$
 */
public abstract class ScheduledPollConsumer<E extends Exchange> extends DefaultConsumer<E> implements
    Runnable {
    private static final transient Log LOG = LogFactory.getLog(ScheduledPollConsumer.class);
    private final ScheduledExecutorService executor;
    private long initialDelay = 1000;
    private long delay = 500;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private boolean useFixedDelay;
    private ScheduledFuture<?> future;
    private Exception firstExceptionThrown;
    public ScheduledPollConsumer(DefaultEndpoint<E> endpoint, Processor processor) {
        this(endpoint, processor, endpoint.getExecutorService());
    }
    public ScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor);
        this.executor = executor;
        if (executor == null) {
            throw new IllegalArgumentException(""A non null ScheduledExecutorService must be provided."");
        }
    }
    /**
     * Invoked whenever we should be polled
     */
    public void run() {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Starting to poll: "" + this.getEndpoint());
        }
        try {
            poll();
        } catch (Exception e) {
            LOG.warn(""An exception occured while polling: "" + this.getEndpoint() + "": "" + e.getMessage(), e);
            if (firstExceptionThrown == null) {
                firstExceptionThrown = e;
            } 
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getInitialDelay() {
        return initialDelay;
    }
    public void setInitialDelay(long initialDelay) {
        this.initialDelay = initialDelay;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public boolean isUseFixedDelay() {
        return useFixedDelay;
    }
    public void setUseFixedDelay(boolean useFixedDelay) {
        this.useFixedDelay = useFixedDelay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * The polling method which is invoked periodically to poll this consumer
     * 
     * @throws Exception can be thrown if an exception occurred during polling
     */
    protected abstract void poll() throws Exception;
    @Override
    protected void doStart() throws Exception {
        firstExceptionThrown = null;
        super.doStart();
        if (isUseFixedDelay()) {
            future = executor.scheduleWithFixedDelay(this, getInitialDelay(), getDelay(), getTimeUnit());
        } else {
            future = executor.scheduleAtFixedRate(this, getInitialDelay(), getDelay(), getTimeUnit());
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (future != null) {
            future.cancel(false);
        }
        super.doStop();
        if (firstExceptionThrown != null) {
            throw firstExceptionThrown;
        }
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.core.MessageChannel;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/springIntergration.html"">Spring Intergration Endpoint</a>
 *
 * @version $Revision$
 */
public class SpringIntegrationEndpoint extends ScheduledPollEndpoint<SpringIntegrationExchange> {
    private static final Log LOG = LogFactory.getLog(SpringIntegrationEndpoint.class);
    private String inputChannel;
    private String outputChannel;
    private String defaultChannel;
    private MessageChannel messageChannel;
    private boolean inOut;
    public SpringIntegrationEndpoint(String uri, String channel, SpringIntegrationComponent component) {
        super(uri, component);
        defaultChannel = channel;
    }
    public SpringIntegrationEndpoint(String uri, MessageChannel channel, CamelContext context) {
        super(uri, context);
        messageChannel = channel;
    }
    public SpringIntegrationEndpoint(String endpointUri, MessageChannel messageChannel) {
        super(endpointUri);
        this.messageChannel = messageChannel;
    }
    public Producer<SpringIntegrationExchange> createProducer() throws Exception {
        return new SpringIntegrationProducer(this);
    }
    public Consumer<SpringIntegrationExchange> createConsumer(Processor processor) throws Exception {
        return new SpringIntegrationConsumer(this, processor);
    }
    public SpringIntegrationExchange createExchange() {
        return createExchange(getExchangePattern());
    }
    public SpringIntegrationExchange createExchange(ExchangePattern pattern) {
        return new SpringIntegrationExchange(getCamelContext(), pattern);
    }
    public void setInputChannel(String input) {
        inputChannel = input;
    }
    public String getInputChannel() {
        return inputChannel;
    }
    public void setOutputChannel(String output) {
        outputChannel = output;
    }
    public String getOutputChannel() {
        return outputChannel;
    }
    public String getDefaultChannel() {
        return defaultChannel;
    }
    public MessageChannel getMessageChannel() {
        return messageChannel;
    }
    public boolean isSingleton() {
        return false;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public boolean isInOut() {
        return this.inOut;
    }
}
"
org.apache.camel.builder.script.ScriptBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * A builder class for creating {@link Processor}, {@link Expression} and
 * {@link Predicate} objects using the JSR 223 scripting engine.
 *
 * @version $Revision$
 */
public class ScriptBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, Processor {
    private static final transient Log LOG = LogFactory.getLog(ScriptBuilder.class);
    private String scriptEngineName;
    private Resource scriptResource;
    private String scriptText;
    private ScriptEngine engine;
    private CompiledScript compiledScript;
    public ScriptBuilder(String scriptEngineName) {
        this.scriptEngineName = scriptEngineName;
    }
    public ScriptBuilder(String scriptEngineName, String scriptText) {
        this(scriptEngineName);
        this.scriptText = scriptText;
    }
    public ScriptBuilder(String scriptEngineName, Resource scriptResource) {
        this(scriptEngineName);
        this.scriptResource = scriptResource;
    }
    @Override
    public String toString() {
        return getScriptDescription();
    }
    public Object evaluate(E exchange) {
        return evaluateScript(exchange);
    }
    public boolean matches(E exchange) {
        Object scriptValue = evaluateScript(exchange);
        return matches(exchange, scriptValue);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object scriptValue = evaluateScript(exchange);
        if (!matches(exchange, scriptValue)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as script returned <"" + scriptValue + "">"");
        }
    }
    public void process(Exchange exchange) {
        evaluateScript(exchange);
    }
    // Builder API
    // -------------------------------------------------------------------------
    /**
     * Sets the attribute on the context so that it is available to the script
     * as a variable in the {@link ScriptContext#ENGINE_SCOPE}
     *
     * @param name the name of the attribute
     * @param value the attribute value
     * @return this builder
     */
    public ScriptBuilder attribute(String name, Object value) {
        getScriptContext().setAttribute(name, value, ScriptContext.ENGINE_SCOPE);
        return this;
    }
    // Create any scripting language builder recognised by JSR 223
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the named language and script contents
     *
     * @param language the language to use for the script
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder script(String language, String scriptText) {
        return new ScriptBuilder(language, scriptText);
    }
    /**
     * Creates a script builder for the named language and script {@link Resource}
     *
     * @param language the language to use for the script
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, Resource scriptResource) {
        return new ScriptBuilder(language, scriptResource);
    }
    /**
     * Creates a script builder for the named language and script {@link File}
     *
     * @param language the language to use for the script
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, File scriptFile) {
        return new ScriptBuilder(language, new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the named language and script {@link URL}
     *
     * @param language the language to use for the script
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, URL scriptURL) {
        return new ScriptBuilder(language, new UrlResource(scriptURL));
    }
    // Beanshell
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the BeanShell script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public static ScriptBuilder beanShell(String scriptText) {
        return new ScriptBuilder(""beanshell"", scriptText);
    }
    /**
     * Creates a script builder for the BeanShell script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public static ScriptBuilder beanShell(Resource scriptResource) {
        return new ScriptBuilder(""beanshell"", scriptResource);
    }
    /**
     * Creates a script builder for the BeanShell script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public static ScriptBuilder beanShell(File scriptFile) {
        return new ScriptBuilder(""beanshell"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the BeanShell script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     * @deprecated will be removed in Camel 2.0
     */
    public static ScriptBuilder beanShell(URL scriptURL) {
        return new ScriptBuilder(""beanshell"", new UrlResource(scriptURL));
    }
    // Groovy
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the groovy script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder groovy(String scriptText) {
        return new ScriptBuilder(""groovy"", scriptText);
    }
    /**
     * Creates a script builder for the groovy script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(Resource scriptResource) {
        return new ScriptBuilder(""groovy"", scriptResource);
    }
    /**
     * Creates a script builder for the groovy script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(File scriptFile) {
        return new ScriptBuilder(""groovy"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the groovy script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(URL scriptURL) {
        return new ScriptBuilder(""groovy"", new UrlResource(scriptURL));
    }
    // JavaScript
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the JavaScript/ECMAScript script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder javaScript(String scriptText) {
        return new ScriptBuilder(""js"", scriptText);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script
     *
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(Resource scriptResource) {
        return new ScriptBuilder(""js"", scriptResource);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(File scriptFile) {
        return new ScriptBuilder(""js"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(URL scriptURL) {
        return new ScriptBuilder(""js"", new UrlResource(scriptURL));
    }
    // PHP
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the PHP script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder php(String scriptText) {
        return new ScriptBuilder(""php"", scriptText);
    }
    /**
     * Creates a script builder for the PHP script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(Resource scriptResource) {
        return new ScriptBuilder(""php"", scriptResource);
    }
    /**
     * Creates a script builder for the PHP script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(File scriptFile) {
        return new ScriptBuilder(""php"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the PHP script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(URL scriptURL) {
        return new ScriptBuilder(""php"", new UrlResource(scriptURL));
    }
    // Python
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Python script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder python(String scriptText) {
        return new ScriptBuilder(""python"", scriptText);
    }
    /**
     * Creates a script builder for the Python script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(Resource scriptResource) {
        return new ScriptBuilder(""python"", scriptResource);
    }
    /**
     * Creates a script builder for the Python script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(File scriptFile) {
        return new ScriptBuilder(""python"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Python script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(URL scriptURL) {
        return new ScriptBuilder(""python"", new UrlResource(scriptURL));
    }
    // Ruby/JRuby
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Ruby/JRuby script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder ruby(String scriptText) {
        return new ScriptBuilder(""jruby"", scriptText);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(Resource scriptResource) {
        return new ScriptBuilder(""jruby"", scriptResource);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(File scriptFile) {
        return new ScriptBuilder(""jruby"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(URL scriptURL) {
        return new ScriptBuilder(""jruby"", new UrlResource(scriptURL));
    }
    // Properties
    // -------------------------------------------------------------------------
    public ScriptEngine getEngine() {
        checkInitialised();
        if (engine == null) {
            throw new IllegalArgumentException(""No script engine could be created for: "" + getScriptEngineName());
        }
        return engine;
    }
    public CompiledScript getCompiledScript() {
        return compiledScript;
    }
    public String getScriptText() {
        return scriptText;
    }
    public void setScriptText(String scriptText) {
        this.scriptText = scriptText;
    }
    public String getScriptEngineName() {
        return scriptEngineName;
    }
    /**
     * Returns a description of the script
     *
     * @return the script description
     */
    public String getScriptDescription() {
        if (scriptText != null) {
            return scriptEngineName + "": "" + scriptText;
        } else if (scriptResource != null) {
            return scriptEngineName + "": "" + scriptResource.getDescription();
        } else {
            return scriptEngineName + "": null script"";
        }
    }
    /**
     * Access the script context so that it can be configured such as adding
     * attributes
     */
    public ScriptContext getScriptContext() {
        return getEngine().getContext();
    }
    /**
     * Sets the context to use by the script
     */
    public void setScriptContext(ScriptContext scriptContext) {
        getEngine().setContext(scriptContext);
    }
    public Resource getScriptResource() {
        return scriptResource;
    }
    public void setScriptResource(Resource scriptResource) {
        this.scriptResource = scriptResource;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void checkInitialised() {
        if (scriptText == null && scriptResource == null) {
            throw new IllegalArgumentException(""Neither scriptText or scriptResource are specified"");
        }
        if (engine == null) {
            engine = createScriptEngine();
        }
        if (compiledScript == null) {
            if (engine instanceof Compilable) {
                compileScript((Compilable)engine);
            }
        }
    }
    protected boolean matches(E exchange, Object scriptValue) {
        return ObjectConverter.toBool(scriptValue);
    }
    protected ScriptEngine createScriptEngine() {
        ScriptEngineManager manager = new ScriptEngineManager();
        try {
            engine = manager.getEngineByName(scriptEngineName);
        } catch (NoClassDefFoundError ex) {
            LOG.error(""Can't load the scriptEngine for "" + scriptEngineName + "", the exception is "" + ex
                      + "", please check the scriptEngine needs jars."");
        }
        if (engine == null) {
            throw new IllegalArgumentException(""No script engine could be created for: "" + getScriptEngineName());
        }
        if (isPython()) {
            ScriptContext context = engine.getContext();
            context.setAttribute(""com.sun.script.jython.comp.mode"", ""eval"", ScriptContext.ENGINE_SCOPE);
        }
        return engine;
    }
    protected void compileScript(Compilable compilable) {
        try {
            if (scriptText != null) {
                compiledScript = compilable.compile(scriptText);
            } else if (scriptResource != null) {
                compiledScript = compilable.compile(createScriptReader());
            }
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script compile failed: "" + e, e);
            }
            throw createScriptCompileException(e);
        } catch (IOException e) {
            throw createScriptCompileException(e);
        }
    }
    protected synchronized Object evaluateScript(Exchange exchange) {
        try {
            getScriptContext();
            populateBindings(getEngine(), exchange);
            Object result = runScript();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""The script evaluation result is: "" + result);
            }
            return result;
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script evaluation failed: "" + e, e);
            }
            throw createScriptEvaluationException(e.getCause());
        } catch (IOException e) {
            throw createScriptEvaluationException(e);
        }
    }
    protected Object runScript() throws ScriptException, IOException {
        checkInitialised();
        Object result = null;
        if (compiledScript != null) {
            result = compiledScript.eval();
        } else {
            if (scriptText != null) {
                result = getEngine().eval(scriptText);
            } else {
                result = getEngine().eval(createScriptReader());
            }
        }
        return result;
    }
    protected void populateBindings(ScriptEngine engine, Exchange exchange) {
        ScriptContext context = engine.getContext();
        int scope = ScriptContext.ENGINE_SCOPE;
        context.setAttribute(""context"", exchange.getContext(), scope);
        context.setAttribute(""exchange"", exchange, scope);
        context.setAttribute(""request"", exchange.getIn(), scope);
        context.setAttribute(""response"", exchange.getOut(false), scope);
    }
    protected InputStreamReader createScriptReader() throws IOException {
        // TODO consider character sets?
        return new InputStreamReader(scriptResource.getInputStream());
    }
    protected ScriptEvaluationException createScriptCompileException(Exception e) {
        return new ScriptEvaluationException(""Failed to compile: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected ScriptEvaluationException createScriptEvaluationException(Throwable e) {
        if (e.getClass().getName().equals(""org.jruby.exceptions.RaiseException"")) {
            // Only the nested exception has the specific problem
            try {
                Object ex = e.getClass().getMethod(""getException"").invoke(e);
                return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "".  Error: "" + ex + "". Cause: "" + e, e);
            } catch (Exception e1) {
                // do nothing here
            }
        }
        return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected boolean isPython() {
        return ""python"".equals(scriptEngineName) || ""jython"".equals(scriptEngineName);
    }
}
"
org.apache.camel.impl.converter.TypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
/**
 * A pluggable strategy to load type converters into a registry from some kind of mechanism
 *
 * @version $Revision$
 */
public interface TypeConverterLoader {
    /**
     * A pluggable strategy to load type converters into a registry from some kind of mechanism
     *
     * @param registry the registry to load the type converters into
     * @throws Exception if the type converters could not be loaded
     */
    void load(TypeConverterRegistry registry) throws Exception;
}
"
org.apache.camel.component.bean.MethodInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Expression;
import org.apache.camel.Pattern;
import org.apache.camel.model.language.ConstantExpression;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.asString;
/**
 * Information about a method to be used for invocation.
 *
 * @version $Revision$
 */
public class MethodInfo {
    private static final transient Log LOG = LogFactory.getLog(MethodInfo.class);
    private Class type;
    private Method method;
    private final List<ParameterInfo> parameters;
    private final List<ParameterInfo> bodyParameters;
    private final boolean hasCustomAnnotation;
    private Expression parametersExpression;
    private ExchangePattern pattern = ExchangePattern.InOut;
    private RecipientList recipientList;
    public MethodInfo(Class type, Method method, List<ParameterInfo> parameters, List<ParameterInfo> bodyParameters, boolean hasCustomAnnotation) {
        this.type = type;
        this.method = method;
        this.parameters = parameters;
        this.bodyParameters = bodyParameters;
        this.hasCustomAnnotation = hasCustomAnnotation;
        this.parametersExpression = createParametersExpression();
        Pattern oneway = findOneWayAnnotation(method);
        if (oneway != null) {
            pattern = oneway.value();
        }
        if (method.getAnnotation(org.apache.camel.RecipientList.class) != null) {
            recipientList = new RecipientList(new ConstantExpression(null));
        }
    }
    public String toString() {
        return method.toString();
    }
    public MethodInvocation createMethodInvocation(final Object pojo, final Exchange exchange) {
        final Object[] arguments = (Object[]) parametersExpression.evaluate(exchange);
        return new MethodInvocation() {
            public Method getMethod() {
                return method;
            }
            public Object[] getArguments() {
                return arguments;
            }
            public Object proceed() throws Exception {
                if (LOG.isTraceEnabled()) {
                    LOG.trace("">>>> invoking: "" + method + "" on bean: "" + pojo + "" with arguments: "" + asString(arguments) + "" for exchange: "" + exchange);
                }
                Object result = invoke(method, pojo, arguments, exchange);
                if (recipientList != null) {
                    recipientList.sendToRecipientList(exchange, result);
                }
                return result;
            }
            public Object getThis() {
                return pojo;
            }
            public AccessibleObject getStaticPart() {
                return method;
            }
        };
    }
    public Class getType() {
        return type;
    }
    public Method getMethod() {
        return method;
    }
    /**
     * Returns the {@link org.apache.camel.ExchangePattern} that should be used when invoking this method. This value
     * defaults to {@link org.apache.camel.ExchangePattern#InOut} unless some {@link org.apache.camel.Pattern} annotation is used
     * to override the message exchange pattern.
     *
     * @return the exchange pattern to use for invoking this method.
     */
    public ExchangePattern getPattern() {
        return pattern;
    }
    public Expression getParametersExpression() {
        return parametersExpression;
    }
    public List<ParameterInfo> getBodyParameters() {
        return bodyParameters;
    }
    public Class getBodyParameterType() {
        ParameterInfo parameterInfo = bodyParameters.get(0);
        return parameterInfo.getType();
    }
    public boolean bodyParameterMatches(Class bodyType) {
        Class actualType = getBodyParameterType();
        return actualType != null && ObjectHelper.isAssignableFrom(bodyType, actualType);
    }
    public List<ParameterInfo> getParameters() {
        return parameters;
    }
    public boolean hasBodyParameter() {
        return !bodyParameters.isEmpty();
    }
    public boolean isHasCustomAnnotation() {
        return hasCustomAnnotation;
    }
    public boolean isReturnTypeVoid() {
        return method.getReturnType().getName().equals(""void"");
    }
    protected Object invoke(Method mth, Object pojo, Object[] arguments, Exchange exchange) throws IllegalAccessException, InvocationTargetException {
        return mth.invoke(pojo, arguments);
    }
    protected Expression createParametersExpression() {
        final int size = parameters.size();
        final Expression[] expressions = new Expression[size];
        for (int i = 0; i < size; i++) {
            Expression parameterExpression = parameters.get(i).getExpression();
            expressions[i] = parameterExpression;
        }
        return new Expression<Exchange>() {
            public Object evaluate(Exchange exchange) {
                Object[] answer = new Object[size];
                Object body = exchange.getIn().getBody();
                boolean multiParameterArray = false;
                if (exchange.getIn().getHeader(BeanProcessor.MULTI_PARAMETER_ARRAY) != null) {
                    multiParameterArray = exchange.getIn().getHeader(BeanProcessor.MULTI_PARAMETER_ARRAY, Boolean.class);
                }
                for (int i = 0; i < size; i++) {
                    Object value = null;
                    if (multiParameterArray) {
                        value = ((Object[])body)[i];
                    } else {
                        value = expressions[i].evaluate(exchange);
                    }
                    // now lets try to coerce the value to the required type
                    Class expectedType = parameters.get(i).getType();
                    value = ExchangeHelper.convertToType(exchange, expectedType, value);
                    answer[i] = value;
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""ParametersExpression: "" + Arrays.asList(expressions);
            }
        };
    }
    /**
     * Finds the oneway annotation in priority order; look for method level annotations first, then the class level annotations,
     * then super class annotations then interface annotations
     *
     * @param method the method on which to search
     * @return the first matching annotation or none if it is not available
     */
    protected Pattern findOneWayAnnotation(Method method) {
        Pattern answer = getPatternAnnotation(method);
        if (answer == null) {
            Class<?> type = method.getDeclaringClass();
            // lets create the search order of types to scan
            List<Class<?>> typesToSearch = new ArrayList<Class<?>>();
            addTypeAndSuperTypes(type, typesToSearch);
            Class[] interfaces = type.getInterfaces();
            for (Class anInterface : interfaces) {
                addTypeAndSuperTypes(anInterface, typesToSearch);
            }
            // now lets scan for a type which the current declared class overloads
            answer = findOneWayAnnotationOnMethod(typesToSearch, method);
            if (answer == null) {
                answer = findOneWayAnnotation(typesToSearch);
            }
        }
        return answer;
    }
    /**
     * Returns the pattern annotation on the given annotated element; either as a direct annotation or
     * on an annotation which is also annotated
     *
     * @param annotatedElement the element to look for the annotation
     * @return the first matching annotation or null if none could be found
     */
    protected Pattern getPatternAnnotation(AnnotatedElement annotatedElement) {
        return getPatternAnnotation(annotatedElement, 2);
    }
    /**
     * Returns the pattern annotation on the given annotated element; either as a direct annotation or
     * on an annotation which is also annotated
     *
     * @param annotatedElement the element to look for the annotation
     * @return the first matching annotation or null if none could be found
     */
    protected Pattern getPatternAnnotation(AnnotatedElement annotatedElement, int depth) {
        Pattern answer = annotatedElement.getAnnotation(Pattern.class);
        int nextDepth = depth - 1;
        if (nextDepth > 0) {
            // lets look at all the annotations to see if any of those are annotated
            Annotation[] annotations = annotatedElement.getAnnotations();
            for (Annotation annotation : annotations) {
                Class<? extends Annotation> annotationType = annotation.annotationType();
                if (annotation instanceof Pattern || annotationType.equals(annotatedElement)) {
                    continue;
                } else {
                    Pattern another = getPatternAnnotation(annotationType, nextDepth);
                    if (pattern != null) {
                        if (answer == null) {
                            answer = another;
                        } else {
                            LOG.warn(""Duplicate pattern annotation: "" + another + "" found on annotation: "" + annotation + "" which will be ignored"");
                        }
                    }
                }
            }
        }
        return answer;
    }
    /**
     * Adds the current class and all of its base classes (apart from {@link Object} to the given list
     * @param type
     * @param result
     */
    protected void addTypeAndSuperTypes(Class<?> type, List<Class<?>> result) {
        for (Class<?> t = type; t != null && t != Object.class; t = t.getSuperclass()) {
            result.add(t);
        }
    }
    /**
     * Finds the first annotation on the base methods defined in the list of classes
     */
    protected Pattern findOneWayAnnotationOnMethod(List<Class<?>> classes, Method method) {
        for (Class<?> type : classes) {
            try {
                Method definedMethod = type.getMethod(method.getName(), method.getParameterTypes());
                Pattern answer = getPatternAnnotation(definedMethod);
                if (answer != null) {
                    return answer;
                }
            } catch (NoSuchMethodException e) {
                // ignore
            }
        }
        return null;
    }
    /**
     * Finds the first annotation on the given list of classes
     */
    protected Pattern findOneWayAnnotation(List<Class<?>> classes) {
        for (Class<?> type : classes) {
            Pattern answer = getPatternAnnotation(type);
            if (answer != null) {
                return answer;
            }
        }
        return null;
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.interceptor.CheckFaultInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMInInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor();
    private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor();
    public DOMInInterceptor() {
        super(Phase.POST_PROTOCOL);
        this.addAfter(CheckFaultInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"",
                                                                   LOG, message.getClass().getName()));
        }
    }
}
"
org.apache.camel.builder.script.JavaScript,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of JavaScript expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""js"")
public @interface JavaScript {
    String value();
}"
org.apache.camel.converter.xmlbeans.XmlBeansConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.xmlbeans;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.NIOConverter;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.impl.piccolo.xml.XMLStreamReader;
/**
 * A <a href=""http://activemq.apache.org/camel/type-coverter.html"">Type Converter</a>
 * of XMLBeans objects
 *
 * @version $Revision$
 */
@Converter
public class XmlBeansConverter {
    private XmlConverter xmlConverter = new XmlConverter();
    @Converter
    public static XmlObject toXmlObject(File value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(Reader value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(Node value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(InputStream value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(String value, Exchange exchange) throws IOException, XmlException {
        return toXmlObject(IOConverter.toInputStream(value, exchange));
    }
    @Converter
    public static XmlObject toXmlObject(byte[] value) throws IOException, XmlException {
        return toXmlObject(IOConverter.toInputStream(value));
    }
    @Converter
    public static XmlObject toXmlObject(ByteBuffer value) throws IOException, XmlException {
        return toXmlObject(NIOConverter.toInputStream(value));
    }
    @Converter
    public static XmlObject toXmlObject(XMLStreamReader value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public XmlObject toXmlObject(Source value) throws IOException, XmlException, TransformerException, ParserConfigurationException, SAXException {
        Document document = getXmlConverter().toDOMDocument(value);
        return toXmlObject(document);
    }
    // Properties
    //-------------------------------------------------------------------------
    public XmlConverter getXmlConverter() {
        return xmlConverter;
    }
    public void setXmlConverter(XmlConverter xmlConverter) {
        this.xmlConverter = xmlConverter;
    }
}
"
org.apache.camel.component.quartz.CamelJob,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
/**
 * @version $Revision$
 */
public class CamelJob implements Job {
    public void execute(JobExecutionContext context) throws JobExecutionException {
        QuartzEndpoint component = (QuartzEndpoint) context.getJobDetail().getJobDataMap().get(QuartzEndpoint.ENDPOINT_KEY);
        if (component == null) {
            throw new JobExecutionException(""No quartz endpoint available for key: "" + QuartzEndpoint.ENDPOINT_KEY + "". Bad job data map"");
        }
        component.onJobExecute(context);
    }
}"
org.apache.camel.component.jms.requestor.PersistentReplyToFutureHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.jms.ExceptionListener;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.component.jms.requestor.PersistentReplyToRequestor.MessageSelectorComposer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.transaction.PlatformTransactionManager;
public class PersistentReplyToFutureHandler extends FutureHandler {
    private static final transient Log LOG = LogFactory.getLog(PersistentReplyToFutureHandler.class);
    protected PersistentReplyToRequestor requestor;
    protected DeferredMessageSentCallback callback;
    protected String correlationID;
    public PersistentReplyToFutureHandler(PersistentReplyToRequestor requestor,
                                          String correlationID) {
        super();
        this.requestor = requestor;
        this.correlationID = correlationID;
    }
    public PersistentReplyToFutureHandler(PersistentReplyToRequestor requestor,
                                          DeferredMessageSentCallback callback) {
        super();
        this.requestor = requestor;
        this.callback = callback;
    }
    @Override
    public Message get() throws InterruptedException, ExecutionException {
        Message result = null;
        try {
            updateSelector();
            result = super.get();
        } finally {
            revertSelector();
        }
        return result;
    }
    @Override
    public Message get(long timeout, TimeUnit unit) throws InterruptedException,
                                                           ExecutionException,
                                                           TimeoutException {
        Message result = null;
        try {
            updateSelector();
            result = super.get(timeout, unit);
        } finally {
            revertSelector();
        }
        return result;
    }
    protected void updateSelector() throws ExecutionException {
        try {
            MessageSelectorComposer composer = (MessageSelectorComposer)requestor.getListenerContainer();
            composer.addCorrelationID((correlationID != null) ? correlationID : callback.getMessage().getJMSMessageID());
        } catch (Exception e) {
            throw new ExecutionException(e);
        }
    }
    protected void revertSelector() throws ExecutionException {
        try {
            MessageSelectorComposer composer = (MessageSelectorComposer)requestor.getListenerContainer();
            composer.removeCorrelationID((correlationID != null) ? correlationID : callback.getMessage().getJMSMessageID());
        } catch (Exception e) {
            throw new ExecutionException(e);
        }
    }
}
"
org.apache.camel.component.atom.AtomComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * An <a href=""http://activemq.apache.org/camel/atom.html"">Atom Component</a>.
 * <p/>
 * Camel uses Apache Abdera as the Atom implementation. 
 *
 * @version $Revision$
 */
public class AtomComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new AtomEndpoint(uri, this, remaining);
    }
}
"
org.apache.camel.converter.jaxb.LongHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""longHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class LongHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Long number;
    public LongHeader() {
    }
    public LongHeader(String name, Long number) {
        super(name);
        this.number = number;
    }
    public Long getNumber() {
        return number;
    }
    public void setNumber(Long number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number)value;
            setNumber(n.longValue());
        } else {
            throw new IllegalArgumentException(""Value must be a Long"");
        }
    }
}"
org.apache.camel.component.http.HttpMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Map;
import javax.servlet.http.HttpServletRequest;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultMessage;
/**
 * @version $Revision$
 */
public class HttpMessage extends DefaultMessage {
    private HttpServletRequest request;
    public HttpMessage(HttpExchange exchange, HttpServletRequest request) {
        setExchange(exchange);
        this.request = request;
        // use binding to read the request allowing end users to use their
        // implementation of the binding
        getExchange().getEndpoint().getBinding().readRequest(request, this);
    }
    @Override
    public HttpExchange getExchange() {
        return (HttpExchange)super.getExchange();
    }
    public HttpServletRequest getRequest() {
        return request;
    }
    @Override
    protected Object createBody() {
        try {
            return getExchange().getEndpoint().getBinding().parseBody(this);
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        // populate the http request headers
        Enumeration names = request.getHeaderNames();
        while (names.hasMoreElements()) {
            String name = (String)names.nextElement();
            Object value = request.getHeader(name);
            map.put(name, value);
        }
        //if the request method is Get, we also populate the http request parameters
        if (request.getMethod().equalsIgnoreCase(""GET"")) {
            names = request.getParameterNames();
            while (names.hasMoreElements()) {
                String name = (String)names.nextElement();
                Object value = request.getParameter(name);
                map.put(name, value);
            }
        }
        // store the method and query as well
        map.put(HttpMethods.HTTP_METHOD, request.getMethod());
        map.put(HttpProducer.QUERY, request.getQueryString());
    }
}
"
org.apache.camel.builder.script.BeanShell,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of BeanShell expressions
 *  into method parameters, fields or properties
 *
 * @deprecated will be removed in Camel 2.0
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""beanshell"")
@Deprecated
public @interface BeanShell {
    String value();
}"
org.apache.camel.component.cxf.CxfSoapProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.OutputStream;
import java.lang.reflect.Proxy;
import javax.xml.transform.Source;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.component.cxf.util.Dummy;
import org.apache.camel.component.cxf.util.NullConduit;
import org.apache.camel.component.cxf.util.NullConduitSelector;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.Bus;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.frontend.ClientProxyFactoryBean;
import org.apache.cxf.interceptor.InterceptorChain;
import org.apache.cxf.interceptor.OutgoingChainInterceptor;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
/**
 * A CXF based soap provider.
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapProducer implements Producer, AsyncProcessor {
    private static final Log LOG = LogFactory.getLog(CxfSoapProducer.class);
    private final CxfSoapEndpoint endpoint;
    private final Producer producer;
    private final AsyncProcessor processor;
    private ClientImpl client;
    public CxfSoapProducer(CxfSoapEndpoint endpoint) throws Exception {
        this.endpoint = endpoint;
        this.producer = endpoint.getInnerEndpoint().createProducer();
        this.processor = new AsyncProcessorDecorator(producer,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderOut(exchange);
                    }
                });
        //create the endpoint and setup the interceptors
        Class sei = null; 
        if (ObjectHelper.isNotEmpty(endpoint.getServiceClass())) {
            sei = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
        }
        ClientProxyFactoryBean cfb = CxfEndpointUtils.getClientFactoryBean(sei);
        if (sei == null) {
            cfb.setServiceClass(Dummy.class);
        } else {
            cfb.setServiceClass(sei);
        }
        cfb.setWsdlURL(endpoint.getWsdl().getURL().toString());
        if (endpoint.getServiceName() != null) {
            cfb.setServiceName(endpoint.getServiceName());
        }
        if (endpoint.getEndpointName() != null) {
            cfb.setEndpointName(endpoint.getEndpointName());
        }
        cfb.setConduitSelector(new NullConduitSelector());
        client = (ClientImpl)((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();
    }
    public org.apache.camel.Endpoint getEndpoint() {
        return producer.getEndpoint();
    }
    public Exchange createExchange() {
        return producer.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return producer.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return producer.createExchange(exchange);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void start() throws Exception {
        producer.start();
    }
    public void stop() throws Exception {
        producer.stop();
    }
    protected void processSoapProviderOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderOut: "" + exchange);
        org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(
                endpoint.getHeaderFilterStrategy(), exchange, true);
        client.setInInterceptors(client.getEndpoint().getService().getInInterceptors());
        client.onMessage(inMessage);
        exchange.getOut().setBody(inMessage.getContent(Source.class));
        exchange.getOut().setHeaders(inMessage);
    }
    protected Bus getBus() {
        return endpoint.getBus();
    }
    protected void processSoapProviderIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderIn: "" + exchange);
        org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();
        org.apache.cxf.message.Exchange cxfExchange = new ExchangeImpl();
        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, cxfEndpoint);
        cxfExchange.put(Bus.class, getBus());
        cxfExchange.setConduit(new NullConduit());
        exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);
        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(
                endpoint.getHeaderFilterStrategy(), exchange, true);
        outMessage.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);
        outMessage.setInterceptorChain(chain);
        chain.doIntercept(outMessage);
        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
        exchange.getOut().setBody(outputStream.getInputStream());
        exchange.getIn().setBody(outputStream.getInputStream());
    }
}
"
org.apache.camel.component.mina.MinaConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.mina.common.ByteBuffer;
/**
 * A set of converter methods for working with MINA types
 *
 * @version $Revision$
 */
@Converter
public final class MinaConverter {
    private MinaConverter() {
        //Utility Class
    }
    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        byte[] answer = new byte[buffer.remaining()];
        try {
            // must acquire the Byte buffer to avoid release if more than twice
            buffer.acquire();
        } catch (IllegalStateException ex) {
            // catch the exception if we acquire the buffer which is already released.
        }
        buffer.get(answer);
        return answer;
    }
    @Converter
    public static String toString(ByteBuffer buffer, Exchange exchange) {
        return IOConverter.toString(toByteArray(buffer), exchange);
    }
    @Converter
    public static InputStream toInputStream(ByteBuffer buffer) {
        return buffer.asInputStream();
    }
    @Converter
    public static ObjectInput toObjectInput(ByteBuffer buffer) throws IOException {
        return IOConverter.toObjectInput(toInputStream(buffer));
    }
    @Converter
    public static ByteBuffer toByteBuffer(byte[] bytes) {
        ByteBuffer buf = ByteBuffer.allocate(bytes.length);
        buf.put(bytes);
        return buf;
    }
}
"
org.apache.camel.impl.SerializationDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
/**
 * The <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * using Java Serialiation.
 *
 * @version $Revision$
 */
public class SerializationDataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        ObjectOutput out = IOConverter.toObjectOutput(stream);
        try {
            out.writeObject(graph);
        } finally {
            out.flush();
            try {
                out.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        ObjectInput in = IOConverter.toObjectInput(stream);
        try {
            return in.readObject();
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}
"
org.apache.camel.component.jms.JmsConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.MessageListener;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A {@link Consumer} which uses Spring's {@link AbstractMessageListenerContainer} implementations to consume JMS messages
 *
 * @version $Revision$
 */
public class JmsConsumer extends DefaultConsumer<JmsExchange> {
    private final AbstractMessageListenerContainer listenerContainer;
    private EndpointMessageListener messageListener;
    public JmsConsumer(JmsEndpoint endpoint, Processor processor, AbstractMessageListenerContainer listenerContainer) {
        super(endpoint, processor);
        this.listenerContainer = listenerContainer;
        createMessageListener(endpoint, processor);
        this.listenerContainer.setMessageListener(messageListener);
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        return listenerContainer;
    }
    public EndpointMessageListener getEndpointMessageListener() {
        return messageListener;
    }
    protected void createMessageListener(JmsEndpoint endpoint, Processor processor) {
        messageListener = new EndpointMessageListener(endpoint, processor);
        messageListener.setBinding(endpoint.getBinding());
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        listenerContainer.afterPropertiesSet();
        listenerContainer.start();
    }
    @Override
    protected void doStop() throws Exception {
        listenerContainer.stop();
        listenerContainer.destroy();
        super.doStop();
    }
}
"
org.apache.camel.component.irc.IrcConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
public class IrcConsumer extends DefaultConsumer<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcConsumer.class);
    private final IrcConfiguration configuration;
    private final IrcEndpoint endpoint;
    private final IRCConnection connection;
    private FilteredIRCEventAdapter listener;
    public IrcConsumer(IrcEndpoint endpoint, Processor processor, IRCConnection connection) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.connection = connection;
        configuration = endpoint.getConfiguration();
    }
    @Override
    protected void doStop() throws Exception {
        String target = endpoint.getConfiguration().getTarget();
        connection.doPart(target);
        connection.removeIRCEventListener(listener);
        super.doStop();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        String target = endpoint.getConfiguration().getTarget();
        connection.addIRCEventListener(new FilteredIRCEventAdapter(target));
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    public IRCConnection getConnection() {
        return connection;
    }
    class FilteredIRCEventAdapter extends IRCEventAdapter {
        final String target;
        public FilteredIRCEventAdapter(String target) {
            this.target = target;
        }
        @Override
        public void onNick(IRCUser user, String newNick) {
            if (configuration.isOnNick()) {
                IrcExchange exchange = endpoint.createOnNickExchange(user, newNick);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onQuit(IRCUser user, String msg) {
            if (configuration.isOnQuit()) {
                IrcExchange exchange = endpoint.createOnQuitExchange(user, msg);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onJoin(String channel, IRCUser user) {
            if (configuration.isOnJoin()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnJoinExchange(channel, user);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onKick(String channel, IRCUser user, String passiveNick, String msg) {
            if (configuration.isOnKick()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnKickExchange(channel, user, passiveNick, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onMode(String channel, IRCUser user, IRCModeParser modeParser) {
            if (configuration.isOnMode()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnModeExchange(channel, user, modeParser);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPart(String channel, IRCUser user, String msg) {
            if (configuration.isOnPart()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPartExchange(channel, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onTopic(String channel, IRCUser user, String topic) {
            if (configuration.isOnTopic()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnTopicExchange(channel, user, topic);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPrivmsg(String target, IRCUser user, String msg) {
            if (configuration.isOnPrivmsg()) {
                if (target.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPrivmsgExchange(target, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
"
org.apache.camel.component.mina.TextLineDelimiter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
/**
 * Possible text line delmiters to be used with the textline codec.
 */
public enum TextLineDelimiter {
    DEFAULT, AUTO, UNIX, WINDOWS, MAC
}
"
org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent.jpa;
import java.util.List;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * @version $Revision$
 */
public class JpaMessageIdRepository implements MessageIdRepository {
    protected static final String QUERY_STRING = ""select x from "" + MessageProcessed.class.getName() + "" x where x.processorName = ?1 and x.messageId = ?2"";
    private JpaTemplate jpaTemplate;
    private String processorName;
    private TransactionTemplate transactionTemplate;
    public JpaMessageIdRepository(JpaTemplate template, String processorName) {
        this(template, createTransactionTemplate(template), processorName);
    }
    public JpaMessageIdRepository(JpaTemplate template, TransactionTemplate transactionTemplate, String processorName) {
        this.jpaTemplate = template;
        this.processorName = processorName;
        this.transactionTemplate = transactionTemplate;
    }
    public static JpaMessageIdRepository jpaMessageIdRepository(String persistenceUnit, String processorName) {
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnit);
        return jpaMessageIdRepository(new JpaTemplate(entityManagerFactory), processorName);
    }
    public static JpaMessageIdRepository jpaMessageIdRepository(JpaTemplate jpaTemplate, String processorName) {
        return new JpaMessageIdRepository(jpaTemplate, processorName);
    }
    private static TransactionTemplate createTransactionTemplate(JpaTemplate jpaTemplate) {
        TransactionTemplate transactionTemplate = new TransactionTemplate();
        transactionTemplate.setTransactionManager(new JpaTransactionManager(jpaTemplate.getEntityManagerFactory()));
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        return transactionTemplate;
    }
    public boolean contains(final String messageId) {
        // Run this in single transaction.
        Boolean rc = (Boolean)transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus arg0) {
                List list = jpaTemplate.find(QUERY_STRING, processorName, messageId);
                if (list.isEmpty()) {
                    MessageProcessed processed = new MessageProcessed();
                    processed.setProcessorName(processorName);
                    processed.setMessageId(messageId);
                    jpaTemplate.persist(processed);
                    jpaTemplate.flush();
                    return Boolean.FALSE;
                } else {
                    return Boolean.TRUE;
                }
            }
        });
        return rc.booleanValue();
    }
}
"
org.apache.camel.converter.jaxb.MessageType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlMixed;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Message;
/**
 * Represents a JAXB2 representation of a Camel {@link Message} - <b>Important</b>: work in progress!
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""message"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class MessageType {
    // TODO: XmlElementRef to the abstrac class HeaderType does not work (CAMEL-583)
    //@XmlElementRef(type = HeaderType.class)
    @XmlAnyElement(lax = true)
    @XmlMixed
    List<HeaderType> headers = new ArrayList<HeaderType>();
    @XmlAnyElement(lax = true)
    @XmlMixed
    private List content = new ArrayList();
    @XmlTransient
    private Object body;
    public Object getBody() {
        if (body == null) {
            if (content != null) {
                if (content.size() == 1) {
                    return content.get(0);
                } else {
                    return content;
                }
            }
        }
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
        if (body instanceof List) {
            content = (List)body;
        } else {
            content = new ArrayList();
            content.add(body);
        }
    }
    public List<HeaderType> getHeaders() {
        return headers;
    }
    public void setHeaders(List<HeaderType> headers) {
        this.headers = headers;
    }
    public Map<String, Object> getHeaderMap() {
        Map<String, Object> answer = new HashMap<String, Object>();
        for (HeaderType header : headers) {
            answer.put(header.getName(), header.getValue());
        }
        return answer;
    }
    /**
     * Copies the headers and body of this object from the given Camel message
     *
     * @param message the Camel message to read the headers and body from
     */
    public void copyFrom(Message message) {
        headers.clear();
        Set<Map.Entry<String, Object>> entries = message.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            Object value = entry.getValue();
            if (value != null) {
                headers.add(createHeader(entry.getKey(), value));
            }
        }
        setBody(message.getBody());
    }
    /**
     * Copies the headers and body of this object to the given Camel message
     *
     * @param message the camel message to overwrite its headers and body
     */
    public void copyTo(Message message) {
        message.setHeaders(getHeaderMap());
        message.setBody(getBody());
    }
    protected HeaderType createHeader(String key, Object value) {
        if (value instanceof String) {
            return new StringHeader(key, (String)value);
        } else if (value instanceof Integer) {
            return new IntegerHeader(key, (Integer)value);
        } else if (value instanceof Long) {
            return new LongHeader(key, (Long)value);
        } else {
            // lets convert to a String
            return new StringHeader(key, value.toString());
            //return new ObjectHeader(key, value);
        }
    }
}
"
org.apache.camel.impl.DefaultRouteContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.processor.Interceptor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ProceedProcessor;
import org.apache.camel.processor.UnitOfWorkProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * The context used to activate new routing rules
 *
 * @version $Revision$
 */
public class DefaultRouteContext implements RouteContext {
    private RouteType route;
    private FromType from;
    private Collection<Route> routes;
    private Endpoint<? extends Exchange> endpoint;
    private List<Processor> eventDrivenProcessors = new ArrayList<Processor>();
    private Interceptor lastInterceptor;
    private CamelContext camelContext;
    private List<InterceptStrategy> interceptStrategies = new ArrayList<InterceptStrategy>();
    private ErrorHandlerWrappingStrategy errorHandlerWrappingStrategy;
    private boolean routeAdded;
    public DefaultRouteContext(RouteType route, FromType from, Collection<Route> routes) {
        this.route = route;
        this.from = from;
        this.routes = routes;
    }
    /**
     * Only used for lazy construction from inside ExpressionType
     */
    public DefaultRouteContext(CamelContext camelContext) {
        this.camelContext = camelContext;
        routes = new ArrayList<Route>();
        route = new RouteType(""temporary"");
    }
    public Endpoint<? extends Exchange> getEndpoint() {
        if (endpoint == null) {
            endpoint = from.resolveEndpoint(this);
        }
        return endpoint;
    }
    public FromType getFrom() {
        return from;
    }
    public RouteType getRoute() {
        return route;
    }
    public CamelContext getCamelContext() {
        if (camelContext == null) {
            camelContext = getRoute().getCamelContext();
        }
        return camelContext;
    }
    public Processor createProcessor(ProcessorType node) throws Exception {
        return node.createOutputsProcessor(this);
    }
    public Endpoint<? extends Exchange> resolveEndpoint(String uri) {
        return route.resolveEndpoint(uri);
    }
    public Endpoint<? extends Exchange> resolveEndpoint(String uri, String ref) {
        Endpoint<? extends Exchange> endpoint = null;
        if (uri != null) {
            endpoint = resolveEndpoint(uri);
            if (endpoint == null) {
                throw new NoSuchEndpointException(uri);
            }
        }
        if (ref != null) {
            endpoint = lookup(ref, Endpoint.class);
            if (endpoint == null) {
                throw new NoSuchEndpointException(""ref:"" + ref);
            }
        }
        if (endpoint == null) {
            throw new IllegalArgumentException(""Either 'uri' or 'ref' must be specified on: "" + this);
        } else {
            return endpoint;
        }
    }
    public <T> T lookup(String name, Class<T> type) {
        return getCamelContext().getRegistry().lookup(name, type);
    }
    public void commit() {
        // now lets turn all of the event driven consumer processors into a
        // single route
        if (!eventDrivenProcessors.isEmpty()) {
            Processor processor = Pipeline.newInstance(eventDrivenProcessors);
            // lets create the async processor
            final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
            Processor unitOfWorkProcessor = new UnitOfWorkProcessor(asyncProcessor);
            // TODO: hz: move all this into the lifecycle strategy! (used by jmx naming strategy)
            Route edcr = new EventDrivenConsumerRoute(getEndpoint(), unitOfWorkProcessor);
            edcr.getProperties().put(Route.ID_PROPERTY, route.idOrCreate());
            edcr.getProperties().put(Route.PARENT_PROPERTY, Integer.toHexString(route.hashCode()));
            if (route.getGroup() != null) {
                edcr.getProperties().put(Route.GROUP_PROPERTY, route.getGroup());
            }
            routes.add(edcr);
        }
    }
    public void addEventDrivenProcessor(Processor processor) {
        eventDrivenProcessors.add(processor);
    }
    public void intercept(Intercept interceptor) {
/*
        InterceptorRef block = new InterceptorRef(interceptor);
        RouteType route = getRoute();
        List<ProcessorType<?>> list = route.getOutputs();
        for (ProcessorType<?> processorType : list) {
            block.addOutput(processorType);
        }
        route.clearOutput();
        route.intercept(block);
*/
        //getRoute().getInterceptors().add(new InterceptorRef(interceptor));
        lastInterceptor = (Interceptor)interceptor;
    }
    public Processor createProceedProcessor() {
        if (lastInterceptor == null) {
            throw new IllegalArgumentException(""Cannot proceed() from outside of an interceptor!"");
        } else {
            return new ProceedProcessor(lastInterceptor);
        }
    }
    public List<InterceptStrategy> getInterceptStrategies() {
        return interceptStrategies;
    }
    public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }
    public void addInterceptStrategy(InterceptStrategy interceptStrategy) {
        getInterceptStrategies().add(interceptStrategy);
    }
    public ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy() {
        return errorHandlerWrappingStrategy;
    }
    public void setErrorHandlerWrappingStrategy(ErrorHandlerWrappingStrategy strategy) {
        errorHandlerWrappingStrategy = strategy;
    }
    public boolean isRouteAdded() {
        return routeAdded;
    }
    public void setIsRouteAdded(boolean b) {
        routeAdded = b;
    }
    public DataFormatType getDataFormat(String ref) {
        Map<String, DataFormatType> dataFormats = getCamelContext().getDataFormats();
        if (dataFormats != null) {
            return dataFormats.get(ref);
        } else {
            return null;
        }
    }
}
"
org.apache.camel.language.juel.JuelLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 *
 * @version $Revision$
 */
public class JuelLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new JuelExpression(expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new JuelExpression(expression, Object.class);
    }
}
"
org.apache.camel.component.jcr.JcrConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.io.InputStream;
import java.util.Calendar;
import javax.jcr.Value;
import org.apache.camel.Converter;
import org.apache.jackrabbit.value.BinaryValue;
import org.apache.jackrabbit.value.BooleanValue;
import org.apache.jackrabbit.value.DateValue;
import org.apache.jackrabbit.value.StringValue;
/**
 * A helper class to transform Object into JCR {@link Value} implementations 
 */
@Converter
public class JcrConverter {
    /**
     * Converts a {@link Boolean} into a {@link Value}
     * @param bool the boolean
     * @return the value
     */
    @Converter
    public Value toValue(Boolean bool) {
        return new BooleanValue(bool);
    }
    /**
     * Converts an {@link InputStream} into a {@link Value}
     * @param stream the input stream
     * @return the value
     */
    @Converter
    public Value toValue(InputStream stream) {
        return new BinaryValue(stream);
    }
    /**
     * Converts a {@link Calendar} into a {@link Value}
     * @param calendar the calendar
     * @return the value
     */
    @Converter
    public Value toValue(Calendar calendar) {
        return new DateValue(calendar);
    }
    /**
     * Converts a {@link String} into a {@link Value}
     * @param value the string
     * @return the value
     */
    @Converter
    public Value toValue(String value) {
        return new StringValue(value);
    }
}
"
org.apache.camel.language.juel.JuelExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.util.Properties;
import javax.el.ArrayELResolver;
import javax.el.CompositeELResolver;
import javax.el.ELContext;
import javax.el.ELResolver;
import javax.el.ExpressionFactory;
import javax.el.ListELResolver;
import javax.el.MapELResolver;
import javax.el.ResourceBundleELResolver;
import javax.el.ValueExpression;
import de.odysseus.el.util.SimpleContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.ExpressionSupport;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 *
 * @version $Revision$
 */
public class JuelExpression extends ExpressionSupport<Exchange> {
    private final String expression;
    private final Class<?> type;
    private ExpressionFactory expressionFactory;
    private Properties expressionFactoryProperties;
    public JuelExpression(String expression, Class<?> type) {
        this.expression = expression;
        this.type = type;
    }
    public static JuelExpression el(String expression) {
        return new JuelExpression(expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible concurrency issues
        // so lets assume that the provider caches
        ELContext context = populateContext(createContext(), exchange);
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(context, expression, type);
        return valueExpression.getValue(context);
    }
    public ExpressionFactory getExpressionFactory() {
        if (expressionFactory == null) {
            Properties properties = getExpressionFactoryProperties();
            expressionFactory = ExpressionFactory.newInstance(properties);
        }
        return expressionFactory;
    }
    public void setExpressionFactory(ExpressionFactory expressionFactory) {
        this.expressionFactory = expressionFactory;
    }
    public Properties getExpressionFactoryProperties() {
        if (expressionFactoryProperties == null) {
            expressionFactoryProperties = new Properties();
            populateDefaultExpressionProperties(expressionFactoryProperties);
        }
        return expressionFactoryProperties;
    }
    public void setExpressionFactoryProperties(Properties expressionFactoryProperties) {
        this.expressionFactoryProperties = expressionFactoryProperties;
    }
    protected ELContext populateContext(ELContext context, Exchange exchange) {
        setVariable(context, ""exchange"", exchange, Exchange.class);
        setVariable(context, ""in"", exchange.getIn(), Message.class);
        Message out = exchange.getOut(false);
        setVariable(context, ""out"", out, Message.class);
        return context;
    }
    /**
     * A Strategy Method to populate the default properties used to create the expression factory
     */
    protected void populateDefaultExpressionProperties(Properties properties) {
        // lets enable method invocations
        properties.setProperty(""javax.el.methodInvocations"", ""true"");
    }
    protected void setVariable(ELContext context, String name, Object value, Class<?> type) {
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(value, type);
        SimpleContext simpleContext = (SimpleContext) context;
        simpleContext.setVariable(name, valueExpression);
    }
    /**
     * Factory method to create the EL context
     */
    protected ELContext createContext() {
        ELResolver resolver = new CompositeELResolver() {
            {
                //add(methodResolver);
                add(new ArrayELResolver(false));
                add(new ListELResolver(false));
                add(new MapELResolver(false));
                add(new ResourceBundleELResolver());
                add(new BeanAndMethodELResolver());
            }
        };
        return new SimpleContext(resolver);
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expression;
    }
}
"
org.apache.camel.component.file.strategy.RenameFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.IOException;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy to rename a file
 * 
 * @version $Revision$
 */
public class RenameFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(RenameFileProcessStrategy.class);
    private FileRenamer beginRenamer;
    private FileRenamer commitRenamer;
    public RenameFileProcessStrategy() {
        this(true);
    }
    public RenameFileProcessStrategy(boolean lock) {
        this(lock, "".camel/"", """");
    }
    public RenameFileProcessStrategy(boolean lock, String namePrefix, String namePostfix) {
        this(lock, new DefaultFileRenamer(namePrefix, namePostfix), null);
    }
    public RenameFileProcessStrategy(boolean lock, String namePrefix, String namePostfix, String preNamePrefix, String preNamePostfix) {
        this(lock, new DefaultFileRenamer(namePrefix, namePostfix), new DefaultFileRenamer(preNamePrefix, preNamePostfix));
    }
    public RenameFileProcessStrategy(boolean lock, FileRenamer commitRenamer, FileRenamer beginRenamer) {
        super(lock);
        this.commitRenamer = commitRenamer;
        this.beginRenamer = beginRenamer;
    }
    @Override
    public boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        boolean answer = super.begin(endpoint, exchange, file);
        if (beginRenamer != null) {
            File newName = beginRenamer.renameFile(exchange, file);
            // deleting any existing files before renaming
            File to = renameFile(file, newName);
            exchange.setFile(to);
        }
        return answer;
    }
    @Override
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        File newName = commitRenamer.renameFile(exchange, file);
        renameFile(file, newName);
        // must commit to release the lock
        super.commit(endpoint, exchange, file);
    }
    private static File renameFile(File from, File to) throws IOException {
        // deleting any existing files before renaming
        if (to.exists()) {
            to.delete();
        }
        // make parent folder if missing
        File parent = to.getParentFile();
        if (!parent.exists()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Creating directory: "" + parent);
            }
            boolean mkdir = parent.mkdirs();
            if (!mkdir) {
                throw new IOException(""Can not create directory: "" + parent);
            }
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Renaming file: "" + from + "" to: "" + to);
        }
        boolean renamed = from.renameTo(to);
        if (!renamed) {
            throw new IOException(""Can not rename file from: "" + from + "" to: "" + to);
        }
        return to;
    }
    public FileRenamer getBeginRenamer() {
        return beginRenamer;
    }
    public void setBeginRenamer(FileRenamer beginRenamer) {
        this.beginRenamer = beginRenamer;
    }
    public FileRenamer getCommitRenamer() {
        return commitRenamer;
    }
    public void setCommitRenamer(FileRenamer commitRenamer) {
        this.commitRenamer = commitRenamer;
    }
}"
org.apache.camel.component.dataset.DataSetSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.util.ExchangeHelper;
/**
 * Base class for DataSet
 *
 * @version $Revision$
 */
public abstract class DataSetSupport implements DataSet {
    private Map<String, Object> defaultHeaders;
    private Processor outputTransformer;
    private long size = 10;
    private long reportCount = -1;
    public DataSetSupport() {
    }
    public DataSetSupport(int size) {
        setSize(size);
    }
    public void populateMessage(Exchange exchange, long messageIndex) throws Exception {
        Message in = exchange.getIn();
        in.setBody(createMessageBody(messageIndex));
        in.setHeaders(getDefaultHeaders());
        applyHeaders(exchange, messageIndex);
        if (outputTransformer != null) {
            outputTransformer.process(exchange);
        }
    }
    public void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception {
        Object expectedBody = expected.getIn().getBody();
        Object actualBody = actual.getIn().getBody();
        if (expectedBody != null) {
            // lets coerce to the correct type
            actualBody = ExchangeHelper.getMandatoryInBody(actual, expectedBody.getClass());
        }
        DataSetEndpoint.assertEquals(""message body"", expectedBody, actualBody, actual);
    }
    // Properties
    //-------------------------------------------------------------------------
    public long getSize() {
        return size;
    }
    public void setSize(long size) {
        this.size = size;
    }
    public long getReportCount() {
        if (reportCount <= 0) {
            reportCount = getSize() / 5;
        }
        return reportCount;
    }
    /**
     * Sets the number of messages in a group on which we will report that messages have been received.
     */
    public void setReportCount(long reportCount) {
        this.reportCount = reportCount;
    }
    public Map<String, Object> getDefaultHeaders() {
        if (defaultHeaders == null) {
            defaultHeaders = new HashMap<String, Object>();
            populateDefaultHeaders(defaultHeaders);
        }
        return defaultHeaders;
    }
    public void setDefaultHeaders(Map<String, Object> defaultHeaders) {
        this.defaultHeaders = defaultHeaders;
    }
    public Processor getOutputTransformer() {
        return outputTransformer;
    }
    public void setOutputTransformer(Processor outputTransformer) {
        this.outputTransformer = outputTransformer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected abstract Object createMessageBody(long messageIndex);
    /**
     * Allows derived classes to add some custom headers for a given message
     */
    protected void applyHeaders(Exchange exchange, long messageIndex) {
    }
    /**
     * Allows derived classes to customize a default set of properties
     */
    protected void populateDefaultHeaders(Map<String, Object> map) {
    }
}"
org.apache.camel.component.seda.SedaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Consumer for the SEDA component.
 *
 * @version $Revision$
 */
public class SedaConsumer extends ServiceSupport implements Consumer, Runnable {
    private static final transient Log LOG = LogFactory.getLog(SedaConsumer.class);
    private SedaEndpoint endpoint;
    private AsyncProcessor processor;
    private Thread thread;
    public SedaConsumer(SedaEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = AsyncProcessorTypeConverter.convert(processor);
    }
    @Override
    public String toString() {
        return ""SedaConsumer: "" + endpoint.getEndpointUri();
    }
    public void run() {
        BlockingQueue<Exchange> queue = endpoint.getQueue();
        while (queue != null && isRunAllowed()) {
            final Exchange exchange;
            try {
                exchange = queue.poll(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Interupted: "" + e, e);
                }
                continue;
            }
            if (exchange != null) {
                if (isRunAllowed()) {
                    try {
                        processor.process(exchange, new AsyncCallback() {
                            public void done(boolean sync) {
                            }
                        });
                    } catch (Exception e) {
                        LOG.error(""Seda queue caught: "" + e, e);
                    }
                } else {
                    LOG.warn(""This consumer is stopped during polling an exchange, so putting it back on the seda queue: "" + exchange);
                    try {
                        queue.put(exchange);
                    } catch (InterruptedException e) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Interupted: "" + e, e);
                        }
                    }
                }
            }
        }
    }
    protected void doStart() throws Exception {
        thread = new Thread(this, getThreadName(endpoint.getEndpointUri()));
        thread.setDaemon(true);
        thread.start();
    }
    protected void doStop() throws Exception {
        thread.join();
        thread = null;
    }
}
"
org.apache.camel.component.jms.JmsProviderMetadata,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import javax.jms.TemporaryTopic;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A class which represents some metadata about the underlying JMS provider
 * so that we can properly bridge JMS providers such as for dealing with temporary destinations.
 *
 * @version $Revision$
 */
public class JmsProviderMetadata {
    private Class<? extends TemporaryQueue> temporaryQueueType;
    private Class<? extends TemporaryTopic> temporaryTopicType;
    /**
     * Lazily loads the temporary queue type if one has not been explicitly configured
     * via calling the {@link #setTemporaryQueueType(Class)}
     */
    public Class<? extends TemporaryQueue> getTemporaryQueueType(JmsOperations template) {
        Class<? extends TemporaryQueue> answer = getTemporaryQueueType();
        if (answer == null) {
            loadTemporaryDestinationTypes(template);
            answer = getTemporaryQueueType();
        }
        return answer;
    }
    /**
     * Lazily loads the temporary topic type if one has not been explicitly configured
     * via calling the {@link #setTemporaryTopicType(Class)}
     */
    public Class<? extends TemporaryTopic> getTemporaryTopicType(JmsOperations template) {
        Class<? extends TemporaryTopic> answer = getTemporaryTopicType();
        if (answer == null) {
            loadTemporaryDestinationTypes(template);
            answer = getTemporaryTopicType();
        }
        return answer;
    }
    // Properties
    //-------------------------------------------------------------------------
    public Class<? extends TemporaryQueue> getTemporaryQueueType() {
        return temporaryQueueType;
    }
    public void setTemporaryQueueType(Class<? extends TemporaryQueue> temporaryQueueType) {
        this.temporaryQueueType = temporaryQueueType;
    }
    public Class<? extends TemporaryTopic> getTemporaryTopicType() {
        return temporaryTopicType;
    }
    public void setTemporaryTopicType(Class<? extends TemporaryTopic> temporaryTopicType) {
        this.temporaryTopicType = temporaryTopicType;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void loadTemporaryDestinationTypes(JmsOperations template) {
        if (template == null) {
            throw new IllegalArgumentException(""No JmsTemplate supplied!"");
        }
        template.execute(new SessionCallback() {
            public Object doInJms(Session session) throws JMSException {
                TemporaryQueue queue = session.createTemporaryQueue();
                setTemporaryQueueType(queue.getClass());
                TemporaryTopic topic = session.createTemporaryTopic();
                setTemporaryTopicType(topic.getClass());
                queue.delete();
                topic.delete();
                return null;
            }
        });
    }
}
"
org.apache.camel.component.jms.requestor.DeferredRequestReplyMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.FutureTask;
import javax.jms.JMSException;
import javax.jms.Message;
import org.apache.camel.component.jms.JmsConfiguration.MessageSentCallback;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.util.TimeoutMap;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class DeferredRequestReplyMap  {
    private static final transient Log LOG = LogFactory.getLog(DeferredRequestReplyMap.class);
    private Requestor requestor;
    private JmsProducer producer;
    private TimeoutMap deferredRequestMap;
    private TimeoutMap deferredReplyMap;
    public static class DeferredMessageSentCallback implements MessageSentCallback {
        private DeferredRequestReplyMap map;
        private String transitionalID;
        private Message message;
        private Object monitor;
        public DeferredMessageSentCallback(DeferredRequestReplyMap map, UuidGenerator uuidGenerator, Object monitor) {
            transitionalID = uuidGenerator.generateId();
            this.map = map;
            this.monitor = monitor;
        }
        public DeferredRequestReplyMap getDeferredRequestReplyMap() {
            return map;
        }
        public String getID() {
            return transitionalID;
        }
        public Message getMessage() {
            return message;
        }
        public void sent(Message message) {
            this.message = message;
            map.processDeferredReplies(monitor, getID(), message);
        }
    }
    public DeferredRequestReplyMap(Requestor requestor,
                                   JmsProducer producer,
                                   TimeoutMap deferredRequestMap,
                                   TimeoutMap deferredReplyMap) {
        this.requestor = requestor;
        this.producer = producer;
        this.deferredRequestMap = deferredRequestMap;
        this.deferredReplyMap = deferredReplyMap;
    }
    public long getRequestTimeout() {
        return producer.getRequestTimeout();
    }
    public DeferredMessageSentCallback createDeferredMessageSentCallback() {
        return new DeferredMessageSentCallback(this, getUuidGenerator(), requestor);
    }
    public void put(DeferredMessageSentCallback callback, FutureTask futureTask) {
        deferredRequestMap.put(callback.getID(), futureTask, getRequestTimeout());
    }
    public void processDeferredRequests(String correlationID, Message inMessage) {
        processDeferredRequests(requestor, deferredRequestMap, deferredReplyMap,
                                correlationID, requestor.getMaxRequestTimeout(), inMessage);
    }
    public static void processDeferredRequests(Object monitor,
                                               TimeoutMap requestMap,
                                               TimeoutMap replyMap,
                                               String correlationID,
                                               long timeout,
                                               Message inMessage) {
        synchronized (monitor) {
            try {
                Object handler = requestMap.get(correlationID);
                if (handler == null) {
                    if (requestMap.size() > replyMap.size()) {
                        replyMap.put(correlationID, inMessage, timeout);
                    } else {
                        LOG.warn(""Response received for unknown correlationID: "" + correlationID + ""; response: "" + inMessage);
                    }
                }
                if (handler != null && handler instanceof ReplyHandler) {
                    ReplyHandler replyHandler = (ReplyHandler) handler;
                    boolean complete = replyHandler.handle(inMessage);
                    if (complete) {
                        requestMap.remove(correlationID);
                    }
                }
            } catch (JMSException e) {
                throw new FailedToProcessResponse(inMessage, e);
            }
        }
    }
    public void processDeferredReplies(Object monitor, String transitionalID, Message outMessage) {
        synchronized (monitor) {
            try {
                Object handler = deferredRequestMap.get(transitionalID);
                if (handler == null) {
                    return;
                }
                deferredRequestMap.remove(transitionalID);
                String correlationID = outMessage.getJMSMessageID();
                Object in = deferredReplyMap.get(correlationID);
                if (in != null && in instanceof Message) {
                    Message inMessage = (Message)in;
                    if (handler instanceof ReplyHandler) {
                        ReplyHandler replyHandler = (ReplyHandler)handler;
                        try {
                            boolean complete = replyHandler.handle(inMessage);
                            if (complete) {
                                deferredReplyMap.remove(correlationID);
                            }
                        } catch (JMSException e) {
                            throw new FailedToProcessResponse(inMessage, e);
                        }
                    }
                } else {
                    deferredRequestMap.put(correlationID, handler, getRequestTimeout());
                }
            } catch (JMSException e) {
                throw new FailedToProcessResponse(outMessage, e);
            }
        }
    }
    protected UuidGenerator getUuidGenerator() {
        return producer.getUuidGenerator();
    }
}
"
org.apache.camel.component.file.remote.RemoteFileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class RemoteFileExchange<T extends RemoteFileBinding> extends DefaultExchange {
    private T binding;
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding, String host, 
                              String fullFileName, String fileName, long fileLength, ByteArrayOutputStream outputStream) {
        this(context, pattern, binding);
        setIn(new RemoteFileMessage(host, fullFileName, fileName, fileLength, outputStream));
    }
    public T getBinding() {
        return binding;
    }
    public void setBinding(T binding) {
        this.binding = binding;
    }
}
"
org.apache.camel.component.uface.UFaceEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.component.list.ListEndpoint;
import org.apache.camel.util.ObjectHelper;
import org.eclipse.core.databinding.observable.Realm;
import org.eclipse.core.databinding.observable.list.WritableList;
/**
 * @version $Revision$
 */
public class UFaceEndpoint extends ListEndpoint {
    public UFaceEndpoint(String uri, UFaceComponent component) {
        super(uri, component);
    }
    public UFaceEndpoint(String endpointUri) {
        super(endpointUri);
    }
    @Override
    protected List<Exchange> createExchangeList() {
        Realm realm = Realm.getDefault();
        ObjectHelper.notNull(realm, ""DataBinding Realm"");
        return new WritableList(realm);
    }
}
"
org.apache.camel.component.mina.MinaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ByteBuffer;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoServiceConfig;
import org.apache.mina.common.IoSession;
import org.apache.mina.filter.LoggingFilter;
import org.apache.mina.filter.codec.ProtocolCodecFactory;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.ProtocolEncoderOutput;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.filter.codec.textline.LineDelimiter;
import org.apache.mina.transport.socket.nio.DatagramAcceptor;
import org.apache.mina.transport.socket.nio.DatagramAcceptorConfig;
import org.apache.mina.transport.socket.nio.DatagramConnector;
import org.apache.mina.transport.socket.nio.DatagramConnectorConfig;
import org.apache.mina.transport.socket.nio.SocketAcceptor;
import org.apache.mina.transport.socket.nio.SocketAcceptorConfig;
import org.apache.mina.transport.socket.nio.SocketConnector;
import org.apache.mina.transport.socket.nio.SocketConnectorConfig;
import org.apache.mina.transport.vmpipe.VmPipeAcceptor;
import org.apache.mina.transport.vmpipe.VmPipeAddress;
import org.apache.mina.transport.vmpipe.VmPipeConnector;
/**
 * Component for Apache MINA.
 *
 * @version $Revision$
 */
public class MinaComponent extends DefaultComponent<MinaExchange> {
    private static final transient Log LOG = LogFactory.getLog(MinaComponent.class);
    private static final long DEFAULT_CONNECT_TIMEOUT = 30000;
    private boolean sync = true;
    private boolean textline;
    private TextLineDelimiter textlineDelimiter;
    private String codec;
    private String encoding;
    private long timeout;
    private boolean lazySessionCreation;
    private boolean transferExchange;
    private boolean minaLogger;
    // encoder used for datagram
    private CharsetEncoder encoder;
    public MinaComponent() {
    }
    public MinaComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<MinaExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating MinaEndpoint from uri: "" + uri);
        }
        setProperties(this, parameters);
        URI u = new URI(remaining);
        String protocol = u.getScheme();
        // if mistyped uri then protocol can be null
        if (protocol != null) {
            if (protocol.equals(""tcp"")) {
                return createSocketEndpoint(uri, u, parameters);
            } else if (protocol.equals(""udp"") || protocol.equals(""mcast"") || protocol.equals(""multicast"")) {
                return createDatagramEndpoint(uri, u, parameters);
            } else if (protocol.equals(""vm"")) {
                return createVmEndpoint(uri, u);
            }
        }
        // protocol not resolved so error
        throw new IllegalArgumentException(""Unrecognised MINA protocol: "" + protocol + "" for uri: "" + uri);
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected MinaEndpoint createVmEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new VmPipeAcceptor();
        SocketAddress address = new VmPipeAddress(connectUri.getPort());
        IoConnector connector = new VmPipeConnector();
        // connector config
        configureCodecFactory(""MinaProducer"", connector.getDefaultConfig(), textline, encoding, codec);
        if (minaLogger) {
            connector.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        // acceptor connectorConfig
        configureCodecFactory(""MinaConsumer"", acceptor.getDefaultConfig(), textline, encoding, codec);
        if (minaLogger) {
            acceptor.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        MinaEndpoint endpoint = new MinaEndpoint(uri, this, address, acceptor, null, connector, null, false, timeout, transferExchange, sync);
        if (encoding != null) {
            endpoint.setCharsetName(getEncodingParameter(""MinaProducer"", encoding).name());
        }
        // set sync or async mode after endpoint is created
        if (sync) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
        return endpoint;
    }
    protected MinaEndpoint createSocketEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new SocketAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new SocketConnector();
        // connector config
        SocketConnectorConfig connectorConfig = new SocketConnectorConfig();
        configureCodecFactory(""MinaProducer"", connectorConfig, textline, encoding, codec);
        if (minaLogger) {
            connectorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        // set connect timeout to mina in seconds
        long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT;
        connectorConfig.setConnectTimeout((int)(connectTimeout / 1000));
        // acceptor connectorConfig
        SocketAcceptorConfig acceptorConfig = new SocketAcceptorConfig();
        configureCodecFactory(""MinaConsumer"", acceptorConfig, textline, encoding, codec);
        acceptorConfig.setReuseAddress(true);
        acceptorConfig.setDisconnectOnUnbind(true);
        if (minaLogger) {
            acceptorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        MinaEndpoint endpoint = new MinaEndpoint(uri, this, address, acceptor, acceptorConfig, connector, connectorConfig, lazySessionCreation, timeout, transferExchange, sync);
        if (encoding != null) {
            endpoint.setCharsetName(getEncodingParameter(""MinaProducer"", encoding).name());
        }
        // set sync or async mode after endpoint is created
        if (sync) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
        return endpoint;
    }
    protected void configureCodecFactory(String type, IoServiceConfig config, boolean textline, String encoding, String codec) {
        ProtocolCodecFactory codecFactory = getCodecFactory(type, codec);
        if (codecFactory == null) {
            if (textline) {
                Charset charset = getEncodingParameter(type, encoding);
                LineDelimiter delimiter = getLineDelimiterParameter();
                codecFactory = new TextLineCodecFactory(charset, delimiter);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(type + "": Using TextLineCodecFactory: "" + codecFactory + "" using encoding: ""
                              + charset + "" and line delimiter: "" + textlineDelimiter + ""("" + delimiter + "")"");
                }
            } else {
                codecFactory = new ObjectSerializationCodecFactory();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(type + "": Using ObjectSerializationCodecFactory: "" + codecFactory);
                }
            }
        }
        addCodecFactory(config, codecFactory);
    }
    protected MinaEndpoint createDatagramEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new DatagramAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new DatagramConnector();
        if (transferExchange) {
            throw new IllegalArgumentException(""transferExchange=true is not supported for datagram protocol"");
        }
        DatagramConnectorConfig connectorConfig = new DatagramConnectorConfig();
        configureDataGramCodecFactory(""MinaProducer"", connectorConfig, encoding, codec);
        if (minaLogger) {
            connectorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        // set connect timeout to mina in seconds
        long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT;
        connectorConfig.setConnectTimeout((int)(connectTimeout / 1000));
        DatagramAcceptorConfig acceptorConfig = new DatagramAcceptorConfig();
        configureDataGramCodecFactory(""MinaConsumer"", acceptorConfig, encoding, codec);
        acceptorConfig.setDisconnectOnUnbind(true);
        // reuse address is default true for datagram
        if (minaLogger) {
            acceptorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        MinaEndpoint endpoint = new MinaEndpoint(uri, this, address, acceptor, acceptorConfig, connector, connectorConfig, lazySessionCreation, timeout, transferExchange, sync);
        if (encoding != null) {
            endpoint.setCharsetName(getEncodingParameter(""MinaProducer"", encoding).name());
        }
        // set sync or async mode after endpoint is created
        if (sync) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
        return endpoint;
    }
    private static Charset getEncodingParameter(String type, String encoding) {
        if (encoding == null) {
            encoding = Charset.defaultCharset().name();
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": No encoding parameter using default charset: "" + encoding);
            }
        }
        if (!Charset.isSupported(encoding)) {
            throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported"");
        }
        return Charset.forName(encoding);
    }
    /**
     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default
     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified
     */
    protected void configureDataGramCodecFactory(String type, IoServiceConfig config, String encoding, String codec) {
        ProtocolCodecFactory codecFactory = getCodecFactory(type, codec);
        if (codecFactory == null) {
            codecFactory = new ProtocolCodecFactory() {
                public ProtocolEncoder getEncoder() throws Exception {
                    return new ProtocolEncoder() {
                        public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception {
                            ByteBuffer buf = toByteBuffer(message);
                            buf.flip();
                            out.write(buf);
                        }
                        public void dispose(IoSession session) throws Exception {
                            // do nothing
                        }
                    };
                }
                public ProtocolDecoder getDecoder() throws Exception {
                    return new ProtocolDecoder() {
                        public void decode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception {
                            // must acquire the bytebuffer since we just pass it below instead of creating a new one (CAMEL-257)
                            in.acquire();
                            // lets just pass the ByteBuffer in
                            out.write(in);
                        }
                        public void finishDecode(IoSession session, ProtocolDecoderOutput out) throws Exception {
                            // do nothing
                        }
                        public void dispose(IoSession session) throws Exception {
                            // do nothing
                        }
                    };
                }
            };
            // set the encoder used for this datagram codec factory
            Charset charset = getEncodingParameter(type, encoding);
            encoder = charset.newEncoder();
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": Using CodecFactory: "" + codecFactory + "" using encoding: "" + charset);
            }
        }
        addCodecFactory(config, codecFactory);
    }
    protected ByteBuffer toByteBuffer(Object message) throws CharacterCodingException {
        ByteBuffer answer = null;
        try {
            answer = convertTo(ByteBuffer.class, message);
        } catch (NoTypeConversionAvailableException e) {
            String value = convertTo(String.class, message);
            answer = ByteBuffer.allocate(value.length()).setAutoExpand(true);
            answer.putString(value, encoder);
        }
        return answer;
    }
    protected ProtocolCodecFactory getCodecFactory(String type, String codec) {
        ProtocolCodecFactory codecFactory = null;
        if (codec != null) {
            codecFactory = getCamelContext().getRegistry().lookup(codec, ProtocolCodecFactory.class);
            if (codecFactory == null) {
                throw new IllegalArgumentException(""Codec "" + codec + "" not found in registry."");
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": Using custom CodecFactory: "" + codecFactory);
            }
        }
        return codecFactory;
    }
    protected void addCodecFactory(IoServiceConfig config, ProtocolCodecFactory codecFactory) {
        config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(codecFactory));
    }
    private LineDelimiter getLineDelimiterParameter() {
        if (textlineDelimiter == null) {
            return LineDelimiter.DEFAULT;
        }
        switch (textlineDelimiter) {
        case DEFAULT:
            return LineDelimiter.DEFAULT;
        case AUTO:
            return LineDelimiter.AUTO;
        case UNIX:
            return LineDelimiter.UNIX;
        case WINDOWS:
            return LineDelimiter.WINDOWS;
        case MAC:
            return LineDelimiter.MAC;
        default:
            throw new IllegalArgumentException(""Unknown textline delimiter: "" + textlineDelimiter);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public boolean isSync() {
        return sync;
    }
    public void setSync(boolean sync) {
        this.sync = sync;
    }
    public boolean isTextline() {
        return textline;
    }
    public void setTextline(boolean textline) {
        this.textline = textline;
    }
    public TextLineDelimiter getTextlineDelimiter() {
        return textlineDelimiter;
    }
    public void setTextlineDelimiter(TextLineDelimiter textlineDelimiter) {
        this.textlineDelimiter = textlineDelimiter;
    }
    public String getCodec() {
        return codec;
    }
    public void setCodec(String codec) {
        this.codec = codec;
    }
    public String getEncoding() {
        return encoding;
    }
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public boolean isLazySessionCreation() {
        return lazySessionCreation;
    }
    public void setLazySessionCreation(boolean lazySessionCreation) {
        this.lazySessionCreation = lazySessionCreation;
    }
    public boolean isTransferExchange() {
        return transferExchange;
    }
    public void setTransferExchange(boolean transferExchange) {
        this.transferExchange = transferExchange;
    }
    public boolean isMinaLogger() {
        return minaLogger;
    }
    public void setMinaLogger(boolean minaLogger) {
        this.minaLogger = minaLogger;
    }
}
"
org.apache.camel.impl.EventDrivenPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A default implementation of the {@link PollingConsumer} which uses the normal
 * asynchronous consumer mechanism along with a {@link BlockingQueue} to allow
 * the caller to pull messages on demand.
 *
 * @version $Revision$
 */
public class EventDrivenPollingConsumer<E extends Exchange> extends PollingConsumerSupport<E> implements Processor {
    private static final transient Log LOG = LogFactory.getLog(EventDrivenPollingConsumer.class);
    private BlockingQueue<E> queue;
    private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler(new Logger(LOG));
    private Consumer<E> consumer;
    public EventDrivenPollingConsumer(Endpoint<E> endpoint) {
        this(endpoint, new ArrayBlockingQueue<E>(1000));
    }
    public EventDrivenPollingConsumer(Endpoint<E> endpoint, BlockingQueue<E> queue) {
        super(endpoint);
        this.queue = queue;
    }
    public E receiveNoWait() {
        return receive(0);
    }
    public E receive() {
        while (isRunAllowed()) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                handleInteruptedException(e);
            }
        }
        LOG.debug(""Consumer is not running, so returning null"");
        return null;
    }
    public E receive(long timeout) {
        try {
            return queue.poll(timeout, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            handleInteruptedException(e);
            return null;
        }
    }
    public void process(Exchange exchange) throws Exception {
        queue.offer((E)exchange);
    }
    public ExceptionHandler getInteruptedExceptionHandler() {
        return interuptedExceptionHandler;
    }
    public void setInteruptedExceptionHandler(ExceptionHandler interuptedExceptionHandler) {
        this.interuptedExceptionHandler = interuptedExceptionHandler;
    }
    protected void handleInteruptedException(InterruptedException e) {
        getInteruptedExceptionHandler().handleException(e);
    }
    protected void doStart() throws Exception {
        // lets add ourselves as a consumer
        consumer = getEndpoint().createConsumer(this);
        consumer.start();
    }
    protected void doStop() throws Exception {
        if (consumer != null) {
            try {
                consumer.stop();
            } finally {
                consumer = null;
            }
        }
    }
}
"
org.apache.camel.builder.ErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.List;
import org.apache.camel.Processor;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.spi.RouteContext;
/**
 * A builder of a <a href=""http://activemq.apache.org/camel/error-handler.html"">Error Handler</a>
 *
 * @version $Revision$
 */
public interface ErrorHandlerBuilder {
    /**
     * Creates a copy of this builder
     */
    ErrorHandlerBuilder copy();
    /**
     * Creates the error handler interceptor
     */
    Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception;
    /**
     * Adds error handler for the given exception type
     * @param exception  the exception to handle
     */
    void addErrorHandlers(ExceptionType exception);
    /**
     * Adds the error handlers for the given list of exception types
     * @param exceptions  the list of exceptions to handle
     */
    void setErrorHandlers(List<ExceptionType> exceptions);
}
"
org.apache.camel.bam.ActivityBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.builder.ProcessorFactory;
import org.apache.camel.impl.EventDrivenConsumerRoute;
/**
 * @version $Revision$
 */
public class ActivityBuilder implements ProcessorFactory {
    private ProcessBuilder processBuilder;
    private Endpoint endpoint;
    private ActivityRules activityRules;
    private Expression correlationExpression;
    public ActivityBuilder(ProcessBuilder processBuilder, Endpoint endpoint) {
        this.processBuilder = processBuilder;
        this.endpoint = endpoint;
        this.activityRules = new ActivityRules(processBuilder);
        this.activityRules.setActivityName(endpoint.getEndpointUri());
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor createProcessor() throws Exception {
        return processBuilder.createActivityProcessor(this);
    }
    public Route createRoute() throws Exception {
        Processor processor = createProcessor();
        if (processor == null) {
            throw new IllegalArgumentException(""No processor created for ActivityBuilder: "" + this);
        }
        return new EventDrivenConsumerRoute(getEndpoint(), processor);
    }
    // Builder methods
    //-----------------------------------------------------------------------
    public ActivityBuilder correlate(Expression correlationExpression) {
        this.correlationExpression = correlationExpression;
        return this;
    }
    public ActivityBuilder name(String name) {
        activityRules.setActivityName(name);
        return this;
    }
    /**
     * Create a temporal rule for when this step starts
     */
    public TimeExpression starts() {
        return new TimeExpression(this, ActivityLifecycle.Started) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeStarted();
            }
        };
    }
    /**
     * Create a temporal rule for when this step completes
     */
    public TimeExpression completes() {
        return new TimeExpression(this, ActivityLifecycle.Completed) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeCompleted();
            }
        };
    }
    // Properties
    //-----------------------------------------------------------------------
    public Expression getCorrelationExpression() {
        return correlationExpression;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ProcessBuilder getProcessBuilder() {
        return processBuilder;
    }
}
"
org.apache.camel.component.seda.ListPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.PollingConsumerSupport;
/**
 * @deprecated not used. Will be removed in Camel 2.0.
 * @version $Revision$
 */
@Deprecated
public class ListPollingConsumer extends PollingConsumerSupport {
    private final List<Exchange> exchanges;
    public ListPollingConsumer(Endpoint endpoint, List<Exchange> exchanges) {
        super(endpoint);
        this.exchanges = exchanges;
    }
    public Exchange receive() {
        return receiveNoWait();
    }
    public Exchange receiveNoWait() {
        if (exchanges.isEmpty()) {
            return null;
        } else {
            return exchanges.remove(0);
        }
    }
    public Exchange receive(long timeout) {
        return receiveNoWait();
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.irc.IrcExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class IrcExchange extends DefaultExchange {
    private IrcBinding binding;
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding, IrcMessage inMessage) {
        this(context, pattern, binding);
        setIn(inMessage);
    }
    public IrcExchange(DefaultExchange parent, IrcBinding binding) {
        super(parent);
        this.binding = binding;
    }
    public IrcBinding getBinding() {
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    @Override
    public IrcMessage getIn() {
        return (IrcMessage) super.getIn();
    }
    @Override
    public IrcMessage getOut() {
        return (IrcMessage) super.getOut();
    }
    @Override
    public IrcMessage getOut(boolean lazyCreate) {
        return (IrcMessage) super.getOut(lazyCreate);
    }
    @Override
    public IrcMessage getFault() {
        return (IrcMessage) super.getFault();
    }
    @Override
    public IrcExchange newInstance() {
        return new IrcExchange(this, getBinding());
    }
    @Override
    protected IrcMessage createInMessage() {
        return new IrcMessage();
    }
    @Override
    protected IrcMessage createOutMessage() {
        return new IrcMessage();
    }
}
"
org.apache.camel.impl.DelegateLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * A helper class for folks writing delegate listener strategies
 *
 * @version $Revision$
 */
public class DelegateLifecycleStrategy implements LifecycleStrategy {
    private final LifecycleStrategy delegate;
    public DelegateLifecycleStrategy(LifecycleStrategy delegate) {
        this.delegate = delegate;
    }
    public void onContextStart(CamelContext context) {
        delegate.onContextStart(context);
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        delegate.onEndpointAdd(endpoint);
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        delegate.onRouteContextCreate(routeContext);
    }
    public void onRoutesAdd(Collection<Route> routes) {
        delegate.onRoutesAdd(routes);
    }
    public void onServiceAdd(CamelContext context, Service service) {
        delegate.onServiceAdd(context, service);
    }
}
"
org.apache.camel.language.jxpath.JXPath,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation used to inject a <a href=""http://commons.apache.org/jxpath/"">JXPath</a>
 * expression into a method parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""jxpath"")
public @interface JXPath {
    String value();
}"
org.apache.camel.spring.util.ReflectionUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
/**
 * Reflection utilities, extending Spring ReflectionUtils.
 */
public class ReflectionUtils extends org.springframework.util.ReflectionUtils {
    public static <T extends Annotation> void callLifecycleMethod(final Object bean, final Class<T> annotation) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                if (method.getAnnotation(annotation) != null) {
                    try {
                        method.invoke(bean, (Object[])null);
                    } catch (IllegalArgumentException ex) {
                        throw new IllegalStateException(""Failure to invoke "" + method + "" on "" + bean.getClass() + "": args=[]"", ex);
                    } catch (IllegalAccessException ex) {
                        throw new UnsupportedOperationException(ex.toString());
                    } catch (InvocationTargetException ex) {
                        throw new UnsupportedOperationException(""PostConstruct method on bean threw exception"", ex.getTargetException());
                    }
                }
            }
        });
    }
    public static void setField(Field f, Object instance, Object value) {
        try {
            boolean oldAccessible = f.isAccessible();
            boolean shouldSetAccessible = !Modifier.isPublic(f.getModifiers()) && !oldAccessible;
            if (shouldSetAccessible) {
                f.setAccessible(true);
            }
            f.set(instance, value);
            if (shouldSetAccessible) {
                f.setAccessible(oldAccessible);
            }
        } catch (IllegalArgumentException ex) {
            throw new UnsupportedOperationException(""Cannot inject value of class '"" + value.getClass() + ""' into "" + f);
        } catch (IllegalAccessException ex) {
            ReflectionUtils.handleReflectionException(ex);
        }
    }
}
"
org.apache.camel.Predicate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Evaluates a binary <a
 * href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> on the
 * message exchange to support things like <a
 * href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting
 * languages</a>, <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well as
 * any arbitrary Java expression.
 * 
 * @version $Revision$
 */
public interface Predicate<E> {
    /**
     * Evaluates the predicate on the message exchange and returns true if this
     * exchange matches the predicate
     * 
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(E exchange);
    /**
     * Allows this predicate to be used nicely in testing to generate a nicely
     * formatted exception and message if this predicate does not match for the
     * given exchange.
     * 
     * @param text the description to use in the exception message
     * @param exchange the exchange to evaluate the expression on
     * @throws AssertionError if the predicate does not match
     */
    void assertMatches(String text, E exchange) throws AssertionError;
}
"
org.apache.camel.impl.LoggingExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.LogFactory;
/**
 * A default implementation of {@link ExceptionHandler} which uses a {@link Logger} to
 * log to an arbitrary {@link org.apache.commons.logging.Log Log} with some {@link LoggingLevel}
 *
 * @version $Revision$
 */
public class LoggingExceptionHandler implements ExceptionHandler {
    private final Logger logger;
    public LoggingExceptionHandler(Class ownerType) {
        this(new Logger(LogFactory.getLog(ownerType), LoggingLevel.ERROR));
    }
    public LoggingExceptionHandler(Logger logger) {
        this.logger = logger;
    }
    public void handleException(Throwable exception) {
        logger.log(exception.getMessage(), exception);
    }
}
"
org.apache.camel.language.ognl.OGNL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://www.ognl.org/"">OGNL</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""ognl"")
public @interface OGNL {
    String value();
}"
org.apache.camel.processor.idempotent.jpa.MessageProcessed,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent.jpa;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
/**
 * @version $Revision$
 */
@Entity
@Table(
    name = ""MESSAGEPROCESSED"",
    uniqueConstraints = @UniqueConstraint(columnNames = {""processorName"", ""messageId""})
)
public class MessageProcessed {
    private Long id;
    private String messageId;
    private String processorName;
    @Override
    public String toString() {
        return ""MessageProcessed[processorName: "" + getProcessorName() + "" messageId: "" + getMessageId() + ""]"";
    }
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getMessageId() {
        return messageId;
    }
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
    public String getProcessorName() {
        return processorName;
    }
    public void setProcessorName(String processorName) {
        this.processorName = processorName;
    }
}
"
org.apache.camel.builder.ErrorHandlerBuilderRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.List;
import org.apache.camel.Processor;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents a proxy to an error handler builder which is resolved by named reference
 *
 * @version $Revision$
 */
public class ErrorHandlerBuilderRef extends ErrorHandlerBuilderSupport {
    private final String ref;
    private ErrorHandlerBuilder handler;
    public ErrorHandlerBuilderRef(String ref) {
        this.ref = ref;
    }
    public ErrorHandlerBuilder copy() {
        return new ErrorHandlerBuilderRef(ref);
    }
    @Override
    public void addErrorHandlers(ExceptionType exception) {
        if (handler != null) {
            handler.addErrorHandlers(exception);
        }
        super.addErrorHandlers(exception);
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        if (handler == null) {
            handler = routeContext.lookup(ref, ErrorHandlerBuilder.class);
            ObjectHelper.notNull(handler, ""error handler '"" + ref + ""'"");
            List<ExceptionType> list = getExceptions();
            for (ExceptionType exceptionType : list) {
                handler.addErrorHandlers(exceptionType);
            }
        }
        return handler.createErrorHandler(routeContext, processor);
    }
}
"
org.apache.camel.spring.spi.TransactionErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.ErrorHandlerBuilderSupport;
import org.apache.camel.processor.DelayPolicy;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * An error handler which will roll the exception back if there is an error
 * rather than using the dead letter channel and retry logic.
 *
 * A delay is also used after a rollback
 *
 * @version $Revision$
 */
public class TransactionErrorHandlerBuilder extends ErrorHandlerBuilderSupport implements Cloneable, InitializingBean {
    private TransactionTemplate transactionTemplate;
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    private DelayPolicy delayPolicy = new DelayPolicy();
    public TransactionErrorHandlerBuilder() {
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    /**
     * @deprecated use setDelayPolicy. Will be removed in Camel 2.0
     */
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * @deprecated use setDelayPolicy. Will be removed in Camel 2.0
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public DelayPolicy getDelayPolicy() {
        return delayPolicy;
    }
    public void setDelayPolicy(DelayPolicy delayPolicy) {
        this.delayPolicy = delayPolicy;
    }
    public ErrorHandlerBuilder copy() {
        try {
            return (ErrorHandlerBuilder) clone();
        } catch (CloneNotSupportedException e) {
            throw new Error(""Clone should be supported: "" + e, e);
        }
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        return new TransactionInterceptor(processor, transactionTemplate, delayPolicy);
    }
    public void afterPropertiesSet() throws Exception {
        ObjectHelper.notNull(transactionTemplate, ""transactionTemplate"");
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    /**
     * @deprecated use delay - will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getDelayPolicy().delay(initialRedeliveryDelay);
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        getRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public TransactionErrorHandlerBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    public TransactionErrorHandlerBuilder delay(long delay) {
        getDelayPolicy().delay(delay);
        return this;
    }
}
"
org.apache.camel.builder.BuilderSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for implementation inheritance for different clauses in the <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision$
 */
public abstract class BuilderSupport {
    private CamelContext context;
    private ErrorHandlerBuilder errorHandlerBuilder;
    private boolean inheritErrorHandler = true;
    protected BuilderSupport(CamelContext context) {
        this.context = context;
    }
    protected BuilderSupport(BuilderSupport parent) {
        this.context = parent.getContext();
        this.inheritErrorHandler = parent.inheritErrorHandler;
        if (inheritErrorHandler && parent.errorHandlerBuilder != null) {
            this.errorHandlerBuilder = parent.errorHandlerBuilder.copy();
        }
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Returns a value builder for the given header
     */
    public ValueBuilder header(String name) {
        return Builder.header(name);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public ValueBuilder body() {
        return Builder.body();
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> ValueBuilder body(Class<T> type) {
        return Builder.bodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public ValueBuilder outBody() {
        return Builder.outBody();
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> ValueBuilder outBody(Class<T> type) {
        return Builder.outBodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public ValueBuilder faultBody() {
        return Builder.faultBody();
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public <T> ValueBuilder faultBodyAs(Class<T> type) {
        return Builder.faultBodyAs(type);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name) {
        return Builder.systemProperty(name);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name, String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }
    /**
     * Returns a constant expression value builder
     */
    public ValueBuilder constant(Object value) {
        return Builder.constant(value);
    }
    /**
     * Resolves the given URI to an endpoint
     *
     * @throws NoSuchEndpointException if the endpoint URI could not be resolved
     */
    public Endpoint endpoint(String uri) throws NoSuchEndpointException {
        ObjectHelper.notNull(uri, ""uri"");
        Endpoint endpoint = getContext().getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
    /**
     * Resolves the given URI to an endpoint of the specified type
     *
     * @throws NoSuchEndpointException if the endpoint URI could not be resolved
     */
    public <T extends Endpoint> T endpoint(String uri, Class<T> type) throws NoSuchEndpointException {
        ObjectHelper.notNull(uri, ""uri"");
        T endpoint = getContext().getEndpoint(uri, type);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
    /**
     * Resolves the list of URIs into a list of {@link Endpoint} instances
     *
     * @throws NoSuchEndpointException if an endpoint URI could not be resolved
     */
    public List<Endpoint> endpoints(String... uris) throws NoSuchEndpointException {
        List<Endpoint> endpoints = new ArrayList<Endpoint>();
        for (String uri : uris) {
            endpoints.add(endpoint(uri));
        }
        return endpoints;
    }
    /**
     * Helper method to create a list of {@link Endpoint} instances
     */
    public List<Endpoint> endpoints(Endpoint... endpoints) {
        List<Endpoint> answer = new ArrayList<Endpoint>();
        answer.addAll(Arrays.asList(endpoints));
        return answer;
    }
    /**
     * Creates a disabled error handler for removing the default error handler
     */
    public NoErrorHandlerBuilder noErrorHandler() {
        return new NoErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler() {
        return new LoggingErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(String log) {
        return loggingErrorHandler(LogFactory.getLog(log));
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log) {
        return new LoggingErrorHandlerBuilder(log);
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log, LoggingLevel level) {
        return new LoggingErrorHandlerBuilder(log, level);
    }
    public DeadLetterChannelBuilder deadLetterChannel() {
        return new DeadLetterChannelBuilder();
    }
    public DeadLetterChannelBuilder deadLetterChannel(String deadLetterUri) {
        return deadLetterChannel(endpoint(deadLetterUri));
    }
    public DeadLetterChannelBuilder deadLetterChannel(Endpoint deadLetterEndpoint) {
        return new DeadLetterChannelBuilder(new SendProcessor(deadLetterEndpoint));
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getContext() {
        return context;
    }
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    public boolean isInheritErrorHandler() {
        return inheritErrorHandler;
    }
    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        this.inheritErrorHandler = inheritErrorHandler;
    }
}
"
org.apache.camel.component.cxf.CxfProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.cxf.feature.MessageDataFormatFeature;
import org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature;
import org.apache.camel.component.cxf.invoker.CxfClient;
import org.apache.camel.component.cxf.invoker.CxfClientFactoryBean;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.camel.component.cxf.invoker.InvokingContextFactory;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.bus.spring.SpringBusFactory;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.configuration.spring.ConfigurerImpl;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.frontend.ClientProxyFactoryBean;
import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.BindingOperationInfo;
/**
 * Sends messages from Camel into the CXF endpoint
 *
 * @version $Revision$
 */
public class CxfProducer extends DefaultProducer<CxfExchange> {
    private CxfEndpoint endpoint;
    private Client client;
    private DataFormat dataFormat;
    public CxfProducer(CxfEndpoint endpoint) throws Exception {
        super(endpoint);
        this.endpoint = endpoint;
        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        if (dataFormat.equals(DataFormat.POJO)) {
            client = createClientFromClientFactoryBean(null);
        } else {
            // Create CxfClient for message or payload type
            client = createClientForStreamMessage();
        }
    }
    private Client createClientForStreamMessage() throws Exception {
        CxfClientFactoryBean cfb = new CxfClientFactoryBean();
        Class serviceClass = null;
        try {
            serviceClass = CxfEndpointUtils.getServiceClass(endpoint);
        } catch (ClassNotFoundException e) {
            throw new CamelException(e);
        }       
        boolean jsr181Enabled = CxfEndpointUtils.hasWebServiceAnnotation(serviceClass);
        cfb.setJSR181Enabled(jsr181Enabled);
        return createClientFromClientFactoryBean(jsr181Enabled ? new JaxWsProxyFactoryBean(cfb)
            : new ClientProxyFactoryBean(cfb));
    }
    // If cfb is null, we will try to find the right cfb to use.
    private Client createClientFromClientFactoryBean(ClientProxyFactoryBean cfb) throws Exception {
        Bus bus = null;
        if (endpoint.getApplicationContext() != null) {            
            if (endpoint.getCxfEndpointBean() != null) {
                bus = endpoint.getCxfEndpointBean().getBus();                
            } else {
                SpringBusFactory busFactory = new SpringBusFactory(endpoint.getApplicationContext());
                bus = busFactory.createBus();
            }
            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {
                BusFactory.setDefaultBus(bus);
            }
        } else {
            // now we just use the default bus here
            bus = BusFactory.getDefaultBus();
        }
        Class serviceClass = CxfEndpointUtils.getServiceClass(endpoint);
        // We need to choose the right front end to create the clientFactoryBean        
        if (cfb == null) {
            cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);
        }
        if (endpoint.isSpringContextEndpoint()) {            
            endpoint.configure(cfb);
        } else { // set up the clientFactoryBean by using URI information
            cfb.setAddress(endpoint.getAddress());
            if (null != endpoint.getServiceClass()) {
                cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));
            }
            if (null != endpoint.getWsdlURL()) {
                cfb.setWsdlURL(endpoint.getWsdlURL());
            }
            if (endpoint.getWsdlURL() != null) {
                cfb.setWsdlURL(endpoint.getWsdlURL());
            }
        }
        cfb.setServiceClass(serviceClass);
        if (CxfEndpointUtils.getServiceName(endpoint) != null) {
            cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));
        }
        if (CxfEndpointUtils.getPortName(endpoint) != null) {
            cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));
        }
        if (dataFormat.equals(DataFormat.MESSAGE)) {
            cfb.getFeatures().add(new MessageDataFormatFeature());
        } else if (dataFormat.equals(DataFormat.PAYLOAD)) {
            cfb.getFeatures().add(new PayLoadDataFormatFeature());
        }
        cfb.setBus(bus);
        return ((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();
    }
    public void process(Exchange exchange) throws Exception {
        CxfExchange cxfExchange = endpoint.createExchange(exchange);
        process(cxfExchange);
        exchange.copyFrom(cxfExchange);
    }
    public void process(CxfExchange exchange) throws Exception {
        Message inMessage = CxfBinding.createCxfMessage(endpoint.getHeaderFilterStrategy(), exchange);
        exchange.setProperty(CxfExchange.DATA_FORMAT, dataFormat);
        if (dataFormat.equals(DataFormat.POJO)) {
            // InputStream is = m.getContent(InputStream.class);
            // now we just deal with the POJO invocations
            List parameters = inMessage.getContent(List.class);
            if (parameters == null) {
                parameters = new ArrayList();
            }
            String operationName = exchange.getIn().getHeader(CxfConstants.OPERATION_NAME, String.class);
            String operationNameSpace = exchange.getIn().getHeader(CxfConstants.OPERATION_NAMESPACE,
                                                                   String.class);
            // Get context from message
            Map<String, Object> context = new HashMap<String, Object>();
            Map<String, Object> responseContext = CxfBinding.propogateContext(inMessage, context);
            Message response = new MessageImpl();
            if (operationName != null) {
                // we need to check out the operation Namespace
                Object[] result = null;
                // call for the client with the parameters
                result = invokeClient(operationNameSpace, operationName, parameters, context);
                if (result != null) {
                    response.setContent(List.class, new MessageContentsList(result));
                } else {
                    response.setContent(List.class, new MessageContentsList());
                }
                // copy the response context to the response
                CxfBinding.storeCXfResponseContext(response, responseContext);
                CxfBinding.storeCxfResponse(endpoint.getHeaderFilterStrategy(), exchange, response);
            } else {
                throw new RuntimeCamelException(""Can't find the operation name in the message!"");
            }
        } else {
            // get the invocation context
            org.apache.cxf.message.Exchange ex = exchange.getExchange();
            if (ex == null) {
                ex = (org.apache.cxf.message.Exchange)exchange.getProperty(CxfConstants.CXF_EXCHANGE);
                exchange.setExchange(ex);
            }
            if (ex == null) {
                ex = new ExchangeImpl();
                exchange.setExchange(ex);
            }
            ObjectHelper.notNull(ex, ""exchange"");
            InvokingContext invokingContext = ex.get(InvokingContext.class);
            if (invokingContext == null) {
                invokingContext = InvokingContextFactory.createContext(dataFormat);
                ex.put(InvokingContext.class, invokingContext);
            }
            Map<Class, Object> params = invokingContext.getRequestContent(inMessage);
            // invoke the stream message with the exchange context
            CxfClient cxfClient = (CxfClient)client;
            // need to get the binding object to create the message
            BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
            Message response = null;
            if (boi == null) {
                // it should be the raw message
                response = new MessageImpl();
            } else {
                // create the message here
                Endpoint ep = ex.get(Endpoint.class);
                response = ep.getBinding().createMessage();
            }
            response.setExchange(ex);
            // invoke the message prepare the context
            Map<String, Object> context = new HashMap<String, Object>();
            Map<String, Object> responseContext = CxfBinding.propogateContext(inMessage, context);
            Object result = cxfClient.dispatch(params, context, ex);
            ex.setOutMessage(response);
            invokingContext.setResponseContent(response, result);
            // copy the response context to the response
            CxfBinding.storeCXfResponseContext(response, responseContext);
            CxfBinding.storeCxfResponse(endpoint.getHeaderFilterStrategy(), exchange, response);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
    }
    private Object[] invokeClient(String operationNameSpace, String operationName, List parameters,
                                  Map<String, Object> context) throws Exception {
        QName operationQName = null;
        if (operationNameSpace == null) {
            operationQName = new QName(client.getEndpoint().getService().getName().getNamespaceURI(),
                                       operationName);
        } else {
            operationQName = new QName(operationNameSpace, operationName);
        }
        BindingOperationInfo op = client.getEndpoint().getEndpointInfo().getBinding()
            .getOperation(operationQName);
        if (op == null) {
            throw new RuntimeCamelException(""No operation found in the CXF client, the operation is ""
                                            + operationQName);
        }
        if (!endpoint.isWrapped()) {
            if (op.isUnwrappedCapable()) {
                op = op.getUnwrappedOperation();
            }
        }
        Object[] result = client.invoke(op, parameters.toArray(), context);
        return result;
    }
    public Client getClient() {
        return client;
    }
}
"
org.apache.camel.component.mail.MailExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Message;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents an {@link Exchange} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailExchange extends DefaultExchange {
    private MailBinding binding;
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new MailMessage(message));
    }
    public MailExchange(DefaultExchange parent, MailBinding binding) {
        super(parent);
        this.binding = binding;
    }
    @Override
    public MailMessage getIn() {
        return (MailMessage) super.getIn();
    }
    @Override
    public MailMessage getOut() {
        return (MailMessage) super.getOut();
    }
    @Override
    public MailMessage getOut(boolean lazyCreate) {
        return (MailMessage) super.getOut(lazyCreate);
    }
    @Override
    public MailMessage getFault() {
        return (MailMessage) super.getFault();
    }
    public MailBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new MailExchange(this, binding);
    }
    // Expose Email APIs
    //-------------------------------------------------------------------------
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected MailMessage createInMessage() {
        return new MailMessage();
    }
    @Override
    protected MailMessage createOutMessage() {
        return new MailMessage();
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.CamelSourceAdpaterParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
/**
 * Parser for the &lt;camelSource/&gt; element
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelSourceAdpaterParser extends AbstractCamelContextBeanDefinitionParaser {
    @Override
    protected Class<?> getBeanClass(Element element) {
        return CamelSourceAdapter.class;
    }
}
"
org.apache.camel.language.bean.BeanExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.bean.BeanHolder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.bean.ConstantBeanHolder;
import org.apache.camel.component.bean.RegistryBean;
import org.apache.camel.impl.ExpressionSupport;
/**
 * Evaluates an expression using a bean method invocation
 *
 * @version $Revision$
 */
public class BeanExpression<E extends Exchange> extends ExpressionSupport<E> {
    private String beanName;
    private String method;
    private Object bean;
    public BeanExpression(Object bean, String method) {
        this.bean = bean;
        this.method = method;
    }
    public BeanExpression(String beanName, String method) {
        this.beanName = beanName;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""BeanExpression[bean:"" + (bean == null ? beanName : bean) + "" method: "" + method + ""]"";
    }
    protected String assertionFailureMessage(E exchange) {
        return ""bean: "" + beanName + "" method: "" + method;
    }
    public Object evaluate(E exchange) {
        // either use registry lookup or a constant bean
        BeanHolder holder;
        if (bean == null) {
            holder = new RegistryBean(exchange.getContext(), beanName);
        } else {
            holder = new ConstantBeanHolder(bean, exchange.getContext());
        }
        BeanProcessor processor = new BeanProcessor(holder);
        if (method != null) {
            processor.setMethod(method);
        }
        try {
            Exchange newExchange = exchange.copy();
            // The BeanExperession always has a result regardless of the ExchangePattern,
            // so I add a checker here to make sure we can get the result.
            if (!newExchange.getPattern().isOutCapable()) {
                newExchange.setPattern(ExchangePattern.InOut);
            }
            processor.process(newExchange);
            return newExchange.getOut(true).getBody();
        } catch (Exception e) {
            throw new RuntimeBeanExpressionException(exchange, beanName, method, e);
        }
    }
}
"
org.apache.camel.component.jpa.Callback,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
/**
 * @version $Revision$
 */
public interface Callback<R, P> {
    R callback(P parameter);
}
"
org.apache.camel.component.file.remote.RemoteFileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
public class RemoteFileMessage extends DefaultMessage {
    private OutputStream outputStream;
    private String fullFileName;
    private String fileName;
    private String hostname;
    private long fileLength;
    public RemoteFileMessage() {
    }
    public RemoteFileMessage(String hostname, String fullFileName, String fileName, long fileLength, OutputStream outputStream) {
        this.hostname = hostname;
        this.fullFileName = fullFileName;
        this.fileName = fileName;
        this.fileLength = fileLength;
        this.outputStream = outputStream;
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getFullFileName() {
        return fullFileName;
    }
    public void setFullFileName(String fullFileName) {
        this.fullFileName = fullFileName;
    }
    public OutputStream getOutputStream() {
        return outputStream;
    }
    public void setOutputStream(OutputStream outputStream) {
        this.outputStream = outputStream;
    }
    @Override
    public RemoteFileExchange getExchange() {
        return (RemoteFileExchange) super.getExchange();
    }
    @Override
    protected Object createBody() {
        if (outputStream != null) {
            return getExchange().getBinding().extractBodyFromOutputStream(getExchange(), outputStream);
        }
        return null;
    }
    @Override
    public RemoteFileMessage newInstance() {
        return new RemoteFileMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        map.put(""file.remote.host"", hostname);
        map.put(""file.remote.fullName"", fullFileName);
        map.put(""file.remote.name"", fileName);
        map.put(""CamelFileName"", fileName);
        map.put(""CamelFilePath"", fullFileName);
        // set the parent if there is a parent folder
        if (fullFileName != null && fullFileName.indexOf(""/"") != -1) {
            String parent = fullFileName.substring(0, fullFileName.lastIndexOf(""/""));
            map.put(""CamelFileParent"", parent);
        }
        if (fileLength > 0) {
            map.put(""CamelFileLength"", new Long(fileLength));
        }
    }
}
"
org.apache.camel.impl.ReportingTypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.TypeConverterRegistry;
import org.apache.camel.spi.Injector;
/**
 * Registry for reporting type converters.
 * <p/>
 * Used by the camel-maven-plugin.
 */
public class ReportingTypeConverterRegistry implements TypeConverterRegistry {
    private List<String> errors = new ArrayList<String>();
    public String[] getErrors() {
        return errors.toArray(new String[errors.size()]);
    }
    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        if (errors.size() == 0) {
            errors.add(""Method should not be invoked."");
        }
    }
    public Injector getInjector() {
        return null;
    }
}
"
org.apache.camel.impl.ServiceSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.Service;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ServiceHelper;
/**
 * A useful base class which ensures that a service is only initialized once and
 * provides some helper methods for enquiring of its status
 *
 * @version $Revision$
 */
public abstract class ServiceSupport implements Service {
    private static int threadCounter;
    private AtomicBoolean started = new AtomicBoolean(false);
    private AtomicBoolean starting = new AtomicBoolean(false);
    private AtomicBoolean stopping = new AtomicBoolean(false);
    private AtomicBoolean stopped = new AtomicBoolean(false);
    private Collection childServices;
    private String version;
    public void start() throws Exception {
        if (started.compareAndSet(false, true)) {
            starting.set(true);
            try {
                if (childServices != null) {
                    ServiceHelper.startServices(childServices);
                }
                doStart();
            } finally {
                starting.set(false);
            }
        }
    }
    public void stop() throws Exception {
        if (started.get() && stopping.compareAndSet(false, true)) {
            try {
                doStop();
            } finally {
                if (childServices != null) {
                    ServiceHelper.stopServices(childServices);
                }
                stopped.set(true);
                started.set(false);
                stopping.set(false);
            }
        }
    }
    /**
     * @return true if this service has been started
     */
    public boolean isStarted() {
        return started.get();
    }
    /**
     * @return true if this service is
     */
    public boolean isStarting() {
        return starting.get();
    }
    /**
     * @return true if this service is in the process of closing
     */
    public boolean isStopping() {
        return stopping.get();
    }
    /**
     * Helper methods so the service knows if it should keep running.
     * Returns false if the service is being stopped or is stopped.
     *
     * @return true if the service should continue to run.
     */
    protected boolean isRunAllowed() {
        return !(stopping.get() || stopped.get());
    }
    /**
     * @return true if this service is closed
     */
    public boolean isStopped() {
        return stopped.get();
    }
    protected abstract void doStart() throws Exception;
    protected abstract void doStop() throws Exception;
    /**
     * Creates a new thread name with the given prefix
     */
    protected String getThreadName(String prefix) {
        return prefix + "" thread:"" + nextThreadCounter();
    }
    protected static synchronized int nextThreadCounter() {
        return ++threadCounter;
    }
    protected void addChildService(Object childService) {
        if (childServices == null) {
            childServices = new ArrayList();
        }
        childServices.add(childService);
    }
    protected boolean removeChildService(Object childService) {
        if (childServices != null) {
            return childServices.remove(childService);
        } else {
            return false;
        }
    }
    protected synchronized String getVersion() {
        if (ObjectHelper.isNotNullAndNonEmpty(version)) {
            return version;
        }
        Package aPackage = getClass().getPackage();
        if (aPackage != null) {
            version = aPackage.getImplementationVersion();
            if (version == null) {
                version = aPackage.getSpecificationVersion();
                if (version == null) {
                    version = """";
                }
            }
        } else {
            version = """";
        }
        return version;
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.Map;
import org.apache.camel.Exchange;
import org.springframework.integration.message.GenericMessage;
/**
 * The helper class for Mapping between the Spring Integration message and
 * the Camel Message
 * @version $Revision$
 */
public final class SpringIntegrationBinding {
    private SpringIntegrationBinding() {
        // Helper class
    }
    public static org.springframework.integration.core.Message createSpringIntegrationMessage(Exchange exchange) {
        return createSpringIntegrationMessage(exchange, null);
    }
    @SuppressWarnings(""unchecked"")
    public static org.springframework.integration.core.Message createSpringIntegrationMessage(Exchange exchange, Map<String, Object> headers) {
        org.apache.camel.Message message = exchange.getIn();
        GenericMessage siMessage = new GenericMessage(message.getBody(), headers);
        return siMessage;
    }
    @SuppressWarnings(""unchecked"")
    public static org.springframework.integration.core.Message storeToSpringIntegrationMessage(org.apache.camel.Message message) {
        GenericMessage siMessage = new GenericMessage(message.getBody());
        return siMessage;
    }
    public static void storeToCamelMessage(org.springframework.integration.core.Message siMessage, org.apache.camel.Message cMessage) {
        cMessage.setBody(siMessage.getPayload());
        cMessage.setHeaders(siMessage.getHeaders());
    }
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingMessageInfo;
//import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class XMLMessageOutInterceptor extends AbstractMessageOutInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageOutInterceptor.class);
    public XMLMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);        
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(XMLMessage message) throws Fault {
        Exchange exchange = message.getExchange();        
        //BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        List<Element> payload = message.get(List.class);
        if (bmi == null && payload.size() > 1) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(
                            ""NO_XML_ROOT_NODE"", LOG));            
        }
        if (bmi != null) {
            Element header = message.get(Element.class);
            if (header != null) {
                //Headers -represent as -Element,
                //Body -represent as StaxStream in CXF Runtime.
                //Copy inbound Header parts to outbound payload
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Copy Message Part related Headers to Payload."");
                }
                moveHeaderPartToPayload(bmi, header, payload);
            }
            XMLBindingMessageFormat msgFormat = 
                bmi.getExtensor(XMLBindingMessageFormat.class);
            QName rootName = msgFormat != null ? msgFormat.getRootNode() : null;
            if (rootName == null) {
                if (payload.size() > 1) {
                    throw new Fault(new org.apache.cxf.common.i18n.Message(
                                    ""NO_XML_ROOT_NODE"", LOG));
                }
            } else {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Create xmlformat RootNode element"");
                }                
                Element el = createElement(rootName, payload);
                payload = new ArrayList<Element>();
                payload.add(el);
            }
            message.put(List.class, payload);
            message.remove(Element.class);
        }
    }
    private void moveHeaderPartToPayload(BindingMessageInfo bmi,
                                         Element header,
                                         List<Element> payload) {
        Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
        NodeList nodes = header.getChildNodes();
        for (int idx = 0; idx < nodes.getLength(); idx++) {
            Node node = nodes.item(idx);
            int index = 0;
            for (MessagePartInfo mpi : bodyParts) {
                QName name = mpi.getConcreteName();
                if (name.getLocalPart().equals(node.getLocalName())
                    && name.getNamespaceURI().equals(node.getNamespaceURI())) {
                    payload.add(index, (Element)node);
                    break;
                } 
                ++index;
            }
        }
    }
}
"
org.apache.camel.component.jms.DestinationEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
/**
 * An optional interface that a {@link JmsEndpoint} may implement to return the
 * underlying {@link Destination} object
 *
 * @version $Revision$
 */
public interface DestinationEndpoint {
    Destination getJmsDestination(Session session) throws JMSException;
}
"
org.apache.camel.builder.xml.DomResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import javax.xml.transform.dom.DOMResult;
import org.apache.camel.Message;
/**
 * Uses DOM to handle results of the transformation
 *
 * @version $Revision$
 */
public class DomResultHandler implements ResultHandler {
    private DOMResult result = new DOMResult();
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(result.getNode());
    }
}
"
org.apache.camel.component.http.HttpPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.http.helper.LoadingByteArrayOutputStream;
import org.apache.camel.impl.PollingConsumerSupport;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.io.IOUtils;
/**
 * A polling HTTP consumer which by default performs a GET
 *
 * @version $Revision$
 */
public class HttpPollingConsumer extends PollingConsumerSupport<HttpExchange> {
    private final HttpEndpoint endpoint;
    private HttpClient httpClient;
    public HttpPollingConsumer(HttpEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        httpClient = endpoint.createHttpClient();
    }
    public HttpExchange receive() {
        return receiveNoWait();
    }
    public HttpExchange receive(long timeout) {
        return receiveNoWait();
    }
    public HttpExchange receiveNoWait() {
        HttpExchange exchange = endpoint.createExchange();
        HttpMethod method = createMethod();
        try {
            int responseCode = httpClient.executeMethod(method);
            // lets store the result in the output message.
            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();
            InputStream is = method.getResponseBodyAsStream();
            IOUtils.copy(is, bos);
            bos.flush();
            is.close();
            Message message = exchange.getIn();
            message.setBody(bos.createInputStream());
            // lets set the headers
            Header[] headers = method.getResponseHeaders();
            HeaderFilterStrategy strategy = endpoint.getHeaderFilterStrategy();
            for (Header header : headers) {
                String name = header.getName();
                String value = header.getValue();
                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {
                    message.setHeader(name, value);
                }
            }
            message.setHeader(""http.responseCode"", responseCode);
            return exchange;
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        } finally {
            method.releaseConnection();
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public HttpClient getHttpClient() {
        return httpClient;
    }
    public void setHttpClient(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected HttpMethod createMethod() {
        String uri = endpoint.getEndpointUri();
        return new GetMethod(uri);
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.validator.msv.MsvComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.msv;
import java.util.Map;
import javax.xml.XMLConstants;
import org.apache.camel.component.validator.SpringValidator;
import org.apache.camel.component.validator.ValidatorComponent;
import org.iso_relax.verifier.VerifierConfigurationException;
import org.iso_relax.verifier.jaxp.validation.RELAXNGSchemaFactoryImpl;
/**
 * The <a href=""http://activemq.apache.org/camel/msv.html"">MSV Component</a> uses the
 * <a href=""https://msv.dev.java.net/"">MSV library</a> to perform XML validation using pluggable XML schema languages.
 *
 * @version $Revision$
 */
public class MsvComponent extends ValidatorComponent {
    private RELAXNGSchemaFactoryImpl schemaFactory;
    public RELAXNGSchemaFactoryImpl getSchemaFactory() throws VerifierConfigurationException {
        if (schemaFactory == null) {
            schemaFactory = new RELAXNGSchemaFactoryImpl();
        }
        return schemaFactory;
    }
    public void setSchemaFactory(RELAXNGSchemaFactoryImpl schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    protected void configureValidator(SpringValidator validator, String uri, String remaining, Map parameters) throws Exception {
        validator.setSchemaLanguage(XMLConstants.RELAXNG_NS_URI);
        validator.setSchemaFactory(getSchemaFactory());
        super.configureValidator(validator, uri, remaining, parameters);
    }
}
"
org.apache.camel.impl.ReportingTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.AnnotationTypeConverterLoader;
import org.apache.camel.impl.converter.TypeConverterRegistry;
import org.apache.camel.util.ObjectHelper;
/**
 * Type converter loader that is capable of reporting the loaded type converters.
 * <p/>
 * Used by the camel-maven-plugin.
 */
public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader {
    private static final Comparator<TypeMapping> COMPARE_LAST_LOADED_FIRST = new Comparator<TypeMapping>() {
        public int compare(TypeMapping t1, TypeMapping t2) {
            if (ObjectHelper.equal(t1.fromType, t2.fromType)) {
                return ObjectHelper.equal(t1.toType, t2.toType) ? t1.index - t2.index : ObjectHelper
                    .compare(getTypeName(t1.toType), getTypeName(t2.toType));
            }
            return ObjectHelper.compare(getTypeName(t1.fromType), getTypeName(t2.fromType));
        }
    };
    private List<TypeMapping> typeMappings = new ArrayList<TypeMapping>();
    public TypeMapping[] getTypeConversions() {
        Collections.sort(typeMappings, COMPARE_LAST_LOADED_FIRST);
        return typeMappings.toArray(new TypeMapping[typeMappings.size()]);
    }
    protected void registerTypeConverter(TypeConverterRegistry registry, Method method, Class toType,
                                         Class fromType, TypeConverter typeConverter) {
        TypeMapping mapping = new TypeMapping(toType, fromType, typeConverter.getClass(), method);
        typeMappings.add(mapping);
    }
    private static String getTypeName(Class type) {
        return type != null ? type.getName() : null;
    }
    /**
     * Represents a mapping from one type (which can be null) to another
     *
     * Used by the camel-maven-plugin.
     */
    public static class TypeMapping {
        private static int counter;
        private Class toType;
        private Class fromType;
        private Class converterType;
        private Method method;
        private int index;
        public TypeMapping(Class toType, Class fromType, Class converterType, Method method) {
            this.toType = toType;
            this.fromType = fromType;
            this.converterType = converterType;
            this.method = method;
            this.index = counter++;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        public Class getConverterType() {
            return converterType;
        }
        public Method getMethod() {
            return method;
        }
        public int getIndex() {
            return index;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return this.index == that.index;
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType.getSimpleName() + ""=>"" + toType.getSimpleName() + ""]"";
        }
    }
}
"
org.apache.camel.component.mail.MailConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import java.io.InputStream;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
/**
 * JavaMail specific converters.
 *
 * @version $Revision$
 */
@Converter
public final class MailConverters {
    private MailConverters() {
        //Utility Class
    }
    /**
     * Converts the given JavaMail message to a String body.
     * Can return null.
     */
    @Converter
    public static String toString(Message message) throws MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof MimeMultipart) {
            MimeMultipart multipart = (MimeMultipart) content;
            if (multipart.getCount() > 0) {
                BodyPart part = multipart.getBodyPart(0);
                content = part.getContent();
            }
        }
        if (content != null) {
            return content.toString();
        }
        return null;
    }
    /**
     * Converts the given JavaMail multipart to a String body, where the contenttype of the multipart
     * must be text based (ie start with text). Can return null.
     */
    @Converter
    public static String toString(Multipart multipart) throws MessagingException, IOException {
        int size = multipart.getCount();
        for (int i = 0; i < size; i++) {
            BodyPart part = multipart.getBodyPart(i);
            if (part.getContentType().startsWith(""text"")) {
                return part.getContent().toString();
            }
        }
        return null;
    }
    /**
     * Converts the given JavaMail message to an InputStream.
     * Can return null.
     */
    @Converter
    public static InputStream toInputStream(Message message) throws IOException, MessagingException {
        String s = toString(message);
        if (s == null) {
            return null;
        }
        return IOConverter.toInputStream(s, null);
    }
    /**
     * Converts the given JavaMail multipart to a InputStream body, where the contenttype of the multipart
     * must be text based (ie start with text). Can return null.
     */
    @Converter
    public static InputStream toInputStream(Multipart multipart) throws IOException, MessagingException {
        String s = toString(multipart);
        if (s == null) {
            return null;
        }
        return IOConverter.toInputStream(s, null);
    }
}
"
org.apache.camel.RuntimeExpressionException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if an expression evaluation fails
 * 
 * @version $Revision$
 */
public class RuntimeExpressionException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeExpressionException(String message) {
        super(message);
    }
    public RuntimeExpressionException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeExpressionException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.builder.ExpressionBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.nio.channels.ReadableByteChannel;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.Scanner;
import java.util.regex.Pattern;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.language.bean.BeanLanguage;
import org.apache.camel.language.simple.SimpleLanguage;
/**
 * A helper class for working with <a href=""http://activemq.apache.org/camel/expression.html"">expressions</a>.
 *
 * @version $Revision$
 */
public final class ExpressionBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionBuilder() {
    }
    /**
     * Returns an expression for the header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> headerExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object header = exchange.getIn().getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""header("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the inbound message headers
     *
     * @see Message#getHeaders()
     * @return an expression object which will return the inbound headers
     */
    public static <E extends Exchange> Expression<E> headersExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeaders();
            }
            @Override
            public String toString() {
                return ""headers"";
            }
        };
    }
    /**
     * Returns an expression for the out header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> outHeaderExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                Object header = out.getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""outHeader("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the outbound message headers
     *
     * @see Message#getHeaders()
     * @return an expression object which will return the inbound headers
     */
    public static <E extends Exchange> Expression<E> outHeadersExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut().getHeaders();
            }
            @Override
            public String toString() {
                return ""outHeaders"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperty(String)
     * @param propertyName the name of the property the expression will return
     * @return an expression object which will return the property value
     */
    public static <E extends Exchange> Expression<E> propertyExpression(final String propertyName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperty(propertyName);
            }
            @Override
            public String toString() {
                return ""property("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperties()
     * @return an expression object which will return the properties
     */
    public static <E extends Exchange> Expression<E> propertiesExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperties();
            }
            @Override
            public String toString() {
                return ""properties"";
            }
        };
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName) {
        return systemPropertyExpression(propertyName, null);
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName,
                                                                              final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(propertyName, defaultValue);
            }
            @Override
            public String toString() {
                return ""systemProperty("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the constant value
     *
     * @param value the value the expression will return
     * @return an expression object which will return the constant value
     */
    public static <E extends Exchange> Expression<E> constantExpression(final Object value) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return value;
            }
            @Override
            public String toString() {
                return """" + value;
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body
     */
    public static <E extends Exchange> Expression<E> bodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody();
            }
            @Override
            public String toString() {
                return ""body"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> bodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody(type);
            }
            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the out messages body
     */
    public static <E extends Exchange> Expression<E> outBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                return out.getBody();
            }
            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges outbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> outBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                return out.getBody(type);
            }
            @Override
            public String toString() {
                return ""outBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the fault messages body
     */
    public static <E extends Exchange> Expression<E> faultBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody();
            }
            @Override
            public String toString() {
                return ""faultBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges fault message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> faultBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody(type);
            }
            @Override
            public String toString() {
                return ""faultBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the exchange
     */
    public static <E extends Exchange> Expression<E> exchangeExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange;
            }
            @Override
            public String toString() {
                return ""exchange"";
            }
        };
    }
    /**
     * Returns the expression for the IN message
     */
    public static <E extends Exchange> Expression<E> inMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn();
            }
            @Override
            public String toString() {
                return ""inMessage"";
            }
        };
    }
    /**
     * Returns the expression for the OUT message
     */
    public static <E extends Exchange> Expression<E> outMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut();
            }
            @Override
            public String toString() {
                return ""outMessage"";
            }
        };
    }
    /**
     * Returns an expression which converts the given expression to the given
     * type
     */
    public static <E extends Exchange> Expression<E> convertTo(final Expression expression, final Class type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                return exchange.getContext().getTypeConverter().convertTo(type, exchange, value);
            }
            @Override
            public String toString() {
                return """" + expression + "".convertTo("" + type.getName() + "".class)"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given token
     */
    public static <E extends Exchange> Expression<E> tokenizeExpression(final Expression<E> expression,
                                                                        final String token) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                Scanner scanner = getScanner(exchange, value);
                scanner.useDelimiter(token);
                return scanner;
            }
            @Override
            public String toString() {
                return ""tokenize("" + expression + "", "" + token + "")"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given regex
     */
    public static <E extends Exchange> Expression<E> regexTokenize(final Expression<E> expression,
                                                                   final String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                Scanner scanner = getScanner(exchange, value);
                scanner.useDelimiter(regexTokenizer);
                return scanner;
            }
            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    private static Scanner getScanner(Exchange exchange, Object value) {
        String charset = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
        Scanner scanner = null;
        if (value instanceof Readable) {
            scanner = new Scanner((Readable)value);
        } else if (value instanceof InputStream) {
            scanner = charset == null ? new Scanner((InputStream)value)
                : new Scanner((InputStream)value, charset);
        } else if (value instanceof File) {
            try {
                scanner = charset == null ? new Scanner((File)value) : new Scanner((File)value, charset);
            } catch (FileNotFoundException e) {
                throw new RuntimeCamelException(e);
            }
        } else if (value instanceof String) {
            scanner = new Scanner((String)value);
        } else if (value instanceof ReadableByteChannel) {
            scanner = charset == null ? new Scanner((ReadableByteChannel)value)
                : new Scanner((ReadableByteChannel)value, charset);
        }
        if (scanner == null) {
            // value is not a suitable type, try to convert value to a string
            String text = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);
            if (text != null) {
                scanner = new Scanner(text);
            }
        }
        if (scanner == null) {
            scanner = new Scanner("""");
        }
        return scanner;
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     final String regex, final String replacement) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     String regex,
                                                                     final Expression<E> replacementExpression) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                String replacement = evaluateStringExpression(replacementExpression, exchange);
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Appends the String evaluations of the two expressions together
     */
    public static <E extends Exchange> Expression<E> append(final Expression<E> left,
                                                            final Expression<E> right) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return evaluateStringExpression(left, exchange) + evaluateStringExpression(right, exchange);
            }
            @Override
            public String toString() {
                return ""append("" + left + "", "" + right + "")"";
            }
        };
    }
    /**
     * Evaluates the expression on the given exchange and returns the String
     * representation
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the String representation of the expression or null if it could
     *         not be evaluated
     */
    public static <E extends Exchange> String evaluateStringExpression(Expression<E> expression, E exchange) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name,
                                                                    final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(name, defaultValue);
            }
        };
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions) {
        return concatExpression(expressions, null);
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @param expression the text description of the expression
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions, final String expression) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                StringBuffer buffer = new StringBuffer();
                for (Expression<E> expression : expressions) {
                    String text = evaluateStringExpression(expression, exchange);
                    if (text != null) {
                        buffer.append(text);
                    }
                }
                return buffer.toString();
            }
            @Override
            public String toString() {
                if (expression != null) {
                    return expression;
                } else {
                    return ""concat"" + expressions;
                }
            }
        };
    }
    /**
     * Returns an Expression for the inbound message id
     */
    public static <E extends Exchange> Expression<E> messageIdExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getMessageId();
            }
            @Override
            public String toString() {
                return ""messageId"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> dateExpression(final String command, final String pattern) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Date date;
                if (""now"".equals(command)) {
                    date = new Date();
                } else if (command.startsWith(""header."") || command.startsWith(""in.header."")) {
                    String key = command.substring(command.lastIndexOf(""."") + 1);
                    date = exchange.getIn().getHeader(key, Date.class);
                    if (date == null) {
                        throw new IllegalArgumentException(""Could not find java.util.Date object at "" + command);
                    }
                } else if (command.startsWith(""out.header."")) {
                    String key = command.substring(command.lastIndexOf(""."") + 1);
                    date = exchange.getOut().getHeader(key, Date.class);
                    if (date == null) {
                        throw new IllegalArgumentException(""Could not find java.util.Date object at "" + command);
                    }
                } else {
                    throw new IllegalArgumentException(""Command not supported for dateExpression: "" + command);
                }
                SimpleDateFormat df = new SimpleDateFormat(pattern);
                return df.format(date);
            }
            @Override
            public String toString() {
                return ""date("" + command + "":"" + pattern + "")"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> simpleExpression(final String simple) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                // must call evalute to return the nested langauge evaluate when evaluating
                // stacked expressions
                return SimpleLanguage.simple(simple).evaluate(exchange);
            }
            @Override
            public String toString() {
                return ""simple("" + simple + "")"";
            }
        };
    }
    public static <E extends Exchange> Expression<E> beanExpression(final String bean) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                // must call evalute to return the nested langauge evaluate when evaluating
                // stacked expressions
                return BeanLanguage.bean(bean).evaluate(exchange);
            }
            @Override
            public String toString() {
                return ""bean("" + bean + "")"";
            }
        };
    }
}
"
org.apache.camel.component.jhc.JhcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.net.URI;
import org.apache.camel.Consumer;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 7, 2007
 * Time: 8:06:42 PM
 * To change this template use File | Settings | File Templates.
 */
public class JhcEndpoint extends DefaultEndpoint<JhcExchange> {
    private HttpParams params;
    private URI httpUri;
    public JhcEndpoint(String endpointUri, JhcComponent component, URI httpUri) {
        super(endpointUri, component);
        params = component.getParams().copy();
        this.httpUri = httpUri;
    }
    public JhcEndpoint(String endpointUri, URI httpUri, HttpParams params) {
        super(endpointUri);
        this.httpUri = httpUri;
        this.params = params;
    }
    public HttpParams getParams() {
        return params;
    }
    public void setParams(HttpParams params) {
        this.params = params;
    }
    public URI getHttpUri() {
        return httpUri;
    }
    public void setHttpUri(URI httpUri) {
        this.httpUri = httpUri;
    }
    public String getProtocol() {
        return httpUri.getScheme();
    }
    public String getHost() {
        return httpUri.getHost();
    }
    public int getPort() {
        if (httpUri.getPort() == -1) {
            if (""https"".equals(getProtocol())) {
                return 443;
            } else {
                return 80;
            }
        }
        return httpUri.getPort();
    }
    public String getPath() {
        return httpUri.getPath();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<JhcExchange> createProducer() throws Exception {
        return new JhcProducer(this);
    }
    public Consumer<JhcExchange> createConsumer(Processor processor) throws Exception {
        return new JhcConsumer(this, processor);
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        if (getComponent() instanceof HeaderFilterStrategyAware) {
            return ((HeaderFilterStrategyAware)getComponent()).getHeaderFilterStrategy();
        } else {
            return new JhcHeaderFilterStrategy();
        }
    }
}
"
org.apache.camel.impl.converter.CachingInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
/**
 * A caching proxy
 *
 * @version $Revision$
 */
public class CachingInjector<T> {
    private final TypeConverterRegistry repository;
    private final Class<T> type;
    private T instance;
    public CachingInjector(TypeConverterRegistry repository, Class<T> type) {
        this.repository = repository;
        this.type = type;
    }
    public synchronized T newInstance() {
        if (instance == null) {
            instance = createInstance(type);
        }
        return instance;
    }
    protected T createInstance(Class<T> t) {
        return repository.getInjector().newInstance(t);
    }
}
"
org.apache.camel.component.http.DefaultHttpBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.Message;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * Binding between {@link HttpMessage} and {@link HttpServletResponse}.
 *
 * @version $Revision$
 */
public class DefaultHttpBinding implements HttpBinding {
    private boolean useReaderForPayload;
    private HeaderFilterStrategy headerFilterStrategy = new HttpHeaderFilterStrategy();
    public DefaultHttpBinding() {
    }
    public DefaultHttpBinding(HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }
    public void readRequest(HttpServletRequest request, HttpMessage message) {
        // lets force a parse of the body and headers
        message.getBody();
        message.getHeaders();
    }
    public void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException {
        if (exchange.isFailed()) {
            Message fault = exchange.getFault(false);
            if (fault != null) {
                doWriteFaultResponse(fault, response);
            } else {
                doWriteExceptionResponse(exchange.getException(), response);
            }
        } else {
            Message out = exchange.getOut();
            if (out != null) {
                doWriteResponse(out, response);
            }
        }
    }
    public void doWriteExceptionResponse(Throwable exception, HttpServletResponse response) throws IOException {
        response.setStatus(500); // 500 for internal server error
        response.setContentType(""text/plain"");
        // append the stacktrace as response
        PrintWriter pw = response.getWriter();
        exception.printStackTrace(pw);
        pw.flush();
    }
    public void doWriteFaultResponse(Message message, HttpServletResponse response) throws IOException {
        doWriteResponse(message, response);
    }
    public void doWriteResponse(Message message, HttpServletResponse response) throws IOException {
        // set the status code in the response. Default is 200.
        if (message.getHeader(HttpProducer.HTTP_RESPONSE_CODE) != null) {
            int code = message.getHeader(HttpProducer.HTTP_RESPONSE_CODE, Integer.class);
            response.setStatus(code);
        }
        // set the content type in the response.
        if (message.getHeader(""Content-Type"") != null) {
            String contentType = message.getHeader(""Content-Type"", String.class);
            response.setContentType(contentType);
        }
        // append headers
        for (String key : message.getHeaders().keySet()) {
            String value = message.getHeader(key, String.class);
            if (headerFilterStrategy != null
                    && !headerFilterStrategy.applyFilterToCamelHeaders(key, value)) {
                response.setHeader(key, value);
            }
        }
        // write the body.
        if (message.getBody() != null) {
            // try to stream the body since that would be the most efficient
            InputStream is = message.getBody(InputStream.class);
            int length = 0;
            if (is != null) {
                ServletOutputStream os = null;
                try {
                    os = response.getOutputStream();
                    int c;
                    while ((c = is.read()) >= 0) {
                        os.write(c);
                        length++;
                    }
                    // set content length before we flush
                    response.setContentLength(length);
                    os.flush();
                } finally {
                    os.close();
                    is.close();
                }
            } else {
                String data = message.getBody(String.class);
                if (data != null) {
                    // set content length before we write data
                    response.setContentLength(data.length());
                    response.getWriter().print(data);
                    response.getWriter().flush();
                }
            }
        }
    }
    public Object parseBody(HttpMessage httpMessage) throws IOException {
        // lets assume the body is a reader
        HttpServletRequest request = httpMessage.getRequest();
        if (isUseReaderForPayload()) {
            return request.getReader();
        } else {
            return request.getInputStream();
        }
    }
    public boolean isUseReaderForPayload() {
        return useReaderForPayload;
    }
    public void setUseReaderForPayload(boolean useReaderForPayload) {
        this.useReaderForPayload = useReaderForPayload;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }
}
"
org.apache.camel.component.cxf.transport.CamelTransportFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import org.apache.camel.CamelContext;
import org.apache.camel.component.cxf.CxfHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.Bus;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractTransportFactory;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.ConduitInitiatorManager;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
import org.apache.cxf.transport.DestinationFactoryManager;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator, DestinationFactory {
    public static final String TRANSPORT_ID = ""http://cxf.apache.org/transports/camel"";
    private static final Set<String> URI_PREFIXES = new HashSet<String>();
    private Collection<String> activationNamespaces;
    private HeaderFilterStrategy headerFilterStrategy = new CxfHeaderFilterStrategy();
    static {
        URI_PREFIXES.add(""camel://"");
    }
    private Bus bus;
    private CamelContext camelContext;
    @Resource(name = ""bus"")
    public void setBus(Bus b) {
        bus = b;
    }
    public Bus getBus() {
        return bus;
    }
    @Resource
    public void setActivationNamespaces(Collection<String> ans) {
        activationNamespaces = ans;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @Resource(name = ""camelContext"")
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public Conduit getConduit(EndpointInfo targetInfo) throws IOException {
        return getConduit(targetInfo, null);
    }
    public Conduit getConduit(EndpointInfo endpointInfo, EndpointReferenceType target) throws IOException {
        return new CamelConduit(camelContext, bus, endpointInfo, target, headerFilterStrategy);
    }
    public Destination getDestination(EndpointInfo endpointInfo) throws IOException {
        return new CamelDestination(camelContext, bus, this, endpointInfo, headerFilterStrategy);
    }
    public Set<String> getUriPrefixes() {
        return URI_PREFIXES;
    }
    @PostConstruct
    void registerWithBindingManager() {
        if (null == bus) {
            return;
        }
        ConduitInitiatorManager cim = bus.getExtension(ConduitInitiatorManager.class);
        if (null != cim && null != activationNamespaces) {
            for (String ns : activationNamespaces) {
                cim.registerConduitInitiator(ns, this);
            }
        }
        DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);
        if (null != dfm && null != activationNamespaces) {
            for (String ns : activationNamespaces) {
                dfm.registerDestinationFactory(ns, this);
            }
        }
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }
}
"
org.apache.camel.component.cxf.util.DataInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.util.logging.Logger;
import javax.xml.stream.XMLStreamException;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import org.w3c.dom.Document;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.AbstractInDatabindingInterceptor;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.DepthXMLStreamReader;
import org.apache.cxf.staxutils.StaxUtils;
public class DataInInterceptor extends AbstractInDatabindingInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(DataInInterceptor.class);
    public DataInInterceptor() {
        super(Phase.UNMARSHAL);
    }
    public void handleMessage(Message message) throws Fault {
        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);
        try {
            // put the payload source as a document
            Document doc = StaxUtils.read(xmlReader);
            message.setContent(Source.class, new DOMSource(doc));
        } catch (XMLStreamException e) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""XMLSTREAM_EXCEPTION"",
                                                                   LOG),
                            e);
        }
    }
}
"
org.apache.camel.language.simple.FileLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import org.apache.camel.Expression;
import org.apache.camel.component.file.FileExchange;
import org.apache.camel.language.IllegalSyntaxException;
import org.apache.camel.util.ObjectHelper;
/**
 * File language is an extension to Simple language to add file specific expressions.
 *
 * Examples of supported file expressions are:
 * <ul>
 * <li><tt>file:name</tt> to access the file name</li>
 * <li><tt>file:name.noext</tt> to access the file name with no extension</li>
 * <li><tt>file:parent</tt> to access the parent file name</li>
 * <li><tt>file:path</tt> to access the file path name</li>
 * <li><tt>file:absolute.path</tt> to access the absolute file path name</li>
 * <li><tt>file:canonical.path</tt> to access the canonical path name</li>
 * <li><tt>file:length</tt> to access the file length as a Long type</li>
 * <li><tt>date:&lt;command&gt;:&lt;pattern&gt;</tt> for date formatting using the {@link java.text.SimpleDateFormat} patterns.
 *     Additional Supported commands are: <tt>file</tt> for the last modified timestamp of the file.
 *     All the commands from {@link SimpleLanguage} is also avaiable.
 * </li>
 * </ul>
 * All the simple expression is also available so you can eg use <tt>${in.header.foo}</tt> to access the foo header.
 *
 * @see org.apache.camel.language.simple.SimpleLanguage
 * @see org.apache.camel.language.bean.BeanLanguage
 */
public class FileLanguage extends AbstractSimpleLanguage {
    public static Expression file(String expression) {
        FileLanguage language = new FileLanguage();
        return language.createExpression(expression);
    }
    protected Expression<FileExchange> createSimpleExpression(String expression) {
        // file: prefix
        String remainder = ifStartsWithReturnRemainder(""file:"", expression);
        if (remainder != null) {
            if (ObjectHelper.equal(remainder, ""name"")) {
                return FileExpressionBuilder.fileNameExpression();
            } else if (ObjectHelper.equal(remainder, ""name.noext"")) {
                return FileExpressionBuilder.fileNameNoExtensionExpression();
            } else if (ObjectHelper.equal(remainder, ""parent"")) {
                return FileExpressionBuilder.fileParentExpression();
            } else if (ObjectHelper.equal(remainder, ""path"")) {
                return FileExpressionBuilder.filePathExpression();
            } else if (ObjectHelper.equal(remainder, ""absolute.path"")) {
                return FileExpressionBuilder.fileAbsolutePathExpression();
            } else if (ObjectHelper.equal(remainder, ""canonical.path"")) {
                return FileExpressionBuilder.fileCanoicalPathExpression();
            } else if (ObjectHelper.equal(remainder, ""length"")) {
                return FileExpressionBuilder.fileSizeExpression();
            }
        }
        // date: prefix
        remainder = ifStartsWithReturnRemainder(""date:"", expression);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length != 2) {
                throw new IllegalSyntaxException(this, expression + "" ${date:command:pattern} is the correct syntax."");
            }
            String command = parts[0];
            String pattern = parts[1];
            return FileExpressionBuilder.dateExpression(command, pattern);
        }
        // fallback to simple language if not file specific
        return FileExpressionBuilder.simpleExpression(expression);
    }
}
"
org.apache.camel.impl.PredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision$
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange)  + "" on "" + exchange);
        }
    }
    protected String assertionFailureMessage(E exchange) {
        return toString();
    }
}
"
org.apache.camel.spring.spi.BeanInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
import org.springframework.context.ApplicationContext;
/**
 * Dependeny Injected Bean injector. 
 *
 * @version $Revision$
 * @deprecated not used. Will be removed in Camel 2.0.
 */
public class BeanInjector extends BeanConfigurerSupport {
    public BeanInjector(ApplicationContext applicationContext) throws Exception {
        setBeanFactory(applicationContext);
        afterPropertiesSet();
    }
    public void inject(Object bean) {
        configureBean(bean);
    }
}
"
org.apache.camel.osgi.OsgiLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class OsgiLanguageResolver implements LanguageResolver {
    private static final transient Log LOG = LogFactory.getLog(OsgiLanguageResolver.class);
    public Language resolveLanguage(String name, CamelContext context) {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found language: "" + name + "" in registry: "" + bean);
            }
        } catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Language) {
                return (Language)bean;
            }
            // we do not throw the exception here and try to auto create a Language from OSGI bundle
        }
        // Check in OSGi bundles        
        Class type = null;
        try {
            type = getLanaguage(name);
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type == null) {
            return null;
        }
        if (Language.class.isAssignableFrom(type)) {
            return (Language)context.getInjector().newInstance(type);
        } else {
            throw new IllegalArgumentException(""Type is not a Lanaguage implementation. Found: ""
                                               + type.getName());
        }
    }
    protected Class getLanaguage(String name) throws Exception {
        return Activator.getLanguage(name);
    }
}
"
org.apache.camel.component.list.ListEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.list;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancerConsumer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.apache.camel.spi.BrowsableEndpoint;
/**
 * An endpoint which maintains a {@link List} of {@link Exchange} instances
 * which can be useful for tooling, debugging and visualising routes.
 *
 * @version $Revision$
 */
public class ListEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private List<Exchange> exchanges;
    private TopicLoadBalancer loadBalancer = new TopicLoadBalancer();
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    public ListEndpoint(String uri, CamelContext camelContext) {
        super(uri, camelContext);
        reset();
    }
    public ListEndpoint(String uri, Component component) {
        super(uri, component);
        reset();
    }
    public ListEndpoint(String endpointUri) {
        super(endpointUri);
        reset();
    }
    public boolean isSingleton() {
        return true;
    }
    public List<Exchange> getExchanges() {
        return exchanges;
    }
    public TopicLoadBalancer getLoadBalancer() {
        return loadBalancer;
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new LoadBalancerConsumer(this, processor, loadBalancer);
    }
    public void reset() {
        exchanges = createExchangeList();
    }
    protected List<Exchange> createExchangeList() {
        return new CopyOnWriteArrayList<Exchange>();
    }
    /**
     * Invoked on a message exchange being sent by a producer
     */
    protected void onExchange(Exchange exchange) throws Exception {
        exchanges.add(exchange);
        // lets fire any consumers
        loadBalancer.process(exchange);
    }
}
"
org.apache.camel.language.ExpressionEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if evaluation of the expression failed.
 *
 * @version $Revision$
 */
public class ExpressionEvaluationException extends RuntimeCamelException {
    private final Expression<Exchange> expression;
    private final Exchange exchange;
    public ExpressionEvaluationException(Expression<Exchange> expression, Exchange exchange, Throwable cause) {
        super(cause);
        this.expression = expression;
        this.exchange = exchange;
    }
    public Expression<Exchange> getExpression() {
        return expression;
    }
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.component.bean.XPathAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
import org.apache.camel.language.XPath;
/**
 * Factory for the XPath expression annotations.
 *
 * @version $Revision$
 */
public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
    @Override
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String xpath = getExpressionFromAnnotation(annotation);
        XPathBuilder builder = XPathBuilder.xpath(xpath);
        if (annotation instanceof XPath) {
            XPath xpathAnnotation = (XPath) annotation;
            NamespacePrefix[] namespaces = xpathAnnotation.namespaces();
            if (namespaces != null) {
                for (NamespacePrefix namespacePrefix : namespaces) {
                    builder = builder.namespace(namespacePrefix.prefix(), namespacePrefix.uri());
                }
            }
        }
        return builder;
    }
}
"
org.apache.camel.language.header.HeaderLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.header;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.spi.Language;
/**
 * A language for header expressions.
 */
public class HeaderLanguage implements Language {
    public static Expression<Exchange> header(String headerName) {        
        return ExpressionBuilder.headerExpression(headerName);
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        return HeaderLanguage.header(expression);
    }
}
"
org.apache.camel.bam.rules.TemporalRule,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.Date;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.TimeExpression;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.OutputType;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.Time;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
/**
 * A temporal rule for use within BAM
 *
 * @version $Revision$
 */
public class TemporalRule extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(TemporalRule.class);
    private TimeExpression first;
    private TimeExpression second;
    private long expectedMillis;
    private long overdueMillis;
    private Processor overdueAction;
    private OutputType overdueProcessors = new OutputType();
    public TemporalRule(TimeExpression first, TimeExpression second) {
        this.first = first;
        this.second = second;
    }
    public TemporalRule expectWithin(Time builder) {
        return expectWithin(builder.toMillis());
    }
    public TemporalRule expectWithin(long millis) {
        expectedMillis = millis;
        return this;
    }
    public OutputType errorIfOver(Time builder) {
        return errorIfOver(builder.toMillis());
    }
    public OutputType errorIfOver(long millis) {
        overdueMillis = millis;
        if (overdueProcessors == null) {
            overdueProcessors = new OutputType();
        }
        return overdueProcessors;
    }
    public TimeExpression getFirst() {
        return first;
    }
    public TimeExpression getSecond() {
        return second;
    }
    public Processor getOverdueAction() throws Exception {
        if (overdueAction == null && overdueProcessors != null) {
            // TOOD refactor to avoid this messyness...
            ArrayList<Route> list = new ArrayList<Route>();
            RouteType route = new RouteType();
            route.setCamelContext(first.getBuilder().getProcessBuilder().getContext());
            RouteContext routeContext = new DefaultRouteContext(route, null, list);
            overdueAction = overdueProcessors.createOutputsProcessor(routeContext);
        }
        return overdueAction;
    }
    public void processExchange(Exchange exchange, ProcessInstance instance) {
        Date firstTime = first.evaluate(instance);
        if (firstTime == null) {
            // ignore as first event has not accurred yet
            return;
        }
        // TODO now we might need to set the second activity state
        // to 'grey' to indicate it now could happen?
        // lets force the lazy creation of the second state
        ActivityState secondState = second.getOrCreateActivityState(instance);
        if (expectedMillis > 0L) {
            Date expected = secondState.getTimeExpected();
            if (expected == null) {
                expected = add(firstTime, expectedMillis);
                secondState.setTimeExpected(expected);
            }
        }
        if (overdueMillis > 0L) {
            Date overdue = secondState.getTimeOverdue();
            if (overdue == null) {
                overdue = add(firstTime, overdueMillis);
                secondState.setTimeOverdue(overdue);
            }
        }
    }
    public void processExpired(ActivityState activityState) throws Exception {
        Processor processor = getOverdueAction();
        if (processor != null) {
            Date now = new Date();
/*
            TODO this doesn't work and returns null for some strange reason
            ProcessInstance instance = activityState.getProcessInstance();
            ActivityState secondState = second.getActivityState(instance);
            if (secondState == null) {
                log.error(""Could not find the second state! Process is: "" 
                + instance + "" with first state: "" + first.getActivityState(instance) 
                + "" and the state I was called with was: "" + activityState);
            }
*/
            ActivityState secondState = activityState;
            Date overdue = secondState.getTimeOverdue();
            if (now.compareTo(overdue) >= 0) {
                Exchange exchange = createExchange();
                exchange.getIn().setBody(activityState);
                processor.process(exchange);
            } else {
                LOG.warn(""Process has not actually expired; the time is: "" + now + "" but the overdue time is: "" + overdue);
            }
        }
    }
    protected Exchange createExchange() {
        return new DefaultExchange(second.getBuilder().getProcessBuilder().getContext());
    }
    /**
     * Returns the date in the future adding the given number of millis
     *
     * @param date
     * @param millis
     * @return the date in the future
     */
    protected Date add(Date date, long millis) {
        return new Date(date.getTime() + millis);
    }
    protected void doStart() throws Exception {
        startServices(getOverdueAction());
    }
    protected void doStop() throws Exception {
        stopServices(getOverdueAction());
    }
}
"
org.apache.camel.component.jms.JmsProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.RuntimeExchangeException;
import org.apache.camel.component.jms.JmsConfiguration.CamelJmsTemplate;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.component.jms.requestor.PersistentReplyToRequestor;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.UuidGenerator;
import org.apache.camel.util.ValueHolder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
/**
 * @version $Revision$
 */
public class JmsProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(JmsProducer.class);
    RequestorAffinity affinity;
    private final JmsEndpoint endpoint;
    private JmsOperations inOnlyTemplate;
    private JmsOperations inOutTemplate;
    private UuidGenerator uuidGenerator;
    private DeferredRequestReplyMap deferredRequestReplyMap;
    private Requestor requestor;
    private AtomicBoolean started = new AtomicBoolean(false);
    private enum RequestorAffinity {
        PER_COMPONENT(0),
        PER_ENDPOINT(1),
        PER_PRODUCER(2);
        private int value;
        private RequestorAffinity(int value) {
            this.value = value;
        }
    };
    public JmsProducer(JmsEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        JmsConfiguration c = endpoint.getConfiguration();
        affinity = RequestorAffinity.PER_PRODUCER;
        if (c.getReplyTo() != null) {
            if (c.getReplyToTempDestinationAffinity().equals(c.REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT)) {
                affinity = RequestorAffinity.PER_ENDPOINT;
            } else if (c.getReplyToTempDestinationAffinity().equals(c.REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT)) {
                affinity = RequestorAffinity.PER_COMPONENT;
            }
        }
    }
    public long getRequestTimeout() {
        return endpoint.getRequestTimeout();
    }
    protected void doStart() throws Exception {
        super.doStart();
    }
    protected void testAndSetRequestor() throws RuntimeCamelException {
        if (!started.get()) {
            synchronized (this) {
                if (started.get()) {
                    return;
                }
                try {
                    JmsConfiguration c = endpoint.getConfiguration();
                    if (c.getReplyTo() != null) {
                        requestor = new PersistentReplyToRequestor(endpoint.getConfiguration(), endpoint
                            .getExecutorService());
                        requestor.start();
                    } else {
                        if (affinity == RequestorAffinity.PER_PRODUCER) {
                            requestor = new Requestor(endpoint.getConfiguration(), endpoint
                                .getExecutorService());
                            requestor.start();
                        } else if (affinity == RequestorAffinity.PER_ENDPOINT) {
                            requestor = endpoint.getRequestor();
                        } else if (affinity == RequestorAffinity.PER_COMPONENT) {
                            requestor = ((JmsComponent)endpoint.getComponent()).getRequestor();
                        }
                    }
                } catch (Exception e) {
                    throw new FailedToCreateProducerException(endpoint, e);
                }
                deferredRequestReplyMap = requestor.getDeferredRequestReplyMap(this);
                started.set(true);
            }
        }
    }
    protected void testAndUnsetRequestor() throws Exception  {
        if (started.get()) {
            synchronized (this) {
                if (!started.get()) {
                    return;
                }
                requestor.removeDeferredRequestReplyMap(this);
                if (affinity == RequestorAffinity.PER_PRODUCER) {
                    requestor.stop();
                }
                started.set(false);
            }
        }
    }
    protected void doStop() throws Exception {
        testAndUnsetRequestor();
        super.doStop();
    }
    public void process(final Exchange exchange) {
        final org.apache.camel.Message in = exchange.getIn();
        if (exchange.getPattern().isOutCapable()) {
            testAndSetRequestor();
            // note due to JMS transaction semantics we cannot use a single transaction
            // for sending the request and receiving the response
            final Destination replyTo = requestor.getReplyTo();
            if (replyTo == null) {
                throw new RuntimeExchangeException(""Failed to resolve replyTo destination"", exchange);
            }
            final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();
            String correlationId = in.getHeader(""JMSCorrelationID"", String.class);
            if (correlationId == null && !msgIdAsCorrId) {
                in.setHeader(""JMSCorrelationID"", getUuidGenerator().generateId());
            }
            final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();
            final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;
            final CamelJmsTemplate template = (CamelJmsTemplate)getInOutTemplate();
            template.send(endpoint.getDestination(), new MessageCreator() {
                public Message createMessage(Session session) throws JMSException {
                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);
                    message.setJMSReplyTo(replyTo);
                    requestor.setReplyToSelectorHeader(in, message);
                    FutureTask future = null;
                    future = (!msgIdAsCorrId)
                        ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint
                            .getRequestTimeout()) : requestor.getReceiveFuture(callback);
                    futureHolder.set(future);
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(endpoint + "" sending JMS message: "" + message);
                    }
                    return message;
                }
            }, callback);
            setMessageId(exchange);
            // lets wait and return the response
            long requestTimeout = endpoint.getConfiguration().getRequestTimeout();
            try {
                Message message = null;
                try {
                    if (requestTimeout < 0) {
                        message = (Message)futureHolder.get().get();
                    } else {
                        message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);
                    }
                } catch (InterruptedException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Future interupted: "" + e, e);
                    }
                } catch (TimeoutException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Future timed out: "" + e, e);
                    }
                }
                if (message != null) {
                    exchange.setOut(new JmsMessage(message, endpoint.getBinding()));
                    if (correlationId != null) {
                        message.setJMSCorrelationID(correlationId);
                        exchange.getOut(false).setHeader(""JMSCorrelationID"", correlationId);
                    }
                } else {
                    // lets set a timed out exception
                    exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));
                }
            } catch (Exception e) {
                exchange.setException(e);
            }
        } else {
            getInOnlyTemplate().send(endpoint.getDestination(), new MessageCreator() {
                public Message createMessage(Session session) throws JMSException {
                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(endpoint + "" sending JMS message: "" + message);
                    }
                    return message;
                }
            });
            setMessageId(exchange);
        }
    }
    protected void setMessageId(Exchange exchange) {
        if (!(exchange instanceof JmsExchange)) {
            return;
        }
        try {
            JmsExchange jmsExchange = JmsExchange.class.cast(exchange);
            JmsMessage out = jmsExchange.getOut(false);
            if (out != null) {
                out.setMessageId(out.getJmsMessage().getJMSMessageID());
            }
        } catch (JMSException e) {
            LOG.warn(""Unable to retrieve JMSMessageID from outgoing JMS Message and ""
                     + ""set it into Camel's MessageId"", e);
        }
    }
    /**
     * Preserved for backwards compatibility.
     *
     * @deprecated
     * @see #getInOnlyTemplate()
     */
    public JmsOperations getTemplate() {
        return getInOnlyTemplate();
    }
    public JmsOperations getInOnlyTemplate() {
        if (inOnlyTemplate == null) {
            inOnlyTemplate = endpoint.createInOnlyTemplate();
        }
        return inOnlyTemplate;
    }
    public void setInOnlyTemplate(JmsOperations inOnlyTemplate) {
        this.inOnlyTemplate = inOnlyTemplate;
    }
    public JmsOperations getInOutTemplate() {
        if (inOutTemplate == null) {
            inOutTemplate = endpoint.createInOutTemplate();
        }
        return inOutTemplate;
    }
    public void setInOutTemplate(JmsOperations inOutTemplate) {
        this.inOutTemplate = inOutTemplate;
    }
    public UuidGenerator getUuidGenerator() {
        if (uuidGenerator == null) {
            uuidGenerator = new UuidGenerator();
        }
        return uuidGenerator;
    }
    public void setUuidGenerator(UuidGenerator uuidGenerator) {
        this.uuidGenerator = uuidGenerator;
    }
}
"
org.apache.camel.bam.model.ActivityState,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Date;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import org.apache.camel.bam.processor.ProcessContext;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default state for a specific activity within a process
 *
 * @version $Revision$
 */
@Entity
public class ActivityState extends TemporalEntity {
    private static final transient Log LOG = LogFactory.getLog(ActivityState.class);
    private ProcessInstance processInstance;
    private Integer receivedMessageCount = 0;
    private ActivityDefinition activityDefinition;
    private Date timeExpected;
    @Temporal(TemporalType.TIME)
    private Date timeOverdue;
    private Integer escalationLevel = 0;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""ActivityState["" + getId() + "" on "" + getProcessInstance() + "" "" + getActivityDefinition() + ""]"";
    }
    public synchronized void processExchange(ActivityRules activityRules, ProcessContext context) throws Exception {
        int messageCount = 0;
        Integer count = getReceivedMessageCount();
        if (count != null) {
            messageCount = count.intValue();
        }
        setReceivedMessageCount(++messageCount);
        if (messageCount == 1) {
            onFirstMessage(context);
        }
        int expectedMessages = activityRules.getExpectedMessages();
        if (messageCount == expectedMessages) {
            onExpectedMessage(context);
        } else if (messageCount > expectedMessages) {
            onExcessMessage(context);
        }
    }
    /**
     * Returns true if this state is for the given activity
     */
    public boolean isActivity(ActivityRules activityRules) {
        return ObjectHelper.equal(getActivityDefinition(), activityRules.getActivityDefinition());
    }
    // Properties
    // -----------------------------------------------------------------------
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
        processInstance.getActivityStates().add(this);
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ActivityDefinition getActivityDefinition() {
        return activityDefinition;
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public Integer getEscalationLevel() {
        return escalationLevel;
    }
    public void setEscalationLevel(Integer escalationLevel) {
        this.escalationLevel = escalationLevel;
    }
    public Integer getReceivedMessageCount() {
        return receivedMessageCount;
    }
    public void setReceivedMessageCount(Integer receivedMessageCount) {
        this.receivedMessageCount = receivedMessageCount;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeExpected() {
        return timeExpected;
    }
    public void setTimeExpected(Date timeExpected) {
        this.timeExpected = timeExpected;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeOverdue() {
        return timeOverdue;
    }
    public void setTimeOverdue(Date timeOverdue) {
        this.timeOverdue = timeOverdue;
    }
    public void setTimeCompleted(Date timeCompleted) {
        super.setTimeCompleted(timeCompleted);
        if (timeCompleted != null) {
            setEscalationLevel(-1);
        }
    }
    @Transient
    public String getCorrelationKey() {
        ProcessInstance pi = getProcessInstance();
        if (pi == null) {
            return null;
        }
        return pi.getCorrelationKey();
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    /**
     * Called when the first message is reached
     */
    protected void onFirstMessage(ProcessContext context) {
        if (!isStarted()) {
            setTimeStarted(currentTime());
            context.onStarted(this);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Activity first message: "" + this);
            }
        }
    }
    /**
     * Called when the expected number of messages are is reached
     */
    protected void onExpectedMessage(ProcessContext context) {
        if (!isCompleted()) {
            setTimeCompleted(currentTime());
            // must also clear overdue otherwise we will get failures
            setTimeOverdue(null);
            context.onCompleted(this);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Activity complete: "" + this);
            }
        }
    }
    /**
     * Called when an excess message (after the expected number of messages) are
     * received
     */
    protected void onExcessMessage(ProcessContext context) {
        // TODO
    }
    protected Date currentTime() {
        return new Date();
    }
}
"
org.apache.camel.component.uface.swing.SwingComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.component.uface.UFaceComponent;
import org.ufacekit.ui.swing.databinding.swing.SwingRealm;
/**
 * @version $Revision$
 */
public class SwingComponent extends UFaceComponent {
    public SwingComponent() {
        SwingRealm.createDefault();
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return super.createEndpoint(uri, remaining, parameters);
    }
}
"
org.apache.camel.component.seda.QueueComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.BlockingQueue;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/queue.html"">Queue components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @deprecated This component has been deprecated; please use the seda: URI format instead of queue: 
 * @version $Revision$
 */
public class QueueComponent extends SedaComponent {
    private static final transient Log LOG = LogFactory.getLog(QueueComponent.class);
    public QueueComponent() {
        LOG.warn(""This component has been deprecated; please use the seda: URI format instead of queue:"");
    }
}
"
org.apache.camel.component.jms.MessagePropertyAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -3996286386119163309L;
    private final String propertyName;
    public MessagePropertyAccessException(String propertyName, JMSException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.impl.DefaultLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.NoSuchLanguageException;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
/**
 * Default language resolver that looks for language factories in <b>META-INF/services/org/apache/camel/language/</b> and
 * language resolvers in <b>META-INF/services/org/apache/camel/language/resolver/</b>.
 *
 * @version $Revision$
 */
public class DefaultLanguageResolver implements LanguageResolver {
    protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder(""META-INF/services/org/apache/camel/language/"");
    protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder(""META-INF/services/org/apache/camel/language/resolver/"");
    public Language resolveLanguage(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_FACTORY.findClass(name);
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (Language.class.isAssignableFrom(type)) {
                return (Language)context.getInjector().newInstance(type);
            } else {
                throw new IllegalArgumentException(""Type is not a Language implementation. Found: "" + type.getName());
            }
        }
        return noSpecificLanguageFound(name, context);
    }
    protected Language noSpecificLanguageFound(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_RESOLVER.findClass(""default"");
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (LanguageResolver.class.isAssignableFrom(type)) {
                LanguageResolver resolver = (LanguageResolver)context.getInjector().newInstance(type);
                return resolver.resolveLanguage(name, context);
            } else {
                throw new IllegalArgumentException(""Type is not a LanguageResolver implementation. Found: "" + type.getName());
            }
        }
        throw new NoSuchLanguageException(name);
    }
}
"
org.apache.camel.converter.jaxb.FallbackTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.io.Closeable;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.transform.Source;
import org.apache.camel.Exchange;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision$
 */
public class FallbackTypeConverter implements TypeConverter, TypeConverterAware {
    private static final transient Log LOG = LogFactory.getLog(FallbackTypeConverter.class);
    private TypeConverter parentTypeConverter;
    private boolean prettyPrint = true;
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public void setTypeConverter(TypeConverter parentTypeConverter) {
        this.parentTypeConverter = parentTypeConverter;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        try {
            if (isJaxbType(type)) {
                return unmarshall(type, value);
            }
            if (value != null) {
                if (isJaxbType(value.getClass()) && isNotStreamCacheType(type)) {
                    return marshall(type, value);
                }
            }
            return null;
        } catch (JAXBException e) {
            throw new RuntimeCamelException(e);
        }
    }
    private <T> boolean isNotStreamCacheType(Class<T> type) {
        return !StreamCache.class.isAssignableFrom(type);
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        return convertTo(type, value);
    }
    protected <T> boolean isJaxbType(Class<T> type) {
        XmlRootElement element = type.getAnnotation(XmlRootElement.class);
        boolean jaxbType = element != null;
        return jaxbType;
    }
    /**
     * Lets try parse via JAXB
     */
    protected <T> T unmarshall(Class<T> type, Object value) throws JAXBException {
        JAXBContext context = createContext(type);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        if (parentTypeConverter != null) {
            InputStream inputStream = parentTypeConverter.convertTo(InputStream.class, value);
            if (inputStream != null) {
                Object unmarshalled = unmarshal(unmarshaller, inputStream);
                return type.cast(unmarshalled);
            }
            Reader reader = parentTypeConverter.convertTo(Reader.class, value);
            if (reader != null) {
                Object unmarshalled = unmarshal(unmarshaller, reader);
                return type.cast(unmarshalled);
            }
            Source source = parentTypeConverter.convertTo(Source.class, value);
            if (source != null) {
                Object unmarshalled = unmarshal(unmarshaller, source);
                return type.cast(unmarshalled);
            }
        }
        if (value instanceof String) {
            value = new StringReader((String) value);
        }
        if (value instanceof InputStream || value instanceof Reader) {
            Object unmarshalled = unmarshal(unmarshaller, value);
            return type.cast(unmarshalled);
        }
        return null;
    }
    protected <T> T marshall(Class<T> type, Object value) throws JAXBException {
        if (parentTypeConverter != null) {
            // lets convert the object to a JAXB source and try convert that to
            // the required source
            JAXBContext context = createContext(value.getClass());
            JAXBSource source = new JAXBSource(context, value);
            try {
                return parentTypeConverter.convertTo(type, source);
            } catch (NoTypeConversionAvailableException e) {
                // lets try a stream
                StringWriter buffer = new StringWriter();
                Marshaller marshaller = context.createMarshaller();
                marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, isPrettyPrint() ? Boolean.TRUE : Boolean.FALSE);
                marshaller.marshal(value, buffer);
                return parentTypeConverter.convertTo(type, buffer.toString());
            }
        }
        // lets try convert to the type from JAXB
        return null;
    }
    /**
     * Unmarshals the given value with the unmarshaller
     *
     * @param unmarshaller  the unmarshaller
     * @param value  the stream to unmarshal (will close it after use, also if exception is thrown)
     * @return  the value
     * @throws JAXBException is thrown if an exception occur while unmarshalling
     */
    protected Object unmarshal(Unmarshaller unmarshaller, Object value) throws JAXBException {
        try {
            if (value instanceof InputStream) {
                return unmarshaller.unmarshal((InputStream) value);
            } else if (value instanceof Reader) {
                return unmarshaller.unmarshal((Reader) value);
            } else if (value instanceof Source) {
                return unmarshaller.unmarshal((Source) value);
            }
        } finally {
            if (value instanceof Closeable) {
                ObjectHelper.close((Closeable) value, ""Unmarshalling"", LOG);
            }
        }
        return null;
    }
    protected <T> JAXBContext createContext(Class<T> type) throws JAXBException {
        JAXBContext context = JAXBContext.newInstance(type);
        return context;
    }
}
"
org.apache.camel.component.mina.MinaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
/**
 * A {@link org.apache.camel.Consumer Consumer} implementation for Apache MINA.
 *
 * @version $Revision$
 */
public class MinaConsumer extends DefaultConsumer<MinaExchange> {
    private static final transient Log LOG = LogFactory.getLog(MinaConsumer.class);
    private final MinaEndpoint endpoint;
    private final SocketAddress address;
    private final IoAcceptor acceptor;
    private boolean sync;
    public MinaConsumer(final MinaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.address = endpoint.getAddress();
        this.acceptor = endpoint.getAcceptor();
        this.sync = endpoint.isSync();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (LOG.isInfoEnabled()) {
            LOG.info(""Binding to server address: "" + address + "" using acceptor: "" + acceptor);
        }
        IoHandler handler = new ReceiveHandler();
        acceptor.bind(address, handler, endpoint.getAcceptorConfig());
    }
    @Override
    protected void doStop() throws Exception {
        if (LOG.isInfoEnabled()) {
            LOG.info(""Unbinding from server address: "" + address + "" using acceptor: "" + acceptor);
        }
        acceptor.unbind(address);
        super.doStop();
    }
    /**
     * Handles comsuming messages and replying if the exchange is out capable.
     */
    private final class ReceiveHandler extends IoHandlerAdapter {
        @Override
        public void exceptionCaught(IoSession session, Throwable cause) throws Exception {
            // close invalid session
            if (session != null) {
                LOG.debug(""Closing session as an exception was thrown from MINA"");
                session.close();
            }
            // must wrap and rethrow since cause can be of Throwable and we must only throw Exception
            throw new CamelException(cause);
        }
        @Override
        public void messageReceived(IoSession session, Object object) throws Exception {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Received body: "" + object);
            }
            MinaExchange exchange = endpoint.createExchange(session, object);
            //Set the exchange charset property for converting
            if (endpoint.getCharsetName() != null) {
                exchange.setProperty(Exchange.CHARSET_NAME, endpoint.getCharsetName());
            }
            getProcessor().process(exchange);
            // if sync then we should return a response
            if (sync) {
                Object body;
                if (ExchangeHelper.isOutCapable(exchange)) {
                    body = MinaPayloadHelper.getOut(endpoint, exchange);
                } else {
                    body = MinaPayloadHelper.getIn(endpoint, exchange);
                }
                boolean failed = exchange.isFailed();
                if (failed && !endpoint.isTransferExchange()) {
                    if (exchange.getException() != null) {
                        body = exchange.getException();
                    } else {
                        body = exchange.getFault().getBody();
                    }
                }
                if (body == null) {
                    // must close session if no data to write otherwise client will never receive a response
                    // and wait forever (if not timing out)
                    LOG.warn(""Can not write body since its null, closing session: "" + exchange);
                    session.close();
                } else {
                    // we got a response to write
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Writing body: "" + body);
                    }
                    MinaHelper.writeBody(session, body, exchange);
                }
            }
        }
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.CamelTargetAdapterParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.StringUtils;
/**
 * Parser for the &lt;camelTarget/&gt; element
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelTargetAdapterParser extends AbstractCamelContextBeanDefinitionParaser {
    @Override
    protected Class<?> getBeanClass(Element element) {
        return CamelTargetAdapter.class;
    }
}
"
org.apache.camel.component.mock.MockEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Mock endpoint which provides a literate, fluent API for testing routes
 * using a <a href=""http://jmock.org/"">JMock style</a> API.
 *
 * @version $Revision$
 */
public class MockEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(MockEndpoint.class);
    private int expectedCount;
    private int counter;
    private Processor defaultProcessor;
    private Map<Integer, Processor> processors;
    private List<Exchange> receivedExchanges;
    private List<Throwable> failures;
    private List<Runnable> tests;
    private CountDownLatch latch;
    private long sleepForEmptyTest;
    private long resultWaitTime;
    private long resultMinimumWaitTime;
    private int expectedMinimumCount;
    private List expectedBodyValues;
    private List actualBodyValues;
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    private String headerName;
    private String headerValue;
    private Object actualHeader;
    private Processor reporter;
    public MockEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
        init();
    }
    public MockEndpoint(String endpointUri) {
        super(endpointUri);
        init();
    }
    /**
     * A helper method to resolve the mock endpoint of the given URI on the given context
     *
     * @param context the camel context to try resolve the mock endpoint from
     * @param uri the uri of the endpoint to resolve
     * @return the endpoint
     */
    public static MockEndpoint resolve(CamelContext context, String uri) {
        return CamelContextHelper.getMandatoryEndpoint(context, uri, MockEndpoint.class);
    }
    public static void assertWait(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        long start = System.currentTimeMillis();
        long left = unit.toMillis(timeout);
        long end = start + left;
        for (MockEndpoint endpoint : endpoints) {
            if (!endpoint.await(left, TimeUnit.MILLISECONDS)) {
                throw new AssertionError(""Timeout waiting for endpoints to receive enough messages. "" + endpoint.getEndpointUri() + "" timed out."");
            }
            left = end - System.currentTimeMillis();
            if (left <= 0) {
                left = 0;
            }
        }
    }
    public static void assertIsSatisfied(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        assertWait(timeout, unit, endpoints);
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    public static void assertIsSatisfied(MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    /**
     * Asserts that all the expectations on any {@link MockEndpoint} instances registered
     * in the given context are valid
     *
     * @param context the camel context used to find all the available endpoints to be asserted
     */
    public static void assertIsSatisfied(CamelContext context) throws InterruptedException {
        ObjectHelper.notNull(context, ""camelContext"");
        Collection<Endpoint> endpoints = context.getSingletonEndpoints();
        for (Endpoint endpoint : endpoints) {
            if (endpoint instanceof MockEndpoint) {
                MockEndpoint mockEndpoint = (MockEndpoint) endpoint;
                mockEndpoint.assertIsSatisfied();
            }
        }
    }
    public static void expectsMessageCount(int count, MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            MockEndpoint.expectsMessageCount(count);
        }
    }
    public List<Exchange> getExchanges() {
        return getReceivedExchanges();
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""You cannot consume from this endpoint"");
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) {
                onExchange(exchange);
            }
        };
    }
    public void reset() {
        init();
    }
    // Testing API
    // -------------------------------------------------------------------------
    /**
     * Set the processor that will be invoked when the index
     * message is received.
     *
     * @param index
     * @param processor
     */
    public void whenExchangeReceived(int index, Processor processor) {
        this.processors.put(index, processor);
    }
    /**
     * Set the processor that will be invoked when the some message
     * is received.
     *
     * This processor could be overwritten by
     * {@link #whenExchangeReceived(int, Processor)} method.
     *
     * @param processor
     */
    public void whenAnyExchangeReceived(Processor processor) {
        this.defaultProcessor = processor;
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     */
    public void assertIsSatisfied() throws InterruptedException {
        assertIsSatisfied(sleepForEmptyTest);
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     *
     * @param timeoutForEmptyEndpoints the timeout in milliseconds that we
     *                should wait for the test to be true
     */
    public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {
        LOG.info(""Asserting: "" + this + "" is satisfied"");
        if (expectedCount == 0) {
            if (timeoutForEmptyEndpoints > 0) {
                LOG.debug(""Sleeping for: "" + timeoutForEmptyEndpoints + "" millis to check there really are no messages received"");
                Thread.sleep(timeoutForEmptyEndpoints);
            }
            assertEquals(""Received message count"", expectedCount, getReceivedCounter());
        } else if (expectedCount > 0) {
            if (expectedCount != getReceivedCounter()) {
                waitForCompleteLatch();
            }
            assertEquals(""Received message count"", expectedCount, getReceivedCounter());
        } else if (expectedMinimumCount > 0 && getReceivedCounter() < expectedMinimumCount) {
            waitForCompleteLatch();
        }
        if (expectedMinimumCount >= 0) {
            int receivedCounter = getReceivedCounter();
            assertTrue(""Received message count "" + receivedCounter + "", expected at least "" + expectedMinimumCount, expectedMinimumCount <= receivedCounter);
        }
        for (Runnable test : tests) {
            test.run();
        }
        for (Throwable failure : failures) {
            if (failure != null) {
                LOG.error(""Caught on "" + getEndpointUri() + "" Exception: "" + failure, failure);
                fail(""Failed due to caught exception: "" + failure);
            }
        }
    }
    /**
     * Validates that the assertions fail on this endpoint
     */
    public void assertIsNotSatisfied() throws InterruptedException {
        try {
            assertIsSatisfied();
            fail(""Expected assertion failure!"");
        } catch (AssertionError e) {
            LOG.info(""Caught expected failure: "" + e);
        }
    }
    /**
     * Specifies the expected number of message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMessageCount(int expectedCount) {
        setExpectedMessageCount(expectedCount);
    }
    /**
     * Specifies the minimum number of expected message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMinimumMessageCount(int expectedCount) {
        setMinimumExpectedMessageCount(expectedCount);
    }
    /**
     * Adds an expectation that the given header name & value are received by this
     * endpoint
     */
    public void expectedHeaderReceived(String name, String value) {
        this.headerName = name;
        this.headerValue = value;
        expects(new Runnable() {
            public void run() {
                assertTrue(""No header with name "" + headerName + "" found."", actualHeader != null);
                assertEquals(""Header of message"", headerValue, actualHeader);
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint in the specified order
     */
    public void expectedBodiesReceived(final List bodies) {
        expectedMessageCount(bodies.size());
        this.expectedBodyValues = bodies;
        this.actualBodyValues = new ArrayList();
        expects(new Runnable() {
            public void run() {
                for (int i = 0; i < expectedBodyValues.size(); i++) {
                    Exchange exchange = getReceivedExchanges().get(i);
                    assertTrue(""No exchange received for counter: "" + i, exchange != null);
                    Object expectedBody = expectedBodyValues.get(i);
                    Object actualBody = null;
                    if (i < actualBodyValues.size()) {
                        actualBody = actualBodyValues.get(i);
                    }
                    assertEquals(""Body of message: "" + i, expectedBody, actualBody);
                }
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint
     */
    public void expectedBodiesReceived(Object... bodies) {
        List bodyList = new ArrayList();
        bodyList.addAll(Arrays.asList(bodies));
        expectedBodiesReceived(bodyList);
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint in any order
     */
    public void expectedBodiesReceivedInAnyOrder(final List bodies) {
        expectedMessageCount(bodies.size());
        this.expectedBodyValues = bodies;
        this.actualBodyValues = new ArrayList();
        expects(new Runnable() {
            public void run() {
                Set actualBodyValuesSet = new HashSet(actualBodyValues);
                for (int i = 0; i < expectedBodyValues.size(); i++) {
                    Exchange exchange = getReceivedExchanges().get(i);
                    assertTrue(""No exchange received for counter: "" + i, exchange != null);
                    Object expectedBody = expectedBodyValues.get(i);
                    assertTrue(""Message with body "" + expectedBody
                            + "" was expected but not found in "" + actualBodyValuesSet,
                            actualBodyValuesSet.remove(expectedBody));
                }
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint in any order
     */
    public void expectedBodiesReceivedInAnyOrder(Object... bodies) {
        List bodyList = new ArrayList();
        bodyList.addAll(Arrays.asList(bodies));
        expectedBodiesReceivedInAnyOrder(bodyList);
    }
    /**
     * Adds an expectation that messages received should have ascending values
     * of the given expression such as a user generated counter value
     *
     * @param expression
     */
    public void expectsAscending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesAscending(expression);
            }
        });
    }
    /**
     * Adds an expectation that messages received should have descending values
     * of the given expression such as a user generated counter value
     *
     * @param expression
     */
    public void expectsDescending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesDescending(expression);
            }
        });
    }
    /**
     * Adds an expectation that no duplicate messages should be received using
     * the expression to determine the message ID
     *
     * @param expression the expression used to create a unique message ID for
     *                message comparison (which could just be the message
     *                payload if the payload can be tested for uniqueness using
     *                {@link Object#equals(Object)} and
     *                {@link Object#hashCode()}
     */
    public void expectsNoDuplicates(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertNoDuplicates(expression);
            }
        });
    }
    /**
     * Asserts that the messages have ascending values of the given expression
     */
    public void assertMessagesAscending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, true);
    }
    /**
     * Asserts that the messages have descending values of the given expression
     */
    public void assertMessagesDescending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, false);
    }
    protected void assertMessagesSorted(Expression<Exchange> expression, boolean ascending) {
        String type = ascending ? ""ascending"" : ""descending"";
        ExpressionComparator comparator = new ExpressionComparator(expression);
        List<Exchange> list = getReceivedExchanges();
        for (int i = 1; i < list.size(); i++) {
            int j = i - 1;
            Exchange e1 = list.get(j);
            Exchange e2 = list.get(i);
            int result = comparator.compare(e1, e2);
            if (result == 0) {
                fail(""Messages not "" + type + "". Messages"" + j + "" and "" + i + "" are equal with value: "" + expression.evaluate(e1) + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and ""
                     + e2);
            } else {
                if (!ascending) {
                    result = result * -1;
                }
                if (result > 0) {
                    fail(""Messages not "" + type + "". Message "" + j + "" has value: "" + expression.evaluate(e1) + "" and message "" + i + "" has value: "" + expression.evaluate(e2) + "" for expression: ""
                         + expression + "". Exchanges: "" + e1 + "" and "" + e2);
                }
            }
        }
    }
    public void assertNoDuplicates(Expression<Exchange> expression) {
        Map<Object, Exchange> map = new HashMap<Object, Exchange>();
        List<Exchange> list = getReceivedExchanges();
        for (int i = 0; i < list.size(); i++) {
            Exchange e2 = list.get(i);
            Object key = expression.evaluate(e2);
            Exchange e1 = map.get(key);
            if (e1 != null) {
                fail(""Duplicate message found on message "" + i + "" has value: "" + key + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and "" + e2);
            } else {
                map.put(key, e2);
            }
        }
    }
    /**
     * Adds the expectation which will be invoked when enough messages are
     * received
     */
    public void expects(Runnable runnable) {
        tests.add(runnable);
    }
    /**
     * Adds an assertion to the given message index
     *
     * @param messageIndex the number of the message
     * @return the assertion clause
     */
    public AssertionClause message(final int messageIndex) {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                applyAssertionOn(MockEndpoint.this, messageIndex, assertExchangeReceived(messageIndex));
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Adds an assertion to all the received messages
     *
     * @return the assertion clause
     */
    public AssertionClause allMessages() {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                List<Exchange> list = getReceivedExchanges();
                int index = 0;
                for (Exchange exchange : list) {
                    applyAssertionOn(MockEndpoint.this, index++, exchange);
                }
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Asserts that the given index of message is received (starting at zero)
     */
    public Exchange assertExchangeReceived(int index) {
        int count = getReceivedCounter();
        assertTrue(""Not enough messages received. Was: "" + count, count > index);
        return getReceivedExchanges().get(index);
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<Throwable> getFailures() {
        return failures;
    }
    public int getReceivedCounter() {
        return getReceivedExchanges().size();
    }
    public List<Exchange> getReceivedExchanges() {
        return receivedExchanges;
    }
    public int getExpectedCount() {
        return expectedCount;
    }
    public long getSleepForEmptyTest() {
        return sleepForEmptyTest;
    }
    /**
     * Allows a sleep to be specified to wait to check that this endpoint really
     * is empty when {@link #expectedMessageCount(int)} is called with zero
     *
     * @param sleepForEmptyTest the milliseconds to sleep for to determine that
     *                this endpoint really is empty
     */
    public void setSleepForEmptyTest(long sleepForEmptyTest) {
        this.sleepForEmptyTest = sleepForEmptyTest;
    }
    public long getResultWaitTime() {
        return resultWaitTime;
    }
    /**
     * Sets the maximum amount of time (in millis) the {@link #assertIsSatisfied()} will
     * wait on a latch until it is satisfied
     */
    public void setResultWaitTime(long resultWaitTime) {
        this.resultWaitTime = resultWaitTime;
    }
    /**
     * Sets the minimum expected amount of time (in millis) the {@link #assertIsSatisfied()} will
     * wait on a latch until it is satisfied
     */
    public void setMinimumResultWaitTime(long resultMinimumWaitTime) {
        this.resultMinimumWaitTime = resultMinimumWaitTime;
    }
    /**
     * Specifies the expected number of message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void setExpectedMessageCount(int expectedCount) {
        this.expectedCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedCount);
        }
    }
    /**
     * Specifies the minimum number of expected message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void setMinimumExpectedMessageCount(int expectedCount) {
        this.expectedMinimumCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedMinimumCount);
        }
    }
    public Processor getReporter() {
        return reporter;
    }
    /**
     * Allows a processor to added to the endpoint to report on progress of the test
     */
    public void setReporter(Processor reporter) {
        this.reporter = reporter;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    private void init() {
        expectedCount = -1;
        counter = 0;
        processors = new HashMap<Integer, Processor>();
        receivedExchanges = new CopyOnWriteArrayList<Exchange>();
        failures = new CopyOnWriteArrayList<Throwable>();
        tests = new CopyOnWriteArrayList<Runnable>();
        latch = null;
        sleepForEmptyTest = 0;
        resultWaitTime = 20000L;
        resultMinimumWaitTime = 0L;
        expectedMinimumCount = -1;
        expectedBodyValues = null;
        actualBodyValues = new ArrayList();
    }
    protected synchronized void onExchange(Exchange exchange) {
        try {
            if (reporter != null) {
                reporter.process(exchange);
            }
            performAssertions(exchange);
        } catch (Throwable e) {
            failures.add(e);
        }
        if (latch != null) {
            latch.countDown();
        }
    }
    protected void performAssertions(Exchange exchange) throws Exception {
        Message in = exchange.getIn();
        Object actualBody = in.getBody();
        if (headerName != null) {
            actualHeader = in.getHeader(headerName);
        }
        if (expectedBodyValues != null) {
            int index = actualBodyValues.size();
            if (expectedBodyValues.size() > index) {
                Object expectedBody = expectedBodyValues.get(index);
                if (expectedBody != null) {
                    actualBody = in.getBody(expectedBody.getClass());
                }
                actualBodyValues.add(actualBody);
            }
        }
        LOG.debug(getEndpointUri() + "" >>>> "" + (++counter) + "" : "" + exchange + "" with body: "" + actualBody);
        receivedExchanges.add(exchange);
        Processor processor = processors.get(getReceivedCounter()) != null
                ? processors.get(getReceivedCounter()) : defaultProcessor;
        if (processor != null) {
            processor.process(exchange);
        }
    }
    protected void waitForCompleteLatch() throws InterruptedException {
        if (latch == null) {
            fail(""Should have a latch!"");
        }
        // now lets wait for the results
        LOG.debug(""Waiting on the latch for: "" + resultWaitTime + "" millis"");
        long start = System.currentTimeMillis();
        latch.await(resultWaitTime, TimeUnit.MILLISECONDS);
        long delta = System.currentTimeMillis() - start;
        LOG.debug(""Took "" + delta + "" millis to complete latch"");
        if (resultMinimumWaitTime > 0 && delta < resultMinimumWaitTime) {
            fail(""Expected minimum "" + resultWaitTime
                    + "" millis waiting on the result, but was faster with "" + delta + "" millis."");
        }
    }
    protected void assertEquals(String message, Object expectedValue, Object actualValue) {
        if (!ObjectHelper.equal(expectedValue, actualValue)) {
            fail(message + "". Expected: <"" + expectedValue + ""> but was: <"" + actualValue + "">"");
        }
    }
    protected void assertTrue(String message, boolean predicate) {
        if (!predicate) {
            fail(message);
        }
    }
    protected void fail(Object message) {
        if (LOG.isDebugEnabled()) {
            List<Exchange> list = getReceivedExchanges();
            int index = 0;
            for (Exchange exchange : list) {
                LOG.debug(""Received["" + (++index) + ""]: "" + exchange);
            }
        }
        throw new AssertionError(getEndpointUri() + "" "" + message);
    }
    public int getExpectedMinimumCount() {
        return expectedMinimumCount;
    }
    public void await() throws InterruptedException {
        if (latch != null) {
            latch.await();
        }
    }
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        if (latch != null) {
            return latch.await(timeout, unit);
        }
        return true;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.impl.converter.DefaultTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Exchange;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * Default implementation of a type converter registry used for
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">type converters</a> in Camel.
 *
 * @version $Revision$
 */
public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistry {
    private static final transient Log LOG = LogFactory.getLog(DefaultTypeConverter.class);
    private final Map<TypeMapping, TypeConverter> typeMappings = new ConcurrentHashMap<TypeMapping, TypeConverter>();
    private Injector injector;
    private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
    private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
    private boolean loaded;
    public DefaultTypeConverter(Injector injector) {
        typeConverterLoaders.add(new AnnotationTypeConverterLoader());
        this.injector = injector;
        addFallbackConverter(new AsyncProcessorTypeConverter());
        addFallbackConverter(new PropertyEditorTypeConverter());
        addFallbackConverter(new ToStringTypeConverter());
        addFallbackConverter(new ArrayTypeConverter());
        addFallbackConverter(new EnumTypeConverter());
    }
    public List<TypeConverterLoader> getTypeConverterLoaders() {
        return typeConverterLoaders;
    }    
    public <T> T convertTo(Class<T> type, Object value) {
        return convertTo(type, null, value);
    }
    @SuppressWarnings(""unchecked"")
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Converting "" + (value == null ? ""null"" : value.getClass().getCanonicalName())
                + "" -> "" + type.getCanonicalName() + "" with value: "" + value);
        }
        if (value == null) {
            // lets avoid NullPointerException when converting to boolean for null values
            if (boolean.class.isAssignableFrom(type)) {
                return (T) Boolean.FALSE;
            }
            return null;
        }
        // same instance type
        if (type.isInstance(value)) {
            return type.cast(value);
        }
        // make sure we have loaded the converters
        checkLoaded();
        // try to find a suitable type converter
        TypeConverter converter = getOrFindTypeConverter(type, value);
        if (converter != null) {
            T rc = converter.convertTo(type, exchange, value);
            if (rc != null) {
                return rc;
            }
        }
        // fallback converters
        for (TypeConverter fallback : fallbackConverters) {
            T rc = fallback.convertTo(type, exchange, value);
            if (rc != null) {
                return rc;
            }
        }
        // primitives
        if (type.isPrimitive()) {
            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);
            if (primitiveType != type) {
                return (T) convertTo(primitiveType, exchange, value);
            }
        }
        // Could not find suitable conversion
        throw new NoTypeConversionAvailableException(value, type);
    }
    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            TypeConverter converter = typeMappings.get(key);
            if (converter != null) {
                LOG.warn(""Overriding type converter from: "" + converter + "" to: "" + typeConverter);
            }
            typeMappings.put(key, typeConverter);
        }
    }
    public void addFallbackConverter(TypeConverter converter) {
        fallbackConverters.add(converter);
        if (converter instanceof TypeConverterAware) {
            TypeConverterAware typeConverterAware = (TypeConverterAware)converter;
            typeConverterAware.setTypeConverter(this);
        }
    }
    public TypeConverter getTypeConverter(Class toType, Class fromType) {
        TypeMapping key = new TypeMapping(toType, fromType);
        return typeMappings.get(key);
    }
    public Injector getInjector() {
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    protected <T> TypeConverter getOrFindTypeConverter(Class toType, Object value) {
        Class fromType = null;
        if (value != null) {
            fromType = value.getClass();
        }
        TypeMapping key = new TypeMapping(toType, fromType);
        TypeConverter converter;
        synchronized (typeMappings) {
            converter = typeMappings.get(key);
            if (converter == null) {
                converter = findTypeConverter(toType, fromType, value);
                if (converter != null) {
                    typeMappings.put(key, converter);
                }
            }
        }
        return converter;
    }
    /**
     * Tries to auto-discover any available type converters
     */
    protected TypeConverter findTypeConverter(Class toType, Class fromType, Object value) {
        // lets try the super classes of the from type
        if (fromType != null) {
            Class fromSuperClass = fromType.getSuperclass();
            if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                if (converter == null) {
                    converter = findTypeConverter(toType, fromSuperClass, value);
                }
                if (converter != null) {
                    return converter;
                }
            }
            for (Class type : fromType.getInterfaces()) {
                TypeConverter converter = getTypeConverter(toType, type);
                if (converter != null) {
                    return converter;
                }
            }
            // lets test for arrays
            if (fromType.isArray() && !fromType.getComponentType().isPrimitive()) {
                // TODO can we try walking the inheritance-tree for the element types?
                if (!fromType.equals(Object[].class)) {
                    fromSuperClass = Object[].class;
                    TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                    if (converter == null) {
                        converter = findTypeConverter(toType, fromSuperClass, value);
                    }
                    if (converter != null) {
                        return converter;
                    }
                }
            }
            // lets test for Object based converters
            if (!fromType.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, Object.class);
                if (converter != null) {
                    return converter;
                }
            }
        }
        // lets try classes derived from this toType
        if (fromType != null) {
            Set<Map.Entry<TypeMapping, TypeConverter>> entries = typeMappings.entrySet();
            for (Map.Entry<TypeMapping, TypeConverter> entry : entries) {
                TypeMapping key = entry.getKey();
                Class aToType = key.getToType();
                if (toType.isAssignableFrom(aToType)) {
                    if (key.getFromType().isAssignableFrom(fromType)) {
                        return entry.getValue();
                    }
                }
            }
        }
        // TODO look at constructors of toType?
        return null;
    }
    /**
     * Checks if the registry is loaded and if not lazily load it
     */
    protected synchronized void checkLoaded() {
        if (!loaded) {
            loaded = true;
            try {
                for (TypeConverterLoader typeConverterLoader : typeConverterLoaders) {
                    typeConverterLoader.load(this);
                }
                // lets try load any other fallback converters
                try {
                    loadFallbackTypeConverters();
                } catch (NoFactoryAvailableException e) {
                    // ignore its fine to have none
                }
            } catch (Exception e) {
                throw wrapRuntimeCamelException(e);
            }
        }
    }
    protected void loadFallbackTypeConverters() throws IOException, ClassNotFoundException {
        FactoryFinder finder = new FactoryFinder();
        List<TypeConverter> converters = finder.newInstances(""FallbackTypeConverter"", getInjector(),
                                                             TypeConverter.class);
        for (TypeConverter converter : converters) {
            addFallbackConverter(converter);
        }
    }
    /**
     * Represents a mapping from one type (which can be null) to another
     */
    protected static class TypeMapping {
        Class toType;
        Class fromType;
        public TypeMapping(Class toType, Class fromType) {
            this.toType = toType;
            this.fromType = fromType;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return ObjectHelper.equal(this.fromType, that.fromType)
                       && ObjectHelper.equal(this.toType, that.toType);
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType + ""=>"" + toType + ""]"";
        }
    }
}
"
org.apache.camel.component.mail.MailComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.ObjectHelper;
/**
 * Component for JavaMail.
 *
 * @version $Revision:520964 $
 */
public class MailComponent extends DefaultComponent<MailExchange> implements HeaderFilterStrategyAware {
    private MailConfiguration configuration;
    private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy();
    public MailComponent() {
        this.configuration = new MailConfiguration();
    }
    public MailComponent(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    public MailComponent(CamelContext context) {
        super(context);
        this.configuration = new MailConfiguration();
    }
    /**
     * Static builder method
     *
     * @deprecated will be removed in Camel 2.0
     */
    public static MailComponent mailComponent() {
        return new MailComponent();
    }
    /**
     * Static builder method
     *
     * @deprecated will be removed in Camel 2.0
     */
    public static MailComponent mailComponent(MailConfiguration configuration) {
        return new MailComponent(configuration);
    }
    @Override
    protected Endpoint<MailExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI url = new URI(uri);
        if (""nntp"".equalsIgnoreCase(url.getScheme())) {
            throw new UnsupportedOperationException(""nntp protocol is not supported"");
        }
        // must use copy as each endpoint can have different options
        ObjectHelper.notNull(configuration, ""configuration"");
        MailConfiguration config = configuration.copy();
        // only configure if we have a url with a known protocol
        config.configure(url);
        MailEndpoint endpoint = new MailEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        // sanity check that we know the mail server
        ObjectHelper.notEmpty(config.getHost(), ""host"");
        ObjectHelper.notEmpty(config.getProtocol(), ""protocol"");
        if (config.getPort() <= 0) {
            throw new IllegalArgumentException(""port mut be specified"");
        }
        return endpoint;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
    /**
     * Sets the Mail configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the actual Mail destination name
     * (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.language.groovy.GroovyRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.GroovyShell;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision$
 */
public abstract class GroovyRouteBuilder extends RouteBuilder {
    public GroovyRouteBuilder() {
        init();
    }
    public GroovyRouteBuilder(CamelContext context) {
        super(context);
        init();
    }
    private void init() {
        ClassLoader loader = getClass().getClassLoader();
        GroovyShell shell = new GroovyShell(loader);
        shell.evaluate(loader.getResourceAsStream(""org/apache/camel/language/groovy/ConfigureCamel.groovy""));
        // TODO compile Groovy as part of build!
        //new ConfigureCamel().run();
    }
}
"
org.apache.camel.component.file.remote.SftpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Vector;
import java.util.concurrent.ScheduledExecutorService;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.apache.camel.Processor;
import org.apache.camel.component.file.FileComponent;
public class SftpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private final SftpEndpoint endpoint;
    private ChannelSftp channel;
    private Session session;
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, Session session) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.session = session;
    }
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, Session session, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.session = session;
    }
    protected void doStart() throws Exception {
        log.info(""Starting"");
        super.doStart();
    }
    protected void doStop() throws Exception {
        log.info(""Stopping"");
        // disconnect when stopping
        try {
            disconnect();
        } catch (Exception e) {
            // ignore just log a warning
            log.warn(""Exception occured during disconecting from "" + remoteServer() + "". ""
                     + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
        }
        super.doStop();
    }
    protected void connectIfNecessary() throws JSchException {
        if (channel == null || !channel.isConnected()) {
            if (session == null || !session.isConnected()) {
                log.trace(""Session isn't connected, trying to recreate and connect."");
                session = endpoint.createSession();
                session.connect();
            }
            log.trace(""Channel isn't connected, trying to recreate and connect."");
            channel = endpoint.createChannelSftp(session);
            channel.connect();
            log.info(""Connected to "" + remoteServer());
        }
    }
    protected void disconnect() throws JSchException {
        log.debug(""Disconnecting from "" + remoteServer());
        if (session != null) {
            session.disconnect();
        }
        if (channel != null) {
            channel.disconnect();
        }
    }
    protected void poll() throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Polling "" + endpoint.getConfiguration());
        }
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't poll
        try {
            final String fileName = endpoint.getConfiguration().getFile();
            if (endpoint.getConfiguration().isDirectory()) {
                pollDirectory(fileName);
            } else {
                int index = fileName.lastIndexOf('/');
                if (index > -1) {
                    // cd to the folder of the filename
                    channel.cd(fileName.substring(0, index));
                }
                // list the files in the fold and poll the first file
                final Vector files = channel.ls(fileName.substring(index + 1));
                final ChannelSftp.LsEntry file = (ChannelSftp.LsEntry) files.get(0);
                pollFile(file);
            }
            lastPollTime = System.currentTimeMillis();
        } catch (Exception e) {
            if (isStopping() || isStopped()) {
                // if we are stopping then ignore any exception during a poll
                log.warn(""Consumer is stopping. Ignoring caught exception: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
            } else {
                log.warn(""Exception occured during polling: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
                disconnect();
                // Rethrow to signify that we didn't poll
                throw e;
            }
        }
    }
    protected void pollDirectory(String dir) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Polling directory: "" + dir);
        }
        String currentDir = channel.pwd();
        channel.cd(dir);
        Vector files = channel.ls(""."");
        for (int i = 0; i < files.size(); i++) {
            ChannelSftp.LsEntry sftpFile = (ChannelSftp.LsEntry)files.get(i);
            if (sftpFile.getFilename().startsWith(""."")) {
                // skip
            } else if (sftpFile.getAttrs().isDir()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(sftpFile));
                }
            } else {
                pollFile(sftpFile);
            }
        }
        // change back to original current dir
        channel.cd(currentDir);
    }
    protected String getFullFileName(ChannelSftp.LsEntry sftpFile) throws IOException, SftpException {
        return channel.pwd() + ""/"" + sftpFile.getFilename();
    }
    private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Polling file: "" + sftpFile);
        }
        // if using last polltime for timestamp matcing (to be removed in Camel 2.0)
        boolean timestampMatched = true;
        if (isTimestamp()) {
            // TODO do we need to adjust the TZ? can we?
            long ts = sftpFile.getAttrs().getMTime() * 1000L;
            timestampMatched = ts > lastPollTime;
            if (log.isTraceEnabled()) {
                log.trace(""The file is to old + "" + sftpFile + "". lastPollTime="" + lastPollTime + "" > fileTimestamp="" + ts);
            }
        }
        if (timestampMatched && isMatched(sftpFile)) {
            String fullFileName = getFullFileName(sftpFile);
            // is we use excluse read then acquire the exclusive read (waiting until we got it)
            if (exclusiveReadLock) {
                acquireExclusiveReadLock(sftpFile);
            }
            // retrieve the file
            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            channel.get(sftpFile.getFilename(), byteArrayOutputStream);
            if (log.isDebugEnabled()) {
                log.debug(""Retrieved file: "" + sftpFile.getFilename() + "" from: "" + remoteServer());
            }
            RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile),
                    sftpFile.getFilename(), sftpFile.getAttrs().getSize(), byteArrayOutputStream);
            if (isSetNames()) {
                String ftpBasePath = endpoint.getConfiguration().getFile();
                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);
                relativePath = relativePath.replaceFirst(""/"", """");
                if (log.isDebugEnabled()) {
                    log.debug(""Setting exchange filename to "" + relativePath);
                }
                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
            }
            if (deleteFile) {
                // delete file after consuming
                if (log.isDebugEnabled()) {
                    log.debug(""Deleteing file: "" + sftpFile.getFilename() + "" from: "" + remoteServer());
                }
                deleteFile(sftpFile.getFilename());
            } else if (isMoveFile()) {
                String fromName = sftpFile.getFilename();
                String toName = getMoveFileName(fromName, exchange);
                if (log.isDebugEnabled()) {
                    log.debug(""Moving file: "" + fromName + "" to: "" + toName);
                }
                // delete any existing file
                boolean deleted = deleteFile(toName);
                if (!deleted) {
                    // if we could not delete any existing file then maybe the folder is missing
                    // build folder if needed
                    int lastPathIndex = toName.lastIndexOf('/');
                    if (lastPathIndex != -1) {
                        String directory = toName.substring(0, lastPathIndex);
                        if (!SftpUtils.buildDirectory(channel, directory)) {
                            log.warn(""Can not build directory: "" + directory + "" (maybe because of denied permissions)"");
                        }
                    }
                }
                // try to rename
                try {
                    channel.rename(fromName, toName);
                } catch (SftpException e) {
                    // ignore just log a warning
                    log.warn(""Can not move file: "" + fromName + "" to: "" + toName);
                }
            }
            getProcessor().process(exchange);
        }
    }
    private boolean deleteFile(String filename) {
        try {
            channel.rm(filename);
            return true;
        } catch (SftpException e) {
            // ignore just log a warning
            log.warn(""Could not delete file: "" + filename + "" from: "" + remoteServer());
            return false;
        }
    }
    protected void acquireExclusiveReadLock(ChannelSftp.LsEntry sftpFile) throws SftpException {
        if (log.isTraceEnabled()) {
            log.trace(""Waiting for exclusive read lock to file: "" + sftpFile);
        }
        // the trick is to try to rename the file, if we can rename then we have exclusive read
        // since its a remote file we can not use java.nio to get a RW access
        String originalName = sftpFile.getFilename();
        String newName = originalName + "".camelExclusiveReadLock"";
        boolean exclusive = false;
        while (!exclusive) {
            try {
                channel.rename(originalName, newName);
                exclusive = true;
            } catch (SftpException e) {
                // ignore we can not rename it
            }
            if (exclusive) {
                if (log.isDebugEnabled()) {
                    log.debug(""Acquired exclusive read lock to file: "" + originalName);
                }
                // rename it back so we can read it
                channel.rename(newName, originalName);
            } else {
                log.trace(""Exclusive read lock not granted. Sleeping for 1000 millis"");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }
    }
    protected String getFileName(Object file) {
        ChannelSftp.LsEntry sftpFile = (ChannelSftp.LsEntry) file;
        return sftpFile.getFilename();
    }
}
"
org.apache.camel.spring.CamelTemplateFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultProducerTemplate;
import org.apache.camel.model.IdentifiedType;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
/**
 * A Spring {@link FactoryBean} for creating a new {@link org.apache.camel.ProducerTemplate}
 * instance with a minimum of XML
 * 
 * @version $Revision$
 */
@XmlRootElement(name = ""template"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelTemplateFactoryBean extends IdentifiedType implements FactoryBean, InitializingBean, CamelContextAware {
    @XmlAttribute(required = false)
    private String defaultEndpoint;
    @XmlTransient
    private CamelContext camelContext;
    public void afterPropertiesSet() throws Exception {
        if (camelContext == null) {
            throw new IllegalArgumentException(""A CamelContext must be injected!"");
        }
    }
    public Object getObject() throws Exception {
        CamelContext context = getCamelContext();
        if (defaultEndpoint != null) {
            Endpoint endpoint = context.getEndpoint(defaultEndpoint);
            if (endpoint == null) {
                throw new IllegalArgumentException(""No endpoint found for URI: "" + defaultEndpoint);
            } else {
                return new DefaultProducerTemplate(context, endpoint);
            }
        }
        return new DefaultProducerTemplate(context);
    }
    public Class getObjectType() {
        return DefaultProducerTemplate.class;
    }
    public boolean isSingleton() {
        return true;
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getDefaultEndpoint() {
        return defaultEndpoint;
    }
    /**
     * Sets the default endpoint URI used by default for sending message
     * exchanges
     */
    public void setDefaultEndpoint(String defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
}
"
org.apache.camel.AsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A more complex version of {@link Processor} which supports asynchronous
 * processing of the {@link Exchange}.  Any processor can be coerced to
 * have an {@link AsyncProcessor} interface by using the
 * {@link org.apache.camel.impl.converter.AsyncProcessorTypeConverter#convert AsyncProcessorTypeConverter.covert}
 * method.
 * 
 * @version $Revision$
 */
public interface AsyncProcessor extends Processor {
    /**
     * Processes the message exchange.  Similar to {@link Processor#process}, but
     * the caller supports having the exchange asynchronously processed.
     *
     * @param exchange the {@link Exchange} to process
     * @param  callback the {@link AsyncCallback} will be invoked when the processing
     *         of the exchange is completed. If the exchange is completed synchronously, then the 
     *         callback is also invoked synchronously.  The callback should therefore be careful of
     *         starting recursive loop.
     *         
     * @return true if the processing was completed synchronously.
     */
    boolean process(Exchange exchange, AsyncCallback callback);
}
"
org.apache.camel.Intercept,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An interface which provides the processing logic as a pluggable processor
 *
 * @version $Revision$
 */
public interface Intercept {
    Processor getInterceptorLogic();
    void setInterceptorLogic(Processor interceptorLogic);
}
"
org.apache.camel.component.jms.requestor.MessageSelectorProvider,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.HashMap;
import java.util.Map;
public class MessageSelectorProvider {
    protected Map<String, String> correlationIds;
    protected boolean dirty = true;
    protected StringBuilder expression;
    public MessageSelectorProvider() {
        correlationIds = new HashMap<String, String>();
    }
    public synchronized void addCorrelationID(String id) {
        correlationIds.put(id, id);
        dirty = true;
    }
    public synchronized void removeCorrelationID(String id) {
        correlationIds.remove(id);
        dirty = true;
    }
    public synchronized String get() {
        if (!dirty) {
            return expression.toString();
        }
        expression = new StringBuilder(""JMSCorrelationID='"");
        boolean first = true;
        for (Map.Entry<String, String> entry : correlationIds.entrySet()) {
            if (!first) {
                expression.append("" OR JMSCorrelationID='"");
            }
            expression.append(entry.getValue()).append(""'"");
            if (first) {
                first = false;
            }
        }
        dirty = false;
        return expression.toString();
    }
}
"
org.apache.camel.component.jhc.JhcMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import org.apache.camel.impl.DefaultMessage;
public class JhcMessage extends DefaultMessage {
}"
org.apache.camel.impl.DefaultExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.UuidGenerator;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A default implementation of {@link Exchange}
 *
 * @version $Revision$
 */
public class DefaultExchange implements Exchange {
    private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator();
    protected final CamelContext context;
    private Map<String, Object> properties;
    private Message in;
    private Message out;
    private Message fault;
    private Throwable exception;
    private String exchangeId;
    private UnitOfWork unitOfWork;
    private ExchangePattern pattern;
    public DefaultExchange(CamelContext context) {
        this(context, ExchangePattern.InOnly);
    }
    public DefaultExchange(CamelContext context, ExchangePattern pattern) {
        this.context = context;
        this.pattern = pattern;
    }
    public DefaultExchange(DefaultExchange parent) {
        this(parent.getContext(), parent.getPattern());
        this.unitOfWork = parent.getUnitOfWork();
    }
    @Override
    public String toString() {
        return ""Exchange["" + in + ""]"";
    }
    public Exchange copy() {
        Exchange exchange = newInstance();
        exchange.copyFrom(this);
        return exchange;
    }
    public void copyFrom(Exchange exchange) {
        if (exchange == this) {
            return;
        }
        setProperties(safeCopy(exchange.getProperties()));
        // this can cause strangeness if we copy, say, a FileMessage onto an FtpExchange with overloaded getExchange() methods etc.
        safeCopy(getIn(), exchange, exchange.getIn());
        Message copyOut = exchange.getOut(false);
        if (copyOut != null) {
            safeCopy(getOut(true), exchange, copyOut);
        }
        Message copyFault = exchange.getFault(false);
        if (copyFault != null) {
            safeCopy(getFault(true), exchange, copyFault);
        }
        setException(exchange.getException());
        unitOfWork = exchange.getUnitOfWork();
        pattern = exchange.getPattern();
    }
    private static void safeCopy(Message message, Exchange exchange, Message that) {
        if (message != null) {
            message.copyFrom(that);
        }
    }
    private static Map<String, Object> safeCopy(Map<String, Object> properties) {
        if (properties == null) {
            return null;
        }
        return new ConcurrentHashMap<String, Object>(properties);
    }
    private static Message safeCopy(Exchange exchange, Message message) {
        if (message == null) {
            return null;
        }
        Message answer = message.copy();
        if (answer instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport) answer;
            messageSupport.setExchange(exchange);
        }
        return answer;
    }
    public Exchange newInstance() {
        return new DefaultExchange(this);
    }
    public CamelContext getContext() {
        return context;
    }
    public Object getProperty(String name) {
        if (properties != null) {
            return properties.get(name);
        }
        return null;
    }
    public <T> T getProperty(String name, Class<T> type) {
        Object value = getProperty(name);
        // if the property is also a well known property in ExchangeProperty then validate that the
        // value is of the same type
        ExchangeProperty<?> property = ExchangeProperty.getByName(name);
        if (property != null) {
            validateExchangePropertyIsExpectedType(property, type, value);
        }
        return getContext().getTypeConverter().convertTo(type, this, value);
    }
    public void setProperty(String name, Object value) {
        ExchangeProperty<?> property = ExchangeProperty.getByName(name);
        // if the property is also a well known property in ExchangeProperty then validate that the
        // value is of the same type
        if (property != null) {
            Class type = value.getClass();
            validateExchangePropertyIsExpectedType(property, type, value);
        }
        if (value != null) {
            // avoid the NullPointException
            getProperties().put(name, value);
        } else {
            // if the value is null , we just remove the key from the map
            if (name != null) {
                getProperties().remove(name);
            }
        }
    }
    private <T> void validateExchangePropertyIsExpectedType(ExchangeProperty<?> property, Class<T> type, Object value) {
        if (value != null && property != null && !property.type().isAssignableFrom(type)) {
            throw new RuntimeCamelException(""Type cast exception while getting an ""
                    + ""Exchange Property value '"" + value.toString()
                    + ""' on Exchange "" + this
                    + "" for a well known Exchange Property with these traits: "" + property);
        }
    }
    public Object removeProperty(String name) {
        return getProperties().remove(name);
    }
    public Map<String, Object> getProperties() {
        if (properties == null) {
            properties = new ConcurrentHashMap<String, Object>();
        }
        return properties;
    }
    public void setProperties(Map<String, Object> properties) {
        this.properties = properties;
    }
    public Message getIn() {
        if (in == null) {
            in = createInMessage();
            configureMessage(in);
        }
        return in;
    }
    public void setIn(Message in) {
        this.in = in;
        configureMessage(in);
    }
    public Message getOut() {
        return getOut(true);
    }
    public Message getOut(boolean lazyCreate) {
        if (out == null && lazyCreate) {
            out = createOutMessage();
            configureMessage(out);
        }
        return out;
    }
    public void setOut(Message out) {
        this.out = out;
        configureMessage(out);
    }
    public Throwable getException() {
        return exception;
    }
    public void setException(Throwable exception) {
        this.exception = exception;
    }
    public ExchangePattern getPattern() {
        return pattern;
    }
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    public void throwException() throws Exception {
        if (exception == null) {
            return;
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException)exception;
        }
        if (exception instanceof Exception) {
            throw (Exception)exception;
        }
        throw wrapRuntimeCamelException(exception);
    }
    public Message getFault() {
        return getFault(true);
    }
    public Message getFault(boolean lazyCreate) {
        if (fault == null && lazyCreate) {
            fault = createFaultMessage();
            configureMessage(fault);
        }
        return fault;
    }
    public void setFault(Message fault) {
        this.fault = fault;
        configureMessage(fault);
    }
    public String getExchangeId() {
        if (exchangeId == null) {
            exchangeId = DefaultExchange.DEFAULT_ID_GENERATOR.generateId();
        }
        return exchangeId;
    }
    public void setExchangeId(String id) {
        this.exchangeId = id;
    }
    public boolean isFailed() {
        Message faultMessage = getFault(false);
        if (faultMessage != null) {
            Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                return true;
            }
        }
        return getException() != null;
    }
    public boolean isTransacted() {
        ExchangeProperty<?> property = ExchangeProperty.get(""transacted"");
        return property != null && property.get(this) == Boolean.TRUE;
    }
    public UnitOfWork getUnitOfWork() {
        return unitOfWork;
    }
    public void setUnitOfWork(UnitOfWork unitOfWork) {
        this.unitOfWork = unitOfWork;
    }
    /**
     * Factory method used to lazily create the IN message
     */
    protected Message createInMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the OUT message
     */
    protected Message createOutMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the FAULT message
     */
    protected Message createFaultMessage() {
        return new DefaultMessage();
    }
    /**
     * Configures the message after it has been set on the exchange
     */
    protected void configureMessage(Message message) {
        if (message instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport)message;
            messageSupport.setExchange(this);
        }
    }
}
"
org.apache.camel.component.freemarker.NoCacheStorage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.freemarker;
import freemarker.cache.CacheStorage;
/**
 * A cache storage for Freemarker with no cache used for development to force reload of templates
 * on every request.
 */
public class NoCacheStorage implements CacheStorage {
    public Object get(Object key) {
        // noop
        return null;
    }
    public void put(Object key, Object value) {
        // noop
    }
    public void remove(Object key) {
        // noop
    }
    public void clear() {
        // noop
    }
}
"
org.apache.camel.spring.remoting.SendBeforeInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.component.bean.CamelInvocationHandler;
import org.apache.camel.component.bean.MethodInfoCache;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A Spring interceptor which sends a message exchange to an endpoint before the method is invoked
 * 
 * @version $Revision$
 */
public class SendBeforeInterceptor implements MethodInterceptor, CamelContextAware, InitializingBean, DisposableBean {
    private String uri;
    private CamelContext camelContext;
    private CamelInvocationHandler invocationHandler;
    private Producer producer;
    public Object invoke(MethodInvocation invocation) throws Throwable {
        invocationHandler.invoke(invocation.getThis(), invocation.getMethod(), invocation.getArguments());
        return invocation.proceed();
    }
    public void afterPropertiesSet() throws Exception {
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        producer = endpoint.createProducer();
        producer.start();
        invocationHandler = new CamelInvocationHandler(endpoint, producer, new MethodInfoCache(endpoint.getCamelContext()));
    }
    public void destroy() throws Exception {
        if (producer != null) {
            producer.stop();
        }
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Properties
    //-----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
}
"
org.apache.camel.osgi.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/osgi"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.osgi;
"
org.apache.camel.component.cxf.interceptors.AbstractMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
//import java.util.ResourceBundle;
//import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
/**
 * This is the base class for message interceptors that intercepts
 * binding specific headers and message parts as DOM Element.
 * Then moves dom elements between header and message part list based on the
 * binding operation info provided in the exchange.
 */
public abstract class AbstractMessageOutInterceptor<T extends Message>
       extends AbstractPhaseInterceptor<T> {
    public AbstractMessageOutInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    protected abstract Logger getLogger();
    protected Element createElement(QName elName, List<Element> childEl) {
        Document doc = DOMUtils.createDocument();
        String prefix = elName.getPrefix();
        StringBuilder tagName = new StringBuilder();
        if (!"""".equals(prefix)) {
            tagName.append(prefix);
            tagName.append("":"");
        }
        tagName.append(elName.getLocalPart());
        Element el = doc.createElementNS(elName.getNamespaceURI(),
                                         tagName.toString());
        if (!"""".equals(elName.getPrefix())) {
            StringBuilder attrName = new StringBuilder(""xmlns"");        
            attrName.append(':');
            attrName.append(elName.getPrefix());
            el.setAttribute(attrName.toString(), elName.getNamespaceURI());
        }
        for (Element part : childEl) {
            Node adoptedNode = doc.adoptNode(part);
            el.appendChild(adoptedNode);
        }
        return el;
    }    
}
"
org.apache.camel.component.file.remote.RemoteFileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public abstract class RemoteFileConsumer<T extends RemoteFileExchange> extends ScheduledPollConsumer<T> {
    protected final transient Log log = LogFactory.getLog(getClass());
    protected RemoteFileEndpoint<T> endpoint;
    // @deprecated lastPollTime to be removed in Camel 2.0
    protected long lastPollTime;
    protected boolean recursive;
    protected String regexPattern;
    protected boolean setNames = true;
    protected boolean exclusiveReadLock;
    protected boolean deleteFile;
    protected String moveNamePrefix;
    protected String moveNamePostfix;
    protected String excludedNamePrefix;
    protected String excludedNamePostfix;
    private boolean timestamp;
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor,
                              ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
    /**
     * Gets the filename.
     *
     * @param file the file object for the given consumer implementation.
     * @return the filename as String.
     */
    protected abstract String getFileName(Object file);
    /**
     * Is the given file matched to be consumed.
     */
    protected boolean isMatched(Object file) {
        String name = getFileName(file);
        // folders/names starting with dot is always skipped (eg. ""."", "".camel"", "".camelLock"")
        if (name.startsWith(""."")) {
            return false;
        }
        if (regexPattern != null && regexPattern.length() > 0) {
            if (!name.matches(regexPattern)) {
                return false;
            }
        }
        if (excludedNamePrefix != null) {
            if (name.startsWith(excludedNamePrefix)) {
                return false;
            }
        }
        if (excludedNamePostfix != null) {
            if (name.endsWith(excludedNamePostfix)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Should the file be moved after consuming?
     */
    protected boolean isMoveFile() {
        return moveNamePostfix != null || moveNamePrefix != null || endpoint.getConfiguration().getExpression() != null;
    }
    /**
     * Gets the to filename for moving.
     *
     * @param name the original filename
     * @param exchange the current exchange
     * @return the move filename
     */
    protected String getMoveFileName(String name, Exchange exchange) {
        // move according to the expression
        if (endpoint.getConfiguration().getExpression()  != null) {
            Object result = endpoint.getConfiguration().getExpression() .evaluate(exchange);
            return exchange.getContext().getTypeConverter().convertTo(String.class, result);
        }
        // move according to the pre and postfix
        StringBuffer buffer = new StringBuffer();
        if (moveNamePrefix != null) {
            buffer.append(moveNamePrefix);
        }
        buffer.append(name);
        if (moveNamePostfix != null) {
            buffer.append(moveNamePostfix);
        }
        return buffer.toString();
    }
    protected String remoteServer() {
        return endpoint.getConfiguration().remoteServerInformation();
    }
    public boolean isRecursive() {
        return recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public long getLastPollTime() {
        return lastPollTime;
    }
    public void setLastPollTime(long lastPollTime) {
        this.lastPollTime = lastPollTime;
    }
    public String getRegexPattern() {
        return regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isSetNames() {
        return setNames;
    }
    public void setSetNames(boolean setNames) {
        this.setNames = setNames;
    }
    public boolean isExclusiveReadLock() {
        return exclusiveReadLock;
    }
    public void setExclusiveReadLock(boolean exclusiveReadLock) {
        this.exclusiveReadLock = exclusiveReadLock;
    }
    public boolean isDeleteFile() {
        return deleteFile;
    }
    public void setDeleteFile(boolean deleteFile) {
        this.deleteFile = deleteFile;
    }
    public String getMoveNamePrefix() {
        return moveNamePrefix;
    }
    public void setMoveNamePrefix(String moveNamePrefix) {
        this.moveNamePrefix = moveNamePrefix;
    }
    public String getMoveNamePostfix() {
        return moveNamePostfix;
    }
    public void setMoveNamePostfix(String moveNamePostfix) {
        this.moveNamePostfix = moveNamePostfix;
    }
    public String getExcludedNamePrefix() {
        return excludedNamePrefix;
    }
    public void setExcludedNamePrefix(String excludedNamePrefix) {
        this.excludedNamePrefix = excludedNamePrefix;
    }
    public String getExcludedNamePostfix() {
        return excludedNamePostfix;
    }
    public void setExcludedNamePostfix(String excludedNamePostfix) {
        this.excludedNamePostfix = excludedNamePostfix;
    }
    /**
     * @deprecated the timestamp feature will be removed in Camel 2.0
     */
    public boolean isTimestamp() {
        return timestamp;
    }
    /**
     * Sets wether polling should use last poll timestamp for filtering only new files.
     * @deprecated the timestamp feature will be removed in Camel 2.0
     */
    public void setTimestamp(boolean timestamp) {
        this.timestamp = timestamp;
    }
}
"
org.apache.camel.AlreadyStoppedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Exception thrown in situations when a {@link Service} has already been stopped.
 *
 * @version $Revision$
 */
public class AlreadyStoppedException extends CamelException {
    public AlreadyStoppedException() {
        super(""Already stopped"");
    }
}
"
org.apache.camel.builder.script.ScriptEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if the script evaluation fails
 * 
 * @version $Revision$
 */
public class ScriptEvaluationException extends RuntimeCamelException {
    public ScriptEvaluationException(String message) {
        super(message);
    }
    public ScriptEvaluationException(String message, Throwable cause) {
        super(message, cause);
    }
    public ScriptEvaluationException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.Header,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being a header on an inbound {@link Message}
 *
 * @see Message#getHeader(String) 
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Header {
    String name();
}
"
org.apache.camel.component.dataset.DataSetEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenPollingConsumer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Endpoint for DataSet.
 *
 * @version $Revision$
 */
public class DataSetEndpoint extends MockEndpoint implements Service {
    private static final transient Log LOG = LogFactory.getLog(DataSetEndpoint.class);
    private DataSet dataSet;
    private AtomicInteger receivedCounter = new AtomicInteger();
    private long produceDelay = -1;
    private long consumeDelay = -1;
    private long startTime;
    private long preloadSize;
    public DataSetEndpoint(String endpointUri, Component component, DataSet dataSet) {
        super(endpointUri, component);
        this.dataSet = dataSet;
    }
    public DataSetEndpoint(String endpointUri, DataSet dataSet) {
        super(endpointUri);
        this.dataSet = dataSet;
    }
    public static void assertEquals(String description, Object expected, Object actual, Exchange exchange) {
        if (!ObjectHelper.equal(expected, actual)) {
            throw new AssertionError(description + "" does not match. Expected: "" + expected + "" but was: "" + actual + "" on "" + exchange + "" with headers: "" + exchange.getIn().getHeaders());
        }
    }
    @Override
    public PollingConsumer<Exchange> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<Exchange>(this);
    }
    @Override
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new DataSetConsumer(this, processor);
    }
    @Override
    public void reset() {
        super.reset();
        receivedCounter.set(0);
    }
    @Override
    public int getReceivedCounter() {
        return receivedCounter.get();
    }
    /**
     * Creates a message exchange for the given index in the {@link DataSet}
     */
    public Exchange createExchange(long messageIndex) throws Exception {
        Exchange exchange = createExchange();
        getDataSet().populateMessage(exchange, messageIndex);
        Message in = exchange.getIn();
        in.setHeader(DataSet.INDEX_HEADER, messageIndex);
        return exchange;
    }
    @Override
    protected void waitForCompleteLatch() throws InterruptedException {
        // TODO lets do a much better version of this!
        long size = getDataSet().getSize();
        size *= 4000;
        setResultWaitTime(size);
        super.waitForCompleteLatch();
    }
    // Properties
    //-------------------------------------------------------------------------
    public DataSet getDataSet() {
        return dataSet;
    }
    public void setDataSet(DataSet dataSet) {
        this.dataSet = dataSet;
    }
    public long getPreloadSize() {
        return preloadSize;
    }
    /**
     * Sets how many messages should be preloaded (sent) before the route completes its initialisation
     */
    public void setPreloadSize(long preloadSize) {
        this.preloadSize = preloadSize;
    }
    public long getConsumeDelay() {
        return consumeDelay;
    }
    /**
     * Allows a delay to be specified which causes consumers to pause - to simulate slow consumers
     */
    public void setConsumeDelay(long consumeDelay) {
        this.consumeDelay = consumeDelay;
    }
    public long getProduceDelay() {
        return produceDelay;
    }
    /**
     * Allows a delay to be specified which causes producers to pause - to simulate slow producers
     */
    public void setProduceDelay(long produceDelay) {
        this.produceDelay = produceDelay;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void performAssertions(Exchange actual) throws Exception {
        if (startTime == 0) {
            startTime = System.currentTimeMillis();
        }
        int receivedCount = receivedCounter.incrementAndGet();
        long index = receivedCount - 1;
        Exchange expected = createExchange(index);
        // now lets assert that they are the same
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Received message: "" + index + "" = "" + actual);
        }
        assertMessageExpected(index, expected, actual);
        if (consumeDelay > 0) {
            Thread.sleep(consumeDelay);
        }
        long group = getDataSet().getReportCount();
        if (receivedCount % group == 0) {
            reportProgress(actual, receivedCount);
        }
    }
    protected void reportProgress(Exchange actual, int receivedCount) {
        long time = System.currentTimeMillis();
        long elapsed = time - startTime;
        startTime = time;
        LOG.info(""Received: "" + receivedCount + "" messages so far. Last group took: "" + elapsed + "" millis"");
    }
    protected void assertMessageExpected(long index, Exchange expected, Exchange actual) throws Exception {
        long actualCounter = ExchangeHelper.getMandatoryHeader(actual, DataSet.INDEX_HEADER, Long.class);
        assertEquals(""Header: "" + DataSet.INDEX_HEADER, index, actualCounter, actual);
        getDataSet().assertMessageExpected(this, expected, actual, index);
    }
    public void start() throws Exception {
        long size = getDataSet().getSize();
        expectedMessageCount((int) size);
    }
    public void stop() throws Exception {
    }
}
"
org.apache.camel.osgi.OsgiResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import org.apache.camel.util.ResolverUtil;
import org.apache.camel.util.ResolverUtil.Test;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.springframework.osgi.util.BundleDelegatingClassLoader;
public class OsgiResolverUtil extends ResolverUtil {
    private Bundle bundle;
    public OsgiResolverUtil(BundleContext context) {
        bundle = context.getBundle();
    }
    /**
     * Returns the classloaders that will be used for scanning for classes. 
     * Here we just add BundleDelegatingClassLoader here
     *
     * @return the ClassLoader instances that will be used to scan for classes
     */
    public Set<ClassLoader> getClassLoaders() {
        Set<ClassLoader> classLoaders = super.getClassLoaders();
        // Using the Activator's bundle to make up a class loader
        ClassLoader osgiLoader = BundleDelegatingClassLoader.createBundleClassLoaderFor(bundle);
        classLoaders.add(osgiLoader);
        return classLoaders;
    }
    /**
     * Scans for classes starting at the package provided and descending into
     * subpackages. Each class is offered up to the Test as it is discovered,
     * and if the Test returns true the class is retained. Accumulated classes
     * can be fetched by calling {@link #getClasses()}.
     *
     * @param test        an instance of {@link Test} that will be used to filter
     *                    classes
     * @param packageName the name of the package from which to start scanning
     *                    for classes, e.g. {@code net.sourceforge.stripes}
     */
    public void find(Test test, String packageName) {
        packageName = packageName.replace('.', '/');
        Set<ClassLoader> set = getClassLoaders();
        ClassLoader osgiClassLoader = getOsgiClassLoader(set);
        if (osgiClassLoader != null) {
            // if we have an osgi bundle loader use this one only
            LOG.debug(""Using only osgi bundle classloader"");
            findInOsgiClassLoader(test, packageName, osgiClassLoader);
        } else {
            LOG.debug(""Using only regular classloaders"");
            for (ClassLoader classLoader : set) {
                if (!isOsgiClassloader(classLoader)) {
                    find(test, packageName, classLoader);
                }
            }
        }
    }
    private void findInOsgiClassLoader(Test test, String packageName, ClassLoader osgiClassLoader) {
        try {
            Method mth = osgiClassLoader.getClass().getMethod(""getBundle"", new Class[]{});
            if (mth != null) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Loading from osgi buindle using classloader: "" + osgiClassLoader);
                }
                loadImplementationsInBundle(test, packageName, osgiClassLoader, mth);
                return;
            }
        } catch (NoSuchMethodException e) {
            LOG.warn(""It's not an osgi bundle classloader: "" + osgiClassLoader);
            return;
        }
    }
    /**
     * Gets the osgi classloader if any in the given set
     */
    private static ClassLoader getOsgiClassLoader(Set<ClassLoader> set) {
        for (ClassLoader loader : set) {
            if (isOsgiClassloader(loader)) {
                return loader;
            }
        }
        return null;
    }
    /**
     * Is it an osgi classloader
     */
    private static boolean isOsgiClassloader(ClassLoader loader) {
        try {
            Method mth = loader.getClass().getMethod(""getBundle"", new Class[]{});
            if (mth != null) {
                return true;
            }
        } catch (NoSuchMethodException e) {
            // ignore its not an osgi loader
        }
        return false;
    }
    private void loadImplementationsInBundle(Test test, String packageName, ClassLoader loader, Method mth) {
        // Use an inner class to avoid a NoClassDefFoundError when used in a non-osgi env
        Set<String> urls = OsgiUtil.getImplementationsInBundle(test, packageName, loader, mth);
        if (urls != null) {
            for (String url : urls) {
                // substring to avoid leading slashes
                addIfMatching(test, url);
            }
        }
    }
    private static final class OsgiUtil {
        private OsgiUtil() {
            // Helper class
        }
        static Set<String> getImplementationsInBundle(Test test, String packageName, ClassLoader loader, Method mth) {
            try {
                org.osgi.framework.Bundle bundle = (org.osgi.framework.Bundle) mth.invoke(loader);
                org.osgi.framework.Bundle[] bundles = bundle.getBundleContext().getBundles();
                Set<String> urls = new HashSet<String>();
                for (org.osgi.framework.Bundle bd : bundles) {
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Searching in bundle:"" + bd);
                    }
                    Enumeration<URL> paths = bd.findEntries(""/"" + packageName, ""*.class"", true);
                    while (paths != null && paths.hasMoreElements()) {
                        URL path = paths.nextElement();
                        String pathString = path.getPath();
                        pathString.indexOf(packageName);
                        urls.add(pathString.substring(pathString.indexOf(packageName)));
                    }
                }
                return urls;
            } catch (Throwable t) {
                LOG.error(""Could not search osgi bundles for classes matching criteria: "" + test
                          + ""due to an Exception: "" + t.getMessage());
                return null;
            }
        }
    }
}
"
org.apache.camel.component.jdbc.JdbcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import javax.sql.DataSource;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcEndpoint extends DefaultEndpoint<DefaultExchange> {
    private int readSize;
    private DataSource dataSource;
    public JdbcEndpoint(String endpointUri, Component component, DataSource dataSource) {
        super(endpointUri, component);
        this.dataSource = dataSource;
    }
    public boolean isSingleton() {
        return true;
    }
    public Consumer<DefaultExchange> createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""Not supported"");
    }
    public Producer<DefaultExchange> createProducer() throws Exception {
        return new JdbcProducer(this, dataSource, readSize);
    }
    public void setReadSize(int readSize) {
        this.readSize = readSize;
    }
}
"
org.apache.camel.CamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Base class for all Camel checked exceptions typically thrown by a {@link Processor}
 *
 * @version $Revision$
 */
public class CamelException extends Exception {
    public CamelException() {
    }
    public CamelException(String message) {
        super(message);
    }
    public CamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public CamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.component.cxf.transport.spring.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""conduit"", new CamelConduitDefinitionParser());
        registerBeanDefinitionParser(""destination"", new CamelDestinationDefinitionParser());
    }
}
"
org.apache.camel.component.uface.swing.Main,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision$
 */
public class Main extends org.apache.camel.spring.Main {
    public static void main(String... args) {
        new Main().run(args);
    }
    protected void postProcesCamelContext(CamelContext camelContext) throws Exception {
        super.postProcesCamelContext(camelContext);
        SwingBrowser browser = new SwingBrowser((DefaultCamelContext) camelContext);
        browser.run();
    }
}
"
org.apache.camel.builder.PredicateFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A Factory of {@link Predicate} objects typically implemented by a builder such as
 * {@link org.apache.camel.builder.xml.XPathBuilder XPathBuilder}
 *
 * @version $Revision$
 */
public interface PredicateFactory<E extends Exchange> {
    /**
     * Creates a predicate object
     *
     * @return the newly created expression object
     */
    Predicate<E> createPredicate();
}
"
org.apache.camel.converter.jaxb.ObjectHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""objectHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ObjectHeader extends HeaderType {
    @XmlAnyElement(lax = true)
    private Object value;
    public ObjectHeader() {
    }
    public ObjectHeader(String name, Object value) {
        super(name);
        this.value = value;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}
"
org.apache.camel.component.cxf.feature.AbstractDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.List;
import java.util.logging.Logger;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.feature.AbstractFeature;
import org.apache.cxf.interceptor.Interceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptor;
/**
 * The abstract class for the data format feature
 */
public abstract class AbstractDataFormatFeature extends AbstractFeature {
    protected abstract Logger getLogger();
    protected void resetServiceInvokerInterceptor(Server server) {
        List<Interceptor> serviceInterceptor = server.getEndpoint().getService().getInInterceptors();
        removeInterceptorWhichIsInThePhases(serviceInterceptor, new String[]{Phase.INVOKE});
        serviceInterceptor.add(new MessageInvokerInterceptor());
    }
    protected void removeInterceptorWhichIsInThePhases(List<Interceptor> interceptors, String[] phaseNames) {
        for (Interceptor i : interceptors) {
            if (i instanceof PhaseInterceptor) {
                PhaseInterceptor p = (PhaseInterceptor)i;
                for (String phaseName : phaseNames) {
                    if (p.getPhase().equals(phaseName)) {
                        getLogger().info(""removing the interceptor "" + p);
                        interceptors.remove(p);
                        break;
                    }
                }
            }
        }
    }
    protected void removeInterceptorWhichIsOutThePhases(List<Interceptor> interceptors, String[] phaseNames) {
        for (Interceptor i : interceptors) {
            boolean outside = false;
            if (i instanceof PhaseInterceptor) {
                PhaseInterceptor p = (PhaseInterceptor)i;
                for (String phaseName : phaseNames) {
                    if (p.getPhase().equals(phaseName)) {
                        outside = true;
                        break;
                    }
                }
                if (!outside) {
                    getLogger().info(""removing the interceptor "" + p);
                    interceptors.remove(p);
                }
            }
        }
    }
}
"
org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Map;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * @version $Revision$
 */
public class InstrumentationErrorHandlerWrappingStrategy implements
        ErrorHandlerWrappingStrategy {
    private Map<ProcessorType, PerformanceCounter> counterMap;
    public InstrumentationErrorHandlerWrappingStrategy(
            Map<ProcessorType, PerformanceCounter> counterMap) {
        this.counterMap = counterMap;
    }
    public Processor wrapProcessorInErrorHandler(RouteContext routeContext, ProcessorType processorType,
                                                 Processor target) throws Exception {
        // don't wrap our instrumentation interceptors
        if (counterMap.containsKey(processorType)) {
            return processorType.getErrorHandlerBuilder().createErrorHandler(routeContext, target);
        }
        return target;
    }
}
"
org.apache.camel.component.jms.JmsBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.File;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.jms.BytesMessage;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import javax.xml.transform.TransformerException;
import org.w3c.dom.Node;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Strategy used to convert between a Camel {@link JmsExchange} and {@link JmsMessage}
 * to and from a JMS {@link Message}
 *
 * @version $Revision$
 */
public class JmsBinding {
    private static final transient Log LOG = LogFactory.getLog(JmsBinding.class);
    private JmsEndpoint endpoint;
    private XmlConverter xmlConverter = new XmlConverter();
    private HeaderFilterStrategy headerFilterStrategy;
    public JmsBinding() {
        headerFilterStrategy = new JmsHeaderFilterStrategy();
    }
    public JmsBinding(JmsEndpoint endpoint) {
        this.endpoint = endpoint;
        headerFilterStrategy = endpoint.getHeaderFilterStrategy();
        if (headerFilterStrategy == null) {
            headerFilterStrategy = new JmsHeaderFilterStrategy();
        }
    }
    /**
     * Extracts the body from the JMS message
     *
     * @param exchange the exchange
     * @param message  the message to extract its body
     * @return the body, can be <tt>null</tt>
     */
    public Object extractBodyFromJms(Exchange exchange, Message message) {
        try {
            if (message instanceof ObjectMessage) {
                ObjectMessage objectMessage = (ObjectMessage)message;
                return objectMessage.getObject();
            } else if (message instanceof TextMessage) {
                TextMessage textMessage = (TextMessage)message;
                return textMessage.getText();
            } else if (message instanceof MapMessage) {
                return createMapFromMapMessage((MapMessage)message);
            } else if (message instanceof BytesMessage) {
                return createByteArrayFromBytesMessage((BytesMessage)message);
            } else if (message instanceof StreamMessage) {
                return message;
            } else {
                return null;
            }
        } catch (JMSException e) {
            throw new RuntimeJmsException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    public Map<String, Object> extractHeadersFromJms(Message jmsMessage) {
        Map<String, Object> map = new HashMap<String, Object>();
        if (jmsMessage != null) {
            // lets populate the standard JMS message headers
            try {
                map.put(""JMSCorrelationID"", jmsMessage.getJMSCorrelationID());
                map.put(""JMSDeliveryMode"", jmsMessage.getJMSDeliveryMode());
                map.put(""JMSDestination"", jmsMessage.getJMSDestination());
                map.put(""JMSExpiration"", jmsMessage.getJMSExpiration());
                map.put(""JMSMessageID"", jmsMessage.getJMSMessageID());
                map.put(""JMSPriority"", jmsMessage.getJMSPriority());
                map.put(""JMSRedelivered"", jmsMessage.getJMSRedelivered());
                map.put(""JMSReplyTo"", jmsMessage.getJMSReplyTo());
                map.put(""JMSTimestamp"", jmsMessage.getJMSTimestamp());
                map.put(""JMSType"", jmsMessage.getJMSType());
                // TODO this works around a bug in the ActiveMQ property handling
                map.put(""JMSXGroupID"", jmsMessage.getStringProperty(""JMSXGroupID""));
            } catch (JMSException e) {
                throw new MessageJMSPropertyAccessException(e);
            }
            Enumeration names;
            try {
                names = jmsMessage.getPropertyNames();
            } catch (JMSException e) {
                throw new MessagePropertyNamesAccessException(e);
            }
            while (names.hasMoreElements()) {
                String name = names.nextElement().toString();
                try {
                    Object value = jmsMessage.getObjectProperty(name);
                    if (headerFilterStrategy != null
                            && headerFilterStrategy.applyFilterToExternalHeaders(name, value)) {
                        continue;
                    }
                    // must decode back from safe JMS header name to original header name
                    // when storing on this Camel JmsMessage object.
                    String key = JmsBinding.decodeFromSafeJmsHeaderName(name);
                    map.put(key, value);
                } catch (JMSException e) {
                    throw new MessagePropertyAccessException(name, e);
                }
            }
        }
        return map;
    }
    protected byte[] createByteArrayFromBytesMessage(BytesMessage message) throws JMSException {
        if (message.getBodyLength() > Integer.MAX_VALUE) {
            return null;
        }
        byte[] result = new byte[(int)message.getBodyLength()];
        message.readBytes(result);
        return result;
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     *
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, Session session) throws JMSException {
        return makeJmsMessage(exchange, exchange.getIn(), session);
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     *
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, org.apache.camel.Message camelMessage, Session session)
        throws JMSException {
        Message answer = null;
        boolean alwaysCopy = (endpoint != null) ? endpoint.getConfiguration().isAlwaysCopyMessage() : false;
        if (!alwaysCopy && camelMessage instanceof JmsMessage) {
            JmsMessage jmsMessage = (JmsMessage)camelMessage;
            if (!jmsMessage.shouldCreateNewMessage()) {
                answer = jmsMessage.getJmsMessage();
            }
        }
        if (answer == null) {
            answer = createJmsMessage(camelMessage.getBody(), session, exchange.getContext());
            appendJmsProperties(answer, exchange, camelMessage);
        }
        return answer;
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    public void appendJmsProperties(Message jmsMessage, Exchange exchange) throws JMSException {
        appendJmsProperties(jmsMessage, exchange, exchange.getIn());
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    public void appendJmsProperties(Message jmsMessage, Exchange exchange, org.apache.camel.Message in)
        throws JMSException {
        Set<Map.Entry<String, Object>> entries = in.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            appendJmsProperty(jmsMessage, exchange, in, headerName, headerValue);
        }
    }
    public void appendJmsProperty(Message jmsMessage, Exchange exchange, org.apache.camel.Message in,
                                  String headerName, Object headerValue) throws JMSException {
        if (headerName.startsWith(""JMS"") && !headerName.startsWith(""JMSX"")) {
            if (headerName.equals(""JMSCorrelationID"")) {
                jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class,
                    headerValue));
            } else if (headerName.equals(""JMSReplyTo"") && headerValue != null) {
                jmsMessage.setJMSReplyTo(ExchangeHelper.convertToType(exchange, Destination.class,
                    headerValue));
            } else if (headerName.equals(""JMSType"")) {
                jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));
            } else if (LOG.isDebugEnabled()) {
                // The following properties are set by the MessageProducer
                // JMSDeliveryMode, JMSDestination, JMSExpiration,
                // JMSPriority,
                // The following are set on the underlying JMS provider
                // JMSMessageID, JMSTimestamp, JMSRedelivered
                LOG.debug(""Ignoring JMS header: "" + headerName + "" with value: "" + headerValue);
            }
        } else if (shouldOutputHeader(in, headerName, headerValue)) {
            // must encode to safe JMS header name before setting property on jmsMessage
            String key = encodeToSafeJmsHeaderName(headerName);
            // only primitive headers and strings is allowed as properties
            // see message properties: http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html
            Object value = getValidJMSHeaderValue(headerName, headerValue);
            if (value != null) {
                jmsMessage.setObjectProperty(key, value);
            } else if (LOG.isDebugEnabled()) {
                // okay the value is not a primitive or string so we can not sent it over the wire
                LOG.debug(""Ignoring non primitive header: "" + headerName + "" of class: ""
                    + headerValue.getClass().getName() + "" with value: "" + headerValue);
            }
        }
    }
    /**
     * Strategy to test if the given header is valid according to the JMS spec to be set as a property
     * on the JMS message.
     * <p/>
     * This default implementation will allow:
     * <ul>
     *   <li>any primitives and their counter Objects (Integer, Double etc.)</li>
     *   <li>String and any other litterals, Character, CharSequence</li>
     *   <li>Boolean</li>
     *   <li>BigDecimal and BigInteger</li>
     *   <li>java.util.Date</li>
     * </ul>
     *
     * @param headerName   the header name
     * @param headerValue  the header value
     * @return  the value to use, <tt>null</tt> to ignore this header
     */
    protected Object getValidJMSHeaderValue(String headerName, Object headerValue) {
        if (headerValue.getClass().isPrimitive()) {
            return headerValue;
        } else if (headerValue instanceof String) {
            return headerValue;
        } else if (headerValue instanceof Number) {
            return headerValue;
        } else if (headerValue instanceof Character) {
            return headerValue.toString();
        } else if (headerValue instanceof BigDecimal || headerValue instanceof BigInteger) {
            return headerValue.toString();
        } else if (headerValue instanceof CharSequence) {
            return headerValue.toString();
        } else if (headerValue instanceof Boolean) {
            return headerValue.toString();
        } else if (headerValue instanceof Date) {
            return headerValue.toString();
        }
        return null;
    }
    protected Message createJmsMessage(Object body, Session session, CamelContext context)
        throws JMSException {
        if (body instanceof Node) {
            // lets convert the document to a String format
            try {
                body = xmlConverter.toString((Node)body);
            } catch (TransformerException e) {
                JMSException jmsException = new JMSException(e.getMessage());
                jmsException.setLinkedException(e);
                throw jmsException;
            }
        }
        if (body instanceof byte[]) {
            BytesMessage result = session.createBytesMessage();
            result.writeBytes((byte[])body);
            return result;
        }
        if (body instanceof Map) {
            MapMessage result = session.createMapMessage();
            Map<?, ?> map = (Map<?, ?>)body;
            try {
                populateMapMessage(result, map, context);
                return result;
            } catch (JMSException e) {
                // if MapMessage creation failed then fall back to Object Message
                LOG.warn(""Can not populate MapMessage will fall back to ObjectMessage, cause by: "" + e.getMessage());
            }
        }
        if (body instanceof String) {
            return session.createTextMessage((String)body);
        }
        if (body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer) {
            BytesMessage result = session.createBytesMessage();
            byte[] bytes = context.getTypeConverter().convertTo(byte[].class, body);
            result.writeBytes(bytes);
            return result;
        }
        if (body instanceof Serializable) {
            return session.createObjectMessage((Serializable)body);
        }
        return session.createMessage();
    }
    /**
     * Populates a {@link MapMessage} from a {@link Map} instance.
     */
    protected void populateMapMessage(MapMessage message, Map<?, ?> map, CamelContext context)
        throws JMSException {
        for (Object key : map.keySet()) {
            String keyString = CamelContextHelper.convertTo(context, String.class, key);
            if (keyString != null) {
                message.setObject(keyString, map.get(key));
            }
        }
    }
    /**
     * Extracts a {@link Map} from a {@link MapMessage}
     */
    public Map<String, Object> createMapFromMapMessage(MapMessage message) throws JMSException {
        Map<String, Object> answer = new HashMap<String, Object>();
        Enumeration names = message.getMapNames();
        while (names.hasMoreElements()) {
            String name = names.nextElement().toString();
            Object value = message.getObject(name);
            answer.put(name, value);
        }
        return answer;
    }
    /**
     * @deprecated Please use {@link DefaultHeaderFilterStrategy#getOutFilter()}
     */
    public Set<String> getIgnoreJmsHeaders() {
        if (headerFilterStrategy instanceof DefaultHeaderFilterStrategy) {
            return ((DefaultHeaderFilterStrategy)headerFilterStrategy)
                .getOutFilter();
        } else {
            // Shouldn't get here unless a strategy that isn't an extension of
            // DefaultHeaderPropagationStrategy has been injected.
            return null;
        }
    }
    /**
     * @deprecated Please use {@link DefaultHeaderFilterStrategy#setOutFilter()}
     */
    public void setIgnoreJmsHeaders(Set<String> ignoreJmsHeaders) {
        if (headerFilterStrategy instanceof DefaultHeaderFilterStrategy) {
            ((DefaultHeaderFilterStrategy)headerFilterStrategy)
                .setOutFilter(ignoreJmsHeaders);
        } else {
            // Shouldn't get here unless a strategy that isn't an extension of
            // DefaultHeaderPropagationStrategy has been injected.
        }
    }
    /**
     * Strategy to allow filtering of headers which are put on the JMS message
     * <p/>
     * <b>Note</b>: Currently only supports sending java identifiers as keys
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName,
                                         Object headerValue) {
        return headerFilterStrategy == null
            || !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue);
    }
    /**
     * Encoder to encode JMS header keys that is that can be sent over the JMS transport.
     * <p/>
     * For example: Sending dots is the key is not allowed. Especially the Bean component has
     * this problem if you want to provide the method name to invoke on the bean.
     * <p/>
     * <b>Note</b>: Currently this encoder is simple as it only supports encoding dots to underscores.
     *
     * @param headerName the header name
     * @return the key to use instead for storing properties and to be for lookup of the same property
     */
    public static String encodeToSafeJmsHeaderName(String headerName) {
        return headerName.replace(""."", ""_"");
    }
    /**
     * Decode operation for the {@link #encodeToSafeJmsHeaderName(String)}.
     *
     * @param headerName the header name
     * @return the original key
     */
    public static String decodeFromSafeJmsHeaderName(String headerName) {
        return headerName.replace(""_"", ""."");
    }
}
"
org.apache.camel.converter.jaxp.XmlConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.nio.ByteBuffer;
import java.util.Properties;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.NIOConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}
 *
 * @version $Revision$
 */
@Converter
public class XmlConverter {
    public static final String DEFAULT_CHARSET_PROPERTY = ""org.apache.camel.default.charset"";
    public static String defaultCharset = ObjectHelper.getSystemProperty(DEFAULT_CHARSET_PROPERTY, ""UTF-8"");
    /*
     * When converting a DOM tree to a SAXSource, we try to use Xalan internal DOM parser if
     * available. Else, transform the DOM tree to a String and build a SAXSource on top of it.
     */
    private static final Class DOM_TO_SAX_CLASS;
    private DocumentBuilderFactory documentBuilderFactory;
    private TransformerFactory transformerFactory;
    static {
        // TODO: Use ObjectHelper.loadClass instead
        Class cl = null;
        try {
            cl = Class.forName(""org.apache.xalan.xsltc.trax.DOM2SAX"");
        } catch (Throwable t) {
            // do nothing here
        }
        DOM_TO_SAX_CLASS = cl;
    }
    public XmlConverter() {
    }
    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    /**
     * Returns the default set of output properties for conversions.
     */
    public Properties defaultOutputProperties() {
        Properties properties = new Properties();
        properties.put(OutputKeys.ENCODING, defaultCharset);
        properties.put(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
        return properties;
    }
    /**
     * Converts the given input Source into the required result
     */
    public void toResult(Source source, Result result) throws TransformerException {
        toResult(source, result, defaultOutputProperties());
    }   
    /**
     * Converts the given input Source into the required result
     */
    public void toResult(Source source, Result result, Properties outputProperties) throws TransformerException {
        if (source == null) {
            return;
        }
        Transformer transformer = createTransfomer();
        if (transformer == null) {
            throw new TransformerException(""Could not create a transformer - JAXP is misconfigured!"");
        }
        transformer.setOutputProperties(outputProperties);
        transformer.transform(source, result);
    } 
    /**
     * Converts the given byte[] to a Source
     */
    @Converter
    public BytesSource toSource(byte[] data) {
        return new BytesSource(data);
    }
    /**
     * Converts the given String to a Source
     */
    @Converter
    public StringSource toSource(String data) {
        return new StringSource(data);
    }
    /**
     * Converts the given Document to a Source
     */
    @Converter
    public DOMSource toSource(Document document) {
        return new DOMSource(document);
    }
    /**
     * Converts the given Node to a Source
     */
    @Converter
    public Source toSource(Node node) {
        return new DOMSource(node);
    }
    /**
     * Converts the given input Source into text
     */
    @Converter
    public String toString(Source source) throws TransformerException {
        if (source == null) {
            return null;
        } else if (source instanceof StringSource) {
            return ((StringSource) source).getText();
        } else if (source instanceof BytesSource) {
            return new String(((BytesSource) source).getData());
        } else {
            StringWriter buffer = new StringWriter();
            toResult(source, new StreamResult(buffer));
            return buffer.toString();
        }
    }
    /**
     * Converts the given input Node into text
     */
/*
    @Converter
    public String toString(NodeList nodeList) throws TransformerException {
        StringWriter buffer = new StringWriter();
        for (int i = 0, size = nodeList.getLength(); i < size; i++) {
            Node node = nodeList.item(i);
            Source source = new DOMSource(node);
            toResult(source, new StreamResult(buffer));
        }
        return buffer.toString();
    }
*/
    /**
     * Converts the given input Node into text
     */
    @Converter
    public String toString(Node node) throws TransformerException {
        return toString(new DOMSource(node));
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        if (source instanceof DOMSource) {
            return (DOMSource) source;
        } else if (source instanceof SAXSource) {
            return toDOMSourceFromSAX((SAXSource) source);
        } else if (source instanceof StreamSource) {
            return toDOMSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        Source source = toSource(text);
        if (source != null) {
            return toDOMSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toStreamSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {
        if (source instanceof SAXSource) {
            return (SAXSource) source;
        } else if (source instanceof DOMSource) {
            return toSAXSourceFromDOM((DOMSource) source);
        } else if (source instanceof StreamSource) {
            return toSAXSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(Source source) throws TransformerException {
        if (source instanceof StreamSource) {
            return (StreamSource) source;
        } else if (source instanceof DOMSource) {
            return toStreamSourceFromDOM((DOMSource) source);
        } else if (source instanceof SAXSource) {
            return toStreamSourceFromSAX((SAXSource) source);
        } else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(InputStream in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(Reader in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(File in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(byte[] in) throws TransformerException {
        if (in != null) {
            return new StreamSource(IOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(ByteBuffer in) throws TransformerException {
        if (in != null) {
            return new StreamSource(NIOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {
        InputSource inputSource = source.getInputSource();
        if (inputSource != null) {
            if (inputSource.getCharacterStream() != null) {
                return new StreamSource(inputSource.getCharacterStream());
            }
            if (inputSource.getByteStream() != null) {
                return new StreamSource(inputSource.getByteStream());
            }
        }
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public SAXSource toSAXSourceFromStream(StreamSource source) {
        InputSource inputSource;
        if (source.getReader() != null) {
            inputSource = new InputSource(source.getReader());
        } else {
            inputSource = new InputSource(source.getInputStream());
        }
        inputSource.setSystemId(source.getSystemId());
        inputSource.setPublicId(source.getPublicId());
        return new SAXSource(inputSource);
    }
    @Converter
    public Reader toReaderFromSource(Source src) throws TransformerException {
        StreamSource stSrc = toStreamSource(src);
        Reader r = stSrc.getReader();
        if (r == null) {
            r = new InputStreamReader(stSrc.getInputStream());
        }
        return r;
    }
    @Converter
    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilder builder = createDocumentBuilder();
        String systemId = source.getSystemId();
        Document document = null;
        Reader reader = source.getReader();
        if (reader != null) {
            document = builder.parse(new InputSource(reader));
        } else {
            InputStream inputStream = source.getInputStream();
            if (inputStream != null) {
                InputSource inputsource = new InputSource(inputStream);
                inputsource.setSystemId(systemId);
                document = builder.parse(inputsource);
            } else {
                throw new IOException(""No input stream or reader available"");
            }
        }
        return new DOMSource(document, systemId);
    }
    @Converter
    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {
        if (DOM_TO_SAX_CLASS != null) {
            try {
                Constructor cns = DOM_TO_SAX_CLASS.getConstructor(Node.class);
                XMLReader converter = (XMLReader) cns.newInstance(source.getNode());
                return new SAXSource(converter, new InputSource());
            } catch (Exception e) {
                throw new TransformerException(e);
            }
        } else {
            String str = toString(source);
            StringReader reader = new StringReader(str);
            return new SAXSource(new InputSource(reader));
        }
    }
    @Converter
    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {
        return new DOMSource(toDOMNodeFromSAX(source));
    }
    @Converter
    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        DOMResult result = new DOMResult();
        toResult(source, result);
        return result.getNode();
    }
    /**
     * Converts the given TRaX Source into a W3C DOM node
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     */
    @Converter
    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        DOMSource domSrc = toDOMSource(source);
        return domSrc != null ? domSrc.getNode() :  null;
    }
    /**
     * Create a DOM element from the given source.
     */
    @Converter
    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMElement(node);
    }
    /**
     * Create a DOM element from the DOM node.
     * Simply cast if the node is an Element, or
     * return the root element if it is a Document.
     */
    @Converter
    public Element toDOMElement(Node node) throws TransformerException {
        // If the node is an document, return the root element
        if (node instanceof Document) {
            return ((Document) node).getDocumentElement();
        // If the node is an element, just cast it
        } else if (node instanceof Element) {
            return (Element) node;
        // Other node types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to an Element"");
        }
    }
    /**
     * Converts the given data to a DOM document
     *
     * @param data is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(new ByteArrayInputStream(data));
    }
    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(Reader in) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(new InputSource(in));
    }
    /**
     * Converts the given {@link InputSource} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link String} to a DOM document
     *
     * @param text is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(new StringReader(text));
    }
    /**
     * Converts the given {@link File} to a DOM document
     *
     * @param file is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(file);
    }
    /**
     * Create a DOM document from the given source.
     */
    @Converter
    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMDocument(node);
    }
    /**
     * Create a DOM document from the given Node.
     * If the node is an document, just cast it,
     * if the node is an root element, retrieve its
     * owner element or create a new document and import
     * the node.
     */
    @Converter
    public Document toDOMDocument(Node node) throws ParserConfigurationException, TransformerException {
        // If the node is the document, just cast it
        if (node instanceof Document) {
            return (Document) node;
        // If the node is an element
        } else if (node instanceof Element) {
            Element elem = (Element) node;
            // If this is the root element, return its owner document
            if (elem.getOwnerDocument().getDocumentElement() == elem) {
                return elem.getOwnerDocument();
            // else, create a new doc and copy the element inside it
            } else {
                Document doc = createDocument();
                doc.appendChild(doc.importNode(node, true));
                return doc;
            }
        // other element types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to a Document"");
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory getDocumentBuilderFactory() {
        if (documentBuilderFactory == null) {
            documentBuilderFactory = createDocumentBuilderFactory();
        }
        return documentBuilderFactory;
    }
    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    // Helper methods
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory createDocumentBuilderFactory() {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setIgnoringElementContentWhitespace(true);
        factory.setIgnoringComments(true);
        return factory;
    }
    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = getDocumentBuilderFactory();
        return factory.newDocumentBuilder();
    }
    public Document createDocument() throws ParserConfigurationException {
        DocumentBuilder builder = createDocumentBuilder();
        return builder.newDocument();
    }
    public TransformerFactory getTransformerFactory() {
        if (transformerFactory == null) {
            transformerFactory = createTransformerFactory();
        }
        return transformerFactory;
    }
    public void setTransformerFactory(TransformerFactory transformerFactory) {
        this.transformerFactory = transformerFactory;
    }
    public Transformer createTransfomer() throws TransformerConfigurationException {
        TransformerFactory factory = getTransformerFactory();
        return factory.newTransformer();
    }
    public TransformerFactory createTransformerFactory() {
        TransformerFactory answer = TransformerFactory.newInstance();
        return answer;
    }
}
"
org.apache.camel.ValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The base class for any validation exception, such as
 * {@link org.apache.camel.processor.validation.SchemaValidationException} so
 * that it is easy to treat all validation errors in a similar way irrespective
 * of the particular validation technology used.
 * 
 * @version $Revision$
 */
public class ValidationException extends CamelExchangeException {
    public ValidationException(Exchange exchange, String message) {
        super(message, exchange);
    }
    public ValidationException(String message, Exchange exchange, Throwable cause) {
        super(message, exchange, cause);
    }
}
"
org.apache.camel.converter.jaxp.StreamSourceConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Converter;
/**
 * A converter from {@link StreamSource} objects
 *
 * @version $Revision$
 */
@Converter
public class StreamSourceConverter {
    @Converter
    public InputStream toInputStream(StreamSource source) {
        return source.getInputStream();
    }
    @Converter
    public Reader toReader(StreamSource source) {
        return source.getReader();
    }
}"
org.apache.camel.component.jms.DefaultQueueBrowseStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.QueueBrowser;
import javax.jms.Session;
import org.apache.camel.Exchange;
import org.springframework.jms.core.BrowserCallback;
import org.springframework.jms.core.JmsOperations;
/**
 * A default implementation of queue browsing using the Spring 2.5.x {@link BrowserCallback}
 * @version $Revision$
 */
public class DefaultQueueBrowseStrategy implements QueueBrowseStrategy {
    public List<Exchange> browse(JmsOperations template, String queue, final JmsQueueEndpoint endpoint) {
        return  (List<Exchange>) template.browse(queue, new BrowserCallback() {
            public Object doInJms(Session session, QueueBrowser browser) throws JMSException {
                // TODO not the best implementation in the world as we have to browse
                // the entire queue, which could be massive
                List<Exchange> answer = new ArrayList<Exchange>();
                Enumeration iter = browser.getEnumeration();
                while (iter.hasMoreElements()) {
                    Message message = (Message) iter.nextElement();
                    JmsExchange exchange = endpoint.createExchange(message);
                    answer.add(exchange);
                }
                return answer;
            }
        });
    }
}
"
org.apache.camel.component.http.HttpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.http.helper.LoadingByteArrayOutputStream;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.EntityEnclosingMethod;
import org.apache.commons.httpclient.methods.RequestEntity;
import org.apache.commons.httpclient.methods.StringRequestEntity;
import org.apache.commons.io.IOUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.component.http.HttpMethods.HTTP_METHOD;
/**
 * @version $Revision$
 */
public class HttpProducer extends DefaultProducer<HttpExchange> implements Producer<HttpExchange> {
    public static final String HTTP_URI = ""http.uri"";
    public static final String HTTP_RESPONSE_CODE = ""http.responseCode"";
    public static final String QUERY = ""org.apache.camel.component.http.query"";    
    // This should be a set of lower-case strings
    @Deprecated
    public static final Set<String> HEADERS_TO_SKIP =
        new HashSet<String>(Arrays.asList(""content-length"", ""content-type"", HTTP_RESPONSE_CODE.toLowerCase()));
    private static final transient Log LOG = LogFactory.getLog(HttpProducer.class);
    private HttpClient httpClient;
    public HttpProducer(HttpEndpoint endpoint) {
        super(endpoint);
        httpClient = endpoint.createHttpClient();
    }
    public void process(Exchange exchange) throws Exception {
        HttpMethod method = createMethod(exchange);
        Message in = exchange.getIn();
        HeaderFilterStrategy strategy = ((HttpEndpoint)getEndpoint()).getHeaderFilterStrategy();
        // propagate headers as HTTP headers
        for (String headerName : in.getHeaders().keySet()) {
            String headerValue = in.getHeader(headerName, String.class);
            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {
                method.addRequestHeader(headerName, headerValue);
            }
        }
        // lets store the result in the output message.
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Executing http "" + method.getName() + "" method: "" + method.getURI().toString());
            }
            int responseCode = executeMethod(method);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Http responseCode: "" + responseCode);
            }
            if (responseCode >= 100 && responseCode < 300) {
                Message answer = exchange.getOut(true);
                answer.setHeaders(in.getHeaders());
                answer.setHeader(HTTP_RESPONSE_CODE, responseCode);
                answer.setBody(extractResponseBody(method));
                // propagate HTTP response headers
                Header[] headers = method.getResponseHeaders();
                for (Header header : headers) {
                    String name = header.getName();
                    String value = header.getValue();
                    if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {
                        answer.setHeader(name, value);
                    }
                }
            } else {
                HttpOperationFailedException exception = null;
                Header[] headers = method.getResponseHeaders();
                InputStream is =  extractResponseBody(method);
                if (responseCode >= 300 && responseCode < 400) {
                    String redirectLocation;
                    Header locationHeader = method.getResponseHeader(""location"");
                    if (locationHeader != null) {
                        redirectLocation = locationHeader.getValue();
                        exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), redirectLocation, headers, is);
                    } else {
                        // no redirect location
                        exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, is);
                    }
                } else {
                    // internal server error (error code 500)
                    exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, is);
                }
                if (exception != null) {                    
                    throw exception;
                }
            }
        } finally {
            method.releaseConnection();
        }
    }
    /**
     * Strategy when executing the method (calling the remote server).
     *
     * @param method    the method to execute
     * @return the response code
     * @throws IOException can be thrown
     */
    protected int executeMethod(HttpMethod method) throws IOException {
        return httpClient.executeMethod(method);
    }
    /**
     * Extracts the response from the method as a InputStream.
     *
     * @param method  the method that was executed
     * @return  the response as a stream
     * @throws IOException can be thrown
     */
    protected static InputStream extractResponseBody(HttpMethod method) throws IOException {
        LoadingByteArrayOutputStream bos = null;
        InputStream is = null;
        try {
            bos = new LoadingByteArrayOutputStream();
            is = method.getResponseBodyAsStream();
            // in case of no response stream
            if (is == null) {
                return null;
            }
            IOUtils.copy(is, bos);
            bos.flush();
            return bos.createInputStream();
        } finally {
            ObjectHelper.close(is, ""Extracting response body"", LOG);
            ObjectHelper.close(bos, ""Extracting response body"", LOG);
        }
    }
    /**
     * Creates the HttpMethod to use to call the remote server, either its GET or POST.
     *
     * @param exchange  the exchange
     * @return the created method as either GET or POST
     */
    protected HttpMethod createMethod(Exchange exchange) {
        // is a query string provided in the endpoint URI or in a header (header overrules endpoint)
        String queryString = exchange.getIn().getHeader(QUERY, String.class);
        if (queryString == null) {
            queryString = ((HttpEndpoint)getEndpoint()).getHttpUri().getQuery();
        }
        RequestEntity requestEntity = createRequestEntity(exchange);
        // compute what method to use either GET or POST
        HttpMethods methodToUse;
        HttpMethods m = exchange.getIn().getHeader(HTTP_METHOD, HttpMethods.class);
        if (m != null) {
            // always use what end-user provides in a header
            methodToUse = m;
        } else if (queryString != null) {
            // if a query string is provided then use GET
            methodToUse = HttpMethods.GET;
        } else {
            // fallback to POST if data, otherwise GET
            methodToUse = requestEntity != null ? HttpMethods.POST : HttpMethods.GET;
        }
        String uri = exchange.getIn().getHeader(HTTP_URI, String.class);
        if (uri == null) {
            uri = ((HttpEndpoint)getEndpoint()).getHttpUri().toString();
        }
        HttpMethod method = methodToUse.createMethod(uri);
        if (queryString != null) {
            method.setQueryString(queryString);
        }
        if (methodToUse.isEntityEnclosing()) {
            ((EntityEnclosingMethod)method).setRequestEntity(requestEntity);
        }
        return method;
    }
    /**
     * Creates a holder object for the data to send to the remote server.
     *
     * @param exchange  the exchange with the IN message with data to send
     * @return the data holder
     */
    protected RequestEntity createRequestEntity(Exchange exchange) {
        Message in = exchange.getIn();
        if (in.getBody() == null) {
            return null;
        }
        try {
            return in.getBody(RequestEntity.class);
        } catch (NoTypeConversionAvailableException ex) {
            try {
                String data = in.getBody(String.class);
                if (data != null) {
                    String contentType = in.getHeader(""Content-Type"", String.class);
                    String charset = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
                    return new StringRequestEntity(data, contentType, charset);
                } else {
                    // no data
                    return null;
                }
            } catch (UnsupportedEncodingException e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
    public HttpClient getHttpClient() {
        return httpClient;
    }
    public void setHttpClient(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
}
"
org.apache.camel.component.ibatis.IBatisPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.PollingConsumerSupport;
/**
 * @version $Revision$
 */
public class IBatisPollingConsumer extends PollingConsumerSupport {
    private final IBatisEndpoint endpoint;
    public IBatisPollingConsumer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public Exchange receive(long timeout) {
        return receiveNoWait();
    }
    public Exchange receive() {
        return receiveNoWait();
    }
    public Exchange receiveNoWait() {
        try {
            Exchange exchange = endpoint.createExchange();
            Message in = exchange.getIn();
            endpoint.query(in);
            return exchange;
        } catch (Exception e) {
            throw new RuntimeCamelException(""Failed to poll: "" + endpoint + "". Reason: "" + e, e);
        }
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.file.remote.FtpOperationFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.RuntimeCamelException;
/**
 * Exception thrown in case of last FTP operation failed.
 *
 * @version $Revision$
 */
public class FtpOperationFailedException extends RuntimeCamelException {
    private final int code;
    private final String reason;
    public FtpOperationFailedException(int code, String reason) {
        super(""Ftp operation failed: "" + reason + "". Code: "" + code);
        this.code = code;
        this.reason = reason;
    }
    public FtpOperationFailedException(int code, String reason, String message) {
        this(code, reason + "" "" + message);
    }
    /**
     * Return the FTP failure code
     */
    public int getCode() {
        return code;
    }
    /**
     * Return the FTP failure reason
     */
    public String getReason() {
        return reason;
    }
}
"
org.apache.camel.impl.PollingConsumerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.spi.ExceptionHandler;
/**
 * A useful base class for implementations of {@link PollingConsumer}
 * 
 * @version $Revision$
 */
public abstract class PollingConsumerSupport<E extends Exchange> extends ServiceSupport implements
    PollingConsumer<E> {
    private final Endpoint<E> endpoint;
    private ExceptionHandler exceptionHandler;
    public PollingConsumerSupport(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""PullConsumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org.apache.camel.builder.xml.XsltBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Exchange;
import org.apache.camel.ExpectedBodyTypeException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeTransformException;
import org.apache.camel.converter.jaxp.XmlConverter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Creates a <a href=""http://activemq.apache.org/camel/processor.html"">Processor</a>
 * which performs an XSLT transformation of the IN message body
 *
 * @version $Revision$
 */
public class XsltBuilder implements Processor {
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private XmlConverter converter = new XmlConverter();
    private Templates template;
    private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory();
    private boolean failOnNullBody = true;
    public XsltBuilder() {
    }
    public XsltBuilder(Templates templates) {
        this.template = templates;
    }
    @Override
    public String toString() {
        return ""XSLT["" + template + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        if (getTemplate() == null) {
            throw new IllegalArgumentException(""No template configured!"");
        }
        Transformer transformer = getTemplate().newTransformer();
        configureTransformer(transformer, exchange);
        Source source = getSource(exchange);
        ResultHandler resultHandler = resultHandlerFactory.createResult();
        Result result = resultHandler.getResult();
        // lets copy the headers before we invoke the transform in case they modify them
        Message out = exchange.getOut(true);
        out.copyFrom(exchange.getIn());
        transformer.transform(source, result);
        resultHandler.setBody(out);
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Creates an XSLT processor using the given templates instance
     */
    public static XsltBuilder xslt(Templates templates) {
        return new XsltBuilder(templates);
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        XsltBuilder answer = new XsltBuilder();
        answer.setTransformerSource(xslt);
        return answer;
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(xslt.openStream());
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Sets the output as being a byte[]
     */
    public XsltBuilder outputBytes() {
        setResultHandlerFactory(new StreamResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a String
     */
    public XsltBuilder outputString() {
        setResultHandlerFactory(new StringResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a DOM
     */
    public XsltBuilder outputDOM() {
        setResultHandlerFactory(new DomResultHandlerFactory());
        return this;
    }
    public XsltBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Map<String, Object> getParameters() {
        return parameters;
    }
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    public void setTemplate(Templates template) {
        this.template = template;
    }
    public Templates getTemplate() {
        return template;
    }
    public boolean isFailOnNullBody() {
        return failOnNullBody;
    }
    public void setFailOnNullBody(boolean failOnNullBody) {
        this.failOnNullBody = failOnNullBody;
    }
    public ResultHandlerFactory getResultHandlerFactory() {
        return resultHandlerFactory;
    }
    public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {
        this.resultHandlerFactory = resultHandlerFactory;
    }
    /**
     * Sets the XSLT transformer from a Source
     *
     * @param source  the source
     * @throws TransformerConfigurationException is thrown if creating a XSLT transformer failed.
     */
    public void setTransformerSource(Source source) throws TransformerConfigurationException {
        // Check that the call to newTemplates() returns a valid template instance.
        // In case of an xslt parse error, it will return null and we should stop the
        // deployment and raise an exception as the route will not be setup properly.
        Templates templates = converter.getTransformerFactory().newTemplates(source);
        if (templates != null) {
            setTemplate(templates);
        } else {
            throw new TransformerConfigurationException(""Error creating XSLT template. ""
                    + ""This is most likely be caused by an XML parse error. ""
                    + ""Please verify your XSLT file configured."");
        }
    }
    /**
     * Sets the XSLT transformer from a File
     */
    public void setTransformerFile(File xslt) throws TransformerConfigurationException {
        setTransformerSource(new StreamSource(xslt));
    }
    /**
     * Sets the XSLT transformer from a URL
     */
    public void setTransformerURL(URL url) throws TransformerConfigurationException, IOException {
        notNull(url, ""url"");
        setTransformerInputStream(url.openStream());
    }
    /**
     * Sets the XSLT transformer from the given input stream
     */
    public void setTransformerInputStream(InputStream in) throws TransformerConfigurationException, IOException {
        notNull(in, ""in"");
        setTransformerSource(new StreamSource(in));
    }
    public XmlConverter getConverter() {
        return converter;
    }
    public void setConverter(XmlConverter converter) {
        this.converter = converter;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Converts the inbound body to a {@link Source}
     */
    protected Source getSource(Exchange exchange) {
        Message in = exchange.getIn();
        Source source = in.getBody(Source.class);
        if (source == null) {
            if (isFailOnNullBody()) {
                throw new ExpectedBodyTypeException(exchange, Source.class);
            } else {
                try {
                    source = converter.toSource(converter.createDocument());
                } catch (ParserConfigurationException e) {
                    throw new RuntimeTransformException(e);
                }
            }
        }
        return source;
    }
    /**
     * Configures the transformer with exchange specific parameters
     */
    protected void configureTransformer(Transformer transformer, Exchange exchange) {
        transformer.clearParameters();
        addParameters(transformer, exchange.getProperties());
        addParameters(transformer, exchange.getIn().getHeaders());
        addParameters(transformer, getParameters());
        transformer.setParameter(""exchange"", exchange);
        transformer.setParameter(""in"", exchange.getIn());
        transformer.setParameter(""out"", exchange.getOut());
    }
    protected void addParameters(Transformer transformer, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                transformer.setParameter(key, value);
            }
        }
    }
}
"
org.apache.camel.component.file.strategy.FileRenamer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileExchange;
/**
 * Used for renaming files.
 *
 * @version $Revision$
 */
public interface FileRenamer {
    /**
     * Renames the given file
     *
     * @param exchange  the exchange
     * @param file      the original file.
     * @return the renamed file.
     */
    File renameFile(FileExchange exchange, File file);
}
"
org.apache.camel.component.cxf.invoker.AbstractInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
/**
 * A RoutingContext encapulates specific knowledge about how to route messages of
 * a particular data format.
 *
 */
public abstract class AbstractInvokingContext implements InvokingContext {
    protected abstract Logger getLogger();
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
            Class <T> clazz) {
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                getLogger().info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.getContent(clazz);
        }
        return retval;
    }
    protected void loggerTheMessage(Message message, String messageTile) {
        StringBuffer buffer = new StringBuffer(messageTile + ""\n""
                                               + ""--------------------------------------"");
        InputStream is = message.getContent(InputStream.class);
        if (is != null) {
            CachedOutputStream bos = new CachedOutputStream();
            try {
                IOUtils.copy(is, bos);
                is.close();
                bos.close();
                buffer.append(""\nMessage:\n"");
                buffer.append(bos.getOut().toString());
                message.setContent(InputStream.class, bos.getInputStream());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        buffer.append(""\n--------------------------------------"");
        getLogger().info(buffer.toString());
    }
}
"
org.apache.camel.management.CamelNamingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.net.InetAddress;
import java.net.UnknownHostException;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.RouteContext;
/**
 * Naming strategy used when registering MBeans.
 */
public class CamelNamingStrategy {
    public static final String VALUE_UNKNOWN = ""unknown"";
    public static final String KEY_NAME = ""name"";
    public static final String KEY_TYPE = ""type"";
    public static final String KEY_CONTEXT = ""context"";
    public static final String KEY_GROUP = ""group"";
    public static final String KEY_ROUTE = ""route"";
    public static final String KEY_NODE_ID = ""nodeid"";
    public static final String TYPE_CONTEXT = ""context"";
    public static final String TYPE_ENDPOINT = ""endpoints"";
    public static final String TYPE_PROCESSOR = ""processors"";
    public static final String TYPE_CONSUMER = ""consumers"";
    public static final String TYPE_ROUTE = ""routes"";
    protected String domainName;
    protected String hostName = ""locahost"";
    public CamelNamingStrategy() {
        this(""org.apache.camel"");
    }
    public CamelNamingStrategy(String domainName) {
        if (domainName != null) {
            this.domainName = domainName;
        }
        try {
            hostName = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException ex) {
            // ignore, use the default ""locahost""
        }
    }
    /**
     * Implements the naming strategy for a {@link CamelContext}.
     * The convention used for a {@link CamelContext} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=context,name=&lt;context-name&gt;</tt>
     *
     * @param context the camel context
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(CamelContext context) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_NAME + ""="").append(""context"");
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ManagedEndpoint}.
     * The convention used for a {@link ManagedEndpoint} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=endpoint,component=&lt;component-name&gt;name=&lt;endpoint-name&gt;</tt>
     */
    public ObjectName getObjectName(ManagedEndpoint mbean) throws MalformedObjectNameException {
        Endpoint<? extends Exchange> ep = mbean.getEndpoint();
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(ep.getCamelContext())).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_ENDPOINT + "","");
        buffer.append(KEY_NAME + ""="").append(ObjectName.quote(getEndpointId(ep)));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link org.apache.camel.impl.ServiceSupport Service}.
     * The convention used for a {@link org.apache.camel.Service Service} ObjectName is
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=service,name=&lt;service-name&gt;</tt>
     */
    public ObjectName getObjectName(CamelContext context, ManagedService mbean) throws MalformedObjectNameException {
        String serviceBranch;
        Service service = mbean.getService();
        if (service instanceof Consumer) {
            serviceBranch = TYPE_CONSUMER;
        } else {
            return null;
        }
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_TYPE + ""="" + serviceBranch + "","");
        buffer.append(KEY_NAME + ""="")
            .append(service.getClass().getSimpleName())
            .append(""(0x"").append(Integer.toHexString(mbean.getService().hashCode())).append("")"");
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ManagedRoute}.
     * The convention used for a {@link ManagedRoute} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,route=&lt;route-name&gt;,type=route,name=&lt;route-name&gt;</tt>
     */
    public ObjectName getObjectName(ManagedRoute mbean) throws MalformedObjectNameException {
        Route<? extends Exchange> route = mbean.getRoute();
        Endpoint<? extends Exchange> ep = route.getEndpoint();
        String id = (String)route.getProperties().get(Route.ID_PROPERTY);
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(ep.getCamelContext())).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_ROUTE + "","");
        buffer.append(KEY_NAME + ""="").append(ObjectName.quote(id == null ? (""0x"" + Integer.toHexString(route.hashCode())) : id));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ProcessorType}.
     * The convention used for a {@link ProcessorType} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,route=&lt;route-name&gt;,type=processor,name=&lt;processor-name&gt;,nodeid=&lt;node-id&gt;</tt>
     */
    public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)
        throws MalformedObjectNameException {
        Endpoint<? extends Exchange> ep = routeContext.getEndpoint();
        String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;
        String cid = ObjectName.quote(ep.getEndpointUri());
        //String id = VALUE_UNKNOWN.equals(cid) ? ObjectName.quote(getEndpointId(ep) : ""["" + cid + ""]"" + ObjectName.quote(getEndpointId(ep);
        String nodeId = processor.idOrCreate();
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(ctxid).append("","");
        // buffer.append(KEY_ROUTE + ""="").append(id).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_PROCESSOR + "","");
        buffer.append(KEY_NODE_ID + ""="").append(nodeId).append("","");
        buffer.append(KEY_NAME + ""="").append(ObjectName.quote(processor.toString()));
        return createObjectName(buffer);
    }
    public String getDomainName() {
        return domainName;
    }
    public void setDomainName(String domainName) {
        this.domainName = domainName;
    }
    public String getHostName() {
        return hostName;
    }
    public void setHostName(String hostName) {
        this.hostName = hostName;
    }
    protected String getContextId(CamelContext context) {
        return hostName + ""/"" + (context != null ? context.getName() : VALUE_UNKNOWN);
    }
    protected String getEndpointId(Endpoint<? extends Exchange> ep) {
        String uri = ep.getEndpointUri();
        int pos = uri.indexOf('?');
        String id = (pos == -1) ? uri : uri.substring(0, pos);
        id += ""?id=0x"" + Integer.toHexString(ep.hashCode());
        return id;
    }
    /**
     * Factory method to create an ObjectName escaping any required characters
     */
    protected ObjectName createObjectName(StringBuffer buffer) throws MalformedObjectNameException {
        String text = buffer.toString();
        try {
            return new ObjectName(text);
        } catch (MalformedObjectNameException e) {
            throw new MalformedObjectNameException(""Could not create ObjectName from: "" + text + "". Reason: "" + e);
        }
    }
}
"
org.apache.camel.bam.rules.ProcessRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision$
 */
public class ProcessRules extends ServiceSupport {
    private ProcessDefinition processDefinition;
    private List<ActivityRules> activities = new ArrayList<ActivityRules>();
    public void processExpired(ActivityState activityState) throws Exception {
        for (ActivityRules activityRules : activities) {
            activityRules.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (ActivityRules activityRules : activities) {
            activityRules.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ActivityRules> getActivities() {
        return activities;
    }
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(activities);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(activities);
    }
}
"
org.apache.camel.component.rmi.RmiEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.net.URI;
import java.net.URISyntaxException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * @version $Revision:520964 $
 */
public class RmiEndpoint extends DefaultEndpoint<BeanExchange> {
    private List<Class> remoteInterfaces;
    private ClassLoader classLoader;
    private URI uri;
    private int port;
    private String method;
    protected RmiEndpoint(String endpointUri, RmiComponent component) throws URISyntaxException {
        super(endpointUri, component);
        this.uri = new URI(endpointUri);
    }
    public RmiEndpoint(String endpointUri) throws URISyntaxException {
        super(endpointUri);
        this.uri = new URI(endpointUri);
    }
    public boolean isSingleton() {
        return false;
    }
    @Override
    public BeanExchange createExchange(ExchangePattern pattern) {
        return new BeanExchange(getCamelContext(), pattern);
    }
    public Consumer<BeanExchange> createConsumer(Processor processor) throws Exception {
        if (remoteInterfaces == null || remoteInterfaces.size() == 0) {
            throw new RuntimeCamelException(""To create a RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured."");
        }
        return new RmiConsumer(this, processor);
    }
    public Producer<BeanExchange> createProducer() throws Exception {
        return new RmiProducer(this);
    }
    public String getName() {
        String path = uri.getPath();
        if (path == null) {
            path = uri.getSchemeSpecificPart();
        }
        // skip leading slash
        if (path.startsWith(""/"")) {
            return path.substring(1);
        }
        return path;
    }
    public Registry getRegistry() throws RemoteException {
        if (uri.getHost() != null) {
            if (uri.getPort() == -1) {
                return LocateRegistry.getRegistry(uri.getHost());
            } else {
                return LocateRegistry.getRegistry(uri.getHost(), uri.getPort());
            }
        } else {
            return LocateRegistry.getRegistry();
        }
    }
    public List<Class> getRemoteInterfaces() {
        return remoteInterfaces;
    }
    public void setRemoteInterfaces(List<Class> remoteInterfaces) {
        this.remoteInterfaces = remoteInterfaces;
        if (classLoader == null && !remoteInterfaces.isEmpty()) {
            classLoader = remoteInterfaces.get(0).getClassLoader();
        }
    }
    public void setRemoteInterfaces(Class... remoteInterfaces) {
        setRemoteInterfaces(Arrays.asList(remoteInterfaces));
    }
    public ClassLoader getClassLoader() {
        return classLoader;
    }
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
}
"
org.apache.camel.bam.model.TemporalEntity,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Date;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
/**
 * @version $Revision$
 */
public abstract class TemporalEntity extends EntitySupport {
    private Date timeStarted;
    private Date timeCompleted;
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }
}
"
org.apache.camel.bam.processor.BamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A base {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which a derived
 * class would do the actual persistence such as the {@link JpaBamProcessor}
 *
 * @version $Revision$
 */
public abstract class BamProcessorSupport<T> implements Processor {
    private static final transient Log LOG = LogFactory.getLog(BamProcessorSupport.class);
    private Class<T> entityType;
    private Expression<Exchange> correlationKeyExpression;
    private TransactionTemplate transactionTemplate;
    private int retryCount = 20;
    private long retrySleep = 1000L;
    protected BamProcessorSupport(TransactionTemplate transactionTemplate,
                                  Expression<Exchange> correlationKeyExpression) {
        this.transactionTemplate = transactionTemplate;
        this.correlationKeyExpression = correlationKeyExpression;
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType)type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    this.entityType = (Class<T>)argumentType;
                }
            }
        }
        if (entityType == null) {
            throw new IllegalArgumentException(""Could not infer the entity type!"");
        }
    }
    protected BamProcessorSupport(TransactionTemplate transactionTemplate,
                                  Expression<Exchange> correlationKeyExpression, Class<T> entitytype) {
        this.transactionTemplate = transactionTemplate;
        this.entityType = entitytype;
        this.correlationKeyExpression = correlationKeyExpression;
    }
    public void process(final Exchange exchange) {
        for (int i = 1; i <= retryCount; i++) {
            if (i > 1) {
                LOG.info(""Retrying attempt: "" + i);
                try {
                    Thread.sleep(retryCount);
                } catch (InterruptedException e) {
                    LOG.debug(""Caught: "" + e, e);
                }
            }
            try {
                transactionTemplate.execute(new TransactionCallback() {
                    public Object doInTransaction(TransactionStatus status) {
                        try {
                            Object key = getCorrelationKey(exchange);
                            T entity = loadEntity(exchange, key);
                            if (LOG.isDebugEnabled()) {
                                LOG.debug(""Correlation key: "" + key + "" with entity: "" + entity);
                            }
                            processEntity(exchange, entity);
                            return entity;
                        } catch (Exception e) {
                            return onError(status, e);
                        }
                    }
                });
                if (i > 1) {
                    LOG.info(""Attempt "" + i + "" worked!"");
                }
                return;
            } catch (Exception e) {
                LOG.warn(""Failed to complete transaction: "" + e, e);
            }
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public Expression<Exchange> getCorrelationKeyExpression() {
        return correlationKeyExpression;
    }
    public Class<T> getEntityType() {
        return entityType;
    }
    // Implemenation methods
    // -----------------------------------------------------------------------
    protected abstract void processEntity(Exchange exchange, T entity) throws Exception;
    protected abstract T loadEntity(Exchange exchange, Object key) throws Exception;
    protected abstract Class getKeyType();
    protected Object getCorrelationKey(Exchange exchange) throws NoCorrelationKeyException {
        Object value = correlationKeyExpression.evaluate(exchange);
        Class keyType = getKeyType();
        if (keyType != null) {
            value = ExchangeHelper.convertToType(exchange, keyType, value);
        }
        if (value == null) {
            throw new NoCorrelationKeyException(this, exchange);
        }
        return value;
    }
    protected Object onError(TransactionStatus status, Exception e) {
        status.setRollbackOnly();
        LOG.error(""Caught: "" + e, e);
        throw wrapRuntimeCamelException(e);
    }
}
"
org.apache.camel.component.xquery.XQueryBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringWriter;
import java.net.URL;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Node;
import net.sf.saxon.Configuration;
import net.sf.saxon.om.DocumentInfo;
import net.sf.saxon.om.Item;
import net.sf.saxon.om.SequenceIterator;
import net.sf.saxon.query.DynamicQueryContext;
import net.sf.saxon.query.StaticQueryContext;
import net.sf.saxon.query.XQueryExpression;
import net.sf.saxon.trans.XPathException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.jaxp.BytesSource;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Creates an XQuery builder
 *
 * @version $Revision$
 */
public abstract class XQueryBuilder implements Expression<Exchange>, Predicate<Exchange>, NamespaceAware, Processor {
    private static final transient Log LOG = LogFactory.getLog(XQueryBuilder.class);
    private Configuration configuration;
    private XQueryExpression expression;
    private StaticQueryContext staticQueryContext;
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private Map<String, String> namespacePrefixes = new HashMap<String, String>();
    private XmlConverter converter = new XmlConverter();
    private ResultFormat resultsFormat = ResultFormat.DOM;
    private Properties properties = new Properties();
    private Class resultType;
    private final AtomicBoolean initialized = new AtomicBoolean(false);
    @Override
    public String toString() {
        return ""XQuery["" + expression + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object body = evaluate(exchange);
        exchange.getOut(true).setBody(body);
        // propogate headers
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
    }
    public Object evaluate(Exchange exchange) {
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Evaluation "" + expression + "" for exchange: "" + exchange);
            }
            if (resultType != null) {
                if (resultType.equals(String.class)) {
                    return evaluateAsString(exchange);
                } else if (resultType.isAssignableFrom(Collection.class)) {
                    return evaluateAsList(exchange);
                } else if (resultType.isAssignableFrom(Node.class)) {
                    return evaluateAsDOM(exchange);
                } else {
                    throw new IllegalArgumentException(""ResultType: "" + resultType.getCanonicalName() + "" not supported"");
                }
            }
            switch (resultsFormat) {
            case Bytes:
                return evaluateAsBytes(exchange);
            case BytesSource:
                return evaluateAsBytesSource(exchange);
            case DOM:
                return evaluateAsDOM(exchange);
            case List:
                return evaluateAsList(exchange);
            case StringSource:
                return evaluateAsStringSource(exchange);
            case String:
            default:
                return evaluateAsString(exchange);
            }
        } catch (Exception e) {
            throw new RuntimeExpressionException(e);
        }
    }
    public List evaluateAsList(Exchange exchange) throws Exception {
        initialize(exchange);
        return getExpression().evaluate(createDynamicContext(exchange));
    }
    public Object evaluateAsStringSource(Exchange exchange) throws Exception {
        initialize(exchange);
        String text = evaluateAsString(exchange);
        return new StringSource(text);
    }
    public Object evaluateAsBytesSource(Exchange exchange) throws Exception {
        initialize(exchange);
        byte[] bytes = evaluateAsBytes(exchange);
        return new BytesSource(bytes);
    }
    public Node evaluateAsDOM(Exchange exchange) throws Exception {
        initialize(exchange);
        DOMResult result = new DOMResult();
        DynamicQueryContext context = createDynamicContext(exchange);
        XQueryExpression expression = getExpression();
        expression.pull(context, result, properties);
        return result.getNode();
    }
    public byte[] evaluateAsBytes(Exchange exchange) throws Exception {
        initialize(exchange);
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Result result = new StreamResult(buffer);
        getExpression().pull(createDynamicContext(exchange), result, properties);
        byte[] bytes = buffer.toByteArray();
        return bytes;
    }
    public String evaluateAsString(Exchange exchange) throws Exception {
        initialize(exchange);
        StringWriter buffer = new StringWriter();
        SequenceIterator iter = getExpression().iterator(createDynamicContext(exchange));
        for (Item item = iter.next(); item != null; item = iter.next()) {
            buffer.append(item.getStringValueCS());
        }
        return buffer.toString();
    }
    public boolean matches(Exchange exchange) {
        try {
            List list = evaluateAsList(exchange);
            return matches(exchange, list);
        } catch (Exception e) {
            throw new RuntimeExpressionException(e);
        }
    }
    public void assertMatches(String text, Exchange exchange) throws AssertionError {
        try {
            List list = evaluateAsList(exchange);
            if (!matches(exchange, list)) {
                throw new AssertionError(this + "" failed on "" + exchange + "" as evaluated: "" + list);
            }
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
    // Static helper methods
    //-------------------------------------------------------------------------
    public static XQueryBuilder xquery(final String queryText) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException {
                return staticQueryContext.compileQuery(queryText);
            }
        };
    }
    public static XQueryBuilder xquery(final Reader reader) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException, IOException {
                return staticQueryContext.compileQuery(reader);
            }
        };
    }
    public static XQueryBuilder xquery(final InputStream in, final String characterSet) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException, IOException {
                return staticQueryContext.compileQuery(in, characterSet);
            }
        };
    }
    public static XQueryBuilder xquery(File file, String characterSet) throws FileNotFoundException {
        return xquery(IOConverter.toInputStream(file), characterSet);
    }
    public static XQueryBuilder xquery(URL url, String characterSet) throws IOException {
        return xquery(IOConverter.toInputStream(url), characterSet);
    }
    public static XQueryBuilder xquery(File file) throws FileNotFoundException {
        return xquery(IOConverter.toInputStream(file), ObjectHelper.getDefaultCharacterSet());
    }
    public static XQueryBuilder xquery(URL url) throws IOException {
        return xquery(IOConverter.toInputStream(url), ObjectHelper.getDefaultCharacterSet());
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public XQueryBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }
    public XQueryBuilder namespace(String prefix, String uri) {
        namespacePrefixes.put(prefix, uri);
        // more namespace, we must re initialize
        initialized.set(false);
        return this;
    }
    public XQueryBuilder resultType(Class resultType) {
        setResultType(resultType);
        return this;
    }
    public XQueryBuilder asBytes() {
        setResultsFormat(ResultFormat.Bytes);
        return this;
    }
    public XQueryBuilder asBytesSource() {
        setResultsFormat(ResultFormat.BytesSource);
        return this;
    }
    public XQueryBuilder asDOM() {
        setResultsFormat(ResultFormat.DOM);
        return this;
    }
    public XQueryBuilder asDOMSource() {
        setResultsFormat(ResultFormat.DOMSource);
        return this;
    }
    public XQueryBuilder asList() {
        setResultsFormat(ResultFormat.List);
        return this;
    }
    public XQueryBuilder asString() {
        setResultsFormat(ResultFormat.String);
        return this;
    }
    public XQueryBuilder asStringSource() {
        setResultsFormat(ResultFormat.StringSource);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Configures the namespace context from the given DOM element
     */
    public void setNamespaces(Map<String, String> namespaces) {
        namespacePrefixes.putAll(namespaces);
        // more namespace, we must re initialize
        initialized.set(false);
    }
    public XQueryExpression getExpression() throws IOException, XPathException {
        return expression;
    }
    public Configuration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(Configuration configuration) {
        this.configuration = configuration;
        // change configuration, we must re intialize
        initialized.set(false);
    }
    public StaticQueryContext getStaticQueryContext() {
        return staticQueryContext;
    }
    public void setStaticQueryContext(StaticQueryContext staticQueryContext) {
        this.staticQueryContext = staticQueryContext;
        // change context, we must re intialize
        initialized.set(false);
    }
    public Map<String, Object> getParameters() {
        return parameters;
    }
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    public Properties getProperties() {
        return properties;
    }
    public void setProperties(Properties properties) {
        this.properties = properties;
    }
    public ResultFormat getResultsFormat() {
        return resultsFormat;
    }
    public void setResultsFormat(ResultFormat resultsFormat) {
        this.resultsFormat = resultsFormat;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A factory method to create the XQuery expression
     */
    protected abstract XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
        throws XPathException, IOException;
    /**
     * Creates a dynamic context for the given exchange
     */
    protected DynamicQueryContext createDynamicContext(Exchange exchange) throws Exception {
        Configuration config = getConfiguration();
        DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config);
        Message in = exchange.getIn();
        Source source = null;
        try {
            Item item = in.getBody(Item.class);
            dynamicQueryContext.setContextItem(item);
        } catch (NoTypeConversionAvailableException e) {
            try {
                source = in.getBody(Source.class);
            } catch (NoTypeConversionAvailableException e2) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""No body available on exchange so using an empty document: "" + exchange);
                }
                source = converter.toSource(converter.createDocument());
            }
            DocumentInfo doc = getStaticQueryContext().buildDocument(source);
            dynamicQueryContext.setContextItem(doc);
        }
        configureQuery(dynamicQueryContext, exchange);
        return dynamicQueryContext;
    }
    /**
     * Configures the dynamic context with exchange specific parameters
     */
    protected void configureQuery(DynamicQueryContext dynamicQueryContext, Exchange exchange)
        throws Exception {
        addParameters(dynamicQueryContext, exchange.getProperties());
        addParameters(dynamicQueryContext, exchange.getIn().getHeaders());
        addParameters(dynamicQueryContext, getParameters());
        dynamicQueryContext.setParameter(""exchange"", exchange);
        Message out = exchange.getOut(false);
        if (out != null && exchange.getPattern().isOutCapable()) {
            dynamicQueryContext.setParameter(""out"", out);
        }
    }
    protected void addParameters(DynamicQueryContext dynamicQueryContext, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            dynamicQueryContext.setParameter(entry.getKey(), entry.getValue());
        }
    }
    protected boolean matches(Exchange exchange, List results) {
        return ObjectHelper.matches(results);
    }
    /**
     * Initializes this builder - <b>Must be invoked before evaluation</b>.
     */
    protected synchronized void initialize(Exchange exchange) throws XPathException, IOException {
        // must use synchronized for concurrency issues and only let it initialize once
        if (!initialized.get()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Initializing XQueryBuilder "" + this);
            }
            configuration = new Configuration();
            configuration.setHostLanguage(Configuration.XQUERY);
            staticQueryContext = new StaticQueryContext(getConfiguration());
            Set<Map.Entry<String, String>> entries = namespacePrefixes.entrySet();
            for (Map.Entry<String, String> entry : entries) {
                String prefix = entry.getKey();
                String uri = entry.getValue();
                staticQueryContext.declareNamespace(prefix, uri);
                staticQueryContext.setInheritNamespaces(true);
            }
            expression = createQueryExpression(staticQueryContext);
            initialized.set(true);
        }
        // let the configuration be accessible on the exchange as its shared for this evaulation
        // and can be needed for 3rd part type converters or in some other situations
        exchange.setProperty(""CamelSaxonConfiguration"", configuration);
    }
}
"
org.apache.camel.spring.CamelProxyFactoryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The &lt;proxy&gt; tag element.
 *
 * @version $Revision$
*/ // to fudge the XSD generation
@XmlRootElement(name = ""proxy"")
public class CamelProxyFactoryType extends IdentifiedType {
    @XmlAttribute
    private String serviceUrl;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.language.xpath.XPathLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.xpath;
import javax.xml.namespace.QName;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.spi.Language;
/**
 * XPath language.
 *
 * @version $Revision$
 */
public class XPathLanguage implements Language {
    private QName resultType;
    public Predicate<Exchange> createPredicate(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public Expression<Exchange> createExpression(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public QName getResultType() {
        return resultType;
    }
    public void setResultType(QName resultType) {
        this.resultType = resultType;
    }
    protected void configureBuilder(XPathBuilder builder) {
        if (resultType != null) {
            builder.setResultQName(resultType);
        }
    }
}
"
org.apache.camel.component.jdbc.JdbcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.util.Map;
import javax.sql.DataSource;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcComponent extends DefaultComponent<DefaultExchange> {
    private DataSource ds;
    public JdbcComponent() {
    }
    public JdbcComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        DataSource dataSource;
        if (ds != null) {
            // use data source set by setter
            dataSource = ds;
        } else {
            // lookup in registry instead
            dataSource = getCamelContext().getRegistry().lookup(remaining, DataSource.class);
            if (dataSource == null) {
                throw new IllegalArgumentException(""DataSource "" + remaining + "" not found in registry"");
            }
        }
        JdbcEndpoint jdbc = new JdbcEndpoint(uri, this, dataSource);
        setProperties(jdbc, parameters);
        return jdbc;
    }
    public void setDataSource(DataSource dataSource) {
        this.ds = dataSource;
    }
}
"
org.apache.camel.component.cxf.converter.CxfConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.converter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPMessage;
import org.apache.camel.Converter;
import org.apache.camel.Endpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.message.MessageContentsList;
/**
 * The <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * for CXF related types' converting .
 *
 * @version $Revision$
 */
@Converter
public final class CxfConverter {
    private static final Log LOG = LogFactory.getLog(CxfConverter.class);
    private CxfConverter() {
        // Helper class
    }
    @Converter
    public static Object[] toArray(final MessageContentsList list) throws Exception {
        if (list == null) {
            throw new IllegalArgumentException(""The MessageChannel is null"");
        }
        return list.toArray();
    }
    @Converter
    public static MessageContentsList toMessageContentsList(final Object[] array) {
        if (array != null) {
            return new MessageContentsList(array);
        } else {
            return new MessageContentsList();
        }
    }
    @Converter
    public static String soapMessageToString(final SOAPMessage soapMessage) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            soapMessage.writeTo(baos);
        } catch (Exception e) {
            LOG.error(""Get the exception when converting the SOAPMessage into String, the exception is "" + e);
        }
        return baos.toString();
    }
}
"
org.apache.camel.Produce,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a field or property as being a producer to an {@link org.apache.camel.Endpoint} either via its
 * <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> or via the name of the endpoint reference
 * which is then resolved in a registry such as the Spring Application Context.
 *
 * Methods invoked on the producer object are then converted to a message {@link org.apache.camel.Exchange} via the
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 * mechanism.
 *
 * @see InOnly
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface Produce {
    String uri() default """";
    String ref() default """";
}"
org.apache.camel.language.ognl.RootObject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
/**
 * @version $Revision$
 */
public class RootObject {
    private final Exchange exchange;
    public RootObject(Exchange exchange) {
        this.exchange = exchange;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public CamelContext getContext() {
        return exchange.getContext();
    }
    public Throwable getException() {
        return exchange.getException();
    }
    public String getExchangeId() {
        return exchange.getExchangeId();
    }
    public Message getFault() {
        return exchange.getFault();
    }
    public Message getRequest() {
        return exchange.getIn();
    }
    /**
     * @deprecated doesnt work in OGNL use request instead
     */
    public Message getIn() {
        return exchange.getIn();
    }
    /**
     * @deprecated doesnt work in OGNL use response instead
     */
    public Message getOut() {
        return exchange.getOut();
    }
    public Message getResponse() {
        return exchange.getOut();
    }
    public Map<String, Object> getProperties() {
        return exchange.getProperties();
    }
    public Object getProperty(String name) {
        return exchange.getProperty(name);
    }
    public <T> T getProperty(String name, Class<T> type) {
        return exchange.getProperty(name, type);
    }
}
"
org.apache.camel.component.quartz.QuartzComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.CronTrigger;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.Trigger;
import org.quartz.impl.StdSchedulerFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/quartz.html"">Quartz Component</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzComponent extends DefaultComponent<QuartzExchange> {
    private static final transient Log LOG = LogFactory.getLog(QuartzComponent.class);
    private SchedulerFactory factory;
    private Scheduler scheduler;
    private Map<Trigger, JobDetail> triggers;
    public QuartzComponent() {
    }
    public QuartzComponent(final CamelContext context) {
        super(context);
    }
    @Override
    protected QuartzEndpoint createEndpoint(final String uri, final String remaining, final Map parameters) throws Exception {
        QuartzEndpoint answer = new QuartzEndpoint(uri, this, getScheduler());
        // lets split the remaining into a group/name
        URI u = new URI(uri);
        String name;
        String group = ""Camel"";
        String path = u.getPath();
        CronTrigger cronTrigger = null;
        if (path != null && path.length() > 1) {
            if (path.startsWith(""/"")) {
                path = path.substring(1);
            }
            int idx = path.indexOf('/');
            if (idx > 0) {
                cronTrigger = new CronTrigger();
                name = path.substring(0, idx);
                String cronExpression = path.substring(idx + 1);
                // lets allow / instead of spaces and allow $ instead of ?
                cronExpression = cronExpression.replace('/', ' ');
                cronExpression = cronExpression.replace('$', '?');
                LOG.debug(""Creating cron trigger: "" + cronExpression);
                cronTrigger.setCronExpression(cronExpression);
                answer.setTrigger(cronTrigger);
            } else {
                name = path;
            }
            group = u.getHost();
        } else {
            name = u.getHost();
        }
        /*
         * String[] names = ObjectHelper.splitOnCharacter(remaining, ""/"", 2); if
         * (names[1] != null) { group = names[0]; name = names[1]; } else { name =
         * names[0]; }
         */
        Trigger trigger = cronTrigger;
        if (trigger == null) {
            trigger = answer.getTrigger();
        }
        trigger.setName(name);
        trigger.setGroup(group);
        Map triggerParameters = IntrospectionSupport.extractProperties(parameters, ""trigger."");
        Map jobParameters = IntrospectionSupport.extractProperties(parameters, ""job."");
        setProperties(trigger, triggerParameters);
        setProperties(answer.getJobDetail(), jobParameters);
        return answer;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getScheduler().start();
    }
    @Override
    protected void doStop() throws Exception {
        if (scheduler != null) {
            scheduler.shutdown();
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public SchedulerFactory getFactory() {
        if (factory == null) {
            factory = createSchedulerFactory();
        }
        return factory;
    }
    public void setFactory(final SchedulerFactory factory) {
        this.factory = factory;
    }
    public Scheduler getScheduler() throws SchedulerException {
        if (scheduler == null) {
            scheduler = createScheduler();
        }
        return scheduler;
    }
    public void setScheduler(final Scheduler scheduler) {
        this.scheduler = scheduler;
    }
    public Map getTriggers() {
        return triggers;
    }
    public void setTriggers(final Map triggers) {
        this.triggers = triggers;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected SchedulerFactory createSchedulerFactory() {
        return new StdSchedulerFactory();
    }
    protected Scheduler createScheduler() throws SchedulerException {
        Scheduler scheduler = getFactory().getScheduler();
        scheduler.getContext().put(QuartzEndpoint.CONTEXT_KEY, getCamelContext());
        return scheduler;
    }
}
"
org.apache.camel.NoSuchBeanException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.spi.Registry;
/**
 * A runtime exception if a given bean could not be found in the {@link Registry}
 *
 * @version $Revision$
 */
public class NoSuchBeanException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String name;
    public NoSuchBeanException(String name) {
        super(""No bean could be found in the registry for: "" + name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
}"
org.apache.camel.component.jms.JmsTemporaryTopicEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryTopic;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 * for working with a {@link TemporaryTopic}
 *
 * @version $Revision$
 */
// TODO need to be really careful to always use the same Connection otherwise the destination goes stale
public class JmsTemporaryTopicEndpoint extends JmsEndpoint implements DestinationEndpoint {
    private Destination jmsDestination;
    public JmsTemporaryTopicEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration) {
        super(uri, component, destination, true, configuration);
    }
    public JmsTemporaryTopicEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination);
    }
    /**
     * This endpoint is a singleton so that the temporary destination instances are shared across all
     * producers and consumers of the same endpoint URI
     *
     * @return true
     */
    public boolean isSingleton() {
        return true;
    }
    public synchronized Destination getJmsDestination(Session session) throws JMSException {
        if (jmsDestination == null) {
            jmsDestination = createJmsDestination(session);
        }
        return jmsDestination;
    }
    protected Destination createJmsDestination(Session session) throws JMSException {
        return session.createTemporaryTopic();
    }
}"
org.apache.camel.impl.DefaultScheduledPollConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
/**
 * A default implementation of an event driven {@link Consumer} which uses the {@link PollingConsumer}
 *
 * @version $Revision$
 */
public class DefaultScheduledPollConsumer<E extends Exchange> extends ScheduledPollConsumer<E> {
    private PollingConsumer<E> pollingConsumer;
    public DefaultScheduledPollConsumer(DefaultEndpoint<E> defaultEndpoint, Processor processor) {
        super(defaultEndpoint, processor);
    }
    public DefaultScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
    protected void poll() throws Exception {
        while (true) {
            E exchange = pollingConsumer.receiveNoWait();
            if (exchange == null) {
                break;
            }
            // if the result of the polled exchange has output we should create a new exchange and
            // use the output as input to the next processor
            Message out = exchange.getOut(false);
            if (out != null) {
                // lets create a new exchange
                E newExchange = getEndpoint().createExchange();
                newExchange.getIn().copyFrom(out);
                exchange = newExchange;
            }
            getProcessor().process(exchange);
        }
    }
    @Override
    protected void doStart() throws Exception {
        pollingConsumer = getEndpoint().createPollingConsumer();
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (pollingConsumer != null) {
            pollingConsumer.stop();
        }
    }
}
"
org.apache.camel.language.groovy.GroovyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import java.util.AbstractMap;
import java.util.Collections;
import java.util.Set;
import groovy.lang.Binding;
import groovy.lang.Script;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision$
 */
public class GroovyExpression extends ExpressionSupport<Exchange> {
    private Class<Script> scriptType;
    private String text;
    public GroovyExpression(Class<Script> scriptType, String text) {
        this.scriptType = scriptType;
        this.text = text;
    }
    @Override
    public String toString() {
        return ""groovy: "" + text;
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return ""groovy: "" + text;
    }
    public Object evaluate(Exchange exchange) {
        Script script = ExchangeHelper.newInstance(exchange, scriptType);
        // lets configure the script
        configure(exchange, script);
        return script.run();
    }
    private void configure(Exchange exchange, Script script) {
        final Binding binding = script.getBinding();
        ExchangeHelper.populateVariableMap(exchange, new AbstractMap<String, Object>() {
            @Override
            public Object put(String key, Object value) {
                binding.setProperty(key, value);
                return null;
            }
            public Set entrySet() {
                return Collections.EMPTY_SET;
            }
        });
    }
}
"
org.apache.camel.impl.JndiRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Registry;
/**
 * A {@link Registry} implementation which looks up the objects in JNDI
 * 
 * @version $Revision$
 */
public class JndiRegistry implements Registry {
    private Context context;
    public JndiRegistry() {
    }
    public JndiRegistry(Context context) {
        this.context = context;
    }
    public <T> T lookup(String name, Class<T> type) {
        Object value = lookup(name);
        return type.cast(value);
    }
    public Object lookup(String name) {
        try {
            return getContext().lookup(name);
        } catch (NameNotFoundException e) {
            return null;
        } catch (NamingException e) {
            return null;
        }
    }
    public void bind(String s, Object o) {
        try {
            getContext().bind(s, o);
        } catch (NamingException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void close() throws NamingException {
        getContext().close();
    }
    public Context getContext() throws NamingException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(Context context) {
        this.context = context;
    }
    protected Context createContext() throws NamingException {
        Hashtable properties = new Hashtable(System.getProperties());
        return new InitialContext(properties);
    }
}
"
org.apache.camel.component.bean.BeanEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Component;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.impl.ProcessorEndpoint;
/**
 * Endpoint for the bean component.
 *
 * @version $Revision$
 */
public class BeanEndpoint extends ProcessorEndpoint {
    private boolean cache;
    private boolean multiParameterArray;
    private String beanName;
    private String method;
    private BeanHolder beanHolder;
    public BeanEndpoint() {
        init();
    }
    public BeanEndpoint(String endpointUri) {
        super(endpointUri);
        init();
    }
    public BeanEndpoint(String endpointUri, BeanProcessor processor) {
        super(endpointUri, processor);
        init();
    }
    public BeanEndpoint(String endpointUri, Component component, BeanProcessor processor) {
        super(endpointUri, component, processor);
        init();
    }
    public BeanEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
        init();
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getBeanName() {
        return beanName;
    }
    public void setBeanName(String beanName) {
        this.beanName = beanName;
    }
    public boolean isMultiParameterArray() {
        return multiParameterArray;
    }
    public void setMultiParameterArray(boolean mpArray) {
        multiParameterArray = mpArray;
    }
    public boolean isCache() {
        return cache;
    }
    public void setCache(boolean cache) {
        this.cache = cache;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    public BeanHolder getBeanHolder() {
        return beanHolder;
    }
    public void setBeanHolder(BeanHolder beanHolder) {
        this.beanHolder = beanHolder;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected String createEndpointUri() {
        return ""bean:"" + getBeanName() + (method != null ? ""?method="" + method : """");
    }
    private void init() {
        setExchangePattern(ExchangePattern.InOut);
    }
    @Override
    protected Processor createProcessor() throws Exception {
        BeanHolder holder = getBeanHolder();
        if (holder == null) {
            RegistryBean registryBean = new RegistryBean(getCamelContext(), beanName);
            if (cache) {
                holder = registryBean.createCacheHolder();
            } else {
                holder = registryBean;
            }
        }
        BeanProcessor processor = new BeanProcessor(holder);
        if (method != null) {
            processor.setMethod(method);
        }
        processor.setMultiParameterArray(isMultiParameterArray());
        return processor;
    }
}
"
org.apache.camel.spring.remoting.CamelServiceExporter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.remoting.support.RemoteExporter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A {@link FactoryBean} to create a proxy to a service exposing a given {@link #getServiceInterface()}
 *
 * @author chirino
 */
public class CamelServiceExporter extends RemoteExporter implements InitializingBean, DisposableBean, ApplicationContextAware, CamelContextAware {
    private String uri;
    private CamelContext camelContext;
    private Consumer consumer;
    private String serviceRef;
    private ApplicationContext applicationContext;
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getServiceRef() {
        return serviceRef;
    }
    public void setServiceRef(String serviceRef) {
        this.serviceRef = serviceRef;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void afterPropertiesSet() throws Exception {
        // lets bind the URI to a pojo
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        if (serviceRef != null && getService() == null && applicationContext != null) {
            setService(applicationContext.getBean(serviceRef));
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        notNull(camelContext, ""service"");
        Object proxy = getProxyForService();
        consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));
        consumer.start();
    }
    public void destroy() throws Exception {
        if (consumer != null) {
            consumer.stop();
        }
    }
}
"
org.apache.camel.builder.xml.Namespaces,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.apache.camel.model.language.XPathExpression;
import org.apache.camel.model.language.XQueryExpression;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class for working with namespaces or creating namespace based expressions
 *
 * @version $Revision$
 */
public class Namespaces {
    public static final String DEFAULT_NAMESPACE = ""http://activemq.apache.org/camel/schema/spring"";
    public static final String IN_NAMESPACE = ""http://camel.apache.org/xml/in/"";
    public static final String OUT_NAMESPACE = ""http://camel.apache.org/xml/out/"";
    public static final String SYSTEM_PROPERTIES_NAMESPACE = ""http://camel.apache.org/xml/variables/system-properties"";
    public static final String ENVIRONMENT_VARIABLES = ""http://camel.apache.org/xml/variables/environment-variables"";
    public static final String EXCHANGE_PROPERTY = ""http://camel.apache.org/xml/variables/exchange-property"";
    private Map<String, String> namespaces = new HashMap<String, String>();
    /**
     * Creates a namespaces object from the given XML element
     *
     * @param element the XML element representing the XPath namespace context
     */
    public Namespaces(Element element) {
        add(element);
    }
    /**
     * Creates a namespace context with a single prefix and URI
     */
    public Namespaces(String prefix, String uri) {
        add(prefix, uri);
    }
    /**
     * Returns true if the given namespaceURI is empty or if it matches the
     * given expected namespace
     */
    public static boolean isMatchingNamespaceOrEmptyNamespace(String namespaceURI, String expectedNamespace) {
        return ObjectHelper.isNullOrBlank(namespaceURI) || namespaceURI.equals(expectedNamespace);
    }
    public Namespaces add(String prefix, String uri) {
        namespaces.put(prefix, uri);
        return this;
    }
    public Namespaces add(Element element) {
        // lets set the parent first in case we overload a prefix here
        Node parentNode = element.getParentNode();
        if (parentNode instanceof org.w3c.dom.Element) {
            add((Element) parentNode);
        }
        NamedNodeMap attributes = element.getAttributes();
        int size = attributes.getLength();
        for (int i = 0; i < size; i++) {
            Attr node = (Attr) attributes.item(i);
            String name = node.getName();
            if (name.startsWith(""xmlns:"")) {
                String prefix = name.substring(""xmlns:"".length());
                String uri = node.getValue();
                add(prefix, uri);
            }
        }
        return this;
    }
    /**
     * Creates the XPath expression using the current namespace context
     */
    public XPathExpression xpath(String expression) {
        XPathExpression answer = new XPathExpression(expression);
        configure(answer);
        return answer;
    }
    /**
     * Creates the XPath expression using the current namespace context
     */
    public XPathExpression xpath(String expression, Class<?> resultType) {
        XPathExpression answer = xpath(expression);
        answer.setResultType(resultType);
        return answer;
    }
    /**
     * Creates the XQuery expression using the current namespace context
     */
    public XQueryExpression xquery(String expression) {
        XQueryExpression answer = new XQueryExpression(expression);
        configure(answer);
        return answer;
    }
    /**
     * Creates the XQuery expression using the current namespace context
     * and the given expected return type
     */
    public XQueryExpression xquery(String expression, Class<?> resultType) {
        XQueryExpression answer = new XQueryExpression(expression);
        answer.setResultType(resultType);
        configure(answer);
        return answer;
    }
    public Map<String, String> getNamespaces() {
        return namespaces;
    }
    /**
     * Configures the namespace aware object
     */
    public void configure(NamespaceAware namespaceAware) {
        namespaceAware.setNamespaces(getNamespaces());
    }
}
"
org.apache.camel.component.jms.JmsIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.util.Enumeration;
import javax.jms.BytesMessage;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageEOFException;
import javax.jms.ObjectMessage;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.NIOConverter;
/**
 * Some simple payload conversions to I/O <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class JmsIOConverter {
    private JmsIOConverter() {
    }
    @Converter
    public static ByteBuffer toByteBuffer(final Message message, Exchange exchange) throws Exception {
        if (message instanceof TextMessage) {
            final String text = ((TextMessage)message).getText();
            return NIOConverter.toByteBuffer(text, exchange);
        }
        if (message instanceof BytesMessage) {
            final BytesMessage bmsg = (BytesMessage)message;
            final int len = (int)bmsg.getBodyLength();
            final byte[] data = new byte[len];
            bmsg.readBytes(data, len);
            return NIOConverter.toByteBuffer(data);
        }
        if (message instanceof StreamMessage) {
            final StreamMessage msg = (StreamMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            try {
                while (true) {
                    final Object obj = msg.readObject();
                    writeData(dataOut, obj);
                }
            } catch (MessageEOFException e) {
                // we have no other way of knowing the end of the message
            } finally {
                dataOut.close();
            }
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof MapMessage) {
            final MapMessage msg = (MapMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            for (final Enumeration en = msg.getMapNames(); en.hasMoreElements();) {
                final Object obj = msg.getObject(en.nextElement().toString());
                writeData(dataOut, obj);
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof ObjectMessage) {
            ObjectMessage objMessage = (ObjectMessage)message;
            Object object = objMessage.getObject();
            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            ObjectOutputStream objectOut = new ObjectOutputStream(bytesOut);
            objectOut.writeObject(object);
            objectOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        return null;
    }
    private static void writeData(DataOutputStream dataOut, Object data) throws Exception {
        if (data instanceof byte[]) {
            dataOut.write((byte[])data);
        } else if (data instanceof String) {
            dataOut.writeUTF(data.toString());
        } else if (data instanceof Double) {
            dataOut.writeDouble(((Double)data).doubleValue());
        } else if (data instanceof Float) {
            dataOut.writeFloat(((Float)data).floatValue());
        } else if (data instanceof Long) {
            dataOut.writeLong(((Long)data).longValue());
        } else if (data instanceof Integer) {
            dataOut.writeInt(((Integer)data).intValue());
        } else if (data instanceof Short) {
            dataOut.writeShort(((Short)data).shortValue());
        } else if (data instanceof Character) {
            dataOut.writeChar(((Character)data).charValue());
        } else if (data instanceof Byte) {
            dataOut.writeByte(((Byte)data).byteValue());
        } else if (data instanceof Boolean) {
            dataOut.writeBoolean(((Boolean)data).booleanValue());
        }
    }
}
"
org.apache.camel.component.file.strategy.DefaultFileRenamer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileExchange;
/**
 * Camel default file renamer.
 *
 * @version $Revision$
 */
public class DefaultFileRenamer implements FileRenamer {
    private static final boolean ON_WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
    private String namePrefix;
    private String namePostfix;
    public DefaultFileRenamer() {
    }
    public DefaultFileRenamer(String namePrefix, String namePostfix) {
        this.namePrefix = namePrefix;
        this.namePostfix = namePostfix;
    }
    public File renameFile(FileExchange exchange, File file) {
        File parent = file.getParentFile();
        String name = renameFileName(file);
        if (ON_WINDOWS && (name.indexOf("":"") >= 0 || name.startsWith(""//""))) {
            return new File(name);
        }
        return new File(parent, name);
    }
    public String getNamePostfix() {
        return namePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example
     * to rename all the files from * to *.done set this value to "".done""
     */
    public void setNamePostfix(String namePostfix) {
        this.namePostfix = namePostfix;
    }
    public String getNamePrefix() {
        return namePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example
     * to move processed files into a hidden directory called "".camel""
     * set this value to "".camel/""
     */
    public void setNamePrefix(String namePrefix) {
        this.namePrefix = namePrefix;
    }
    protected String renameFileName(File file) {
        StringBuffer buffer = new StringBuffer();
        if (namePrefix != null) {
            buffer.append(namePrefix);
        }
        buffer.append(file.getName());
        if (namePostfix != null) {
            buffer.append(namePostfix);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.language.bean.BeanLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/bean-language.html"">bean language</a>
 * which uses a simple text notation to invoke methods on beans to evaluate predicates or expressions
 * <p/>
 * The notation is essentially <code>beanName.methodName</code> which is then invoked using the
 * beanName to lookup in the <a href=""http://activemq.apache.org/camel/registry.html>registry</a>
 * then the method is invoked to evaluate the expression using the
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">bean integration</a> to bind the
 * {@link Exchange} to the method arguments.
 * <p/>
 * As of Camel 1.5 the bean language also supports invoking a provided bean by
 * its classname or the bean itself.
 *
 * @version $Revision$
 */
public class BeanLanguage implements Language {
    /**
     * Creates the expression based on the string syntax.
     *
     * @param expression the string syntax
     * @return the expression
     */
    public static Expression bean(String expression) {
        BeanLanguage language = new BeanLanguage();
        return language.createExpression(expression);
    }
    /**
     * Creates the expression for invoking the bean type.
     *
     * @param beanType  the bean type to invoke
     * @param method optional name of method to invoke for instance to avoid ambiguity
     * @return the expression
     */
    public static Expression bean(Class beanType, String method) {
        Object bean = ObjectHelper.newInstance(beanType);
        return bean(bean, method);
    }
    /**
     * Creates the expression for invoking the bean type.
     *
     * @param bean  the bean to invoke
     * @param method optional name of method to invoke for instance to avoid ambiguity
     * @return the expression
     */
    public static Expression bean(Object bean, String method) {
        BeanLanguage language = new BeanLanguage();
        return language.createExpression(bean, method);
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        ObjectHelper.notNull(expression, ""expression"");
        int idx = expression.lastIndexOf('.');
        String beanName = expression;
        String method = null;
        if (idx > 0) {
            beanName = expression.substring(0, idx);
            method = expression.substring(idx + 1);
        }
        return new BeanExpression(beanName, method);
    }
    public Expression<Exchange> createExpression(Object bean, String method) {
        ObjectHelper.notNull(bean, ""bean"");
        return new BeanExpression(bean, method);
    }
}"
org.apache.camel.converter.HasAnnotation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate that the actual type of a parameter on a converter method must have the given annotation class
 * to be applicable. e.g. this annotation could be used on a JAXB converter which only applies to objects with a
 * JAXB annotation on them
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface HasAnnotation {
    Class value();
}
"
org.apache.camel.component.file.remote.FtpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.commons.net.ftp.FTPClient;
public class FtpProducer extends RemoteFileProducer<RemoteFileExchange> {
    private FtpEndpoint endpoint;
    private FTPClient client;
    private boolean loggedIn;
    public FtpProducer(FtpEndpoint endpoint, FTPClient client) {
        super(endpoint);
        this.endpoint = endpoint;
        this.client = client;
    }
    public void process(Exchange exchange) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Processing "" + endpoint.getConfiguration());
        }
        try {
            connectIfNecessary();
            if (!loggedIn) {
                String message = ""Could not connect/login to "" + endpoint.getConfiguration();
                log.warn(message);
                throw new FtpOperationFailedException(client.getReplyCode(), client.getReplyString(), message);
            }
            process(endpoint.createExchange(exchange));
        } catch (Exception e) {
            loggedIn = false;
            if (isStopping() || isStopped()) {
                // if we are stopping then ignore any exception during a poll
                log.warn(""Producer is stopping. Ignoring caught exception: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
            } else {
                log.warn(""Exception occured during processing: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
                disconnect();
                // Rethrow to signify that we didn't poll
                throw e;
            }
        }
    }
    protected void connectIfNecessary() throws IOException {
        if (!client.isConnected() || !loggedIn) {
            if (log.isDebugEnabled()) {
                log.debug(""Not connected/logged in, connecting to "" + remoteServer());
            }
            loggedIn = FtpUtils.connect(client, endpoint.getConfiguration());
            if (!loggedIn) {
                return;
            }
        }
        log.info(""Connected and logged in to "" + remoteServer());
    }
    public void disconnect() throws IOException {
        loggedIn = false;
        if (log.isDebugEnabled()) {
            log.debug(""Disconnecting from "" + remoteServer());
        }
        FtpUtils.disconnect(client);
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        try {
            String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
            int lastPathIndex = fileName.lastIndexOf('/');
            if (lastPathIndex != -1) {
                String directory = fileName.substring(0, lastPathIndex);
                if (!FtpUtils.buildDirectory(client, directory)) {
                    log.warn(""Couldn't build directory: "" + directory + "" (could be because of denied permissions)"");
                }
            }
            boolean success = client.storeFile(fileName, payload);
            if (!success) {
                String message = ""Error sending file: "" + fileName + "" to: "" + remoteServer();
                throw new FtpOperationFailedException(client.getReplyCode(), client.getReplyString(), message);
            }
            log.info(""Sent: "" + fileName + "" to: "" + remoteServer());
        } finally {
            if (payload != null) {
                payload.close();
            }
        }
    }
}
"
org.apache.camel.impl.ScheduledPollEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.util.IntrospectionSupport;
/**
 * A base class for {@link Endpoint} which creates a {@link ScheduledPollConsumer}
 *
 * @version $Revision$
 */
public abstract class ScheduledPollEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private Map consumerProperties;
    protected ScheduledPollEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected ScheduledPollEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    protected ScheduledPollEndpoint(String endpointUri) {
        super(endpointUri);
    }
    protected ScheduledPollEndpoint() {
    }
    public Map getConsumerProperties() {
        return consumerProperties;
    }
    public void setConsumerProperties(Map consumerProperties) {
        this.consumerProperties = consumerProperties;
    }
    protected void configureConsumer(Consumer<E> consumer) throws Exception {
        if (consumerProperties != null) {
            // TODO pass in type converter
            IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), consumer, consumerProperties);
            if (!this.isLenientProperties() && consumerProperties.size() > 0) {
                throw new ResolveEndpointFailedException(this.getEndpointUri(), ""There are "" + consumerProperties.size()
                    + "" parameters that couldn't be set on the endpoint consumer.""
                    + "" Check the uri if the parameters are spelt correctly and that they are properties of the endpoint.""
                    + "" Unknown consumer parameters=["" + consumerProperties + ""]"");
            }
        }
    }
    public void configureProperties(Map options) {
        Map consumerProperties = IntrospectionSupport.extractProperties(options, ""consumer."");
        if (consumerProperties != null) {
            setConsumerProperties(consumerProperties);
        }
    }
}
"
org.apache.camel.component.cxf.MessageInvoker,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.cxf.message.Exchange;
/**
 * The interface to provide a CXF message invoke method
 */
public interface MessageInvoker {
    /**
     * This method is called when the incoming message is to be passed into the
     * camel processor. The return value is the response from the processor
     *
     * @param exchange the CXF exchange which holds the in and out message
     */
    void invoke(Exchange exchange);
}
"
org.apache.camel.management.InstrumentationLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.management.JMException;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMX agent that registeres Camel lifecycle events in JMX.
 *
 * @version $Revision$
 */
public class InstrumentationLifecycleStrategy implements LifecycleStrategy {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationProcessor.class);
    private InstrumentationAgent agent;
    private CamelNamingStrategy namingStrategy;
    private boolean initialized;
    // A map (Endpoint -> InstrumentationProcessor) to facilitate
    // adding per-route interceptor and registering ManagedRoute MBean
    private Map<Endpoint, InstrumentationProcessor> interceptorMap =
        new HashMap<Endpoint, InstrumentationProcessor>();
    public InstrumentationLifecycleStrategy() {
        this(new DefaultInstrumentationAgent());
    }
    public InstrumentationLifecycleStrategy(InstrumentationAgent agent) {
        this.agent = agent;
    }
    /**
     * Constructor for camel context that has been started.
     *
     * @param agent    the agent
     * @param context  the camel context
     */
    public InstrumentationLifecycleStrategy(InstrumentationAgent agent, CamelContext context) {
        this.agent = agent;
        onContextStart(context);
    }
    public void onContextStart(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            try {
                initialized = true;
                DefaultCamelContext dc = (DefaultCamelContext)context;
                // call addService so that context will start and stop the agent
                dc.addService(agent);
                namingStrategy = new CamelNamingStrategy(agent.getMBeanObjectDomainName());
                ManagedService ms = new ManagedService(dc);
                agent.register(ms, getNamingStrategy().getObjectName(dc));
            } catch (Exception e) {
                LOG.warn(""Could not register CamelContext MBean"", e);
            }
        }
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        try {
            ManagedEndpoint me = new ManagedEndpoint(endpoint);
            agent.register(me, getNamingStrategy().getObjectName(me));
        } catch (JMException e) {
            LOG.warn(""Could not register Endpoint MBean"", e);
        }
    }
    public void onRoutesAdd(Collection<Route> routes) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        for (Route route : routes) {
            try {
                ManagedRoute mr = new ManagedRoute(route);
                // retrieve the per-route intercept for this route
                InstrumentationProcessor interceptor = interceptorMap.get(route.getEndpoint());
                if (interceptor == null) {
                    LOG.warn(""Instrumentation processor not found for route endpoint ""
                             + route.getEndpoint());
                } else {
                    interceptor.setCounter(mr);
                }
                agent.register(mr, getNamingStrategy().getObjectName(mr));
            } catch (JMException e) {
                LOG.warn(""Could not register Route MBean"", e);
            }
        }
    }
    public void onServiceAdd(CamelContext context, Service service) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        if (service instanceof ServiceSupport && service instanceof Consumer) {
            // TODO: add support for non-consumer services?
            try {
                ManagedService ms = new ManagedService((ServiceSupport)service);
                agent.register(ms, getNamingStrategy().getObjectName(context, ms));
            } catch (JMException e) {
                LOG.warn(""Could not register Service MBean"", e);
            }
        }
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        // Create a map (ProcessorType -> PerformanceCounter)
        // to be passed to InstrumentationInterceptStrategy.
        Map<ProcessorType, PerformanceCounter> counterMap =
            new HashMap<ProcessorType, PerformanceCounter>();
        // Each processor in a route will have its own performance counter
        // The performance counter are MBeans that we register with MBeanServer.
        // These performance counter will be embedded
        // to InstrumentationProcessor and wrap the appropriate processor
        // by InstrumentationInterceptStrategy.
        RouteType route = routeContext.getRoute();
        for (ProcessorType processor : route.getOutputs()) {
            ObjectName name = null;
            try {
                // get the mbean name
                name = getNamingStrategy().getObjectName(routeContext, processor);
                // register mbean wrapped in the performance counter mbean
                PerformanceCounter pc = new PerformanceCounter();
                agent.register(pc, name);
                // add to map now that it has been registered
                counterMap.put(processor, pc);
            } catch (MalformedObjectNameException e) {
                LOG.warn(""Could not create MBean name: "" + name, e);
            } catch (JMException e) {
                LOG.warn(""Could not register PerformanceCounter MBean: "" + name, e);
            }
        }
        routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(counterMap));
        routeContext.setErrorHandlerWrappingStrategy(
                new InstrumentationErrorHandlerWrappingStrategy(counterMap));
        // Add an InstrumentationProcessor at the beginning of each route and
        // set up the interceptorMap for onRoutesAdd() method to register the
        // ManagedRoute MBeans.
        RouteType routeType = routeContext.getRoute();
        if (routeType.getInputs() != null && !routeType.getInputs().isEmpty()) {
            if (routeType.getInputs().size() > 1) {
                LOG.warn(""Add InstrumentationProcessor to first input only."");
            }
            Endpoint endpoint  = routeType.getInputs().get(0).getEndpoint();
            List<ProcessorType<?>> exceptionHandlers = new ArrayList<ProcessorType<?>>();
            List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
            // separate out the exception handers in the outputs
            for (ProcessorType output : routeType.getOutputs()) {
                if (output instanceof ExceptionType) {
                    exceptionHandlers.add(output);
                } else {
                    outputs.add(output);
                }
            }
            // clearing the outputs
            routeType.clearOutput();
            // add exception handlers as top children
            routeType.getOutputs().addAll(exceptionHandlers);
            // add an interceptor
            InstrumentationProcessor processor = new InstrumentationProcessor();
            routeType.intercept(processor);
            // add the output
            for (ProcessorType<?> processorType : outputs) {
                routeType.addOutput(processorType);
            }
            interceptorMap.put(endpoint, processor);
        }
    }
    public CamelNamingStrategy getNamingStrategy() {
        return namingStrategy;
    }
    public void setNamingStrategy(CamelNamingStrategy strategy) {
        this.namingStrategy = strategy;
    }
    public void setAgent(InstrumentationAgent agent) {
        this.agent = agent;
    }
}
"
org.apache.camel.language.NamespacePrefix,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Creates a namespace prefix for an XPath
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface NamespacePrefix {
    String prefix();
    String uri();
}"
org.apache.camel.management.DefaultInstrumentationAgent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.modelmbean.InvalidTargetObjectTypeException;
import javax.management.modelmbean.ModelMBeanInfo;
import javax.management.modelmbean.RequiredModelMBean;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource;
import org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler;
/**
 * Default implementation of the Camel JMX service agent
 */
public class DefaultInstrumentationAgent extends ServiceSupport implements InstrumentationAgent {
    public static final String DEFAULT_DOMAIN = ""org.apache.camel"";
    public static final String DEFAULT_HOST = ""localhost"";
    public static final int DEFAULT_REGISTRY_PORT = 1099;
    public static final int DEFAULT_CONNECTION_PORT = -1;
    public static final String DEFAULT_SERVICE_URL_PATH = ""/jmxrmi/camel"";
    private static final transient Log LOG = LogFactory.getLog(DefaultInstrumentationAgent.class);
    private MBeanServer server;
    private Set<ObjectName> mbeans = new HashSet<ObjectName>();
    private MetadataMBeanInfoAssembler assembler;
    private JMXConnectorServer cs;
    private Integer registryPort;
    private Integer connectorPort;
    private String mBeanServerDefaultDomain;
    private String mBeanObjectDomainName;
    private String serviceUrlPath;
    private Boolean usePlatformMBeanServer = true;
    private Boolean createConnector;
    protected void finalizeSettings() {
        if (registryPort == null) {
            registryPort = Integer.getInteger(JmxSystemPropertyKeys.REGISTRY_PORT,
                    DEFAULT_REGISTRY_PORT);
        }
        if (connectorPort == null) {
            connectorPort = Integer.getInteger(JmxSystemPropertyKeys.CONNECTOR_PORT,
                    DEFAULT_CONNECTION_PORT);
        }
        if (mBeanServerDefaultDomain == null) {
            mBeanServerDefaultDomain =
                System.getProperty(JmxSystemPropertyKeys.DOMAIN, DEFAULT_DOMAIN);
        }
        if (mBeanObjectDomainName == null) {
            mBeanObjectDomainName =
                System.getProperty(JmxSystemPropertyKeys.MBEAN_DOMAIN, DEFAULT_DOMAIN);
        }
        if (serviceUrlPath == null) {
            serviceUrlPath =
                System.getProperty(JmxSystemPropertyKeys.SERVICE_URL_PATH,
                        DEFAULT_SERVICE_URL_PATH);
        }
        if (createConnector == null) {
            createConnector = Boolean.getBoolean(JmxSystemPropertyKeys.CREATE_CONNECTOR);
        }
        // ""Use platform mbean server"" is true by default
        if (System.getProperty(JmxSystemPropertyKeys.USE_PLATFORM_MBS) != null) {
            usePlatformMBeanServer = Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS);
        }
    }
    public void setRegistryPort(Integer value) {
        registryPort = value;
    }
    public void setConnectorPort(Integer value) {
        connectorPort = value;
    }
    public void setMBeanServerDefaultDomain(String value) {
        mBeanServerDefaultDomain = value;
    }
    public void setMBeanObjectDomainName(String value) {
        mBeanObjectDomainName = value;
    }
    public void setServiceUrlPath(String value) {
        serviceUrlPath = value;
    }
    public void setCreateConnector(Boolean flag) {
        createConnector = flag;
    }
    public void setUsePlatformMBeanServer(Boolean flag) {
        usePlatformMBeanServer = flag;
    }
    public MBeanServer getMBeanServer() {
        return server;
    }
    public void register(Object obj, ObjectName name) throws JMException {
        register(obj, name, false);
    }
    public void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException {
        try {
            registerMBeanWithServer(obj, name, forceRegistration);
        } catch (NotCompliantMBeanException e) {
            // If this is not a ""normal"" MBean, then try to deploy it using JMX
            // annotations
            ModelMBeanInfo mbi = null;
            mbi = assembler.getMBeanInfo(obj, name.toString());
            RequiredModelMBean mbean = (RequiredModelMBean)server.instantiate(RequiredModelMBean.class
                .getName());
            mbean.setModelMBeanInfo(mbi);
            try {
                mbean.setManagedResource(obj, ""ObjectReference"");
            } catch (InvalidTargetObjectTypeException itotex) {
                throw new JMException(itotex.getMessage());
            }
            registerMBeanWithServer(mbean, name, forceRegistration);
        }
    }
    public void unregister(ObjectName name) throws JMException {
        server.unregisterMBean(name);
    }
    protected void doStart() throws Exception {
        assembler = new MetadataMBeanInfoAssembler();
        assembler.setAttributeSource(new AnnotationJmxAttributeSource());
        // create mbean server if is has not be injected.
        if (server == null) {
            finalizeSettings();
            createMBeanServer();
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Starting JMX agent on server: "" + getMBeanServer());
        }
    }
    protected void doStop() throws Exception {
        // close JMX Connector
        if (cs != null) {
            try {
                cs.stop();
            } catch (IOException e) {
                // ignore
            }
            cs = null;
        }
        // Using the array to hold the busMBeans to avoid the
        // CurrentModificationException
        Object[] mBeans = mbeans.toArray();
        int caught = 0;
        for (Object name : mBeans) {
            mbeans.remove((ObjectName)name);
            try {
                unregister((ObjectName)name);
            } catch (JMException jmex) {
                LOG.info(""Exception unregistering MBean"", jmex);
                caught++;
            }
        }
        if (caught > 0) {
            LOG.warn(""A number of "" + caught
                     + "" exceptions caught while unregistering MBeans during stop operation.""
                     + "" See INFO log for details."");
        }
    }
    private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration)
        throws JMException {
        // have we already registered the bean, there can be shared instances in the camel routes
        boolean exists = server.isRegistered(name);
        if (exists) {
            if (forceRegistration) {
                LOG.info(""ForceRegistration enabled, unregistering existing MBean"");
                server.unregisterMBean(name);
            } else {
                // okay ignore we do not want to force it and it could be a shared instance
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""MBean already registered with objectname: "" + name);
                }
            }
        }
        // register bean if by force or not exsists
        ObjectInstance instance = null;
        if (forceRegistration || !exists) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Registering MBean with objectname: "" + name);
            }
            instance = server.registerMBean(obj, name);
        }
        if (instance != null) {
            ObjectName registeredName = instance.getObjectName();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Registered MBean with objectname: "" + registeredName);
            }
            mbeans.add(registeredName);
        }
    }
    protected void createMBeanServer() {
        String hostName = DEFAULT_HOST;
        boolean canAccessSystemProps = true;
        try {
            // we'll do it this way mostly to determine if we should lookup the
            // hostName
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        } catch (SecurityException se) {
            canAccessSystemProps = false;
        }
        if (canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
            } catch (UnknownHostException uhe) {
                LOG.info(""Cannot determine localhost name. Using default: ""
                         + DEFAULT_REGISTRY_PORT, uhe);
                hostName = DEFAULT_HOST;
            }
        } else {
            hostName = DEFAULT_HOST;
        }
        server = findOrCreateMBeanServer();
        try {
            // Create the connector if we need
            if (createConnector) {
                createJmxConnector(hostName);
            }
        } catch (IOException ioe) {
            LOG.warn(""Could not create and start JMX connector."", ioe);
        }
    }
    @SuppressWarnings(""unchecked"")
    protected MBeanServer findOrCreateMBeanServer() {
        // return platform mbean server if the option is specified.
        if (usePlatformMBeanServer) {
            return ManagementFactory.getPlatformMBeanServer();
        }
        // look for the first mbean server that has match default domain name
        List<MBeanServer> servers =
            (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);
        for (MBeanServer server : servers) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Found MBeanServer with default domain "" + server.getDefaultDomain());
            }
            if (mBeanServerDefaultDomain.equals(server.getDefaultDomain())) {
                return server;
            }
        }
        // create a mbean server with the given default domain name
        return MBeanServerFactory.createMBeanServer(mBeanServerDefaultDomain);
    }
    protected void createJmxConnector(String host) throws IOException {
        try {
            LocateRegistry.createRegistry(registryPort);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Created JMXConnector RMI regisry on port "" + registryPort);
            }
        } catch (RemoteException ex) {
            // The registry may had been created, we could get the registry instead
        }
        // Create an RMI connector and start it
        JMXServiceURL url;
        if (connectorPort > 0) {
            url = new JMXServiceURL(""service:jmx:rmi://"" + host + "":"" + connectorPort + ""/jndi/rmi://"" + host
                                    + "":"" + registryPort + serviceUrlPath);
        } else {
            url = new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://"" + host + "":"" + registryPort
                                    + serviceUrlPath);
        }
        cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);
        // Start the connector server asynchronously (in a separate thread).
        Thread connectorThread = new Thread() {
            public void run() {
                try {
                    cs.start();
                } catch (IOException ioe) {
                    LOG.warn(""Could not start JMXConnector thread."", ioe);
                }
            }
        };
        connectorThread.setName(""Camel JMX Connector Thread ["" + url + ""]"");
        connectorThread.start();
        LOG.info(""JMX Connector thread started and listening at: "" + url);
    }
    public String getMBeanObjectDomainName() {
        return mBeanObjectDomainName;
    }
    public void setServer(MBeanServer value) {
        server = value;
    }
}
"
org.apache.camel.component.file.strategy.NoOpFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
/**
 * A simple strategy which does not move or delete the processed files in any way.
 *
 * @version $Revision$
 */
public class NoOpFileProcessStrategy extends FileProcessStrategySupport {
    public NoOpFileProcessStrategy() {
        super(true);
    }
    public NoOpFileProcessStrategy(boolean isLock) {
        super(isLock);
    }
}
"
org.apache.camel.language.IllegalSyntaxException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Language;
/**
 * An exception thrown if some illegal syntax is rejected by a specific language
 *
 * @version $Revision$
 */
public class IllegalSyntaxException extends RuntimeCamelException {
    private final Language language;
    private final String expression;
    public IllegalSyntaxException(Language language, String expression) {
        this(language, expression, null);
    }
    public IllegalSyntaxException(Language language, String expression, Throwable cause) {
        super(""Illegal syntax for language: "" + language + "". Expression: "" + expression, cause);
        this.language = language;
        this.expression = expression;
    }
    public String getExpression() {
        return expression;
    }
    public Language getLanguage() {
        return language;
    }
}
"
org.apache.camel.component.jcr.JcrEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.net.URI;
import java.net.URISyntaxException;
import javax.jcr.Credentials;
import javax.jcr.Repository;
import javax.jcr.SimpleCredentials;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
/**
 * A JCR endpoint
 */
public class JcrEndpoint extends DefaultEndpoint<DefaultExchange> {
    private Credentials credentials;
    private Repository repository;
    private String base;
    @SuppressWarnings(""unchecked"")
    protected JcrEndpoint(String endpointUri, JcrComponent component) {
        super(endpointUri, component);
        try {
            URI uri = new URI(endpointUri);
            if (uri.getUserInfo() != null && uri.getAuthority() != null) {
                this.credentials = new SimpleCredentials(uri.getUserInfo(), uri.getAuthority().toCharArray());
            }
            this.repository = (Repository) component.getCamelContext().getRegistry().lookup(uri.getHost());
            if (repository == null) {
                throw new RuntimeCamelException(""No JCR repository defined under '"" + uri.getHost() + ""'"");
            }
            this.base = uri.getPath().replaceAll(""^/"", """");
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException(""Invalid URI: "" + endpointUri, e);
        }
    }
    public JcrEndpoint(String endpointUri, String base, Credentials credentials, Repository repository) {
        super(endpointUri);
        this.base = base;
        this.credentials = credentials;
        this.repository = repository;
    }
    /**
     * Currently unsupported
     * @throws RuntimeCamelException
     */
    public Consumer<DefaultExchange> createConsumer(Processor processor) throws Exception {
        throw new RuntimeCamelException(""No consumer endpoint support for JCR available"");
    }
    /**
     * Creates a new {@link Producer} 
     */
    public Producer<DefaultExchange> createProducer() throws Exception {
        return new JcrProducer(this);
    }
    /**
     * {@inheritDoc}
     */
    public boolean isSingleton() {
        return false;
    }
    /**
     * Get the {@link Repository}
     * 
     * @return the repository
     */
    protected Repository getRepository() {
        return repository;
    }
    /**
     * Get the {@link Credentials} for establishing the JCR repository connection
     * 
     * @return the credentials
     */
    protected Credentials getCredentials() {
        return credentials;
    }
    /**
     * Get the base node when accessing the reposititory
     * 
     * @return the base node
     */
    protected String getBase() {
        return base;
    }
}
"
org.apache.camel.component.cxf.CxfEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.configuration.spring.ConfigurerImpl;
import org.apache.cxf.message.Message;
import org.springframework.context.ApplicationContext;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Endpoint</a>
 *
 * @version $Revision$
 */
public class CxfEndpoint extends DefaultEndpoint<CxfExchange> {
    private final CxfComponent component;
    private final String address;
    private String wsdlURL;
    private String serviceClass;
    private String portName;
    private String serviceName;
    private String dataFormat;
    private String beanId;
    private String serviceClassInstance;
    private boolean isWrapped;
    private boolean isSpringContextEndpoint;
    private boolean inOut = true;
    private Boolean isSetDefaultBus;
    private ConfigurerImpl configurer;
    private CxfEndpointBean cxfEndpointBean;
    public CxfEndpoint(String uri, String address, CxfComponent component) {
        super(uri, component);
        this.component = component;
        this.address = address;
        if (address.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {
            isSpringContextEndpoint = true;
            // Get the bean from the Spring context
            beanId = address.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());
            if (beanId.startsWith(""//"")) {
                beanId = beanId.substring(2);
            }
            SpringCamelContext context = (SpringCamelContext) this.getCamelContext();
            configurer = new ConfigurerImpl(context.getApplicationContext());
            cxfEndpointBean = (CxfEndpointBean) context.getApplicationContext().getBean(beanId);
            ObjectHelper.notNull(cxfEndpointBean, ""cxfEndpointBean"");
        }
    }
    public Producer<CxfExchange> createProducer() throws Exception {
        return new CxfProducer(this);
    }
    public Consumer<CxfExchange> createConsumer(Processor processor) throws Exception {
        return new CxfConsumer(this, processor);
    }
    public CxfExchange createExchange() {
        return new CxfExchange(getCamelContext(), getExchangePattern());
    }
    public CxfExchange createExchange(ExchangePattern pattern) {
        return new CxfExchange(getCamelContext(), pattern);
    }
    public CxfExchange createExchange(Message inMessage) {
        return new CxfExchange(getCamelContext(), getExchangePattern(), inMessage);
    }
    public String getDataFormat() {
        return dataFormat;
    }
    public void setDataFormat(String format) {
        dataFormat = format;
    }
    public boolean isSpringContextEndpoint() {
        return isSpringContextEndpoint;
    }
    public String getAddress() {
        return address;
    }
    public String getWsdlURL() {
        return wsdlURL;
    }
    public void setWsdlURL(String url) {
        wsdlURL = url;
    }
    public void setSetDefaultBus(Boolean set) {
        isSetDefaultBus = set;
    }
    public Boolean isSetDefaultBus() {
        return isSetDefaultBus;
    }
    public String getServiceClass() {
        return serviceClass;
    }
    public void setServiceClass(String className) {        
        serviceClass = className;
    }
    public String getServiceClassInstance() {
        return serviceClassInstance;
    }
    public void setServiceClassInstance(String classInstance) {
        serviceClassInstance = classInstance;
    }
    public void setPortName(String port) {
        portName = port;
    }
    public void setServiceName(String service) {
        serviceName = service;
    }
    public String getPortName() {
        return portName;
    }
    public String getServiceName() {
        return serviceName;
    }
    public boolean isInOut() {
        return inOut;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public boolean isWrapped() {
        return isWrapped;
    }
    public void setWrapped(boolean wrapped) {
        isWrapped = wrapped;
    }
    public CxfComponent getComponent() {
        return component;
    }
    public boolean isSingleton() {
        return true;
    }
    public String getBeanId() {
        return beanId;
    }
    public CxfEndpointBean getCxfEndpointBean() {
        return cxfEndpointBean;
    }
    public void configure(Object beanInstance) {
        configurer.configureBean(beanId, beanInstance);
    }
    public ApplicationContext getApplicationContext() {
        if (getCamelContext() instanceof SpringCamelContext) {
            SpringCamelContext context = (SpringCamelContext) getCamelContext();
            return context.getApplicationContext();
        } else {
            return null;
        }
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return component.getHeaderFilterStrategy();
    }
}
"
org.apache.camel.impl.converter.TypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
/**
 * Registry for type converters.
 *
 * @version $Revision$
 */
public interface TypeConverterRegistry {
    /**
     * Allows a new type converter to be registered
     *
     * @param toType        the type to convert to
     * @param fromType      the type to convert from
     * @param typeConverter the type converter to use
     */
    void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter);
    Injector getInjector();
}
"
org.apache.camel.component.mail.MailBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.mail.Address;
import javax.mail.BodyPart;
import javax.mail.Header;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Part;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.mail.util.ByteArrayDataSource;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.CollectionHelper;
/**
 * A Strategy used to convert between a Camel {@link Exchange} and {@link Message} to and
 * from a Mail {@link MimeMessage}
 *
 * @version $Revision$
 */
public class MailBinding {
    private HeaderFilterStrategy headerFilterStrategy;
    public MailBinding() {
        headerFilterStrategy = new DefaultHeaderFilterStrategy();
    }
    public MailBinding(HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }
    public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange)
        throws MessagingException, IOException {
        // camel message headers takes presedence over endpoint configuration
        if (hasRecipientHeaders(exchange.getIn())) {
            setRecipientFromCamelMessage(mimeMessage, exchange, exchange.getIn());
        } else {
            // fallback to endpoint configuration
            setRecipientFromEndpointConfiguration(mimeMessage, endpoint);
        }
        // must have at least one recipients otherwise we do not know where to send the mail
        if (mimeMessage.getAllRecipients() == null) {
            throw new IllegalArgumentException(""The mail message does not have any recipients set."");
        }
        // append the rest of the headers (no recipients) that could be subject, reply-to etc.
        appendHeadersFromCamelMessage(mimeMessage, exchange, exchange.getIn());
        if (empty(mimeMessage.getFrom())) {
            // lets default the address to the endpoint destination
            String from = endpoint.getConfiguration().getFrom();
            mimeMessage.setFrom(new InternetAddress(from));
        }
        if (exchange.getIn().hasAttachments()) {
            appendAttachmentsFromCamel(mimeMessage, exchange.getIn(), endpoint.getConfiguration());
        } else {
            if (""text/html"".equals(endpoint.getConfiguration().getContentType())) {
                DataSource ds = new ByteArrayDataSource(exchange.getIn().getBody(String.class), ""text/html"");
                mimeMessage.setDataHandler(new DataHandler(ds));
            } else {
                // its just text/plain
                mimeMessage.setText(exchange.getIn().getBody(String.class));
            }
        }
    }
    /**
     * Extracts the body from the Mail message
     */
    public Object extractBodyFromMail(MailExchange exchange, Message message) {
        try {
            return message.getContent();
        } catch (Exception e) {
            throw new RuntimeCamelException(""Failed to extract body due to: "" + e.getMessage()
                + "". Exchange: "" + exchange + "". Message: "" + message, e);
        }
    }
    /**
     * Appends the Mail headers from the Camel {@link MailMessage}
     */
    protected void appendHeadersFromCamelMessage(MimeMessage mimeMessage, Exchange exchange,
                                                 org.apache.camel.Message camelMessage)
        throws MessagingException {
        for (Map.Entry<String, Object> entry : camelMessage.getHeaders().entrySet()) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerValue != null) {
                if (headerFilterStrategy != null
                        && !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue)) {
                    if (isRecipientHeader(headerName)) {
                        // skip any recipients as they are handled specially
                        continue;
                    }
                    // Mail messages can repeat the same header...
                    if (ObjectConverter.isCollection(headerValue)) {
                        Iterator iter = ObjectConverter.iterator(headerValue);
                        while (iter.hasNext()) {
                            Object value = iter.next();
                            mimeMessage.addHeader(headerName, asString(exchange, value));
                        }
                    } else {
                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));
                    }
                }
            }
        }
    }
    private void setRecipientFromCamelMessage(MimeMessage mimeMessage, Exchange exchange,
                                                org.apache.camel.Message camelMessage)
        throws MessagingException {
        for (Map.Entry<String, Object> entry : camelMessage.getHeaders().entrySet()) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerValue != null && isRecipientHeader(headerName)) {
                // special handling of recipients
                if (ObjectConverter.isCollection(headerValue)) {
                    Iterator iter = ObjectConverter.iterator(headerValue);
                    while (iter.hasNext()) {
                        Object recipient = iter.next();
                        appendRecipientToMimeMessage(mimeMessage, headerName, asString(exchange, recipient));
                    }
                } else {
                    appendRecipientToMimeMessage(mimeMessage, headerName, asString(exchange, headerValue));
                }
            }
        }
    }
    /**
     * Appends the Mail headers from the endpoint configuraiton.
     */
    protected void setRecipientFromEndpointConfiguration(MimeMessage mimeMessage, MailEndpoint endpoint)
        throws MessagingException {
        Map<Message.RecipientType, String> recipients = endpoint.getConfiguration().getRecipients();
        if (recipients.containsKey(Message.RecipientType.TO)) {
            appendRecipientToMimeMessage(mimeMessage, Message.RecipientType.TO.toString(), recipients.get(Message.RecipientType.TO));
        }
        if (recipients.containsKey(Message.RecipientType.CC)) {
            appendRecipientToMimeMessage(mimeMessage, Message.RecipientType.CC.toString(), recipients.get(Message.RecipientType.CC));
        }
        if (recipients.containsKey(Message.RecipientType.BCC)) {
            appendRecipientToMimeMessage(mimeMessage, Message.RecipientType.BCC.toString(), recipients.get(Message.RecipientType.BCC));
        }
        // fallback to use destination if no TO provided at all
        String destination = endpoint.getConfiguration().getDestination();
        if (destination != null && mimeMessage.getRecipients(Message.RecipientType.TO) == null) {
            appendRecipientToMimeMessage(mimeMessage, Message.RecipientType.TO.toString(), destination);
        }
    }
    /**
     * Appends the Mail attachments from the Camel {@link MailMessage}
     */
    protected void appendAttachmentsFromCamel(MimeMessage mimeMessage, org.apache.camel.Message camelMessage,
                                              MailConfiguration configuration)
        throws MessagingException {
        // Create a Multipart
        MimeMultipart multipart = new MimeMultipart();
        // fill the body with text
        multipart.setSubType(""mixed"");
        MimeBodyPart textBodyPart = new MimeBodyPart();
        textBodyPart.setContent(camelMessage.getBody(String.class), configuration.getContentType());
        multipart.addBodyPart(textBodyPart);
        for (Map.Entry<String, DataHandler> entry : camelMessage.getAttachments().entrySet()) {
            String attachmentFilename = entry.getKey();
            DataHandler handler = entry.getValue();
            if (handler != null) {
                if (shouldOutputAttachment(camelMessage, attachmentFilename, handler)) {
                    // Create another body part
                    BodyPart messageBodyPart = new MimeBodyPart();
                    // Set the data handler to the attachment
                    messageBodyPart.setDataHandler(handler);
                    // Set the filename
                    messageBodyPart.setFileName(attachmentFilename);
                    // Set Disposition
                    messageBodyPart.setDisposition(Part.ATTACHMENT);
                    // Add part to multipart
                    multipart.addBodyPart(messageBodyPart);
                }
            }
        }
        // Put parts in message
        mimeMessage.setContent(multipart);
    }
    /**
     * Strategy to allow filtering of attachments which are put on the Mail message
     */
    protected boolean shouldOutputAttachment(org.apache.camel.Message camelMessage, String attachmentFilename, DataHandler handler) {
        return true;
    }
    protected Map<String, Object> extractHeadersFromMail(Message mailMessage) throws MessagingException {
        Map<String, Object> answer = new HashMap<String, Object>();
        Enumeration names = mailMessage.getAllHeaders();
        while (names.hasMoreElements()) {
            Header header = (Header)names.nextElement();
            String[] value = mailMessage.getHeader(header.getName());
            if (headerFilterStrategy != null
                    && !headerFilterStrategy.applyFilterToExternalHeaders(header.getName(), value)) {
                // toLowerCase() for doing case insensitive search
                if (value.length == 1) {
                    CollectionHelper.appendValue(answer, header.getName().toLowerCase(), value[0]);
                } else {
                    CollectionHelper.appendValue(answer, header.getName().toLowerCase(), value);
                }
            }
        }
        return answer;
    }
    private static void appendRecipientToMimeMessage(MimeMessage mimeMessage, String type, String recipient)
        throws MessagingException {
        // we support that multi recipient can be given as a string seperated by comma or semi colon
        String[] lines = recipient.split(""[,|;]"");
        for (String line : lines) {
            line = line.trim();
            mimeMessage.addRecipients(asRecipientType(type), line);
        }
    }
    /**
     * Does the given camel message contain any To, CC or BCC header names?
     */
    private static boolean hasRecipientHeaders(org.apache.camel.Message camelMessage) {
        for (String key : camelMessage.getHeaders().keySet()) {
            if (isRecipientHeader(key)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Is the given key a mime message recipient header (To, CC or BCC)
     */
    private static boolean isRecipientHeader(String key) {
        if (Message.RecipientType.TO.toString().equalsIgnoreCase(key)) {
            return true;
        } else if (Message.RecipientType.CC.toString().equalsIgnoreCase(key)) {
            return true;
        } else if (Message.RecipientType.BCC.toString().equalsIgnoreCase(key)) {
            return true;
        }
        return false;
    }
    /**
     * Returns the RecipientType object.
     */
    private static Message.RecipientType asRecipientType(String type) {
        if (Message.RecipientType.TO.toString().equalsIgnoreCase(type)) {
            return Message.RecipientType.TO;
        } else if (Message.RecipientType.CC.toString().equalsIgnoreCase(type)) {
            return Message.RecipientType.CC;
        } else if (Message.RecipientType.BCC.toString().equalsIgnoreCase(type)) {
            return Message.RecipientType.BCC;
        }
        throw new IllegalArgumentException(""Unknown recipient type: "" + type);
    }
    private static boolean empty(Address[] addresses) {
        return addresses == null || addresses.length == 0;
    }
    private static String asString(Exchange exchange, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);
    }
}
"
org.apache.camel.component.http.HttpClientConfigurer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.commons.httpclient.HttpClient;
/**
 * A plugable strategy for configuring the HttpClient used by this component
 *
 * @version $Revision$
 */
public interface HttpClientConfigurer {
    /**
     * Configure the HttpClient such as setting the authentication or proxying details
     */
    void configureHttpClient(HttpClient client);
}
"
org.apache.camel.component.list.ListComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.list;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/list.html"">List</a> component.
 *
 * @version $Revision$
 */
public class ListComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new ListEndpoint(uri, this);
    }
}"
org.apache.camel.component.cxf.CamelInvoker,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.cxf.util.CxfHeaderHelper;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.frontend.MethodDispatcher;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.invoker.Invoker;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
public class CamelInvoker implements Invoker, MessageInvoker {
    private static final Logger LOG = LogUtils.getL7dLogger(CamelInvoker.class);
    private CxfConsumer cxfConsumer;
    public CamelInvoker(CxfConsumer consumer) {
        cxfConsumer = consumer;
    }
    /**
    * This method is called when the incoming message is to
    * be passed into the Camel processor. The return value is the response
    * from the processor
    */
    public void invoke(Exchange exchange) {
        Message inMessage = exchange.getInMessage();
        //TODO set the request context here
        CxfEndpoint endpoint = cxfConsumer.getEndpoint();
        CxfExchange cxfExchange = endpoint.createExchange(inMessage);
        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);
        cxfExchange.setProperty(BindingOperationInfo.class.toString(), bop);
        if (bop != null && bop.getOperationInfo().isOneWay()) {
            cxfExchange.setPattern(ExchangePattern.InOnly);
        } else {
            cxfExchange.setPattern(ExchangePattern.InOut);
        }
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception ex) {
            // catch the exception and send back to cxf client
            throw new Fault(ex);
        }
        // make sure the client has returned back the message
        copybackExchange(cxfExchange, exchange);
        Message outMessage = exchange.getOutMessage();
        // update the outMessageContext
        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        if (boi != null) {
            exchange.put(BindingMessageInfo.class, boi.getOutput());
        }
    }
    public void copybackExchange(CxfExchange result, Exchange exchange) {
        final Endpoint endpoint = exchange.get(Endpoint.class);
        Message outMessage = null;
        if (result.isFailed()) {
            // The exception will be send back to the soap client
            CxfMessage fault = result.getFault();
            outMessage = exchange.getInFaultMessage();
            if (outMessage == null) {
                outMessage = endpoint.getBinding().createMessage();
                outMessage.setExchange(exchange);
                exchange.setInFaultMessage(outMessage);
            }
            Throwable ex = (Throwable) fault.getBody();
            if (ex != null) {
                outMessage.setContent(Throwable.class, ex);
            } else {
                outMessage.setContent(Throwable.class, result.getException());
            }
        } else {
            outMessage = result.getOutMessage();
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(""Get the response outMessage "" + outMessage);
            }
            // Copy the outMessage back if we set the out's body
            org.apache.camel.Message camelMessage = result.getOut();
            CxfBinding.copyMessage(camelMessage, outMessage);
        }
        // set the CXF outMessage back to the exchange
        exchange.setOutMessage(outMessage);
    }
    @SuppressWarnings(""unchecked"")
    public void updateContext(Map<String, Object> from, Map<String, Object> to) {
        if (to != null && from != null) {
            for (Iterator iter = from.entrySet().iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry) iter.next();
                String key = (String)entry.getKey();
                //Requires deep copy.
                if (!(Message.INBOUND_MESSAGE.equals(key)
                      || Message.REQUESTOR_ROLE.equals(key)
                      || Message.PROTOCOL_HEADERS.equals(key))) {
                    to.put(key, entry.getValue());
                }
            }
        }
    }
    /**
     * This method is called when the incoming pojo or WebServiceProvider invocation is called
     * from the service invocation interceptor. The return value is the response
     * from the processor
     */
    public Object invoke(Exchange exchange, Object o) {
        CxfEndpoint endpoint = cxfConsumer.getEndpoint();
        Object params = null;
        if (o instanceof List) {
            params = CastUtils.cast((List<?>)o);
        } else if (o != null) {
            params = new MessageContentsList(o);
        }
        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());
        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);
        MethodDispatcher md = (MethodDispatcher)
            exchange.get(Service.class).get(MethodDispatcher.class.getName());
        Method m = md.getMethod(bop);
        cxfExchange.setProperty(BindingOperationInfo.class.toString(), bop);
        // The SEI could be the provider class which will not have the bop information.
        if (bop != null && bop.getOperationInfo().isOneWay()) {
            cxfExchange.setPattern(ExchangePattern.InOnly);
        } else {
            cxfExchange.setPattern(ExchangePattern.InOut);
        }
        if (bop != null && bop.getName() != null) {
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAMESPACE, bop.getName().getNamespaceURI());
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, bop.getName().getLocalPart());
        } else {
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());
        }
        CxfHeaderHelper.propagateCxfToCamel(endpoint.getHeaderFilterStrategy(), exchange.getInMessage(),
                cxfExchange.getIn().getHeaders());
        cxfExchange.getIn().setBody(params);
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception ex) {
            // catch the exception and send back to cxf client
            throw new Fault(ex);
        }
        Object result = null;
        if (cxfExchange.isFailed()) {
            Throwable ex = (Throwable)cxfExchange.getFault().getBody();
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                if (ex == null) {
                    ex = cxfExchange.getException();
                }
                throw new Fault(ex);
            }
        } else {
            result = cxfExchange.getOut().getBody();
            if (result != null) {
                if (result instanceof MessageContentsList || result instanceof List || result.getClass().isArray()) {
                    return result;
                } else { // if the result is the single object
                    MessageContentsList resList = new MessageContentsList();
                    resList.add(result);
                    return resList;
                }
            }
        }
        return result;
    }
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class SoapMessageInInterceptor extends AbstractMessageInInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageInInterceptor() {
        super(Phase.READ);
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(SoapMessage message) {
        //Fault Processing is Handled in SOAP Binding in the ReadHeadersInterceptor.
        return false;
    }
    protected BindingOperationInfo getBindingOperation(SoapMessage message, Document doc) {
        Exchange ex = message.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : soapBinding.getOperations()) {
            String style = soapBinding.getStyle(boi.getOperationInfo());
            QName rootName = null;
            if (""rpc"".equals(style)) {
                rootName = boi.getOperationInfo().getName();
            } else {
                BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
                if (bmi != null) {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        if (boiList.size() > 1
            && LOG.isLoggable(Level.INFO)) {
            LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
        }
        return boiList.size() != 1 ? null : boiList.get(0);
    }
    protected List<Element> getPartList(SoapMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        Exchange ex = inMessage.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Remove the operation element.
            rootNode = (Element)DOMUtils.getChild(rootNode, Node.ELEMENT_NODE);
        }
        partList.add(rootNode);
        return partList;
    }
}
"
org.apache.camel.component.jpa.TransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import org.apache.camel.Service;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public interface TransactionStrategy extends Service {
    Object execute(JpaCallback callback);
}
"
org.apache.camel.Producer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Provides a channel on which clients can create and invoke message exchanges
 * on an {@link Endpoint}
 * 
 * @version $Revision$
 */
public interface Producer<E extends Exchange> extends Processor, Service {
    Endpoint<E> getEndpoint();
    /**
     * Creates a new exchange to send to this endpoint
     * 
     * @return a newly created exchange
     */
    E createExchange();
    /**
     * Creates a new exchange of the given pattern to send to this endpoint
     *
     * @return a newly created exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(E exchange);
}
"
org.apache.camel.builder.PredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision$
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange)  + "" on "" + exchange);
        }
    }
    protected String assertionFailureMessage(E exchange) {
        return toString();
    }
}
"
org.apache.camel.component.cxf.util.NullDestination,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
public class NullDestination implements Destination {
    MessageObserver messageObserver;
    public NullDestination() {
        // do nothing here
    }
    public EndpointReferenceType getAddress() {
        return null;
    }
    public Conduit getBackChannel(Message inMessage, Message partialResponse, EndpointReferenceType address) throws IOException {
        return null;
    }
    public MessageObserver getMessageObserver() {
        return messageObserver;
    }
    public void shutdown() {
        messageObserver = null;
    }
    public void setMessageObserver(MessageObserver observer) {
        messageObserver = observer;
    }
}
"
org.apache.camel.component.cxf.DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * The data format the user expects to see at the Camel CXF components.  It can be
 * configured as a property (DataFormat) in the Camel CXF endpoint.
 */
public enum DataFormat {
    /**
     * PAYLOAD is the message payload of the message after message configured in
     * the CXF endpoint is applied.  Streaming and non-streaming are both
     * supported.
     */
    PAYLOAD,
    /**
     * MESSAGE is the raw message that is received from the transport layer.
     * Streaming and non-streaming are both supported.
     */
    MESSAGE,
    /**
     * POJOs (Plain old Java objects) are the Java parameters to the method
     * it is invoking on the target server.  The ""serviceClass"" property
     * must be included in the endpoint.  Streaming is not available for this
     * data format.
     */
    POJO,
    /**
     * For UNKNOWN cases.
     */
    UNKNOWN;
    public static DataFormat asEnum(String value) {
        try {
            return valueOf(value.toUpperCase());
        } catch (Exception e) {
            return UNKNOWN;
        }
    }
}
"
org.apache.camel.component.jmx.JMXMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import org.apache.camel.impl.DefaultMessage;
/**
 * A {@link org.apache.camel.Message Message} for a JMX Notification
 * 
 * @version $Revision$
 */
public class JMXMessage extends DefaultMessage {
    private Notification notification;
    public JMXMessage() {
        this(null);
    }
    public JMXMessage(Notification notification) {
        this.notification = notification;
    }
    @Override
    public String toString() {
        return ""JMXMessage: "" + notification;
    }
    @Override
    public JMXExchange getExchange() {
        return (JMXExchange)super.getExchange();
    }
    @Override
    public JMXMessage newInstance() {
        return new JMXMessage();
    }
    public Notification getNotification() {
        return notification;
    }
}
"
org.apache.camel.component.bean.ParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Expression;
/**
 * A strategy for creating a default parameter expression for a given type
 *
 * @version $Revision$
 */
public interface ParameterMappingStrategy {
    Expression getDefaultParameterTypeExpression(Class parameterType);
}
"
org.apache.camel.language.LanguageExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Base annotation for language expressions.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface LanguageExpression {
    String language();
    String expression();
}
"
org.apache.camel.builder.script.ScriptLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.CamelContext;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
/**
 * @version $Revision$
 */
public class ScriptLanguageResolver implements LanguageResolver {
    public Language resolveLanguage(String name, CamelContext context) {
        return new ScriptLanguage(name);
    }
}
"
org.apache.camel.component.irc.IrcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultEndpoint;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Endpoint</a>
 *
 * @version $Revision$
 */
public class IrcEndpoint extends DefaultEndpoint<IrcExchange> {
    private IrcBinding binding;
    private IrcConfiguration configuration;
    private IrcComponent component;
    public IrcEndpoint(String endpointUri, IrcComponent component, IrcConfiguration configuration) {
        super(endpointUri, component);
        this.component = component;
        this.configuration = configuration;
    }
    public boolean isSingleton() {
        return true;
    }
    public IrcExchange createExchange(ExchangePattern pattern) {
        return new IrcExchange(getCamelContext(), pattern, getBinding());
    }
    public IrcExchange createOnPrivmsgExchange(String target, IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""PRIVMSG"", target, user, msg));
    }
    public IrcExchange createOnNickExchange(IRCUser user, String newNick) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""NICK"", user, newNick));
    }
    public IrcExchange createOnQuitExchange(IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""QUIT"", user, msg));
    }
    public IrcExchange createOnJoinExchange(String channel, IRCUser user) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""JOIN"", channel, user));
    }
    public IrcExchange createOnKickExchange(String channel, IRCUser user, String whoWasKickedNick, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""KICK"", channel, user, whoWasKickedNick, msg));
    }
    public IrcExchange createOnModeExchange(String channel, IRCUser user, IRCModeParser modeParser) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""MODE"", channel, user, modeParser.getLine()));
    }
    public IrcExchange createOnPartExchange(String channel, IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""PART"", channel, user, msg));
    }
    public IrcExchange createOnTopicExchange(String channel, IRCUser user, String topic) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""TOPIC"", channel, user, topic));
    }
    public IrcProducer createProducer() throws Exception {
        return new IrcProducer(this, component.getIRCConnection(configuration));
    }
    public IrcConsumer createConsumer(Processor processor) throws Exception {
        return new IrcConsumer(this, processor, component.getIRCConnection(configuration));
    }
    public IrcComponent getComponent() {
        return component;
    }
    public void setComponent(IrcComponent component) {
        this.component = component;
    }
    public IrcBinding getBinding() {
        if (binding == null) {
            binding = new IrcBinding();
        }
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.restlet.converter.RestletConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet.converter;
import org.apache.camel.Converter;
import org.restlet.data.MediaType;
import org.restlet.data.Method;
/**
 *
 * @version $Revision$
 */
@Converter
public class RestletConverter {
    @Converter
    public Method toMethod(String name) {
        return Method.valueOf(name.toUpperCase());
    }
    @Converter
    public MediaType toMediaType(String name) {
        return MediaType.valueOf(name);
    }
}
"
org.apache.camel.component.event.EventEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Endpoint</a>
 * for working with Spring ApplicationEvents
 *
 * @version $Revision$
 */
public class EventEndpoint extends DefaultEndpoint<Exchange> implements ApplicationContextAware {
    private LoadBalancer loadBalancer;
    private ApplicationContext applicationContext;
    public EventEndpoint(String endpointUri, EventComponent component) {
        super(endpointUri, component);
        this.applicationContext = component.getApplicationContext();
    }
    public EventEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<Exchange> createProducer() throws Exception {
        ObjectHelper.notNull(getApplicationContext(), ""applicationContext"");
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                ApplicationEvent event = toApplicationEvent(exchange);
                getApplicationContext().publishEvent(event);
            }
        };
    }
    public EventConsumer createConsumer(Processor processor) throws Exception {
        return new EventConsumer(this, processor);
    }
    public void onApplicationEvent(ApplicationEvent event) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(event);
        try {
            getLoadBalancer().process(exchange);
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(EventConsumer consumer) {
        getLoadBalancer().addProcessor(consumer.getProcessor());
    }
    public synchronized void consumerStopped(EventConsumer consumer) {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
    }
    protected LoadBalancer createLoadBalancer() {
        return new TopicLoadBalancer();
    }
    protected ApplicationEvent toApplicationEvent(Exchange exchange) {
        try {
            ApplicationEvent event = exchange.getIn().getBody(ApplicationEvent.class);
            if (event != null) {
                return event;
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore, handled below
        }
        return new CamelEvent(this, exchange);
    }
}
"
org.apache.camel.converter.ObjectConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.util.Collection;
import java.util.Iterator;
import org.apache.camel.Converter;
import org.apache.camel.util.ObjectHelper;
/**
 * Some core java.lang based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class ObjectConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectConverter() {
    }
    public static boolean isCollection(Object value) {
        // TODO we should handle primitive array types?
        return value instanceof Collection || (value != null && value.getClass().isArray());
    }
    /**
     * Creates an iterator over the value
     *
     * @deprecated use {@link org.apache.camel.util.ObjectHelper#createIterator(Object)}. Will be removed in Camel 2.0.
     */
    @SuppressWarnings(""unchecked"")
    @Converter
    @Deprecated
    public static Iterator iterator(Object value) {
        return ObjectHelper.createIterator(value);
    }
    /**
     * Converts the given value to a boolean, handling strings or Boolean
     * objects; otherwise returning false if the value could not be converted to
     * a boolean
     */
    @Converter
    public static boolean toBool(Object value) {
        Boolean answer = toBoolean(value);
        if (answer != null) {
            return answer.booleanValue();
        }
        return false;
    }
    /**
     * Converts the given value to a Boolean, handling strings or Boolean
     * objects; otherwise returning null if the value cannot be converted to a
     * boolean
     */
    @Converter
    public static Boolean toBoolean(Object value) {
        return ObjectHelper.toBoolean(value);
    }
    /**
     * Returns the boolean value, or null if the value is null
     */
    @Converter
    public static Boolean toBoolean(Boolean value) {
        if (value != null) {
            return value;
        }
        return Boolean.FALSE;
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Byte toByte(Object value) {
        if (value instanceof Byte) {
            return (Byte) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Byte.valueOf(number.byteValue());
        } else if (value instanceof String) {
            return Byte.valueOf((String) value);
        } else {
            return null;
        }
    }
    @Converter
    public static byte[] toByteArray(String value) {
        return value.getBytes();
    }
    @Converter
    public static char[] toCharArray(String value) {
        return value.toCharArray();
    }
    @Converter
    public static String fromCharArray(char[] value) {
        return new String(value);
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Short toShort(Object value) {
        if (value instanceof Short) {
            return (Short) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Short.valueOf(number.shortValue());
        } else if (value instanceof String) {
            return Short.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Integer toInteger(Object value) {
        if (value instanceof Integer) {
            return (Integer) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Integer.valueOf(number.intValue());
        } else if (value instanceof String) {
            return Integer.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Long toLong(Object value) {
        if (value instanceof Long) {
            return (Long) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Long.valueOf(number.longValue());
        } else if (value instanceof String) {
            return Long.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Float toFloat(Object value) {
        if (value instanceof Float) {
            return (Float) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Float.valueOf(number.floatValue());
        } else if (value instanceof String) {
            return Float.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Double toDouble(Object value) {
        if (value instanceof Double) {
            return (Double) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Double.valueOf(number.doubleValue());
        } else if (value instanceof String) {
            return Double.valueOf((String) value);
        } else {
            return null;
        }
    }
}
"
org.apache.camel.AsyncCallback,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The callback interface for an {@link AsyncProcessor} so that it can
 * notify you when an {@link Exchange} has completed. 
 */
public interface AsyncCallback {
    /**
     * This method is invoked once the Exchange is completed.  If an error 
     * occurred while processing the exchange, the exception field of the 
     * {@link Exchange} being processed will hold the error. 
     *  
     * @param doneSynchronously set to true if the processing of the exchange was completed synchronously thread.
     */
    void done(boolean doneSynchronously);    
}
"
org.apache.camel.spring.Main,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import javax.xml.bind.JAXBException;
import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.spring.handler.CamelNamespaceHandler;
import org.apache.camel.util.MainSupport;
import org.apache.camel.view.ModelFileGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
/**
 * A command line tool for booting up a CamelContext using an optional Spring
 * ApplicationContext
 *
 * @version $Revision$
 */
public class Main extends MainSupport {
    private static Main instance;
    private String applicationContextUri = ""META-INF/spring/*.xml"";
    private String fileApplicationContextUri;
    private AbstractApplicationContext applicationContext;
    private AbstractApplicationContext parentApplicationContext;
    private String parentApplicationContextUri;
    public Main() {
        addOption(new ParameterOption(""ac"", ""applicationContext"",
                ""Sets the classpath based spring ApplicationContext"", ""applicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setApplicationContextUri(parameter);
            }
        });
        addOption(new ParameterOption(""fa"", ""fileApplicationContext"",
                ""Sets the filesystem based spring ApplicationContext"", ""fileApplicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setFileApplicationContextUri(parameter);
            }
        });
    }
    /**
     * A class for intercepting the hang up signal and do a graceful shutdown of
     * the Camel.
     */
    private class HangupInterceptor extends Thread {
        Log log = LogFactory.getLog(this.getClass());
        Main mainInstance;
        public HangupInterceptor(Main main) {
            mainInstance = main;
        }
        @Override
        public void run() {
            log.info(""Recieved hang up - stopping the main instance."");
            try {
                mainInstance.stop();
            } catch (Exception ex) {
                log.warn(ex);
            }
        }
    }
    public static void main(String... args) {
        Main main = new Main();
        instance = main;
        main.enableHangupSupport();
        main.run(args);
    }
    /**
     * Returns the currently executing main
     *
     * @return the current running instance
     */
    public static Main getInstance() {
        return instance;
    }
    /**
     * Enables the hangup support. Gracefully stops by calling stop() on a
     * Hangup signal.
     */
    public void enableHangupSupport() {
        HangupInterceptor interceptor = new HangupInterceptor(this);
        Runtime.getRuntime().addShutdownHook(interceptor);
    }
    @Override
    public void enableDebug() {
        super.enableDebug();
        setParentApplicationContextUri(""/META-INF/services/org/apache/camel/spring/debug.xml"");
    }
    @Override
    public void enableTrace() {
        super.enableTrace();
        setParentApplicationContextUri(""/META-INF/services/org/apache/camel/spring/trace.xml"");
    }
    // Properties
    // -------------------------------------------------------------------------
    public AbstractApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(AbstractApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String getApplicationContextUri() {
        return applicationContextUri;
    }
    public void setApplicationContextUri(String applicationContextUri) {
        this.applicationContextUri = applicationContextUri;
    }
    public String getFileApplicationContextUri() {
        return fileApplicationContextUri;
    }
    public void setFileApplicationContextUri(String fileApplicationContextUri) {
        this.fileApplicationContextUri = fileApplicationContextUri;
    }
    public AbstractApplicationContext getParentApplicationContext() {
        if (parentApplicationContext == null) {
            if (parentApplicationContextUri != null) {
                parentApplicationContext = new ClassPathXmlApplicationContext(parentApplicationContextUri);
                parentApplicationContext.start();
            }
        }
        return parentApplicationContext;
    }
    public void setParentApplicationContext(AbstractApplicationContext parentApplicationContext) {
        this.parentApplicationContext = parentApplicationContext;
    }
    public String getParentApplicationContextUri() {
        return parentApplicationContextUri;
    }
    public void setParentApplicationContextUri(String parentApplicationContextUri) {
        this.parentApplicationContextUri = parentApplicationContextUri;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (applicationContext == null) {
            applicationContext = createDefaultApplicationContext();
        }
        LOG.debug(""Starting Spring ApplicationContext: "" + applicationContext.getId());
        applicationContext.start();
        postProcessContext();
    }
    protected void doStop() throws Exception {
        super.doStop();
        if (applicationContext != null) {
            LOG.debug(""Stopping Spring ApplicationContext: "" + applicationContext.getId());
            applicationContext.close();
        }
    }
    protected ProducerTemplate findOrCreateCamelTemplate() {
        String[] names = getApplicationContext().getBeanNamesForType(ProducerTemplate.class);
        if (names != null && names.length > 0) {
            return (ProducerTemplate) getApplicationContext().getBean(names[0], ProducerTemplate.class);
        }
        for (CamelContext camelContext : getCamelContexts()) {
            return camelContext.createProducerTemplate();
        }
        throw new IllegalArgumentException(""No CamelContexts are available so cannot create a ProducerTemplate!"");
    }
    protected AbstractApplicationContext createDefaultApplicationContext() {
        // file based
        if (getFileApplicationContextUri() != null) {
            String[] args = getFileApplicationContextUri().split("";"");
            ApplicationContext parentContext = getParentApplicationContext();
            if (parentContext != null) {
                return new FileSystemXmlApplicationContext(args, parentContext);
            } else {
                return new FileSystemXmlApplicationContext(args);
            }
        }
        // default to classpath based
        String[] args = getApplicationContextUri().split("";"");
        ApplicationContext parentContext = getParentApplicationContext();
        if (parentContext != null) {
            return new ClassPathXmlApplicationContext(args, parentContext);
        } else {
            return new ClassPathXmlApplicationContext(args);
        }
    }
    protected Map<String, CamelContext> getCamelContextMap() {
        Map<String, SpringCamelContext> map = applicationContext.getBeansOfType(SpringCamelContext.class);
        Set<Map.Entry<String, SpringCamelContext>> entries = map.entrySet();
        Map<String, CamelContext> answer = new HashMap<String, CamelContext>();
        for (Map.Entry<String, SpringCamelContext> entry : entries) {
            String name = entry.getKey();
            CamelContext camelContext = entry.getValue();
            answer.put(name, camelContext);
        }
        return answer;
    }
    protected ModelFileGenerator createModelFileGenerator() throws JAXBException {
        return new ModelFileGenerator(new CamelNamespaceHandler().getJaxbContext());
    }
}
"
org.apache.camel.language.jxpath.JXPathLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * <a href=""http://commons.apache.org/jxpath/"">JXPath</a> {@link Language}
 * provider
 */
public class JXPathLanguage implements Language {
    public Expression<Exchange> createExpression(String expression) {
        return new JXPathExpression(expression, Object.class);
    }
    public Predicate<Exchange> createPredicate(String predicate) {
        return new JXPathExpression(predicate, Boolean.class);
    }
}
"
org.apache.camel.component.ibatis.IBatisProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.util.Iterator;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision$
 */
public class IBatisProducer extends DefaultProducer {
    private final IBatisEndpoint endpoint;
    public IBatisProducer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    @Override
    public IBatisEndpoint getEndpoint() {
        return (IBatisEndpoint) super.getEndpoint();
    }
    public void process(Exchange exchange) throws Exception {
        Object body = exchange.getIn().getBody();
        if (body == null) {
            // must be a poll so lets do a query
            endpoint.query(exchange.getOut(true));
        } else {
            String operation = getOperationName(exchange);
            // lets handle arrays or collections of objects
            Iterator iter = ObjectHelper.createIterator(body);
            while (iter.hasNext()) {
                endpoint.getSqlClient().insert(operation, iter.next());
            }
        }
    }
    /**
     * Returns the iBatis insert operation name
     */
    protected String getOperationName(Exchange exchange) {
        return endpoint.getEntityName();
    }
}
"
org.apache.camel.builder.Builder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A helper class for including portions of the <a
 * href=""http://activemq.apache.org/camel/expression.html"">expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision$
 */
public final class Builder {
    /**
     * Utility classes should not have a public constructor.
     */
    private Builder() {
    }
    /**
     * Returns a constant expression
     */
    public static <E extends Exchange> ValueBuilder<E> constant(Object value) {
        Expression<E> expression = ExpressionBuilder.constantExpression(value);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> header(String name) {
        Expression<E> expression = ExpressionBuilder.headerExpression(name);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> body() {
        Expression<E> expression = ExpressionBuilder.bodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> bodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.bodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> outBody() {
        Expression<E> expression = ExpressionBuilder.outBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> outBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.outBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> faultBody() {
        Expression<E> expression = ExpressionBuilder.faultBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> faultBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.faultBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name,
                                                                      final String defaultValue) {
        return new ValueBuilder<E>(ExpressionBuilder.<E> systemProperty(name, defaultValue));
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultExchange;
/**
 * An {@link Exchange} for working with Spring Integration endpoints which exposes the underlying
 * Spring messages via {@link #getInMessage()} and {@link #getOutMessage()}
 *
 * @version $Revision$
 */
public class SpringIntegrationExchange  extends DefaultExchange {
    public SpringIntegrationExchange(CamelContext context) {
        super(context);
    }
    public SpringIntegrationExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    @Override
    public Exchange newInstance() {
        return new SpringIntegrationExchange(this.getContext());
    }
    @Override
    public SpringIntegrationMessage getIn() {
        return (SpringIntegrationMessage) super.getIn();
    }
    @Override
    public SpringIntegrationMessage getOut() {
        return (SpringIntegrationMessage) super.getOut();
    }
    @Override
    public SpringIntegrationMessage getOut(boolean lazyCreate) {
        return (SpringIntegrationMessage) super.getOut(lazyCreate);
    }
    @Override
    public SpringIntegrationMessage getFault() {
        return (SpringIntegrationMessage) super.getFault();
    }
    @Override
    protected Message createFaultMessage() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Message createInMessage() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Message createOutMessage() {
        return new SpringIntegrationMessage();
    }
}
"
org.apache.camel.InvalidPayloadException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Is thrown if the payload from the exchange could not be retrieve because of being null, wrong class type etc.
 *
 * @version $Revision$
 */
public class InvalidPayloadException extends CamelExchangeException {
    private final Class<?> type;
    public InvalidPayloadException(Exchange exchange, Class<?> type) {
        this(exchange, type, exchange.getIn());
    }
    public InvalidPayloadException(Exchange exchange, Class<?> type, Message message) {
        super(""No in body available of type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(message.getBody()) + "" on: "" + message, exchange);
        this.type = type;
    }
    /**
     * The expected type of the body
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.component.http.HttpConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.BufferedReader;
import java.io.IOException;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import org.apache.camel.Converter;
/**
 * Some converter methods making it easy to convert the body of a message to servlet types or to switch between
 * the underlying {@link ServletInputStream} or {@link BufferedReader} payloads etc.
 *
 * @version $Revision$
 */
@Converter
public class HttpConverter {
    @Converter
    public HttpServletRequest toServletRequest(HttpMessage message) {
        if (message == null) {
            return null;
        }
        return message.getRequest();
    }
    @Converter
    public ServletInputStream toServletInputStream(HttpMessage message) throws IOException {
        HttpServletRequest request = toServletRequest(message);
        if (request != null) {
            return request.getInputStream();
        }
        return null;
    }
    @Converter
    public BufferedReader toReader(HttpMessage message) throws IOException {
        HttpServletRequest request = toServletRequest(message);
        if (request != null) {
            return request.getReader();
        }
        return null;
    }
}
"
org.apache.camel.component.event.EventComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Component</a>
 * for working with Spring ApplicationEvents
 * 
 * @version $Revision$
 */
public class EventComponent extends DefaultComponent<Exchange> implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    public EventComponent() {
    }
    public EventComponent(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public ConfigurableApplicationContext getConfigurableApplicationContext() {
        ApplicationContext applicationContext = getApplicationContext();
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return (ConfigurableApplicationContext)applicationContext;
        } else {
            throw new IllegalArgumentException(""Not created with a ConfigurableApplicationContext! Was: "" + applicationContext);
        }
    }
    protected EventEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        EventEndpoint answer = new EventEndpoint(uri, this);
        // getConfigurableApplicationContext().addApplicationListener(answer);
        return answer;
    }
}
"
org.apache.camel.component.jpa.QueryFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.Query;
/**
 * A Strategy to create a query to search for objects in a database
 *
 * @version $Revision$
 */
public interface QueryFactory {
    /**
     * Creates a new query to find objects to be processed
     *
     * @param entityManager
     * @return the query configured with any parameters etc
     */
    Query createQuery(EntityManager entityManager);
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.wsdl.Definition;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.SoapVersion;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.binding.soap.model.SoapHeaderInfo;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.wsdl11.WSDLServiceBuilder;
public class SoapMessageOutInterceptor extends AbstractMessageOutInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(SoapMessage message) throws Fault {        
        List<Element> payload = message.get(List.class);
        Exchange exchange = message.getExchange();
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        //The soap header is handled by the SoapOutInterceptor
        if (LOG.isLoggable(Level.INFO)) {
            LOG.info(""SoapMessageOutInterceptor binding operation style processing."");
        }
        SoapBindingInfo soapBinding = (SoapBindingInfo)exchange.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Add the Operation Node or Operation+""Response"" node
            //Remove the operation element.
            OperationInfo oi = bmi.getBindingOperation().getOperationInfo();
            Endpoint ep = exchange.get(Endpoint.class);
            Definition def =
                ep.getService().getServiceInfos().get(0).getProperty(WSDLServiceBuilder.WSDL_DEFINITION,
                                                             Definition.class);
            String prefix = def.getPrefix(oi.getName().getNamespaceURI());
            if ("""".equals(prefix)) {
                prefix = ""tns"";
            }
            QName opName = null;
            boolean isClient = isRequestor(message);
            if (isClient) {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart(),
                                   prefix);
            } else {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart() + ""Response"",
                                   prefix);
            }
            Element opEl = createElement(opName, payload);
            payload = new ArrayList<Element>();
            payload.add(opEl);
        }
        message.put(List.class, payload);
    }
}
"
org.apache.camel.language.juel.EL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of EL (JSP & JSF) expressions into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""el"")
public @interface EL {
    String value();
}"
org.apache.camel.HeaderFilterStrategyAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * An interface to represent an object which can make use of
 * injected {@link HeaderFilterStrategy}.
 * 
 * @since 1.5
 * @version $Revision$
 */
public interface HeaderFilterStrategyAware {
    HeaderFilterStrategy getHeaderFilterStrategy();
    void setHeaderFilterStrategy(HeaderFilterStrategy strategy);
}
"
org.apache.camel.spring.remoting.CamelProxyFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.component.bean.ProxyHelper;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.remoting.support.UrlBasedRemoteAccessor;
/**
 * A {@link FactoryBean} to create a Proxy to a a Camel Pojo Endpoint.
 *
 * @author chirino
 */
public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean, CamelContextAware, DisposableBean {
    private CamelContext camelContext;
    private Endpoint endpoint;
    private Object serviceProxy;
    private Producer producer;
    @Override
    public void afterPropertiesSet() {
        super.afterPropertiesSet();
        try {
            if (endpoint == null) {
                if (getServiceUrl() == null || camelContext == null) {
                    throw new IllegalArgumentException(""If endpoint is not specified, the serviceUrl and camelContext must be specified."");
                }
                endpoint = camelContext.getEndpoint(getServiceUrl());
                if (endpoint == null) {
                    throw new IllegalArgumentException(""Could not resolve endpoint: "" + getServiceUrl());
                }
            }
            this.producer = endpoint.createProducer();
            this.producer.start();
            this.serviceProxy = ProxyHelper.createProxy(endpoint, producer, getServiceInterface());
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public void destroy() throws Exception {
        this.producer.stop();
        this.producer = null;
        this.serviceProxy = null;
    }
    public Class getServiceInterface() {
        return super.getServiceInterface();
    }
    public String getServiceUrl() {
        return super.getServiceUrl();
    }
    public Object getObject() throws Exception {
        return serviceProxy;
    }
    public Class getObjectType() {
        return getServiceInterface();
    }
    public boolean isSingleton() {
        return true;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
}
"
org.apache.camel.language.groovy.GroovyLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.GroovyClassLoader;
import groovy.lang.Script;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class GroovyLanguage implements Language  {
    public static GroovyExpression groovy(String expression) {
        return new GroovyLanguage().createExpression(expression);
    }
    public GroovyExpression createPredicate(String expression) {
        return createExpression(expression);
    }
    public GroovyExpression createExpression(String expression) {
        Class<Script> scriptType = parseExpression(expression);
        return new GroovyExpression(scriptType, expression);
    }
    protected Class<Script> parseExpression(String expression) {
        return new GroovyClassLoader().parseClass(expression);
    }
}
"
org.apache.camel.InOut,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a method as being {@link ExchangePattern#InOut} when a class or interface has been annotated with
 * {@link InOnly} when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a> or
 * <a href=""http://activemq.apache.org/camel/spring-remoting.html"">Spring Remoting</a>.
 *
 * This annotation is only intended to be used on methods which the class or interface has been annotated with
 * a default exchange pattern annotation such as {@link InOnly} or {@link Pattern}
 *
 * See the <a href=""using-exchange-pattern-annotations.html"">using exchange pattern annotations</a>
 * for more details on how the overloading rules work.
 *
 * @see org.apache.camel.ExchangePattern
 * @see org.apache.camel.Exchange#getPattern()
 * @see InOut
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Pattern(ExchangePattern.InOut)
public @interface InOut {
}"
org.apache.camel.component.bean.NoBeanAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelException;
/**
 * Exception thrown if the bean could not be found in the registry.
 *
 * @version $Revision$
 */
public class NoBeanAvailableException extends CamelException {
    private final String name;
    public NoBeanAvailableException(String name) {
        super(""No bean available for endpoint: "" + name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
"
org.apache.camel.component.test.TestEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.test;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.EndpointHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/test.html"">Test Endpoint</a> is a
 * <a href=""http://activemq.apache.org/camel/mock.html"">Mock Endpoint</a> for testing but it will
 * pull all messages from the nested endpoint and use those as expected message body assertions.
 *
 * @version $Revision$
 */
public class TestEndpoint extends MockEndpoint implements Service {
    private static final transient Log LOG = LogFactory.getLog(TestEndpoint.class);
    private final Endpoint expectedMessageEndpoint;
    private long timeout = 2000L;
    public TestEndpoint(String endpointUri, Component component, Endpoint expectedMessageEndpoint) {
        super(endpointUri, component);
        this.expectedMessageEndpoint = expectedMessageEndpoint;
    }
    public TestEndpoint(String endpointUri, Endpoint expectedMessageEndpoint) {
        super(endpointUri);
        this.expectedMessageEndpoint = expectedMessageEndpoint;
    }
    public void start() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Consuming expected messages from: "" + expectedMessageEndpoint);
        }
        final List expectedBodies = new ArrayList();
        EndpointHelper.pollEndpoint(expectedMessageEndpoint, new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object body = getInBody(exchange);
                expectedBodies.add(body);
            }
        }, timeout);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Received: "" + expectedBodies.size() + "" expected message(s) from: "" + expectedMessageEndpoint);
        }
        expectedBodiesReceived(expectedBodies);
    }
    public void stop() throws Exception {
    }
    /**
     * This method allows us to convert or coerce the expected message body into some other type
     */
    protected Object getInBody(Exchange exchange) {
        return exchange.getIn().getBody();
    }
}
"
org.apache.camel.language.juel.BeanAndMethodELResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import javax.el.BeanELResolver;
import javax.el.ELContext;
import javax.el.PropertyNotFoundException;
/**
 * An extension of the JUEL {@link BeanELResolver} which also supports the resolving of methods
 *
 * @version $Revision$
 */
public class BeanAndMethodELResolver extends BeanELResolver {
    public BeanAndMethodELResolver() {
        super(false);
    }
    @Override
    public Object getValue(ELContext elContext, Object base, Object property) {
        try {
            return super.getValue(elContext, base, property);
        } catch (PropertyNotFoundException e) {
            // lets see if its a method call...
            Method method = findMethod(elContext, base, property);
            if (method != null) {
                elContext.setPropertyResolved(true);
                return method;
            } else {
                throw e;
            }
        }
    }
    protected Method findMethod(ELContext elContext, Object base, Object property) {
        if (base != null && property instanceof String) {
            Method[] methods = base.getClass().getMethods();
            List<Method> matching = new ArrayList<Method>();
            for (Method method : methods) {
                if (method.getName().equals(property) && Modifier.isPublic(method.getModifiers())) {
                    matching.add(method);
                }
            }
            int size = matching.size();
            if (size > 0) {
                if (size > 1) {
                    // TODO there's currently no way for JUEL to tell us how many parameters there are
                    // so lets just pick the first one that has a single param by default
                    for (Method method : matching) {
                        Class<?>[] paramTypes = method.getParameterTypes();
                        if (paramTypes.length == 1) {
                            return method;
                        }
                    }
                }
                // lets default to the first one
                return matching.get(0);
            }
        }
        return null;
    }
}
"
org.apache.camel.component.jhc.JhcServerEngineFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.util.HashMap;
import java.util.Map;
import org.apache.http.params.HttpParams;
public final class JhcServerEngineFactory {
    private static Map<Integer, JhcServerEngine> portMap = new HashMap<Integer, JhcServerEngine>();
    private JhcServerEngineFactory() {
        //Utility Class
    }
    public static synchronized JhcServerEngine getJhcServerEngine(final HttpParams params, final int port, final String protocol) {
        JhcServerEngine engine = portMap.get(port);
        // check the engine parament
        if (engine == null) {
            engine = new JhcServerEngine(params, port, protocol.trim());
            portMap.put(port, engine);
        } else {
            if (!engine.getProtocol().equals(protocol.trim())) {
                throw new IllegalArgumentException(""Jhc protocol error, the engine's protocol is ""
                                                   + engine.getProtocol() + "" you want is "" + protocol);
            }
        }
        return engine;
    }
}
"
org.apache.camel.converter.jaxp.StringSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class which provides a JAXP {@link javax.xml.transform.Source Source} from a String which can
 * be read as many times as required. Encoding is default UTF-8.
 *
 * @version $Revision$
 */
public class StringSource extends StreamSource implements Externalizable {
    private String text;
    private String encoding = ""UTF-8"";
    public StringSource() {
    }
    public StringSource(String text) {
        ObjectHelper.notNull(text, ""text"");
        this.text = text;
    }
    public StringSource(String text, String systemId) {
        this(text);
        ObjectHelper.notNull(systemId, ""systemId"");
        setSystemId(systemId);
    }
    public StringSource(String text, String systemId, String encoding) {
        this(text, systemId);
        ObjectHelper.notNull(encoding, ""encoding"");
        this.encoding = encoding;
    }
    public InputStream getInputStream() {
        try {
            return new ByteArrayInputStream(text.getBytes(encoding));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
    public Reader getReader() {
        return new StringReader(text);
    }
    public String toString() {
        return ""StringSource["" + text + ""]"";
    }
    public String getText() {
        return text;
    }
    public String getEncoding() {
        return encoding;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    /**
     * @deprecated will be removed in Camel 2.0
     */
    public void setText(String text) {
        this.text = text;
    }
    public void writeExternal(ObjectOutput out) throws IOException {
        int b = (text != null ? 0x01 : 0x00) + (encoding != null ? 0x02 : 0x00)
                + (getPublicId() != null ? 0x04 : 0x00) + (getSystemId() != null ? 0x08 : 0x00);
        out.writeByte(b);
        if ((b & 0x01) != 0) {
            out.writeUTF(text);
        }
        if ((b & 0x02) != 0) {
            out.writeUTF(encoding);
        }
        if ((b & 0x04) != 0) {
            out.writeUTF(getPublicId());
        }
        if ((b & 0x08) != 0) {
            out.writeUTF(getSystemId());
        }
    }
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        int b = in.readByte();
        if ((b & 0x01) != 0) {
            text = in.readUTF();
        }
        if ((b & 0x02) != 0) {
            encoding = in.readUTF();
        }
        if ((b & 0x04) != 0) {
            setPublicId(in.readUTF());
        }
        if ((b & 0x08) != 0) {
            setSystemId(in.readUTF());
        }
    }
}
"
org.apache.camel.builder.script.ScriptLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class ScriptLanguage implements Language {
    private final String language;
    public ScriptLanguage(String language) {
        this.language = language;
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return new ScriptBuilder(language, expression);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new ScriptBuilder(language, expression);
    }
}
"
org.apache.camel.CamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.FactoryFinder;
/**
 * Interface used to represent the context used to configure routes and the
 * policies to use during message exchanges between endpoints.
 *
 * @version $Revision$
 */
public interface CamelContext extends Service {
    /**
     * Gets the name of the this context.
     *
     * @return the name
     */
    String getName();
    // Component Management Methods
    //-----------------------------------------------------------------------
    /**
     * Adds a component to the context.
     *
     * @param componentName  the name the component is registered as
     * @param component      the component
     */
    void addComponent(String componentName, Component component);
    /**
     * Gets a component from the context by name.
     *
     * @param componentName the name of the component
     * @return the component
     */
    Component getComponent(String componentName);
    /**
     * Gets a component from the context by name and specifying the expected type of component.
     *
     * @param name  the name to lookup
     * @param componentType  the expected type
     * @return the component
     */
    <T extends Component> T getComponent(String name, Class<T> componentType);
    /**
     * Removes a previously added component.
     *
     * @param componentName the component name to remove
     * @return the previously added component or null if it had not been previously added.
     */
    Component removeComponent(String componentName);
    /**
     * Gets the a previously added component by name or lazily creates the component
     * using the factory Callback.
     *
     * @param componentName the name of the component
     * @param factory       used to create a new component instance if the component was not previously added.
     * @return the component
     */
    Component getOrCreateComponent(String componentName, Callable<Component> factory);
    // Endpoint Management Methods
    //-----------------------------------------------------------------------
    /**
     * Resolves the given URI to an {@link Endpoint}.  If the URI has a singleton endpoint
     * registered, then the singleton is returned.  Otherwise, a new {@link Endpoint} is created
     * and if the endpoint is a singleton it is registered as a singleton endpoint.
     *
     * @param uri  the URI of the endpoint
     * @return  the endpoint
     */
    Endpoint getEndpoint(String uri);
    /**
     * Resolves the given name to an {@link Endpoint} of the specified type.
     * If the name has a singleton endpoint registered, then the singleton is returned.
     * Otherwise, a new {@link Endpoint} is created and if the endpoint is a
     * singleton it is registered as a singleton endpoint.
     *
     * @param name  the name of the endpoint
     * @param endpointType  the expected type
     * @return the endpoint
     */
    <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType);
    /**
     * Returns the collection of all registered endpoints.
     *
     * @return  all endpoints
     */
    Collection<Endpoint> getEndpoints();
    /**
     * Returns the collection of all registered endpoints for a uri or an empty collection.
     * For a singleton endpoint the collection will contain exactly one element.
     *
     * @param uri  the URI of the endpoints
     * @return  collection of endpoints
     */
    Collection<Endpoint> getEndpoints(String uri);
    /**
     * Returns the collection of all registered singleton endpoints.
     *
     * @return  all the singleton endpoints
     */
    Collection<Endpoint> getSingletonEndpoints();
    /**
     * Adds the endpoint to the context using the given URI.
     *
     * @param uri the URI to be used to resolve this endpoint
     * @param endpoint the endpoint to be added to the context
     * @return the old endpoint that was previously registered to the context if 
     * there was already an singleton endpoint for that URI or null
     * @throws Exception if the new endpoint could not be started or the old 
     * singleton endpoint could not be stopped
     */
    Endpoint addEndpoint(String uri, Endpoint endpoint) throws Exception;
    /**
     * Removes all endpoints with the given URI
     *
     * @param uri the URI to be used to remove
     * @return a collection of endpoints removed or null if there are no endpoints for this URI
     * @throws Exception if at least one endpoint could not be stopped
     */
    Collection<Endpoint> removeEndpoints(String uri) throws Exception;
    /**
     * Adds the endpoint to the context using the given URI.  The endpoint will be registered as a singleton.
     *
     * @param uri the URI to be used to resolve this endpoint
     * @param endpoint the endpoint to be added to the context
     * @return the old endpoint that was previously registered to the context if there was
     * already an endpoint for that URI
     * @throws Exception if the new endpoint could not be started or the old endpoint could not be stopped
     */
    @Deprecated
    Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception;
    /**
     * Removes the singleton endpoint with the given URI
     *
     * @param uri the URI to be used to remove
     * @return the endpoint that was removed or null if there is no endpoint for this URI
     * @throws Exception if endpoint could not be stopped
     */
    @Deprecated
    Endpoint removeSingletonEndpoint(String uri) throws Exception;
    // Route Management Methods
    //-----------------------------------------------------------------------
    /**
     * Returns a list of the current route definitions
     *
     * @return list of the current route definitions
     */
    List<RouteType> getRouteDefinitions();
    /**
     * Returns the current routes in this context
     *
     * @return the current routes
     */
    List<Route> getRoutes();
    /**
     * Sets the routes for this context, replacing any current routes
     *
     * @param routes the new routes to use
     * @deprecated is considered for deprecation, use addRoutes instead, could be removed in Camel 2.0
     */
    @Deprecated
    void setRoutes(List<Route> routes);
    /**
     * Adds a collection of routes to this context
     *
     * @param routes the routes to add
     * @throws Exception if the routes could not be created for whatever reason
     */
    void addRoutes(Collection<Route> routes) throws Exception;
    /**
     * Adds a collection of routes to this context using the given builder
     * to build them
     *
     * @param builder the builder which will create the routes and add them to this context
     * @throws Exception if the routes could not be created for whatever reason
     */
    void addRoutes(Routes builder) throws Exception;
    /**
     * Adds a collection of route definitions to the context
     *
     * @param routeDefinitions the route definitions to add
     * @throws Exception if the route definition could not be created for whatever reason
     */
    void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception;
    // Properties
    //-----------------------------------------------------------------------
    /**
     * Returns the converter of exchanges from one type to another
     *
     * @return the converter
     */
    ExchangeConverter getExchangeConverter();
    /**
     * Returns the type converter used to coerce types from one type to another
     *
     * @return the converter
     */
    TypeConverter getTypeConverter();
    /**
     * Returns the registry used to lookup components by name and type such as the Spring ApplicationContext,
     * JNDI or the OSGi Service Registry
     *
     * @return the registry
     */
    Registry getRegistry();
    /**
     * Returns the injector used to instantiate objects by type
     *
     * @return the injector
     */
    Injector getInjector();
    /**
     * Returns the lifecycle strategy used to handle lifecycle notification
     *
     * @return the lifecycle strategy
     */
    LifecycleStrategy getLifecycleStrategy();
    /**
     * Resolves a language for creating expressions
     *
     * @param language  name of the language
     * @return the resolved language
     */
    Language resolveLanguage(String language);
    /**
     * Creates a new ProducerTemplate.
     * <p/>
     * See this FAQ before use: <a href=""http://activemq.apache.org/camel/why-does-camel-use-too-many-threads-with-producertemplate.html"">
     * Why does Camel use too many threads with ProducerTemplate?</a>
     *
     * @return the template
     */
    <E extends Exchange> ProducerTemplate<E> createProducerTemplate();
    /**
     * Adds the given interceptor strategy
     *
     * @param interceptStrategy the strategy
     */
    void addInterceptStrategy(InterceptStrategy interceptStrategy);
    /**
     * Gets the default error handler builder which is inherited by the routes
     *
     * @return the builder
     */
    ErrorHandlerBuilder getErrorHandlerBuilder();
    /**
     * Sets the default error handler builder which is inherited by the routes
     *
     * @param errorHandlerBuilder  the builder
     */
    void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder);
    /**
     * Sets the data formats that can be referenced in the routes.
     * @param dataFormats the data formats
     */
    void setDataFormats(Map<String, DataFormatType> dataFormats);
    /**
     * Gets the data formats that can be referenced in the routes.
     *
     * @return the data formats available
     */
    Map<String, DataFormatType> getDataFormats();
    /**
     * Create a FactoryFinder which will be used for the loading the factory class from META-INF
     * @return the factory finder
     */
    FactoryFinder createFactoryFinder();
    /**
     * Create a FactoryFinder which will be used for the loading the factory class from META-INF
     * @param path the META-INF path
     * @return the factory finder
     */
    FactoryFinder createFactoryFinder(String path);
}
"
org.apache.camel.component.http.HttpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.net.URI;
import java.net.URISyntaxException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.params.HttpClientParams;
/**
 * Represents a <a href=""http://activemq.apache.org/camel/http.html"">HTTP
 * endpoint</a>
 *
 * @version $Revision$
 */
public class HttpEndpoint extends DefaultPollingEndpoint<HttpExchange> {
    private HttpBinding binding;
    private HttpComponent component;
    private URI httpUri;
    private HttpClientParams clientParams;
    private HttpClientConfigurer httpClientConfigurer;
    private HttpConnectionManager httpConnectionManager;
    public HttpEndpoint(String endPointURI, HttpComponent component, URI httpURI, HttpConnectionManager httpConnectionManager) throws URISyntaxException {
        this(endPointURI, component, httpURI, new HttpClientParams(), httpConnectionManager, null);
    }
    public HttpEndpoint(String endPointURI, HttpComponent component, URI httpURI, HttpClientParams clientParams,
                        HttpConnectionManager httpConnectionManager, HttpClientConfigurer clientConfigurer) throws URISyntaxException {
        super(endPointURI, component);
        this.component = component;
        this.httpUri = httpURI;
        this.clientParams = clientParams;
        this.httpClientConfigurer = clientConfigurer;
        this.httpConnectionManager = httpConnectionManager;
    }
    public Producer<HttpExchange> createProducer() throws Exception {
        return new HttpProducer(this);
    }
    @Override
    public PollingConsumer<HttpExchange> createPollingConsumer() throws Exception {
        return new HttpPollingConsumer(this);
    }
    public HttpExchange createExchange(ExchangePattern pattern) {
        return new HttpExchange(this, pattern);
    }
    public HttpExchange createExchange(HttpServletRequest request, HttpServletResponse response) {
        return new HttpExchange(this, request, response);
    }
    /**
     * Factory method used by producers and consumers to create a new {@link HttpClient} instance
     */
    public HttpClient createHttpClient() {
        HttpClient answer = new HttpClient(getClientParams());
        answer.setHttpConnectionManager(httpConnectionManager);
        HttpClientConfigurer configurer = getHttpClientConfigurer();
        if (configurer != null) {
            configurer.configureHttpClient(answer);
        }
        return answer;
    }
    public void connect(HttpConsumer consumer) throws Exception {
        component.connect(consumer);
    }
    public void disconnect(HttpConsumer consumer) throws Exception {
        component.disconnect(consumer);
    }
    @Override
    public boolean isLenientProperties() {
        // true to allow dynamic URI options to be configured and passed to external system for eg. the HttpProducer
        return true;
    }
    // Properties
    //-------------------------------------------------------------------------
    /**
     * Provide access to the client parameters used on new {@link HttpClient} instances
     * used by producers or consumers of this endpoint.
     */
    public HttpClientParams getClientParams() {
        return clientParams;
    }
    /**
     * Provide access to the client parameters used on new {@link HttpClient} instances
     * used by producers or consumers of this endpoint.
     */
    public void setClientParams(HttpClientParams clientParams) {
        this.clientParams = clientParams;
    }
    public HttpClientConfigurer getHttpClientConfigurer() {
        return httpClientConfigurer;
    }
    /**
     * Register a custom configuration strategy for new {@link HttpClient} instances
     * created by producers or consumers such as to configure authentication mechanisms etc
     *
     * @param httpClientConfigurer the strategy for configuring new {@link HttpClient} instances
     */
    public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {
        this.httpClientConfigurer = httpClientConfigurer;
    }
    public HttpBinding getBinding() {
        if (binding == null) {
            binding = new DefaultHttpBinding(getHeaderFilterStrategy());
        }
        return binding;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return component.getHeaderFilterStrategy();
    }
    public void setBinding(HttpBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return true;
    }
    public String getPath() {
        return httpUri.getPath();
    }
    public int getPort() {
        if (httpUri.getPort() == -1) {
            if (""https"".equals(getProtocol())) {
                return 443;
            } else {
                return 80;
            }
        }
        return httpUri.getPort();
    }
    public String getProtocol() {
        return httpUri.getScheme();
    }
    public URI getHttpUri() {
        return httpUri;
    }
}
"
org.apache.camel.RuntimeExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception caused by a specific message {@link Exchange}
 *
 * @version $Revision$
 */
public class RuntimeExchangeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public RuntimeExchangeException(String message, Exchange exchange) {
        super(message + "" on the exchange: "" +  exchange);
        this.exchange = exchange;
    }
    public RuntimeExchangeException(Exception e, Exchange exchange) {
        super(e.getMessage(), e);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
}"
org.apache.camel.component.http.CamelServlet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @version $Revision$
 */
public class CamelServlet extends HttpServlet {
    private ConcurrentHashMap<String, HttpConsumer> consumers = new ConcurrentHashMap<String, HttpConsumer>();
    public CamelServlet() {
    }
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            // Is there a consumer registered for the request.
            HttpConsumer consumer = resolve(request);
            if (consumer == null) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            // Have the camel process the HTTP exchange.
            HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);
            consumer.getProcessor().process(exchange);
            // HC: The getBinding() is interesting because it illustrates the
            // impedance miss-match between
            // HTTP's stream oriented protocol, and Camels more message oriented
            // protocol exchanges.
            // now lets output to the response
            consumer.getBinding().writeResponse(exchange, response);
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
    protected HttpConsumer resolve(HttpServletRequest request) {
        String path = request.getPathInfo();
        return consumers.get(path);
    }
    public void connect(HttpConsumer consumer) {
        consumers.put(consumer.getPath(), consumer);
    }
    public void disconnect(HttpConsumer consumer) {
        consumers.remove(consumer.getPath());
    }
}
"
org.apache.camel.language.Bean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject a bean expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""bean"")
public @interface Bean {
    String value();
}"
org.apache.camel.ResolveEndpointFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an {@link Endpoint} can not be resolved via URI
 * 
 * @version $Revision$
 */
public class ResolveEndpointFailedException extends RuntimeCamelException {
    private final String uri;
    public ResolveEndpointFailedException(String uri, Throwable cause) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + cause, cause);
        this.uri = uri;
    }
    public ResolveEndpointFailedException(String uri, String message) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + message);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.InvalidTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Is thrown if type conversion failed.
 *
 * @version $Revision$
 */
public class InvalidTypeException extends CamelExchangeException {
    private final Object value;
    private final Class<?> type;
    public InvalidTypeException(Exchange exchange, Object value, Class<?> type) {
        super(""Could not convert value: "" + value + "" to type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(value), exchange);
        this.value = value;
        this.type = type;
    }
    /**
     * The value
     */
    public Object getValue() {
        return value;
    }
    /**
     * The expected type of the value
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.bam.model.ProcessInstance,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a single business process
 *
 * @version $Revision$
 */
@Entity
public class ProcessInstance  {
    private static final transient Log LOG = LogFactory.getLog(ProcessInstance.class);
    private ProcessDefinition processDefinition;
    private Collection<ActivityState> activityStates = new HashSet<ActivityState>();
    private String correlationKey;
    private Date timeStarted;
    private Date timeCompleted;
    public ProcessInstance() {
        setTimeStarted(new Date());
    }
    public String toString() {
        return ""ProcessInstance["" + getCorrelationKey() + ""]"";
    }
    @Id
    public String getCorrelationKey() {
        return correlationKey;
    }
    public void setCorrelationKey(String correlationKey) {
        this.correlationKey = correlationKey;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    @OneToMany(mappedBy = ""processInstance"", fetch = FetchType.LAZY, cascade = {CascadeType.ALL })
    public Collection<ActivityState> getActivityStates() {
        return activityStates;
    }
    public void setActivityStates(Collection<ActivityState> activityStates) {
        this.activityStates = activityStates;
    }
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }    // Helper methods
    //-------------------------------------------------------------------------
    /**
     * Returns the activity state for the given activity
     *
     * @param activityRules the activity to find the state for
     * @return the activity state or null if no state could be found for the
     *         given activity
     */
    public ActivityState getActivityState(ActivityRules activityRules) {
        for (ActivityState activityState : getActivityStates()) {
            if (activityState.isActivity(activityRules)) {
                return activityState;
            }
        }
        return null;
    }
    public ActivityState getOrCreateActivityState(ActivityRules activityRules) {
        ActivityState state = getActivityState(activityRules);
        if (state == null) {
            state = createActivityState();
            state.setProcessInstance(this);
            state.setActivityDefinition(activityRules.getActivityDefinition());
            // we don't need to do: getTemplate().persist(state);
        }
        return state;
    }
    protected ActivityState createActivityState() {
        return new ActivityState();
    }
}
"
org.apache.camel.spring.SpringRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spring.spi.SpringTransactionPolicy;
import org.apache.camel.spring.spi.TransactionErrorHandlerBuilder;
import org.apache.camel.spring.spi.TransactionInterceptor;
import org.springframework.context.ApplicationContext;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * An extension of the {@link RouteBuilder} to provide some additional helper
 * methods
 *
 * @version $Revision$
 */
public abstract class SpringRouteBuilder extends RouteBuilder {
    private ApplicationContext applicationContext;
    public TransactionInterceptor transactionInterceptor() {
        return new TransactionInterceptor(bean(TransactionTemplate.class));
    }
    /**
     * Looks up the bean with the given name in the application context and
     * returns it, or throws an exception if the bean is not present or is not
     * of the given type
     *
     * @param type the type of the bean
     * @param beanName the name of the bean in the application context
     * @return the bean
     */
    public <T> T bean(Class<T> type, String beanName) {
        ApplicationContext context = getApplicationContext();
        return (T)context.getBean(beanName, type);
    }
    /**
     * Looks up the bean with the given type in the application context and
     * returns it, or throws an exception if the bean is not present or there
     * are multiple possible beans to choose from for the given type
     *
     * @param type the type of the bean
     * @return the bean
     */
    public <T> T bean(Class<T> type) {
        ApplicationContext context = getApplicationContext();
        String[] names = context.getBeanNamesForType(type, true, true);
        if (names != null) {
            int count = names.length;
            if (count == 1) {
                // lets instantiate the single bean
                return (T)context.getBean(names[0]);
            } else if (count > 1) {
                throw new IllegalArgumentException(""Too many beans in the application context of type: "" + type + "". Found: "" + count);
            }
        }
        throw new IllegalArgumentException(""No bean available in the application context of type: "" + type);
    }
    /**
     * Returns the application context which has been configured via the
     * {@link #setApplicationContext(ApplicationContext)} method or from the
     * underlying {@link SpringCamelContext}
     */
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            CamelContext camelContext = getContext();
            if (camelContext instanceof SpringCamelContext) {
                SpringCamelContext springCamelContext = (SpringCamelContext)camelContext;
                return springCamelContext.getApplicationContext();
            } else {
                throw new IllegalArgumentException(""This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured"");
            }
        }
        return applicationContext;
    }
    /**
     * Sets the application context to use to lookup beans
     */
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    /**
     * Creates a transaction error handler.
     *
     * @param policy   using this transaction policy (eg: required, supports, ...)
     * @return the created error handler
     */
    public TransactionErrorHandlerBuilder transactionErrorHandler(SpringTransactionPolicy policy) {
        TransactionErrorHandlerBuilder answer = new TransactionErrorHandlerBuilder();
        answer.setTransactionTemplate(policy.getTemplate());
        return answer;
    }
}
"
org.apache.camel.spring.handler.CamelNamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.xml.bind.Binder;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.spring.CamelBeanPostProcessor;
import org.apache.camel.spring.CamelContextFactoryBean;
import org.apache.camel.spring.CamelJMXAgentType;
import org.apache.camel.spring.CamelTemplateFactoryBean;
import org.apache.camel.spring.EndpointFactoryBean;
import org.apache.camel.spring.remoting.CamelProxyFactoryBean;
import org.apache.camel.spring.remoting.CamelServiceExporter;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.view.ModelFileGenerator;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
/**
 * Camel namespace for the spring XML configuration file.
 */
public class CamelNamespaceHandler extends NamespaceHandlerSupport {
    protected BeanDefinitionParser endpointParser = new BeanDefinitionParser(EndpointFactoryBean.class);
    protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser(CamelBeanPostProcessor.class);
    protected Set<String> parserElementNames = new HashSet<String>();
    protected Binder<Node> binder;
    private JAXBContext jaxbContext;
    private Map<String, BeanDefinitionParser> parserMap = new HashMap<String, BeanDefinitionParser>();
    public ModelFileGenerator createModelFileGenerator() throws JAXBException {
        return new ModelFileGenerator(getJaxbContext());
    }
    public void init() {
        // remoting
        addBeanDefinitionParser(""proxy"", CamelProxyFactoryBean.class);
        addBeanDefinitionParser(""template"", CamelTemplateFactoryBean.class);
        addBeanDefinitionParser(""export"", CamelServiceExporter.class);
        // data types
        addBeanDefinitionParser(""artixDS"", ArtixDSDataFormat.class);
        addBeanDefinitionParser(""jaxb"", JaxbDataFormat.class);
        addBeanDefinitionParser(""serialization"", SerializationDataFormat.class);
        addBeanDefinitionParser(""xmlBeans"", XMLBeansDataFormat.class);
        // load balancers
        addBeanDefinitionParser(""roundRobin"", RoundRobinLoadBalanceStrategy.class);
        addBeanDefinitionParser(""random"", RandomLoadBalanceStrategy.class);
        addBeanDefinitionParser(""sticky"", StickyLoadBalanceStrategy.class);
        addBeanDefinitionParser(""topic"", TopicLoadBalanceStrategy.class);
        // jmx agent
        addBeanDefinitionParser(""jmxAgent"", CamelJMXAgentType.class);
        // TODO switch to use the above mechanism?
        registerParser(""endpoint"", endpointParser);
        Class cl = CamelContextFactoryBean.class;
        try {
            cl = Class.forName(""org.apache.camel.osgi.CamelContextFactoryBean"");
        } catch (Throwable t) {
        }
        registerParser(""camelContext"", new CamelContextBeanDefinitionParser(cl));
    }
    private void addBeanDefinitionParser(String elementName, Class<?> type) {
        BeanDefinitionParser parser = new BeanDefinitionParser(type);
        registerParser(elementName, parser);
        parserMap.put(elementName, parser);
    }
    protected void createBeanPostProcessor(ParserContext parserContext, String contextId, Element childElement, BeanDefinitionBuilder parentBuilder) {
        String beanPostProcessorId = contextId + "":beanPostProcessor"";
        childElement.setAttribute(""id"", beanPostProcessorId);
        BeanDefinition definition = beanPostProcessorParser.parse(childElement, parserContext);
        definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
        parentBuilder.addPropertyReference(""beanPostProcessor"", beanPostProcessorId);
    }
    protected void registerScriptParser(String elementName, String engineName) {
        registerParser(elementName, new ScriptDefinitionParser(engineName));
    }
    protected void registerParser(String name,
                                  org.springframework.beans.factory.xml.BeanDefinitionParser parser) {
        parserElementNames.add(name);
        registerBeanDefinitionParser(name, parser);
    }
    public Set<String> getParserElementNames() {
        return parserElementNames;
    }
    protected Object parseUsingJaxb(Element element, ParserContext parserContext) {
        try {
            binder = getJaxbContext().createBinder();
            return binder.unmarshal(element);
            /*
             * Unmarshaller unmarshaller =
             * getJaxbContext().createUnmarshaller(); return
             * unmarshaller.unmarshal(element);
             */
        } catch (JAXBException e) {
            throw new BeanDefinitionStoreException(""Failed to parse JAXB element: "" + e, e);
        }
    }
    public JAXBContext getJaxbContext() throws JAXBException {
        if (jaxbContext == null) {
            jaxbContext = createJaxbContext();
        }
        return jaxbContext;
    }
    protected JAXBContext createJaxbContext() throws JAXBException {
        StringBuilder packages = new StringBuilder();
        for (Class cl : getJaxbPackages()) {
            if (packages.length() > 0) {
                packages.append("":"");
            }
            packages.append(cl.getName().substring(0, cl.getName().lastIndexOf('.')));
        }
        return JAXBContext.newInstance(packages.toString(), getClass().getClassLoader());
    }
    protected Set<Class> getJaxbPackages() {
        Set<Class> classes = new HashSet<Class>();
        classes.add(org.apache.camel.spring.CamelContextFactoryBean.class);
        classes.add(ExchangePattern.class);
        classes.add(org.apache.camel.model.RouteType.class);
        classes.add(org.apache.camel.model.config.StreamResequencerConfig.class);
        classes.add(org.apache.camel.model.dataformat.DataFormatType.class);
        classes.add(org.apache.camel.model.language.ExpressionType.class);
        classes.add(org.apache.camel.model.loadbalancer.LoadBalancerType.class);
        return classes;
    }
    protected class CamelContextBeanDefinitionParser extends BeanDefinitionParser {
        public CamelContextBeanDefinitionParser(Class type) {
            super(type);
        }
        @Override
        protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
            super.doParse(element, parserContext, builder);
            String contextId = element.getAttribute(""id"");
            // lets avoid folks having to explicitly give an ID to a camel
            // context
            if (ObjectHelper.isNullOrBlank(contextId)) {
                contextId = ""camelContext"";
                element.setAttribute(""id"", contextId);
            }
            // now lets parse the routes
            Object value = parseUsingJaxb(element, parserContext);
            if (value instanceof CamelContextFactoryBean) {
                CamelContextFactoryBean factoryBean = (CamelContextFactoryBean)value;
                builder.addPropertyValue(""id"", contextId);
                builder.addPropertyValue(""routes"", factoryBean.getRoutes());
                builder.addPropertyValue(""intercepts"", factoryBean.getIntercepts());
                builder.addPropertyValue(""dataFormats"", factoryBean.getDataFormats());
                builder.addPropertyValue(""builderRefs"", factoryBean.getBuilderRefs());
                if (factoryBean.getPackages().length > 0) {
                    builder.addPropertyValue(""packages"", factoryBean.getPackages());
                }
            }
            boolean createdBeanPostProcessor = false;
            NodeList list = element.getChildNodes();
            int size = list.getLength();
            for (int i = 0; i < size; i++) {
                Node child = list.item(i);
                if (child instanceof Element) {
                    Element childElement = (Element)child;
                    String localName = child.getLocalName();
                    if (localName.equals(""beanPostProcessor"")) {
                        createBeanPostProcessor(parserContext, contextId, childElement, builder);
                        createdBeanPostProcessor = true;
                    } else if (localName.equals(""endpoint"")) {
                        BeanDefinition definition = endpointParser.parse(childElement, parserContext);
                        String id = childElement.getAttribute(""id"");
                        if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                            // TODO we can zap this?
                            definition.getPropertyValues()
                                .addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
                            // definition.getPropertyValues().addPropertyValue(""context"",
                            // builder.getBeanDefinition());
                            parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                        }
                    } else {
                        BeanDefinitionParser parser = parserMap.get(localName);
                        if (parser != null) {
                            BeanDefinition definition = parser.parse(childElement, parserContext);
                            String id = childElement.getAttribute(""id"");
                            if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                                parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                                if (localName.equals(""jmxAgent"")) {
                                    builder.addPropertyReference(""camelJMXAgent"", id);
                                }
                            }
                        }
                    }
                }
            }
            // lets inject the namespaces into any namespace aware POJOs
            injectNamespaces(element);
            if (!createdBeanPostProcessor) {
                // no bean processor element so lets create it by ourself
                Element childElement = element.getOwnerDocument().createElement(""beanPostProcessor"");
                element.appendChild(childElement);
                createBeanPostProcessor(parserContext, contextId, childElement, builder);
            }
        }
    }
    protected void injectNamespaces(Element element) {
        NodeList list = element.getChildNodes();
        Namespaces namespaces = null;
        int size = list.getLength();
        for (int i = 0; i < size; i++) {
            Node child = list.item(i);
            if (child instanceof Element) {
                Element childElement = (Element)child;
                Object object = binder.getJAXBNode(child);
                if (object instanceof NamespaceAware) {
                    NamespaceAware namespaceAware = (NamespaceAware)object;
                    if (namespaces == null) {
                        namespaces = new Namespaces(element);
                    }
                    namespaces.configure(namespaceAware);
                }
                injectNamespaces(childElement);
            }
        }
    }
}
"
org.apache.camel.builder.ExpressionClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.Map;
import org.apache.camel.Expression;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.model.ExpressionNode;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.language.MethodCallExpression;
import org.apache.camel.model.language.XPathExpression;
import org.apache.camel.model.language.XQueryExpression;
/**
 * Represents an expression clause within the DSL which when the expression is complete
 * the clause continues to another part of the DSL
 *
 * @version $Revision$
 */
public class ExpressionClause<T> extends ExpressionType {
    private T result;
    private String language;
    public ExpressionClause(T result) {
        this.result = result;
    }
    public static <T extends ExpressionNode> ExpressionClause<T> createAndSetExpression(T result) {
        ExpressionClause<T> clause = new ExpressionClause<T>(result);
        result.setExpression(clause);
        return clause;
    }
    // Helper expressions
    //-------------------------------------------------------------------------
    /**
     * Specify an {@link Expression} instance
     */
    public T expression(Expression expression) {
        setExpressionValue(expression);
        return result;
    }
    /**
     * Specify the constant expression value
     */
    public T constant(Object value) {
        return expression(ExpressionBuilder.constantExpression(value));
    }
    /**
     * An expression of the exchange
     */
    public T exchange() {
        return expression(ExpressionBuilder.exchangeExpression());
    }
    /**
     * An expression of an inbound message
     */
    public T inMessage() {
        return expression(ExpressionBuilder.inMessageExpression());
    }
    /**
     * An expression of an inbound message
     */
    public T outMessage() {
        return expression(ExpressionBuilder.outMessageExpression());
    }
    /**
     * An expression of an inbound message body
     */
    public T body() {
        return expression(ExpressionBuilder.bodyExpression());
    }
    /**
     * An expression of an inbound message body converted to the expected type
     */
    public T body(Class expectedType) {
        return expression(ExpressionBuilder.bodyExpression(expectedType));
    }
    /**
     * An expression of an outbound message body
     */
    public T outBody() {
        return expression(ExpressionBuilder.outBodyExpression());
    }
    /**
     * An expression of an outbound message body converted to the expected type
     */
    public T outBody(Class expectedType) {
        return expression(ExpressionBuilder.outBodyExpression(expectedType));
    }
    /**
     * An expression of an inbound message header of the given name
     */
    public T header(String name) {
        return expression(ExpressionBuilder.headerExpression(name));
    }
    /**
     * An expression of the inbound headers
     */
    public T headers() {
        return expression(ExpressionBuilder.headersExpression());
    }
    /**
     * An expression of an outbound message header of the given name
     */
    public T outHeader(String name) {
        return expression(ExpressionBuilder.outHeaderExpression(name));
    }
    /**
     * An expression of the outbound headers
     */
    public T outHeaders() {
        return expression(ExpressionBuilder.outHeadersExpression());
    }
    /**
     * An expression of an exchange property of the given name
     */
    public T property(String name) {
        return expression(ExpressionBuilder.propertyExpression(name));
    }
    /**
     * An expression of the exchange properties
     */
    public T properties() {
        return expression(ExpressionBuilder.propertiesExpression());
    }
    // Languages
    //-------------------------------------------------------------------------
    /**
     * Evaluates an expression using the
     * <a href=""http://activemq.apache.org/camel/bean-language.html>bean language</a>
     * which basically means the bean is invoked to determine the expression value.
     *
     * @param bean the name of the bean looked up the registry
     * @return the builder to continue processing the DSL
     */
    public T method(String bean) {
        MethodCallExpression expression = new MethodCallExpression(bean);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an expression using the
     * <a href=""http://activemq.apache.org/camel/bean-language.html>bean language</a>
     * which basically means the bean is invoked to determine the expression value.
     *
     * @param bean   the name of the bean looked up the registry
     * @param method the name of the method to invoke on the bean
     * @return the builder to continue processing the DSL
     */
    public T method(String bean, String method) {
        MethodCallExpression expression = new MethodCallExpression(bean, method);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/beanshell.html"">BeanShell expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     * @deprecated use language(<tt>""beanshell""</tt>, text). Will be removed in Camel 2.0.
     */
    public T beanShell(String text) {
        return language(""beanshell"", text);
    }
    /**
     * Evaluates the  <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
     * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T el(String text) {
        return language(""el"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/groovy.html"">Groovy expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T groovy(String text) {
        return language(""groovy"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/java-script.html"">JavaScript expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T javaScript(String text) {
        return language(""js"", text);
    }
    /**
     * Evaluates a <a href=""http://commons.apache.org/jxpath/"">JXPath expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T jxpath(String text) {
        return language(""jxpath"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/ognl.html"">OGNL expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ognl(String text) {
        return language(""ognl"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/php.html"">PHP expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T php(String text) {
        return language(""php"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/python.html"">Python expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T python(String text) {
        return language(""python"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/ruby.html"">Ruby expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ruby(String text) {
        return language(""ruby"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/sql.html"">SQL expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T sql(String text) {
        return language(""sql"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/simple.html"">Simple expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T simple(String text) {
        return language(""simple"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text) {
        return language(""xpath"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expressiopn
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType) {
        XPathExpression expression = new XPathExpression(text);
        expression.setResultType(resultType);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType, Namespaces namespaces) {
        return xpath(text, resultType, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType, Map<String, String> namespaces) {
        XPathExpression expression = new XPathExpression(text);
        expression.setResultType(resultType);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Namespaces namespaces) {
        return xpath(text, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Map<String, String> namespaces) {
        XPathExpression expression = new XPathExpression(text);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text) {
        return language(""xquery"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expressiopn
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setResultType(resultType);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType, Namespaces namespaces) {
        return xquery(text, resultType, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType, Map<String, String> namespaces) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setResultType(resultType);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Namespaces namespaces) {
        return xquery(text, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Map<String, String> namespaces) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates a given language name with the expression text
     *
     * @param language   the name of the language
     * @param expression the expression in the given language
     * @return the builder to continue processing the DSL
     */
    public T language(String language, String expression) {
        setLanguage(language);
        setExpression(expression);
        return result;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getLanguage() {
        return language;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
}
"
org.apache.camel.component.file.strategy.FileProcessStrategyFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.util.Map;
import org.apache.camel.Expression;
import org.apache.camel.component.file.FileProcessStrategy;
/**
 * Factory to provide the {@link org.apache.camel.component.file.FileProcessStrategy} to use.
 */
public final class FileProcessStrategyFactory {
    private FileProcessStrategyFactory() {
        // Factory class
    }
    /**
     * A strategy method to lazily create the file strategy to use.
     */
    public static FileProcessStrategy createFileProcessStrategy(Map<String, Object> params) {
        // We assume a value is present only if its value not null for String and 'true' for boolean
        boolean isDelete = params.get(""delete"") != null;
        boolean isLock = params.get(""lock"") != null;
        String moveNamePrefix = (String) params.get(""moveNamePrefix"");
        String moveNamePostfix = (String) params.get(""moveNamePostfix"");
        String preMoveNamePrefix = (String) params.get(""preMoveNamePrefix"");
        String preMoveNamePostfix = (String) params.get(""preMoveNamePostfix"");
        Expression expression = (Expression) params.get(""expression"");
        Expression preMoveExpression = (Expression) params.get(""preMoveExpression"");
        boolean move = moveNamePrefix != null || moveNamePostfix != null;
        boolean preMove = preMoveNamePrefix != null || preMoveNamePostfix != null;
        if (params.containsKey(""noop"")) {
            return new NoOpFileProcessStrategy(isLock);
        } else if (move || preMove) {
            RenameFileProcessStrategy strategy = new RenameFileProcessStrategy(isLock);
            if (move) {
                strategy.setCommitRenamer(new DefaultFileRenamer(moveNamePrefix, moveNamePostfix));
            }
            if (preMove) {
                strategy.setBeginRenamer(new DefaultFileRenamer(preMoveNamePrefix, preMoveNamePostfix));
            }
            return strategy;
        } else if (expression != null || preMoveExpression != null) {
            RenameFileProcessStrategy strategy = new RenameFileProcessStrategy(isLock);
            if (expression != null) {
                FileExpressionRenamer renamer = new FileExpressionRenamer();
                renamer.setExpression(expression);
                strategy.setCommitRenamer(renamer);
            }
            if (preMoveExpression != null) {
                FileExpressionRenamer renamer = new FileExpressionRenamer();
                renamer.setExpression(preMoveExpression);
                strategy.setBeginRenamer(renamer);
            }
            return strategy;
        } else if (isDelete) {
            return new DeleteFileProcessStrategy(isLock);
        } else {
            // default strategy will move to .camel subfolder
            return new RenameFileProcessStrategy(isLock);
        }
    }
}
"
org.apache.camel.component.file.remote.SftpUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.SftpException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Utility methods for SFTP.
 */
public final class SftpUtils {
    private static final transient Log LOG = LogFactory.getLog(SftpUtils.class);
    private SftpUtils() {
    }
    public static boolean buildDirectory(ChannelSftp sftpClient, String dirName)
        throws IOException, SftpException {
        String originalDirectory = sftpClient.pwd();
        boolean success = false;
        try {
            // maybe the full directory already exsits
            try {
                sftpClient.cd(dirName);
                success = true;
            } catch (SftpException e) {
                // ignore, we could not change directory so try to create it instead
            }
            if (!success) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Trying to build remote directory: "" + dirName);
                }
                try {
                    sftpClient.mkdir(dirName);
                    success = true;
                } catch (SftpException e) {
                    // we are here if the server side doesn't create intermediate folders
                    // so create the folder one by one
                    success = buildDirectoryChunks(sftpClient, dirName);
                }
            }
        } finally {
            // change back to original directory
            sftpClient.cd(originalDirectory);
        }
        return success;
    }
    public static boolean buildDirectoryChunks(ChannelSftp sftpClient, String dirName)
        throws IOException, SftpException {
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        boolean success = false;
        for (String dir : dirs) {
            sb.append(dir).append('/');
            String directory = sb.toString();
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Trying to build remote directory: "" + directory);
            }
            try {
                sftpClient.mkdir(directory);
                success = true;
            } catch (SftpException e) {
                // ignore keep trying to create the rest of the path
            }
        }
        return success;
    }
}"
org.apache.camel.management.Counter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Counter"", currencyTimeLimit = 15)
public class Counter {
    protected AtomicLong numExchanges = new AtomicLong(0L);
    @ManagedOperation(description = ""Reset counters"")
    public void reset() {
        numExchanges.set(0L);
    }
    @ManagedAttribute(description = ""Total number of exchanges"")
    public long getNumExchanges() throws Exception {
        return numExchanges.get();
    }
    public long increment() {
        return numExchanges.incrementAndGet();
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import java.util.Map;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.configuration.spring.AbstractBeanDefinitionParser;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
public class CxfEndpointBeanDefinitionParser extends AbstractBeanDefinitionParser {
    @Override
    protected Class getBeanClass(Element arg0) {
        return CxfSpringEndpointBean.class;
    }
    @Override
    protected void mapAttribute(BeanDefinitionBuilder bean, Element e, String name, String val) {
        if (""endpointName"".equals(name) || ""serviceName"".equals(name)) {
            QName q = parseQName(e, val);
            bean.addPropertyValue(name, q);
        } else {
            mapToProperty(bean, name, val);
        }
    }
    @Override
    protected void mapElement(ParserContext ctx, BeanDefinitionBuilder bean, Element el, String name) {
        if (""properties"".equals(name)) {
            Map map = ctx.getDelegate().parseMapElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(""properties"", map);
        } else if (""binding"".equals(name)) {
            setFirstChildAsProperty(el, ctx, bean, ""bindingConfig"");
        } else if (""inInterceptors"".equals(name) || ""inFaultInterceptors"".equals(name)
            || ""outInterceptors"".equals(name) || ""outFaultInterceptors"".equals(name)
            || ""features"".equals(name) || ""schemaLocations"".equals(name)
            || ""handlers"".equals(name)) {
            java.util.List list = (java.util.List)ctx.getDelegate().parseListElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(name, list);
        } else {
            setFirstChildAsProperty(el, ctx, bean, name);
        }
    }
    @Override
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        super.doParse(element, ctx, bean);
        bean.setLazyInit(false);
    }
    @Override
    protected String resolveId(Element elem,
                               AbstractBeanDefinition definition,
                               ParserContext ctx)
        throws BeanDefinitionStoreException {
        String id = super.resolveId(elem, definition, ctx);
        if (StringUtils.isEmpty(id)) {
            throw new BeanDefinitionStoreException(""The bean id is needed."");
        }
        return id;
    }
    @Override
    protected boolean hasBusProperty() {
        return true;
    }
    // To make the CxfEndpointBean clear without touching any Spring relates class 
    // , we implements the ApplicationContextAware here
    public static class CxfSpringEndpointBean extends CxfEndpointBean implements ApplicationContextAware {
        public CxfSpringEndpointBean() {
            super();
        }
        public CxfSpringEndpointBean(ReflectionServiceFactoryBean factory) {
            super(factory);
        }
        public void setApplicationContext(ApplicationContext ctx) throws BeansException {
            if (getBus() == null) {
                Bus bus = BusFactory.getDefaultBus();                
                setBus(bus);
            }
            BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(getBus(), ctx);
        }
    }
}
"
org.apache.camel.component.jms.JmsQueueEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.Collections;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
/**
 * An endpoint for a JMS Queue which is also browsable
 *
 * @version $Revision$
 */
public class JmsQueueEndpoint extends JmsEndpoint implements BrowsableEndpoint<JmsExchange> {
    private static final transient Log LOG = LogFactory.getLog(JmsQueueEndpoint.class);
    private int maximumBrowseSize = -1;
    private final QueueBrowseStrategy queueBrowseStrategy;
    public JmsQueueEndpoint(String uri, JmsComponent component, String destination,
            JmsConfiguration configuration) {
        this(uri, component, destination, configuration, null);
    }
    public JmsQueueEndpoint(String uri, JmsComponent component, String destination,
            JmsConfiguration configuration, QueueBrowseStrategy queueBrowseStrategy) {
        super(uri, component, destination, false, configuration);
        if (queueBrowseStrategy == null) {
            this.queueBrowseStrategy = createQueueBrowseStrategy();
        } else {
            this.queueBrowseStrategy = queueBrowseStrategy;
        }
    }
    public JmsQueueEndpoint(String endpointUri, String destination, QueueBrowseStrategy queueBrowseStrategy) {
        super(endpointUri, destination, false);
        if (queueBrowseStrategy == null) {
            this.queueBrowseStrategy = createQueueBrowseStrategy();
        } else {
            this.queueBrowseStrategy = queueBrowseStrategy;
        }
    }
    public JmsQueueEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination, false);
        queueBrowseStrategy = createQueueBrowseStrategy();
    }
    public int getMaximumBrowseSize() {
        return maximumBrowseSize;
    }
    /**
     * If a number is set > 0 then this limits the number of messages that are
     * returned when browsing the queue
     */
    public void setMaximumBrowseSize(int maximumBrowseSize) {
        this.maximumBrowseSize = maximumBrowseSize;
    }
    public List<Exchange> getExchanges() {
        if (queueBrowseStrategy == null) {
            return Collections.EMPTY_LIST;
        }
        String queue = getDestination();
        JmsOperations template = getConfiguration().createInOnlyTemplate(this, false, queue);
        return queueBrowseStrategy.browse(template, queue, this);
    }
    protected static QueueBrowseStrategy createQueueBrowseStrategy() {
        QueueBrowseStrategy answer = null;
        try {
            answer = JmsComponent.tryCreateDefaultQueueBrowseStrategy();
        } catch (Throwable e) {
            LOG.debug(""Caught exception trying to create default QueueBrowseStrategy. ""
                      + ""This could be due to spring 2.0.x on classpath? Cause: "" + e, e);
        }
        if (answer == null) {
            LOG.warn(""Cannot browse queues as no QueueBrowseStrategy specified. Are you using Spring 2.0.x by any chance? If you upgrade to 2.5.x or later then queue browsing is supported"");
        }
        return answer;
    }
}
"
org.apache.camel.component.irc.IrcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventListener;
public class IrcProducer extends DefaultProducer<IrcExchange> {
    public static final String[] COMMANDS = new String[] {""AWAY"", ""INVITE"", ""ISON"", ""JOIN"", ""KICK"", ""LIST"", ""NAMES"", ""PRIVMSG"", ""MODE"", ""NICK"", ""NOTICE"", ""PART"", ""PONG"", ""QUIT"", ""TOPIC"", ""WHO"",
                                                          ""WHOIS"", ""WHOWAS"", ""USERHOST""};
    private static final transient Log LOG = LogFactory.getLog(IrcProducer.class);
    private IRCConnection connection;
    private IrcEndpoint endpoint;
    private IRCEventListener ircErrorLogger;
    public IrcProducer(IrcEndpoint endpoint, IRCConnection connection) {
        super(endpoint);
        this.endpoint = endpoint;
        this.connection = connection;
    }
    public void process(Exchange exchange) throws Exception {
        try {
            final String msg = exchange.getIn().getBody(String.class);
            if (isMessageACommand(msg)) {
                connection.send(msg);
            } else {
                final String target = endpoint.getConfiguration().getTarget();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""sending to: "" + target + "" message: "" + msg);
                }
                connection.doPrivmsg(target, msg);
            }
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ircErrorLogger = createIrcErrorLogger();
        connection.addIRCEventListener(ircErrorLogger);
        final String target = endpoint.getConfiguration().getTarget();
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (connection != null) {
            connection.removeIRCEventListener(ircErrorLogger);
        }
    }
    protected boolean isMessageACommand(String msg) {
        for (String command : COMMANDS) {
            if (msg.startsWith(command)) {
                return true;
            }
        }
        return false;
    }
    protected IRCEventListener createIrcErrorLogger() {
        return new IrcErrorLogger(LOG);
    }
}
"
org.apache.camel.component.jms.JmsComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.Map;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.Session;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelException;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.connection.JmsTransactionManager;
import org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Component</a>
 *
 * @version $Revision:520964 $
 */
public class JmsComponent extends DefaultComponent<JmsExchange> implements ApplicationContextAware,
    HeaderFilterStrategyAware {
    private static final transient Log LOG = LogFactory.getLog(JmsComponent.class);
    private static final String DEFAULT_QUEUE_BROWSE_STRATEGY = ""org.apache.camel.component.jms.DefaultQueueBrowseStrategy"";
    private JmsConfiguration configuration;
    private ApplicationContext applicationContext;
    private Requestor requestor;
    private QueueBrowseStrategy queueBrowseStrategy;
    private boolean attemptedToCreateQueueBrowserStrategy;
    private HeaderFilterStrategy headerFilterStrategy;
    public JmsComponent() {
        setHeaderFilterStrategy(new JmsHeaderFilterStrategy());
    }
    public JmsComponent(JmsConfiguration configuration) {
        this.configuration = configuration;
        setHeaderFilterStrategy(new JmsHeaderFilterStrategy());
    }
    public JmsComponent(CamelContext context) {
        super(context);
        setHeaderFilterStrategy(new JmsHeaderFilterStrategy());
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent() {
        return new JmsComponent();
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(JmsConfiguration configuration) {
        return new JmsComponent(configuration);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(ConnectionFactory connectionFactory) {
        return jmsComponent(new JmsConfiguration(connectionFactory));
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentClientAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.CLIENT_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentAutoAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory) {
        JmsTransactionManager transactionManager = new JmsTransactionManager();
        transactionManager.setConnectionFactory(connectionFactory);
        return jmsComponentTransacted(connectionFactory, transactionManager);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory,
                                                      PlatformTransactionManager transactionManager) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setTransactionManager(transactionManager);
        template.setTransacted(true);
        template.setTransactedInOut(true);
        return jmsComponent(template);
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsConfiguration getConfiguration() {
        if (configuration == null) {
            configuration = createConfiguration();
            // If we are being configured with spring...
            if (applicationContext != null) {
                Map beansOfType = applicationContext.getBeansOfType(ConnectionFactory.class);
                if (!beansOfType.isEmpty()) {
                    ConnectionFactory cf = (ConnectionFactory)beansOfType.values().iterator().next();
                    configuration.setConnectionFactory(cf);
                }
                beansOfType = applicationContext.getBeansOfType(DestinationResolver.class);
                if (!beansOfType.isEmpty()) {
                    DestinationResolver destinationResolver = (DestinationResolver)beansOfType.values()
                        .iterator().next();
                    configuration.setDestinationResolver(destinationResolver);
                }
            }
        }
        return configuration;
    }
    /**
     * Sets the JMS configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        getConfiguration().setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementMode(consumerAcknowledgementMode);
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementModeName(consumerAcknowledgementMode);
    }
    public void setAutoStartup(boolean autoStartup) {
        getConfiguration().setAutoStartup(autoStartup);
    }
    public void setCacheLevel(int cacheLevel) {
        getConfiguration().setCacheLevel(cacheLevel);
    }
    public void setCacheLevelName(String cacheName) {
        getConfiguration().setCacheLevelName(cacheName);
    }
    public void setClientId(String consumerClientId) {
        getConfiguration().setClientId(consumerClientId);
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        getConfiguration().setConcurrentConsumers(concurrentConsumers);
    }
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        getConfiguration().setConnectionFactory(connectionFactory);
    }
    public void setConsumerType(ConsumerType consumerType) {
        getConfiguration().setConsumerType(consumerType);
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        getConfiguration().setDeliveryPersistent(deliveryPersistent);
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        getConfiguration().setDurableSubscriptionName(durableSubscriptionName);
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        getConfiguration().setExceptionListener(exceptionListener);
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        getConfiguration().setExplicitQosEnabled(explicitQosEnabled);
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        getConfiguration().setExposeListenerSession(exposeListenerSession);
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        getConfiguration().setIdleTaskExecutionLimit(idleTaskExecutionLimit);
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        getConfiguration().setMaxConcurrentConsumers(maxConcurrentConsumers);
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        getConfiguration().setMaxMessagesPerTask(maxMessagesPerTask);
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        getConfiguration().setMessageConverter(messageConverter);
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        getConfiguration().setMessageIdEnabled(messageIdEnabled);
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        getConfiguration().setMessageTimestampEnabled(messageTimestampEnabled);
    }
    public void setAlwaysCopyMessage(boolean alwaysCopyMessage) {
        getConfiguration().setAlwaysCopyMessage(alwaysCopyMessage);
    }
    public void setUseMessageIDAsCorrelationID(boolean useMessageIDAsCorrelationID) {
        getConfiguration().setUseMessageIDAsCorrelationID(useMessageIDAsCorrelationID);
    }
    public void setPriority(int priority) {
        getConfiguration().setPriority(priority);
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        getConfiguration().setPubSubNoLocal(pubSubNoLocal);
    }
    public void setReceiveTimeout(long receiveTimeout) {
        getConfiguration().setReceiveTimeout(receiveTimeout);
    }
    public void setRecoveryInterval(long recoveryInterval) {
        getConfiguration().setRecoveryInterval(recoveryInterval);
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        getConfiguration().setServerSessionFactory(serverSessionFactory);
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        getConfiguration().setSubscriptionDurable(subscriptionDurable);
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        getConfiguration().setTaskExecutor(taskExecutor);
    }
    public void setTimeToLive(long timeToLive) {
        getConfiguration().setTimeToLive(timeToLive);
    }
    public void setTransacted(boolean consumerTransacted) {
        getConfiguration().setTransacted(consumerTransacted);
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        getConfiguration().setTransactionManager(transactionManager);
    }
    public void setTransactionName(String transactionName) {
        getConfiguration().setTransactionName(transactionName);
    }
    public void setTransactionTimeout(int transactionTimeout) {
        getConfiguration().setTransactionTimeout(transactionTimeout);
    }
    public void setUseVersion102(boolean useVersion102) {
        getConfiguration().setUseVersion102(useVersion102);
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        getConfiguration().setJmsOperations(jmsOperations);
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        getConfiguration().setDestinationResolver(destinationResolver);
    }
    public synchronized Requestor getRequestor() throws Exception {
        if (requestor == null) {
            requestor = new Requestor(getConfiguration(), getExecutorService());
            requestor.start();
        }
        return requestor;
    }
    public void setRequestor(Requestor requestor) {
        this.requestor = requestor;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public QueueBrowseStrategy getQueueBrowseStrategy() {
        if (queueBrowseStrategy == null) {
            if (!attemptedToCreateQueueBrowserStrategy) {
                attemptedToCreateQueueBrowserStrategy = true;
                try {
                    queueBrowseStrategy = tryCreateDefaultQueueBrowseStrategy();
                } catch (Throwable e) {
                    LOG.warn(""Could not instantiate the QueueBrowseStrategy are you using Spring 2.0.x""
                        + "" by any chance? Error: "" + e, e);
                }
            }
        }
        return queueBrowseStrategy;
    }
    public void setQueueBrowseStrategy(QueueBrowseStrategy queueBrowseStrategy) {
        this.queueBrowseStrategy = queueBrowseStrategy;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    @Override
    protected void doStop() throws Exception {
        if (requestor != null) {
            requestor.stop();
        }
        super.doStop();
    }
    @Override
    protected Endpoint<JmsExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        boolean pubSubDomain = false;
        boolean tempDestination = false;
        if (remaining.startsWith(JmsConfiguration.QUEUE_PREFIX)) {
            pubSubDomain = false;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.QUEUE_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TOPIC_PREFIX)) {
            pubSubDomain = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TOPIC_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TEMP_QUEUE_PREFIX)) {
            pubSubDomain = false;
            tempDestination = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TEMP_QUEUE_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TEMP_TOPIC_PREFIX)) {
            pubSubDomain = true;
            tempDestination = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TEMP_TOPIC_PREFIX.length()), '/');
        }
        final String subject = convertPathToActualDestination(remaining, parameters);
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        JmsConfiguration newConfiguration = getConfiguration().copy();        
        JmsEndpoint endpoint;
        if (pubSubDomain) {
            if (tempDestination) {
                endpoint = new JmsTemporaryTopicEndpoint(uri, this, subject, newConfiguration);
            } else {
                endpoint = new JmsEndpoint(uri, this, subject, pubSubDomain, newConfiguration);
            }
        } else {
            QueueBrowseStrategy strategy = getQueueBrowseStrategy();
            if (tempDestination) {
                endpoint = new JmsTemporaryQueueEndpoint(uri, this, subject, newConfiguration, strategy);
            } else {
                endpoint = new JmsQueueEndpoint(uri, this, subject, newConfiguration, strategy);
            }
        }
        String selector = getAndRemoveParameter(parameters, ""selector"", String.class);
        if (selector != null) {
            endpoint.setSelector(selector);
        }
        String username = getAndRemoveParameter(parameters, ""username"", String.class);
        String password = getAndRemoveParameter(parameters, ""password"", String.class);
        if (username != null && password != null) {
            ConnectionFactory cf = endpoint.getConfiguration().getConnectionFactory();
            UserCredentialsConnectionFactoryAdapter ucfa = new UserCredentialsConnectionFactoryAdapter();
            ucfa.setTargetConnectionFactory(cf);
            ucfa.setPassword(password);
            ucfa.setUsername(username);
            endpoint.getConfiguration().setConnectionFactory(ucfa);
        } else {
            if (username != null || password != null) {
                // exclude the the saturation of username and password are all empty
                throw new IllegalArgumentException(""The JmsComponent's username or password is null"");
            }
        }
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the
     * actual JMS destination name (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path, Map parameters) {
        return path;
    }
    /**
     * Factory method to create the default configuration instance
     *
     * @return a newly created configuration object which can then be further
     *         customized
     */
    protected JmsConfiguration createConfiguration() {
        return new JmsConfiguration();
    }
    /**
     * Attempts to instantiate the default {@link QueueBrowseStrategy} which
     * should work fine if Spring 2.5.x or later is on the classpath but this
     * will fail if 2.0.x are on the classpath. We can continue to operate on
     * this version we just cannot support the browseable queues supported by
     * {@link JmsQueueEndpoint}
     *
     * @return the queue browse strategy or null if it cannot be supported
     */
    protected static QueueBrowseStrategy tryCreateDefaultQueueBrowseStrategy() {
        // lets try instantiate the default implementation
        Class<?> type = ObjectHelper.loadClass(DEFAULT_QUEUE_BROWSE_STRATEGY);
        if (type == null) {
            LOG.warn(""Could not load class: "" + DEFAULT_QUEUE_BROWSE_STRATEGY
                     + "" maybe you are on Spring 2.0.x?"");
            return null;
        } else {
            return (QueueBrowseStrategy)ObjectHelper.newInstance(type);
        }
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        this.headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.component.restlet.MethodBasedRouter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.restlet.Restlet;
import org.restlet.data.Method;
import org.restlet.data.Request;
import org.restlet.data.Response;
import org.restlet.data.Status;
/**
 * A simple router that routes requests to target Restlets based on method. 
 * 
 * @version $Revision$
 */
class MethodBasedRouter extends Restlet {
    private static final Log LOG = LogFactory.getLog(MethodBasedRouter.class);
    private String uriPattern;
    private Map<Method, Restlet> routes = new ConcurrentHashMap<Method, Restlet>();
    private AtomicBoolean hasBeenAttachedFlag = new AtomicBoolean(false);
    MethodBasedRouter(String uriPattern) {
        this.uriPattern = uriPattern;
    }
    @Override
    public void handle(Request request, Response response) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""MethodRouter ("" + uriPattern + "") received request method: "" 
                    + request.getMethod());
        }
        Restlet target = routes.get(request.getMethod());
        if (target != null) {
            target.handle(request, response);
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""No route for request method: "" + request.getMethod());
            }
            response.setStatus(Status.CLIENT_ERROR_NOT_FOUND);
        }
    }
    void addRoute(Method method, Restlet target) {
        routes.put(method, target);
    }
    void removeRoute(Method method) {
        routes.remove(method);
    }
    /**
     * This method does ""test-and-set"" on the underlying flag that indicates
     * whether this router restlet has been attached to a server or not.  It 
     * is the caller's responsibility to perform the ""attach"" when this method 
     * returns false. 
     * 
     * @return true only this method is called the first time.
     */
    boolean hasBeenAttached() {
        return hasBeenAttachedFlag.getAndSet(true);
    }
}
"
org.apache.camel.component.ibatis.IBatisComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.SqlMapClientBuilder;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Component</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision$
 */
public class IBatisComponent extends DefaultComponent {
    public static final String DEFAULT_CONFIG_URI = ""SqlMapConfig.xml"";
    private static final transient Log LOG = LogFactory.getLog(IBatisComponent.class);
    private SqlMapClient sqlMapClient;
    private Resource sqlMapResource;
    public IBatisComponent() {
    }
    public IBatisComponent(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    // Properties
    //-------------------------------------------------------------------------
    public SqlMapClient getSqlMapClient() throws IOException {
        if (sqlMapClient == null) {
            sqlMapClient = createSqlMapClient();
        }
        return sqlMapClient;
    }
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    public Resource getSqlMapResource() {
        if (sqlMapResource == null) {
            sqlMapResource = new ClassPathResource(DEFAULT_CONFIG_URI);
            LOG.debug(""Defaulting to use the iBatis configuration from: "" + sqlMapResource);
        }
        return sqlMapResource;
    }
    public void setSqlMapResource(Resource sqlMapResource) {
        this.sqlMapResource = sqlMapResource;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new IBatisEndpoint(uri, this, remaining);
    }
    protected SqlMapClient createSqlMapClient() throws IOException {
        InputStream in = getSqlMapResource().getInputStream();
        return SqlMapClientBuilder.buildSqlMapClient(in);
    }
}
"
org.apache.camel.spring.spi.ApplicationContextRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Registry;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.ApplicationContext;
/**
 * A {@link Registry} implementation which looks up the objects in the Spring
 * {@link ApplicationContext}
 * 
 * @version $Revision$
 */
public class ApplicationContextRegistry implements Registry {
    private ApplicationContext applicationContext;
    public ApplicationContextRegistry(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T lookup(String name, Class<T> type) {
        try {
            Object value = applicationContext.getBean(name, type);
            return type.cast(value);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
    public Object lookup(String name) {
        try {
            return applicationContext.getBean(name);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
}
"
org.apache.camel.converter.stream.StreamCacheConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.stream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import javax.xml.transform.TransformerException;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.jaxp.BytesSource;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A set of {@link Converter} methods for wrapping stream-based messages in a {@link StreamCache}
 * implementation to ensure message re-readability (eg multicasting, retrying)
 */
@Converter
public class StreamCacheConverter {
    private static final transient Log LOG = LogFactory.getLog(StreamCacheConverter.class);
    private XmlConverter converter = new XmlConverter();
    @Converter
    public StreamCache convertToStreamCache(StreamSource source) throws TransformerException {
        return new SourceCache(converter.toString(source));
    }
    @Converter
    public StreamCache convertToStreamCache(StringSource source) throws TransformerException {
        //no need to do stream caching for a StringSource
        return null;
    }
    @Converter
    public StreamCache convertToStreamCache(BytesSource source) throws TransformerException {
        //no need to do stream caching for a BytesSource
        return null;
    }
    @Converter
    public StreamCache convertToStreamCache(SAXSource source) throws TransformerException {
        return new SourceCache(converter.toString(source));
    }
    @Converter
    public StreamCache convertToStreamCache(InputStream stream) throws IOException {
        return new InputStreamCache(IOConverter.toBytes(stream));
    }
    @Converter
    public StreamCache convertToStreamCache(Reader reader) throws IOException {
        return new ReaderCache(IOConverter.toString(reader));
    }
    /*
     * {@link StreamCache} implementation for {@link Source}s
     */
    private class SourceCache extends StringSource implements StreamCache {
        private static final long serialVersionUID = 4147248494104812945L;
        public SourceCache() {
        }
        public SourceCache(String text) {
            super(text);
        }
        public void reset() {
            // do nothing here
        }
    }
    private class InputStreamCache extends ByteArrayInputStream implements StreamCache {
        public InputStreamCache(byte[] data) {
            super(data);
        }
    }
    private class ReaderCache extends StringReader implements StreamCache {
        public ReaderCache(String s) {
            super(s);
        }
        public void reset() {
            try {
                super.reset();
            } catch (IOException e) {
                LOG.warn(""Exception is thrown when resets the ReaderCache"", e);
            }
        }
        public void close() {
            // Do not release the string for caching
        }
    }
}
"
org.apache.camel.component.file.remote.RemoteFileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.component.file.FileComponent;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.language.simple.FileLanguage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public abstract class RemoteFileProducer<T extends RemoteFileExchange> extends DefaultProducer<T> {
    protected final transient Log log = LogFactory.getLog(getClass());
    protected RemoteFileEndpoint<T> endpoint;
    protected RemoteFileProducer(RemoteFileEndpoint<T> endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    protected String createFileName(Message message, RemoteFileConfiguration fileConfig) {
        String answer;
        String name = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        // expression support
        Expression expression = endpoint.getConfiguration().getExpression();
        if (name != null) {
            // the header name can be an expression too, that should override whatever configured on the endpoint
            if (name.indexOf(""${"") > -1) {
                if (log.isDebugEnabled()) {
                    log.debug(FileComponent.HEADER_FILE_NAME + "" contains a FileLanguage expression: "" + name);
                }
                expression = FileLanguage.file(name);
            }
        }
        if (expression != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Filename evaluated as expression: "" + expression);
            }
            Object result = expression.evaluate(message.getExchange());
            name = message.getExchange().getContext().getTypeConverter().convertTo(String.class, result);
        }        
        String endpointFile = fileConfig.getFile();
        if (fileConfig.isDirectory()) {
            // If the path isn't empty, we need to add a trailing / if it isn't already there
            String baseDir = """";
            if (endpointFile.length() > 0) {
                baseDir = endpointFile + (endpointFile.endsWith(""/"") ? """" : ""/"");
            }
            String fileName = (name != null) ? name : endpoint.getGeneratedFileName(message); 
            answer = baseDir + fileName;
        } else {
            answer = endpointFile;
        }
        // lets store the name we really used in the header, so end-users can retrieve it
        message.setHeader(FileComponent.HEADER_FILE_NAME_PRODUCED, answer);
        return answer;
    }
    protected String remoteServer() {
        return endpoint.getConfiguration().remoteServerInformation();
    }
    @Override
    protected void doStart() throws Exception {
        log.info(""Starting"");
        // do not connect when component starts, just wait until we process as we will
        // connect at that time if needed
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        log.info(""Stopping"");
        // disconnect when stopping
        try {
            disconnect();
        } catch (Exception e) {
            // ignore just log a warning
            log.warn(""Exception occured during disconecting from "" + remoteServer() + "". ""
                     + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
        }
        super.doStop();
    }
    protected abstract void connectIfNecessary() throws Exception;
    protected abstract void disconnect() throws Exception;
}
"
org.apache.camel.component.bean.AmbiguousMethodCallException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Collection;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if an attempted method invocation resulted in an ambiguous method
 * such that multiple methods match the inbound message exchange
 *
 * @version $Revision$
 */
public class AmbiguousMethodCallException extends CamelExchangeException {
    private final Collection<MethodInfo> methods;
    public AmbiguousMethodCallException(Exchange exchange, Collection<MethodInfo> methods) {
        super(""Ambiguous method invocations possible: "" + methods, exchange);
        this.methods = methods;
    }
    /**
     * The ambiguous methods for which a single method could not be chosen
     */
    public Collection<MethodInfo> getMethods() {
        return methods;
    }
}
"
org.apache.camel.impl.DefaultConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
/**
 * A default consumer useful for implementation inheritance.
 *
 * @version $Revision$
 */
public class DefaultConsumer<E extends Exchange> extends ServiceSupport implements Consumer<E> {
    private Endpoint<E> endpoint;
    private Processor processor;
    private AsyncProcessor asyncProcessor;
    private ExceptionHandler exceptionHandler;
    public DefaultConsumer(Endpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Consumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * Provides an {@link AsyncProcessor} interface to the configured
     * processor on the consumer.  If the processor does not implement
     * the interface, it will be adapted so that it does.  
     */
    public AsyncProcessor getAsyncProcessor() {
        if (asyncProcessor == null) {
            asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
        }
        return asyncProcessor;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        Throwable newt = (t == null) ? new Throwable(""Handling [null] exception"") : t;
        getExceptionHandler().handleException(newt);
    }
}
"
org.apache.camel.component.xmpp.XmppComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * @version $Revision:520964 $
 */
public class XmppComponent extends DefaultComponent<XmppExchange> implements HeaderFilterStrategyAware {
    private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy();
    public XmppComponent() {
    }
    public XmppComponent(CamelContext context) {
        super(context);
    }
    /**
     * Static builder method
     */
    public static XmppComponent xmppComponent() {
        return new XmppComponent();
    }
    @Override
    protected Endpoint<XmppExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        XmppEndpoint endpoint = new XmppEndpoint(uri, this);
        URI u = new URI(uri);
        endpoint.setHost(u.getHost());
        endpoint.setPort(u.getPort());
        if (u.getUserInfo() != null) {
            endpoint.setUser(u.getUserInfo());
        }
        String remainingPath = u.getPath();
        if (remainingPath != null) {
            if (remainingPath.startsWith(""/"")) {
                remainingPath = remainingPath.substring(1);
            }
            // assume its a participant
            if (remainingPath.length() > 0) {
                endpoint.setParticipant(remainingPath);
            }
        }
        return endpoint;
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.component.bean.BeanComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An alternative to the <a href=""http://activemq.apache.org/pojo.html"">POJO Component</a>
 * which implements the <a href=""http://activemq.apache.org/bean.html"">Bean Component</a>
 * which will look up the URI in the Spring ApplicationContext and use that to handle message dispatching.
 *
 * @version $Revision$
 */
public class BeanComponent extends DefaultComponent {
    private static final transient Log LOG = LogFactory.getLog(BeanComponent.class);
    private ParameterMappingStrategy parameterMappingStrategy;
    public BeanComponent() {
    }
    /**
     * A helper method to create a new endpoint from a bean with a generated URI
     */
    public ProcessorEndpoint createEndpoint(Object bean) {
        String uri = ""bean:generated:"" + bean;
        return createEndpoint(bean, uri);
    }
    /**
     * A helper method to create a new endpoint from a bean with a given URI
     */
    public ProcessorEndpoint createEndpoint(Object bean, String uri) {
        BeanProcessor processor = new BeanProcessor(bean, getCamelContext(), getParameterMappingStrategy());
        return createEndpoint(uri, processor);
    }
    public ParameterMappingStrategy getParameterMappingStrategy() {
        if (parameterMappingStrategy == null) {
            parameterMappingStrategy = createParameterMappingStrategy();
        }
        return parameterMappingStrategy;
    }
    public void setParameterMappingStrategy(ParameterMappingStrategy parameterMappingStrategy) {
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    // Implementation methods
    //-----------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        BeanEndpoint endpoint = new BeanEndpoint(uri, this);
        endpoint.setBeanName(remaining);
        endpoint.setCache(ObjectConverter.toBool(parameters.remove(""cache"")));
        Processor processor = endpoint.getProcessor();
        setProperties(processor, parameters);
        return endpoint;
    }
    protected BeanEndpoint createEndpoint(String uri, BeanProcessor processor) {
        return new BeanEndpoint(uri, this, processor);
    }
    protected ParameterMappingStrategy createParameterMappingStrategy() {
        return BeanInfo.createParameterMappingStrategy(getCamelContext());
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.springframework.integration.core.MessageHeaders;
/**
 * The Message {@link DefaultMessage} implementation
 * for accessing the SpringIntegrationMessage
 *
 * @version $Revision$
 */
public class SpringIntegrationMessage extends DefaultMessage {
    private org.springframework.integration.core.Message siMessage;
    public SpringIntegrationMessage(org.springframework.integration.core.Message message) {
        siMessage = message;
    }
    public SpringIntegrationMessage() {
    }
    public void setMessage(org.springframework.integration.core.Message message) {
        siMessage = message;
    }
    public org.springframework.integration.core.Message getMessage() {
        return siMessage;
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
        if (that instanceof SpringIntegrationMessage) {
            SpringIntegrationMessage orig = (SpringIntegrationMessage) that;
            setMessage(orig.getMessage());
        }
    }
    @Override
    public String toString() {
        if (siMessage != null) {
            return ""SpringIntegrationMessage: "" + siMessage;
        } else {
            return ""SpringIntegrationMessage: "" + getBody();
        }
    }
    @Override
    public SpringIntegrationExchange getExchange() {
        return (SpringIntegrationExchange)super.getExchange();
    }
    public Object getHeader(String name) {
        if (siMessage != null) {
            return siMessage.getHeaders().get(name);
        } else {
            return super.getHeader(name);
        }
    }
    @Override
    public Map<String, Object> getHeaders() {
        if (siMessage != null) {
            return siMessage.getHeaders();
        } else {
            return super.getHeaders();
        }
    }
    @Override
    public SpringIntegrationMessage newInstance() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Object createBody() {
        return siMessage.getPayload();
    }
}
"
org.apache.camel.converter.jaxb.IntegerHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""intHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class IntegerHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Integer number;
    public IntegerHeader() {
    }
    public IntegerHeader(String name, Integer number) {
        super(name);
        this.number = number;
    }
    public Integer getNumber() {
        return number;
    }
    public void setNumber(Integer number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number) value;
            setNumber(n.intValue());
        } else {
            throw new IllegalArgumentException(""Value must be an Integer"");
        }
    }
}"
org.apache.camel.component.cxf.transport.CamelTransportConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
/**
 * @version $Revision$
 */
public final class CamelTransportConstants {
    public static final String TEXT_MESSAGE_TYPE = ""text"";
    public static final String BINARY_MESSAGE_TYPE = ""binary"";
    public static final String CAMEL_TARGET_ENDPOINT_URI = ""org.apache.cxf.camel.target.endpoint.uri"";
    public static final String CAMEL_SERVER_REQUEST_HEADERS = ""org.apache.cxf.camel.server.request.headers"";
    public static final String CAMEL_SERVER_RESPONSE_HEADERS = ""org.apache.cxf.camel.server.response.headers"";
    public static final String CAMEL_REQUEST_MESSAGE = ""org.apache.cxf.camel.request.message"";
    public static final String CAMEL_RESPONSE_MESSAGE = ""org.apache.cxf.camel.reponse.message"";
    public static final String CAMEL_CLIENT_REQUEST_HEADERS = ""org.apache.cxf.camel.template.request.headers"";
    public static final String CAMEL_CLIENT_RESPONSE_HEADERS =
            ""org.apache.cxf.camel.template.response.headers"";
    public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = ""org.apache.cxf.camel.template.timeout"";
    public static final String CAMEL_SERVER_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-server"";
    public static final String CAMEL_CLIENT_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-template"";
    public static final String ENDPOINT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/endpoint-config"";
    public static final String SERVICE_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/service-config"";
    public static final String PORT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/port-config"";
    public static final String CAMEL_CLIENT_CONFIG_ID = ""camel-template"";
    public static final String CAMEL_SERVER_CONFIG_ID = ""camel-server"";
    public static final String CAMEL_REBASED_REPLY_TO = ""org.apache.cxf.camel.server.replyto"";
    public static final String CAMEL_CORRELATION_ID = ""org.apache.cxf.camel.correlationId"";
    public static final String CONTENT_TYPE = ""content.type"";
    private CamelTransportConstants() {
        // Utility class
    }
}
"
org.apache.camel.language.constant.ConstantLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.constant;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.spi.Language;
/**
 * A language for constant expressions.
 */
public class ConstantLanguage implements Language {
    public static Expression<Exchange> constant(Object value) {        
        return ExpressionBuilder.constantExpression(value);
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        return ConstantLanguage.constant(expression);
    }
}
"
org.apache.camel.component.xmpp.XmppConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.Chat;
import org.jivesoftware.smack.MessageListener;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.SmackConfiguration;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smackx.muc.DiscussionHistory;
import org.jivesoftware.smackx.muc.MultiUserChat;
/**
 * A {@link org.apache.camel.Consumer Consumer} which listens to XMPP packets
 *
 * @version $Revision$
 */
public class XmppConsumer extends DefaultConsumer<XmppExchange> implements PacketListener, MessageListener {
    private static final transient Log LOG = LogFactory.getLog(XmppConsumer.class);
    private final XmppEndpoint endpoint;
    private Chat privateChat;
    private MultiUserChat muc;
    public XmppConsumer(XmppEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        if (endpoint.getRoom() == null) {
            privateChat = endpoint.getConnection().getChatManager().createChat(endpoint.getParticipant(), this);
            LOG.info(""Open chat to "" + privateChat.getParticipant());
        } else {
            muc = new MultiUserChat(endpoint.getConnection(), endpoint.resolveRoom());
            muc.addMessageListener(this);
            DiscussionHistory history = new DiscussionHistory();
            history.setMaxChars(0); // we do not want any historical messages
            muc.join(endpoint.getNickname(), null, history, SmackConfiguration.getPacketReplyTimeout());
            LOG.info(""Joined room: "" + muc.getRoom());
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (muc != null) {
            muc.leave();
            muc = null;
        }
    }
    public void processPacket(Packet packet) {
        Message message = (Message)packet;
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Recieved XMPP message: "" + message.getBody());
        }
        XmppExchange exchange = endpoint.createExchange(message);
        try {
            getProcessor().process(exchange);
        } catch (Exception e) {
            LOG.error(""Error while processing message"", e);
        }
    }
    public void processMessage(Chat chat, Message message) {
        processPacket(message);
    }
}
"
org.apache.camel.CamelTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultProducerTemplate;
/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link Message} instances in an
 * {@link Exchange} to an {@link Endpoint}.
 *
 * @version $Revision$
 * @deprecated use {@link ProducerTemplate} instead, can be created using {@link org.apache.camel.CamelContext#createProducerTemplate()}. Will be removed in Camel 2.0
 */
@Deprecated
public class CamelTemplate<E extends Exchange> extends DefaultProducerTemplate<E> {
    public CamelTemplate(CamelContext context) {
        super(context);
    }
    public CamelTemplate(CamelContext context, Endpoint defaultEndpoint) {
        super(context, defaultEndpoint);
    }
}
"
org.apache.camel.component.validator.jing.RelaxNGCompactSyntaxComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.util.Map;
/**
 * A component for validating the XML payload using
 * <a href=""http://www.oasis-open.org/committees/relax-ng/compact-20021121.html"">RelaxNG Compact Syntax</a> using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision$
 */
public class RelaxNGCompactSyntaxComponent extends JingComponent {
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        validator.setCompactSyntax(true);
        super.configureValidator(validator, uri, remaining, parameters);
    }
}
"
org.apache.camel.builder.xml.StringResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringWriter;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a String
 *
 * @version $Revision$
 */
public class StringResultHandler implements ResultHandler {
    StringWriter buffer = new StringWriter();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toString());
    }
}
"
org.apache.camel.component.jhc.JhcConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import org.apache.camel.Converter;
import org.apache.http.HttpEntity;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.util.EntityUtils;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 10, 2007
 * Time: 8:26:44 AM
 * To change this template use File | Settings | File Templates.
 */
@Converter
public final class JhcConverter {
    private JhcConverter() {
    }
    @Converter
    public static InputStream toInputStream(HttpEntity entity) throws IOException {
        return entity.getContent();
    }
    @Converter
    public static byte[] toByteArray(HttpEntity entity) throws IOException {
        return EntityUtils.toByteArray(entity);
    }
    @Converter
    public static String toString(HttpEntity entity) throws IOException {
        return EntityUtils.toString(entity);
    }
    @Converter
    public static HttpEntity toEntity(InputStream is) {
        return new InputStreamEntity(is, -1);
    }
    @Converter
    public static HttpEntity toEntity(String str) throws UnsupportedEncodingException {
        return new StringEntity(str);
    }
}
"
org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.commons.io.IOUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class RawMessageContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public RawMessageContentRedirectInterceptor() {
        super(Phase.WRITE);
    }
    public void handleMessage(Message message) throws Fault {
        // check the fault from the message
        Throwable ex = message.getContent(Throwable.class);
        if (ex != null) {
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                throw new Fault(ex);
            }
        }
        InputStream is = message.getContent(InputStream.class);
        OutputStream os = message.getContent(OutputStream.class);
        try {
            IOUtils.copy(is, os);
            is.close();
            os.flush();
        } catch (Exception e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.converter.IOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URL;
import javax.xml.transform.TransformerException;
import javax.xml.transform.dom.DOMSource;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some core java.io based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class IOConverter {
    private static final transient Log LOG = LogFactory.getLog(IOConverter.class);
    private static XmlConverter xmlConverter;
    /**
     * Utility classes should not have a public constructor.
     */
    private IOConverter() {
    }
    @Converter
    public static InputStream toInputStream(URL url) throws IOException {
        return url.openStream();
    }
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
    @Converter
    public static BufferedReader toReader(File file) throws FileNotFoundException {
        return new BufferedReader(new FileReader(file));
    }
    @Converter
    public static File toFile(String name) throws FileNotFoundException {
        return new File(name);
    }
    @Converter
    public static OutputStream toOutputStream(File file) throws FileNotFoundException {
        return new BufferedOutputStream(new FileOutputStream(file));
    }
    @Converter
    public static BufferedWriter toWriter(File file) throws IOException {
        return new BufferedWriter(new FileWriter(file));
    }
    @Converter
    public static Reader toReader(InputStream in) throws FileNotFoundException {
        return new InputStreamReader(in);
    }
    @Converter
    public static Writer toWriter(OutputStream out) throws FileNotFoundException {
        return new OutputStreamWriter(out);
    }
    @Converter
    public static StringReader toReader(String text) {
        return new StringReader(text);
    }
    @Converter
    public static InputStream toInputStream(String text, Exchange exchange) {
        if (exchange != null) {
            String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
            if (charsetName != null) {
                try {
                    return toInputStream(text.getBytes(charsetName));
                } catch (UnsupportedEncodingException e) {
                    LOG.warn(""Can't convert the String into the bytes with the charset "" + charsetName, e);
                }
            }
        }
        return toInputStream(text.getBytes());
    }
    @Converter
    public static InputStream toInputStream(BufferedReader buffer, Exchange exchange) throws IOException {
        return toInputStream(toString(buffer), exchange);
    }
    @Converter
    public static InputStream toInputStrean(DOMSource source) throws TransformerException, IOException {
        XmlConverter xmlConverter = createXmlConverter();
        ByteArrayInputStream bais = new ByteArrayInputStream(xmlConverter.toString(source).getBytes());
        return bais;
    }
    private static XmlConverter createXmlConverter() {
        if (xmlConverter == null) {
            xmlConverter = new XmlConverter();
        }
        return xmlConverter;
    }
    @Converter
    public static String toString(byte[] data, Exchange exchange) {
        if (exchange != null) {
            String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
            if (charsetName != null) {
                try {
                    return new String(data, charsetName);
                } catch (UnsupportedEncodingException e) {
                    LOG.warn(""Can't convert the byte to String with the charset "" + charsetName, e);
                }
            }
        }
        return new String(data);
    }
    @Converter
    public static String toString(File file) throws IOException {
        return toString(toReader(file));
    }
    @Converter
    public static byte[] toByteArray(File file) throws IOException {
        return toBytes(toInputStream(file));
    }
    @Converter
    public static byte[] toByteArray(Reader reader) throws IOException {
        if (reader instanceof BufferedReader) {
            return toByteArray((BufferedReader)reader);
        } else {
            return toByteArray(new BufferedReader(reader));
        }
    }
    @Converter
    public static String toString(URL url) throws IOException {
        return toString(toInputStream(url));
    }
    @Converter
    public static String toString(Reader reader) throws IOException {
        if (reader instanceof BufferedReader) {
            return toString((BufferedReader)reader);
        } else {
            return toString(new BufferedReader(reader));
        }
    }
    @Converter
    public static String toString(BufferedReader reader) throws IOException {
        if (reader == null) {
            return null;
        }
        try {
            CollectionStringBuffer builder = new CollectionStringBuffer(""\n"");
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    return builder.toString();
                }
                builder.append(line);
            }
        } finally {
            try {
                reader.close();
            } catch (IOException e) {
                LOG.warn(""Failed to close stream: "" + e, e);
            }
        }
    }
    @Converter
    public static byte[] toByteArray(BufferedReader reader) throws IOException {
        if (reader == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder(1024);
        char[] buf = new char[1024];
        try {
            int len = reader.read(buf);
            if (len != -1) {
                sb.append(buf, 0, len);
            }
        } finally {
            try {
                reader.close();
            } catch (IOException e) {
                LOG.warn(""Failed to close stream: "" + e, e);
            }
        }
        return sb.toString().getBytes();
    }
    @Converter
    public static String toString(InputStream in) throws IOException {
        return toString(toReader(in));
    }
    @Converter
    public static InputStream toInputStream(byte[] data) {
        return new ByteArrayInputStream(data);
    }
    @Converter
    public static ObjectOutput toObjectOutput(OutputStream stream) throws IOException {
        if (stream instanceof ObjectOutput) {
            return (ObjectOutput) stream;
        } else {
            return new ObjectOutputStream(stream);
        }
    }
    @Converter
    public static ObjectInput toObjectInput(InputStream stream) throws IOException {
        if (stream instanceof ObjectInput) {
            return (ObjectInput) stream;
        } else {
            return new ObjectInputStream(stream);
        }
    }
    @Converter
    public static byte[] toBytes(InputStream stream) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        copy(stream, bos);
        return bos.toByteArray();
    }
    public static void copy(InputStream stream, OutputStream os) throws IOException {
        byte[] data = new byte[4096];
        int read = stream.read(data);        
        while (read != -1) {            
            os.write(data, 0, read);
            read = stream.read(data);
        }
        os.flush();
    }
}
"
org.apache.camel.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/xml-configuration.html"">XML Configuration</a>
 * of the routing rules.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel;
"
org.apache.camel.component.jpa.JpaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.lang.reflect.Method;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import javax.persistence.Query;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public class JpaConsumer extends ScheduledPollConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(JpaConsumer.class);
    private final JpaEndpoint endpoint;
    private final TransactionStrategy template;
    private QueryFactory queryFactory;
    private DeleteHandler<Object> deleteHandler;
    private String query;
    private String namedQuery;
    private String nativeQuery;
    public JpaConsumer(JpaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.template = endpoint.createTransactionStrategy();
    }
    protected void poll() throws Exception {
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                Query query = getQueryFactory().createQuery(entityManager);
                configureParameters(query);
                List results = query.getResultList();
                for (Object result : results) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Processing new entity: "" + result);
                    }
                    if (lockEntity(result, entityManager)) {
                        // lets turn the result into an exchange and fire it
                        // into the processor
                        Exchange exchange = createExchange(result);
                        try {
                            getProcessor().process(exchange);
                        } catch (Exception e) {
                            throw new PersistenceException(e);
                        }
                        getDeleteHandler().deleteObject(entityManager, result);
                    }
                }
                entityManager.flush();
                return null;
            }
        });
    }
    // Properties
    // -------------------------------------------------------------------------
    public JpaEndpoint getEndpoint() {
        return endpoint;
    }
    public QueryFactory getQueryFactory() {
        if (queryFactory == null) {
            queryFactory = createQueryFactory();
            if (queryFactory == null) {
                throw new IllegalArgumentException(""No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume"");
            }
        }
        return queryFactory;
    }
    public void setQueryFactory(QueryFactory queryFactory) {
        this.queryFactory = queryFactory;
    }
    public DeleteHandler getDeleteHandler() {
        if (deleteHandler == null) {
            deleteHandler = createDeleteHandler();
        }
        return deleteHandler;
    }
    public void setDeleteHandler(DeleteHandler deleteHandler) {
        this.deleteHandler = deleteHandler;
    }
    public String getNamedQuery() {
        return namedQuery;
    }
    public void setNamedQuery(String namedQuery) {
        this.namedQuery = namedQuery;
    }
    public String getNativeQuery() {
        return nativeQuery;
    }
    public void setNativeQuery(String nativeQuery) {
        this.nativeQuery = nativeQuery;
    }
    public String getQuery() {
        return query;
    }
    public void setQuery(String query) {
        this.query = query;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to lock an object with an exclusive lock so that it can
     * be processed
     * 
     * @param entity the entity to be locked
     * @param entityManager
     * @return true if the entity was locked
     */
    protected boolean lockEntity(Object entity, EntityManager entityManager) {
        if (!getEndpoint().isConsumeDelete() || !getEndpoint().isConsumeLockEntity()) {
            return true;
        }
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Acquiring exclusive lock on entity: "" + entity);
            }
            entityManager.lock(entity, LockModeType.WRITE);
            return true;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Failed to achieve lock on entity: "" + entity + "". Reason: "" + e, e);
            }
            return false;
        }
    }
    protected QueryFactory createQueryFactory() {
        if (query != null) {
            return QueryBuilder.query(query);
        } else if (namedQuery != null) {
            return QueryBuilder.namedQuery(namedQuery);
        } else if (nativeQuery != null) {
            return QueryBuilder.nativeQuery(nativeQuery);
        } else {
            Class<?> entityType = endpoint.getEntityType();
            if (entityType == null) {
                return null;
            } else {
                return QueryBuilder.query(""select x from "" + entityType.getName() + "" x"");
            }
        }
    }
    protected DeleteHandler<Object> createDeleteHandler() {
        // TODO auto-discover an annotation in the entity bean to indicate the
        // process completed method call?
        Class<?> entityType = getEndpoint().getEntityType();
        if (entityType != null) {
            List<Method> methods = ObjectHelper.findMethodsWithAnnotation(entityType, Consumed.class);
            if (methods.size() > 1) {
                throw new IllegalArgumentException(""Only one method can be annotated with the @Consumed annotation but found: "" + methods);
            } else if (methods.size() == 1) {
                final Method method = methods.get(0);
                return new DeleteHandler<Object>() {
                    public void deleteObject(EntityManager entityManager, Object entityBean) {
                        ObjectHelper.invokeMethod(method, entityBean);
                    }
                };
            }
        }
        if (getEndpoint().isConsumeDelete()) {
            return new DeleteHandler<Object>() {
                public void deleteObject(EntityManager entityManager, Object entityBean) {
                    entityManager.remove(entityBean);
                }
            };
        } else {
            return new DeleteHandler<Object>() {
                public void deleteObject(EntityManager entityManager, Object entityBean) {
                    // do nothing
                }
            };
        }
    }
    protected void configureParameters(Query query) {
        int maxResults = endpoint.getMaximumResults();
        if (maxResults > 0) {
            query.setMaxResults(maxResults);
        }
    }
    protected Exchange createExchange(Object result) {
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setBody(result);
        return exchange;
    }
}
"
org.apache.camel.component.file.strategy.DeleteFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.IOException;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy which will delete the file when its processed
 *
 * @version $Revision$
 */
public class DeleteFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(DeleteFileProcessStrategy.class);
    public DeleteFileProcessStrategy() {
    }
    public DeleteFileProcessStrategy(boolean lockFile) {
        super(lockFile);
    }
    @Override
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Deleting file: "" + file);
        }
        boolean deleted = file.delete();
        if (!deleted) {
            throw new IOException(""Can not delete file: "" + file);
        }
        // must commit to release the lock
        super.commit(endpoint, exchange, file);
    }
}
"
org.apache.camel.component.atom.AtomConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.camel.Converter;
/**
 * Date converters.
 */
@Converter
public final class AtomConverter {
    public static final String DATE_PATTERN_NO_TIMEZONE = ""yyyy-MM-dd'T'HH:mm:ss"";
    private AtomConverter() {
        //Helper class
    }
    @Converter
    public static Date toDate(String text) throws ParseException {
        DateFormat sdf = new SimpleDateFormat(DATE_PATTERN_NO_TIMEZONE);
        return sdf.parse(text);
    }
}
"
org.apache.camel.Consumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A consumer of message exchanges from an {@link Endpoint}
 *
 * @version $Revision$
 */
public interface Consumer<E extends Exchange> extends Service {
}
"
org.apache.camel.component.jms.JmsPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.impl.PollingConsumerSupport;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
/**
 * @version $Revision$
 */
public class JmsPollingConsumer extends PollingConsumerSupport<JmsExchange> {
    private JmsOperations template;
    public JmsPollingConsumer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.template = template;
    }
    @Override
    public JmsEndpoint getEndpoint() {
        return (JmsEndpoint)super.getEndpoint();
    }
    public JmsExchange receiveNoWait() {
        return receive(0);
    }
    public JmsExchange receive() {
        return receive(-1);
    }
    public JmsExchange receive(long timeout) {
        setReceiveTimeout(timeout);
        Message message = template.receive();
        if (message != null) {
            return getEndpoint().createExchange(message);
        }
        return null;
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
    protected void setReceiveTimeout(long timeout) {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate)template;
            jmsTemplate.setReceiveTimeout(timeout);
        } else if (template instanceof JmsTemplate102) {
            JmsTemplate102 jmsTemplate102 = (JmsTemplate102)template;
            jmsTemplate102.setReceiveTimeout(timeout);
        } else {
            throw new IllegalArgumentException(""Cannot set the receiveTimeout property on unknown JmsOperations type: "" + template);
        }
    }
}
"
org.apache.camel.builder.xml.InvalidXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.xpath.XPathException;
import org.apache.camel.RuntimeExpressionException;
/**
 * An exception thrown if am XPath expression could not be parsed or evaluated
 *
 * @version $Revision$
 */
public class InvalidXPathExpression extends RuntimeExpressionException {
    private final String xpath;
    public InvalidXPathExpression(String xpath, XPathException e) {
        super(""Invalid xpath: "" + xpath + "". Reason: "" + e, e);
        this.xpath = xpath;
    }
    public String getXpath() {
        return xpath;
    }
}
"
org.apache.camel.component.cxf.feature.MessageInvokerInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.concurrent.Executor;
import org.apache.camel.component.cxf.MessageInvoker;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.Service;
/**
 * This interceptor just works for invoking the MessageInvoker implementor
 *
 */
public class MessageInvokerInterceptor extends AbstractPhaseInterceptor<Message> {
    public MessageInvokerInterceptor() {
        super(Phase.INVOKE);
    }
    public void handleMessage(final Message message) {
        final Exchange exchange = message.getExchange();
        final Endpoint endpoint = exchange.get(Endpoint.class);
        final Service service = endpoint.getService();
        final MessageInvoker invoker = (MessageInvoker)service.getInvoker();
        // How to deal with the oneway messge
        Runnable invocation = new Runnable() {
            public void run() {
                Exchange runableEx = message.getExchange();
                invoker.invoke(runableEx);
                if (!exchange.isOneWay()) {
                    Endpoint ep = exchange.get(Endpoint.class);
                    Message outMessage = runableEx.getOutMessage();
                    copyJaxwsProperties(message, outMessage);
                    if (outMessage == null) {
                        outMessage = ep.getBinding().createMessage();
                        exchange.setOutMessage(outMessage);
                    }
                }
            }
        };
        Executor executor = getExecutor(endpoint);
        if (exchange.get(Executor.class) == executor) {
            // already executing on the appropriate executor
            invocation.run();
        } else {
            exchange.put(Executor.class, executor);
            executor.execute(invocation);
        }
    }
    /**
     * Get the Executor for this invocation.
     * @param endpoint
     * @return
     */
    private Executor getExecutor(final Endpoint endpoint) {
        return endpoint.getService().getExecutor();
    }
    private void copyJaxwsProperties(Message inMsg, Message outMsg) {
        outMsg.put(Message.WSDL_OPERATION, inMsg.get(Message.WSDL_OPERATION));
        outMsg.put(Message.WSDL_SERVICE, inMsg.get(Message.WSDL_SERVICE));
        outMsg.put(Message.WSDL_INTERFACE, inMsg.get(Message.WSDL_INTERFACE));
        outMsg.put(Message.WSDL_PORT, inMsg.get(Message.WSDL_PORT));
        outMsg.put(Message.WSDL_DESCRIPTION, inMsg.get(Message.WSDL_DESCRIPTION));
    }
}
"
org.apache.camel.builder.script.Groovy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://groovy.codehaus.org/"">Groovy</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""groovy"")
public @interface Groovy {
    String value();
}"
org.apache.camel.converter.jaxp.StaxConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import org.apache.camel.Converter;
/**
 * A converter of StAX objects
 *
 * @version $Revision$
 */
@Converter
public class StaxConverter {
    private XMLInputFactory inputFactory;
    private XMLOutputFactory outputFactory;
    @Converter
    public XMLEventWriter createXMLEventWriter(OutputStream out) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(out);
    }
    @Converter
    public XMLEventWriter createXMLEventWriter(Writer writer) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(writer);
    }
    @Converter
    public XMLEventWriter createXMLEventWriter(Result result) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(result);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(OutputStream outputStream) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(outputStream);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(Writer writer) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(writer);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(Result result) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(result);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(InputStream in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(Reader in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(Source in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(InputStream in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(Reader in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(XMLStreamReader in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(Source in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    // Properties
    //-------------------------------------------------------------------------
    public XMLInputFactory getInputFactory() {
        if (inputFactory == null) {
            inputFactory = XMLInputFactory.newInstance();
        }
        return inputFactory;
    }
    public void setInputFactory(XMLInputFactory inputFactory) {
        this.inputFactory = inputFactory;
    }
    public XMLOutputFactory getOutputFactory() {
        if (outputFactory == null) {
            outputFactory = XMLOutputFactory.newInstance();
        }
        return outputFactory;
    }
    public void setOutputFactory(XMLOutputFactory outputFactory) {
        this.outputFactory = outputFactory;
    }
}
"
org.apache.camel.component.jhc.JhcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ThreadFactory;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.DefaultConnectionReuseStrategy;
import org.apache.http.impl.nio.DefaultClientIOEventDispatch;
import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
import org.apache.http.message.BasicHttpEntityEnclosingRequest;
import org.apache.http.message.BasicHttpRequest;
import org.apache.http.nio.NHttpConnection;
import org.apache.http.nio.protocol.BufferingHttpClientHandler;
import org.apache.http.nio.protocol.EventListener;
import org.apache.http.nio.protocol.HttpRequestExecutionHandler;
import org.apache.http.nio.reactor.ConnectingIOReactor;
import org.apache.http.nio.reactor.IOEventDispatch;
import org.apache.http.nio.reactor.SessionRequest;
import org.apache.http.nio.reactor.SessionRequestCallback;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.BasicHttpProcessor;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.RequestConnControl;
import org.apache.http.protocol.RequestContent;
import org.apache.http.protocol.RequestExpectContinue;
import org.apache.http.protocol.RequestTargetHost;
import org.apache.http.protocol.RequestUserAgent;
public class JhcProducer extends DefaultProducer<JhcExchange> implements AsyncProcessor {
    public static final String HTTP_RESPONSE_CODE = ""http.responseCode"";
    @Deprecated
    public static final Set<String> HEADERS_TO_SKIP = new HashSet<String>(Arrays.asList(
            ""content-length"", ""content-type"", HTTP_RESPONSE_CODE.toLowerCase()));
    private static final transient Log LOG = LogFactory.getLog(JhcProducer.class);
    private int nbThreads = 2;
    private ConnectingIOReactor ioReactor;
    private ThreadFactory threadFactory;
    private Thread runner;
    public JhcProducer(JhcEndpoint endpoint) {
        super(endpoint);
    }
    @Override
    public JhcEndpoint getEndpoint() {
        return (JhcEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        HttpParams params = getEndpoint().getParams();
        ioReactor = new DefaultConnectingIOReactor(nbThreads, threadFactory, params);
        BasicHttpProcessor httpproc = new BasicHttpProcessor();
        httpproc.addInterceptor(new RequestContent());
        httpproc.addInterceptor(new RequestTargetHost());
        httpproc.addInterceptor(new RequestConnControl());
        httpproc.addInterceptor(new RequestUserAgent());
        httpproc.addInterceptor(new RequestExpectContinue());
        BufferingHttpClientHandler handler = new BufferingHttpClientHandler(
                httpproc,
                new MyHttpRequestExecutionHandler(),
                new DefaultConnectionReuseStrategy(),
                params);
        handler.setEventListener(new EventLogger());
        final IOEventDispatch ioEventDispatch = new DefaultClientIOEventDispatch(handler, params);
        runner = new Thread(new Runnable() {
            public void run() {
                try {
                    ioReactor.execute(ioEventDispatch);
                } catch (InterruptedIOException ex) {
                    LOG.info(""Interrupted"");
                } catch (IOException e) {
                    LOG.warn(""I/O error: "" + e.getMessage());
                }
                LOG.debug(""Shutdown"");
            }
        });
        runner.start();
    }
    @Override
    protected void doStop() throws Exception {
        ioReactor.shutdown();
        runner.join();
        super.doStop();
    }
    public void process(Exchange exchange) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""process: "" + exchange);
        }
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""processAsync: "" + exchange);
        }
        SocketAddress addr = new InetSocketAddress(getEndpoint().getHost(), getEndpoint().getPort());
        exchange.setProperty(AsyncCallback.class.getName(), callback);
        SessionRequest req = ioReactor.connect(addr, null, exchange, new MySessionRequestCallback());
        return false;
    }
    protected HttpRequest createRequest(Exchange exchange) {
        String uri = getEndpoint().getEndpointUri();
        HttpEntity entity = createEntity(exchange);
        HttpRequest req;
        if (entity == null) {
            req = new BasicHttpRequest(""GET"", getEndpoint().getPath());
        } else {
            req = new BasicHttpEntityEnclosingRequest(""POST"", getEndpoint().getPath());
            ((BasicHttpEntityEnclosingRequest)req).setEntity(entity);
        }
        // propagate headers as HTTP headers
        HeaderFilterStrategy strategy = ((JhcEndpoint)getEndpoint()).getHeaderFilterStrategy();
        for (String headerName : exchange.getIn().getHeaders().keySet()) {
            String headerValue = exchange.getIn().getHeader(headerName, String.class);
            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {
                req.addHeader(headerName, headerValue);
            }
        }
        return req;
    }
    protected HttpEntity createEntity(Exchange exchange) {
        Message in = exchange.getIn();
        HttpEntity entity = in.getBody(HttpEntity.class);
        if (entity == null) {
            byte[] data = in.getBody(byte[].class);
            if (data == null) {
                return null;
            }
            entity = new ByteArrayEntity(data);
            String contentType = in.getHeader(""Content-Type"", String.class);
            if (contentType != null) {
                ((ByteArrayEntity) entity).setContentType(contentType);
            }
            String contentEncoding = in.getHeader(""Content-Encoding"", String.class);
            if (contentEncoding != null) {
                ((ByteArrayEntity) entity).setContentEncoding(contentEncoding);
            }
        }
        return entity;
    }
    static class MySessionRequestCallback implements SessionRequestCallback {
        public void completed(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Completed"");
            }
        }
        public void failed(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Failed"");
            }
        }
        public void timeout(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Timeout"");
            }
        }
        public void cancelled(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Cancelled"");
            }
        }
    }
    class MyHttpRequestExecutionHandler implements HttpRequestExecutionHandler {
        private static final String REQUEST_SENT       = ""request-sent"";
        private static final String RESPONSE_RECEIVED  = ""response-received"";
        public void initalizeContext(HttpContext httpContext, Object o) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Initialize context"");
            }
            httpContext.setAttribute(Exchange.class.getName(), (Exchange) o);
        }
        public HttpRequest submitRequest(HttpContext httpContext) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Submit request: "" + httpContext);
            }
            Object flag = httpContext.getAttribute(REQUEST_SENT);
            if (flag == null) {
                // Stick some object into the context
                httpContext.setAttribute(REQUEST_SENT, Boolean.TRUE);
                Exchange e = (Exchange) httpContext.getAttribute(Exchange.class.getName());
                return createRequest(e);
            } else {
                return null;
            }
        }
        public void handleResponse(HttpResponse httpResponse, HttpContext httpContext) throws IOException {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Handle response"");
            }
            httpContext.setAttribute(RESPONSE_RECEIVED, Boolean.TRUE);
            Exchange e = (Exchange) httpContext.getAttribute(Exchange.class.getName());
            e.getOut().setBody(httpResponse.getEntity());
            HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy();
            for (Iterator it = httpResponse.headerIterator(); it.hasNext();) {
                Header h = (Header) it.next();
                if (strategy != null && !strategy.applyFilterToExternalHeaders(h.getName(), h.getValue())) {
                    e.getOut().setHeader(h.getName(), h.getValue());
                }
            }
            e.getOut().setHeader(HTTP_RESPONSE_CODE, httpResponse.getStatusLine().getStatusCode());
            AsyncCallback callback = (AsyncCallback) e.removeProperty(AsyncCallback.class.getName());
            callback.done(false);
        }
        public void finalizeContext(HttpContext httpContext) {
        }
    }
    static class EventLogger implements EventListener {
        public void connectionOpen(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection open: "" + conn);
            }
        }
        public void connectionTimeout(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection timed out: "" + conn);
            }
        }
        public void connectionClosed(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection closed: "" + conn);
            }
        }
        public void fatalIOException(final IOException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""I/O error: "" + ex.getMessage());
            }
        }
        public void fatalProtocolException(final HttpException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""HTTP error: "" + ex.getMessage());
            }
        }
    }
}
"
org.apache.camel.bam.model.ActivityDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
/**
 * @version $Revision$
 */
@Entity
@Table(
    name = ""ACTIVITYDEFINITION"",
    uniqueConstraints = @UniqueConstraint(columnNames = {""name""})
)
public class ActivityDefinition extends EntitySupport {
    private String name;
    private ProcessDefinition processDefinition;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""Activity["" + getId() + "" name: "" + getName() + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
}
"
org.apache.camel.component.xmpp.XmppMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents a {@link org.apache.camel.Message} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppMessage extends DefaultMessage {
    private Message xmppMessage;
    public XmppMessage() {
        this(new Message());
    }
    public XmppMessage(Message jmsMessage) {
        this.xmppMessage = jmsMessage;
    }
    @Override
    public String toString() {
        if (xmppMessage != null) {
            return ""XmppMessage: "" + xmppMessage;
        } else {
            return ""XmppMessage: "" + getBody();
        }
    }
    @Override
    public XmppExchange getExchange() {
        return (XmppExchange)super.getExchange();
    }
    /**
     * Returns the underlying XMPP message
     */
    public Message getXmppMessage() {
        return xmppMessage;
    }
    public void setXmppMessage(Message xmppMessage) {
        this.xmppMessage = xmppMessage;
    }
    @Override
    public XmppMessage newInstance() {
        return new XmppMessage();
    }
    @Override
    protected Object createBody() {
        if (xmppMessage != null) {
            return getExchange().getBinding().extractBodyFromXmpp(getExchange(), xmppMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (xmppMessage != null) {
            map.putAll(getExchange().getBinding().extractHeadersFromXmpp(xmppMessage));
        }
    }
}
"
org.apache.camel.impl.ExpressionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.util.ObjectHelper;
/**
 * A useful base class for {@link Predicate} and {@link Expression} implementations
 *
 * @version $Revision$
 */
public abstract class ExpressionSupport<E extends Exchange> implements Expression<E> , Predicate<E> {
    public boolean matches(E exchange) {
        Object value = evaluate(exchange);
        return ObjectHelper.evaluateValuePredicate(value);
    }
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(text + "" "" + assertionFailureMessage(exchange) + "" for exchange: "" + exchange);
        }
    }
    protected abstract String assertionFailureMessage(E exchange);
}
"
org.apache.camel.component.file.remote.FtpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class FtpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FtpEndpoint.class);
    public FtpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public FtpEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public FtpProducer createProducer() throws Exception {
        return new FtpProducer(this, FtpUtils.createNewFtpClient());
    }
    public FtpConsumer createConsumer(Processor processor) throws Exception {
        final FtpConsumer consumer = new FtpConsumer(this, processor, FtpUtils.createNewFtpClient());
        configureConsumer(consumer);
        return consumer;
    }
}
"
org.apache.camel.impl.DefaultMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.activation.DataHandler;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
/**
 * The default implementation of {@link Message}
 *
 * @version $Revision$
 */
public class DefaultMessage extends MessageSupport {
    private Map<String, Object> headers;
    private Map<String, DataHandler> attachments;
    @Override
    public String toString() {
        return ""Message: "" + getBody();
    }
    public Object getHeader(String name) {
        return getHeaders().get(name);
    }
    public <T> T getHeader(String name, Class<T> type) {
        Object value = getHeader(name);
        Exchange e = getExchange();
        return e.getContext().getTypeConverter().convertTo(type, e, value);
    }
    public void setHeader(String name, Object value) {
        if (headers == null) {
            headers = createHeaders();
        }
        headers.put(name, value);
    }
    public Object removeHeader(String name) {
        if (headers != null) {
            return headers.remove(name);
        } else {
            return null;
        }
    }
    public Map<String, Object> getHeaders() {
        if (headers == null) {
            headers = createHeaders();
        }
        return headers;
    }
    public void setHeaders(Map<String, Object> headers) {
        this.headers = headers;
    }
    public DefaultMessage newInstance() {
        return new DefaultMessage();
    }
    /**
     * A factory method to lazily create the headers to make it easy to create
     * efficient Message implementations which only construct and populate the
     * Map on demand
     *
     * @return return a newly constructed Map possibly containing headers from
     *         the underlying inbound transport
     */
    protected Map<String, Object> createHeaders() {
        HashMap<String, Object> map = new HashMap<String, Object>();
        populateInitialHeaders(map);
        return map;
    }
    /**
     * A strategy method populate the initial set of headers on an inbound
     * message from an underlying binding
     *
     * @param map is the empty header map to populate
     */
    protected void populateInitialHeaders(Map<String, Object> map) {
    }
    /**
     * A factory method to lazily create the attachments to make it easy to
     * create efficient Message implementations which only construct and
     * populate the Map on demand
     *
     * @return return a newly constructed Map
     */
    protected Map<String, DataHandler> createAttachments() {
        HashMap<String, DataHandler> map = new HashMap<String, DataHandler>();
        populateInitialAttachments(map);
        return map;
    }
    /**
     * A strategy method populate the initial set of attachments on an inbound
     * message from an underlying binding
     *
     * @param map is the empty attachment map to populate
     */
    protected void populateInitialAttachments(Map<String, DataHandler> map) {
    }
    public void addAttachment(String id, DataHandler content) {
        if (attachments == null) {
            attachments = createAttachments();
        }
        attachments.put(id, content);
    }
    public DataHandler getAttachment(String id) {
        return getAttachments().get(id);
    }
    public Set<String> getAttachmentNames() {
        if (attachments == null) {
            attachments = createAttachments();
        }
        return attachments.keySet();
    }
    public void removeAttachment(String id) {
        if (attachments != null && attachments.containsKey(id)) {
            attachments.remove(id);
        }
    }
    public Map<String, DataHandler> getAttachments() {
        if (attachments == null) {
            attachments = createAttachments();
        }
        return attachments;
    }
    public void setAttachments(Map<String, DataHandler> attachments) {
        this.attachments = attachments;
    }
    public boolean hasAttachments() {
        if (attachments == null) {
            attachments = createAttachments();
        }
        return this.attachments != null && this.attachments.size() > 0;
    }
    /**
     * Returns true if the headers have been mutated in some way
     */
    protected boolean hasPopulatedHeaders() {
        return headers != null;
    }
}
"
org.apache.camel.spring.CamelBeanPostProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.EndpointInject;
import org.apache.camel.Produce;
import org.apache.camel.impl.CamelPostProcessorHelper;
import org.apache.camel.spring.util.ReflectionUtils;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeanInstantiationException;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
/**
 * A bean post processor which implements the <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 * features in Camel such as the <a href=""http://activemq.apache.org/camel/bean-injection.html"">Bean Injection</a> of objects like
 * {@link Endpoint} and
 * {@link org.apache.camel.ProducerTemplate} together with support for
 * <a href=""http://activemq.apache.org/camel/pojo-consuming.html"">POJO Consuming</a> via the 
 * {@link org.apache.camel.Consume} and {@link org.apache.camel.MessageDriven} annotations along with
 * <a href=""http://activemq.apache.org/camel/pojo-producing.html"">POJO Producing</a> via the
 * {@link org.apache.camel.Produce} annotation along with other annotations such as
 * {@link org.apache.camel.RecipientList} for creating <a href=""http://activemq.apache.org/camel/recipientlist-annotation.html"">a Recipient List router via annotations</a>.
 * <p>
 * If you use the &lt;camelContext&gt; element in your <a href=""http://activemq.apache.org/camel/spring.html"">Spring XML</a> 
 * then one of these bean post processors is implicity installed and configured for you. So you should never have to
 * explicitly create or configure one of these instances.
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""beanPostProcessor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {
    private static final transient Log LOG = LogFactory.getLog(CamelBeanPostProcessor.class);
    @XmlTransient
    private SpringCamelContext camelContext;
    @XmlTransient
    private ApplicationContext applicationContext;
    @XmlTransient
    private CamelPostProcessorHelper postProcessor;
    public CamelBeanPostProcessor() {
    }
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        injectFields(bean);
        injectMethods(bean);
        if (bean instanceof CamelContextAware) {
            CamelContextAware contextAware = (CamelContextAware)bean;
            if (camelContext == null) {
                LOG.warn(""No CamelContext defined yet so cannot inject into: "" + bean);
            } else {
                contextAware.setCamelContext(camelContext);
            }
        }
        return bean;
    }
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    // Properties
    // -------------------------------------------------------------------------
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public SpringCamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(SpringCamelContext camelContext) {
        this.camelContext = camelContext;
        postProcessor = new CamelPostProcessorHelper(camelContext) {
            @Override
            protected RuntimeException createProxyInstantiationRuntimeException(Class<?> type, Endpoint endpoint, Exception e) {
                return new BeanInstantiationException(type, ""Could not instantiate proxy of type "" + type.getName() + "" on endpoint "" + endpoint, e);
            }
        };
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to allow implementations to perform some custom JBI
     * based injection of the POJO
     *
     * @param bean the bean to be injected
     */
    protected void injectFields(final Object bean) {
        ReflectionUtils.doWithFields(bean.getClass(), new ReflectionUtils.FieldCallback() {
            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
                EndpointInject annotation = field.getAnnotation(EndpointInject.class);
                if (annotation != null) {
                    injectField(field, annotation.uri(), annotation.name(), bean);
                }
                Produce produce = field.getAnnotation(Produce.class);
                if (produce != null) {
                    injectField(field, produce.uri(), produce.ref(), bean);
                }
            }
        });
    }
    protected void injectField(Field field, String endpointUri, String endpointRef, Object bean) {
        ReflectionUtils.setField(field, bean, getPostProcessor().getInjectionValue(field.getType(), endpointUri, endpointRef, field.getName()));
    }
    protected void injectMethods(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                setterInjection(method, bean);
                getPostProcessor().consumerInjection(method, bean);
            }
        });
    }
    protected void setterInjection(Method method, Object bean) {
        EndpointInject annoation = method.getAnnotation(EndpointInject.class);
        if (annoation != null) {
            setterInjection(method, bean, annoation.uri(), annoation.name());
        }
        Produce produce = method.getAnnotation(Produce.class);
        if (produce != null) {
            setterInjection(method, bean, produce.uri(), produce.ref());
        }
    }
    protected void setterInjection(Method method, Object bean, String endpointUri, String endpointRef) {
        Class<?>[] parameterTypes = method.getParameterTypes();
        if (parameterTypes != null) {
            if (parameterTypes.length != 1) {
                LOG.warn(""Ignoring badly annotated method for injection due to incorrect number of parameters: "" + method);
            } else {
                String propertyName = ObjectHelper.getPropertyName(method);
                Object value = getPostProcessor().getInjectionValue(parameterTypes[0], endpointUri, endpointRef, propertyName);
                ObjectHelper.invokeMethod(method, bean, value);
            }
        }
    }
    protected void consumerInjection(final Object bean) {
        org.springframework.util.ReflectionUtils.doWithMethods(bean.getClass(), new org.springframework.util.ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                /*
                 * TODO support callbacks? if
                 * (method.getAnnotation(Callback.class) != null) { try {
                 * Expression e = ExpressionFactory.createExpression(
                 * method.getAnnotation(Callback.class).condition());
                 * JexlContext jc = JexlHelper.createContext();
                 * jc.getVars().put(""this"", obj); Object r = e.evaluate(jc); if
                 * (!(r instanceof Boolean)) { throw new
                 * RuntimeException(""Expression did not returned a boolean value
                 * but: "" + r); } Boolean oldVal =
                 * req.getCallbacks().get(method); Boolean newVal = (Boolean) r;
                 * if ((oldVal == null || !oldVal) && newVal) {
                 * req.getCallbacks().put(method, newVal); method.invoke(obj,
                 * new Object[0]); // TODO: handle return value and sent it as
                 * the answer } } catch (Exception e) { throw new
                 * RuntimeException(""Unable to invoke callback"", e); } }
                 */
            }
        });
    }
    public CamelPostProcessorHelper getPostProcessor() {
        ObjectHelper.notNull(postProcessor, ""postProcessor"");
        return postProcessor;
    }
}
"
org.apache.camel.component.cxf.feature.MessageDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.interceptors.FaultOutInterceptor;
import org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.phase.Phase;
/**
 * This feature just setting up the CXF endpoint interceptor for handling the
 * Message in Message data format
 */
public class MessageDataFormatFeature extends AbstractDataFormatFeature {
    private static final Logger LOG = LogUtils.getL7dLogger(MessageDataFormatFeature.class);
    // interceptor filiter
    // filiter the unused phase interceptor
    private static final String[] REMAINING_IN_PHASES = {Phase.RECEIVE , Phase.POST_INVOKE};
    private static final String[] REMAINING_OUT_PHASES = {Phase.PREPARE_SEND, Phase.WRITE, Phase.SEND, Phase.PREPARE_SEND_ENDING};
    @Override
    public void initialize(Client client, Bus bus) {
        removeInterceptorWhichIsOutThePhases(client.getInInterceptors(), REMAINING_IN_PHASES);
        removeInterceptorWhichIsOutThePhases(client.getEndpoint().getInInterceptors(), REMAINING_IN_PHASES);
        client.getEndpoint().getBinding().getInInterceptors().clear();
        removeInterceptorWhichIsOutThePhases(client.getOutInterceptors(), REMAINING_OUT_PHASES);
        removeInterceptorWhichIsOutThePhases(client.getEndpoint().getOutInterceptors(), REMAINING_OUT_PHASES);
        client.getEndpoint().getBinding().getOutInterceptors().clear();
        client.getEndpoint().getOutInterceptors().add(new RawMessageContentRedirectInterceptor());
        client.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    @Override
    public void initialize(Server server, Bus bus) {
        // currently we do not filiter the bus
        // remove the interceptors
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getService().getInInterceptors(), REMAINING_IN_PHASES);
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getInInterceptors(), REMAINING_IN_PHASES);
        // Do not using the binding interceptor any more
        server.getEndpoint().getBinding().getInInterceptors().clear();
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getService().getOutInterceptors(), REMAINING_OUT_PHASES);
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getOutInterceptors(), REMAINING_OUT_PHASES);
        // Do not use the binding interceptor any more
        server.getEndpoint().getBinding().getOutInterceptors().clear();
        server.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
        resetServiceInvokerInterceptor(server);
        server.getEndpoint().getOutInterceptors().add(new RawMessageContentRedirectInterceptor());
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.osgi.CamelContextFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.impl.converter.AnnotationTypeConverterLoader;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.impl.converter.TypeConverterLoader;
import org.apache.camel.spring.RouteBuilderFinder;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.ResolverUtil;
import org.osgi.framework.BundleContext;
import org.springframework.osgi.context.BundleContextAware;
@XmlRootElement(name = ""camelContext"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelContextFactoryBean extends org.apache.camel.spring.CamelContextFactoryBean implements BundleContextAware {
    @XmlTransient
    private BundleContext bundleContext;
    public BundleContext getBundleContext() {
        return bundleContext;
    }
    public void setBundleContext(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    protected SpringCamelContext createContext() {
        SpringCamelContext context = super.createContext();
        if (bundleContext != null) {
            context.setComponentResolver(new OsgiComponentResolver());
            context.setLanguageResolver(new OsgiLanguageResolver());
            addOsgiAnnotationTypeConverterLoader(context, bundleContext);
            context.setFactoryFinderClass(OsgiFactoryFinder.class);
        }
        return context;
    }    
    /**
     * The factory method for create the ResolverUtil
     * @return a new instance of ResolverUtil
     */
    protected ResolverUtil createResolverUtil() {
        if (bundleContext != null) {
            return new OsgiResolverUtil(bundleContext);
        } else {
            return new ResolverUtil();
        }
    }
    protected void addOsgiAnnotationTypeConverterLoader(SpringCamelContext context, BundleContext bundleContext) {
        DefaultTypeConverter typeConverter = (DefaultTypeConverter) context.getTypeConverter();
        List<TypeConverterLoader> typeConverterLoaders = typeConverter.getTypeConverterLoaders();
        // Remove the AnnotationTypeConverterLoader
        TypeConverterLoader atLoader = null; 
        for (TypeConverterLoader loader : typeConverterLoaders) {
            if (loader instanceof AnnotationTypeConverterLoader) {
                atLoader = loader;
                break;
            }
        }
        if (atLoader != null) {
            typeConverterLoaders.remove(atLoader);
        }
        typeConverterLoaders.add(new OsgiAnnotationTypeConverterLoader(bundleContext));
    }    
}
"
org.apache.camel.component.stream.StreamConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Consumer that can read from streams
 */
public class StreamConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamConsumer.class);
    private static final String TYPES = ""in,file,url"";
    private static final String INVALID_URI = ""Invalid uri, valid form: 'stream:{"" + TYPES + ""}'"";
    private static final List<String> TYPES_LIST = Arrays.asList(TYPES.split("",""));
    private InputStream inputStream = System.in;
    private StreamEndpoint endpoint;
    private String uri;
    public StreamConsumer(StreamEndpoint endpoint, Processor processor, String uri) throws Exception {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.uri = uri;
        validateUri(uri);
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (""in"".equals(uri)) {
            inputStream = System.in;
        } else if (""file"".equals(uri)) {
            inputStream = resolveStreamFromFile();
        } else if (""url"".equals(uri)) {
            inputStream = resolveStreamFromUrl();
        }
        readFromStream();
    }
    @Override
    public void doStop() throws Exception {
        // important: do not close the stream as it will close the standard system.in etc.
        super.doStop();
    }
    private void readFromStream() throws Exception {
        Charset charset = endpoint.getCharset();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, charset));
        String line;
        while ((line = br.readLine()) != null) {
            consumeLine(line);
        }
        // important: do not close the reader as it will close the standard system.in etc.
    }
    private void consumeLine(Object line) throws Exception {
        Exchange exchange = endpoint.createExchange();
        Message msg = new DefaultMessage();
        msg.setBody(line);
        exchange.setIn(msg);
        getProcessor().process(exchange);
    }
    private InputStream resolveStreamFromUrl() throws IOException {
        String u = endpoint.getUrl();
        URL url = new URL(u);
        URLConnection c = url.openConnection();
        return c.getInputStream();
    }
    private InputStream resolveStreamFromFile() throws IOException {
        String fileName = endpoint.getFile() != null ? endpoint.getFile().trim() : ""_file"";
        File f = new File(fileName);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to read from file: "" + f);
        }
        f.createNewFile();
        return new FileInputStream(f);
    }
    private void validateUri(String uri) throws IllegalArgumentException {
        String[] s = uri.split("":"");
        if (s.length < 2) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        String[] t = s[1].split(""\\?"");
        if (t.length < 1) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        this.uri = t[0].trim();
        if (!TYPES_LIST.contains(this.uri)) {
            throw new IllegalArgumentException(INVALID_URI);
        }
    }
}
"
org.apache.camel.spring.CamelServiceExporterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The &lt;export&gt; tag element.
 *
 * @version $Revision$
*/
@XmlRootElement(name = ""export"")
public class CamelServiceExporterType extends IdentifiedType {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String serviceRef;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.builder.DataFormatClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.zip.Deflater;
import org.w3c.dom.Node;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.dataformat.ArtixDSContentType;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.HL7DataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.JsonDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.TidyMarkupDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.dataformat.XStreamDataFormat;
import org.apache.camel.model.dataformat.ZipDataFormat;
import org.apache.camel.spi.DataFormat;
/**
 * An expression for constructing the different possible {@link DataFormat}
 * options.
 *
 * @version $Revision$
 */
public class DataFormatClause<T extends ProcessorType> {
    private final T processorType;
    private final Operation operation;
    /**
     * {@link DataFormat} operations.
     */
    public enum Operation {
        Marshal, Unmarshal
    }
    public DataFormatClause(T processorType, Operation operation) {
        this.processorType = processorType;
        this.operation = operation;
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format for dealing with lots of different message formats such as SWIFT etc.
     */
    public T artixDS() {
        return dataFormat(new ArtixDSDataFormat());
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> dataObjectType) {
        return dataFormat(new ArtixDSDataFormat(dataObjectType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> elementType, ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(elementType, contentType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified content type
     * for marshalling and unmarshalling messages
     */
    public T artixDS(ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(contentType));
    }
    /**
     * Uses the CSV data format
     */
    public T csv() {
        return dataFormat(new CsvDataFormat());
    }
    /**
     * Uses the HL7 data format
     */
    public T hl7() {
        return dataFormat(new HL7DataFormat());
    }
    /**
     * Uses the JAXB data format
     */
    public T jaxb() {
        return dataFormat(new JaxbDataFormat());
    }
    /**
     * Uses the JAXB data format turning pretty printing on or off
     */
    public T jaxb(boolean prettyPrint) {
        return dataFormat(new JaxbDataFormat(prettyPrint));
    }
    /**
     * Uses the Java Serialization data format
     */
    public T serialization() {
        return dataFormat(new SerializationDataFormat());
    }
    /**
     * Uses the String data format
     */
    public T string() {
        return string(null);
    }
    /**
     * Uses the String data format supporting encoding using given charset
     */
    public T string(String charset) {
        StringDataFormat sdf = new StringDataFormat();
        sdf.setCharset(charset);
        return dataFormat(sdf);
    }
    /**
     * Uses the JAXB data format
     */
    public T xmlBeans() {
        return dataFormat(new XMLBeansDataFormat());
    }
    /**
     * Return WellFormed HTML (an XML Document) either 
     * {@link java.lang.String} or {@link org.w3c.dom.Node}
     */
    public T tidyMarkup(Class<?> dataObjectType) {
        return dataFormat(new TidyMarkupDataFormat(dataObjectType));
    }
    /**
     * Return TidyMarkup in the default format 
     *  as {@link org.w3c.dom.Node}
     */
    public T tidyMarkup() {
        return dataFormat(new TidyMarkupDataFormat(Node.class));
    }
    /**
     * Uses the XStream data format
     */
    public T xstream() {
        return dataFormat(new XStreamDataFormat());
    }
    /**
     * Uses the JSON data format
     */
    public T json() {
        return dataFormat(new JsonDataFormat());
    }
    private T dataFormat(DataFormatType dataFormatType) {
        switch (operation) {
        case Unmarshal:
            return (T)processorType.unmarshal(dataFormatType);
        case Marshal:
            return (T)processorType.marshal(dataFormatType);
        default:
            throw new IllegalArgumentException(""Unknown DataFormat operation: "" + operation);
        }
    }
    public T zip() {
        ZipDataFormat zdf = new ZipDataFormat(Deflater.DEFAULT_COMPRESSION);
        return dataFormat(zdf);
    }
    public T zip(int compressionLevel) {
        ZipDataFormat zdf = new ZipDataFormat(compressionLevel);
        return dataFormat(zdf);
    }
}
"
org.apache.camel.component.rmi.RmiProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import org.apache.camel.Exchange;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanHolder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.impl.DefaultProducer;
/**
 * @version $Revision$
 */
public class RmiProducer extends DefaultProducer<BeanExchange> {
    private BeanProcessor beanProcessor;
    public RmiProducer(RmiEndpoint endpoint) throws RemoteException, NotBoundException {
        super(endpoint);
        BeanHolder holder = new RmiRegistryBean(endpoint.getCamelContext(), endpoint.getName(), endpoint.getRegistry());
        beanProcessor = new BeanProcessor(holder);
        String method = endpoint.getMethod();
        if (method != null) {
            beanProcessor.setMethod(method);
        }
    }
    public void process(Exchange exchange) throws Exception {
        beanProcessor.process(exchange);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.util.UuidGenerator;
public abstract class RemoteFileEndpoint<T extends RemoteFileExchange> extends ScheduledPollEndpoint<T> {
    private RemoteFileBinding binding;
    private RemoteFileConfiguration configuration;
    public RemoteFileEndpoint(String uri, RemoteFileComponent component, RemoteFileConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    protected RemoteFileEndpoint(String endpointUri, RemoteFileConfiguration configuration) {
        super(endpointUri);
        this.configuration = configuration;
    }
    protected RemoteFileEndpoint(String endpointUri) {
        this(endpointUri, new RemoteFileConfiguration());
    }
    protected RemoteFileBinding createRemoteFileBinding() {
        return new RemoteFileBinding();
    }
    public T createExchange() {
        return (T) new RemoteFileExchange(getCamelContext(), getExchangePattern(), getBinding());
    }
    public T createExchange(ExchangePattern pattern) {
        return (T) new RemoteFileExchange(getCamelContext(), pattern, getBinding());
    }
    public T createExchange(String fullFileName, String fileName, long fileLength, ByteArrayOutputStream outputStream) {
        return (T) new RemoteFileExchange(getCamelContext(), getExchangePattern(), getBinding(),
                getConfiguration().getHost(), fullFileName, fileName, fileLength, outputStream);
    }
    public RemoteFileBinding getBinding() {
        if (binding == null) {
            binding = createRemoteFileBinding();
        }
        return binding;
    }
    public void setBinding(RemoteFileBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return true;
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
    /**
      * Return the file name that will be auto-generated for the given message if none is provided
      */
    public String getGeneratedFileName(Message message) {
        return getFileFriendlyMessageId(message.getMessageId());
    }
    protected String getFileFriendlyMessageId(String id) {
        return UuidGenerator.generateSanitizedId(id);
    }
}
"
org.apache.camel.impl.DefaultExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ExchangeConverter;
/**
 * Default implementation of {@link org.apache.camel.spi.ExchangeConverter}.
 *
 * @version $Revision$
 */
public class DefaultExchangeConverter implements ExchangeConverter {
    public <T> T convertTo(Class<T> type, Exchange exchange) {
        // TODO use some kinda introspection to find available exchange conversions
        throw new UnsupportedOperationException(""Not implemented yet"");
    }
}
"
org.apache.camel.spring.spi.SpringConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Converter;
import org.apache.camel.component.bean.BeanInvocation;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * Some Spring based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class SpringConverters {
    private SpringConverters() {        
    }
    @Converter
    public static InputStream toInputStream(Resource resource) throws IOException {
        return resource.getInputStream();
    }
    @Converter
    public static File toFile(Resource resource) throws IOException {
        return resource.getFile();
    }
    @Converter
    public static URL toUrl(Resource resource) throws IOException {
        return resource.getURL();
    }
    @Converter
    public static UrlResource toResource(String uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static UrlResource toResource(URL uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static FileSystemResource toResource(File file) throws IOException {
        return new FileSystemResource(file);
    }
    @Converter
    public static ByteArrayResource toResource(byte[] data) throws IOException {
        return new ByteArrayResource(data);
    }
    @Converter
    public static BeanInvocation toBeanInvocation(MethodInvocation invocation) {
        return new BeanInvocation(invocation.getMethod(), invocation.getArguments());
    }
}
"
org.apache.camel.component.jms.ConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * @version $Revision$
 */
public enum ConsumerType {
    Simple, Default, ServerSessionPool
}
"
org.apache.camel.component.file.remote.FtpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Processor;
import org.apache.camel.component.file.FileComponent;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
public class FtpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private FtpEndpoint endpoint;
    private FTPClient client;
    private boolean loggedIn;
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.client = client;
    }
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client,
                       ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.client = client;
    }
    protected void doStart() throws Exception {
        log.info(""Starting"");
        super.doStart();
    }
    protected void doStop() throws Exception {
        log.info(""Stopping"");
        // disconnect when stopping
        try {
            disconnect();
        } catch (Exception e) {
            // ignore just log a warning
            String message = ""Could not disconnect from "" + remoteServer()
                    + "". Reason: "" + client.getReplyString() + "". Code: "" + client.getReplyCode();
            log.warn(message);
        }
        super.doStop();
    }
    protected void connectIfNecessary() throws IOException {
        if (!client.isConnected() || !loggedIn) {
            if (log.isDebugEnabled()) {
                log.debug(""Not connected/logged in, connecting to "" + remoteServer());
            }
            loggedIn = FtpUtils.connect(client, endpoint.getConfiguration());
            if (!loggedIn) {
                return;
            }
        }
        log.info(""Connected and logged in to "" + remoteServer());
    }
    protected void disconnect() throws IOException {
        loggedIn = false;
        log.debug(""Disconnecting from "" + remoteServer());
        FtpUtils.disconnect(client);
    }
    protected void poll() throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Polling "" + endpoint.getConfiguration());
        }
        try {
            connectIfNecessary();
            if (!loggedIn) {
                String message = ""Could not connect/login to "" + endpoint.getConfiguration();
                log.warn(message);
                throw new FtpOperationFailedException(client.getReplyCode(), client.getReplyString(), message);
            }
            final String fileName = endpoint.getConfiguration().getFile();
            if (endpoint.getConfiguration().isDirectory()) {
                pollDirectory(fileName);
            } else {
                int index = fileName.lastIndexOf('/');
                if (index > -1) {
                    // cd to the folder of the filename
                    client.changeWorkingDirectory(fileName.substring(0, index));
                }
                // list the files in the fold and poll the first file
                final FTPFile[] files = client.listFiles(fileName.substring(index + 1));
                pollFile(files[0]);
            }
            lastPollTime = System.currentTimeMillis();
        } catch (Exception e) {
            loggedIn = false;
            if (isStopping() || isStopped()) {
                // if we are stopping then ignore any exception during a poll
                log.warn(""Consumer is stopping. Ignoring caught exception: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
            } else {
                log.warn(""Exception occured during polling: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
                disconnect();
                // Rethrow to signify that we didn't poll
                throw e;
            }
        }
    }
    protected void pollDirectory(String dir) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Polling directory: "" + dir);
        }
        String currentDir = client.printWorkingDirectory();
        client.changeWorkingDirectory(dir);
        for (FTPFile ftpFile : client.listFiles()) {
            if (ftpFile.isFile()) {
                pollFile(ftpFile);
            } else if (ftpFile.isDirectory()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(ftpFile));
                }
            } else {
                log.debug(""Unsupported type of FTPFile: "" + ftpFile + "" (not a file or directory). It is skipped."");
            }
        }
        // change back to original current dir
        client.changeWorkingDirectory(currentDir);
    }
    protected String getFullFileName(FTPFile ftpFile) throws IOException {
        return client.printWorkingDirectory() + ""/"" + ftpFile.getName();
    }
    private void pollFile(FTPFile ftpFile) throws Exception {
        if (ftpFile == null) {
            return;
        }
        if (log.isTraceEnabled()) {
            log.trace(""Polling file: "" + ftpFile);
        }
        // if using last polltime for timestamp matcing (to be removed in Camel 2.0)
        boolean timestampMatched = true;
        if (isTimestamp()) {
            // TODO do we need to adjust the TZ? can we?
            long ts = ftpFile.getTimestamp().getTimeInMillis();
            timestampMatched = ts > lastPollTime;
            if (log.isTraceEnabled()) {
                log.trace(""The file is to old + "" + ftpFile + "". lastPollTime="" + lastPollTime + "" > fileTimestamp="" + ts);
            }
        }
        if (timestampMatched && isMatched(ftpFile)) {
            String fullFileName = getFullFileName(ftpFile);
            // is we use excluse read then acquire the exclusive read (waiting until we got it)
            if (exclusiveReadLock) {
                acquireExclusiveReadLock(client, ftpFile);
            }
            // retrieve the file
            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);
            if (log.isDebugEnabled()) {
                log.debug(""Retrieved file: "" + ftpFile.getName() + "" from: "" + remoteServer());
            }
            RemoteFileExchange exchange = endpoint.createExchange(fullFileName, ftpFile.getName(),
                    ftpFile.getSize(), byteArrayOutputStream);
            if (isSetNames()) {
                // set the filename in the special header filename marker to the ftp filename
                String ftpBasePath = endpoint.getConfiguration().getFile();
                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);
                relativePath = relativePath.replaceFirst(""/"", """");
                if (log.isDebugEnabled()) {
                    log.debug(""Setting exchange filename to "" + relativePath);
                }
                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
            }
            if (deleteFile) {
                // delete file after consuming
                if (log.isDebugEnabled()) {
                    log.debug(""Deleteing file: "" + ftpFile.getName() + "" from: "" + remoteServer());
                }
                boolean deleted = client.deleteFile(ftpFile.getName());
                if (!deleted) {
                    String message = ""Can not delete file: "" + ftpFile.getName() + "" from: "" + remoteServer();
                    throw new FtpOperationFailedException(client.getReplyCode(), client.getReplyString(), message);
                }
            } else if (isMoveFile()) {
                String fromName = ftpFile.getName();
                String toName = getMoveFileName(fromName, exchange);
                if (log.isDebugEnabled()) {
                    log.debug(""Moving file: "" + fromName + "" to: "" + toName);
                }
                // delete any existing file
                boolean deleted = client.deleteFile(toName);
                if (!deleted) {
                    // if we could not delete any existing file then maybe the folder is missing
                    // build folder if needed
                    int lastPathIndex = toName.lastIndexOf('/');
                    if (lastPathIndex != -1) {
                        String directory = toName.substring(0, lastPathIndex);
                        if (!FtpUtils.buildDirectory(client, directory)) {
                            log.warn(""Can not build directory: "" + directory + "" (maybe because of denied permissions)"");
                        }
                    }
                }
                // try to rename
                boolean success = client.rename(fromName, toName);
                if (!success) {
                    String message = ""Can not move file: "" + fromName + "" to: "" + toName;
                    throw new FtpOperationFailedException(client.getReplyCode(), client.getReplyString(), message);
                }
            }
            // all success so lets process it
            getProcessor().process(exchange);
        }
    }
    protected void acquireExclusiveReadLock(FTPClient client, FTPFile ftpFile) throws IOException {
        if (log.isTraceEnabled()) {
            log.trace(""Waiting for exclusive read lock to file: "" + ftpFile);
        }
        // the trick is to try to rename the file, if we can rename then we have exclusive read
        // since its a remote file we can not use java.nio to get a RW lock
        String originalName = ftpFile.getName();
        String newName = originalName + "".camelExclusiveReadLock"";
        boolean exclusive = false;
        while (!exclusive) {
            exclusive = client.rename(originalName, newName);
            if (exclusive) {
                if (log.isDebugEnabled()) {
                    log.debug(""Acquired exclusive read lock to file: "" + originalName);
                }
                // rename it back so we can read it
                client.rename(newName, originalName);
            } else {
                log.trace(""Exclusive read lock not granted. Sleeping for 1000 millis."");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }
    }
    protected String getFileName(Object file) {
        FTPFile ftpFile = (FTPFile) file;
        return ftpFile.getName();
    }
}
"
org.apache.camel.component.quartz.QuartzExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.quartz.JobExecutionContext;
/**
 * @version $Revision$
 */
public class QuartzExchange extends DefaultExchange {
    public QuartzExchange(CamelContext context, ExchangePattern pattern, JobExecutionContext jobExecutionContext) {
        super(context, pattern);
        setIn(new QuartzMessage(this, jobExecutionContext));
    }
    @Override
    public QuartzMessage getIn() {
        return (QuartzMessage) super.getIn();
    }
    public JobExecutionContext getJobExecutionContext() {
        return getIn().getJobExecutionContext();
    }
}
"
org.apache.camel.converter.CollectionConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.apache.camel.Converter;
/**
 * Some core java.util Collection based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class CollectionConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionConverter() {
    }
    /**
     * Converts a collection to an array
     */
    @Converter
    public static Object[] toArray(Collection value) {
        if (value == null) {
            return null;
        }
        return value.toArray();
    }
    /**
     * Converts an array to a collection
     */
    @Converter
    public static List toList(Object[] array) {
        return Arrays.asList(array);
    }
    /**
     * Converts a collection to a List if it is not already
     */
    @Converter
    public static List toList(Collection collection) {
        return new ArrayList(collection);
    }
    /**
     * Converts an {@link Iterator} to a {@link ArrayList}
     */
    @Converter
    public static ArrayList toArrayList(Iterator it) {
        ArrayList list = new ArrayList();
        while (it.hasNext()) {
            list.add(it.next());
        }
        return list;
    }
    @Converter
    public static Set toSet(Object[] array) {
        Set answer = new HashSet();
        answer.addAll(Arrays.asList(array));
        return answer;
    }
    @Converter
    public static Set toSet(Collection collection) {
        return new HashSet(collection);
    }
    @Converter
    public static Set toSet(Map map) {
        return map.entrySet();
    }
    @Converter
    public static Properties toProperties(Map map) {
        Properties answer = new Properties();
        answer.putAll(map);
        return answer;
    }
    @Converter
    public static Hashtable toHashtable(Map map) {
        return new Hashtable(map);
    }
    @Converter
    public static HashMap toHashMap(Map map) {
        return new HashMap(map);
    }
    /**
     * Converts an {@link Iterable} into a {@link List} 
     */
    @Converter
    public static List toList(Iterable iterable) {
        if (iterable instanceof List) {
            return (List) iterable;
        }
        List result = new LinkedList();
        for (Object value : iterable) {
            result.add(value);
        }
        return result;
    }
}
"
org.apache.camel.component.validator.SpringValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import java.io.IOException;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.processor.validation.ValidatingProcessor;
import org.springframework.core.io.Resource;
/**
 * Validator that uses Spring for reading the scheme resource.
 *
 * @version $Revision$
 */
public class SpringValidator extends ValidatingProcessor {
    private Resource schemaResource;
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    @Override
    protected Source createSchemaSource() throws IOException {
        if (schemaResource != null) {
            if (schemaResource.getURL() == null) {
                return new StreamSource(schemaResource.getInputStream());
            } else {
                return new StreamSource(schemaResource.getInputStream(), schemaResource.getURL().toExternalForm());
            }
        } else {
            throw new IllegalArgumentException(""You must specify a schema, schemaFile, schemaResource, schemaSource or schemaUrl property"");
        }
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
/**
 * The name space handler Spring Integration Camel Adapter
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""camelSource"", new CamelSourceAdpaterParser());
        registerBeanDefinitionParser(""camelTarget"", new CamelTargetAdapterParser());
    }
}
"
org.apache.camel.impl.EventDrivenConsumerRoute,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.Service;
/**
 * A {@link Route} which starts with an
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
 *
 * @version $Revision$
 */
public class EventDrivenConsumerRoute<E extends Exchange> extends Route<E> {
    private Processor processor;
    public EventDrivenConsumerRoute(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""EventDrivenConsumerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    /**
     * Factory method to lazily create the complete list of services required for this route
     * such as adding the processor or consumer
     */
    @Override
    protected void addServices(List<Service> services) throws Exception {
        Endpoint<E> endpoint = getEndpoint();
        Consumer<E> consumer = endpoint.createConsumer(processor);
        if (consumer != null) {
            services.add(consumer);
        }
        Processor processor = getProcessor();
        if (processor instanceof Service) {
            services.add((Service)processor);
        }
    }
}
"
org.apache.camel.component.restlet.RestletProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.restlet.Client;
import org.restlet.data.Request;
import org.restlet.data.Response;
/**
 * A Camel producer that acts as a client to Restlet server.
 *
 * @version $Revision$
 */
public class RestletProducer extends DefaultProducer {
    private static final Log LOG = LogFactory.getLog(RestletProducer.class);
    private Client client;
    public RestletProducer(RestletEndpoint endpoint) throws Exception {
        super(endpoint);
        client = new Client(endpoint.getProtocol());
    }
    @Override
    public void doStart() throws Exception {
        super.doStart();
        client.start();
    }
    @Override
    public void doStop() throws Exception {
        client.stop();
        super.doStop();
    }
    public void process(Exchange exchange) throws Exception {
        RestletEndpoint endpoint = (RestletEndpoint)getEndpoint();
        String resourceUri = buildUri(endpoint);
        Request request = new Request(endpoint.getRestletMethod(), 
                resourceUri);
        RestletBinding binding = endpoint.getRestletBinding();
        binding.populateRestletRequestFromExchange(request, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Client sends a request (method: "" + request.getMethod() 
                    + "", uri: "" + resourceUri + "")"");
        }
        Response response = client.handle(request);
        binding.populateExchangeFromRestletResponse(exchange, response);
    }
    private static String buildUri(RestletEndpoint endpoint) {
        return endpoint.getProtocol() + ""://"" + endpoint.getHost() + "":"" 
            + endpoint.getPort() + endpoint.getUriPattern();
    }
}
"
org.apache.camel.component.cxf.AsyncProcessorDecorator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.AsyncProcessorHelper;
/**
 * A simple class to wrap an existing processor (synchronous or asynchronous)
 * with two synchronous processors that will be executed before and after the
 * main processor.
 */
public class AsyncProcessorDecorator implements AsyncProcessor {
    private final AsyncProcessor processor;
    private final Processor before;
    private final Processor after;
    public AsyncProcessorDecorator(Processor processor, Processor before, Processor after) {
        this.processor = AsyncProcessorTypeConverter.convert(processor);
        this.before = before;
        this.after = after;
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        try {
            before.process(exchange);
        } catch (Throwable t) {
            exchange.setException(t);
            callback.done(true);
            return true;
        }
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                try {
                    after.process(exchange);
                    callback.done(doneSynchronously);
                } catch (Throwable t) {
                    exchange.setException(t);
                }
            }
        });
    }
}
"
org.apache.camel.component.jpa.DeleteHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
/**
 * A strategy for deleting entity beans which have been processed; either by a real delete or by an update of some
 * application specific properties so that the entity bean will not be found in future polling queries.
 *
 * @version $Revision$
 */
public interface DeleteHandler<T> {
    /**
     * Deletes the entity bean after it has been processed either by actually
     * deleting the object or updating it in a way so that future queries do not return this object again.
     *
     * @param entityManager
     * @param entityBean    the entity bean that has been processed and should be deleted
     */
    void deleteObject(EntityManager entityManager, Object entityBean);
}
"
org.apache.camel.impl.ProducerTemplateProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.util.ObjectHelper;
/**
 * A simple processor which just sends the message exchange to the default endpoint of the {@link ProducerTemplate}
 *
 * @version $Revision$
 */
public class ProducerTemplateProcessor implements Processor {
    private final ProducerTemplate producerTemplate;
    public ProducerTemplateProcessor(ProducerTemplate producerTemplate) {
        this.producerTemplate = producerTemplate;
        ObjectHelper.notNull(producerTemplate,  ""producerTemplate"");
    }
    public void process(Exchange exchange) throws Exception {
        producerTemplate.send(exchange);
    }
    @Override
    public String toString() {
        return ""ProducerTemplateProcessor["" + producerTemplate + ""]"";
    }
}
"
org.apache.camel.NoSuchEndpointException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if a routing processor such as a
 * {@link org.apache.camel.processor.RecipientList RecipientList} is unable to resolve an
 * {@link Endpoint} from a URI.
 *
 * @version $Revision$
 */
public class NoSuchEndpointException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String uri;
    public NoSuchEndpointException(String uri) {
        super(""No endpoint could be found for: "" + uri
              + "", please check your classpath contains the needed camel component jar."");
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.component.jms.MessagePropertyNamesAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyNamesAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessagePropertyNamesAccessException(JMSException e) {
        super(""Failed to access the JMS message property names: "" + e, e);
    }
}
"
org.apache.camel.component.direct.DirectProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The direct producer.
 *
 * @version $Revision$
 */
public class DirectProducer<E extends Exchange> extends DefaultProducer implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(DirectProducer.class);
    private DirectEndpoint<E> endpoint;
    public DirectProducer(DirectEndpoint<E> endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        if (endpoint.getConsumers().isEmpty()) {
            LOG.warn(""No getConsumers() available on "" + this + "" for "" + exchange);
        } else {
            for (DefaultConsumer<E> consumer : endpoint.getConsumers()) {
                consumer.getProcessor().process(exchange);
            }
        }
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        int size = endpoint.getConsumers().size();
        if (size == 0) {
            LOG.warn(""No getConsumers() available on "" + this + "" for "" + exchange);
        } else if (size == 1) {
            DefaultConsumer<E> consumer = endpoint.getConsumers().get(0);
            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(consumer.getProcessor());
            return processor.process(exchange, callback);
        } else if (size > 1) {
            // Too hard to do multiple async.. do it sync
            try {
                for (DefaultConsumer<E> consumer : endpoint.getConsumers()) {
                    consumer.getProcessor().process(exchange);
                }
            } catch (Throwable error) {
                exchange.setException(error);
            }
        }
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.Pattern,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a method as having a specific kind of {@link ExchangePattern} for use with
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a> or
 * <a href=""http://activemq.apache.org/camel/spring-remoting.html"">Spring Remoting</a>
 * to overload the default value which is {@link ExchangePattern#InOut} for request/reply if no annotations are used.
 *
 * There are abbreviation annotations like {@link InOnly} or {@link InOut} which are typically used for
 * the common message exchange patterns. You could also add this annotation onto your own custom annotation to default
 * the message exchange pattern when your own annotation is added to a method
 * <a href=""using-exchange-pattern-annotations.html"">as in this example</a>.
 *
 * This annotation can be added to individual methods or added to a class or interface to act as a default for all methods
 * within the class or interface.
 *
 * See the <a href=""using-exchange-pattern-annotations.html"">using exchange pattern annotations</a>
 * for more details on how the overloading rules work.
 *
 * @see InOut
 * @see InOnly
 * @see ExchangePattern
 * @see Exchange#getPattern()
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Pattern {
    /**
     * Specifies the exchange pattern to be used for this method
     */
    ExchangePattern value();
}"
org.apache.camel.InvalidPayloadRuntimeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Runtime version of the {@link org.apache.camel.InvalidTypeException}.
 *
 * @version $Revision$
 */
public class InvalidPayloadRuntimeException extends RuntimeExchangeException {
    private final Class<?> type;
    public InvalidPayloadRuntimeException(Exchange exchange, Class<?> type) {
        super(""No in body available of type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(exchange.getIn().getBody()), exchange);
        this.type = type;
    }
    /**
     * The expected type of the body
     */
    public Class<?> getType() {
        return type;
    }
}"
org.apache.camel.component.sql.SqlEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.util.Map;
import javax.sql.DataSource;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.util.IntrospectionSupport;
import org.springframework.jdbc.core.JdbcTemplate;
/**
 * SQL Endpoint. Endpoint URI should contain valid SQL statement, but instead of
 * question marks (that are parameter placeholders), sharp signs should be used.
 * This is because in camel question mark has other meaning.
 */
public class SqlEndpoint extends DefaultEndpoint {
    private JdbcTemplate jdbcTemplate;
    private String query;
    public SqlEndpoint(String uri, String query, Component component, DataSource dataSource, Map parameters) throws Exception {
        super(uri, component);
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        IntrospectionSupport.setProperties(jdbcTemplate, parameters, ""template."");
        this.query = query;
    }
    public SqlEndpoint(String endpointUri, JdbcTemplate jdbcTemplate, String query) {
        super(endpointUri);
        this.jdbcTemplate = jdbcTemplate;
        this.query = query;
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""Not implemented"");
    }
    public Producer createProducer() throws Exception {
        return new SqlProducer(this, query, jdbcTemplate);
    }
    public boolean isSingleton() {
        return false;
    }
}
"
org.apache.camel.component.vm.VmComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.vm;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.seda.SedaComponent;
import org.apache.camel.component.seda.SedaEndpoint;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/vm.html"">VM components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within the classloader tree containing
 * the camel-core.jar. i.e. to handle communicating across CamelContext instances and possibly across
 * web application contexts, providing that camel-core.jar is on the system classpath.
 *
 * @version $Revision$
 */
public class VmComponent extends SedaComponent {
    protected static final Map<String, BlockingQueue> QUEUES = new HashMap<String, BlockingQueue>();
    private static final AtomicInteger START_COUNTER = new AtomicInteger();
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        BlockingQueue<Exchange> blockingQueue = getBlockingQueue(uri, parameters);
        return new SedaEndpoint(uri, this, blockingQueue);
    }
    protected BlockingQueue<Exchange> getBlockingQueue(String uri, Map parameters) {
        synchronized (QUEUES) {
            BlockingQueue<Exchange> answer = QUEUES.get(uri);
            if (answer == null) {
                answer = createQueue(uri, parameters);
                QUEUES.put(uri, answer);
            }
            return answer;
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        START_COUNTER.incrementAndGet();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (START_COUNTER.decrementAndGet() == 0) {
            synchronized (QUEUES) {
                for (BlockingQueue q : QUEUES.values()) {
                    q.clear();
                }
                QUEUES.clear();
            }
        }
    }
}
"
org.apache.camel.component.jms.QueueBrowseStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.List;
import org.apache.camel.Exchange;
import org.springframework.jms.core.JmsOperations;
/**
 * @version $Revision$
 */
public interface QueueBrowseStrategy {
    List<Exchange> browse(JmsOperations template, String queue, JmsQueueEndpoint endpoint);
}
"
org.apache.camel.CamelContextAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An interface to represent an object which wishes to be injected with
 * a {@link CamelContext} such as when working with Spring or Guice
 *
 * @version $Revision$
 */
public interface CamelContextAware {
    /**
     * Injects the {@link CamelContext}
     *
     * @param camelContext
     */
    void setCamelContext(CamelContext camelContext);
}
"
org.apache.camel.builder.ErrorHandlerBuilderSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.ErrorHandlerSupport;
/**
 * Base class for builders of error handling.
 *
 * @version $Revision$
 */
public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder {
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    public void addErrorHandlers(ExceptionType exception) {
        exceptions.add(exception);
    }
    protected void configure(ErrorHandlerSupport handler) {
        for (ExceptionType exception : exceptions) {
            handler.addExceptionPolicy(exception);
        }
    }
    public List<ExceptionType> getExceptions() {
        return exceptions;
    }
    public void setErrorHandlers(List<ExceptionType> exceptions) {
        this.exceptions.clear();
        this.exceptions.addAll(exceptions);
    }
}
"
org.apache.camel.component.seda.SedaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/seda.html"">SEDA components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision$
 */
public class SedaComponent extends DefaultComponent<Exchange> {
    public BlockingQueue<Exchange> createQueue(String uri, Map parameters) {
        int size = getAndRemoveParameter(parameters, ""size"", Integer.class, 1000);
        return new LinkedBlockingQueue<Exchange>(size);
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new SedaEndpoint(uri, this, parameters);
    }
}
"
org.apache.camel.component.cxf.invoker.InvokingContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import org.apache.camel.component.cxf.DataFormat;
public final class InvokingContextFactory {
    private InvokingContextFactory() {
        // not constructed
    }
    /**
     * Static method that creates a routing context object from a given data format
     * @param dataFormat
     * @return routing context
     */
    public static InvokingContext createContext(DataFormat dataFormat) {
        if (dataFormat == DataFormat.MESSAGE) {
            return new RawMessageInvokingContext();
        }
        if (dataFormat == DataFormat.PAYLOAD) {
            return new PayloadInvokingContext();
        }
        //Default is DataFormat.MESSAGE, we do not set the POJO context
        return new RawMessageInvokingContext();
    }
}
"
org.apache.camel.component.jms.JmsEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.TemporaryQueue;
import javax.jms.TemporaryTopic;
import org.apache.camel.ExchangePattern;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 *
 * @version $Revision:520964 $
 */
public class JmsEndpoint extends DefaultEndpoint<JmsExchange> {
    private final boolean pubSubDomain;
    private JmsBinding binding;
    private String destination;
    private String selector;
    private JmsConfiguration configuration;
    private Requestor requestor;
    public JmsEndpoint(String uri, JmsComponent component, String destination, boolean pubSubDomain, JmsConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
    }
    public JmsEndpoint(String endpointUri, JmsBinding binding, JmsConfiguration configuration, String destination, boolean pubSubDomain) {
        super(endpointUri);
        this.binding = binding;
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
    }
    public JmsEndpoint(String endpointUri, String destination, boolean pubSubDomain) {
        this(endpointUri, new JmsBinding(), new JmsConfiguration(), destination, pubSubDomain);
    }
    /**
     * Creates a pub-sub endpoint with the given destination
     */
    public JmsEndpoint(String endpointUri, String destination) {
        this(endpointUri, destination, true);
    }
    public JmsProducer createProducer() throws Exception {
        return new JmsProducer(this);
    }
    /**
     * Creates a producer using the given template for InOnly message exchanges
     */
    public JmsProducer createProducer(JmsOperations template) throws Exception {
        JmsProducer answer = createProducer();
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate) template;
            jmsTemplate.setPubSubDomain(pubSubDomain);
            jmsTemplate.setDefaultDestinationName(destination);
        }
        answer.setInOnlyTemplate(template);
        return answer;
    }
    public JmsConsumer createConsumer(Processor processor) throws Exception {
        AbstractMessageListenerContainer listenerContainer = configuration.createMessageListenerContainer(this);
        return createConsumer(processor, listenerContainer);
    }
    /**
     * Creates a consumer using the given processor and listener container
     *
     * @param processor         the processor to use to process the messages
     * @param listenerContainer the listener container
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {
        listenerContainer.setDestinationName(destination);
        listenerContainer.setPubSubDomain(pubSubDomain);
        return new JmsConsumer(this, processor, listenerContainer);
    }
    @Override
    public PollingConsumer<JmsExchange> createPollingConsumer() throws Exception {
        JmsOperations template = createInOnlyTemplate();
        return new JmsPollingConsumer(this, template);
    }
    @Override
    public JmsExchange createExchange(ExchangePattern pattern) {
        return new JmsExchange(getCamelContext(), pattern, getBinding());
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    /**
     * Factory method for creating a new template for InOnly message exchanges
     */
    public JmsOperations createInOnlyTemplate() {
        return configuration.createInOnlyTemplate(this, pubSubDomain, destination);
    }
    /**
     * Factory method for creating a new template for InOut message exchanges
     */
    public JmsOperations createInOutTemplate() {
        return configuration.createInOutTemplate(this, pubSubDomain, destination, getRequestTimeout());
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding(this);
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public String getDestination() {
        return destination;
    }
    public JmsConfiguration getConfiguration() {
        return configuration;
    }
    public String getSelector() {
        return selector;
    }
    /**
     * Sets the JMS selector to use
     */
    public void setSelector(String selector) {
        this.selector = selector;
    }
    public boolean isSingleton() {
        return false;
    }
    public synchronized Requestor getRequestor() throws Exception {
        if (requestor == null) {
            requestor = new Requestor(getConfiguration(), getExecutorService());
            requestor.start();
        }
        return requestor;
    }
    public void setRequestor(Requestor requestor) {
        this.requestor = requestor;
    }
    /**
     * @deprecated use configuration.requestTimeout. Will be removed in Camel 2.0
     */
    public long getRequestTimeout() {
        return configuration.getRequestTimeout();
    }
    /**
     * Sets the timeout in milliseconds which requests should timeout after
     *
     * @deprecated use configuration.requestTimeout. Will be removed in Camel 2.0
     */
    public void setRequestTimeout(long requestTimeout) {
        configuration.setRequestTimeout(requestTimeout);
    }
    public boolean isPubSubDomain() {
        return pubSubDomain;
    }
    /**
     * Lazily loads the temporary queue type if one has not been explicitly configured
     * via calling the {@link JmsProviderMetadata#setTemporaryQueueType(Class)}
     * on the {@link #getConfiguration()} instance
     */
    public Class<? extends TemporaryQueue> getTemporaryQueueType() {
        JmsProviderMetadata metadata = getProviderMetadata();
        JmsOperations template = getMetadataJmsOperations();
        return metadata.getTemporaryQueueType(template);
    }
    /**
     * Lazily loads the temporary topic type if one has not been explicitly configured
     * via calling the {@link JmsProviderMetadata#setTemporaryTopicType(Class)}
     * on the {@link #getConfiguration()} instance
     */
    public Class<? extends TemporaryTopic> getTemporaryTopicType() {
        JmsOperations template = getMetadataJmsOperations();
        JmsProviderMetadata metadata = getProviderMetadata();
        return metadata.getTemporaryTopicType(template);
    }
    /**
     * Returns the provider metadata
     */
    protected JmsProviderMetadata getProviderMetadata() {
        JmsConfiguration conf = getConfiguration();
        JmsProviderMetadata metadata = conf.getProviderMetadata();
        return metadata;
    }
    /**
     * Returns the {@link JmsOperations} used for metadata operations such as creating temporary destinations
     */
    protected JmsOperations getMetadataJmsOperations() {
        JmsOperations template = getConfiguration().getMetadataJmsOperations(this);
        if (template == null) {
            throw new IllegalArgumentException(""No Metadata JmsTemplate supplied!"");
        }
        return template;
    }
    public void checkValidTemplate(JmsTemplate template) {
        if (template.getDestinationResolver() == null) {
            if (this instanceof DestinationEndpoint) {
                final DestinationEndpoint destinationEndpoint = (DestinationEndpoint) this;
                template.setDestinationResolver(JmsConfiguration.createDestinationResolver(destinationEndpoint));
            }
        }
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        if (getComponent() instanceof HeaderFilterStrategyAware) {
            return ((HeaderFilterStrategyAware)getComponent()).getHeaderFilterStrategy();
        } else {
            return new JmsHeaderFilterStrategy();
        }
    }
}
"
org.apache.camel.component.atom.AtomProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * AtomProducer is currently not implemented
 *
 * @version $Revision$
 */
public class AtomProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(AtomProducer.class);
    private final AtomEndpoint endpoint;
    public AtomProducer(AtomEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        throw new UnsupportedOperationException(""AtomProducer is not implemented"");
    }
}
"
org.apache.camel.component.cxf.CxfSoapBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import javax.xml.transform.Source;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.component.cxf.util.CxfHeaderHelper;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.MessageImpl;
public final class CxfSoapBinding {
    private static final Log LOG = LogFactory.getLog(CxfSoapBinding.class);
    private CxfSoapBinding() {
    }
    /**
     * @deprecated  Please use {@link #getCxfInMessage(HeaderFilterStrategy, org.apache.camel.Exchange, boolean)}
     */
    public static org.apache.cxf.message.Message getCxfInMessage(org.apache.camel.Exchange exchange, boolean isClient) {
        return CxfSoapBinding.getCxfInMessage(new DefaultHeaderFilterStrategy(), exchange, isClient);
    }
    public static org.apache.cxf.message.Message getCxfInMessage(HeaderFilterStrategy headerFilterStrategy,
            org.apache.camel.Exchange exchange, boolean isClient) {
        MessageImpl answer = new MessageImpl();
        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE,
                                                                        org.apache.cxf.message.Exchange.class);
        org.apache.camel.Message message = null;
        if (isClient) {
            message = exchange.getOut();
        } else {
            message = exchange.getIn();
        }
        ObjectHelper.notNull(message, ""message"");
        if (cxfExchange == null) {
            cxfExchange = new ExchangeImpl();
            exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);
        }
        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), answer);
        try {
            InputStream body = message.getBody(InputStream.class);
            answer.setContent(InputStream.class, body);
        } catch (NoTypeConversionAvailableException ex) {
            LOG.warn(""Can't get right InputStream object here, the message body is "" + message.getBody());
        }
        answer.putAll(message.getHeaders());
        answer.setExchange(cxfExchange);
        cxfExchange.setInMessage(answer);
        return answer;
    }
    /**
     * @deprecated Please use {@link #getCxfOutMessage(HeaderFilterStrategy, org.apache.camel.Exchange, boolean)}
     */
    public static org.apache.cxf.message.Message getCxfOutMessage(org.apache.camel.Exchange exchange, boolean isClient) {
        return CxfSoapBinding.getCxfOutMessage(new DefaultHeaderFilterStrategy(), exchange, isClient);
    }
    public static org.apache.cxf.message.Message getCxfOutMessage(HeaderFilterStrategy headerFilterStrategy,
            org.apache.camel.Exchange exchange, boolean isClient) {
        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE, org.apache.cxf.message.Exchange.class);
        ObjectHelper.notNull(cxfExchange, ""cxfExchange"");
        org.apache.cxf.endpoint.Endpoint cxfEndpoint = cxfExchange.get(org.apache.cxf.endpoint.Endpoint.class);
        org.apache.cxf.message.Message outMessage = cxfEndpoint.getBinding().createMessage();
        outMessage.setExchange(cxfExchange);
        cxfExchange.setOutMessage(outMessage);
        org.apache.camel.Message message = null;
        if (isClient) {
            message = exchange.getIn();
        } else {
            message = exchange.getOut();
        }
        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), outMessage);
        // send the body back
        try {
            Source body = message.getBody(Source.class);
            outMessage.setContent(Source.class, body);
        } catch (NoTypeConversionAvailableException ex) {
            LOG.warn(""Can't get right Source object here, the message body is "" + message.getBody());
        }
        outMessage.putAll(message.getHeaders());
        return outMessage;
    }
    /**
     * @deprecated Please use {@link CxfHeaderHelper#propagateCxfToCamel(HeaderFilterStrategy, org.apache.cxf.message.Message, Map)}
     */
    public static void setProtocolHeader(Map<String, Object> headers, Map<String, List<String>> protocolHeader) {
        if (protocolHeader != null) {
            StringBuilder value = new StringBuilder(256);
            for (Map.Entry<String, List<String>> entry : protocolHeader.entrySet()) {
                value.setLength(0);
                boolean first = true;
                for (String s : entry.getValue()) {
                    if (!first) {
                        value.append(""; "");
                    }
                    value.append(s);
                    first = false;
                }
                headers.put(entry.getKey(), value.toString());
            }
        }
    }
}
"
org.apache.camel.impl.DefaultEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.util.ObjectHelper;
/**
 * A default endpoint useful for implementation inheritance
 *
 * @version $Revision$
 */
public abstract class DefaultEndpoint<E extends Exchange> implements Endpoint<E>, CamelContextAware {
    private String endpointUri;
    private CamelContext camelContext;
    private Component component;
    private ScheduledExecutorService executorService;
    private ExchangePattern exchangePattern = ExchangePattern.InOnly;
    protected DefaultEndpoint(String endpointUri, Component component) {
        this(endpointUri, component.getCamelContext());
        this.component = component;
    }
    protected DefaultEndpoint(String endpointUri, CamelContext camelContext) {
        this(endpointUri);
        this.camelContext = camelContext;
    }
    protected DefaultEndpoint(String endpointUri) {
        this.setEndpointUri(endpointUri);
    }
    protected DefaultEndpoint() {
    }
    public int hashCode() {
        return getEndpointUri().hashCode() * 37 + 1;
    }
    @Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint) object;
            return ObjectHelper.equal(this.getEndpointUri(), that.getEndpointUri());
        }
        return false;
    }
    @Override
    public String toString() {
        return ""Endpoint["" + getEndpointUri() + ""]"";
    }
    public String getEndpointUri() {
        if (endpointUri == null) {
            endpointUri = createEndpointUri();
            if (endpointUri == null) {
                throw new IllegalArgumentException(""endpointUri is not specified and "" + getClass().getName()
                        + "" does not implement createEndpointUri() to create a default value"");
            }
        }
        return endpointUri;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public Component getComponent() {
        return component;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public synchronized ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            Component c = getComponent();
            if (c != null && c instanceof DefaultComponent) {
                DefaultComponent dc = (DefaultComponent) c;
                executorService = dc.getExecutorService();
            }
            if (executorService == null) {
                executorService = createExecutorService();
            }
        }
        return executorService;
    }
    public synchronized void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    public PollingConsumer<E> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<E>(this);
    }
    /**
     * Converts the given exchange to the specified exchange type
     */
    public E convertTo(Class<E> type, Exchange exchange) {
        // TODO we could infer type parameter
        if (type.isInstance(exchange)) {
            return type.cast(exchange);
        }
        return getCamelContext().getExchangeConverter().convertTo(type, exchange);
    }
    public E createExchange(Exchange exchange) {
        Class<E> exchangeType = getExchangeType();
        if (exchangeType != null) {
            if (exchangeType.isInstance(exchange)) {
                return exchangeType.cast(exchange);
            }
        }
        E answer = createExchange();
        answer.copyFrom(exchange);
        return answer;
    }
    /**
     * Returns the type of the exchange which is generated by this component
     */
    public Class<E> getExchangeType() {
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    return (Class<E>) argumentType;
                }
            }
        }
        return null;
    }
    public E createExchange() {
        return createExchange(getExchangePattern());
    }
    public E createExchange(ExchangePattern pattern) {
        return (E) new DefaultExchange(getCamelContext(), pattern);
    }
    public ExchangePattern getExchangePattern() {
        return exchangePattern;
    }
    public void setExchangePattern(ExchangePattern exchangePattern) {
        this.exchangePattern = exchangePattern;
    }
    protected ScheduledThreadPoolExecutor createExecutorService() {
        return new ScheduledThreadPoolExecutor(10);
    }
    public void configureProperties(Map options) {
    }
    /**
     * A factory method to lazily create the endpointUri if none is specified 
     */
    protected String createEndpointUri() {
        return null;
    }
    protected void setEndpointUri(String endpointUri) {
        this.endpointUri = endpointUri;
    }
    @Deprecated
    public CamelContext getContext() {
        return getCamelContext();
    }
    @Deprecated
    public void setContext(CamelContext context) {
        setCamelContext(context);
    }
    public boolean isLenientProperties() {
        // default should be false for most components
        return false;
    }
}
"
org.apache.camel.Converter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation used to mark classes and methods to indicate code capable of
 * converting from a type to another type which are then auto-discovered using
 * the <a href=""http://activemq.apache.org/camel/type-converter.html"">Type
 * Conversion Support</a>
 * 
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD })
public @interface Converter {
}
"
org.apache.camel.component.http.BasicAuthenticationHttpClientConfigurer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.commons.httpclient.Credentials;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.UsernamePasswordCredentials;
import org.apache.commons.httpclient.auth.AuthScope;
public class BasicAuthenticationHttpClientConfigurer implements HttpClientConfigurer {
    private final String username;
    private final String password;
    public BasicAuthenticationHttpClientConfigurer(String user, String pwd) {
        username = user;
        password = pwd;
    }
    public void configureHttpClient(HttpClient client) {
        Credentials defaultcreds = new UsernamePasswordCredentials(username, password);
        client.getState().setCredentials(AuthScope.ANY, defaultcreds);
    }
}
"
org.apache.camel.impl.ProducerCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * Cache containing created {@link Producer}.
 *
 * @version $Revision$
 */
public class ProducerCache<E extends Exchange> extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(ProducerCache.class);
    private Map<String, Producer<E>> producers = new HashMap<String, Producer<E>>();
    public synchronized Producer<E> getProducer(Endpoint<E> endpoint) {
        String key = endpoint.getEndpointUri();
        Producer<E> answer = producers.get(key);
        if (answer == null) {
            try {
                answer = endpoint.createProducer();
                answer.start();
            } catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            }
            producers.put(key, answer);
        }
        return answer;
    }
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public void send(Endpoint<E> endpoint, E exchange) {
        try {
            Producer<E> producer = getProducer(endpoint);
            producer.process(exchange);
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange.  The callback
     * will be called when the exchange is completed.
     *
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            boolean sync = sendExchange(endpoint, producer, processor, exchange, callback);
            setProcessedSync(exchange, sync);
            return exchange;
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    public static boolean isProcessedSync(Exchange exchange) {
        Boolean rc = exchange.getProperty(ProducerCache.class.getName() + "".SYNC"", Boolean.class);
        return rc == null ? false : rc;
    }
    public static void setProcessedSync(Exchange exchange, boolean b) {
        exchange.setProperty(ProducerCache.class.getName() + "".SYNC"", b ? Boolean.TRUE : Boolean.FALSE);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange(pattern);
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
    }
    protected E sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        producer.process(exchange);
        return exchange;
    }
    protected boolean sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange, AsyncCallback callback) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        return AsyncProcessorTypeConverter.convert(producer).process(exchange, callback);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producers.values());
        producers.clear();
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.component.cxf.util.WSDLSoapServiceFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import javax.xml.namespace.QName;
import org.apache.cxf.binding.AbstractBindingFactory;
import org.apache.cxf.binding.soap.interceptor.CheckFaultInterceptor;
import org.apache.cxf.binding.soap.interceptor.MustUnderstandInterceptor;
import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionOutInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapHeaderInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapHeaderOutFilterInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapOutInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapPreProtocolOutInterceptor;
import org.apache.cxf.interceptor.AttachmentInInterceptor;
import org.apache.cxf.interceptor.AttachmentOutInterceptor;
import org.apache.cxf.interceptor.StaxInInterceptor;
import org.apache.cxf.interceptor.StaxOutInterceptor;
import org.apache.cxf.interceptor.URIMappingInterceptor;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.service.model.ServiceInfo;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
//The service factorybean which just create the service for soap component
public class WSDLSoapServiceFactoryBean extends ReflectionServiceFactoryBean {
    private QName serviceName;
    private QName endpointName;
    @Override
    public Service create() {
        WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), getWsdlURL(), getServiceQName());
        setService(factory.create());
        initializeSoapInterceptors();
        //disable the date interceptors
        updateEndpointInfors();
        createEndpoints();
        return getService();
    }
    private void updateEndpointInfors() {
        Service service = getService();
        for (ServiceInfo inf : service.getServiceInfos()) {
            for (EndpointInfo ei : inf.getEndpoints()) {
                //setup the endpoint address
                ei.setAddress(""local://"" + ei.getService().getName().toString() + ""/"" + ei.getName().getLocalPart());
                // working as the dispatch mode, the binding factory will not add interceptor
                ei.getBinding().setProperty(AbstractBindingFactory.DATABINDING_DISABLED, Boolean.TRUE);
            }
        }
    }
    protected void checkServiceClassAnnotations(Class<?> sc) {
        // do nothing here
    }
    // do not handle any payload information here
    private void initializeSoapInterceptors() {
        getService().getInInterceptors().add(new DataInInterceptor());
        getService().getInInterceptors().add(new ReadHeadersInterceptor(getBus()));
        getService().getInInterceptors().add(new MustUnderstandInterceptor());
        getService().getInInterceptors().add(new AttachmentInInterceptor());
        getService().getInInterceptors().add(new SoapHeaderInterceptor());
        getService().getInInterceptors().add(new CheckFaultInterceptor());
        getService().getInInterceptors().add(new URIMappingInterceptor());
        getService().getInInterceptors().add(new StaxInInterceptor());
        getService().getInInterceptors().add(new SoapActionInInterceptor());
        getService().getOutInterceptors().add(new DataOutInterceptor());
        getService().getOutInterceptors().add(new SoapActionOutInterceptor());
        getService().getOutInterceptors().add(new AttachmentOutInterceptor());
        getService().getOutInterceptors().add(new StaxOutInterceptor());
        getService().getOutInterceptors().add(new SoapHeaderOutFilterInterceptor());
        getService().getOutInterceptors().add(new SoapPreProtocolOutInterceptor());
        getService().getOutInterceptors().add(new SoapOutInterceptor(getBus()));
        getService().getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));
    }
    public void setServiceName(QName name) {
        serviceName = name;
    }
    public String getServiceName() {
        return serviceName.toString();
    }
    public QName getServiceQName() {
        return serviceName;
    }
    public QName getEndpointName() {
        // get the endpoint name if it is not set
        if (endpointName == null) {
            endpointName = getService().getEndpoints().keySet().iterator().next();
        }
        return endpointName;
    }
    public void setEndpointName(QName name) {
        endpointName = name;
    }
}
"
org.apache.camel.Properties,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the properties of an {@link Exchange}
 *
 * @see Exchange#getProperties()  
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Properties {
}"
org.apache.camel.component.validator.jing.JingValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import com.thaiopensource.relaxng.SchemaFactory;
import com.thaiopensource.util.PropertyMap;
import com.thaiopensource.util.PropertyMapBuilder;
import com.thaiopensource.validate.IncorrectSchemaException;
import com.thaiopensource.validate.Schema;
import com.thaiopensource.validate.ValidateProperty;
import com.thaiopensource.validate.Validator;
import com.thaiopensource.xml.sax.Jaxp11XMLReaderCreator;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.processor.validation.DefaultValidationErrorHandler;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.Resource;
/**
 * A validator which uses the <a
 * href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing</a> library to
 * validate XML against RelaxNG
 * 
 * @version $Revision$
 */
public class JingValidator implements Processor {
    private static final transient Log LOG = LogFactory.getLog(JingValidator.class);
    private Schema schema;
    private SchemaFactory schemaFactory;
    private String schemaNamespace = XMLConstants.RELAXNG_NS_URI;
    private Resource schemaResource;
    private InputSource inputSource;
    private boolean compactSyntax;
    public void process(Exchange exchange) throws Exception {
        Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator();
        DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler();
        PropertyMapBuilder mapBuilder = new PropertyMapBuilder();
        mapBuilder.put(ValidateProperty.XML_READER_CREATOR, xmlCreator);
        mapBuilder.put(ValidateProperty.ERROR_HANDLER, errorHandler);
        PropertyMap propertyMap = mapBuilder.toPropertyMap();
        Validator validator = getSchema().createValidator(propertyMap);
        Message in = exchange.getIn();
        SAXSource saxSource = in.getBody(SAXSource.class);
        if (saxSource == null) {
            Source source = ExchangeHelper.getMandatoryInBody(exchange, Source.class);
            saxSource = ExchangeHelper.convertToMandatoryType(exchange, SAXSource.class, source);
        }
        InputSource bodyInput = saxSource.getInputSource();
        // now lets parse the body using the validator
        XMLReader reader = xmlCreator.createXMLReader();
        reader.setContentHandler(validator.getContentHandler());
        reader.setDTDHandler(validator.getDTDHandler());
        reader.setErrorHandler(errorHandler);
        reader.parse(bodyInput);
        errorHandler.handleErrors(exchange, schema);
    }
    // Properties
    // -------------------------------------------------------------------------
    public Schema getSchema() throws IOException, IncorrectSchemaException, SAXException {
        if (schema == null) {
            SchemaFactory factory = getSchemaFactory();
            schema = factory.createSchema(getInputSource());
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public InputSource getInputSource() throws IOException {
        if (inputSource == null) {
            Resource resource = getSchemaResource();
            if (resource == null) {
                throw new IllegalArgumentException(""No schemaResource or inputSource specified"");
            } else {
                InputStream inputStream = resource.getInputStream();
                if (inputStream == null) {
                    throw new IllegalArgumentException(""No inputStream available for: "" + resource);
                }
                inputSource = new InputSource(inputStream);
            }
        }
        return inputSource;
    }
    public void setInputSource(InputSource inputSource) {
        this.inputSource = inputSource;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = new SchemaFactory();
            schemaFactory.setCompactSyntax(compactSyntax);
            schemaFactory.setXMLReaderCreator(new Jaxp11XMLReaderCreator());
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    public String getSchemaNamespace() {
        return schemaNamespace;
    }
    public void setSchemaNamespace(String schemaNamespace) {
        this.schemaNamespace = schemaNamespace;
    }
    public boolean isCompactSyntax() {
        return compactSyntax;
    }
    public void setCompactSyntax(boolean compactSyntax) {
        this.compactSyntax = compactSyntax;
    }
}
"
org.apache.camel.component.spring.integration.adapter.AbstractCamelAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
/**
 * The Abstract class for the Spring Integration Camel Adapter
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public abstract class AbstractCamelAdapter {
    private CamelContext camelContext;
    private String camelEndpointUri;
    private volatile boolean expectReply = true;
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public String getCamelEndpointUri() {
        return camelEndpointUri;
    }
    public void setCamelEndpointUri(String uri) {
        camelEndpointUri = uri;
    }
    public void setExpectReply(boolean expectReply) {
        this.expectReply = expectReply;
    }
    public boolean isExpectReply() {
        return expectReply;
    }
}
"
org.apache.camel.Headers,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the headers of an inbound {@link Message}
 *
 * @see Message#getHeaders()
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Headers {
}"
org.apache.camel.spring.handler.ScriptDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Element;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
/**
 * A parser of the various scripting language expressions
 *
 * @version $Revision$
 */
public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser {
    private final String scriptEngineName;
    public ScriptDefinitionParser(String scriptEngineName) {
        super(""org.apache.camel.builder.script.ScriptBuilder"", ""camel-script"");
        this.scriptEngineName = scriptEngineName;
    }
    @Override
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        // lets create a child context
        String engine = scriptEngineName;
        if (engine == null) {
            engine = element.getAttribute(""language"");
        }
        builder.addConstructorArgValue(engine);
        super.doParse(element, parserContext, builder);
        String scriptText = DomUtils.getTextValue(element).trim();
        if (scriptText.length() > 0) {
            builder.addPropertyValue(""scriptText"", scriptText);
        }
    }
}
"
org.apache.camel.component.bean.ParameterInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.Expression;
/**
 * Parameter information to be used for method invocation.
 *
 * @version $Revision$
 */
public class ParameterInfo {
    private final int index;
    private final Class type;
    private final Annotation[] annotations;
    private Expression expression;
    public ParameterInfo(int index, Class type, Annotation[] annotations, Expression expression) {
        this.index = index;
        this.type = type;
        this.annotations = annotations;
        this.expression = expression;
    }
    public Annotation[] getAnnotations() {
        return annotations;
    }
    public Expression getExpression() {
        return expression;
    }
    public int getIndex() {
        return index;
    }
    public Class getType() {
        return type;
    }
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
}
"
org.apache.camel.component.rmi.RmiConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanInvocation;
import org.apache.camel.impl.DefaultConsumer;
/**
 * A {@link org.apache.camel.Consumer Consumer} which uses RMI's {@link UnicastRemoteObject} to consume
 * method invocations.
 * 
 * @version $Revision$
 */
public class RmiConsumer extends DefaultConsumer<BeanExchange> implements InvocationHandler {
    private final RmiEndpoint endpoint;
    private Remote stub;
    private Remote proxy;
    public RmiConsumer(RmiEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        Class[] interfaces = new Class[endpoint.getRemoteInterfaces().size()];
        endpoint.getRemoteInterfaces().toArray(interfaces);
        proxy = (Remote)Proxy.newProxyInstance(endpoint.getClassLoader(), interfaces, this);
        stub = UnicastRemoteObject.exportObject(proxy, endpoint.getPort());
        try {
            Registry registry = endpoint.getRegistry();
            String name = endpoint.getName();
            registry.bind(name, stub);
        } catch (Exception e) { // Registration might fail.. clean up..
            try {
                UnicastRemoteObject.unexportObject(stub, true);
            } catch (Throwable ignore) {
            }
            stub = null;
            throw e;
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        try {
            Registry registry = endpoint.getRegistry();
            registry.unbind(endpoint.getName());
        } catch (Throwable e) { // do our best to unregister
        }
        UnicastRemoteObject.unexportObject(proxy, true);
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (!isStarted()) {
            throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
        }
        BeanInvocation invocation = new BeanInvocation(method, args);
        BeanExchange exchange = getEndpoint().createExchange();
        exchange.setInvocation(invocation);
        getProcessor().process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
    }
    public Remote getProxy() {
        return proxy;
    }
    public Remote getStub() {
        return stub;
    }
}
"
org.apache.camel.component.mina.MinaPayloadHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Holder object for sending an exchange over the wire using the MINA ObjectSerializationCodecFactory codec.
 * This is configured using the <tt>transferExchange=true</tt> option for the TCP protocol.
 * <p/>
 * As opposed to normal usage of camel-mina where only the body part of the exchange is transfered, this holder
 * object serializes the following fields over the wire:
 * <ul>
 *     <li>in body</li>
 *     <li>out body</li>
 *     <li>in headers</li>
 *     <li>out headers</li>
 *     <li>fault body </li>
 *     <li>fault headers</li>
 *     <li>exchange properties</li>
 *     <li>exception</li>
 * </ul>
 *
 * @version $Revision$
 */
public class MinaPayloadHolder implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final transient Log LOG = LogFactory.getLog(MinaPayloadHolder.class);
    private Object inBody;
    private Object outBody;
    private Object faultBody;
    private Map<String, Object> inHeaders = new LinkedHashMap<String, Object>();
    private Map<String, Object> outHeaders = new LinkedHashMap<String, Object>();
    private Map<String, Object> properties = new LinkedHashMap<String, Object>();
    private Map<String, Object> faultHeaders = new LinkedHashMap<String, Object>();
    private Throwable exception;
    /**
     * Creates a payload object with the information from the given exchange.
     * Only marshal the Serializable object
     *
     * @param exchange     the exchange
     * @return the holder object with information copied form the exchange
     */
    public static MinaPayloadHolder marshal(Exchange exchange) {
        MinaPayloadHolder payload = new MinaPayloadHolder();
        payload.inBody = checkSerializableObject(exchange.getIn().getBody());
        if (exchange.getOut(false) != null) {
            payload.outBody = checkSerializableObject(exchange.getOut().getBody());
        }
        payload.inHeaders.putAll(checkMapSerializableObjects(exchange.getIn().getHeaders()));
        payload.outHeaders.putAll(checkMapSerializableObjects(exchange.getOut().getHeaders()));
        payload.properties.putAll(checkMapSerializableObjects(exchange.getProperties()));
        payload.exception = exchange.getException();
        if (exchange.getFault(false) != null) {
            payload.faultBody = exchange.getFault().getBody();
            payload.faultHeaders.putAll(checkMapSerializableObjects(exchange.getFault().getHeaders()));
        }
        return payload;
    }
    /**
     * Transfers the information from the payload to the exchange.
     *
     * @param exchange   the exchange to set values from the payload
     * @param payload    the payload with the values
     */
    public static void unmarshal(Exchange exchange, MinaPayloadHolder payload) {
        exchange.getIn().setBody(payload.inBody);
        exchange.getOut().setBody(payload.outBody);
        exchange.getIn().setHeaders(payload.inHeaders);
        exchange.getOut().setHeaders(payload.outHeaders);
        if (payload.faultBody != null) {
            exchange.getFault().setBody(payload.faultBody);
            exchange.getFault().setHeaders(payload.faultHeaders);
        }
        for (String key : payload.properties.keySet()) {
            exchange.setProperty(key, payload.properties.get(key));
        }
        exchange.setException(payload.exception);
    }
    public String toString() {
        return ""MinaPayloadHolder{"" + ""inBody="" + inBody + "", outBody="" + outBody + "", inHeaders=""
               + inHeaders + "", outHeaders="" + outHeaders + "", faultBody="" + faultBody + "" , faultHeaders=""
               + faultHeaders + "", properties="" + properties + "", exception="" + exception + '}';
    }
    private static Object checkSerializableObject(Object object) {
        if (object instanceof Serializable) {
            return object;
        } else {
            LOG.warn(""Object "" + object + "" can't be serialized, it will be excluded by the MinaPayloadHolder"");
            return null;
        }
    }
    private static Map<String, Object> checkMapSerializableObjects(Map<String, Object> map) {
        if (map == null) {
            return null;
        }
        Map<String, Object> result = new LinkedHashMap<String, Object>();
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (entry.getValue() instanceof Serializable) {
                result.put(entry.getKey(), entry.getValue());
            } else {
                LOG.warn(""Object "" + entry.getValue() + "" of key "" + entry.getKey()
                         + "" can't be serialized, it will be excluded by the MinaPayloadHolder"");
            }
        }
        return result;
    }
}
"
org.apache.camel.builder.sql.SQL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of SQL expressions into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""sql"")
public @interface SQL {
    String value();
}"
org.apache.camel.component.jms.requestor.ReplyHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import javax.jms.JMSException;
import javax.jms.Message;
/**
 * @version $Revision$
 */
public interface ReplyHandler {
    /**
     * Processes the message, returning true if this is the last method of a lifecycle
     * so that the handler can be discarded
     */
    boolean handle(Message message) throws JMSException;
}
"
org.apache.camel.component.jms.DestinationTransformProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * A processor which is capable of transforming the
 *
 * @deprecated not used. Will be removed in Camel 2.0
 * @version $Revision$
 */
public class DestinationTransformProcessor {
}
"
org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.spring.integration.SpringIntegrationBinding;
import org.apache.camel.component.spring.integration.SpringIntegrationExchange;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.core.Message;
import org.springframework.integration.core.MessageChannel;
import org.springframework.integration.core.MessageHeaders;
import org.springframework.integration.message.MessageDeliveryException;
import org.springframework.integration.message.MessageHandler;
import org.springframework.integration.message.MessageRejectedException;
/**
 * CamelTargeAdapter will redirect the Spring Integration message to the Camel context.
 * When we inject the camel context into it, we need also specify the Camel endpoint url
 * we will route the Spring Integration message to the Camel context
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelTargetAdapter extends AbstractCamelAdapter implements MessageHandler {
    private final Log logger = LogFactory.getLog(this.getClass());
    private ProducerTemplate<Exchange> camelTemplate;
    private MessageChannel replyChannel;
    public void setReplyChannel(MessageChannel channel) {
        replyChannel = channel;
    }
    public MessageChannel getReplyChannel() {
        return replyChannel;
    }
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {
            CamelContext ctx = getCamelContext();
            if (ctx == null) {
                ctx = new DefaultCamelContext();
            }
            camelTemplate = ctx.createProducerTemplate();
        }
        return camelTemplate;
    }
    public boolean send(Message<?> message) throws MessageRejectedException, MessageDeliveryException {
        ExchangePattern pattern;
        boolean result = false;
        if (isExpectReply()) {
            pattern = ExchangePattern.InOut;
        } else {
            pattern = ExchangePattern.InOnly;
        }
        Exchange inExchange = new SpringIntegrationExchange(getCamelContext(), pattern);
        SpringIntegrationBinding.storeToCamelMessage(message, inExchange.getIn());
        Exchange outExchange = getCamelTemplate().send(getCamelEndpointUri(), inExchange);
        if (outExchange.getFault() != null) {
            result = true;
        }
        Message response = null;
        if (isExpectReply()) {
            //Check the message header for the return address
            response = SpringIntegrationBinding.storeToSpringIntegrationMessage(outExchange.getOut());
            if (replyChannel == null) {
                MessageChannel messageReplyChannel = (MessageChannel) message.getHeaders().get(MessageHeaders.REPLY_CHANNEL);
                if (messageReplyChannel != null) {
                    result = messageReplyChannel.send(response);
                } else {
                    throw new MessageDeliveryException(response, ""Can't find reply channel from the CamelTargetAdapter or MessageHeaders"");
                }
            } else {
                result = replyChannel.send(response);
            }
        }
        return result;
    }
    public void handleMessage(Message<?> message) {
        send(message);        
    }
}
"
org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.spring.integration.SpringIntegrationBinding;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.channel.PollableChannel;
import org.springframework.integration.core.Message;
import org.springframework.integration.core.MessageChannel;
import org.springframework.integration.core.MessageHeaders;
import org.springframework.integration.gateway.SimpleMessagingGateway;
import org.springframework.integration.message.MessageHandler;
import org.springframework.integration.transformer.Transformer;
/**
 * A CamelContext will be injected into CameSourceAdapter which will
 * let Spring Integration channel talk to the CamelContext certain endpoint
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelSourceAdapter extends AbstractCamelAdapter implements InitializingBean {
    protected final Object lifecycleMonitor = new Object();
    private final Log logger = LogFactory.getLog(this.getClass());
    private Consumer consumer;
    private Endpoint camelEndpoint;
    private MessageChannel requestChannel;
    private DirectChannel replyChannel;
    private volatile boolean initialized;
    public void setRequestChannel(MessageChannel channel) {
        requestChannel = channel;        
    }
    public MessageChannel getChannel() {
        return requestChannel;
    }
    public void setReplyChannel(DirectChannel channel) {        
        replyChannel = channel;
    }
    protected class ConsumerProcessor implements AsyncProcessor {
        public void process(Exchange exchange) throws Exception {
            AsyncProcessorHelper.process(this, exchange);      
        }
        public boolean process(final Exchange exchange, final AsyncCallback callback) {
            org.springframework.integration.core.Message request =
                SpringIntegrationBinding.createSpringIntegrationMessage(exchange);
            Map<String, Object> headers = new HashMap<String, Object>();
            if (exchange.getPattern().isOutCapable()) {
                headers.put(MessageHeaders.REPLY_CHANNEL , replyChannel);
                replyChannel.subscribe(new MessageHandler() {                
                    public void handleMessage(Message<?> message) {
                        //TODO set the corralationID
                        SpringIntegrationBinding.storeToCamelMessage(message, exchange.getOut());
                        callback.done(true);
                    }
                });
            }
            requestChannel.send(request);
            if (!exchange.getPattern().isOutCapable()) {
                callback.done(true);
            }            
            return true;
        }
    }
    public final void afterPropertiesSet() throws Exception {
        synchronized (this.lifecycleMonitor) {
            if (this.initialized) {
                return;
            }
        }
        this.initialize();
        this.initialized = true;
    }
    protected void initialize() throws Exception {
        // start the service here
        camelEndpoint = getCamelContext().getEndpoint(getCamelEndpointUri());
        consumer = camelEndpoint.createConsumer(new ConsumerProcessor());
        consumer.start();
    }   
}
"
org.apache.camel.spring.EndpointFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.model.IdentifiedType;
import org.springframework.beans.factory.FactoryBean;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A {@link FactoryBean} which instantiates {@link Endpoint} objects
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""endpoint"")
@XmlAccessorType(XmlAccessType.FIELD)
public class EndpointFactoryBean extends IdentifiedType implements FactoryBean, CamelContextAware {
    @XmlAttribute
    private String uri;
    @XmlTransient
    private CamelContext context;
    @XmlTransient
    private Endpoint endpoint;
    @XmlTransient
    private boolean singleton;
    public Object getObject() throws Exception {
        if (endpoint == null) {
            endpoint = createEndpoint();
        }
        return endpoint;
    }
    public Class getObjectType() {
        return Endpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    public CamelContext getCamelContext() {
        return context;
    }
    /**
     * Sets the context to use to resolve endpoints
     *
     * @param context the context used to resolve endpoints
     */
    public void setCamelContext(CamelContext context) {
        this.context = context;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI to use to resolve the endpoint
     *
     * @param uri the URI used to set the endpoint
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    protected Endpoint createEndpoint() {
        notNull(context, ""context"");
        notNull(uri, ""uri"");
        Endpoint endpoint = context.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
}
"
org.apache.camel.language.LanguageAnnotation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.component.bean.DefaultAnnotationExpressionFactory;
/**
 * Base annotation for languages.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface LanguageAnnotation {
    String language();
    Class<?> factory() default DefaultAnnotationExpressionFactory.class;
}"
org.apache.camel.osgi.OsgiFactoryFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Properties;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
public class OsgiFactoryFinder extends FactoryFinder {
    private class BundleEntry {
        URL url;
        Bundle bundle;
    }
    public OsgiFactoryFinder() {
        super();
    }
    public OsgiFactoryFinder(String path) {
        super(path);
    }
    public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
        if (propertyPrefix == null) {
            propertyPrefix = """";
        }
        Class clazz = (Class)classMap.get(propertyPrefix + key);
        Properties properties = null;
        if (clazz == null) {
            BundleEntry entry = getResource(key);
            if (entry != null) {
                URL url = entry.url;
                InputStream in = url.openStream();
                // lets load the file
                BufferedInputStream reader = null;
                try {
                    reader = new BufferedInputStream(in);
                    properties = new Properties();
                    properties.load(reader);
                    String className = properties.getProperty(propertyPrefix + ""class"");
                    if (className == null) {
                        throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
                    }
                    clazz = entry.bundle.loadClass(className);
                    classMap.put(propertyPrefix + key, clazz);
                } finally {
                    ObjectHelper.close(reader, key, null);
                    ObjectHelper.close(in, key, null);
                }
            } else {
                throw new NoFactoryAvailableException(propertyPrefix + key);
            }           
        }
        return clazz;
    }
    public BundleEntry getResource(String name) {
        URL url = null;
        BundleEntry entry = null;
        BundleContext bundleContext =  Activator.getBundle().getBundleContext();
        for (Bundle bundle : bundleContext.getBundles()) {            
            url = bundle.getEntry(getPath() + name);
            if (url != null) {
                entry = new BundleEntry();
                entry.url = url;
                entry.bundle = bundle;
                break;
            }
        }
        return entry;
    }
}
"
org.apache.camel.language.jxpath.JXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.language.ExpressionEvaluationException;
import org.apache.commons.jxpath.CompiledExpression;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
/**
 * <a href=""http://commons.apache.org/jxpath/"">JXPath</a> {@link Expression} support 
 */
public class JXPathExpression extends ExpressionSupport<Exchange> {
    private String expression;
    private CompiledExpression compiledExpression;
    private final Class<?> type;
    /**
     * Creates a new JXPathExpression instance
     * 
     * @param expression the JXPath expression to be evaluated
     * @param type the expected result type
     */
    public JXPathExpression(String expression, Class<?> type) {
        super();
        this.expression = expression;
        this.type = type;
    }
    public Object evaluate(Exchange exchange) {
        try {
            JXPathContext context = JXPathContext.newContext(exchange);
            Object result = getJXPathExpression().getValue(context, type);
            assertResultType(exchange, result);
            return result;
        } catch (JXPathException e) {
            throw new ExpressionEvaluationException(this, exchange, e);
        }
    }
    /*
     * Check if the result is of the specified type
     */
    private void assertResultType(Exchange exchange, Object result) {
        if (result != null && !type.isAssignableFrom(result.getClass())) {
            throw new JXPathException(""JXPath result type is "" + result.getClass() + "" instead of required type "" + type);
        }
    }
    @Override
    protected String assertionFailureMessage(Exchange exchange) {
        return expression.toString();
    }
    /*
     * Get a compiled expression instance for better performance
     */
    private synchronized CompiledExpression getJXPathExpression() {
        if (compiledExpression == null) {
            compiledExpression = JXPathContext.compile(expression);
        }
        return compiledExpression;
    }
}
"
org.apache.camel.component.file.FileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.IOException;
import java.util.Date;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * A {@link Exchange} for File
 *
 * @version $Revision$
 */
public class FileExchange extends DefaultExchange {
    private File file;
    public FileExchange(CamelContext camelContext, ExchangePattern pattern, File file) {
        super(camelContext, pattern);
        setFile(file);
    }
    public FileExchange(DefaultExchange parent, File file) {
        super(parent);
        setFile(file);
    }
    public File getFile() {
        return this.file;
    }
    public void setFile(File file) {
        setIn(new FileMessage(file));
        this.file = file;
        populateHeaders(file);
    }
    public Exchange newInstance() {
        return new FileExchange(this, getFile());
    }
    private void populateHeaders(File file) {
        // set additional headers with file information
        if (file != null) {
            getIn().setHeader(""CamelFileName"", file.getName());
            getIn().setHeader(""CamelFileAbsolutePath"", file.getAbsolutePath());
            getIn().setHeader(""CamelFileParent"", file.getParent());
            getIn().setHeader(""CamelFilePath"", file.getPath());
            try {
                getIn().setHeader(""CamelFileCanonicalPath"", file.getCanonicalPath());
            } catch (IOException e) {
                // ignore
            }
            if (file.length() > 0) {
                getIn().setHeader(""CamelFileLength"", new Long(file.length()));
            }
            if (file.lastModified() > 0) {
                getIn().setHeader(""CamelFileLastModified"", new Date(file.lastModified()));
            }
        }
    }
}
"
org.apache.camel.builder.xml.MessageVariableResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPathVariableResolver;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.builder.xml.Namespaces.ENVIRONMENT_VARIABLES;
import static org.apache.camel.builder.xml.Namespaces.EXCHANGE_PROPERTY;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.SYSTEM_PROPERTIES_NAMESPACE;
/**
 * A variable resolver for XPath expressions which support properties on the
 * messge, exchange as well as making system properties and environment
 * properties available.
 *
 * @version $Revision$
 */
public class MessageVariableResolver implements XPathVariableResolver {
    private static final transient Log LOG = LogFactory.getLog(MessageVariableResolver.class);
    private Exchange exchange;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public Object resolveVariable(QName name) {
        String uri = name.getNamespaceURI();
        String localPart = name.getLocalPart();
        Object answer = null;
        Message in = exchange.getIn();
        if (uri == null || uri.length() == 0) {
            answer = variables.get(localPart);
            if (answer == null) {
                Message message = in;
                if (message != null) {
                    answer = message.getHeader(localPart);
                }
                if (answer == null) {
                    answer = exchange.getProperty(localPart);
                }
            }
        } else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {
            try {
                answer = System.getProperty(localPart);
            } catch (Exception e) {
                LOG.debug(""Security exception evaluating system property: "" + localPart
                          + "". Reason: "" + e, e);
            }
        } else if (uri.equals(ENVIRONMENT_VARIABLES)) {
            answer = System.getenv().get(localPart);
        } else if (uri.equals(EXCHANGE_PROPERTY)) {
            answer = exchange.getProperty(localPart);
        } else if (uri.equals(IN_NAMESPACE)) {
            answer = in.getHeader(localPart);
            if (answer == null && localPart.equals(""body"")) {
                answer = in.getBody();
            }
        } else if (uri.equals(OUT_NAMESPACE)) {
            Message out = exchange.getOut(false);
            if (out != null) {
                answer = out.getHeader(localPart);
                if (answer == null && localPart.equals(""body"")) {
                    answer = out.getBody();
                }
            }
        }
        // If we can't find an answer we must return void.
        // We can't return null then the xpath engine will throw a NullPointerException
        if (answer == null) {
            return Void.class;
        } else {
            return answer;
        }
    }
    public void addVariable(String localPart, Object value) {
        variables.put(localPart, value);
    }
}
"
org.apache.camel.component.ResourceBasedComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * A useful base class for components which depend on a resource
 * such as things like Velocity or XQuery based components.
 *
 * @version $Revision$
 */
public abstract class ResourceBasedComponent extends DefaultComponent<Exchange> {
    protected final transient Log log = LogFactory.getLog(getClass());
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
    protected Resource resolveMandatoryResource(String uri) {
        Resource resource = getResourceLoader().getResource(uri);
        if (resource == null) {
            throw new IllegalArgumentException(""Could not find resource for URI: "" + uri + "" using: "" + getResourceLoader());
        } else {
            return resource;
        }
    }
}
"
org.apache.camel.component.irc.IrcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Component</a>
 *
 * @version $Revision$
 */
public class IrcComponent extends DefaultComponent<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcComponent.class);
    private IrcConfiguration configuration;
    private final Map<String, IRCConnection> connectionCache = new HashMap<String, IRCConnection>();
    public IrcComponent() {
        configuration = new IrcConfiguration();
    }
    public IrcComponent(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public IrcComponent(CamelContext context) {
        super(context);
        configuration = new IrcConfiguration();
    }
    public static IrcComponent ircComponent() {
        return new IrcComponent();
    }
    protected IrcEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        IrcConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final IrcEndpoint endpoint = new IrcEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public synchronized IRCConnection getIRCConnection(IrcConfiguration configuration) {
        final IRCConnection connection;
        if (connectionCache.containsKey(configuration.getCacheKey())) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Returning Cached Connection to "" + configuration.getHostname() + "" "" + configuration.getTarget());
            }
            connection = connectionCache.get(configuration.getCacheKey());
        } else {
            connection = createConnection(configuration);
            connectionCache.put(configuration.getCacheKey(), connection);
        }
        return connection;
    }
    protected IRCConnection createConnection(IrcConfiguration configuration) {
        LOG.debug(""Creating Connection to "" + configuration.getHostname() + "" destination: "" + configuration.getTarget() + "" nick: "" + configuration.getNickname() + "" user: ""
                  + configuration.getUsername());
        final IRCConnection conn = new IRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(),
                                                     configuration.getRealname());
        conn.setEncoding(""UTF-8"");
        // conn.setDaemon(true);
        conn.setColors(configuration.isColors());
        conn.setPong(true);
        try {
            conn.connect();
        } catch (Exception e) {
            LOG.error(""Failed to connect: "" + e, e);
            throw new RuntimeCamelException(e);
        }
        return conn;
    }
    public void closeConnection(String key, IRCConnection connection) {
        try {
            connection.doQuit();
            connection.close();
        } catch (Exception e) {
            LOG.warn(""Error closing connection."", e);
        }
    }
    @Override
    protected synchronized void doStop() throws Exception {
        // lets use a copy so we can clear the connections eagerly in case of
        // exceptions
        Map<String, IRCConnection> map = new HashMap<String, IRCConnection>(connectionCache);
        connectionCache.clear();
        for (Map.Entry<String, IRCConnection> entry : map.entrySet()) {
            closeConnection(entry.getKey(), entry.getValue());
        }
        super.doStop();
    }
}
"
org.apache.camel.spring.factory.BeanEndpointFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.factory;
import org.apache.camel.component.bean.BeanEndpoint;
import org.springframework.beans.factory.FactoryBean;
/**
 * Spring {@link org.springframework.beans.factory.FactoryBean} for creating
 * Camel {@link BeanEndpoint} objects.
 *
 * @version $Revision$
 */
public class BeanEndpointFactory implements FactoryBean {
    private boolean singleton = true;
    public Object getObject() throws Exception {
        return new BeanEndpoint();
    }
    public Class getObjectType() {
        return BeanEndpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    protected void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    // Properties
    //-------------------------------------------------------------------------
}
"
org.apache.camel.component.log.LogFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
import org.apache.camel.util.ObjectHelper;
/**
 * Log formatter to format the logging output.
 */
public class LogFormatter implements ExchangeFormatter {
    private boolean showExchangeId;
    private boolean showProperties;
    private boolean showHeaders;
    private boolean showBodyType = true;
    private boolean showBody = true;
    private boolean showOut;
    private boolean showAll;
    private boolean multiline;
    public Object format(Exchange exchange) {
        Message in = exchange.getIn();
        StringBuilder sb = new StringBuilder("""");
        if (showAll || showExchangeId) {
            if (multiline) {
                sb.append('\n');
            }
            sb.append("", Id:"").append(exchange.getExchangeId());
        }
        if (showAll || showProperties) {
            if (multiline) {
                sb.append('\n');
            }
            sb.append("", Properties:"").append(exchange.getProperties());
        }
        if (showAll || showHeaders) {
            if (multiline) {
                sb.append('\n');
            }
            sb.append("", Headers:"").append(in.getHeaders());
        }
        if (showAll || showBodyType) {
            if (multiline) {
                sb.append('\n');
            }
            sb.append("", BodyType:"").append(getBodyTypeAsString(in));
        }
        if (showAll || showBody) {
            if (multiline) {
                sb.append('\n');
            }
            sb.append("", Body:"").append(getBodyAsString(in));
        }
        Message out = exchange.getOut(false);
        if (showAll || showOut) {
            if (out != null) {
                if (showAll || showHeaders) {
                    if (multiline) {
                        sb.append('\n');
                    }
                    sb.append("", OutHeaders:"").append(out.getHeaders());
                }
                if (showAll || showBodyType) {
                    if (multiline) {
                        sb.append('\n');
                    }
                    sb.append("", OutBodyType:"").append(getBodyTypeAsString(out));
                }
                if (showAll || showBody) {
                    if (multiline) {
                        sb.append('\n');
                    }
                    sb.append("", OutBody:"").append(getBodyAsString(out));
                }
            } else {
                if (multiline) {
                    sb.append('\n');
                }
                sb.append("", Out: null"");
            }
        }
        // get rid of the leading space comma if needed
        return ""Exchange["" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + ""]"");
    }
    public boolean isShowExchangeId() {
        return showExchangeId;
    }
    public void setShowExchangeId(boolean showExchangeId) {
        this.showExchangeId = showExchangeId;
    }
    public boolean isShowProperties() {
        return showProperties;
    }
    public void setShowProperties(boolean showProperties) {
        this.showProperties = showProperties;
    }
    public boolean isShowHeaders() {
        return showHeaders;
    }
    public void setShowHeaders(boolean showHeaders) {
        this.showHeaders = showHeaders;
    }
    public boolean isShowBodyType() {
        return showBodyType;
    }
    public void setShowBodyType(boolean showBodyType) {
        this.showBodyType = showBodyType;
    }
    public boolean isShowBody() {
        return showBody;
    }
    public void setShowBody(boolean showBody) {
        this.showBody = showBody;
    }
    public boolean isShowOut() {
        return showOut;
    }
    public void setShowOut(boolean showOut) {
        this.showOut = showOut;
    }
    public boolean isShowAll() {
        return showAll;
    }
    public void setShowAll(boolean showAll) {
        this.showAll = showAll;
    }
    public boolean isMultiline() {
        return multiline;
    }
    /**
     * If enabled then each information is outputted on a newline.
     */
    public void setMultiline(boolean multiline) {
        this.multiline = multiline;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Object getBodyAsString(Message message) {
        StreamCache newBody = null;
        try {
            newBody = message.getBody(StreamCache.class);
            if (newBody != null) {
                message.setBody(newBody);
            }
        } catch (NoTypeConversionAvailableException ex) {
            // ignore
        }
        Object answer = null;
        try {
            answer = message.getBody(String.class);
        } catch (NoTypeConversionAvailableException ex) {
            answer = message.getBody();
        }
        if (newBody != null) {
            // Reset the StreamCache
            newBody.reset();
        }
        return answer;
    }
    protected Object getBodyTypeAsString(Message message) {
        String answer = ObjectHelper.classCanonicalName(message.getBody());
        if (answer != null && answer.startsWith(""java.lang."")) {
            return answer.substring(10);
        }
        return answer;
    }
}
"
org.apache.camel.component.rmi.RmiRegistryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.registry.Registry;
import org.apache.camel.CamelContext;
import org.apache.camel.component.bean.ParameterMappingStrategy;
import org.apache.camel.component.bean.RegistryBean;
/**
 * @version $Revision$
 */
public class RmiRegistryBean extends RegistryBean {
    private final Registry registry;
    public RmiRegistryBean(CamelContext context, String name, Registry registry) {
        super(context, name);
        this.registry = registry;
    }
    public RmiRegistryBean(CamelContext context, String name, ParameterMappingStrategy parameterMappingStrategy, Registry registry) {
        super(context, name, parameterMappingStrategy);
        this.registry = registry;
    }
    @Override
    protected Object lookupBean() throws Exception {
        return registry.lookup(getName());
    }
}
"
org.apache.camel.Routes,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.List;
/**
 * Routes defined in the camel context.
 */
public interface Routes {
    /**
     * Gets the Camel context used.
     */
    CamelContext getContext();
    /**
     * Sets the Camel context to use.
     */
    void setContext(CamelContext context);
    /**
     * Gets the list of routes currently in the camel context.
     */
    List<Route> getRouteList() throws Exception;
}
"
org.apache.camel.component.validator.ValidatorComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * The <a href=""http://activemq.apache.org/camel/validator.html"">Validator Component</a>
 * for validating XML against some schema
 *
 * @version $Revision$
 */
public class ValidatorComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        SpringValidator validator = new SpringValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(SpringValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.builder.xml.StreamResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.ByteArrayOutputStream;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a byte[]
 *
 * @version $Revision$
 */
public class StreamResultHandler implements ResultHandler {
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toByteArray());
    }
}
"
org.apache.camel.component.velocity.VelocityComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.velocity.app.VelocityEngine;
/**
 * @version $Revision$
 */
public class VelocityComponent extends DefaultComponent {
    private VelocityEngine velocityEngine = new VelocityEngine();
    public VelocityEngine getVelocityEngine() {
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new VelocityEndpoint(uri, this, remaining, parameters);
    }
}
"
org.apache.camel.component.quartz.QuartzEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SimpleTrigger;
import org.quartz.Trigger;
/**
 * A <a href=""http://activemq.apache.org/quartz.html"">Quartz Endpoint</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzEndpoint extends DefaultEndpoint<QuartzExchange> {
    public static final String ENDPOINT_KEY = ""org.apache.camel.quartz"";
    public static final String CONTEXT_KEY = ""org.apache.camel.CamelContext"";
    private static final transient Log LOG = LogFactory.getLog(QuartzEndpoint.class);
    private Scheduler scheduler;
    private LoadBalancer loadBalancer;
    private Trigger trigger;
    private JobDetail jobDetail;
    private boolean started;
    private boolean stateful;
    public QuartzEndpoint(final String endpointUri, final QuartzComponent component, final Scheduler scheduler) {
        super(endpointUri, component);
        this.scheduler = scheduler;
    }
    public QuartzEndpoint(final String endpointUri, final Scheduler scheduler) {
        super(endpointUri);
        this.scheduler = scheduler;
    }
    public void addTriggers(final Map<Trigger, JobDetail> triggerMap) throws SchedulerException {
        if (triggerMap != null) {
            Set<Map.Entry<Trigger, JobDetail>> entries = triggerMap.entrySet();
            for (Map.Entry<Trigger, JobDetail> entry : entries) {
                Trigger key = entry.getKey();
                JobDetail value = entry.getValue();
                ObjectHelper.notNull(key, ""key"");
                ObjectHelper.notNull(value, ""value"");
                addTrigger(key, value);
            }
        }
    }
    public void addTrigger(final Trigger trigger, final JobDetail detail) throws SchedulerException {
        // lets default the trigger name to the job name
        if (trigger.getName() == null) {
            trigger.setName(detail.getName());
        }
        // lets default the trigger group to the job group
        if (trigger.getGroup() == null) {
            trigger.setGroup(detail.getGroup());
        }
        // default start time to now if not specified
        if (trigger.getStartTime() == null) {
            trigger.setStartTime(new Date());
        }
        if (isStateful()) {
            detail.getJobDataMap().put(ENDPOINT_KEY, getEndpointUri());
        } else {
            detail.getJobDataMap().put(ENDPOINT_KEY, this);
        }
        if (null == detail.getJobClass()) {
            if (isStateful()) {
                detail.setJobClass(StatefulCamelJob.class);
            } else {
                detail.setJobClass(CamelJob.class);
            }
        }
        if (detail.getName() == null) {
            detail.setName(getEndpointUri());
        }
        getScheduler().scheduleJob(detail, trigger);
    }
    public void removeTrigger(final Trigger trigger, final JobDetail jobDetail) throws SchedulerException {
        getScheduler().unscheduleJob(trigger.getName(), trigger.getGroup());
    }
    /**
     * This method is invoked when a Quartz job is fired.
     *
     * @param jobExecutionContext the Quartz Job context
     */
    public void onJobExecute(final JobExecutionContext jobExecutionContext) throws JobExecutionException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Firing Quartz Job with context: "" + jobExecutionContext);
        }
        QuartzExchange exchange = createExchange(jobExecutionContext);
        try {
            getLoadBalancer().process(exchange);
        } catch (JobExecutionException e) {
            throw e;
        } catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }
    @Override
    public QuartzExchange createExchange(final ExchangePattern pattern) {
        return new QuartzExchange(getCamelContext(), pattern, null);
    }
    public QuartzExchange createExchange(final JobExecutionContext jobExecutionContext) {
        return new QuartzExchange(getCamelContext(), getExchangePattern(), jobExecutionContext);
    }
    public Producer<QuartzExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""You cannot send messages to this endpoint"");
    }
    public QuartzConsumer createConsumer(final Processor processor) throws Exception {
        return new QuartzConsumer(this, processor);
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public QuartzComponent getComponent() {
        return (QuartzComponent)super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Scheduler getScheduler() {
        return scheduler;
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(final LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    public JobDetail getJobDetail() {
        if (jobDetail == null) {
            jobDetail = createJobDetail();
        }
        return jobDetail;
    }
    public void setJobDetail(final JobDetail jobDetail) {
        this.jobDetail = jobDetail;
    }
    public Trigger getTrigger() {
        if (trigger == null) {
            trigger = createTrigger();
        }
        return trigger;
    }
    public void setTrigger(final Trigger trigger) {
        this.trigger = trigger;
    }
    /**
     * @return the stateful
     */
    public boolean isStateful() {
        return this.stateful;
    }
    /**
     * @param stateful the stateful to set
     */
    public void setStateful(final boolean stateful) {
        this.stateful = stateful;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(final QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().addProcessor(consumer.getProcessor());
        // if we have not yet added our default trigger, then lets do it
        if (!started) {
            addTrigger(getTrigger(), getJobDetail());
            started = true;
        }
    }
    public synchronized void consumerStopped(final QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
        if (getLoadBalancer().getProcessors().isEmpty() && started) {
            removeTrigger(getTrigger(), getJobDetail());
            started = false;
        }
    }
    protected LoadBalancer createLoadBalancer() {
        return new RoundRobinLoadBalancer();
    }
    protected JobDetail createJobDetail() {
        return new JobDetail();
    }
    protected Trigger createTrigger() {
        return new SimpleTrigger();
    }
}
"
org.apache.camel.osgi.OsgiComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.io.BufferedInputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.spi.ComponentResolver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;
import org.springframework.osgi.util.BundleDelegatingClassLoader;
public class OsgiComponentResolver implements ComponentResolver {
    private static final transient Log LOG = LogFactory.getLog(OsgiComponentResolver.class);
    protected Class getComponent(String name) throws Exception {
        return Activator.getComponent(name);       
    }
    public Component resolveComponent(String name, CamelContext context) throws Exception {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found component: "" + name + "" in registry: "" + bean);
            }
        } catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component)bean;
            }
            // we do not throw the exception here and try to auto create a component
        }
        // Check in OSGi bundles        
        Class type = null;
        try {
            type = getComponent(name);
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Component registered for scheme : "" + name, e);
        }
        if (type == null) {
            return null;
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component)context.getInjector().newInstance(type);
        } else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: ""
                                               + type.getName());
        }
    }
}
"
org.apache.camel.component.jms.requestor.FailedToProcessResponse,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import javax.jms.JMSException;
import javax.jms.Message;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if a response message from an InOut could not be processed
 *
 * @version $Revision$
 */
public class FailedToProcessResponse extends RuntimeCamelException {
    private final Message response;
    public FailedToProcessResponse(Message response, JMSException e) {
        super(""Failed to process response: "" + e + "". Message: "" + response, e);
        this.response = response;
    }
    /**
     * The response message which caused the exception
     */
    public Message getResponse() {
        return response;
    }
}
"
org.apache.camel.component.uface.UFaceComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision$
 */
public class UFaceComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new UFaceEndpoint(uri, this);
    }
}
"
org.apache.camel.builder.PredicateBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.compare;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A helper class for working with predicates
 *
 * @version $Revision$
 */
public final class PredicateBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private PredicateBuilder() {
    }
    /**
     * Converts the given expression into an {@link Predicate}
     */
    public static <E extends Exchange> Predicate<E> toPredicate(final Expression<E> expression) {
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return ObjectHelper.evaluateValuePredicate(value);
            }
            @Override
            public String toString() {
                return expression.toString();
            }
        };
    }
    /**
     * A helper method to return the logical not of the given predicate
     */
    public static <E extends Exchange> Predicate<E> not(final Predicate<E> predicate) {
        notNull(predicate, ""predicate"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return !predicate.matches(exchange);
            }
            @Override
            public String toString() {
                return ""not "" + predicate;
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical AND
     */
    public static <E extends Exchange> Predicate<E> and(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) && right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") and ("" + right + "")"";
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical OR
     */
    public static <E extends Exchange> Predicate<E> or(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) || right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") or ("" + right + "")"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isEqualTo(final Expression<E> left,
                                                              final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.equal(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""=="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNotEqualTo(final Expression<E> left,
                                                                 final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return !ObjectHelper.equal(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""!="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThan(final Expression<E> left,
                                                               final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) < 0;
            }
            protected String getOperationText() {
                return ""<"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThanOrEqualTo(final Expression<E> left,
                                                                        final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) <= 0;
            }
            protected String getOperationText() {
                return ""<="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThan(final Expression<E> left,
                                                                  final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) > 0;
            }
            protected String getOperationText() {
                return "">"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThanOrEqualTo(final Expression<E> left,
                                                                           final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) >= 0;
            }
            protected String getOperationText() {
                return "">="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> contains(final Expression<E> left,
                                                             final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.contains(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""contains"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNull(final Expression<E> expression) {
        return isEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isNotNull(final Expression<E> expression) {
        return isNotEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isInstanceOf(final Expression<E> expression,
                                                                 final Class type) {
        notNull(expression, ""expression"");
        notNull(type, ""type"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return type.isInstance(value);
            }
            @Override
            public String toString() {
                return expression + "" instanceof "" + type.getName();
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange)
                    + "" for <"" + expression.evaluate(exchange) + "">"";
            }
        };
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     *
     * @param expression the expression to evaluate
     * @param regex the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final String regex) {
        return regex(expression, Pattern.compile(regex));
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     *
     * @param expression the expression to evaluate
     * @param pattern the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression,
                                                          final Pattern pattern) {
        notNull(expression, ""expression"");
        notNull(pattern, ""pattern"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                if (value != null) {
                    Matcher matcher = pattern.matcher(value.toString());
                    return matcher.matches();
                }
                return false;
            }
            @Override
            public String toString() {
                return expression + "".matches("" + pattern + "")"";
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange)
                       + "">"";
            }
        };
    }
}
"
org.apache.camel.builder.xml.XPathBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringReader;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.transform.dom.DOMSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import javax.xml.xpath.XPathFunction;
import javax.xml.xpath.XPathFunctionException;
import javax.xml.xpath.XPathFunctionResolver;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ExchangeHelper;
import static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;
import static org.apache.camel.converter.ObjectConverter.toBoolean;
/**
 * Creates an XPath expression builder which creates a nodeset result by default.
 * If you want to evaluate a String expression then call {@link #stringResult()}
 *
 * @see XPathConstants#NODESET
 *
 * @version $Revision$
 */
public class XPathBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, NamespaceAware {
    private final String text;
    private XPathFactory xpathFactory;
    private Class documentType = Document.class;
    // For some reason the default expression of ""a/b"" on a document such as
    // <a><b>1</b><b>2</b></a>
    // will evaluate as just ""1"" by default which is bizarre. So by default
    // lets assume XPath expressions result in nodesets.
    private Class resultType;
    private QName resultQName = XPathConstants.NODESET;
    private String objectModelUri;
    private DefaultNamespaceContext namespaceContext;
    private XPathFunctionResolver functionResolver;
    private XPathExpression expression;
    private MessageVariableResolver variableResolver = new MessageVariableResolver();
    private E exchange;
    private XPathFunction bodyFunction;
    private XPathFunction headerFunction;
    private XPathFunction outBodyFunction;
    private XPathFunction outHeaderFunction;
    public XPathBuilder(String text) {
        this.text = text;
    }
    public static XPathBuilder xpath(String text) {
        return new XPathBuilder(text);
    }
    @Override
    public String toString() {
        return ""XPath: "" + text;
    }
    public boolean matches(E exchange) {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        return toBoolean(booleanResult);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        if (!toBoolean(booleanResult)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as returned <"" + booleanResult + "">"");
        }
    }
    public Object evaluate(E exchange) {
        Object answer = evaluateAs(exchange, resultQName);
        if (resultType != null) {
            return ExchangeHelper.convertToType(exchange, resultType, answer);
        }
        return answer;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> booleanResult() {
        resultQName = XPathConstants.BOOLEAN;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeResult() {
        resultQName = XPathConstants.NODE;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeSetResult() {
        resultQName = XPathConstants.NODESET;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> numberResult() {
        resultQName = XPathConstants.NUMBER;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> stringResult() {
        resultQName = XPathConstants.STRING;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> resultType(Class resultType) {
        setResultType(resultType);
        return this;
    }
    /**
     * Sets the object model URI to use
     *
     * @return the current builder
     */
    public XPathBuilder<E> objectModel(String uri) {
        this.objectModelUri = uri;
        return this;
    }
    /**
     * Sets the {@link XPathFunctionResolver} instance to use on these XPath
     * expressions
     *
     * @return the current builder
     */
    public XPathBuilder<E> functionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
        return this;
    }
    /**
     * Registers the namespace prefix and URI with the builder so that the
     * prefix can be used in XPath expressions
     *
     * @param prefix is the namespace prefix that can be used in the XPath
     *                expressions
     * @param uri is the namespace URI to which the prefix refers
     * @return the current builder
     */
    public XPathBuilder<E> namespace(String prefix, String uri) {
        getNamespaceContext().add(prefix, uri);
        return this;
    }
    /**
     * Registers namespaces with the builder so that the registered
     * prefixes can be used in XPath expressions
     *
     * @param namespaces is namespaces object that should be used in the
     *                      XPath expression
     * @return the current builder
     */
    public XPathBuilder<E> namespaces(Namespaces namespaces) {
        namespaces.configure(this);
        return this;
    }
    /**
     * Registers a variable (in the global namespace) which can be referred to
     * from XPath expressions
     */
    public XPathBuilder<E> variable(String name, Object value) {
        variableResolver.addVariable(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public XPathFactory getXPathFactory() throws XPathFactoryConfigurationException {
        if (xpathFactory == null) {
            if (objectModelUri != null) {
                xpathFactory = XPathFactory.newInstance(objectModelUri);
            }
            xpathFactory = XPathFactory.newInstance();
        }
        return xpathFactory;
    }
    public void setXPathFactory(XPathFactory xpathFactory) {
        this.xpathFactory = xpathFactory;
    }
    public Class getDocumentType() {
        return documentType;
    }
    public void setDocumentType(Class documentType) {
        this.documentType = documentType;
    }
    public String getText() {
        return text;
    }
    public QName getResultQName() {
        return resultQName;
    }
    public void setResultQName(QName resultQName) {
        this.resultQName = resultQName;
    }
    public DefaultNamespaceContext getNamespaceContext() {
        if (namespaceContext == null) {
            try {
                DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext(getXPathFactory());
                populateDefaultNamespaces(defaultNamespaceContext);
                namespaceContext = defaultNamespaceContext;
            } catch (XPathFactoryConfigurationException e) {
                throw new RuntimeExpressionException(e);
            }
        }
        return namespaceContext;
    }
    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {
        this.namespaceContext = namespaceContext;
    }
    public XPathFunctionResolver getFunctionResolver() {
        return functionResolver;
    }
    public void setFunctionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
    }
    public XPathExpression getExpression() throws XPathFactoryConfigurationException,
        XPathExpressionException {
        if (expression == null) {
            expression = createXPathExpression();
        }
        return expression;
    }
    public void setNamespaces(Map<String, String> namespaces) {
        getNamespaceContext().setNamespaces(namespaces);
    }
    public XPathFunction getBodyFunction() {
        if (bodyFunction == null) {
            bodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange == null) {
                        return null;
                    }
                    return exchange.getIn().getBody();
                }
            };
        }
        return bodyFunction;
    }
    public void setBodyFunction(XPathFunction bodyFunction) {
        this.bodyFunction = bodyFunction;
    }
    public XPathFunction getHeaderFunction() {
        if (headerFunction == null) {
            headerFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getIn().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return headerFunction;
    }
    public void setHeaderFunction(XPathFunction headerFunction) {
        this.headerFunction = headerFunction;
    }
    public XPathFunction getOutBodyFunction() {
        if (outBodyFunction == null) {
            outBodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null) {
                        Message out = exchange.getOut(false);
                        if (out != null) {
                            return out.getBody();
                        }
                    }
                    return null;
                }
            };
        }
        return outBodyFunction;
    }
    public void setOutBodyFunction(XPathFunction outBodyFunction) {
        this.outBodyFunction = outBodyFunction;
    }
    public XPathFunction getOutHeaderFunction() {
        if (outHeaderFunction == null) {
            outHeaderFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getOut().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return outHeaderFunction;
    }
    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {
        this.outHeaderFunction = outHeaderFunction;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
        if (Number.class.isAssignableFrom(resultType)) {
            numberResult();
        } else if (String.class.isAssignableFrom(resultType)) {
            stringResult();
        } else if (Boolean.class.isAssignableFrom(resultType)) {
            booleanResult();
        } else if (Node.class.isAssignableFrom(resultType)) {
            nodeResult();
        } else if (NodeList.class.isAssignableFrom(resultType)) {
            nodeSetResult();
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Evaluates the expression as the given result type
     */
    protected synchronized Object evaluateAs(E exchange, QName resultQName) {
        this.exchange = exchange;
        variableResolver.setExchange(exchange);
        try {
            Object document = getDocument(exchange);
            if (resultQName != null) {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource, resultQName);
                } else if (document instanceof DOMSource) {
                    DOMSource source = (DOMSource) document;
                    return getExpression().evaluate(source.getNode(), resultQName);
                } else {
                    return getExpression().evaluate(document, resultQName);
                }
            } else {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource);
                } else if (document instanceof DOMSource) {
                    DOMSource source = (DOMSource)document;
                    return getExpression().evaluate(source.getNode());
                } else {
                    return getExpression().evaluate(document);
                }
            }
        } catch (XPathExpressionException e) {
            throw new InvalidXPathExpression(getText(), e);
        } catch (XPathFactoryConfigurationException e) {
            throw new InvalidXPathExpression(getText(), e);
        }
    }
    protected XPathExpression createXPathExpression() throws XPathExpressionException,
        XPathFactoryConfigurationException {
        XPath xPath = getXPathFactory().newXPath();
        // lets now clear any factory references to avoid keeping them around
        xpathFactory = null;
        xPath.setNamespaceContext(getNamespaceContext());
        xPath.setXPathVariableResolver(variableResolver);
        XPathFunctionResolver parentResolver = getFunctionResolver();
        if (parentResolver == null) {
            parentResolver = xPath.getXPathFunctionResolver();
        }
        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));
        return xPath.compile(text);
    }
    /**
     * Lets populate a number of standard prefixes if they are not already there
     */
    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {
        setNamespaceIfNotPresent(context, ""in"", IN_NAMESPACE);
        setNamespaceIfNotPresent(context, ""out"", OUT_NAMESPACE);
        setNamespaceIfNotPresent(context, ""env"", Namespaces.ENVIRONMENT_VARIABLES);
        setNamespaceIfNotPresent(context, ""system"", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);
    }
    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {
        if (context != null) {
            String current = context.getNamespaceURI(prefix);
            if (current == null) {
                context.add(prefix, uri);
            }
        }
    }
    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {
        return new XPathFunctionResolver() {
            public XPathFunction resolveFunction(QName qName, int argumentCount) {
                XPathFunction answer = null;
                if (parent != null) {
                    answer = parent.resolveFunction(qName, argumentCount);
                }
                if (answer == null) {
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)
                        || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getHeaderFunction();
                        }
                    }
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getOutBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getOutHeaderFunction();
                        }
                    }
                }
                return answer;
            }
        };
    }
    /**
     * Strategy method to extract the document from the exchange
     */
    protected Object getDocument(E exchange) {
        Message in = exchange.getIn();
        Class type = getDocumentType();
        Object answer = null;
        if (type != null) {
            answer = in.getBody(type);
        }
        if (answer == null) {
            answer = in.getBody();
        }
        // lets try coerce some common types into something JAXP can deal with
        if (answer instanceof String) {
            answer = new InputSource(new StringReader(answer.toString()));
        }
        return answer;
    }
}
"
org.apache.camel.component.http.HttpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision$
 */
public class HttpConsumer extends DefaultConsumer<HttpExchange> {
    private final HttpEndpoint endpoint;
    public HttpConsumer(HttpEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    public HttpEndpoint getEndpoint() {
        return (HttpEndpoint)super.getEndpoint();
    }
    public HttpBinding getBinding() {
        return endpoint.getBinding();
    }
    public String getPath() {
        return endpoint.getPath();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.connect(this);
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.disconnect(this);
        super.doStop();
    }
}
"
org.apache.camel.language.ognl.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import ognl.Ognl;
import ognl.OgnlContext;
import ognl.OgnlException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.language.ExpressionEvaluationException;
import org.apache.camel.language.IllegalSyntaxException;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Expression}
 *
 * @version $Revision$
 */
public class OgnlExpression extends ExpressionSupport<Exchange> {
    private final String expressionString;
    private final Class<?> type;
    private Object expression;
    public OgnlExpression(OgnlLanguage language, String expressionString, Class<?> type) {
        this.expressionString = expressionString;
        this.type = type;
        try {
            this.expression = Ognl.parseExpression(expressionString);
        } catch (OgnlException e) {
            throw new IllegalSyntaxException(language, expressionString, e);
        }
    }
    public static OgnlExpression ognl(String expression) {
        return new OgnlExpression(new OgnlLanguage(), expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible
        // concurrency issues
        // so lets assume that the provider caches
        OgnlContext oglContext = new OgnlContext();
        try {
            return Ognl.getValue(expression, oglContext, new RootObject(exchange));
        } catch (OgnlException e) {
            throw new ExpressionEvaluationException(this, exchange, e);
        }
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expressionString;
    }
}
"
org.apache.camel.impl.CamelPostProcessorHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.lang.reflect.Method;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Consume;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.MessageDriven;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.Service;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.bean.ProxyHelper;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A helper class for Camel based injector or post processing hooks which can be reused by
 * both the <a href=""http://activemq.apache.org/camel/spring.html"">Spring</a>
 * and <a href=""http://activemq.apache.org/camel/guice.html"">Guice</a> support.
 *
 * @version $Revision$
 */
public class CamelPostProcessorHelper implements CamelContextAware {
    private static final transient Log LOG = LogFactory.getLog(CamelPostProcessorHelper.class);
    @XmlTransient
    private CamelContext camelContext;
    public CamelPostProcessorHelper() {
    }
    public CamelPostProcessorHelper(CamelContext camelContext) {
        this.setCamelContext(camelContext);
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public void consumerInjection(Method method, Object bean) {
        MessageDriven annotation = method.getAnnotation(MessageDriven.class);
        if (annotation != null) {
            LOG.info(""Creating a consumer for: "" + annotation);
            subscribeMethod(method, bean, annotation.uri(), annotation.name());
        }
        Consume consume = method.getAnnotation(Consume.class);
        if (consume != null) {
            LOG.info(""Creating a consumer for: "" + consume);
            subscribeMethod(method, bean, consume.uri(), consume.ref());
        }
    }
    protected void subscribeMethod(Method method, Object bean, String endpointUri, String endpointName) {
        // lets bind this method to a listener
        String injectionPointName = method.getName();
        Endpoint endpoint = getEndpointInjection(endpointUri, endpointName, injectionPointName, true);
        if (endpoint != null) {
            try {
                Processor processor = createConsumerProcessor(bean, method, endpoint);
                LOG.info(""Created processor: "" + processor);
                Consumer consumer = endpoint.createConsumer(processor);
                startService(consumer);
            } catch (Exception e) {
                LOG.warn(e);
                throw org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(e);
            }
        }
    }
    public void startService(Service service) throws Exception {
        CamelContext camelContext = getCamelContext();
        if (camelContext instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) camelContext;
            defaultCamelContext.addService(service);
        } else {
            service.start();
        }
    }
    /**
     * Create a processor which invokes the given method when an incoming
     * message exchange is received
     */
    protected Processor createConsumerProcessor(final Object pojo, final Method method, final Endpoint endpoint) {
        BeanProcessor answer = new BeanProcessor(pojo, getCamelContext());
        answer.setMethodObject(method);
        return answer;
    }
    protected Endpoint getEndpointInjection(String uri, String name, String injectionPointName, boolean mandatory) {
        return CamelContextHelper.getEndpointInjection(getCamelContext(), uri, name, injectionPointName, mandatory);
    }
    /**
     * Creates the object to be injected for an {@link org.apache.camel.EndpointInject} or {@link org.apache.camel.Produce} injection point
     */
    public Object getInjectionValue(Class<?> type, String endpointUri, String endpointRef, String injectionPointName) {
        if (type.isAssignableFrom(ProducerTemplate.class)) {
            // endpoint is optional for this injection point
            Endpoint endpoint = getEndpointInjection(endpointUri, endpointRef, injectionPointName, false);
            return new DefaultProducerTemplate(getCamelContext(), endpoint);
        } else {
            Endpoint endpoint = getEndpointInjection(endpointUri, endpointRef, injectionPointName, true);
            if (endpoint != null) {
                if (type.isInstance(endpoint)) {
                    return endpoint;
                } else if (type.isAssignableFrom(Producer.class)) {
                    return createInjectionProducer(endpoint);
                } else if (type.isAssignableFrom(PollingConsumer.class)) {
                    return createInjectionPollingConsumer(endpoint);
                } else if (type.isInterface()) {
                    // lets create a proxy
                    try {
                        return ProxyHelper.createProxy(endpoint, type);
                    } catch (Exception e) {
                        throw createProxyInstantiationRuntimeException(type, endpoint, e);
                    }
                } else {
                    throw new IllegalArgumentException(""Invalid type: "" + type.getName() + "" which cannot be injected via @EndpointInject for "" + endpoint);
                }
            }
            return null;
        }
    }
    protected RuntimeException createProxyInstantiationRuntimeException(Class<?> type, Endpoint endpoint, Exception e) {
        return new ProxyInstantiationException(type, endpoint, e);
    }
    /**
     * Factory method to create a started {@link org.apache.camel.PollingConsumer} to be injected
     * into a POJO
     */
    protected PollingConsumer createInjectionPollingConsumer(Endpoint endpoint) {
        try {
            PollingConsumer pollingConsumer = endpoint.createPollingConsumer();
            startService(pollingConsumer);
            return pollingConsumer;
        } catch (Exception e) {
            throw org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(e);
        }
    }
    /**
     * A Factory method to create a started {@link org.apache.camel.Producer} to be injected into
     * a POJO
     */
    protected Producer createInjectionProducer(Endpoint endpoint) {
        try {
            Producer producer = endpoint.createProducer();
            startService(producer);
            return producer;
        } catch (Exception e) {
            throw org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.impl.DefaultHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import org.apache.camel.spi.HeaderFilterStrategy;
/**
 * The default header filtering strategy.  Users can configure filter by 
 * setting filter set and/or setting a regular expression.  Subclass can 
 * add extended filter logic in 
 * {@link #extendedFilter(org.apache.camel.impl.DefaultHeaderFilterStrategy.Direction, String, Object)}
 * 
 * Filters are associated with directions (in or out).  ""In"" direction is 
 * referred to propagating headers ""to"" Camel message.  The ""out"" direction
 * is opposite which is referred to propagating headers from Camel message
 * to a native message like JMS and CXF message.  You can see example of
 * DefaultHeaderFilterStrategy are being extended and invoked in camel-jms 
 * and camel-cxf components.
 *
 * @version $Revision$
 */
public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy {
    protected enum Direction { IN, OUT }
    private Set<String> inFilter;
    private Pattern inFilterPattern;
    private Set<String> outFilter;
    private Pattern outFilterPattern;
    private boolean isLowercase;
    private boolean allowNullValues;
    /**
     * Applies filtering logic to Camel Message header that is
     * going to be copied to target message.
     * 
     * It returns true if the filtering logics return a match.  Otherwise,
     * it returns false.  A match means the header should be excluded.
     * 
     * @param headerName 
     * @param headerValue
     * @return true if this header should be filtered out.
     */
    public boolean applyFilterToCamelHeaders(String headerName, Object headerValue) {
        return doFiltering(Direction.OUT, headerName, headerValue);
    }
    /**
     * Applies filtering logic to an external message header message that 
     * is going to be copied to Camel message header.
     * 
     * It returns true if the filtering logics return a match.  Otherwise,
     * it returns false.  A match means the header should be excluded.
     *  
     * @param headerName 
     * @param headerValue
     * @return true if this header should be excluded.
     */
    public boolean applyFilterToExternalHeaders(String headerName, Object headerValue) {
        return doFiltering(Direction.IN, headerName, headerValue);
    }
    /**
     * Gets the ""out"" direction filter set.  The ""out"" direction is referred to 
     * copying headers from a Camel message to an external message.
     * 
     * @return a set that contains header names that should be excluded.
     */
    public Set<String> getOutFilter() {
        if (outFilter == null) {
            outFilter = new HashSet<String>();
        }
        return outFilter;
    }
    /**
     * Sets the ""out"" direction filter set.  The ""out"" direction is referred to 
     * copying headers from a Camel message to an external message.
     */
    public void setOutFilter(Set<String> value) {
        outFilter = value;
    }
    /**
     * Gets the ""out"" direction filter regular expression {@link Pattern}.  The
     * ""out"" direction is referred to copying headers from Camel message to
     * an external message.  If the pattern matches a header, the header will 
     * be filtered out. 
     * 
     * @return regular expression filter pattern
     */
    public String getOutFilterPattern() {
        return outFilterPattern == null ? null : outFilterPattern.pattern();
    }
    /**
     * Sets the ""out"" direction filter regular expression {@link Pattern}.  The
     * ""out"" direction is referred to copying headers from Camel message to
     * an external message.  If the pattern matches a header, the header will 
     * be filtered out. 
     * 
     * @param value regular expression filter pattern
     */
    public void setOutFilterPattern(String value) {
        if (value == null) {
            outFilterPattern = null;
        } else {
            outFilterPattern = Pattern.compile(value);
        }
    }
    /**
     * Gets the ""in"" direction filter set.  The ""in"" direction is referred to 
     * copying headers from an external message to a Camel message.
     * 
     * @return a set that contains header names that should be excluded.
     */
    public Set<String> getInFilter() {
        if (inFilter == null) {
            inFilter = new HashSet<String>();
        }
        return inFilter;
    }
    /**
     * Sets the ""in"" direction filter set.  The ""in"" direction is referred to 
     * copying headers from an external message to a Camel message.
     */
    public void setInFilter(Set<String> value) {
        inFilter = value;
    }
    /**
     * Gets the ""in"" direction filter regular expression {@link Pattern}.  The
     * ""in"" direction is referred to copying headers from an external message
     * to a Camel message.  If the pattern matches a header, the header will 
     * be filtered out. 
     * 
     * @return regular expression filter pattern
     */
    public String getInFilterPattern() {
        return inFilterPattern == null ? null : inFilterPattern.pattern();
    }
    /**
     * Sets the ""in"" direction filter regular expression {@link Pattern}.  The
     * ""in"" direction is referred to copying headers from an external message
     * to a Camel message.  If the pattern matches a header, the header will 
     * be filtered out. 
     * 
     * @param value regular expression filter pattern
     */
    public void setInFilterPattern(String value) {
        if (value == null) {
            inFilterPattern = null;
        } else {
            inFilterPattern = Pattern.compile(value);
        }
    }
    /**
     * Gets the isLowercase property which is a boolean to determinte
     * whether header names should be converted to lowercase before
     * checking it the filter Set.  It does not affect filtering using
     * regular expression pattern.
     */
    public boolean getIsLowercase() {
        return isLowercase;
    }
    /**
     * Sets the isLowercase property which is a boolean to determinte
     * whether header names should be converted to lowercase before
     * checking it the filter Set.  It does not affect filtering using
     * regular expression pattern.
     */
    public void setIsLowercase(boolean value) {
        isLowercase = value;
    }
    public boolean getAllowNullValues() {
        return allowNullValues;
    }
    public void setAllowNullValues(boolean value) {
        allowNullValues = value;
    }   
    protected boolean extendedFilter(Direction direction, String key, Object value) {
        return false;
    }
    private boolean doFiltering(Direction direction, String headerName, Object headerValue) {
        if (headerName == null) {
            return true;
        }
        if (headerValue == null && !allowNullValues) {
            return true;
        }
        Pattern pattern = null;
        Set<String> filter = null;
        if (Direction.OUT == direction) {
            pattern = outFilterPattern;
            filter = outFilter;                
        } else if (Direction.IN == direction) {
            pattern = inFilterPattern;
            filter = inFilter;
        }
        if (pattern != null && pattern.matcher(headerName).matches()) {
            return true;
        }
        if (filter != null) {
            if (isLowercase) {
                if (filter.contains(headerName.toLowerCase())) {
                    return true;
                }
            } else {
                if (filter.contains(headerName)) {
                    return true;
                }
            }
        }
        if (extendedFilter(direction, headerName, headerValue)) {
            return true;
        }
        return false;
    }
}
"
org.apache.camel.component.jhc.JhcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.net.URI;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
public class JhcComponent extends DefaultComponent<JhcExchange> implements HeaderFilterStrategyAware {
    private static final Log LOG = LogFactory.getLog(JhcComponent.class);
    private HttpParams params;
    private HeaderFilterStrategy headerFilterStrategy;
    public JhcComponent() {
        setHeaderFilterStrategy(new JhcHeaderFilterStrategy());
        params = new BasicHttpParams()
            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, 5000)
            .setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT, 10000)
            .setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024)
            .setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK, false)
            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, true)
            .setParameter(HttpProtocolParams.USER_AGENT, ""Camel-JhcComponent/1.1"");
    }
    public HttpParams getParams() {
        return params;
    }
    public void setParams(HttpParams params) {
        this.params = params;
    }
    protected Endpoint<JhcExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new JhcEndpoint(uri, this, new URI(uri.substring(uri.indexOf(':') + 1)));
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.builder.ProcessorFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * An interface representing a builder of a {@link Processor}
 *
 * @version $Revision$
 */
public interface ProcessorFactory {
    Processor createProcessor() throws Exception;
}
"
org.apache.camel.component.jcr.JcrComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultExchange;
/**
 * A component for integrating with JSR-170 (JCR) compliant content repositories
 */
public class JcrComponent extends DefaultComponent<DefaultExchange> {
    /**
     * Property key for specifying the name of a node in the repository 
     */
    public static final String NODE_NAME = ""org.apache.camel.component.jcr.node_name"";
    @Override @SuppressWarnings(""unchecked"")
    protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map properties) throws Exception {
        return new JcrEndpoint(uri, this);
    }
}
"
org.apache.camel.component.atom.AtomUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import org.apache.abdera.Abdera;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Feed;
import org.apache.abdera.parser.ParseException;
import org.apache.abdera.parser.Parser;
/**
 * Atom utilities.
 */
public final class AtomUtils {
    private AtomUtils() {
        // Helper class
    }
    /**
     * Gets the Atom parser.
     */
    public static Parser getAtomParser() {
        return Abdera.getInstance().getParser();
    }
    /**
     * Parses the given uri and returns the response as a atom feed document.
     *
     * @param uri the uri for the atom feed.
     * @return  the document
     * @throws IOException is thrown if error reading from the uri
     * @throws ParseException is thrown if the parsing failed
     */
    public static Document<Feed> parseDocument(String uri) throws IOException, ParseException {
        InputStream in = new URL(uri).openStream();
        return getAtomParser().parse(in);
    }
}
"
org.apache.camel.component.stream.StreamProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Producer that can write to streams
 */
public class StreamProducer extends DefaultProducer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamProducer.class);
    private static final String TYPES = ""out,err,file,header,url"";
    private static final String INVALID_URI = ""Invalid uri, valid form: 'stream:{"" + TYPES + ""}'"";
    private static final List<String> TYPES_LIST = Arrays.asList(TYPES.split("",""));
    private OutputStream outputStream = System.out;
    private StreamEndpoint endpoint;
    private String uri;
    public StreamProducer(StreamEndpoint endpoint, String uri)
        throws Exception {
        super(endpoint);
        this.endpoint = endpoint;
        validateUri(uri);
    }
    @Override
    public void doStop() throws Exception {
        // important: do not close the stream as it will close the standard system.out etc.
        super.doStop();
    }
    public void process(Exchange exchange) throws Exception {
        delay(endpoint.getDelay());
        if (""out"".equals(uri)) {
            outputStream = System.out;
        } else if (""err"".equals(uri)) {
            outputStream = System.err;
        } else if (""file"".equals(uri)) {
            outputStream = resolveStreamFromFile();
        } else if (""header"".equals(uri)) {
            outputStream = resolveStreamFromHeader(exchange.getIn().getHeader(""stream""), exchange);
        } else if (""url"".equals(uri)) {
            outputStream = resolveStreamFromUrl();
        }
        writeToStream(exchange);
    }
    private OutputStream resolveStreamFromUrl() throws IOException {
        String u = endpoint.getUrl();
        URL url = new URL(u);
        URLConnection c = url.openConnection();
        return c.getOutputStream();
    }
    private OutputStream resolveStreamFromFile() throws IOException {
        String fileName = endpoint.getFile() != null ? endpoint.getFile().trim() : ""_file"";
        File f = new File(fileName);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to write to file: "" + f);
        }
        f.createNewFile();
        return new FileOutputStream(f);
    }
    private OutputStream resolveStreamFromHeader(Object o, Exchange exchange) throws CamelExchangeException {
        if (o != null && o instanceof OutputStream) {
            return (OutputStream)o;
        } else {
            throw new CamelExchangeException(""Expected OutputStream in header('stream'), found: "" + o,
                exchange);
        }
    }
    private void delay(long ms) throws InterruptedException {
        if (ms == 0) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Delaying "" + ms + "" millis"");
        }
        Thread.sleep(ms);
    }
    private void writeToStream(Exchange exchange) throws IOException, CamelExchangeException {
        Object body = exchange.getIn().getBody();
        if (body instanceof String) {
            Charset charset = endpoint.getCharset();
            Writer writer = new OutputStreamWriter(outputStream, charset);
            BufferedWriter bw = new BufferedWriter(writer);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Writing as text: "" + body + "" to "" + outputStream + "" using encoding:"" + charset);
            }
            bw.write((String)body);
            bw.write(""\n"");
            bw.flush();
            // important: do not close the writer as it will close the standard system.out etc.
        } else if (body instanceof byte[]) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Writing as text: "" + body + "" to "" + outputStream);
            }
            outputStream.write((byte[])body);
        } else {
            throw new CamelExchangeException(""The body is neither a String or byte array. ""
                + ""Can not write body to output stream"", exchange);
        }
    }
    private void validateUri(String uri) throws Exception {
        String[] s = uri.split("":"");
        if (s.length < 2) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        String[] t = s[1].split(""\\?"");
        if (t.length < 1) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        this.uri = t[0].trim();
        if (!TYPES_LIST.contains(this.uri)) {
            throw new IllegalArgumentException(INVALID_URI);
        }
    }
}
"
org.apache.camel.spring.CamelJMXAgentType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The JAXB type class for the configuration of jmxAgent
 * @author Willem Jiang
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""jmxAgent"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelJMXAgentType extends IdentifiedType {
    /**
     * Disable JMI (default false)
     */
    @XmlAttribute(required = false)
    private Boolean disabled = Boolean.FALSE;
    /**
     * RMI connector registry port (default 1099)
     */
    @XmlAttribute(required = false)
    private Integer registryPort;
    /**
     * RMI connector server port (default -1 not used)
     */
    @XmlAttribute(required = false)
    private Integer connectorPort;
    /**
     * MBean server default domain name (default org.apache.camel)
     */
    @XmlAttribute(required = false)
    private String mbeanServerDefaultDomain;
    /**
     * MBean object domain name (default org.apache.camel)
     */
    @XmlAttribute(required = false)
    private String mbeanObjectDomainName;
    /**
     * JMX Service URL path (default /jmxrmi)
     */
    @XmlAttribute(required = false)
    private String serviceUrlPath;
    /**
     * A flag that indicates whether the agent should be created
     */
    @XmlAttribute(required = false)
    private Boolean createConnector = Boolean.TRUE;
    /**
     * A flag that indicates whether the platform mbean server should be used
     */
    @XmlAttribute(required = false)
    private Boolean usePlatformMBeanServer = Boolean.TRUE;
    public Integer getConnectorPort() {
        return connectorPort;
    }
    public void setConnectorPort(Integer value) {
        connectorPort = value;
    }
    public Integer getRegistryPort() {
        return registryPort;
    }
    public void setRegistryPort(Integer value) {
        registryPort = value;
    }
    public String getMbeanServerDefaultDomain() {
        return mbeanServerDefaultDomain;
    }
    public void setMbeanServerDefaultDomain(String value) {
        mbeanServerDefaultDomain = value;
    }
    public String getMbeanObjectDomainName() {
        return mbeanObjectDomainName;
    }
    public void setMbeanObjectDomainName(String value) {
        mbeanObjectDomainName = value;
    }
    public String getServiceUrlPath() {
        return serviceUrlPath;
    }
    public void setServiceUrlPath(String value) {
        serviceUrlPath = value;
    }
    public Boolean isCreateConnector() {
        return createConnector;
    }
    public void setCreateConnector(Boolean value) {
        createConnector = value !=  null ? value : Boolean.FALSE;
    }
    public Boolean isUsePlatformMBeanServer() {
        return usePlatformMBeanServer;
    }
    public void setUsePlatformMBeanServer(Boolean value) {
        usePlatformMBeanServer = value !=  null ? value : Boolean.FALSE;
    }
    public Boolean isDisabled() {
        return disabled;
    }
    public void setDisabled(Boolean value) {
        disabled = value != null ? value : Boolean.FALSE;
    }
}
"
org.apache.camel.component.jhc.JhcExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
public class JhcExchange extends DefaultExchange {
    public JhcExchange(CamelContext context) {
        super(context);
    }
    public JhcExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
}"
org.apache.camel.component.uface.UFaceBrowser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.Collection;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DelegateLifecycleStrategy;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import org.eclipse.core.databinding.observable.Realm;
import org.eclipse.core.databinding.observable.list.IObservableList;
import org.eclipse.core.databinding.observable.list.WritableList;
import org.eclipse.core.databinding.observable.value.WritableValue;
import org.ufacekit.model.ModelHelper;
import org.ufacekit.ui.AttributeDescriptor;
import org.ufacekit.ui.UIComposite;
import org.ufacekit.ui.UIFactory;
import org.ufacekit.ui.beanform.BeanForm;
import org.ufacekit.ui.controls.CellLabelProvider;
import org.ufacekit.ui.controls.UITable;
import org.ufacekit.ui.controls.UITableColumn;
import org.ufacekit.ui.layouts.GridLayoutData;
/**
 * @version $Revision$
 */
public class UFaceBrowser {
    private final DefaultCamelContext camelContext;
    private IObservableList endpoints;
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    public UFaceBrowser(DefaultCamelContext camelContext) {
        ObjectHelper.notNull(camelContext, ""camelContext"");
        this.camelContext = camelContext;
        this.endpoints = new WritableList(Realm.getDefault());
        // lets add any endpoints already added
        List<BrowsableEndpoint> list = CamelContextHelper.getSingletonEndpoints(camelContext, BrowsableEndpoint.class);
        for (BrowsableEndpoint endpoint : list) {
            if (!endpoints.contains(endpoint)) {
                endpoints.add(endpoint);
            }
        }
        camelContext.setLifecycleStrategy(new DelegateLifecycleStrategy(camelContext.getLifecycleStrategy()) {
            @Override
            public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
                super.onEndpointAdd(endpoint);
                if (endpoint instanceof BrowsableEndpoint) {
                    onBrowsableEndpoint((BrowsableEndpoint) endpoint);
                }
            }
        });
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public IObservableList getEndpoints() {
        return endpoints;
    }
    public DefaultCamelContext getCamelContext() {
        return camelContext;
    }
    public void createBrowserUI(UIComposite root) {
        UIFactory ui = root.getFactory();
        UIComposite splitter = ui.newHorizontalSplitPanel(root, new GridLayoutData(GridLayoutData.ALIGN_CENTER, GridLayoutData.ALIGN_CENTER));
        UITable tree = createEndpointTableUI(splitter);
        BeanForm selectionForm = new BeanForm();
        UITable table = ui.newTable(splitter, new UITable.TableUIInfo(new GridLayoutData(GridLayoutData.ALIGN_FILL, GridLayoutData.ALIGN_FILL, true, true)));
        selectionForm.add(table, new UITable.TableBindingInfo(selectionForm.detailList(""exchanges"", Collection.class)));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                Exchange exchange = (Exchange) object;
                return exchange.getIn().getBody(String.class);
            }
        }));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                Exchange exchange = (Exchange) object;
                return exchange.getIn().getHeaders().toString();
            }
        }));
        selectionForm.bind(tree.getSelectionObservable());
    }
    protected UITable createEndpointTableUI(UIComposite root) {
        BeanForm form = new BeanForm();
        UIFactory ui = root.getFactory();
        AttributeDescriptor bindingData = form.detailList(""endpoints"", Collection.class);
        UITable table = ui.newTable(root, new UITable.TableUIInfo(null));
        form.add(table, new UITable.TableBindingInfo(bindingData));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                BrowsableEndpoint endpoint = (BrowsableEndpoint) object;
                return endpoint.getEndpointUri();
            }
        }));
        WritableValue value = ModelHelper.createWritableValue(this);
        form.bind(value);
        return table;
    }
    protected void onBrowsableEndpoint(BrowsableEndpoint endpoint) {
        endpoints.add(endpoint);
    }
}
"
org.apache.camel.component.jhc.JhcConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.HttpEntity;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.ProtocolVersion;
import org.apache.http.impl.DefaultHttpResponseFactory;
import org.apache.http.nio.NHttpConnection;
import org.apache.http.nio.protocol.EventListener;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpRequestHandler;
/**
 * Created by IntelliJ IDEA. User: gnodet Date: Sep 7, 2007 Time: 8:15:54 PM To
 * change this template use File | Settings | File Templates.
 */
public class JhcConsumer extends DefaultConsumer<JhcExchange> {
    private static final Log LOG = LogFactory.getLog(JhcConsumer.class);
    private JhcServerEngine engine;
    private MyHandler handler;
    public JhcConsumer(JhcEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        engine = JhcServerEngineFactory.getJhcServerEngine(endpoint.getParams(), endpoint.getPort(), endpoint
            .getProtocol());
        handler = new MyHandler(endpoint.getParams(), endpoint.getPath());
    }
    public JhcEndpoint getEndpoint() {
        return (JhcEndpoint)super.getEndpoint();
    }
    protected void doStart() throws Exception {
        super.doStart();
        engine.register(handler.getPath() + ""*"", handler);
        if (!engine.isStarted()) {
            engine.start();
        }
    }
    protected void doStop() throws Exception {
        engine.unregister(handler.getPath() + ""*"");
        if (engine.getReferenceCounter() == 0) {
            engine.stop();
        }
        super.doStop();
    }
    class MyHttpRequestHandler implements HttpRequestHandler {
        public void handle(HttpRequest httpRequest, HttpResponse httpResponse, HttpContext httpContext)
            throws HttpException, IOException {
            LOG.debug(""handle"");
        }
    }
    static class EventLogger implements EventListener {
        public void connectionOpen(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection open: "" + conn);
            }
        }
        public void connectionTimeout(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection timed out: "" + conn);
            }
        }
        public void connectionClosed(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection closed: "" + conn);
            }
        }
        public void fatalIOException(final IOException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""I/O error: "" + ex.getMessage());
            }
        }
        public void fatalProtocolException(final HttpException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""HTTP error: "" + ex.getMessage());
            }
        }
    }
    class MyHandler implements AsyncHttpRequestHandler {
        private final HttpParams params;
        private final HttpResponseFactory responseFactory;
        private final String path;
        public MyHandler(HttpParams params, String path) {
            this(params, path, new DefaultHttpResponseFactory());
        }
        public MyHandler(HttpParams params, String path, HttpResponseFactory responseFactory) {
            this.params = params;
            this.path = path;
            this.responseFactory = responseFactory;
        }
        public String getPath() {
            return path;
        }
        public void handle(final HttpRequest request, final HttpContext context,
                           final AsyncResponseHandler handler) throws HttpException, IOException {
            final Exchange exchange = getEndpoint().createExchange();
            exchange.getIn().setHeader(""http.uri"", request.getRequestLine().getUri());
            if (request instanceof HttpEntityEnclosingRequest) {
                exchange.getIn().setBody(((HttpEntityEnclosingRequest)request).getEntity());
            }
            getAsyncProcessor().process(exchange, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    LOG.debug(""handleExchange"");
                    // create the default response to this request
                    ProtocolVersion httpVersion = (HttpVersion)request.getRequestLine().getProtocolVersion();
                    HttpResponse response = responseFactory.newHttpResponse(
                        httpVersion, HttpStatus.SC_OK, context);
                    response.setParams(params);
                    HttpEntity entity = exchange.getOut().getBody(HttpEntity.class);
                    response.setEntity(entity);
                    response.setParams(getEndpoint().getParams());
                    try {
                        handler.sendResponse(response);
                    } catch (Exception e) {
                        LOG.info(e);
                    }
                }
            });
        }
        public void handle(HttpRequest request, HttpResponse response, HttpContext context)
            throws HttpException, IOException {
            // now we just handler the requset async, do nothing here
        }
    }
}
"
org.apache.camel.builder.NoRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
/**
 * A helper class, usually used for testing which does not create any routes.
 *
 * @version $Revision$
 */
public class NoRouteBuilder extends RouteBuilder {
    private static final NoRouteBuilder INSTANCE = new NoRouteBuilder();
    public static NoRouteBuilder getInstance() {
        return INSTANCE;
    }
    public void configure() throws Exception {
    }
}
"
org.apache.camel.impl.DefaultComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.net.URI;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.URISupport;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Default component to use for base for components implementations.
 *
 * @version $Revision$
 */
public abstract class DefaultComponent<E extends Exchange> extends ServiceSupport implements Component<E> {
    private static final transient Log LOG = LogFactory.getLog(DefaultComponent.class);
    private int defaultThreadPoolSize = 5;
    private CamelContext camelContext;
    private ScheduledExecutorService executorService;
    public DefaultComponent() {
    }
    public DefaultComponent(CamelContext context) {
        this.camelContext = context;
    }
    public Endpoint<E> createEndpoint(String uri) throws Exception {
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
        //encode URI string to the unsafe URI characters
        URI u = new URI(UnsafeUriCharactersEncoder.encode(uri));
        String path = u.getSchemeSpecificPart();
        // lets trim off any query arguments
        if (path.startsWith(""//"")) {
            path = path.substring(2);
        }
        int idx = path.indexOf('?');
        if (idx > 0) {
            path = path.substring(0, idx);
        }
        Map parameters = URISupport.parseParameters(u);
        validateURI(uri, path, parameters);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating endpoint uri=["" + uri + ""], path=["" + path + ""], parameters=["" + parameters + ""]"");
        }
        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);
        if (endpoint == null) {
            return null;
        }
        if (parameters != null) {
            endpoint.configureProperties(parameters);
            if (useIntrospectionOnEndpoint()) {
                setProperties(endpoint, parameters);
            }
            // if endpoint is strict (not lenient) and we have unknown parameters configured then
            // fail if there are parameters that could not be set, then they are probably miss spelt or not supported at all
            if (!endpoint.isLenientProperties() && parameters.size() > 0) {
                throw new ResolveEndpointFailedException(uri, ""There are "" + parameters.size()
                    + "" parameters that couldn't be set on the endpoint.""
                    + "" Check the uri if the parameters are spelt correctly and that they are properties of the endpoint.""
                    + "" Unknown parameters=["" + parameters + ""]"");
            }
        }
        return endpoint;
    }
    /**
     * Strategy for validation of the uri when creating the endpoint.
     *
     * @param uri        the uri - the uri the end user provided untouched
     * @param path       the path - part after the scheme
     * @param parameters the parameters, an empty map if no parameters given
     * @throws ResolveEndpointFailedException should be thrown if the URI validation failed
     */
    protected void validateURI(String uri, String path, Map parameters) throws ResolveEndpointFailedException {
        // check for uri containing & but no ? marker
        if (uri.contains(""&"") && !uri.contains(""?"")) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: no ? marker however the uri ""
                + ""has & parameter separators. Check the uri if its missing a ? marker."");
        }
        // check for uri containing double && markers
        if (uri.contains(""&&"")) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Double && marker found. ""
                + ""Check the uri and remove the duplicate & marker."");
        }
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext context) {
        this.camelContext = context;
    }
    public ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            executorService = createExecutorService();
        }
        return executorService;
    }
    public void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    /**
     * A factory method to create a default thread pool and executor
     */
    protected ScheduledExecutorService createExecutorService() {
        return new ScheduledThreadPoolExecutor(defaultThreadPoolSize, new ThreadFactory() {
            int counter;
            public synchronized Thread newThread(Runnable runnable) {
                Thread thread = new Thread(runnable);
                thread.setName(""Thread: "" + (++counter) + "" "" + DefaultComponent.this.toString());
                return thread;
            }
        });
    }
    protected void doStart() throws Exception {
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
    }
    protected void doStop() throws Exception {
        if (executorService != null) {
            executorService.shutdown();
        }
    }
    /**
     * A factory method allowing derived components to create a new endpoint
     * from the given URI, remaining path and optional parameters
     *
     * @param uri the full URI of the endpoint
     * @param remaining the remaining part of the URI without the query
     *                parameters or component prefix
     * @param parameters the optional parameters passed in
     * @return a newly created endpoint or null if the endpoint cannot be
     *         created based on the inputs
     */
    protected abstract Endpoint<E> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception;
    /**
     * Sets the bean properties on the given bean
     */
    protected void setProperties(Object bean, Map parameters) throws Exception {
        IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), bean, parameters);
    }
    /**
     * Derived classes may wish to overload this to prevent the default introspection of URI parameters
     * on the created Endpoint instance
     */
    protected boolean useIntrospectionOnEndpoint() {
        return true;
    }
    // Some helper methods
    //-------------------------------------------------------------------------
    /**
     * Converts the given value to the requested type
     */
    public <T> T convertTo(Class<T> type, Object value) {
        return CamelContextHelper.convertTo(getCamelContext(), type, value);
    }
    /**
     * Converts the given value to the specified type throwing an {@link IllegalArgumentException}
     * if the value could not be converted to a non null value
     */
    public  <T> T mandatoryConvertTo(Class<T> type, Object value) {
        return CamelContextHelper.mandatoryConvertTo(getCamelContext(), type, value);
    }
    /**
     * Creates a new instance of the given type using the {@link Injector} on the given
     * {@link CamelContext}
     */
    public  <T> T newInstance(Class<T> beanType) {
        return getCamelContext().getInjector().newInstance(beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext}
     */
    public Object lookup(String name) {
        return getCamelContext().getRegistry().lookup(name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public <T> T lookup(String name, Class<T> beanType) {
        return getCamelContext().getRegistry().lookup(name, beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext} or throws
     */
    public Object mandatoryLookup(String name) {
        return CamelContextHelper.mandatoryLookup(getCamelContext(), name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public <T> T mandatoryLookup(String name, Class<T> beanType) {
        return CamelContextHelper.mandatoryLookup(getCamelContext(), name, beanType);
    }
    /**
     * Gets the parameter and remove it from the parameter map.
     * 
     * @param parameters  the parameters
     * @param key        the key
     * @param type       the requested type to convert the value from the parameter
     * @return  the converted value parameter, <tt>null</tt> if parameter does not exists.
     */
    public <T> T getAndRemoveParameter(Map parameters, String key, Class<T> type) {
        return getAndRemoveParameter(parameters, key, type, null);
    }
    /**
     * Gets the parameter and remove it from the parameter map.
     *
     * @param parameters     the parameters
     * @param key           the key
     * @param type          the requested type to convert the value from the parameter
     * @param defaultValue  use this default value if the parameter does not contain the key
     * @return  the converted value parameter
     */
    public <T> T getAndRemoveParameter(Map parameters, String key, Class<T> type, T defaultValue) {
        Object value = parameters.remove(key);
        if (value == null) {
            value = defaultValue;
        }
        if (value == null) {
            return null;
        }
        return convertTo(type, value);
    }
}
"
org.apache.camel.impl.converter.ToStringTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
/**
 * A simple converter that can convert any object to a String type by using the
 * toString() method of the object.
 *
 * @version $Revision$
 */
public class ToStringTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(String.class)) {
                return (T)value.toString();
            }
        }
        return null;
    }
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        return convertTo(type, value);
    }
}
"
org.apache.camel.component.rmi.RmiComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class RmiComponent extends DefaultComponent<BeanExchange> {
    public RmiComponent() {
    }
    public RmiComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<BeanExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new RmiEndpoint(uri, this);
    }
}
"
org.apache.camel.component.cxf.transport.CamelDestination,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfSoapBinding;
import org.apache.camel.component.cxf.util.CxfHeaderHelper;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.AbstractDestination;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import org.apache.cxf.wsdl.EndpointReferenceUtils;
/**
 * @version $Revision$
 */
public class CamelDestination extends AbstractDestination implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-destination"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelDestination.class);
    final ConduitInitiator conduitInitiator;
    CamelContext camelContext;
    Consumer consumer;
    String camelDestinationUri;
    private ProducerTemplate<Exchange> camelTemplate;
    private Endpoint distinationEndpoint;
    private HeaderFilterStrategy headerFilterStrategy;
    public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info) throws IOException {
        this(camelContext, bus, ci, info, null);
    }
    public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info,
            HeaderFilterStrategy headerFilterStrategy) throws IOException {
        super(bus, getTargetReference(info, bus), info);
        this.camelContext = camelContext;
        conduitInitiator = ci;
        camelDestinationUri = endpointInfo.getAddress().substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());
        if (camelDestinationUri.startsWith(""//"")) {
            camelDestinationUri = camelDestinationUri.substring(2);
        }
        initConfig();
        this.headerFilterStrategy = headerFilterStrategy;
    }
    protected Logger getLogger() {
        return LOG;
    }
    /**
     * @param inMessage the incoming message
     * @return the inbuilt backchannel
     */
    protected Conduit getInbuiltBackChannel(Message inMessage) {
        //we can pass the message back by looking up the camelExchange from inMessage
        return new BackChannelConduit(inMessage);
    }
    public void activate() {
        getLogger().log(Level.FINE, ""CamelDestination activate().... "");
        try {
            getLogger().log(Level.FINE, ""establishing Camel connection"");            
            distinationEndpoint = getCamelContext().getEndpoint(camelDestinationUri);
            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());
            consumer.start();
        } catch (Exception ex) {
            // TODO: Is it okay just to log severe errors such as this?
            getLogger().log(Level.SEVERE, ""Camel connect failed with Exception : "", ex);
        }
    }
    public void deactivate() {
        try {
            consumer.stop();
        } catch (Exception e) {
            // TODO: Is it okay just to log severe errors such as this?
            getLogger().log(Level.SEVERE, ""Camel stop failed with Exception : "", e);
        }
    }
    public void shutdown() {
        getLogger().log(Level.FINE, ""CamelDestination shutdown()"");
        this.deactivate();
    }
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {            
            camelTemplate = getCamelContext().createProducerTemplate();
        }
        return camelTemplate;
    }
    public void setCamelTemplate(ProducerTemplate<Exchange> template) {
        camelTemplate = template;
    }
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        if (camelContext == null) {
            getLogger().log(Level.INFO, ""No CamelContext injected, create a default one"");
            camelContext = new DefaultCamelContext();
        }
        return camelContext;
    }
    protected void incoming(org.apache.camel.Exchange camelExchange) {
        getLogger().log(Level.FINE, ""server received request: "", camelExchange);
        org.apache.cxf.message.Message inMessage =
            CxfSoapBinding.getCxfInMessage(headerFilterStrategy, camelExchange, false);
        inMessage.put(CxfConstants.CAMEL_EXCHANGE, camelExchange);
        ((MessageImpl)inMessage).setDestination(this);
        // Handling the incoming message
        // The response message will be send back by the outgoingchain        
        incomingObserver.onMessage(inMessage);
    }
    public String getBeanName() {
        if (endpointInfo == null || endpointInfo.getName() == null) {
            return ""default"" + BASE_BEAN_NAME_SUFFIX;
        }        
        return endpointInfo.getName().toString() + BASE_BEAN_NAME_SUFFIX;
    }
    private void initConfig() {
        //we could configure the camel context here
        if (bus != null) {            
            Configurer configurer = bus.getExtension(Configurer.class);
            if (null != configurer) {
                configurer.configureBean(this);
            }
        }
    }
    protected class ConsumerProcessor implements Processor {
        public void process(Exchange exchange) {
            try {
                incoming(exchange);
            } catch (Throwable ex) {
                getLogger().log(Level.WARNING, ""Failed to process incoming message : "", ex);
            }
        }
    }
    // this should deal with the cxf message
    protected class BackChannelConduit extends AbstractConduit {
        protected Message inMessage;
        Exchange camelExchange;
        org.apache.cxf.message.Exchange cxfExchange;
        BackChannelConduit(Message message) {
            super(EndpointReferenceUtils.getAnonymousEndpointReference());
            inMessage = message;
            cxfExchange = inMessage.getExchange();
            camelExchange = cxfExchange.get(Exchange.class);
        }
        /**
         * Register a message observer for incoming messages.
         *
         * @param observer the observer to notify on receipt of incoming
         */
        public void setMessageObserver(MessageObserver observer) {
            // shouldn't be called for a back channel conduit
        }
        /**
         * Send an outbound message, assumed to contain all the name-value
         * mappings of the corresponding input message (if any).
         *
         * @param message the message to be sent.
         */
        public void prepare(Message message) throws IOException {
            message.put(CxfConstants.CAMEL_EXCHANGE, inMessage.get(CxfConstants.CAMEL_EXCHANGE));
            message.setContent(OutputStream.class, new CamelOutputStream(message));
        }
        protected Logger getLogger() {
            return LOG;
        }
    }
    /**
     * Mark message as a partial message.
     *
     * @param partialResponse the partial response message
     * @param decoupledTarget the decoupled target
     * @return <tt>true</tt> if partial responses is supported
     */
    protected boolean markPartialResponse(Message partialResponse,
                                       EndpointReferenceType decoupledTarget) {
        return true;
    }
    /**
     * @return the associated conduit initiator
     */
    protected ConduitInitiator getConduitInitiator() {
        return conduitInitiator;
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message outMessage;
        public CamelOutputStream(Message m) {
            super();
            outMessage = m;
        }
        // Prepare the message and get the send out message
        private void commitOutputMessage() throws IOException {
            Exchange camelExchange = (Exchange)outMessage.get(CxfConstants.CAMEL_EXCHANGE);
            CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, camelExchange.getOut().getHeaders());
            CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
            camelExchange.getOut().setBody(outputStream.getBytes());
            getLogger().log(Level.FINE, ""send the response message: "" + outputStream);
        }
        @Override
        protected void doFlush() throws IOException {
            // Do nothing here
        }
        @Override
        protected void doClose() throws IOException {
            commitOutputMessage();
        }
        @Override
        protected void onWrite() throws IOException {
            // Do nothing here
        }
    }
}
"
org.apache.camel.component.bean.MethodBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.io.Serializable;
import java.lang.reflect.Method;
/**
 * Represents a {@link Serializable} version of a {@link Method}
 *
 * @version $Revision$
 */
public class MethodBean implements Serializable {
    private String name;
    private Class<?> type;
    private Class<?>[] parameterTypes;
    public MethodBean() {
    }
    public MethodBean(Method method) {
        this.name = method.getName();
        this.type = method.getDeclaringClass();
        this.parameterTypes = method.getParameterTypes();
    }
    public Method getMethod() throws NoSuchMethodException {
        return type.getMethod(name, parameterTypes);
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Class<?>[] getParameterTypes() {
        return parameterTypes;
    }
    public void setParameterTypes(Class<?>[] parameterTypes) {
        this.parameterTypes = parameterTypes;
    }
    public Class<?> getType() {
        return type;
    }
    public void setType(Class<?> type) {
        this.type = type;
    }
}
"
org.apache.camel.component.file.strategy.FileProcessStrategySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.RandomAccessFile;
import java.nio.channels.Channel;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.camel.component.file.FileProcessStrategy;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for {@link org.apache.camel.component.file.FileProcessStrategy} implementation to extend.
 *
 * @version $Revision$
 */
public abstract class FileProcessStrategySupport implements FileProcessStrategy {
    private static final transient Log LOG = LogFactory.getLog(FileProcessStrategySupport.class);
    private boolean lockFile;
    private FileRenamer lockFileRenamer;
    protected FileProcessStrategySupport() {
        this(true);
    }
    protected FileProcessStrategySupport(boolean lockFile) {
        this(lockFile, new DefaultFileRenamer(null, FileEndpoint.DEFAULT_LOCK_FILE_POSTFIX));
    }
    protected FileProcessStrategySupport(boolean lockFile, FileRenamer lockFileRenamer) {
        this.lockFile = lockFile;
        this.lockFileRenamer = lockFileRenamer;
    }
    public boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            File newFile = lockFileRenamer.renameFile(exchange, file);
            String lockFileName = newFile.getAbsolutePath();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Locking the file: "" + file + "" using the lock file name: "" + lockFileName);
            }
            FileChannel channel = new RandomAccessFile(lockFileName, ""rw"").getChannel();
            FileLock lock = channel.lock();
            if (lock != null) {
                exchange.setProperty(""org.apache.camel.file.lock"", lock);
                exchange.setProperty(""org.apache.camel.file.lock.name"", lockFileName);
                return true;
            } else {
                return false;
            }
        }
        return true;
    }
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        unlockFile(endpoint, exchange, file);
    }
    public void rollback(FileEndpoint endpoint, FileExchange exchange, File file) {
        try {
            unlockFile(endpoint, exchange, file);
        } catch (Exception e) {
            LOG.warn(""Unable to unlock file: "" + file, e);
        }
    }
    public boolean isLockFile() {
        return lockFile;
    }
    public void setLockFile(boolean lockFile) {
        this.lockFile = lockFile;
    }
    public FileRenamer getLockFileRenamer() {
        return lockFileRenamer;
    }
    public void setLockFileRenamer(FileRenamer lockFileRenamer) {
        this.lockFileRenamer = lockFileRenamer;
    }
    protected void unlockFile(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            FileLock lock = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.file.lock"", FileLock.class);
            String lockFileName = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.file.lock.name"", String.class);
            Channel channel = lock.channel();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Unlocking file: "" + file);
            }
            try {
                lock.release();
            } finally {
                // must close channel
                ObjectHelper.close(channel, ""Closing channel"", LOG);
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Deleting lock file: "" + lockFileName);
                }
                File lockfile = new File(lockFileName);
                lockfile.delete();
            }
        }
    }
}
"
org.apache.camel.builder.script.PHP,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of PHP expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""php"")
public @interface PHP {
    String value();
}"
org.apache.camel.builder.LoggingErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.model.LoggingLevel;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingErrorHandler;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Uses the {@link Logger} as an error handler, will log at <tt>ERROR</tt> level by default.
 *
 * @version $Revision$
 */
public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    private Log log = LogFactory.getLog(Logger.class);
    private LoggingLevel level = LoggingLevel.ERROR;
    public LoggingErrorHandlerBuilder() {
    }
    public LoggingErrorHandlerBuilder(final Log log) {
        this.log = log;
    }
    public LoggingErrorHandlerBuilder(final Log log, final LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public ErrorHandlerBuilder copy() {
        LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder();
        answer.setLog(getLog());
        answer.setLevel(getLevel());
        return answer;
    }
    public Processor createErrorHandler(final RouteContext routeContext, final Processor processor) {
        LoggingErrorHandler handler = new LoggingErrorHandler(processor, log, level);
        configure(handler);
        return handler;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(final LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(final Log log) {
        this.log = log;
    }
    public LoggingErrorHandlerBuilder level(final LoggingLevel level) {
        this.level = level;
        return this;
    }
    public LoggingErrorHandlerBuilder log(final Log log) {
        this.log = log;
        return this;
    }
}
"
org.apache.camel.component.jpa.JpaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Map;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.springframework.orm.jpa.JpaTemplate;
/**
 * @version $Revision$
 */
public class JpaEndpoint extends ScheduledPollEndpoint<Exchange> {
    private EntityManagerFactory entityManagerFactory;
    private String persistenceUnit = ""camel"";
    private JpaTemplate template;
    private Expression<Exchange> producerExpression;
    private int maximumResults = -1;
    private Class<?> entityType;
    private Map entityManagerProperties;
    private boolean consumeDelete = true;
    private boolean consumeLockEntity = true;
    private boolean flushOnSend = true;
    public JpaEndpoint(String uri, JpaComponent component) {
        super(uri, component);
        entityManagerFactory = component.getEntityManagerFactory();
    }
    public JpaEndpoint(String endpointUri, EntityManagerFactory entityManagerFactory) {
        super(endpointUri);
        this.entityManagerFactory = entityManagerFactory;
    }
    public JpaEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        validate();
        return new JpaProducer(this, getProducerExpression());
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        validate();
        JpaConsumer consumer = new JpaConsumer(this, processor);
        configureConsumer(consumer);
        return consumer;
    }
    @Override
    public void configureProperties(Map options) {
        super.configureProperties(options);
        Map emProperties = IntrospectionSupport.extractProperties(options, ""emf."");
        if (emProperties != null) {
            setEntityManagerProperties(emProperties);
        }
    }
    public boolean isSingleton() {
        return false;
    }
    // Properties
    // -------------------------------------------------------------------------
    public JpaTemplate getTemplate() {
        if (template == null) {
            template = createTemplate();
        }
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    public Expression<Exchange> getProducerExpression() {
        if (producerExpression == null) {
            producerExpression = createProducerExpression();
        }
        return producerExpression;
    }
    public void setProducerExpression(Expression<Exchange> producerExpression) {
        this.producerExpression = producerExpression;
    }
    public int getMaximumResults() {
        return maximumResults;
    }
    public void setMaximumResults(int maximumResults) {
        this.maximumResults = maximumResults;
    }
    public Class<?> getEntityType() {
        return entityType;
    }
    public void setEntityType(Class<?> entityType) {
        this.entityType = entityType;
    }
    public EntityManagerFactory getEntityManagerFactory() {
        if (entityManagerFactory == null) {
            entityManagerFactory = createEntityManagerFactory();
        }
        return entityManagerFactory;
    }
    public void setEntityManagerFactory(EntityManagerFactory entityManagerFactory) {
        this.entityManagerFactory = entityManagerFactory;
    }
    public Map getEntityManagerProperties() {
        if (entityManagerProperties == null) {
            entityManagerProperties = System.getProperties();
        }
        return entityManagerProperties;
    }
    public void setEntityManagerProperties(Map entityManagerProperties) {
        this.entityManagerProperties = entityManagerProperties;
    }
    public String getPersistenceUnit() {
        return persistenceUnit;
    }
    public void setPersistenceUnit(String persistenceUnit) {
        this.persistenceUnit = persistenceUnit;
    }
    public boolean isConsumeDelete() {
        return consumeDelete;
    }
    public void setConsumeDelete(boolean consumeDelete) {
        this.consumeDelete = consumeDelete;
    }
    public boolean isConsumeLockEntity() {
        return consumeLockEntity;
    }
    public void setConsumeLockEntity(boolean consumeLockEntity) {
        this.consumeLockEntity = consumeLockEntity;
    }
    public boolean isFlushOnSend() {
        return flushOnSend;
    }
    public void setFlushOnSend(boolean flushOnSend) {
        this.flushOnSend = flushOnSend;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void validate() {
        ObjectHelper.notNull(getEntityManagerFactory(), ""entityManagerFactory property"");
    }
    protected JpaTemplate createTemplate() {
        return new JpaTemplate(getEntityManagerFactory());
    }
    protected EntityManagerFactory createEntityManagerFactory() {
        return Persistence.createEntityManagerFactory(persistenceUnit, getEntityManagerProperties());
    }
    protected EntityManager createEntityManager() {
        return getEntityManagerFactory().createEntityManager();
    }
    protected TransactionStrategy createTransactionStrategy() {
        EntityManagerFactory emf = getEntityManagerFactory();
        return JpaTemplateTransactionStrategy.newInstance(emf, getTemplate());
        // return new DefaultTransactionStrategy(emf);
    }
    protected Expression<Exchange> createProducerExpression() {
        final Class<?> type = getEntityType();
        if (type == null) {
            return ExpressionBuilder.bodyExpression();
        } else {
            return new Expression<Exchange>() {
                public Object evaluate(Exchange exchange) {
                    Object answer = exchange.getIn().getBody(type);
                    if (answer == null) {
                        Object defaultValue = exchange.getIn().getBody();
                        if (defaultValue != null) {
                            throw new NoTypeConversionAvailableException(defaultValue, type);
                        }
                        // if we don't have a body then
                        // lets instantiate and inject a new instance
                        answer = exchange.getContext().getInjector().newInstance(type);
                    }
                    return answer;
                }
            };
        }
    }
}
"
org.apache.camel.impl.StringDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * The text based <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a> supporting
 * charset encoding.
 *
 * @version $Revision$
 */
public class StringDataFormat implements DataFormat {
    private String charset;
    public StringDataFormat(String charset) {
        this.charset = charset;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        String text = ExchangeHelper.convertToType(exchange, String.class, graph);
        byte[] bytes;
        if (charset != null) {
            bytes = text.getBytes(charset);
        } else {
            bytes = text.getBytes();
        }
        stream.write(bytes);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        byte[] bytes = IOConverter.toBytes(stream);
        String answer;
        if (charset != null) {
            answer = new String(bytes, charset);
        } else {
            answer = new String(bytes);
        }
        return answer;
    }
}"
org.apache.camel.InOnly,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks methods as being {@link ExchangePattern#InOnly}
 * for one way asynchronous invocation when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a> or
 * <a href=""http://activemq.apache.org/camel/spring-remoting.html"">Spring Remoting</a>
 * to overload the default value which is {@link ExchangePattern#InOut} for request/reply if no annotations are used.
 *
 * This annotation can be added to individual methods or added to a class or interface to act as a default for all methods
 * within the class or interface.
 *
 * See the <a href=""using-exchange-pattern-annotations.html"">using exchange pattern annotations</a>
 * for more details on how the overloading rules work.
 *
 * @see org.apache.camel.ExchangePattern
 * @see org.apache.camel.Exchange#getPattern()
 * @see InOut
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Pattern(ExchangePattern.InOnly)
public @interface InOnly {
}"
org.apache.camel.builder.xml.StreamResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link StreamResultHandler}
 *
 * @version $Revision$
 */
public class StreamResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StreamResultHandler();
    }
}
"
org.apache.camel.builder.xml.ResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link org.apache.camel.builder.xml.ResultHandler}
 *
 * @version $Revision$
 */
public interface ResultHandlerFactory {
    ResultHandler createResult();
}
"
org.apache.camel.management.InstrumentationProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMX enabled processor that uses the {@link Counter} for instrumenting
 * processing of exchanges.
 *
 * @version $Revision$
 */
public class InstrumentationProcessor extends DelegateProcessor implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationProcessor.class);
    private PerformanceCounter counter;
    public InstrumentationProcessor(PerformanceCounter counter) {
        this.counter = counter;
    }
    public InstrumentationProcessor() {
    }
    @Override
    public String toString() {
        return ""Instrumentation("" + processor + "")"";
    }
    public void setCounter(PerformanceCounter counter) {
        this.counter = counter;
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (processor == null) {
            // no processor so nothing to process, so return
            callback.done(true);
            return true;
        }
        final long startTime = System.nanoTime();
        if (processor instanceof AsyncProcessor) {
            return ((AsyncProcessor)processor).process(exchange, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    if (counter != null) {
                        // convert nanoseconds to milliseconds
                        recordTime(exchange, (System.nanoTime() - startTime) / 1000000.0);
                    }
                    callback.done(doneSynchronously);
                }
            });
        }
        try {
            processor.process(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        if (counter != null) {
            // convert nanoseconds to milliseconds
            recordTime(exchange, (System.nanoTime() - startTime) / 1000000.0);
        }
        callback.done(true);
        return true;
    }
    protected void recordTime(Exchange exchange, double duration) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Recording duration: "" + duration + "" millis for exchange: "" + exchange);
        }
        if (!exchange.isFailed() && exchange.getException() == null) {
            counter.completedExchange(duration);
        } else {
            counter.failedExchange();
        }
    }
}
"
org.apache.camel.component.jms.EndpointMessageListener,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Session;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
/**
 * A JMS {@link MessageListener} which can be used to delegate processing to a
 * Camel endpoint.
 *
 * Note that instance of this object has to be thread safe (reentrant)
 *
 * @version $Revision$
 */
public class EndpointMessageListener implements MessageListener {
    private static final transient Log LOG = LogFactory.getLog(EndpointMessageListener.class);
    private JmsEndpoint endpoint;
    private Processor processor;
    private JmsBinding binding;
    private boolean eagerLoadingOfProperties;
    private Destination replyToDestination;
    private JmsOperations template;
    private boolean disableReplyTo;
    public EndpointMessageListener(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
        endpoint.getConfiguration().configure(this);
    }
    public void onMessage(final Message message) {
        RuntimeCamelException rce = null;
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(endpoint + "" consumer receiving JMS message: "" + message);
            }
            Destination replyDestination = getReplyToDestination(message);
            final JmsExchange exchange = createExchange(message, replyDestination);
            if (eagerLoadingOfProperties) {
                exchange.getIn().getHeaders();
            }
            // process the exchange
            processor.process(exchange);
            // get the correct jms message to send as reply
            JmsMessage body = null;
            if (exchange.isFailed()) {
                if (exchange.getException() != null) {
                    // an exception occured while processing
                    // TODO: Camel-585 somekind of flag to determine if we should send the exchange back to the client
                    // or do as now where we wrap as runtime exception to be thrown back to spring so it can do rollback
                    rce = wrapRuntimeCamelException(exchange.getException());
                } else if (exchange.getFault().getBody() != null) {
                    // a fault occured while processing
                    body = exchange.getFault();
                }
            } else {
                // process OK so get the reply
                body = exchange.getOut(false);
            }
            // send the reply
            if (rce == null && body != null && !disableReplyTo) {
                sendReply(replyDestination, message, exchange, body);
            }
        } catch (Exception e) {
            rce = wrapRuntimeCamelException(e);
        }
        if (rce != null) {
            LOG.warn(endpoint + "" consumer caught an exception while processing ""
                     + ""JMS message: "" + message, rce);
            throw rce;
        }
    }
    public JmsExchange createExchange(Message message, Destination replyDestination) {
        JmsExchange exchange = new JmsExchange(endpoint.getCamelContext(), endpoint.getExchangePattern(), getBinding(), message);
        // lets set to an InOut if we have some kind of reply-to destination
        if (replyDestination != null && !disableReplyTo) {
            exchange.setProperty(""org.apache.camel.jms.replyDestination"", replyDestination);
            exchange.setPattern(ExchangePattern.InOut);
        }
        return exchange;
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding(endpoint);
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }
    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }
    public synchronized JmsOperations getTemplate() {
        if (template == null) {
            template = endpoint.createInOnlyTemplate();
        }
        return template;
    }
    public void setTemplate(JmsOperations template) {
        this.template = template;
    }
    public boolean isDisableReplyTo() {
        return disableReplyTo;
    }
    /**
     * Allows the reply-to behaviour to be disabled
     */
    public void setDisableReplyTo(boolean disableReplyTo) {
        this.disableReplyTo = disableReplyTo;
    }
    public Destination getReplyToDestination() {
        return replyToDestination;
    }
    /**
     * Provides an explicit reply to destination which overrides
     * any incoming value of {@link Message#getJMSReplyTo()}
     *
     * @param replyToDestination the destination that should be used to send replies to
     */
    public void setReplyToDestination(Destination replyToDestination) {
        this.replyToDestination = replyToDestination;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void sendReply(Destination replyDestination, final Message message, final JmsExchange exchange, final JmsMessage out) {
        if (replyDestination == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Cannot send reply message as there is no replyDestination for: "" + out);
            }
            return;
        }
        getTemplate().send(replyDestination, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session);
                if (endpoint.getConfiguration().isUseMessageIDAsCorrelationID()) {
                    String messageID = exchange.getIn().getHeader(""JMSMessageID"", String.class);
                    reply.setJMSCorrelationID(messageID);
                } else {
                    String correlationID = message.getJMSCorrelationID();
                    if (correlationID != null) {
                        reply.setJMSCorrelationID(correlationID);
                    }
                }
                if (LOG.isDebugEnabled()) {
                    LOG.debug(endpoint + "" sending reply JMS message: "" + reply);
                }
                return reply;
            }
        });
    }
    protected Destination getReplyToDestination(Message message) throws JMSException {
        // lets send a response back if we can
        Destination destination = replyToDestination;
        if (destination == null) {
            destination = message.getJMSReplyTo();
        }
        return destination;
    }
}
"
org.apache.camel.component.freemarker.FreemarkerEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.freemarker;
import java.io.StringWriter;
import java.util.Map;
import freemarker.template.Configuration;
import freemarker.template.Template;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.component.ResourceBasedEndpoint;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Freemarker endpoint
 */
public class FreemarkerEndpoint extends ResourceBasedEndpoint {
    private String encoding;
    private Configuration configuration;
    public FreemarkerEndpoint(String uri, Component component, String resourceUri, Map parameters) {
        super(uri, component, resourceUri, null);
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
    @Override
    public ExchangePattern getExchangePattern() {
        return ExchangePattern.InOut;
    }
    /**
     * Sets the encoding to be used for loading the template file.
     */
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    public String getEncoding() {
        return encoding;
    }
    public Configuration getConfiguration() {
        return configuration;
    }
    /**
     * Sets the Freemarker configuration to use
     */
    public void setConfiguration(Configuration configuration) {
        this.configuration = configuration;
    }
    @Override
    @SuppressWarnings(""unchecked"")
    protected void onExchange(Exchange exchange) throws Exception {
        String path = getResourceUri();
        ObjectHelper.notNull(configuration, ""configuration"");
        ObjectHelper.notNull(path, ""resourceUri"");
        Map variableMap = ExchangeHelper.createVariableMap(exchange);
        if (log.isDebugEnabled()) {
            log.debug(""Freemarker is evaluating "" + path + "" using context: "" + variableMap);
        }
        // let freemarker parse and generate the result in buffer
        Template template;
        if (encoding != null) {
            template = configuration.getTemplate(path, encoding);
        } else {
            template = configuration.getTemplate(path);
        }
        StringWriter buffer = new StringWriter();
        template.process(variableMap, buffer);
        buffer.flush();
        // now lets output the results to the exchange
        Message out = exchange.getOut(true);
        out.setBody(buffer.toString());
        out.setHeader(""org.apache.camel.freemarker.resource"", getResource());
        out.setHeader(""org.apache.camel.freemarker.resourceUri"", path);
        Map<String, Object> headers = (Map<String, Object>) variableMap.get(""headers"");
        for (String key : headers.keySet()) {
            out.setHeader(key, headers.get(key));
        }
    }
}
"
org.apache.camel.component.event.CamelEvent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.springframework.context.ApplicationEvent;
/**
 * Represents a Spring {@link ApplicationEvent} which contains a Camel {@link Exchange}
 *
 * @version $Revision$
 */
public class CamelEvent extends ApplicationEvent {
    private final Exchange exchange;
    public CamelEvent(EventEndpoint source, Exchange exchange) {
        super(source);
        this.exchange = exchange;
    }
    @Override
    public EventEndpoint getSource() {
        return (EventEndpoint) super.getSource();
    }
    /**
     * Returns the message exchange
     *
     * @return the camel message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.impl.converter.AnnotationTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;
import static java.lang.reflect.Modifier.isAbstract;
import static java.lang.reflect.Modifier.isPublic;
import static java.lang.reflect.Modifier.isStatic;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ResolverUtil;
import org.apache.camel.util.WebSphereResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A class which will auto-discover converter objects and methods to pre-load
 * the registry of converters on startup
 *
 * @version $Revision$
 */
public class AnnotationTypeConverterLoader implements TypeConverterLoader {
    public static final String META_INF_SERVICES = ""META-INF/services/org/apache/camel/TypeConverter"";
    private static final transient Log LOG = LogFactory.getLog(AnnotationTypeConverterLoader.class);
    private ResolverUtil resolver;
    private Set<Class> visitedClasses = new HashSet<Class>();
    public AnnotationTypeConverterLoader() {
        // use WebSphere specific resolver if running on WebSphere
        if (WebSphereResolverUtil.isWebSphereClassLoader(this.getClass().getClassLoader())) {
            LOG.info(""Using WebSphere specific ResolverUtil"");
            resolver = new WebSphereResolverUtil(META_INF_SERVICES);
        } else {
            resolver = new ResolverUtil();
        }
    }
    public AnnotationTypeConverterLoader(ResolverUtil resolverUtil) {
        this.resolver = resolverUtil;
    }
    public void load(TypeConverterRegistry registry) throws Exception {
        String[] packageNames = findPackageNames();
        resolver.findAnnotated(Converter.class, packageNames);
        Set<Class> classes = resolver.getClasses();
        for (Class type : classes) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Loading converter class: "" + ObjectHelper.name(type));
            }
            loadConverterMethods(registry, type);
        }
    }
    /**
     * Finds the names of the packages to search for on the classpath looking
     * for text files on the classpath at the {@link #META_INF_SERVICES} location.
     *
     * @return a collection of packages to search for
     * @throws IOException is thrown for IO related errors
     */
    protected String[] findPackageNames() throws IOException {
        Set<String> packages = new HashSet<String>();
        ClassLoader ccl = Thread.currentThread().getContextClassLoader();
        if (ccl != null) {
            findPackages(packages, ccl);
        }
        findPackages(packages, getClass().getClassLoader());
        return packages.toArray(new String[packages.size()]);
    }
    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {
        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);
        while (resources.hasMoreElements()) {
            URL url = resources.nextElement();
            if (url != null) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                try {
                    while (true) {
                        String line = reader.readLine();
                        if (line == null) {
                            break;
                        }
                        line = line.trim();
                        if (line.startsWith(""#"") || line.length() == 0) {
                            continue;
                        }
                        tokenize(packages, line);
                    }
                } finally {
                    ObjectHelper.close(reader, null, LOG);
                }
            }
        }
    }
    /**
     * Tokenizes the line from the META-IN/services file using commas and
     * ignoring whitespace between packages
     */
    protected void tokenize(Set<String> packages, String line) {
        StringTokenizer iter = new StringTokenizer(line, "","");
        while (iter.hasMoreTokens()) {
            String name = iter.nextToken().trim();
            if (name.length() > 0) {
                packages.add(name);
            }
        }
    }
    /**
     * Loads all of the converter methods for the given type
     */
    protected void loadConverterMethods(TypeConverterRegistry registry, Class type) {
        if (visitedClasses.contains(type)) {
            return;
        }
        visitedClasses.add(type);
        try {
            Method[] methods = type.getDeclaredMethods();
            CachingInjector injector = null;
            for (Method method : methods) {
                // this may be prone to ClassLoader or packaging problems when the same class is defined
                // in two different jars (as is the case sometimes with specs).
                if (ObjectHelper.hasAnnotation(method, Converter.class, true)) {
                    if (isValidConverterMethod(method)) {
                        int modifiers = method.getModifiers();
                        if (isAbstract(modifiers) || !isPublic(modifiers)) {
                            LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                    + "" as a converter method is not a public and concrete method"");
                        } else {
                            Class<?> toType = method.getReturnType();
                            if (toType.equals(Void.class)) {
                                LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: ""
                                        + method + "" as a converter method returns a void method"");
                            } else {
                                Class<?> fromType = method.getParameterTypes()[0];
                                if (isStatic(modifiers)) {
                                    registerTypeConverter(registry, method, toType, fromType,
                                            new StaticMethodTypeConverter(method));
                                } else {
                                    if (injector == null) {
                                        injector = new CachingInjector(registry, type);
                                    }
                                    registerTypeConverter(registry, method, toType, fromType,
                                            new InstanceMethodTypeConverter(injector, method));
                                }
                            }
                        }
                    } else {
                        LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                + "" as a converter method should have one parameter"");
                    }
                }
            }
            Class superclass = type.getSuperclass();
            if (superclass != null && !superclass.equals(Object.class)) {
                loadConverterMethods(registry, superclass);
            }
        } catch (NoClassDefFoundError e) {
            LOG.warn(""Ignoring converter type: "" + type.getName() + "" as a dependent class could not be found: "" + e, e);
        }
    }
    protected void registerTypeConverter(TypeConverterRegistry registry,
                                         Method method, Class toType, Class fromType, TypeConverter typeConverter) {
        registry.addTypeConverter(toType, fromType, typeConverter);
    }
    protected boolean isValidConverterMethod(Method method) {
        Class<?>[] parameterTypes = method.getParameterTypes();
        return (parameterTypes != null) && (parameterTypes.length == 1
            || (parameterTypes.length == 2 && Exchange.class.isAssignableFrom(parameterTypes[1])));
    }
}
"
org.apache.camel.component.timer.TimerConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The timer consumer.
 *
 * @version $Revision$
 */
public class TimerConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(TimerConsumer.class);
    private final TimerEndpoint endpoint;
    private TimerTask task;
    public TimerConsumer(TimerEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        task = new TimerTask() {
            @Override
            public void run() {
                sendTimerExchange();
            }
        };
        Timer timer = endpoint.getTimer();
        configureTask(task, timer);
    }
    @Override
    protected void doStop() throws Exception {
        task.cancel();
    }
    protected void configureTask(TimerTask task, Timer timer) {
        if (endpoint.isFixedRate()) {
            if (endpoint.getTime() != null) {
                timer.scheduleAtFixedRate(task, endpoint.getTime(), endpoint.getPeriod());
            } else {
                timer.scheduleAtFixedRate(task, endpoint.getDelay(), endpoint.getPeriod());
            }
        } else {
            if (endpoint.getTime() != null) {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getTime(), endpoint.getPeriod());
                } else {
                    timer.schedule(task, endpoint.getTime());
                }
            } else {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getDelay(), endpoint.getPeriod());
                } else {
                    timer.schedule(task, endpoint.getDelay());
                }
            }
        }
    }
    protected void sendTimerExchange() {
        Exchange exchange = endpoint.createExchange();
        exchange.setProperty(""org.apache.camel.timer.name"", endpoint.getTimerName());
        exchange.setProperty(""org.apache.camel.timer.time"", endpoint.getTime());
        exchange.setProperty(""org.apache.camel.timer.period"", endpoint.getPeriod());
        Date now = new Date();
        exchange.setProperty(""org.apache.camel.timer.firedTime"", now);
        // also set now on in header with same key as quaartz to be consistent
        exchange.getIn().setHeader(""firedTime"", now);
        try {
            getProcessor().process(exchange);
        } catch (Exception e) {
            LOG.error(""Caught: "" + e, e);
        }
    }
}
"
org.apache.camel.component.http.HttpOperationFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.InputStream;
import org.apache.camel.CamelException;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.StatusLine;
public class HttpOperationFailedException extends CamelException {    
    private final String redirectLocation;
    private final int statusCode;
    private final StatusLine statusLine;
    private final Header[] responseHeaders;
    private final InputStream responseBody;
    public HttpOperationFailedException(int statusCode, StatusLine statusLine, String location, Header[] responseHeaders, InputStream responseBody) {
        super(""HTTP operation failed with statusCode: "" + statusCode + "", status: "" + statusLine + (location != null ? "", redirectLocation: "" + location : """"));
        this.statusCode = statusCode;
        this.statusLine = statusLine;
        this.redirectLocation = location;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }
    public HttpOperationFailedException(int statusCode, StatusLine statusLine, Header[] responseHeaders, InputStream responseBody) {
        this(statusCode, statusLine, null, responseHeaders, responseBody);
    }
    public boolean isRedirectError() {
        return statusCode >= 300 && statusCode < 400;
    }
    public boolean hasRedirectLocation() {
        return ObjectHelper.isNotNullAndNonEmpty(redirectLocation);
    }
    public String getRedirectLocation() {
        return redirectLocation;
    }
    public StatusLine getStatusLine() {
        return statusLine;
    }
    public int getStatusCode() {
        return statusCode;
    }
    public Header[] getResponseHeaders() {
        return responseHeaders;
    }
    public InputStream getResponseBody() {
        return responseBody;
    }
}"
org.apache.camel.component.cxf.spring.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""cxfEndpoint"", new CxfEndpointBeanDefinitionParser());
    }
}
"
org.apache.camel.language.XPath,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.component.bean.XPathAnnotationExpressionFactory;
/**
 * Used to inject an XPath expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""xpath"", factory = XPathAnnotationExpressionFactory.class)
public @interface XPath {
    String value();
    NamespacePrefix[] namespaces() default {
    @NamespacePrefix(prefix = ""soap"", uri = ""http://www.w3.org/2003/05/soap-envelope""),
    @NamespacePrefix(prefix = ""xsd"", uri = ""http://www.w3.org/2001/XMLSchema"")};
}"
org.apache.camel.component.bean.MethodInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
/**
 * Information used by Camel to perform method invocation.
 *
 * @version $Revision$
 */
public interface MethodInvocation {
    Method getMethod();
    Object[] getArguments();
    Object proceed() throws Exception;
    Object getThis();
    AccessibleObject getStaticPart();
}
"
org.apache.camel.impl.BinaryPredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A useful base class for {@link Predicate} implementations
 * 
 * @deprecated is a duplicate of the same class in the builder package. Will be removed in Camel 2.0
 * @version $Revision$
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {
    private final Expression<E> left;
    private final Expression<E> right;
    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        this.left = left;
        this.right = right;
    }
    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }
    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }
    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(text + assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }
    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);
    protected abstract String getOperationText();
    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <""
               + rightValue + "">"";
    }
}
"
org.apache.camel.component.ibatis.IBatisEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import java.sql.SQLException;
import java.util.List;
import com.ibatis.sqlmap.client.SqlMapClient;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Endpoint</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision$
 */
public class IBatisEndpoint extends DefaultPollingEndpoint {
    private final String entityName;
    public IBatisEndpoint(String endpointUri, IBatisComponent component, String entityName) {
        super(endpointUri, component);
        this.entityName = entityName;
    }
    public IBatisEndpoint(String endpointUri, String entityName) {
        super(endpointUri);
        this.entityName = entityName;
    }
    @Override
    public IBatisComponent getComponent() {
        return (IBatisComponent) super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer createProducer() throws Exception {
        return new IBatisProducer(this);
    }
    @Override
    public PollingConsumer createPollingConsumer() throws Exception {
        return new IBatisPollingConsumer(this);
    }
    /**
     * Returns the iBatis SQL client
     */
    public SqlMapClient getSqlClient() throws IOException {
        return getComponent().getSqlMapClient();
    }
    public String getEntityName() {
        return entityName;
    }
    public void query(Message message) throws IOException, SQLException {
        String name = getEntityName();
        List list = getSqlClient().queryForList(name);
        message.setBody(list);
        message.setHeader(""org.apache.camel.ibatis.queryName"", name);
    }
}
"
org.apache.camel.component.irc.IrcConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.net.URI;
import org.apache.camel.RuntimeCamelException;
public class IrcConfiguration implements Cloneable {
    private String target;
    private String hostname;
    private String password;
    private String nickname;
    private String realname;
    private String username;
    private boolean persistent = true;
    private boolean colors = true;
    private boolean onNick = true;
    private boolean onQuit = true;
    private boolean onJoin = true;
    private boolean onKick = true;
    private boolean onMode = true;
    private boolean onPart = true;
    private boolean onTopic = true;
    private boolean onPrivmsg = true;
    private int[] ports = {6667, 6668, 6669};
    public IrcConfiguration() {
    }
    public IrcConfiguration(String hostname, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.nickname = nickname;
        this.username = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration(String hostname, String username, String password, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.username = username;
        this.password = password;
        this.nickname = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration copy() {
        try {
            return (IrcConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String getCacheKey() {
        return hostname + "":"" + nickname;
    }
    public void configure(URI uri) {
        setNickname(uri.getUserInfo());
        setUsername(uri.getUserInfo());
        setRealname(uri.getUserInfo());
        setHostname(uri.getHost());
        setTarget(uri.getPath().substring(1));
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getNickname() {
        return nickname;
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public String getRealname() {
        return realname;
    }
    public void setRealname(String realname) {
        this.realname = realname;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public int[] getPorts() {
        return ports;
    }
    public void setPorts(int[] ports) {
        this.ports = ports;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public boolean isPersistent() {
        return persistent;
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public boolean isColors() {
        return colors;
    }
    public void setColors(boolean colors) {
        this.colors = colors;
    }
    public boolean isOnNick() {
        return onNick;
    }
    public void setOnNick(boolean onNick) {
        this.onNick = onNick;
    }
    public boolean isOnQuit() {
        return onQuit;
    }
    public void setOnQuit(boolean onQuit) {
        this.onQuit = onQuit;
    }
    public boolean isOnJoin() {
        return onJoin;
    }
    public void setOnJoin(boolean onJoin) {
        this.onJoin = onJoin;
    }
    public boolean isOnKick() {
        return onKick;
    }
    public void setOnKick(boolean onKick) {
        this.onKick = onKick;
    }
    public boolean isOnMode() {
        return onMode;
    }
    public void setOnMode(boolean onMode) {
        this.onMode = onMode;
    }
    public boolean isOnPart() {
        return onPart;
    }
    public void setOnPart(boolean onPart) {
        this.onPart = onPart;
    }
    public boolean isOnTopic() {
        return onTopic;
    }
    public void setOnTopic(boolean onTopic) {
        this.onTopic = onTopic;
    }
    public boolean isOnPrivmsg() {
        return onPrivmsg;
    }
    public void setOnPrivmsg(boolean onPrivmsg) {
        this.onPrivmsg = onPrivmsg;
    }
    public String toString() {
        return ""IrcConfiguration{"" + ""target='"" + target + '\'' + "", hostname='"" + hostname + '\'' + "", password='"" + password + '\'' + "", nickname='"" + nickname + '\'' + "", realname='"" + realname
               + '\'' + "", username='"" + username + '\'' + "", persistent="" + persistent + "", colors="" + colors + "", onNick="" + onNick + "", onQuit="" + onQuit + "", onJoin="" + onJoin + "", onKick=""
               + onKick + "", onMode="" + onMode + "", onPart="" + onPart + "", onTopic="" + onTopic + "", onPrivmsg="" + onPrivmsg + "", ports="" + ports + '}';
    }
}
"
org.apache.camel.component.irc.IrcMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.schwering.irc.lib.IRCUser;
public class IrcMessage extends DefaultMessage {
    private String messageType;
    private String target;
    private IRCUser user;
    private String whoWasKickedNick;
    private String message;
    public IrcMessage() {
    }
    public IrcMessage(String messageType, IRCUser user, String message) {
        this.messageType = messageType;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String whoWasKickedNick, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.whoWasKickedNick = whoWasKickedNick;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
    }
    public String getMessageType() {
        return messageType;
    }
    public void setMessageType(String messageType) {
        this.messageType = messageType;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public IRCUser getUser() {
        return user;
    }
    public void setUser(IRCUser user) {
        this.user = user;
    }
    public String getWhoWasKickedNick() {
        return whoWasKickedNick;
    }
    public void setWhoWasKickedNick(String whoWasKickedNick) {
        this.whoWasKickedNick = whoWasKickedNick;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    @Override
    public IrcExchange getExchange() {
        return (IrcExchange)super.getExchange();
    }
    @Override
    protected Object createBody() {
        IrcExchange ircExchange = getExchange();
        IrcBinding binding = ircExchange.getBinding();
        return binding.extractBodyFromIrc(ircExchange, this);
    }
    @Override
    public IrcMessage newInstance() {
        return new IrcMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        map.put(""irc.messageType"", messageType);
        if (target != null) {
            map.put(""irc.target"", target);
        }
        if (whoWasKickedNick != null) {
            map.put(""irc.user.kicked"", whoWasKickedNick);
        }
        if (user != null) {
            map.put(""irc.user.host"", user.getHost());
            map.put(""irc.user.nick"", user.getNick());
            map.put(""irc.user.servername"", user.getServername());
            map.put(""irc.user.username"", user.getUsername());
        }
    }
    @Override
    public String toString() {
        if (message != null) {
            return ""IrcMessage: "" + message;
        } else {
            return ""IrcMessage: "" + getBody();
        }
    }
}
"
org.apache.camel.component.atom.AtomEntryPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.abdera.parser.ParseException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Consumer to poll atom feeds and return each entry from the feed step by step.
 *
 * @version $Revision$
 */
public class AtomEntryPollingConsumer extends AtomPollingConsumer {
    private Document<Feed> document;
    private int entryIndex;
    private EntryFilter entryFilter;
    private List<Entry> list;
    public AtomEntryPollingConsumer(AtomEndpoint endpoint, Processor processor, boolean filter,
                                    Date lastUpdate) {
        super(endpoint, processor);
        if (filter) {
            entryFilter = new UpdatedDateFilter(lastUpdate);
        }
    }
    public void poll() throws Exception {
        getDocument();
        Feed feed = document.getRoot();
        while (hasNextEntry()) {
            Entry entry = list.get(entryIndex--);
            boolean valid = true;
            if (entryFilter != null) {
                valid = entryFilter.isValidEntry(endpoint, document, entry);
            }
            if (valid) {
                Exchange exchange = endpoint.createExchange(feed, entry);
                getProcessor().process(exchange);
                // return and wait for the next poll to continue from last time (this consumer is stateful)
                return;
            }
        }
        // reset document to be able to poll again
        document = null;
    }
    private Document<Feed> getDocument() throws IOException, ParseException {
        if (document == null) {
            document = AtomUtils.parseDocument(endpoint.getAtomUri());
            list = document.getRoot().getEntries();
            entryIndex = list.size() - 1;
        }
        return document;
    }
    private boolean hasNextEntry() {
        return entryIndex >= 0;
    }
}
"
org.apache.camel.component.file.remote.SftpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.InputStream;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import org.apache.camel.Exchange;
public class SftpProducer extends RemoteFileProducer<RemoteFileExchange> {
    private SftpEndpoint endpoint;
    private ChannelSftp channel;
    private Session session;
    public SftpProducer(SftpEndpoint endpoint, Session session) {
        super(endpoint);
        this.endpoint = endpoint;
        this.session = session;
    }
    public void process(Exchange exchange) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace(""Processing "" + endpoint.getConfiguration());
        }
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't deliver
        try {
            process(endpoint.createExchange(exchange));
        } catch (Exception e) {
            if (isStopping() || isStopped()) {
                // if we are stopping then ignore any exception during a poll
                log.warn(""Producer is stopping. Ignoring caught exception: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
            } else {
                log.warn(""Exception occured during processing: ""
                         + e.getClass().getCanonicalName() + "" message: "" + e.getMessage());
                disconnect();
                // Rethrow to signify that we didn't poll
                throw e;
            }
        }
    }
    protected void connectIfNecessary() throws JSchException {
        if (channel == null || !channel.isConnected()) {
            if (session == null || !session.isConnected()) {
                log.trace(""Session isn't connected, trying to recreate and connect."");
                session = endpoint.createSession();
                session.connect();
            }
            log.trace(""Channel isn't connected, trying to recreate and connect."");
            channel = endpoint.createChannelSftp(session);
            channel.connect();
            log.info(""Connected to "" + endpoint.getConfiguration().remoteServerInformation());
        }
    }
    protected void disconnect() throws JSchException {
        if (log.isDebugEnabled()) {
            log.debug(""Disconnecting from "" + remoteServer());
        }
        if (session != null) {
            session.disconnect();
        }
        if (channel != null) {
            channel.disconnect();
        }
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        try {
            String remoteServer = endpoint.getConfiguration().remoteServerInformation();
            String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
            int lastPathIndex = fileName.lastIndexOf('/');
            if (lastPathIndex != -1) {
                String directory = fileName.substring(0, lastPathIndex);
                boolean success = SftpUtils.buildDirectory(channel, directory);
                if (!success) {
                    log.warn(""Couldn't build directory: "" + directory + "" (could be because of denied permissions)"");
                }
            }
            channel.put(payload, fileName);
            log.info(""Sent: "" + fileName + "" to: "" + remoteServer);
        } finally {
            if (payload != null) {
                payload.close();
            }
        }
    }
}
"
org.apache.camel.Component,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/component.html"">component</a> is
 * a factory of {@link Endpoint} objects.
 * 
 * @version $Revision$
 */
public interface Component<E extends Exchange> {
    /**
     * Returns the context
     * 
     * @return the context of this component
     */
    CamelContext getCamelContext();
    /**
     * The {@link CamelContext} is injected into the component when it is added
     * to it
     */
    void setCamelContext(CamelContext context);
    /**
     * Attempt to resolve an endpoint for the given URI if the component is
     * capable of handling the URI
     * 
     * @param uri the URI to create
     * @return a newly created endpoint or null if this component cannot create
     *         instances of the given uri
     */
    Endpoint<E> createEndpoint(String uri) throws Exception;
}
"
org.apache.camel.component.file.FileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/file.html"">File Component</a>
 * for working with file systems
 *
 * @version $Revision$
 */
public class FileComponent extends DefaultComponent<FileExchange> {
    /**
     * Header key holding the value: the fixed filename to use for producing files.
     */
    public static final String HEADER_FILE_NAME = ""org.apache.camel.file.name"";
    /**
     * Header key holding the value: absolute filepath for the actual file produced (by file producer).
     * Value is set automatically by Camel
     */
    public static final String HEADER_FILE_NAME_PRODUCED = ""org.apache.camel.file.name.produced"";
    public FileComponent() {
    }
    public FileComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        File file = new File(remaining);
        FileEndpoint result = new FileEndpoint(file, uri, this);
        setProperties(result, parameters);
        return result;
    }
}
"
org.apache.camel.component.mail.MailMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import java.util.Map;
import javax.activation.DataHandler;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultMessage;
import org.apache.camel.util.CollectionHelper;
/**
 * Represents a {@link org.apache.camel.Message} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailMessage extends DefaultMessage {
    private Message mailMessage;
    public MailMessage() {
    }
    public MailMessage(Message message) {
        this.mailMessage = message;
    }
    @Override
    public String toString() {
        if (mailMessage != null) {
            return ""MailMessage: "" + MailUtils.dumpMessage(mailMessage);
        } else {
            return ""MailMessage: "" + getBody();
        }
    }
    @Override
    public MailExchange getExchange() {
        return (MailExchange)super.getExchange();
    }
    public MailMessage copy() {
        MailMessage answer = (MailMessage)super.copy();
        answer.mailMessage = mailMessage;
        return answer;
    }
    /**
     * Returns the underlying Mail message
     */
    public Message getMessage() {
        return mailMessage;
    }
    public void setMessage(Message mailMessage) {
        this.mailMessage = mailMessage;
    }
    @Override
    public Object getHeader(String name) {
        Object answer = super.getHeader(name);
        // mimic case insensitive search of mail message getHeader
        if (answer == null) {
            answer = super.getHeader(name.toLowerCase());
        }
        return answer;
    }
    @Override
    public MailMessage newInstance() {
        return new MailMessage();
    }
    @Override
    protected Object createBody() {
        if (mailMessage != null) {
            return getExchange().getBinding().extractBodyFromMail(getExchange(), mailMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (mailMessage != null) {
            try {
                map.putAll(getExchange().getBinding().extractHeadersFromMail(mailMessage));
            } catch (MessagingException e) {
                throw new RuntimeCamelException(""Error accessing headers due to: "" + e.getMessage(), e);
            }
        }
    }
    @Override
    protected void populateInitialAttachments(Map<String, DataHandler> map) {
        if (mailMessage != null) {
            try {
                extractAttachments(mailMessage, map);
            } catch (Exception e) {
                throw new RuntimeCamelException(""Error populating the initial mail message attachments"", e);
            }
        }
    }
    public void copyFrom(org.apache.camel.Message that) {
        super.copyFrom(that);
        if (that instanceof MailMessage) {
            MailMessage mailMessage = (MailMessage) that;
            this.mailMessage = mailMessage.mailMessage;
        }
    }
    /**
     * Parses the attachments of the given mail message and adds them to the map
     *
     * @param  message  the mail message with attachments
     * @param  map      the map to add found attachments (attachmentFilename is the key)
     */
    protected static void extractAttachments(Message message, Map<String, DataHandler> map)
        throws javax.mail.MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof Multipart) {
            // mail with attachment
            Multipart mp = (Multipart)content;
            for (int i = 0; i < mp.getCount(); i++) {
                Part part = mp.getBodyPart(i);
                String disposition = part.getDisposition();
                if (disposition != null) {
                    if (disposition.equalsIgnoreCase(Part.ATTACHMENT) || disposition.equalsIgnoreCase(Part.INLINE)) {
                        // only add named attachments
                        if (part.getFileName() != null) {
                            // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments
                            CollectionHelper.appendValue(map, part.getFileName(), part.getDataHandler());
                        }
                    }
                }
            }
        }
    }
}
"
org.apache.camel.ExchangeTimedOutException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception thrown if an InOut exchange times out receiving the OUT message
 *
 * @version $Revision$
 */
public class ExchangeTimedOutException extends CamelExchangeException {
    private final long timeout;
    public ExchangeTimedOutException(Exchange exchange, long timeout) {
        super(""The OUT message was not received within: "" + timeout + "" millis"", exchange);
        this.timeout = timeout;
    }
    /**
     * Return the timeout which expired in milliseconds
     */
    public long getTimeout() {
        return timeout;
    }
}"
org.apache.camel.component.cxf.invoker.PayloadInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.w3c.dom.Element;
import org.apache.camel.Headers;
import org.apache.cxf.binding.soap.SoapHeader;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.headers.Header;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public class PayloadInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = LogUtils.getL7dLogger(PayloadInvokingContext.class);
    public PayloadInvokingContext() {
    }
    public void setRequestOutMessageContent(Message message, Map<Class, Object> contents) {
        PayloadMessage request = (PayloadMessage)contents.get(PayloadMessage.class);
        List<SoapHeader> headers = request.getHeaders();
        List<Element> payload = request.getPayload();
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""header = "" + headers + "", paylaod = "" + payload);
        }
        message.put(Header.HEADER_LIST, headers);
        message.put(List.class, payload);
    }
    @SuppressWarnings(""unchecked"")
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        PayloadMessage payloadMsg = null;
        Message msg = exchange.getInMessage();
        List<Element> payload = getResponseObject(msg , responseContext, List.class);
        List<SoapHeader> header = CastUtils.cast((List<?>)exchange.getInMessage().get(Header.HEADER_LIST));
        payloadMsg = new PayloadMessage(payload, header);
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(payloadMsg.toString());
        }
        return payloadMsg;
    }
    @Override
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
                                      Class <T> clazz) {
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                LOG.info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.get(clazz);
        }
        return retval;
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        if (resultPayload != null) {
            PayloadMessage payloadMessage = (PayloadMessage) resultPayload;
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(payloadMessage.toString());
            }
            outMessage.put(List.class, payloadMessage.getPayload());
            outMessage.put(Header.HEADER_LIST, payloadMessage.getHeaders());
        }
    }
    @SuppressWarnings(""unchecked"")
    public Map<Class, Object> getRequestContent(Message inMessage) {
        List<Element> payload = inMessage.get(List.class);
        List<SoapHeader> headers = CastUtils.cast((List<?>)inMessage.get(Header.HEADER_LIST));
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""Header = "" + headers + "", Payload = "" + payload);
        }
        Map<Class, Object> contents = new IdentityHashMap<Class, Object>();
        contents.put(PayloadMessage.class, new PayloadMessage(payload, headers));
        return contents;
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.Route,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/camel/routes.html"">Route</a>
 * defines the processing used on an inbound message exchange
 * from a specific {@link Endpoint} within a {@link CamelContext}
 *
 * @version $Revision$
 */
public class Route<E extends Exchange> {
    public static final String ID_PROPERTY = ""id"";
    public static final String PARENT_PROPERTY = ""parent"";
    public static final String GROUP_PROPERTY = ""group"";
    private final Map<String, Object> properties = new HashMap<String, Object>(16);
    private Endpoint<E> endpoint;
    private List<Service> services = new ArrayList<Service>();
    public Route(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    public Route(Endpoint<E> endpoint, Service... services) {
        this(endpoint);
        for (Service service : services) {
            addService(service);
        }
    }
    @Override
    public String toString() {
        return ""Route"";
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * This property map is used to associate information about
     * the route.
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    public List<Service> getServicesForRoute() throws Exception {
        List<Service> servicesForRoute = new ArrayList<Service>(getServices());
        addServices(servicesForRoute);
        return servicesForRoute;
    }
    /**
     * Returns the additional services required for this particular route
     */
    public List<Service> getServices() {
        return services;
    }
    public void setServices(List<Service> services) {
        this.services = services;
    }
    public void addService(Service service) {
        getServices().add(service);
    }
    /**
     * Strategy method to allow derived classes to lazily load services for the route
     */
    protected void addServices(List<Service> services) throws Exception {
    }
}
"
org.apache.camel.bam.processor.JpaBamProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A concrete {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which uses JPA as
 * the persistence and uses the {@link ProcessInstance} entity to store the
 * process information.
 * 
 * @version $Revision$
 */
public class JpaBamProcessor extends JpaBamProcessorSupport<ProcessInstance> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessor.class);
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules);
    }
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, 
                           ActivityRules activityRules, Class<ProcessInstance> entitytype) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules, entitytype);
    }
    protected void processEntity(Exchange exchange, ProcessInstance process) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Processing process instance: "" + process);
        }
        // lets force the lazy creation of this activity
        ActivityRules rules = getActivityRules();
        ActivityState state = process.getOrCreateActivityState(rules);
        state.processExchange(rules, new ProcessContext(exchange, rules, state));
        rules.getProcessRules().processExchange(exchange, process);
    }
}
"
org.apache.camel.component.sql.SqlComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.util.Map;
import javax.sql.DataSource;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class SqlComponent extends DefaultComponent<Exchange> {
    private DataSource dataSource;
    public SqlComponent() {
    }
    public SqlComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        String dataSourceRef = getAndRemoveParameter(parameters, ""dataSourceRef"", String.class);
        if (dataSourceRef != null) {
            dataSource = getCamelContext().getRegistry().lookup(dataSourceRef, DataSource.class);
            if (dataSource == null) {
                throw new IllegalArgumentException(""DataSource "" + dataSourceRef + "" not found in registry"");
            }
        }
        return new SqlEndpoint(uri, remaining.replaceAll(""#"", ""?""), this, dataSource, parameters);
    }
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
"
org.apache.camel.MessageDriven,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate a method on a POJO which is used as a {@link Consumer} of
 * {@link Exchange} instances to process {@link Message} instances.
 * 
 * Either a <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an
 * endpoint should be configured, or a name of an endpoint which refers to a
 * Spring bean name in your Spring ApplicationContext.
 * 
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface MessageDriven {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.bam.processor.NoCorrelationKeyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if no correlation key could be found for a message
 * exchange preventing any particular orchestration or
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a>
 *
 * @version $Revision$
 */
public class NoCorrelationKeyException extends CamelExchangeException {
    private final BamProcessorSupport processor;
    public NoCorrelationKeyException(BamProcessorSupport processor, Exchange exchange) {
        super(""No correlation key could be found for "" + processor.getCorrelationKeyExpression(), exchange);
        this.processor = processor;
    }
    public BamProcessorSupport getProcessor() {
        return processor;
    }
}
"
org.apache.camel.component.file.remote.RemoteFileConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import org.apache.camel.Converter;
/**
 * A set of converter methods for working with remote file types
 *
 * @version $Revision$
 */
@Converter
public final class RemoteFileConverter {
    private RemoteFileConverter() {
        // Helper Class
    }
    @Converter
    public static byte[] toByteArray(ByteArrayOutputStream os) {
        return os.toByteArray();
    }
    @Converter
    public static String toString(ByteArrayOutputStream os) {
        return os.toString();
    }
    @Converter
    public static InputStream toInputStream(ByteArrayOutputStream os) {
        return new ByteArrayInputStream(os.toByteArray());
    }
}
"
org.apache.camel.component.hl7.HL7MLLPCodec,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.hl7;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import ca.uhn.hl7v2.model.Message;
import org.apache.camel.dataformat.hl7.HL7Converter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ByteBuffer;
import org.apache.mina.common.IoSession;
import org.apache.mina.filter.codec.ProtocolCodecFactory;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.ProtocolEncoderOutput;
/**
 * HL7 MLLP codec.
 * <p/>
 * This codec supports encoding/decoding the HL7 MLLP protocol.
 * It will use the default markers for start and end combination:
 * <ul>
 *   <li>0x0b (11 decimal) = start marker</li>
 *   <li>0x0d (13 decimal = the \r char) = segment terminators</li>
 *   <li>0x1c (28 decimal) = end 1 marker</li>
 *   <li>0x0d (13 decimal) = end 2 marker</li>
 * </ul>
 * <p/>
 * The decoder is used for decoding from MLLP (bytes) to String. The String will not contain any of
 * the start and end markers.
 * <p/>
 * The encoder is used for encoding from String to MLLP (bytes). The String should <b>not</b> contain
 * any of the start and end markers, the enoder will add these, and stream the string as bytes.
 * Also the enocder will convert any <tt>\n</tt> (line breaks) as segment terminators to <tt>\r</tt>.
 * <p/>
 * This codes supports charset encoding/decoding between bytes and String. The JVM platform default charset
 * is used, but the charset can be configued on this codec using the setter method.
 * The decoder will use the JVM platform default charset for decoding, but the charset can be configued on the this codec.
 */
public class HL7MLLPCodec implements ProtocolCodecFactory {
    private static final transient Log LOG = LogFactory.getLog(HL7MLLPCodec.class);
    private static final String CHARSET_ENCODER = HL7MLLPCodec.class.getName() + "".charsetencoder"";
    private static final String CHARSET_DECODER = HL7MLLPCodec.class.getName() + "".charsetdecoder"";
    // HL7 MLLP start and end markers
    private char startByte = 0x0b; // 11 decimal
    private char endByte1 = 0x1c;  // 28 decimal
    private char endByte2 = 0x0d;  // 13 decimal
    private Charset charset = Charset.defaultCharset();
    private boolean convertLFtoCR = true;
    public ProtocolEncoder getEncoder() throws Exception {
        return new ProtocolEncoder() {
            public void encode(IoSession session, Object message, ProtocolEncoderOutput out)
                throws Exception {
                if (message == null) {
                    throw new IllegalArgumentException(""Message to encode is null"");
                } else if (message instanceof Exception) {
                    // we cant handle exceptions
                    throw (Exception) message;
                }
                CharsetEncoder encoder = (CharsetEncoder)session.getAttribute(CHARSET_ENCODER);
                if (encoder == null) {
                    encoder = charset.newEncoder();
                    session.setAttribute(CHARSET_ENCODER, encoder);
                }
                // convert to string
                String body;
                if (message instanceof Message) {
                    body = HL7Converter.toString((Message)message);
                } else if (message instanceof String) {
                    body = (String)message;
                } else if (message instanceof byte[]) {
                    body = new String((byte[])message);
                } else {
                    throw new IllegalArgumentException(""The message to encode is not a supported type: ""
                            + message.getClass().getCanonicalName());
                }
                // replace \n with \r as HL7 uses 0x0d = \r as segment termninators
                if (convertLFtoCR) {
                    body = body.replace('\n', '\r');
                }
                // put the data into the byte buffer
                ByteBuffer bb = ByteBuffer.allocate(body.length() + 3).setAutoExpand(true);
                bb.put((byte) startByte);
                bb.putString(body, encoder);
                bb.put((byte) endByte1);
                bb.put((byte) endByte2);
                // flip the buffer so we can use it to write to the out stream
                bb.flip();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Encoding HL7 from "" + message.getClass().getCanonicalName() + "" to byte stream"");
                }
                out.write(bb);
            }
            public void dispose(IoSession session) throws Exception {
                session.removeAttribute(CHARSET_ENCODER);
            }
        };
    }
    public ProtocolDecoder getDecoder() throws Exception {
        return new ProtocolDecoder() {
            public void decode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception {
                // find position where we have the end1 end2 combination
                int posEnd = 0;
                int posStart = 0;
                while (in.hasRemaining()) {
                    byte b = in.get();
                    if (b == startByte) {
                        posStart = in.position();
                    }
                    if (b == endByte1) {
                        byte next = in.get();
                        if (next == endByte2) {
                            posEnd = in.position() - 2; // use -2 to skip these last 2 end markers
                            break;
                        } else {
                            // we expected the 2nd end marker
                            LOG.warn(""The 2nd end byte "" + endByte2 + "" was not found, but was "" + b);
                        }
                    }
                }
                // okay we have computed the start and end position of the special HL7 markers
                // rewind the bytebuffer so we can read from it again
                in.rewind();
                // narrow the buffer to only include between the start and end markers
                in.skip(posStart);
                if (posEnd > 0) {
                    in.limit(posEnd);
                }
                try {
                    // convert to string using the charset decoder
                    CharsetDecoder decoder = (CharsetDecoder)session.getAttribute(CHARSET_DECODER);
                    if (decoder == null) {
                        decoder = charset.newDecoder();
                        session.setAttribute(CHARSET_DECODER, decoder);
                    }
                    String body = in.getString(decoder);
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Decoding HL7 from byte stream to String"");
                    }
                    out.write(body);
                } finally {
                    // clear the buffer now that we have transfered the data to the String
                    in.clear();
                }
            }
            public void finishDecode(IoSession session, ProtocolDecoderOutput out) throws Exception {
                // do nothing
            }
            public void dispose(IoSession session) throws Exception {
                session.removeAttribute(CHARSET_DECODER);
            }
        };
    }
    public Charset getCharset() {
        return charset;
    }
    public void setCharset(Charset charset) {
        this.charset = charset;
    }
    public void setCharset(String charsetName) {
        this.charset = Charset.forName(charsetName);
    }
    public boolean isConvertLFtoCR() {
        return convertLFtoCR;
    }
    public void setConvertLFtoCR(boolean convertLFtoCR) {
        this.convertLFtoCR = convertLFtoCR;
    }
    public char getStartByte() {
        return startByte;
    }
    public void setStartByte(char startByte) {
        this.startByte = startByte;
    }
    public char getEndByte1() {
        return endByte1;
    }
    public void setEndByte1(char endByte1) {
        this.endByte1 = endByte1;
    }
    public char getEndByte2() {
        return endByte2;
    }
    public void setEndByte2(char endByte2) {
        this.endByte2 = endByte2;
    }
}
"
org.apache.camel.converter.stream.StreamCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.stream;
import java.io.IOException;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
/**
 * Tagging interface to indicate that a type is capable of caching the underlying data stream.
 * <p/>
 * This is a useful feature for avoid message re-readability issues.
 * This interface is mainly used by the {@link StreamCachingInterceptor} for determining if/how to wrap a
 * stream-based message.
 */
public interface StreamCache {
    /**
     * Resets the StreamCache for a new stream consumption.
     */
    void reset();
}
"
org.apache.camel.converter.jaxb.ExchangeType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""exchange"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ExchangeType {
    @XmlElement(name = ""property"", required = false)
    List<PropertyType> properties = new ArrayList<PropertyType>();
    @XmlAnyElement(lax = true)
    private Object body;
    public Object getBody() {
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public List<PropertyType> getProperties() {
        return properties;
    }
    public void setProperties(List<PropertyType> properties) {
        this.properties = properties;
    }
}"
org.apache.camel.component.mail.MailEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Message;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * Endpoint for Camel Mail.
 *
 * @version $Revision:520964 $
 */
public class MailEndpoint extends ScheduledPollEndpoint<MailExchange> {
    private MailBinding binding;
    private MailConfiguration configuration;
    public MailEndpoint(String uri, MailComponent component, MailConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
        this.binding = new MailBinding(component.getHeaderFilterStrategy());
    }
    public MailEndpoint(String endpointUri, MailConfiguration configuration) {
        super(endpointUri);
        this.configuration = configuration;
    }
    public MailEndpoint(String endpointUri) {
        this(endpointUri, new MailConfiguration());
    }
    public Producer<MailExchange> createProducer() throws Exception {
        JavaMailSender sender = configuration.createJavaMailSender();
        return createProducer(sender);
    }
    /**
     * Creates a producer using the given sender
     */
    public Producer<MailExchange> createProducer(JavaMailSender sender) throws Exception {
        return new MailProducer(this, sender);
    }
    public Consumer<MailExchange> createConsumer(Processor processor) throws Exception {
        if (configuration.getProtocol().startsWith(""smtp"")) {
            throw new IllegalArgumentException(""Protocol "" + configuration.getProtocol()
                + "" can not be used for a MailConsumer. Please use another protocol such as pop3 or imap."");
        }
        JavaMailSenderImpl sender = configuration.createJavaMailSender();
        return createConsumer(processor, sender);
    }
    /**
     * Creates a consumer using the given processor and sender
     */
    public Consumer<MailExchange> createConsumer(Processor processor, JavaMailSenderImpl sender) throws Exception {
        MailConsumer answer = new MailConsumer(this, processor, sender);
        // ScheduledPollConsumer default delay is 500 millis and that is too often for polling a mailbox,
        // so we override with a new default value. End user can override this value by providing a consumer.delay parameter
        answer.setDelay(MailConsumer.DEFAULT_CONSUMER_DELAY);
        configureConsumer(answer);
        return answer;
    }
    @Override
    public MailExchange createExchange(ExchangePattern pattern) {
        return new MailExchange(getCamelContext(), pattern, getBinding());
    }
    public MailExchange createExchange(Message message) {
        return new MailExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public MailBinding getBinding() {
        if (binding == null) {
            binding = new MailBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a Mail
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(MailBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return false;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
}
"
org.apache.camel.spring.handler.BeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.core.Conventions;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
/**
 * A base class for a parser for a bean.
 *
 * @version $Revision$
 */
// TODO cannot use AbstractSimpleBeanDefinitionParser
// as doParse() is final and isEligableAttribute does not allow us to filter out attributes
// with the name ""xmlns:""
public class BeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    private Class type;
    protected BeanDefinitionParser() {
    }
    public BeanDefinitionParser(Class type) {
        this.type = type;
    }
    protected Class getBeanClass(Element element) {
        if (type == null) {
            type = loadType();
        }
        return type;
    }
    protected Class loadType() {
        throw new IllegalArgumentException(""No type specified!"");
    }
    protected boolean isEligibleAttribute(String attributeName) {
        return attributeName != null && !ID_ATTRIBUTE.equals(attributeName)
                && !attributeName.equals(""xmlns"") && !attributeName.startsWith(""xmlns:"");
    }
    // TODO the following code is copied from AbstractSimpleBeanDefinitionParser
    // it can be removed if ever the doParse() method is not final!
    // or the Spring bug http://jira.springframework.org/browse/SPR-4599 is resolved
    /**
     * Parse the supplied {@link Element} and populate the supplied
     * {@link BeanDefinitionBuilder} as required.
     * <p>This implementation maps any attributes present on the
     * supplied element to {@link org.springframework.beans.PropertyValue}
     * instances, and
     * {@link BeanDefinitionBuilder#addPropertyValue(String, Object) adds them}
     * to the
     * {@link org.springframework.beans.factory.config.BeanDefinition builder}.
     * <p>The {@link #extractPropertyName(String)} method is used to
     * reconcile the name of an attribute with the name of a JavaBean
     * property.
     *
     * @param element the XML element being parsed
     * @param builder used to define the <code>BeanDefinition</code>
     * @see #extractPropertyName(String)
     */
    protected final void doParse(Element element, BeanDefinitionBuilder builder) {
        NamedNodeMap attributes = element.getAttributes();
        for (int x = 0; x < attributes.getLength(); x++) {
            Attr attribute = (Attr) attributes.item(x);
            String name = attribute.getLocalName();
            String fullName = attribute.getName();
            if (!fullName.startsWith(""xmlns:"") && !fullName.equals(""xmlns"") && isEligibleAttribute(name)) {
                String propertyName = extractPropertyName(name);
                Assert.state(StringUtils.hasText(propertyName),
                        ""Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty."");
                builder.addPropertyValue(propertyName, attribute.getValue());
            }
        }
        postProcess(builder, element);
    }
    /**
     * Extract a JavaBean property name from the supplied attribute name.
     * <p>The default implementation uses the
     * {@link Conventions#attributeNameToPropertyName(String)}
     * method to perform the extraction.
     * <p>The name returned must obey the standard JavaBean property name
     * conventions. For example for a class with a setter method
     * '<code>setBingoHallFavourite(String)</code>', the name returned had
     * better be '<code>bingoHallFavourite</code>' (with that exact casing).
     *
     * @param attributeName the attribute name taken straight from the
     *                      XML element being parsed (never <code>null</code>)
     * @return the extracted JavaBean property name (must never be <code>null</code>)
     */
    protected String extractPropertyName(String attributeName) {
        return Conventions.attributeNameToPropertyName(attributeName);
    }
    /**
     * Hook method that derived classes can implement to inspect/change a
     * bean definition after parsing is complete.
     * <p>The default implementation does nothing.
     *
     * @param beanDefinition the parsed (and probably totally defined) bean definition being built
     * @param element        the XML element that was the source of the bean definition's metadata
     */
    protected void postProcess(BeanDefinitionBuilder beanDefinition, Element element) {
    }
}"
org.apache.camel.component.file.remote.FtpUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.net.ftp.FTPClient;
/**
 * Utility methods for FTP.
 */
public final class FtpUtils {
    private static final transient Log LOG = LogFactory.getLog(FtpUtils.class);
    private FtpUtils() {
    }
    public static boolean connect(FTPClient client, RemoteFileConfiguration config) throws IOException {
        String host = config.getHost();
        int port = config.getPort();
        String username = config.getUsername();
        if (config.getFtpClientConfig() != null) {
            LOG.trace(""Configuring FTPClient with config: "" + config.getFtpClientConfig());
            client.configure(config.getFtpClientConfig());
        }
        LOG.trace(""Connecting to "" + config);
        client.connect(host, port);
        // must enter passive mode directly after connect
        if (config.isPassiveMode()) {
            LOG.trace(""Using passive mode connections"");
            client.enterLocalPassiveMode();
        }
        boolean login;
        if (username != null) {
            LOG.trace(""Attempting to login user: "" + username);
            login = client.login(username, config.getPassword());
        } else {
            LOG.trace(""Attempting to login anonymous"");
            login = client.login(""anonymous"", null);
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(""User "" + (username != null ? username : ""anonymous"") + "" logged in: "" + login);
        }
        if (!login) {
            return false;
        }
        client.setFileType(config.isBinary() ? FTPClient.BINARY_FILE_TYPE : FTPClient.ASCII_FILE_TYPE);
        return true;
    }
    public static void disconnect(FTPClient client) throws IOException {
        if (client.isConnected()) {
            client.disconnect();
        }
    }
    public static FTPClient createNewFtpClient() {
        return new FTPClient();
    }
    public static boolean buildDirectory(FTPClient ftpClient, String dirName) throws IOException {
        String originalDirectory = ftpClient.printWorkingDirectory();
        boolean success = false;
        try {
            // maybe the full directory already exsits
            success = ftpClient.changeWorkingDirectory(dirName);
            if (!success) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Trying to build remote directory: "" + dirName);
                }
                success = ftpClient.makeDirectory(dirName);
                if (!success) {
                    // we are here if the server side doesn't create intermediate folders
                    // so create the folder one by one
                    buildDirectoryChunks(ftpClient, dirName);
                }
            }
        } finally {
            // change back to original directory
            ftpClient.changeWorkingDirectory(originalDirectory);
        }
        return success;
    }
    public static boolean buildDirectoryChunks(FTPClient ftpClient, String dirName) throws IOException {
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        boolean success = false;
        for (String dir : dirs) {
            sb.append(dir).append('/');
            String directory = sb.toString();
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Trying to build remote directory: "" + directory);
            }
            success = ftpClient.makeDirectory(directory);
        }
        return success;
    }
}
"
org.apache.camel.component.cxf.CxfHeaderFilterStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.impl.DefaultHeaderFilterStrategy;
/**
 * @version $Revision$
 */
public class CxfHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
    public CxfHeaderFilterStrategy() {
        initialize();  
    }
    protected void initialize() {
        getOutFilter().add(CxfConstants.OPERATION_NAME);
        getOutFilter().add(CxfConstants.OPERATION_NAMESPACE);
    }
}
"
org.apache.camel.dataformat.xstream.AbstractXStreamWrapper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.xstream;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.stream.XMLStreamException;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.StaxConverter;
import org.apache.camel.spi.DataFormat;
/**
 * An abstract class which implement <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) interface which leverage the XStream library for XML or JSON's marshaling and unmarshaling
 *
 * @version $Revision$
 */
public abstract class AbstractXStreamWrapper implements DataFormat {
    private XStream xstream;
    private StaxConverter staxConverter;
    public AbstractXStreamWrapper() {
    }
    public AbstractXStreamWrapper(XStream xstream) {
        this.xstream = xstream;
    }
    public XStream getXStream() {
        if (xstream == null) {
            xstream = createXStream();
        }
        return xstream;
    }
    public void setXStream(XStream xstream) {
        this.xstream = xstream;
    }
    protected XStream createXStream() {
        return new XStream();
    }
    public StaxConverter getStaxConverter() {
        if (staxConverter == null) {
            staxConverter = new StaxConverter();
        }
        return staxConverter;
    }
    public void setStaxConverter(StaxConverter staxConverter) {
        this.staxConverter = staxConverter;
    }  
    public void marshal(Exchange exchange, Object body, OutputStream stream) throws Exception {
        HierarchicalStreamWriter writer = createHierarchicalStreamWriter(exchange, body, stream);
        try {
            getXStream().marshal(body, writer);
        } finally {
            writer.close();
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        HierarchicalStreamReader reader = createHierarchicalStreamReader(exchange, stream);
        try {
            return getXStream().unmarshal(reader);
        } finally {
            reader.close();
        }
    }
    protected abstract HierarchicalStreamWriter createHierarchicalStreamWriter(Exchange exchange, Object body, OutputStream stream) throws XMLStreamException;
    protected abstract HierarchicalStreamReader createHierarchicalStreamReader(Exchange exchange, InputStream stream) throws XMLStreamException;
}
"
org.apache.camel.component.stringtemplate.StringTemplateComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stringtemplate;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision$
 */
public class StringTemplateComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new StringTemplateEndpoint(uri, this, remaining, parameters);
    }
}"
org.apache.camel.builder.xml.DefaultNamespaceContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPathFactory;
import org.apache.camel.spi.NamespaceAware;
/**
 * An implementation of {@link NamespaceContext} which uses a simple Map where
 * the keys are the prefixes and the values are the URIs
 *
 * @version $Revision$
 */
public class DefaultNamespaceContext implements NamespaceContext, NamespaceAware {
    private final Map<String, String> map;
    private final NamespaceContext parent;
    public DefaultNamespaceContext() {
        this(XPathFactory.newInstance());
    }
    public DefaultNamespaceContext(XPathFactory factory) {
        this.parent = factory.newXPath().getNamespaceContext();
        this.map = new HashMap<String, String>();
    }
    public DefaultNamespaceContext(NamespaceContext parent, Map<String, String> map) {
        this.parent = parent;
        this.map = map;
    }
    /**
     * A helper method to make it easy to create newly populated instances
     */
    public DefaultNamespaceContext add(String prefix, String uri) {
        map.put(prefix, uri);
        return this;
    }
    public String getNamespaceURI(String prefix) {
        String answer = map.get(prefix);
        if (answer == null && parent != null) {
            return parent.getNamespaceURI(prefix);
        }
        return answer;
    }
    public String getPrefix(String namespaceURI) {
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                return (String) entry.getKey();
            }
        }
        if (parent != null) {
            return parent.getPrefix(namespaceURI);
        }
        return null;
    }
    public Iterator getPrefixes(String namespaceURI) {
        Set set = new HashSet();
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                set.add(entry.getKey());
            }
        }
        if (parent != null) {
            Iterator iter = parent.getPrefixes(namespaceURI);
            while (iter.hasNext()) {
                set.add(iter.next());
            }
        }
        return set.iterator();
    }
    public void setNamespaces(Map<String, String> namespaces) {
        map.putAll(namespaces);
    }
}
"
org.apache.camel.component.mina.TextLineCodecFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.nio.charset.Charset;
import org.apache.mina.filter.codec.ProtocolCodecFactory;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.textline.LineDelimiter;
import org.apache.mina.filter.codec.textline.TextLineDecoder;
import org.apache.mina.filter.codec.textline.TextLineEncoder;
/**
 * Text line codec that supports setting charset and delimiter.
 * <p/>
 * Uses Mina's default TextLineEncoder and TextLineDncoder. 
 */
public class TextLineCodecFactory implements ProtocolCodecFactory {
    private ProtocolEncoder encoder;
    private ProtocolDecoder decoder;
    public TextLineCodecFactory(Charset charset, LineDelimiter delimiter) {
        if (delimiter.equals(LineDelimiter.AUTO)) {
            // AUTO not supported by encoder
            encoder = new TextLineEncoder(charset);
        } else {
            encoder = new TextLineEncoder(charset, delimiter);
        }
        decoder = new TextLineDecoder(charset, delimiter);
    }
    public ProtocolEncoder getEncoder() throws Exception {
        return encoder;
    }
    public ProtocolDecoder getDecoder() throws Exception {
        return decoder;
    }
}
"
org.apache.camel.bam.rules.ActivityRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.ProcessBuilder;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a activity which is typically a system or could be an endpoint
 *
 * @version $Revision$
 */
public class ActivityRules extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(ActivityRules.class);
    private int expectedMessages = 1;
    private ProcessRules processRules;
    private List<TemporalRule> rules = new ArrayList<TemporalRule>();
    private ActivityDefinition activityDefinition;
    private String activityName;
    private final org.apache.camel.bam.ProcessBuilder builder;
    public ActivityRules(ProcessBuilder builder) {
        this.builder = builder;
        this.processRules = builder.getProcessRules();
        processRules.getActivities().add(this);
    }
    public void addRule(TemporalRule rule) {
        rules.add(rule);
    }
    /**
     * Handles overdue activities
     */
    public void processExpired(ActivityState activityState) throws Exception {
        for (TemporalRule rule : rules) {
            rule.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (TemporalRule rule : rules) {
            rule.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public ActivityDefinition getActivityDefinition() {
        // lets always query for it, to avoid issues with refreshing before a commit etc
        return builder.findOrCreateActivityDefinition(activityName);
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public int getExpectedMessages() {
        return expectedMessages;
    }
    public void setExpectedMessages(int expectedMessages) {
        this.expectedMessages = expectedMessages;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public void setActivityName(String activityName) {
        this.activityName = activityName;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(rules);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(rules);
    }
}
"
org.apache.camel.component.bean.BeanInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Body;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Header;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.OutHeaders;
import org.apache.camel.Properties;
import org.apache.camel.Property;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ExchangeHelper.convertToType;
/**
 * Represents the metadata about a bean type created via a combination of
 * introspection and annotations together with some useful sensible defaults
 *
 * @version $Revision$
 */
public class BeanInfo {
    private static final transient Log LOG = LogFactory.getLog(BeanInfo.class);
    private final CamelContext camelContext;
    private Class type;
    private ParameterMappingStrategy strategy;
    private Map<String, MethodInfo> operations = new ConcurrentHashMap<String, MethodInfo>();
    private MethodInfo defaultMethod;
    private List<MethodInfo> operationsWithBody = new ArrayList<MethodInfo>();
    private List<MethodInfo> operationsWithCustomAnnotation = new ArrayList<MethodInfo>();
    private Map<Method, MethodInfo> methodMap = new HashMap<Method, MethodInfo>();
    private BeanInfo superBeanInfo;
    public BeanInfo(CamelContext camelContext, Class type) {
        this(camelContext, type, createParameterMappingStrategy(camelContext));
    }
    public BeanInfo(CamelContext camelContext, Class type, ParameterMappingStrategy strategy) {
        this.camelContext = camelContext;
        this.type = type;
        this.strategy = strategy;
        introspect(getType());
        if (operations.size() == 1) {
            Collection<MethodInfo> methodInfos = operations.values();
            for (MethodInfo methodInfo : methodInfos) {
                defaultMethod = methodInfo;
            }
        }
    }
    public Class getType() {
        return type;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public MethodInvocation createInvocation(Method method, Object pojo, Exchange exchange)
        throws RuntimeCamelException {
        MethodInfo methodInfo = introspect(type, method);
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    public MethodInvocation createInvocation(Object pojo, Exchange exchange) throws RuntimeCamelException,
        AmbiguousMethodCallException {
        MethodInfo methodInfo = null;
        // TODO use some other mechanism?
        String name = exchange.getIn().getHeader(BeanProcessor.METHOD_NAME, String.class);
        if (name != null) {
            methodInfo = operations.get(name);
        }
        if (methodInfo == null) {
            methodInfo = chooseMethod(pojo, exchange);
        }
        if (methodInfo == null) {
            methodInfo = defaultMethod;
        }
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    protected void introspect(Class clazz) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Introspecting class: "" + clazz);
        }
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            if (isValidMethod(clazz, method)) {
                introspect(clazz, method);
            }
        }
        Class superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            introspect(superclass);
        }
    }
    protected MethodInfo introspect(Class clazz, Method method) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Introspecting class: "" + clazz + "", method: "" + method);
        }
        String opName = method.getName();
        MethodInfo methodInfo = createMethodInfo(clazz, method);
        // methods already registered should be prefered to use instead of super classes of existing methods
        // we want to us the method from the sub class over super classes, so if we have already registered
        // the method then use it (we are traversing upwards: sub (child) -> super (farther) )
        MethodInfo existingMethodInfo = overridesExistingMethod(methodInfo);
        if (existingMethodInfo != null) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""This method is already overriden in a subclass, so the method from the sub class is prefered: "" + existingMethodInfo);
            }
            return existingMethodInfo;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Adding operation: "" + opName + "" for method: "" + methodInfo);
        }
        operations.put(opName, methodInfo);
        if (methodInfo.hasBodyParameter()) {
            operationsWithBody.add(methodInfo);
        }
        if (methodInfo.isHasCustomAnnotation() && !methodInfo.hasBodyParameter()) {
            operationsWithCustomAnnotation.add(methodInfo);
        }
        // must add to method map last otherwise we break stuff
        methodMap.put(method, methodInfo);
        return methodInfo;
    }
    /**
     * Does the given method info override an existing method registered before (from a subclass)
     *
     * @param methodInfo  the method to test
     * @return the already registered method to use, null if not overriding any
     */
    private MethodInfo overridesExistingMethod(MethodInfo methodInfo) {
        for (MethodInfo info : methodMap.values()) {
            // name test
            if (!info.getMethod().getName().equals(methodInfo.getMethod().getName())) {
                continue;
            }
            // parameter types
            if (info.getMethod().getParameterTypes().length != methodInfo.getMethod().getParameterTypes().length) {
                continue;
            }
            for (int i = 0; i < info.getMethod().getParameterTypes().length; i++) {
                Class type1 = info.getMethod().getParameterTypes()[i];
                Class type2 = methodInfo.getMethod().getParameterTypes()[i];
                if (!type1.equals(type2)) {
                    continue;
                }
            }
            // sanme name, same parameters, then its overrides an existing class
            return info;
        }
        return null;
    }
    /**
     * Returns the {@link MethodInfo} for the given method if it exists or null
     * if there is no metadata available for the given method
     */
    public MethodInfo getMethodInfo(Method method) {
        MethodInfo answer = methodMap.get(method);
        if (answer == null) {
            // maybe the method is defined on a base class?
            if (superBeanInfo == null && type != Object.class) {
                Class superclass = type.getSuperclass();
                if (superclass != null && superclass != Object.class) {
                    superBeanInfo = new BeanInfo(camelContext, superclass, strategy);
                    return superBeanInfo.getMethodInfo(method);
                }
            }
        }
        return answer;
    }
    protected MethodInfo createMethodInfo(Class clazz, Method method) {
        Class[] parameterTypes = method.getParameterTypes();
        Annotation[][] parametersAnnotations = method.getParameterAnnotations();
        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();
        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();
        boolean hasCustomAnnotation = false;
        for (int i = 0; i < parameterTypes.length; i++) {
            Class parameterType = parameterTypes[i];
            Annotation[] parameterAnnotations = parametersAnnotations[i];
            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType,
                                                                       parameterAnnotations);
            hasCustomAnnotation |= expression != null;
            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations,
                                                            expression);
            parameters.add(parameterInfo);
            if (expression == null) {
                hasCustomAnnotation |= ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);
                if (bodyParameters.isEmpty()) {
                    // lets assume its the body
                    if (Exchange.class.isAssignableFrom(parameterType)) {
                        expression = ExpressionBuilder.exchangeExpression();
                    } else {
                        expression = ExpressionBuilder.bodyExpression(parameterType);
                    }
                    parameterInfo.setExpression(expression);
                    bodyParameters.add(parameterInfo);
                } else {
                    // will ignore the expression for parameter evaluation
                }
            }
        }
        // now lets add the method to the repository
        // TODO allow an annotation to expose the operation name to use
        /* if (method.getAnnotation(Operation.class) != null) { String name =
         * method.getAnnotation(Operation.class).name(); if (name != null &&
         * name.length() > 0) { opName = name; } }
         */
        MethodInfo methodInfo = new MethodInfo(clazz, method, parameters, bodyParameters, hasCustomAnnotation);
        return methodInfo;
    }
    /**
     * Lets try choose one of the available methods to invoke if we can match
     * the message body to the body parameter
     *
     * @param pojo the bean to invoke a method on
     * @param exchange the message exchange
     * @return the method to invoke or null if no definitive method could be
     *         matched
     */
    protected MethodInfo chooseMethod(Object pojo, Exchange exchange) throws AmbiguousMethodCallException {
        if (operationsWithBody.size() == 1) {
            return operationsWithBody.get(0);
        } else if (!operationsWithBody.isEmpty()) {
            return chooseMethodWithMatchingBody(exchange, operationsWithBody);
        } else if (operationsWithCustomAnnotation.size() == 1) {
            return operationsWithCustomAnnotation.get(0);
        }
        return null;
    }
    protected MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList) throws AmbiguousMethodCallException {
        // lets see if we can find a method who's body param type matches the message body
        Message in = exchange.getIn();
        Object body = in.getBody();
        if (body != null) {
            Class bodyType = body.getClass();
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Matching for method with a single parameter that matches type: "" + bodyType.getCanonicalName());
            }
            List<MethodInfo> possibles = new ArrayList<MethodInfo>();
            for (MethodInfo methodInfo : operationList) {
                // TODO: AOP proxies have additioan methods - consider having a static
                // method exclude list to skip all known AOP proxy methods
                // TODO: This class could use some TRACE logging
                // test for MEP pattern matching
                boolean out = exchange.getPattern().isOutCapable();
                if (out && methodInfo.isReturnTypeVoid()) {
                    // skip this method as the MEP is Out so the method must return someting
                    continue;
                }
                // try to match the arguments
                if (methodInfo.bodyParameterMatches(bodyType)) {
                    possibles.add(methodInfo);
                }
            }
            if (possibles.size() == 1) {
                return possibles.get(0);
            } else if (possibles.isEmpty()) {
                // lets try converting
                Object newBody = null;
                MethodInfo matched = null;
                for (MethodInfo methodInfo : operationList) {
                    Object value = null;
                    try {
                        value = convertToType(exchange, methodInfo.getBodyParameterType(), body);
                        if (value != null) {
                            if (newBody != null) {
                                throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched,
                                                                                               methodInfo));
                            } else {
                                newBody = value;
                                matched = methodInfo;
                            }
                        }
                    } catch (NoTypeConversionAvailableException e) {
                        // we can safely ignore this exception as we want a behaviour similar to
                        // that if convertToType return null
                    }
                }
                if (matched != null) {
                    in.setBody(newBody);
                    return matched;
                }
            } else {
                // if we only have a single method with custom annotations, lets use that one
                if (operationsWithCustomAnnotation.size() == 1) {
                    return operationsWithCustomAnnotation.get(0);
                }
                return chooseMethodWithCustomAnnotations(exchange, possibles);
            }
        }
        // no match so return null
        return null;
    }
    protected MethodInfo chooseMethodWithCustomAnnotations(Exchange exchange, Collection<MethodInfo> possibles) throws AmbiguousMethodCallException {
        // if we have only one method with custom annotations lets choose that
        MethodInfo chosen = null;
        for (MethodInfo possible : possibles) {
            if (possible.isHasCustomAnnotation()) {
                if (chosen != null) {
                    chosen = null;
                    break;
                } else {
                    chosen = possible;
                }
            }
        }
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }
    /**
     * Creates an expression for the given parameter type if the parameter can
     * be mapped automatically or null if the parameter cannot be mapped due to
     * unsufficient annotations or not fitting with the default type
     * conventions.
     */
    protected Expression createParameterUnmarshalExpression(Class clazz, Method method, Class parameterType,
                                                            Annotation[] parameterAnnotation) {
        // TODO look for a parameter annotation that converts into an expression
        for (Annotation annotation : parameterAnnotation) {
            Expression answer = createParameterUnmarshalExpressionForAnnotation(clazz, method, parameterType,
                                                                                annotation);
            if (answer != null) {
                return answer;
            }
        }
        return strategy.getDefaultParameterTypeExpression(parameterType);
    }
    protected boolean isPossibleBodyParameter(Annotation[] annotations) {
        if (annotations != null) {
            for (Annotation annotation : annotations) {
                if ((annotation instanceof Property)
                        || (annotation instanceof Header)
                        || (annotation instanceof Headers)
                        || (annotation instanceof OutHeaders)
                        || (annotation instanceof Properties)) {
                    return false;
                }
                LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
                if (languageAnnotation != null) {
                    return false;
                }
            }
        }
        return true;
    }
    protected Expression createParameterUnmarshalExpressionForAnnotation(Class clazz, Method method,
                                                                         Class parameterType,
                                                                         Annotation annotation) {
        if (annotation instanceof Property) {
            Property propertyAnnotation = (Property)annotation;
            return ExpressionBuilder.propertyExpression(propertyAnnotation.name());
        } else if (annotation instanceof Properties) {
            return ExpressionBuilder.propertiesExpression();
        } else if (annotation instanceof Header) {
            Header headerAnnotation = (Header)annotation;
            return ExpressionBuilder.headerExpression(headerAnnotation.name());
        } else if (annotation instanceof Headers) {
            return ExpressionBuilder.headersExpression();
        } else if (annotation instanceof OutHeaders) {
            return ExpressionBuilder.outHeadersExpression();
        } else {
            LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
            if (languageAnnotation != null) {
                Class<?> type = languageAnnotation.factory();
                Object object = camelContext.getInjector().newInstance(type);
                if (object instanceof AnnotationExpressionFactory) {
                    AnnotationExpressionFactory expressionFactory = (AnnotationExpressionFactory) object;
                    return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);
                } else {
                    LOG.error(""Ignoring bad annotation: "" + languageAnnotation + ""on method: "" + method
                            + "" which declares a factory: "" + type.getName()
                            + "" which does not implement "" + AnnotationExpressionFactory.class.getName());
                }
            }
        }
        return null;
    }
    protected boolean isValidMethod(Class clazz, Method method) {
        // must be a public method
        if (!Modifier.isPublic(method.getModifiers())) {
            return false;
        }
        // return type must not be an Exchange
        if (method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) {
            return false;
        }
        return true;
    }
    public static ParameterMappingStrategy createParameterMappingStrategy(CamelContext camelContext) {
        Registry registry = camelContext.getRegistry();
        ParameterMappingStrategy answer = registry.lookup(ParameterMappingStrategy.class.getName(),
                                                          ParameterMappingStrategy.class);
        if (answer == null) {
            answer = new DefaultParameterMappingStrategy();
        }
        return answer;
    }
}
"
org.apache.camel.component.cxf.util.CxfEndpointUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.lang.annotation.Annotation;
import java.net.URI;
import java.net.URL;
import java.util.logging.Logger;
import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.ws.WebServiceProvider;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelException;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfEndpoint;
import org.apache.camel.component.cxf.DataFormat;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.Bus;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.common.i18n.Message;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.common.util.ClassHelper;
import org.apache.cxf.frontend.ClientProxyFactoryBean;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
import org.apache.cxf.jaxws.JaxWsServerFactoryBean;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.factory.AbstractServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
public final class CxfEndpointUtils {
    public static final String PROP_NAME_PORT = ""port"";
    public static final String PROP_NAME_SERVICE = ""service"";
    public static final String PROP_NAME_SERVICECLASS = ""serviceClass"";
    public static final String PROP_NAME_DATAFORMAT = ""dataFormat"";
    public static final String DATAFORMAT_POJO = ""pojo"";
    public static final String DATAFORMAT_MESSAGE = ""message"";
    public static final String DATAFORMAT_PAYLOAD = ""payload"";
    private static final Logger LOG = LogUtils.getL7dLogger(CxfEndpointUtils.class);
    private CxfEndpointUtils() {
        // not constructed
    }
    static QName getQName(final String name) {
        QName qName = null;
        if (name != null) {
            try {
                qName =  QName.valueOf(name);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        return qName;
    }
    public static Class getServiceClass(CxfEndpoint cxfEndpoint) throws ClassNotFoundException {
        Class<?> answer = null;
        if (cxfEndpoint.isSpringContextEndpoint()) {
            answer = cxfEndpoint.getCxfEndpointBean().getServiceClass();
            if (answer != null) {
                return answer;
            }
        }
        if (cxfEndpoint.getServiceClassInstance() != null) {        
            Object bean = cxfEndpoint.getCamelContext().getRegistry().lookup(cxfEndpoint.getServiceClassInstance());
            if (bean != null) {
                answer = ClassHelper.getRealClass(bean);
            } else {
                throw new ClassNotFoundException(""Can't find serviceClass instace with name"" + cxfEndpoint.getServiceClassInstance() + "" from CamelContext registry."");
            }
        } else {
            if (ObjectHelper.isNotEmpty(cxfEndpoint.getServiceClass())) {
                answer = ClassLoaderUtils.loadClass(cxfEndpoint.getServiceClass(), CxfEndpointUtils.class);
            } else {
                throw new ClassNotFoundException(""Can't find serviceClass from uri, please check the cxf endpoint configuration"");
            }
        }
        return answer;
    }
    public static QName getPortName(final CxfEndpoint endpoint) {
        if (endpoint.getPortName() != null) {
            return getQName(endpoint.getPortName());
        } else {
            String portLocalName = getCxfEndpointPropertyValue(endpoint, CxfConstants.PORT_LOCALNAME);
            String portNamespace = getCxfEndpointPropertyValue(endpoint, CxfConstants.PORT_NAMESPACE);
            if (portLocalName != null) {
                return new QName(portNamespace, portLocalName);
            } else {
                return null;
            }           
        }
    }
    public static QName getServiceName(final CxfEndpoint endpoint) {
        if (endpoint.getServiceName() != null) {
            return getQName(endpoint.getServiceName());
        } else {
            String serviceLocalName = getCxfEndpointPropertyValue(endpoint, CxfConstants.SERVICE_LOCALNAME);
            String serviceNamespace = getCxfEndpointPropertyValue(endpoint, CxfConstants.SERVICE_NAMESPACE);
            if (serviceLocalName != null) {
                return new QName(serviceNamespace, serviceLocalName);
            } else {
                return null;
            }
        }
    }
    public static EndpointInfo getEndpointInfo(final Service service, final CxfEndpoint endpoint) {
        EndpointInfo endpointInfo = null;
        final java.util.Collection<EndpointInfo> endpoints = service.getServiceInfos().get(0).getEndpoints();
        if (endpoints.size() == 1) {
            endpointInfo = endpoints.iterator().next();
        } else {
            final String port = endpoint.getPortName();
            if (port != null) {
                final QName endpointName = QName.valueOf(port);
                endpointInfo = service.getServiceInfos().get(0).getEndpoint(endpointName);
            }
            //TBD may be delegate to the EndpointUri params.
        }
        return endpointInfo;
    }   
    public static boolean hasWebServiceAnnotation(Class<?> cls) {
        return hasAnnotation(cls, WebService.class) || hasAnnotation(cls, WebServiceProvider.class);
    }
    public static boolean hasAnnotation(Class<?> cls, Class<? extends Annotation> annotation) {
        if (cls == null || cls == Object.class) {
            return false;
        }
        if (null != cls.getAnnotation(annotation)) {
            return true;
        }
        for (Class<?> interfaceClass : cls.getInterfaces()) {
            if (null != interfaceClass.getAnnotation(annotation)) {
                return true;
            }
        }
        return hasAnnotation(cls.getSuperclass(), annotation);
    }
    public static ServerFactoryBean getServerFactoryBean(Class<?> cls) throws CamelException {
        ServerFactoryBean serverFactory  = null;
        try {
            if (cls == null) {
                serverFactory = new ServerFactoryBean();
                serverFactory.setServiceFactory(new WSDLSoapServiceFactoryBean());
            } else {
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean()
                            : new ServerFactoryBean();
            }
            return serverFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    public static ClientProxyFactoryBean getClientFactoryBean(Class<?> cls) throws CamelException {
        ClientProxyFactoryBean clientFactory = null;
        try {
            if (cls == null) {
                clientFactory = new ClientProxyFactoryBean();
                clientFactory.setServiceFactory(new WSDLSoapServiceFactoryBean());
            } else {
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                clientFactory = isJSR181SEnabled ? new JaxWsProxyFactoryBean()
                        : new ClientProxyFactoryBean();
            }
            return clientFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    //TODO check the CxfEndpoint information integration
    public static void checkEndpiontIntegration(CxfEndpoint endpoint, Bus bus) throws CamelException {
        String wsdlLocation = endpoint.getWsdlURL();
        QName serviceQName = CxfEndpointUtils.getQName(endpoint.getServiceName());
        String serviceClassName = endpoint.getServiceClass();
        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        URL wsdlUrl = null;
        if (wsdlLocation != null) {
            try {
                wsdlUrl = UriUtils.getWsdlUrl(new URI(wsdlLocation));
            } catch (Exception e) {
                throw new CamelException(e);
            }
        }
        if (serviceQName == null) {
            throw new CamelException(new Message(""SVC_QNAME_NOT_FOUND_X"", LOG, endpoint.getServiceName()).toString());
        }
        if (serviceClassName == null && dataFormat == DataFormat.POJO) {
            throw new CamelException(new Message(""SVC_CLASS_PROP_IS_REQUIRED_X"", LOG).toString());
        }
        AbstractServiceFactoryBean serviceFactory = null;
        try {
            if (serviceClassName != null) {
                Class<?> cls = ClassLoaderUtils.loadClass(serviceClassName, CxfEndpointUtils.class);
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                serviceFactory = isJSR181SEnabled
                    ? new JaxWsServiceFactoryBean() : new ReflectionServiceFactoryBean();
                serviceFactory.setBus(bus);
                if (wsdlUrl != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setWsdlURL(wsdlUrl);
                }
                if (serviceQName != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setServiceName(serviceQName);
                }
                ((ReflectionServiceFactoryBean)serviceFactory).setServiceClass(cls);
            } else {
                if (wsdlUrl == null) {
                    throw new CamelException(new Message(""SVC_WSDL_URL_IS_NULL_X"", LOG, wsdlLocation).toString());
                }
                serviceFactory = new WSDLServiceFactory(bus, wsdlUrl, serviceQName);
            }
        } catch (ClassNotFoundException cnfe) {
            throw new CamelException(new Message(""CLASS_X_NOT_FOUND "", LOG, serviceClassName).toString(), cnfe);
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    public static boolean getSetDefaultBus(CxfEndpoint endpoint) {
        Boolean isSetDefaultBus = null;
        // check the value of cxfEndpointBean's property
        CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
        if (cxfEndpointBean != null && cxfEndpointBean.getProperties() != null) {
            String value =  (String)cxfEndpointBean.getProperties().get(CxfConstants.SET_DEFAULT_BUS);
            isSetDefaultBus = Boolean.valueOf(value);
        }
        // We will get the value from the cxfEndpontBean's properties
        if (isSetDefaultBus != null && endpoint.isSetDefaultBus() == null) {
            return isSetDefaultBus.booleanValue();
        } else if (endpoint.isSetDefaultBus() != null) {
            return endpoint.isSetDefaultBus().booleanValue();
        } else { // return the default value false
            return false;
        }
    }   
    public static String getCxfEndpointPropertyValue(CxfEndpoint endpoint, String property) {
        String result = null;
        CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
        if (cxfEndpointBean != null && cxfEndpointBean.getProperties() != null) {
            result = (String) cxfEndpointBean.getProperties().get(property);
        }
        return result;
    }
    public static DataFormat getDataFormat(CxfEndpoint endpoint) throws CamelException {
        String dataFormatString = endpoint.getDataFormat();
        if (dataFormatString == null) {
            dataFormatString = getCxfEndpointPropertyValue(endpoint, CxfConstants.DATA_FORMAT);           
        }
        // return the default value if nothing is set
        if (dataFormatString == null) {
            return DataFormat.POJO;
        }
        DataFormat retval = DataFormat.asEnum(dataFormatString);
        if (retval == DataFormat.UNKNOWN) {
            throw new CamelException(new Message(""INVALID_MESSAGE_FORMAT_XXXX"", LOG, dataFormatString).toString());
        }
        return retval;
    }
}
"
org.apache.camel.component.event.EventConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Consumer</a>
 * for working with Spring ApplicationEvents
 *
 * @version $Revision$
 */
public class EventConsumer extends DefaultConsumer<Exchange> {
    private EventEndpoint endpoint;
    public EventConsumer(EventEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.component.validator.jing.JingComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * A component for validating XML payloads using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision$
 */
public class JingComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        JingValidator validator = new JingValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.component.velocity.VelocityEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.component.ResourceBasedEndpoint;
import org.apache.camel.util.ExchangeHelper;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
import org.apache.velocity.runtime.log.SimpleLog4JLogSystem;
import org.springframework.core.io.Resource;
/**
 * @version $Revision$
 */
public class VelocityEndpoint extends ResourceBasedEndpoint {
    private final VelocityComponent component;
    private VelocityEngine velocityEngine;
    private boolean loaderCache = true;
    private String encoding;
    public VelocityEndpoint(String uri, VelocityComponent component, String resourceUri, Map parameters) {
        super(uri, component, resourceUri, null);
        this.component = component;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
    @Override
    public ExchangePattern getExchangePattern() {
        return ExchangePattern.InOut;
    }
    private VelocityEngine getVelocityEngine() throws Exception {
        if (velocityEngine == null) {
            velocityEngine = component.getVelocityEngine();
            velocityEngine.setProperty(Velocity.FILE_RESOURCE_LOADER_CACHE, isLoaderCache() ? Boolean.TRUE : Boolean.FALSE);
            velocityEngine.setProperty(Velocity.RUNTIME_LOG_LOGSYSTEM_CLASS, SimpleLog4JLogSystem.class.getName());
            velocityEngine.setProperty(""runtime.log.logsystem.log4j.category"", VelocityEndpoint.class.getName());
            velocityEngine.init();
        }
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    public boolean isLoaderCache() {
        return loaderCache;
    }
    /**
     * Enables / disables the velocity resource loader cache which is enabled by default
     *
     * @param loaderCache a flag to enable/disable the cache
     */
    public void setLoaderCache(boolean loaderCache) {
        this.loaderCache = loaderCache;
    }
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    public String getEncoding() {
        return encoding;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    protected void onExchange(Exchange exchange) throws Exception {
        Resource resource = getResource();
        // getResourceAsInputStream also considers the content cache
        Reader reader = encoding != null ? new InputStreamReader(getResourceAsInputStream(), encoding) : new InputStreamReader(getResourceAsInputStream());
        StringWriter buffer = new StringWriter();
        String logTag = getClass().getName();
        Map variableMap = ExchangeHelper.createVariableMap(exchange);
        Context velocityContext = new VelocityContext(variableMap);
        // let velocity parse and generate the result in buffer
        VelocityEngine engine = getVelocityEngine();
        if (log.isDebugEnabled()) {
            log.debug(""Velocity is evaluating using velocity context: "" + variableMap);
        }
        engine.evaluate(velocityContext, buffer, logTag, reader);
        // now lets output the results to the exchange
        Message out = exchange.getOut(true);
        out.setBody(buffer.toString());
        out.setHeader(""org.apache.camel.velocity.resource"", resource);
        Map<String, Object> headers = (Map<String, Object>)velocityContext.get(""headers"");
        for (String key : headers.keySet()) {
            out.setHeader(key, headers.get(key));
        }
    }
}
"
org.apache.camel.dataformat.hl7.HL7DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.hl7;
import java.io.InputStream;
import java.io.OutputStream;
import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.util.Terser;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * HL7 DataFormat (supports v2.x of the HL7 protocol).
 * <p/>
 * This data format supports two operations:
 * <ul>
 *   <li>marshal = from Message to String (can be used when returning as response using the HL7 MLLP codec)</li>
 *   <li>unmarshal = from String to Message (can be used when receiving streamed data from the HL7 MLLP codec).
 *   This operation will also enrich the message by adding the MSH fields (MSH-3 to MSH-12) as headers on the message.</li>
 * </ul>
 * <p/>
 * Uses the <a href=""http://hl7api.sourceforge.net/index.html"">HAPI (HL7 API)</a> for HL7 parsing.
 * <p/>
 * Uses the default PipeParser from the HAPI API. This DataFormat <b>only</b> supports the EDI based HL7
 * messages and not the XML based (their are not commonly used).
 * <p/>
 * The <tt>unmarshal</tt> operation adds these MSH fields as headers on the Camel message (key, MSH-field):
 * <ul>
 *   <li>hl7.msh.sendingApplication = MSH-3</li>
 *   <li>hl7.msh.sendingFacility = MSH-4</li>
 *   <li>hl7.msh.receivingApplication = MSH-5</li>
 *   <li>hl7.msh.receivingFacility = MSH-6</li>
 *   <li>hl7.msh.timestamp = MSH-7</li>
 *   <li>hl7.msh.security = MSH-8</li>
 *   <li>hl7.msh.messageType = MSH-9-1</li>
 *   <li>hl7.msh.triggerEvent = MSH-9-2</li>
 *   <li>hl7.msh.messageControl = MSH-10</li>
 *   <li>hl7.msh.processingId = MSH-11</li>
 *   <li>hl7.msh.versionId = MSH-12</li>
 * </ul>
 * All headers are String types.
 * <p/>
 * The <a href=""http://www.hl7.org/Special/IG/final.pdf"">HL7 spec</a> can be downloaded as a pdf at
 *
 * @see org.apache.camel.component.hl7.HL7MLLPCodec
 */
public class HL7DataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object body, OutputStream outputStream) throws Exception {
        Message message = ExchangeHelper.convertToMandatoryType(exchange, Message.class, body);
        String encoded = HL7Converter.toString(message);
        outputStream.write(encoded.getBytes());
    }
    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {
        String body = ExchangeHelper.convertToMandatoryType(exchange, String.class, inputStream);
        Message message = HL7Converter.toMessage(body);
        // add MSH fields as message out headers
        Terser terser = new Terser(message);
        exchange.getOut().setHeader(""hl7.msh.sendingApplication"", terser.get(""MSH-3""));
        exchange.getOut().setHeader(""hl7.msh.sendingFacility"", terser.get(""MSH-4""));
        exchange.getOut().setHeader(""hl7.msh.receivingApplication"", terser.get(""MSH-5""));
        exchange.getOut().setHeader(""hl7.msh.receivingFacility"", terser.get(""MSH-6""));
        exchange.getOut().setHeader(""hl7.msh.timestamp"", terser.get(""MSH-7""));
        exchange.getOut().setHeader(""hl7.msh.security"", terser.get(""MSH-8""));
        exchange.getOut().setHeader(""hl7.msh.messageType"", terser.get(""MSH-9-1""));
        exchange.getOut().setHeader(""hl7.msh.triggerEvent"", terser.get(""MSH-9-2""));
        exchange.getOut().setHeader(""hl7.msh.messageControl"", terser.get(""MSH-10""));
        exchange.getOut().setHeader(""hl7.msh.processingId"", terser.get(""MSH-11""));
        exchange.getOut().setHeader(""hl7.msh.versionId"", terser.get(""MSH-12""));
        return message;
    }
}
"
org.apache.camel.component.xquery.XQueryLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class XQueryLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return XQueryBuilder.xquery(expression);
    }
    public Expression<Exchange> createExpression(String expression) {
        return XQueryBuilder.xquery(expression);
    }
}
"
org.apache.camel.component.cxf.CxfBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.MessageContext.Scope;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.component.cxf.util.CxfHeaderHelper;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxws.context.WrappedMessageContext;
import org.apache.cxf.message.Message;
/**
 * The binding/mapping of Camel messages to Apache CXF and back again
 *
 * @version $Revision$
 */
public final class CxfBinding {
    private CxfBinding() {
        // Helper class
    }
    public static Object extractBodyFromCxf(CxfExchange exchange, Message message) {
        // TODO how do we choose a format?
        return getBody(message);
    }
    protected static Object getBody(Message message) {
        Set<Class<?>> contentFormats = message.getContentFormats();
        if (contentFormats != null) {
            for (Class<?> contentFormat : contentFormats) {
                Object answer = message.getContent(contentFormat);
                if (answer != null) {
                    return answer;
                }
            }
        }
        return null;
    }
    /**
     * @deprecated please use {@link #createCxfMessage(HeaderFilterStrategy, CxfExchange)} instead
     */
    public static Message createCxfMessage(CxfExchange exchange) {
        return CxfBinding.createCxfMessage(new CxfHeaderFilterStrategy(), exchange);
    }
    public static Message createCxfMessage(HeaderFilterStrategy strategy, CxfExchange exchange) {
        Message answer = exchange.getInMessage();
        CxfMessage in = exchange.getIn();
        // Check the body if the POJO parameter list first
        try {
            List body = in.getBody(List.class);
            // just set the operation's parameter
            answer.setContent(List.class, body);
            CxfHeaderHelper.propagateCamelToCxf(strategy, in.getHeaders(), answer);
        } catch (NoTypeConversionAvailableException ex) {
            // CXF uses StAX which is based on the stream API to parse the XML,
            // so the CXF transport is also based on the stream API.
            // And the interceptors are also based on the stream API,
            // so let's use an InputStream to host the CXF on wire message.
            try {
                InputStream body = in.getBody(InputStream.class);
                answer.setContent(InputStream.class, body);
            } catch (NoTypeConversionAvailableException ex2) {
                // ignore
            }
            // TODO do we propagate header the same way in non-POJO mode?
            // CxfHeaderHelper.propagateCamelToCxf(strategy, in.getHeaders(), answer);
        }
        //Ensure there is a request context, which is needed by propogateContext() below
        Map<String, Object> requestContext = CastUtils.cast((Map)answer.get(Client.REQUEST_CONTEXT));
        if (requestContext == null) {
            requestContext = new HashMap<String, Object>();
        }
        if (exchange.getExchange() != null) {
            requestContext.putAll(exchange.getExchange());
        }
        if (exchange.getProperties() != null) {
            //Allows other components to pass properties into cxf request context
            requestContext.putAll(exchange.getProperties());
        }
        answer.put(Client.REQUEST_CONTEXT, requestContext);
        return answer;
    }
    /**
     * @deprecated please use {@link #storeCxfResponse(HeaderFilterStrategy, CxfExchange, Message)} instead.
     */
    public static void storeCxfResponse(CxfExchange exchange, Message response) {
        CxfBinding.storeCxfResponse(new CxfHeaderFilterStrategy(), exchange, response);
    }
    public static void storeCxfResponse(HeaderFilterStrategy strategy, CxfExchange exchange,
            Message response) {
        CxfMessage out = exchange.getOut();
        if (response != null) {
            CxfHeaderHelper.propagateCxfToCamel(strategy, response, out.getHeaders());
            out.setMessage(response);
            DataFormat dataFormat = (DataFormat) exchange.getProperty(CxfExchange.DATA_FORMAT);
            if (dataFormat.equals(DataFormat.MESSAGE)) {
                out.setBody(response.getContent(InputStream.class));
            }
            if (dataFormat.equals(DataFormat.PAYLOAD)) {
                out.setBody(response);
            }
        }
    }
    /**
     * @deprecated Please use {@link #copyMessage(HeaderFilterStrategy, org.apache.camel.Message, Message)} instead.
     */
    public static void copyMessage(org.apache.camel.Message camelMessage, org.apache.cxf.message.Message cxfMessage) {
        CxfBinding.copyMessage(new CxfHeaderFilterStrategy(), camelMessage, cxfMessage);
    }
    // Copy the Camel message to CXF message
    public static void copyMessage(HeaderFilterStrategy strategy,
            org.apache.camel.Message camelMessage, org.apache.cxf.message.Message cxfMessage) {
        CxfHeaderHelper.propagateCamelToCxf(strategy, camelMessage.getHeaders(), cxfMessage);
        try {
            InputStream is = camelMessage.getBody(InputStream.class);
            if (is != null) {
                cxfMessage.setContent(InputStream.class, is);
            }
        } catch (NoTypeConversionAvailableException ex) {
            Object result = camelMessage.getBody();
            if (result instanceof InputStream) {
                cxfMessage.setContent(InputStream.class, result);
            } else {
                cxfMessage.setContent(result.getClass(), result);
            }
        }
    }
    public static void storeCXfResponseContext(Message response, Map<String, Object> context) {
        if (context != null) {
            MessageContext messageContext = new WrappedMessageContext(context, null, Scope.HANDLER);
            response.put(Client.RESPONSE_CONTEXT, messageContext);
            //put the ResponseCode in the response context
            Object value = context.get(Message.RESPONSE_CODE);
            if (value != null) {
                response.put(Message.RESPONSE_CODE, value);
            }
        }
    }
    public static void storeCxfResponse(CxfExchange exchange, Object response) {
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setBody(response);
        }
    }
    public static void storeCxfFault(CxfExchange exchange, Message message) {
        CxfMessage fault = exchange.getFault();
        if (fault != null) {
            fault.setBody(getBody(message));
        }
    }
    public static Map<String, Object> propogateContext(Message message, Map<String, Object> context) {
        Map<String, Object> requestContext = CastUtils.cast((Map)message.get(Client.REQUEST_CONTEXT));
        Map<String, Object> responseContext = CastUtils.cast((Map)message.get(Client.RESPONSE_CONTEXT));
        // TODO map the JAXWS properties to cxf
        if (requestContext != null) {
            Map<String, Object> realMap = new HashMap<String, Object>();
            WrappedMessageContext ctx = new WrappedMessageContext(realMap,
                                                                  null,
                                                                  Scope.APPLICATION);
            ctx.putAll(requestContext);
            requestContext = realMap;
        }
        if (responseContext == null) {
            responseContext = new HashMap<String, Object>();
        } else {
            // clear the response context
            responseContext.clear();
        }
        context.put(Client.REQUEST_CONTEXT, requestContext);
        context.put(Client.RESPONSE_CONTEXT, responseContext);
        return responseContext;
    }
}
"
org.apache.camel.NoSuchLanguageException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an attempt is made to resolve an unknown
 * language definition.
 * 
 * @see org.apache.camel.CamelContext#resolveLanguage(String)
 * 
 * @version $Revision$
 */
public class NoSuchLanguageException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String language;
    public NoSuchLanguageException(String language) {
        super(""No language could be found for: "" + language);
        this.language = language;
    }
    public String getLanguage() {
        return language;
    }
}
"
org.apache.camel.component.cxf.CxfExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
/**
 * An {@link Exchange} for working with Apache CXF which exposes the underlying
 * CXF messages via {@link #getInMessage()} and {@link #getOutMessage()} along with the
 * {@link #getExchange()}
 *
 * @version $Revision$
 */
public class CxfExchange extends DefaultExchange {
    public static final String DATA_FORMAT = ""DATA_FORMAT"";
    private Exchange exchange;
    public CxfExchange(CamelContext context, ExchangePattern pattern, Exchange exchange) {
        super(context, pattern);
        this.exchange = exchange;
        // TO avoid the NPE here
        if (exchange != null) {
            if (exchange.getOutMessage() != null) {
                setOut(new CxfMessage(exchange.getOutMessage()));
            }
            if (exchange.getInMessage() != null) {
                setIn(new CxfMessage(exchange.getInMessage()));
            }
            if (exchange.getInFaultMessage() != null) {
                setFault(new CxfMessage(exchange.getInFaultMessage()));
            }
        }
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public CxfExchange(CxfExchange exchange) {
        super(exchange);
        this.exchange = exchange.getExchange();      
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern, Message inMessage) {
        this(context, pattern);
        this.exchange = inMessage.getExchange();
        setIn(new CxfMessage(inMessage));
        if (exchange != null) {
            if (exchange.getOutMessage() != null) {
                setOut(new CxfMessage(exchange.getOutMessage()));
            }
            if (exchange.getInFaultMessage() != null) {
                setFault(new CxfMessage(exchange.getInFaultMessage()));
            }
        }
    }
    @Override
    public org.apache.camel.Exchange newInstance() {
        return new CxfExchange(this);
    }
    @Override
    public CxfMessage getIn() {
        return (CxfMessage) super.getIn();
    }
    @Override
    public CxfMessage getOut() {
        return (CxfMessage) super.getOut();
    }
    @Override
    public CxfMessage getOut(boolean lazyCreate) {
        return (CxfMessage) super.getOut(lazyCreate);
    }
    @Override
    public CxfMessage getFault() {
        return (CxfMessage) super.getFault();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new CxfMessage();
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    // Expose CXF APIs directly on the exchange
    //-------------------------------------------------------------------------
    /**
     * Returns the underlying CXF message exchange for an inbound exchange
     * or null for outbound messages
     *
     * @return the inbound message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
    public Message getInMessage() {
        return getIn().getMessage();
    }
    public Message getOutMessage() {
        return getOut().getMessage();
    }
    public Message getOutFaultMessage() {
        return getExchange().getOutFaultMessage();
    }
    public Message getInFaultMessage() {
        return getExchange().getInFaultMessage();
    }
    public Destination getDestination() {
        return getExchange().getDestination();
    }
    public Conduit getConduit(Message message) {
        return getExchange().getConduit(message);
    }
    @Override
    protected CxfMessage createInMessage() {
        return new CxfMessage();
    }
    @Override
    protected CxfMessage createOutMessage() {
        return new CxfMessage();
    }
}
"
org.apache.camel.NoSuchPropertyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.util.ExchangeHelper;
/**
 * An exception caused when a mandatory property is not available on a message
 * {@link Exchange}
 * 
 * @see ExchangeHelper#getMandatoryProperty(Exchange, String, Class)
 * 
 * @version $Revision$
 */
public class NoSuchPropertyException extends CamelExchangeException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String propertyName;
    private final Class<?> type;
    public NoSuchPropertyException(Exchange exchange, String propertyName, Class<?> type) {
        super(""No '"" + propertyName + ""' property available of type: "" + type.getName()
              + reason(exchange, propertyName), exchange);
        this.propertyName = propertyName;
        this.type = type;
    }
    public String getPropertyName() {
        return propertyName;
    }
    public Class<?> getType() {
        return type;
    }
    protected static String reason(Exchange exchange, String propertyName) {
        Object value = exchange.getProperty(propertyName);
        return valueDescription(value);
    }
    static String valueDescription(Object value) {
        if (value == null) {
            return """";
        }
        return "" but has value: "" + value + "" of type: "" + value.getClass().getName();
    }
}
"
org.apache.camel.component.jpa.JpaTemplateTransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceException;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Delegates the strategy to the {@link JpaTemplate} and {@link TransactionTemplate} for transaction handling
 *
 * @version $Revision$
 */
public class JpaTemplateTransactionStrategy extends ServiceSupport implements TransactionStrategy {
    private final JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    public JpaTemplateTransactionStrategy(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
    }
    /**
     * Creates a new implementation from the given JPA factory
     */
    public static JpaTemplateTransactionStrategy newInstance(EntityManagerFactory emf) {
        JpaTemplate template = new JpaTemplate(emf);
        return newInstance(emf, template);
    }
    public static JpaTemplateTransactionStrategy newInstance(EntityManagerFactory emf, JpaTemplate template) {
        JpaTransactionManager transactionManager = new JpaTransactionManager(emf);
        transactionManager.afterPropertiesSet();
        TransactionTemplate tranasctionTemplate = new TransactionTemplate(transactionManager);
        tranasctionTemplate.afterPropertiesSet();
        return new JpaTemplateTransactionStrategy(template, tranasctionTemplate);
    }
    public Object execute(final JpaCallback callback) {
        return transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus status) {
                return jpaTemplate.execute(new JpaCallback() {
                    public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                        return callback.doInJpa(entityManager);
                    }
                });
            }
        });
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.bean.AnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.language.LanguageAnnotation;
/**
 * A factory which creates an {@link Expression} object from an annotation on a field, property or method parameter
 * of a specified type.
 *
 * @version $Revision$
 */
public interface AnnotationExpressionFactory {
    Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType);
}
"
org.apache.camel.component.dataset.DataSetConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.processor.ThroughputLogger;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * DataSet consumer.
 *
 * @version $Revision$
 */
public class DataSetConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(DataSetConsumer.class);
    private DataSetEndpoint endpoint;
    private Processor reporter;
    public DataSetConsumer(DataSetEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (reporter == null) {
            reporter = createReporter();
        }
        final DataSet dataSet = endpoint.getDataSet();
        final long preloadSize = endpoint.getPreloadSize();
        sendMessages(0, preloadSize);
        endpoint.getExecutorService().execute(new Runnable() {
            public void run() {
                sendMessages(preloadSize, dataSet.getSize());
            }
        });
    }
    protected void sendMessages(long startIndex, long endIndex) {
        try {
            for (long i = startIndex; i < endIndex; i++) {
                Exchange exchange = endpoint.createExchange(i);
                getProcessor().process(exchange);
                try {
                    long delay = endpoint.getProduceDelay();
                    if (delay < 3) {
                        // if no delay set then we must sleep at lest for 3 millis to avoid concurrency
                        // issues with extremely high throughput
                        delay = 3;
                    }
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                    // ignore and just log to debug
                    LOG.debug(e);
                }
                if (reporter != null) {
                    reporter.process(exchange);
                }
            }
        } catch (Exception e) {
            LOG.error(e);
        }
    }
    protected ThroughputLogger createReporter() {
        ThroughputLogger answer = new ThroughputLogger(endpoint.getEndpointUri(), (int) endpoint.getDataSet().getReportCount());
        answer.setAction(""Sent"");
        return answer;
    }
}
"
org.apache.camel.component.cxf.util.DataOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.util.logging.Logger;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Source;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.AbstractOutDatabindingInterceptor;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.StaxUtils;
public class DataOutInterceptor extends AbstractOutDatabindingInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(DataOutInterceptor.class);
    public DataOutInterceptor() {
        super(Phase.MARSHAL);
    }
    public void handleMessage(Message message) throws Fault {
        XMLStreamWriter xmlWriter = getXMLStreamWriter(message);
        try {
            // put the payload source as a document
            Source source = message.getContent(Source.class);
            if (source != null) {
                XMLStreamReader xmlReader = StaxUtils.createXMLStreamReader(source);
                StaxUtils.copy(xmlReader, xmlWriter);
            }
        } catch (XMLStreamException e) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""XMLSTREAM_EXCEPTION"",
                                                                   LOG, e),
                            e);
        }
    }
}
"
org.apache.camel.Endpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
/**
 * An <a href=""http://activemq.apache.org/camel/endpoint.html"">endpoint</a>
 * implements the <a
 * href=""http://activemq.apache.org/camel/message-endpoint.html"">Message
 * Endpoint</a> pattern and represents an endpoint that can send and receive
 * message exchanges
 *
 * @see Exchange
 * @see Message
 * @version $Revision$
 */
public interface Endpoint<E extends Exchange> {
    /**
     * Returns if the endpoint should be a CamelContext singleton. If the
     * endpoint is a Singleton, then a single Endpoint instance will be shared
     * by all routes with the same URI. Because the endpoint is shared, it
     * should be treated as an immutable.
     */
    boolean isSingleton();
    /**
     * Returns the string representation of the endpoint URI
     */
    String getEndpointUri();
    /**
     * Create a new exchange for communicating with this endpoint
     */
    E createExchange();
    /**
     * Create a new exchange for communicating with this endpoint
     * with the specified {@link ExchangePattern} such as whether its going
     * to be an {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut} exchange
     *
     * @param pattern the message exchange pattern for the exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(Exchange exchange);
    /**
     * Returns the context which created the endpoint
     *
     * @return the context which created the endpoint
     */
    CamelContext getCamelContext();
    /**
     * Creates a new producer which is used send messages into the endpoint
     *
     * @return a newly created producer
     */
    Producer<E> createProducer() throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Driven Consumer</a> which consumes messages from the endpoint using the
     * given processor
     *
     * @return a newly created consumer
     */
    Consumer<E> createConsumer(Processor processor) throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
     * Consumer</a> so that the caller can poll message exchanges from the
     * consumer using {@link PollingConsumer#receive()},
     * {@link PollingConsumer#receiveNoWait()} or
     * {@link PollingConsumer#receive(long)} whenever it is ready to do so
     * rather than using the <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Based Consumer</a> returned by {@link #createConsumer(Processor)}
     *
     * @return a newly created pull consumer
     * @throws Exception if the pull consumer could not be created
     */
    PollingConsumer<E> createPollingConsumer() throws Exception;
    void configureProperties(Map options);
    void setCamelContext(CamelContext context);
    @Deprecated
    CamelContext getContext();
    @Deprecated
    void setContext(CamelContext context);
    /**
     * Should all properties be known or does the endpoint allow unknown options?
     * <p/>
     * <tt>Lenient = false</tt> means that the endpoint should validate that all
     * given options is known and configured properly
     * <tt>lenient = true</tt> means that the endpoint allows additional unknown options to
     * be passed to it but does not throw a ResolveEndpointFailedException when creating
     * the endpoint.
     * <p/>
     * This options is used by a few components for instance the HTTP based that can have
     * dynamic URI options appended that is targeted for an external system.
     * <p/>
     * Most endpoints is configued to be <b>not</b> lenient.
     */
    boolean isLenientProperties();
}
"
org.apache.camel.converter.jaxb.JaxbConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.util.HashMap;
import java.util.Map;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.converter.HasAnnotation;
import org.apache.camel.converter.jaxp.XmlConverter;
/**
 * @version $Revision$
 */
public final class JaxbConverter {
    private XmlConverter jaxbConverter;
    private Map<Class, JAXBContext> contexts = new HashMap<Class, JAXBContext>();
    public XmlConverter getJaxbConverter() {
        if (jaxbConverter == null) {
            jaxbConverter = new XmlConverter();
        }
        return jaxbConverter;
    }
    public void setJaxbConverter(XmlConverter jaxbConverter) {
        this.jaxbConverter = jaxbConverter;
    }
    @Converter
    public JAXBSource toSource(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException {
        JAXBContext context = getJaxbContext(value);
        return new JAXBSource(context, value);
    }
    @Converter
    public Document toDocument(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException, ParserConfigurationException {
        JAXBContext context = getJaxbContext(value);
        Marshaller marshaller = context.createMarshaller();
        Document doc = getJaxbConverter().createDocument();
        marshaller.marshal(value, doc);
        return doc;
    }
    @Converter
    public static MessageType toMessageType(Exchange exchange) {
        return toMessageType(exchange.getIn());
    }
    @Converter
    public static MessageType toMessageType(Message in) {
        MessageType answer = new MessageType();
        answer.copyFrom(in);
        return answer;
    }
    private synchronized JAXBContext getJaxbContext(Object value) throws JAXBException {
        JAXBContext context = contexts.get(value.getClass());
        if (context == null) {
            context = createJaxbContext(value);
            contexts.put(value.getClass(), context);
        }
        return context;
    }
    private JAXBContext createJaxbContext(Object value) throws JAXBException {
        if (value == null) {
            throw new IllegalArgumentException(""Cannot convert from null value to JAXBSource"");
        }
        return JAXBContext.newInstance(value.getClass());
    }
}
"
org.apache.camel.component.mina.MinaProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ConnectFuture;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
import org.apache.mina.transport.socket.nio.SocketConnector;
/**
 * A {@link Producer} implementation for MINA
 *
 * @version $Revision$
 */
public class MinaProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(MinaProducer.class);
    private IoSession session;
    private MinaEndpoint endpoint;
    private CountDownLatch latch;
    private boolean lazySessionCreation;
    private long timeout;
    private IoConnector connector;
    private boolean sync;
    public MinaProducer(MinaEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        this.lazySessionCreation = endpoint.isLazySessionCreation();
        this.timeout = endpoint.getTimeout();
        this.sync = endpoint.isSync();
    }
    public void process(Exchange exchange) throws Exception {
        if (session == null && !lazySessionCreation) {
            throw new IllegalStateException(""Not started yet!"");
        }
        if (session == null || !session.isConnected()) {
            openConnection();
        }
        // set the exchange encoding property
        if (endpoint.getCharsetName() != null) {
            exchange.setProperty(Exchange.CHARSET_NAME, endpoint.getCharsetName());
        }
        Object body = MinaPayloadHelper.getIn(endpoint, exchange);
        if (body == null) {
            LOG.warn(""No payload to send for exchange: "" + exchange);
            return; // exit early since nothing to write
        }
        // if sync is true then we should also wait for a response (synchronous mode)
        if (sync) {
            // only initialize latch if we should get a response
            latch = new CountDownLatch(1);
            // reset handler if we expect a response
            ResponseHandler handler = (ResponseHandler) session.getHandler();
            handler.reset();
        }
        // write the body
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Writing body: "" + body);
        }
        MinaHelper.writeBody(session, body, exchange);
        if (sync) {
            // wait for response, consider timeout
            LOG.debug(""Waiting for response"");
            latch.await(timeout, TimeUnit.MILLISECONDS);
            if (latch.getCount() == 1) {
                throw new ExchangeTimedOutException(exchange, timeout);
            }
            // did we get a response
            ResponseHandler handler = (ResponseHandler) session.getHandler();
            if (handler.getCause() != null) {
                throw new CamelExchangeException(""Response Handler had an exception"", exchange, handler.getCause());
            } else if (!handler.isMessageRecieved()) {
                // no message received
                throw new CamelExchangeException(""No response received from remote server: "" + endpoint.getEndpointUri(), exchange);
            } else {
                // set the result on either IN or OUT on the original exchange depending on its pattern
                if (ExchangeHelper.isOutCapable(exchange)) {
                    MinaPayloadHelper.setOut(exchange, handler.getMessage());
                } else {
                    MinaPayloadHelper.setIn(exchange, handler.getMessage());
                }
            }
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (!lazySessionCreation) {
            openConnection();
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Stopping connector: "" + connector + "" at address: "" + endpoint.getAddress());
        }
        if (connector instanceof SocketConnector) {
            // Change the worker timeout to 0 second to make the I/O thread quit soon when there's no connection to manage.
            // Default worker timeout is 60 sec and therefore the client using MinaProducer can not terminate the JVM
            // asap but must wait for the timeout to happend, so to speed this up we set the timeout to 0.
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Setting SocketConnector WorkerTimeout=0 to force MINA stopping its resources faster"");
            }
            ((SocketConnector) connector).setWorkerTimeout(0);
        }
        if (session != null) {
            session.close();
        }
        super.doStop();
    }
    private void openConnection() {
        SocketAddress address = endpoint.getAddress();
        connector = endpoint.getConnector();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating connector to address: "" + address + "" using connector: "" + connector + "" timeout: "" + timeout + "" millis."");
        }
        IoHandler ioHandler = new ResponseHandler(endpoint);
        // connect and wait until the connection is established
        ConnectFuture future = connector.connect(address, ioHandler, endpoint.getConnectorConfig());
        future.join();
        session = future.getSession();
    }
    /**
     * Handles response from session writes
     *
     * @author <a href=""mailto:karajdaar@gmail.com"">nsandhu</a>
     */
    private final class ResponseHandler extends IoHandlerAdapter {
        private MinaEndpoint endpoint;
        private Object message;
        private Throwable cause;
        private boolean messageRecieved;
        private ResponseHandler(MinaEndpoint endpoint) {
            this.endpoint = endpoint;
        }
        public void reset() {
            this.message = null;
            this.cause = null;
            this.messageRecieved = false;
        }
        @Override
        public void messageReceived(IoSession ioSession, Object message) throws Exception {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Message received: "" + message);
            }
            this.message = message;
            messageRecieved = true;
            cause = null;
            countDown();
        }
        protected void countDown() {
            CountDownLatch downLatch = latch;
            if (downLatch != null) {
                downLatch.countDown();
            }
        }
        @Override
        public void sessionClosed(IoSession session) throws Exception {
            if (sync && message == null) {
                // sync=true (InOut mode) so we expected a message as reply but did not get one before the session is closed
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Session closed but no message received from address: "" + this.endpoint.getAddress());
                }
                // session was closed but no message received. This could be because the remote server had an internal error
                // and could not return a response. We should count down to stop waiting for a response
                countDown();
            }
        }
        @Override
        public void exceptionCaught(IoSession ioSession, Throwable cause) {
            LOG.error(""Exception on receiving message from address: "" + this.endpoint.getAddress()
                    + "" using connector: "" + this.endpoint.getConnector(), cause);
            this.message = null;
            this.messageRecieved = false;
            this.cause = cause;
            if (ioSession != null) {
                ioSession.close();
            }
        }
        public Throwable getCause() {
            return this.cause;
        }
        public Object getMessage() {
            return this.message;
        }
        public boolean isMessageRecieved() {
            return messageRecieved;
        }
    }
}
"
org.apache.camel.builder.xml.StringResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link StringResultHandler}
 *
 * @version $Revision$
 */
public class StringResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StringResultHandler();
    }
}
"
org.apache.camel.component.jms.JmsMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.File;
import java.util.Map;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Topic;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a {@link org.apache.camel.Message} for working with JMS
 *
 * @version $Revision:520964 $
 */
public class JmsMessage extends DefaultMessage {
    private static final transient Log LOG = LogFactory.getLog(JmsMessage.class);
    private Message jmsMessage;
    private JmsBinding binding;
    public JmsMessage() {
    }
    public JmsMessage(Message jmsMessage) {
        setJmsMessage(jmsMessage);
    }
    public JmsMessage(Message jmsMessage, JmsBinding binding) {
        this(jmsMessage);
        setBinding(binding);
    }
    @Override
    public String toString() {
        if (jmsMessage != null) {
            return ""JmsMessage: "" + jmsMessage;
        } else {
            return ""JmsMessage: "" + getBody();
        }
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        boolean copyMessageId = true;
        if (that instanceof JmsMessage) {
            JmsMessage thatMessage = (JmsMessage) that;
            this.jmsMessage = thatMessage.jmsMessage;
            if (this.jmsMessage != null) {
                // for performance lets not copy the messageID if we are a JMS message
                copyMessageId = false;
            }
        }
        if (copyMessageId) {
            setMessageId(that.getMessageId());
        }
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
    }
    /**
     * Returns the underlying JMS message
     */
    public Message getJmsMessage() {
        return jmsMessage;
    }
    public JmsBinding getBinding() {
        if (binding == null) {
            Exchange exchange = getExchange();
            if (exchange instanceof JmsExchange) {
                JmsExchange jmsExchange = (JmsExchange) exchange;
                return jmsExchange.getBinding();
            } else {
                return new JmsBinding();
            }
        }
        return binding;
    }
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public void setJmsMessage(Message jmsMessage) {
        try {
            setMessageId(jmsMessage.getJMSMessageID());
        } catch (JMSException e) {
            LOG.warn(""Unable to retrieve JMSMessageID from JMS Message"", e);
        }
        this.jmsMessage = jmsMessage;
    }
    public Object getHeader(String name) {
        Object answer = null;
        // we will exclude using JMS-prefixed headers here to avoid strangeness with some JMS providers
        // e.g. ActiveMQ returns the String not the Destination type for ""JMSReplyTo""!
        if (jmsMessage != null && !name.startsWith(""JMS"")) {
            try {
                answer = jmsMessage.getObjectProperty(name);
            } catch (JMSException e) {
                throw new MessagePropertyAccessException(name, e);
            }
        }
        if (answer == null) {
            answer = super.getHeader(name);
        }
        return answer;
    }
    @Override
    public JmsMessage newInstance() {
        return new JmsMessage();
    }
    /**
     * Returns true if a new JMS message instance should be created to send to the next component
     */
    public boolean shouldCreateNewMessage() {
        return super.hasPopulatedHeaders();
    }
    @Override
    protected Object createBody() {
        if (jmsMessage != null) {
            return getBinding().extractBodyFromJms(getExchange(), jmsMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (jmsMessage != null && map != null) {
            map.putAll(getBinding().extractHeadersFromJms(jmsMessage));
        }
    }
    @Override
    protected String createMessageId() {
        if (jmsMessage == null) {
            LOG.info(""The jmsMessage is not set yet, call the super's createMessageId"");
            return super.createMessageId();
        }
        try {
            String id = getDestinationAsString(jmsMessage.getJMSDestination()) + jmsMessage.getJMSMessageID();
            return getSanitizedString(id);
        } catch (JMSException e) {
            LOG.error(""Failed to get message id from message "" + jmsMessage, e);
            return super.createMessageId();
        }
    }
    private String getDestinationAsString(Destination destination) throws JMSException {
        String result;
        if (destination == null) {
            result = ""null destination!"" + File.separator;
        } else if (destination instanceof Topic) {
            result = ""topic"" + File.separator + ((Topic) destination).getTopicName() + File.separator;
        } else {
            result = ""queue"" + File.separator + ((Queue) destination).getQueueName() + File.separator;
        }
        return result;
    }
    private String getSanitizedString(Object value) {
        return value != null ? value.toString().replaceAll(""[^a-zA-Z0-9\\.\\_\\-]"", ""_"") : """";
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
public final class SpringIntegrationHelper {
    private SpringIntegrationHelper() {
        // Helper class
    }
    public static void checkSpringBeanInstance(Object bean, String name) {
        if (bean == null) {
            throw new IllegalArgumentException(""Can't find the bean: "" + name + "" from the Spring context"");
        }
    }
}
"
org.apache.camel.ExchangeProperty,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * Represents an instance and a type safe registry of well known Camel Exchange properties.
 * <p/>
 * <b>Usage pattern:</b>
 * <br/>In your code register a property that you wish to pass via Camel Exchange:
 * <pre>
 *      public static final ExchangeProperty<Boolean> myProperty =
 *            new ExchangeProperty<Boolean>(""myProperty"", ""org.apache.myproject.mypackage.myproperty"", Boolean.class);
 *
 *  Then in your code set this property's value:
 *      myProperty.set(exchange, Boolean.TRUE);
 *
 *  Check the value of this property where required:
 *      ExchangeProperty<?> property = ExchangeProperty.get(""myProperty"");
 *      if (property != null && property.get(exchange) == Boolean.TRUE) {
 *           // do your thing ...
 *       }
 *  Or
 *      Boolean value = myProperty.get(exchange);
 *      if (value == Boolean.TRUE) {
 *          // do your thing
 *      }
 *
 *  When your code no longer requires this property then deregister it:
 *      ExchangeProperty.deregister(myProperty);
 *  Or
 *      ExchangeProperty.deregister(""myProperty"");
 *  </pre>
 *
 *  <b>Note:</b> that if ExchangeProperty instance get or set methods are used then type checks
 *  of property's value are performed and a runtime exception can be thrown if type
 *  safety is violated.
 */
public class ExchangeProperty<T> {
    private static final List<ExchangeProperty<?>> VALUES =
        new ArrayList<ExchangeProperty<?>>();
    private static final Map<String, ExchangeProperty<?>> LITERAL_MAP =
        new HashMap<String, ExchangeProperty<?>>();
    private static final Map<String, ExchangeProperty<?>> NAME_MAP =
        new HashMap<String, ExchangeProperty<?>>();
    private final String literal;
    private final String name;
    private final Class<T> type;
    public ExchangeProperty(String literal, String name, Class<T> type) {
        this.literal = literal;
        this.name = name;
        this.type = type;
        register(this);
    }
    public String literal() {
        return literal;
    }
    public String name() {
        return name;
    }
    public Class<T> type() {
        return type;
    }
    public T get(Exchange exchange) {
        return exchange.getProperty(name, type);
    }
    public static ExchangeProperty<?> get(String literal) {
        return LITERAL_MAP.get(literal);
    }
    public static ExchangeProperty<?> getByName(String name) {
        return NAME_MAP.get(name);
    }
    public T set(Exchange exchange, T value) {
        T oldValue = get(exchange);
        exchange.setProperty(name, value);
        return oldValue;
    }
    public T remove(Exchange exchange) {
        T oldValue = get(exchange);
        exchange.removeProperty(name);
        return oldValue;
    }
    @Override
    public String toString() {
        return type().getCanonicalName() + "" "" + name + "" ("" + literal() + "")"";
    }
    public static synchronized void register(ExchangeProperty<?> property) {
        ExchangeProperty<?> existingProperty = LITERAL_MAP.get(property.literal());
        if (existingProperty != null && existingProperty != property) {
            throw new RuntimeCamelException(""An Exchange Property '"" + property.literal()
                    + ""' has already been registered; its traits are: "" + existingProperty.toString());
        }
        VALUES.add(property);
        LITERAL_MAP.put(property.literal(), property);
        NAME_MAP.put(property.name(), property);
    }
    public static synchronized void deregister(ExchangeProperty<?> property) {
        if (property != null) {
            VALUES.remove(property);
            LITERAL_MAP.remove(property.literal());
            NAME_MAP.put(property.name(), property);
        }
    }
    public static synchronized void deregister(String literal) {
        ExchangeProperty<?> property = LITERAL_MAP.get(literal);
        if (property != null) {
            VALUES.remove(property);
            LITERAL_MAP.remove(property.literal());
            NAME_MAP.put(property.name(), property);
        }
    }
    public static synchronized ExchangeProperty<?>[] values() {
        return VALUES.toArray(new ExchangeProperty[0]);
    }
}"
org.apache.camel.component.http.helper.LoadingByteArrayOutputStream,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http.helper;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
/**
 * Subclass of ByteArrayOutputStream that allows creation of a
 * ByteArrayInputStream directly without creating a copy of the byte[].
 *
 * Also, on ""toByteArray()"" it truncates it's buffer to the current size
 * and returns the new buffer directly.  Multiple calls to toByteArray()
 * will return the exact same byte[] unless a write is called in between.
 *
 * Note: once the InputStream is created, the output stream should
 * no longer be used.  In particular, make sure not to call reset()
 * and then write as that may overwrite the data that the InputStream
 * is using.
 */
public class LoadingByteArrayOutputStream extends ByteArrayOutputStream {
    public LoadingByteArrayOutputStream() {
        super(1024);
    }
    public LoadingByteArrayOutputStream(int i) {
        super(i);
    }
    public ByteArrayInputStream createInputStream() {
        return new ByteArrayInputStream(buf, 0, count);
    }
    public byte[] toByteArray() {
        if (count != buf.length) {
            buf = super.toByteArray();
        }
        return buf;
    }
}"
org.apache.camel.dataformat.xstream.JsonDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.xstream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import javax.xml.stream.XMLStreamException;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.QNameMap;
import com.thoughtworks.xstream.io.xml.StaxReader;
import com.thoughtworks.xstream.io.xml.StaxWriter;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.codehaus.jettison.mapped.MappedXMLInputFactory;
import org.codehaus.jettison.mapped.MappedXMLOutputFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using XStream and Jettison to marshal to and from JSON
 *
 * @version $Revision$
 */
public class JsonDataFormat extends AbstractXStreamWrapper {
    private final MappedXMLOutputFactory mof;
    private final MappedXMLInputFactory mif;
    public JsonDataFormat() {
        final HashMap nstjsons = new HashMap();
        mof = new MappedXMLOutputFactory(nstjsons);
        mif = new MappedXMLInputFactory(nstjsons);
    }
    protected HierarchicalStreamWriter createHierarchicalStreamWriter(Exchange exchange, Object body, OutputStream stream) throws XMLStreamException {        
        return new StaxWriter(new QNameMap(), mof.createXMLStreamWriter(stream));
    }
    protected HierarchicalStreamReader createHierarchicalStreamReader(Exchange exchange, InputStream stream) throws XMLStreamException {        
        return new StaxReader(new QNameMap(), mif.createXMLStreamReader(stream));
    }
}
"
org.apache.camel.component.xquery.XQueryAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.lang.annotation.Annotation;
import net.sf.saxon.functions.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.component.bean.DefaultAnnotationExpressionFactory;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
/**
 * @version $Revision$
 */
public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
    @Override
    public Expression createExpression(CamelContext camelContext, Annotation annotation,
                                       LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String xQuery = getExpressionFromAnnotation(annotation);
        XQueryBuilder builder = XQueryBuilder.xquery(xQuery);
        if (annotation instanceof XQuery) {
            XQuery xQueryAnnotation = (XQuery)annotation;
            NamespacePrefix[] namespaces = xQueryAnnotation.namespaces();
            if (namespaces != null) {
                for (NamespacePrefix namespacePrefix : namespaces) {
                    // TODO
                    // builder = builder.namespace(namespacePrefix.prefix(),
                    // namespacePrefix.uri());
                }
            }
        }
        if (expressionReturnType.isAssignableFrom(String.class)) {
            builder.setResultsFormat(ResultFormat.String);
        } else if (expressionReturnType.isAssignableFrom(Collection.class)) {
            builder.setResultsFormat(ResultFormat.List);
        }
        return builder;
    }
}
"
org.apache.camel.converter.jaxp.BytesSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class which provides a JAXP {@link javax.xml.transform.Source Source} from a byte[]
 * which can be read as many times as required.
 *
 * @version $Revision$
 */
public class BytesSource extends StreamSource {
    private byte[] data;
    public BytesSource(byte[] data) {
        ObjectHelper.notNull(data, ""data"");
        this.data = data;
    }
    public BytesSource(byte[] data, String systemId) {
        ObjectHelper.notNull(data, ""data"");
        this.data = data;
        setSystemId(systemId);
    }
    public InputStream getInputStream() {
        return new ByteArrayInputStream(data);
    }
    public Reader getReader() {
        return new InputStreamReader(getInputStream());
    }
    public byte[] getData() {
        return data;
    }
    public String toString() {
        return ""BytesSource["" + new String(data) + ""]"";
    }
}
"
org.apache.camel.component.cxf.interceptors.FaultOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapFault;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingOperationInfo;
public class FaultOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(FaultOutInterceptor.class);
    public FaultOutInterceptor() {
        super(Phase.PREPARE_SEND);
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        // To walk around the FaultOutInterceptor NPE issue of CXF 2.0.4
        checkBindingOperationInfor(message);
        Throwable ex = message.getContent(Throwable.class);
        if (ex != null) {
            if (!(ex instanceof Fault)) {
                ex = new Fault(ex);
            }
            if (message instanceof XMLMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating XMLFault"");
                }
                ex = XMLFault.createFault((Fault)ex);
            } else if (message instanceof SoapMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating SoapFault"");
                }
                SoapMessage sm = (SoapMessage)message;
                ex = SoapFault.createFault((Fault)ex, sm.getVersion());
            }
            message.setContent(Throwable.class, ex);
        }
    }
    /*
     * This method is used to walk around the NPE issue of CXF 2.0.4
     * org.apache.cxf.interceptor.FaultOutInterceptor.
     * This issue was fixed in CXF 2.0.5 and CXF 2.1, when we upgrade CXF to that version
     * we could remove this method from the interceptor
     */
    private void checkBindingOperationInfor(Message message) {
        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);
        if (bop == null) {
            bop = new FakeBindingOperationInfo();
            message.getExchange().put(BindingOperationInfo.class, bop);
        }
    }
}
"
org.apache.camel.component.bean.ProxyHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.Proxy;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
/**
 * A helper class for creating proxies which delegate to Camel
 *
 * @version $Revision$
 */
public final class ProxyHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProxyHelper() {
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     */
    @SuppressWarnings(""unchecked"")
    public static Object createProxyObject(Endpoint endpoint, Producer producer, ClassLoader classLoader, Class[] interfaces, MethodInfoCache methodCache) {
        return Proxy.newProxyInstance(classLoader, interfaces.clone(), new CamelInvocationHandler(endpoint, producer, methodCache));
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class[] interfaces, MethodInfoCache methodCache) throws Exception {
        return (T) createProxyObject(endpoint, endpoint.createProducer(), cl, interfaces, methodCache);
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class<T>... interfaceClasses) throws Exception {
        return (T) createProxy(endpoint, cl, interfaceClasses, createMethodInfoCache(endpoint));
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, Class<T>... interfaceClasses) throws Exception {
        return (T) createProxy(endpoint, getClassLoader(interfaceClasses), interfaceClasses);
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, Producer producer, Class<T>... interfaceClasses) throws Exception {
        return (T) createProxyObject(endpoint, producer, getClassLoader(interfaceClasses), interfaceClasses, createMethodInfoCache(endpoint));
    }
    /**
     * Returns the class loader of the first interface or throws {@link IllegalArgumentException} if there are no interfaces specified
     *
     * @return the class loader
     */
    protected static ClassLoader getClassLoader(Class... interfaces) {
        if (interfaces == null || interfaces.length < 1) {
            throw new IllegalArgumentException(""You must provide at least 1 interface class."");
        }
        return interfaces[0].getClassLoader();
    }
    protected static MethodInfoCache createMethodInfoCache(Endpoint endpoint) {
        return new MethodInfoCache(endpoint.getCamelContext());
    }
}
"
org.apache.camel.component.jmx.JMXConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import javax.management.NotificationListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * Creates an JMXExchange after getting a JMX Notification
 * 
 * @version $Revision$
 */
public class JMXConsumer extends DefaultConsumer implements NotificationListener {
    private JMXEndpoint jmxEndpoint;
    public JMXConsumer(JMXEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.jmxEndpoint = endpoint;
    }
    public void handleNotification(Notification notification, Object handback) {
        try {
            getProcessor().process(jmxEndpoint.createExchange(notification));
        } catch (Throwable e) {
            handleException(e);
        }
    }
}
"
org.apache.camel.component.atom.EntryFilter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
/**
 * Filter used by the {@link org.apache.camel.component.atom.AtomEntryPollingConsumer} to filter entries
 * from the feed.
 *
 * @version $Revision$
 */
public interface EntryFilter {
    /**
     * Tests to be used as filtering the feed for only entries of interest, such as only new entries, etc.
     *
     * @param endpoint  the endpoint
     * @param feed      the Atom feed
     * @param entry     the given entry to filter
     * @return  <tt>true</tt> to include the entry, <ff>false</tt> to skip it
     */
    boolean isValidEntry(AtomEndpoint endpoint, Document<Feed> feed, Entry entry);
}
"
org.apache.camel.bam.ProcessBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.processor.ActivityMonitorEngine;
import org.apache.camel.bam.processor.JpaBamProcessor;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A builder of a process definition
 * 
 * @version $Revision$
 */
public abstract class ProcessBuilder extends RouteBuilder {
    private static int processCounter;
    private JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    private final String processName;
    private List<ActivityBuilder> activityBuilders = new ArrayList<ActivityBuilder>();
    private Class entityType = ProcessInstance.class;
    private ProcessRules processRules = new ProcessRules();
    private ProcessDefinition processDefinition;
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this(jpaTemplate, transactionTemplate, createProcessName());
    }
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate, String processName) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
        this.processName = processName;
    }
    protected static synchronized String createProcessName() {
        return ""Process-"" + (++processCounter);
    }
    public ActivityBuilder activity(String endpointUri) {
        return activity(endpoint(endpointUri));
    }
    public ActivityBuilder activity(Endpoint endpoint) {
        ActivityBuilder answer = new ActivityBuilder(this, endpoint);
        activityBuilders.add(answer);
        return answer;
    }
    /**
     * Sets the process entity type used to perform state management
     */
    public ProcessBuilder entityType(Class entityType) {
        this.entityType = entityType;
        return this;
    }
    public Processor createActivityProcessor(ActivityBuilder activityBuilder) {
        notNull(jpaTemplate, ""jpaTemplate"");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                processRules.setProcessDefinition(getProcessDefinition());
            }
        });
        return new JpaBamProcessor(getTransactionTemplate(), getJpaTemplate(), activityBuilder.getCorrelationExpression(), activityBuilder.getActivityRules(), getEntityType());
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<ActivityBuilder> getActivityBuilders() {
        return activityBuilders;
    }
    public Class getEntityType() {
        return entityType;
    }
    public JpaTemplate getJpaTemplate() {
        return jpaTemplate;
    }
    public void setJpaTemplate(JpaTemplate jpaTemplate) {
        this.jpaTemplate = jpaTemplate;
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public String getProcessName() {
        return processName;
    }
    public ProcessDefinition getProcessDefinition() {
        if (processDefinition == null) {
            processDefinition = findOrCreateProcessDefinition();
        }
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void populateRoutes(List<Route> routes) throws Exception {
        boolean first = true;
        for (ActivityBuilder builder : activityBuilders) {
            Route route = builder.createRoute();
            if (first) {
                route.getServices().add(new ActivityMonitorEngine(getJpaTemplate(), getTransactionTemplate(), getProcessRules()));
                first = false;
            }
            routes.add(route);
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public ActivityDefinition findOrCreateActivityDefinition(String activityName) {
        ProcessDefinition definition = getProcessDefinition();
        List<ActivityDefinition> list = jpaTemplate.find(""select x from "" + ActivityDefinition.class.getName() + "" x where x.processDefinition = ?1 and x.name = ?2"", definition, activityName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ActivityDefinition answer = new ActivityDefinition();
            answer.setName(activityName);
            answer.setProcessDefinition(ProcessDefinition.getRefreshedProcessDefinition(jpaTemplate, definition));
            jpaTemplate.persist(answer);
            return answer;
        }
    }
    protected ProcessDefinition findOrCreateProcessDefinition() {
        List<ProcessDefinition> list = jpaTemplate.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            jpaTemplate.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.sql.SqlProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.impl.DefaultProducer;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.RowMapperResultSetExtractor;
public class SqlProducer extends DefaultProducer {
    public static final String UPDATE_COUNT = ""org.apache.camel.sql.update-count"";
    private String query;
    private JdbcTemplate jdbcTemplate;
    public SqlProducer(SqlEndpoint endpoint, String query, JdbcTemplate jdbcTemplate) {
        super(endpoint);
        this.jdbcTemplate = jdbcTemplate;
        this.query = query;
    }
    public void process(final Exchange exchange) throws Exception {
        jdbcTemplate.execute(query, new PreparedStatementCallback() {
            public Object doInPreparedStatement(PreparedStatement ps) throws SQLException,
                DataAccessException {
                int argNumber = 1;
                try {
                    Iterator<?> iterator = exchange.getIn().getBody(Iterator.class);
                    while (iterator != null && iterator.hasNext()) {
                        ps.setObject(argNumber++, iterator.next());
                    }
                } catch (NoTypeConversionAvailableException e) {
                    // ignored - assumed no parameters have to be used
                }
                // number of parameters must match
                int expected = ps.getParameterMetaData().getParameterCount();
                if (argNumber - 1 != expected) {
                    throw new SQLException(""Number of parameters mismatch. Expected: "" + expected + "", was:"" + (argNumber - 1));
                }
                boolean isResultSet = ps.execute();
                if (isResultSet) {
                    RowMapperResultSetExtractor mapper = new RowMapperResultSetExtractor(new ColumnMapRowMapper());
                    List<?> result = (List<?>) mapper.extractData(ps.getResultSet());
                    exchange.getOut().setBody(result);
                    // preserve headers
                    exchange.getOut().setHeaders(exchange.getIn().getHeaders());
                } else {
                    exchange.getIn().setHeader(UPDATE_COUNT, ps.getUpdateCount());
                }
                // data is set on exchange so return null
                return null;
            }
        });
    }
}
"
org.apache.camel.PollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents a <a
 * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
 * Consumer</a> where the caller polls for messages when it is ready.
 * 
 * @version $Revision$
 */
public interface PollingConsumer<E extends Exchange> extends Consumer<E> {
    /**
     * Waits until a message is available and then returns it. Warning that this
     * method could block indefinitely if no messages are available.
     * <p/>
     * Will return <tt>null</tt> if the consumer is not started
     * 
     * @return the message exchange received.
     */
    E receive();
    /**
     * Attempts to receive a message exchange immediately without waiting and
     * returning <tt>null</tt> if a message exchange is not available yet.
     * 
     * @return the message exchange if one is immediately available otherwise
     *         <tt>null</tt>
     */
    E receiveNoWait();
    /**
     * Attempts to receive a message exchange, waiting up to the given timeout
     * to expire if a message is not yet available
     * 
     * @param timeout the amount of time in milliseconds to wait for a message
     *                before timing out and returning <tt>null</tt>
     * 
     * @return the message exchange if one iwas available within the timeout
     *         period, or <tt>null</tt> if the timeout expired
     */
    E receive(long timeout);
}
"
org.apache.camel.component.xquery.ResultFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
/**
 * @version $Revision$
 */
public enum ResultFormat {
    Bytes, BytesSource, DOM, DOMSource, List, String, StringSource
}
"
org.apache.camel.Processor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/processor.html"">processor</a> is
 * used to implement the 
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">
 * Event Driven Consumer</a> and 
 * <a href=""http://activemq.apache.org/camel/message-translator.html"">
 * Message Translator</a> patterns and to process message exchanges.
 * 
 * @version $Revision$
 */
public interface Processor {
    /**
     * Processes the message exchange
     * 
     * @throws Exception if an internal processing error has occurred.
     */
    void process(Exchange exchange) throws Exception;
}
"
org.apache.camel.dataformat.tagsoup.TidyMarkupDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.tagsoup;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.Map.Entry;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.sax.SAXSource;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.ccil.cowan.tagsoup.HTMLSchema;
import org.ccil.cowan.tagsoup.Parser;
import org.ccil.cowan.tagsoup.Schema;
import org.ccil.cowan.tagsoup.XMLWriter;
/**
 * Dataformat for TidyMarkup (aka Well formed HTML in XML form.. may or may not
 * be XHTML) This dataformat is intended to convert bad HTML from a site (or
 * file) into a well formed HTML document which can then be sent to XSLT or
 * xpath'ed on.
 * 
 */
public class TidyMarkupDataFormat implements DataFormat {
    /*
     * Our Logger
     */
    private static final transient Log LOG = LogFactory.getLog(TidyMarkupDataFormat.class);
    private static final String NO = ""no"";
    private static final String YES = ""yes"";
    private static final String XML = ""xml"";
    /**
     * When returning a String, do we omit the XML ?
     */
    private boolean isOmitXmlDeclaration;
    /**
     * String or Node to return
     */
    private Class dataObjectType;
    /**
     * What is the default output format ?
     */
    private String method;
    /**
     * The Schema which we are parsing (default HTMLSchema)
     */
    private Schema parsingSchema;
    /**
     * User supplied Parser features
     * <p>
     * {@link http://home.ccil.org/~cowan/XML/tagsoup/#properties}
     * {@link http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html}
     * </p>
     */
    private Map<String, Boolean> parserFeatures;
    /**
     * User supplied Parser properties
     * <p>
     * {@link http://home.ccil.org/~cowan/XML/tagsoup/#properties}
     * {@link http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html}
     * </p>
     */
    private Map<String, Object> parserPropeties;
    /**
     * Unsupported operation. We cannot create ugly HTML.
     */
    public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws Exception {
        throw new CamelException(""Marshalling from Well Formed HTML to ugly HTML is not supported.""
                + "" Only unmarshal is supported"");
    }
    /**
     * Unmarshal the data
     * 
     * @throws Exception
     */
    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {
        ObjectHelper.notNull(dataObjectType, ""dataObjectType"", this);
        if (dataObjectType.isAssignableFrom(Node.class)) {
            return asNodeTidyMarkup(inputStream);
        } else if (dataObjectType.isAssignableFrom(String.class)) {
            return asStringTidyMarkup(inputStream);
        } else {
            throw new IllegalArgumentException(""The return type ["" + dataObjectType.getCanonicalName()
                    + ""] is unsupported"");
        }
    }
    /**
     * Return the tidy markup as a string
     * 
     * @param inputStream
     * @return String of XML
     * @throws CamelException
     */
    public String asStringTidyMarkup(InputStream inputStream) throws CamelException {
        XMLReader parser = createTagSoupParser();
        StringWriter w = new StringWriter();
        parser.setContentHandler(createContentHandler(w));
        try {
            parser.parse(new InputSource(inputStream));
            return w.toString();
        } catch (Exception e) {
            throw new CamelException(""Failed to convert the HTML to tidy Markup"", e);
        } finally {
            try {
                inputStream.close();
            } catch (Exception e) {
                LOG.warn(""Failed to close the inputStream"");
            }
        }
    }
    /**
     * Return the HTML Markup as an {@link org.w3c.dom.Node}
     * 
     * @param inputStream
     *            The input Stream to convert
     * @return org.w3c.dom.Node The HTML Markup as a DOM Node
     * @throws CamelException
     */
    public Node asNodeTidyMarkup(InputStream inputStream) throws CamelException {
        XMLReader parser = createTagSoupParser();
        StringWriter w = new StringWriter();
        parser.setContentHandler(createContentHandler(w));
        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            DOMResult result = new DOMResult();
            transformer.transform(new SAXSource(parser, new InputSource(inputStream)), result);
            return result.getNode();
        } catch (Exception e) {
            throw new CamelException(""Failed to convert the HTML to tidy Markup"", e);
        }
    }
    /**
     * Create the tagSoup Parser
     * 
     * @return
     * @throws CamelException
     */
    protected XMLReader createTagSoupParser() throws CamelException {
        XMLReader reader = new Parser();
        try {
            reader.setFeature(Parser.namespacesFeature, false);
            reader.setFeature(Parser.namespacePrefixesFeature, false);
            /*
             * set each parser feature that the user may have supplied.
             * http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html
             * http://home.ccil.org/~cowan/XML/tagsoup/#properties
             */
            if (getParserFeatures() != null) {
                for (Entry<String, Boolean> e : getParserFeatures().entrySet()) {
                    reader.setFeature(e.getKey(), e.getValue());
                }
            }
            /*
             * set each parser feature that the user may have supplied. {@link
             * http://home.ccil.org/~cowan/XML/tagsoup/#properties}
             */
            if (getParserPropeties() != null) {
                for (Entry<String, Object> e : getParserPropeties().entrySet()) {
                    reader.setProperty(e.getKey(), e.getValue());
                }
            }
            /*
             * default the schema to HTML
             */
            if (this.getParsingSchema() != null) {
                reader.setProperty(Parser.schemaProperty, getParsingSchema());
            }
        } catch (Exception e) {
            throw new IllegalArgumentException(""Problem configuring the parser"", e);
        }
        return reader;
    }
    /**
     * @param htmlSchema
     *            the htmlSchema to set
     */
    public void setParsingSchema(Schema schema) {
        this.parsingSchema = schema;
    }
    /**
     * @return the htmlSchema
     */
    public Schema getParsingSchema() {
        if (parsingSchema == null) {
            this.parsingSchema = new HTMLSchema();
        }
        return parsingSchema;
    }
    protected ContentHandler createContentHandler(Writer w) {
        XMLWriter xmlWriter = new XMLWriter(w);
        // we might need to expose more than these two but that is pretty good
        // for a default well formed Html generator
        if (getMethod() != null) {
            xmlWriter.setOutputProperty(XMLWriter.METHOD, getMethod());
        } else {
            xmlWriter.setOutputProperty(XMLWriter.METHOD, XML);
        }
        if (isOmitXmlDeclaration) {
            xmlWriter.setOutputProperty(XMLWriter.OMIT_XML_DECLARATION, YES);
        } else {
            xmlWriter.setOutputProperty(XMLWriter.OMIT_XML_DECLARATION, NO);
        }
        return xmlWriter;
    }
    /**
     * @param parserFeatures
     *            the parserFeatures to set
     */
    public void setParserFeatures(Map<String, Boolean> parserFeatures) {
        this.parserFeatures = parserFeatures;
    }
    /**
     * @return the parserFeatures
     */
    public Map<String, Boolean> getParserFeatures() {
        return parserFeatures;
    }
    /**
     * @param parserPropeties
     *            the parserPropeties to set
     */
    public void setParserPropeties(Map<String, Object> parserPropeties) {
        this.parserPropeties = parserPropeties;
    }
    /**
     * @return the parserPropeties
     */
    public Map<String, Object> getParserPropeties() {
        return parserPropeties;
    }
    /**
     * @param method
     *            the method to set
     */
    public void setMethod(String method) {
        this.method = method;
    }
    /**
     * @return the method
     */
    public String getMethod() {
        return method;
    }
    /**
     * @return the dataObjectType
     */
    public Class getDataObjectType() {
        return dataObjectType;
    }
    /**
     * @param dataObjectType
     *            the dataObjectType to set
     */
    public void setDataObjectType(Class dataObjectType) {
        this.dataObjectType = dataObjectType;
    }
}
"
org.apache.camel.component.file.remote.RemoteFileConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.net.URI;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.language.simple.FileLanguage;
import org.apache.commons.net.ftp.FTPClientConfig;
public class RemoteFileConfiguration implements Cloneable {
    private String protocol;
    private String username;
    private String host;
    private int port;
    private String password;
    private String file;
    private boolean binary;
    private boolean directory = true;
    private FTPClientConfig ftpClientConfig;
    private Expression expression;
    private boolean passiveMode;
    private String knownHosts;
    private String privateKeyFile;
    private String privateKeyFilePassphrase;
    public RemoteFileConfiguration() {
    }
    public RemoteFileConfiguration(URI uri) {
        configure(uri);
    }
    public RemoteFileConfiguration copy() {
        try {
            return (RemoteFileConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String toString() {
        return remoteServerInformation() + ""/"" + file;
    }
    /**
     * Returns human readable server information for logging purpose
     */
    public String remoteServerInformation() {
        return protocol + ""://"" + (username != null ? username : ""anonymous"") + ""@"" + host + "":"" + port;
    }
    public void configure(URI uri) {
        setProtocol(uri.getScheme());
        setDefaultPort();
        setUsername(uri.getUserInfo());
        setHost(uri.getHost());
        setPort(uri.getPort());
        setFile(uri.getPath());
    }
    protected void setDefaultPort() {
        if (""ftp"".equalsIgnoreCase(protocol)) {
            setPort(21);
        } else if (""sftp"".equalsIgnoreCase(protocol)) {
            setPort(22);
        }
    }
    public String getFile() {
        return file;
    }
    public void setFile(String file) {
        // Avoid accidentally putting everything in root on
        // servers that expose the full filesystem
        if (file.startsWith(""/"")) {
            file = file.substring(1);
        }
        this.file = file;
    }
    public String getKnownHosts() {
        return knownHosts;
    }
    public void setKnownHosts(String knownHosts) {
        this.knownHosts = knownHosts;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        if (port != -1) { // use default
            this.port = port;
        }
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public boolean isBinary() {
        return binary;
    }
    public void setBinary(boolean binary) {
        this.binary = binary;
    }
    public boolean isDirectory() {
        return directory;
    }
    public void setDirectory(boolean directory) {
        this.directory = directory;
    }
    public FTPClientConfig getFtpClientConfig() {
        return ftpClientConfig;
    }
    public void setFtpClientConfig(FTPClientConfig ftpClientConfig) {
        this.ftpClientConfig = ftpClientConfig;
    }
    public Expression getExpression() {
        return expression;
    }
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
    /**
     * Sets the expression based on {@link org.apache.camel.language.simple.FileLanguage}
     */
    public void setExpression(String fileLanguageExpression) {
        this.expression = FileLanguage.file(fileLanguageExpression);
    }
    public boolean isPassiveMode() {
        return passiveMode;
    }
    /**
     * Sets passive mode connections.
     * <br/>
     * Default is active mode connections.
     */
    public void setPassiveMode(boolean passiveMode) {
        this.passiveMode = passiveMode;
    }
    public String getPrivateKeyFile() {
        return privateKeyFile;
    }
    public void setPrivateKeyFile(String privateKeyFile) {
        this.privateKeyFile = privateKeyFile;
    }
    public String getPrivateKeyFilePassphrase() {
        return privateKeyFilePassphrase;
    }
    public void setPrivateKeyFilePassphrase(String privateKeyFilePassphrase) {
        this.privateKeyFilePassphrase = privateKeyFilePassphrase;
    }
}
"
org.apache.camel.component.jhc.JhcServerEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.concurrent.ThreadFactory;
import javax.net.ssl.SSLContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.impl.nio.DefaultServerIOEventDispatch;
import org.apache.http.impl.nio.reactor.DefaultListeningIOReactor;
import org.apache.http.impl.nio.reactor.SSLServerIOEventDispatch;
import org.apache.http.nio.reactor.IOEventDispatch;
import org.apache.http.nio.reactor.IOReactorException;
import org.apache.http.nio.reactor.ListeningIOReactor;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.HttpRequestHandlerRegistry;
public class JhcServerEngine {
    private static final Log LOG = LogFactory.getLog(JhcServerEngine.class);
    private final HttpParams params;
    private int port;
    private String protocol;
    private int nbThreads = 2;
    private ListeningIOReactor ioReactor;
    private ThreadFactory threadFactory;
    private Thread runner;
    private SSLContext sslContext;
    private AsyncBufferingHttpServiceHandler serviceHandler;
    private HttpRequestHandlerRegistry handlerRegistry;
    private boolean isStarted;
    private int referenceCounter;
    JhcServerEngine(HttpParams params, int port, String protocol) {
        this.params = params;
        serviceHandler = new AsyncBufferingHttpServiceHandler(params);
        handlerRegistry = new HttpRequestHandlerRegistry();
        serviceHandler.setHandlerResolver(handlerRegistry);
        this.port = port;
        this.protocol = protocol;
    }
    public int getPort() {
        return port;
    }
    public String getProtocol() {
        return this.protocol;
    }
    public void setSslContext(SSLContext sslContext) {
        this.sslContext = sslContext;
    }
    public SSLContext getSslContext() {
        return this.sslContext;
    }
    public synchronized void register(String pattern, AsyncHttpRequestHandler handler) {
        handlerRegistry.register(pattern, handler);
        referenceCounter++;
    }
    public synchronized void unregister(String pattern) {
        handlerRegistry.unregister(pattern);
        referenceCounter--;
    }
    public int getReferenceCounter() {
        return referenceCounter;
    }
    public boolean isStarted() {
        return isStarted;
    }
    public void start() throws IOReactorException {
        final SocketAddress addr = new InetSocketAddress(port);
        ioReactor = new DefaultListeningIOReactor(nbThreads, threadFactory, params);
        final IOEventDispatch ioEventDispatch;
        if (""https"".equals(protocol)) {
            ioEventDispatch = new SSLServerIOEventDispatch(serviceHandler, sslContext, params);
        } else {
            ioEventDispatch = new DefaultServerIOEventDispatch(serviceHandler, params);
        }
        runner = new Thread() {
            public void run() {
                try {
                    ioReactor.listen(addr);
                    isStarted = true;
                    ioReactor.execute(ioEventDispatch);
                } catch (InterruptedIOException ex) {
                    LOG.info(""Interrupted"");
                } catch (IOException e) {
                    LOG.warn(""I/O error: "" + e.getMessage());
                }
                LOG.debug(""Shutdown"");
            }
        };
        runner.start();
    }
    public void stop() throws IOException {
        LOG.debug(""Stopping the jhc ioReactor "");
        ioReactor.shutdown();
        LOG.debug(""Waiting the runner"");
        try {
            runner.join();
        } catch (InterruptedException e) {
            //do nothing here
        }
        isStarted = false;
        LOG.debug(""Runner stopped"");
    }
}
"
org.apache.camel.osgi.CamelNamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.util.HashSet;
import java.util.Set;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
public class CamelNamespaceHandler extends org.apache.camel.spring.handler.CamelNamespaceHandler {
    public void init() {
        super.init();
        registerParser(""camelContext"", new CamelContextBeanDefinitionParser(CamelContextFactoryBean.class));
    }
    protected JAXBContext createJaxbContext() throws JAXBException {
        StringBuilder packages = new StringBuilder();
        for (Class cl : getJaxbPackages()) {
            if (packages.length() > 0) {
                packages.append("":"");
            }
            packages.append(cl.getName().substring(0, cl.getName().lastIndexOf('.')));
        }
        return JAXBContext.newInstance(packages.toString(), getClass().getClassLoader());
    }
    protected Set<Class> getJaxbPackages() {
        Set<Class> classes = new HashSet<Class>();
        classes.add(org.apache.camel.osgi.CamelContextFactoryBean.class);
        classes.add(org.apache.camel.spring.CamelContextFactoryBean.class);
        classes.add(org.apache.camel.model.RouteType.class);
        classes.add(org.apache.camel.model.config.StreamResequencerConfig.class);
        classes.add(org.apache.camel.model.dataformat.DataFormatType.class);
        classes.add(org.apache.camel.model.language.ExpressionType.class);
        classes.add(org.apache.camel.model.loadbalancer.LoadBalancerType.class);
        return classes;
    }
}
"
org.apache.camel.component.cxf.util.NullConduitSelector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import org.apache.cxf.endpoint.ConduitSelector;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
public class NullConduitSelector implements ConduitSelector {
    private Endpoint endpoint;
    private NullConduit nullConduit;
    public NullConduitSelector() {
        nullConduit = new NullConduit();
    }
    public void complete(Exchange exchange) {
        //do nothing here
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void prepare(Message message) {
        //do nothing here
    }
    public Conduit selectConduit(Message message) {
        return nullConduit;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
}
"
org.apache.camel.component.cxf.util.NullConduit,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
public class NullConduit implements Conduit {
    public void close() {
    }
    public void close(Message message) throws IOException {
        OutputStream outputStream = message.getContent(OutputStream.class);
        if (outputStream != null) {
            outputStream.close();
        }
    }
    public Destination getBackChannel() {
        return null;
    }
    public EndpointReferenceType getTarget() {
        return null;
    }
    public void prepare(Message message) throws IOException {
        CachedOutputStream outputStream = new CachedOutputStream();
        message.setContent(OutputStream.class, outputStream);
    }
    public void setMessageObserver(MessageObserver observer) {
    }
}
"
org.apache.camel.builder.script.Ruby,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://ruby-lang.org/"">Ruby</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""jruby"")
public @interface Ruby {
    String value();
}"
org.apache.camel.Service,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents the core lifecycle API for POJOs which can be started and stopped
 * 
 * @version $Revision$
 */
public interface Service {
    /**
     * Starts the service
     * 
     * @throws Exception
     */
    void start() throws Exception;
    /**
     * Stops the service
     * 
     * @throws Exception
     */
    void stop() throws Exception;
}
"
org.apache.camel.component.restlet.DefaultRestletBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.restlet;
import java.io.IOException;
import java.util.Map;
import javax.xml.transform.dom.DOMSource;
import org.apache.camel.Exchange;
import org.apache.camel.HeaderFilterStrategyAware;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.restlet.data.ChallengeResponse;
import org.restlet.data.ChallengeScheme;
import org.restlet.data.Form;
import org.restlet.data.MediaType;
import org.restlet.data.Parameter;
import org.restlet.data.Request;
import org.restlet.data.Response;
import org.restlet.data.Status;
/**
 * Default Restlet binding implementation
 *
 * @version $Revision$
 */
public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrategyAware {
    private static final Log LOG = LogFactory.getLog(DefaultRestletBinding.class);
    private HeaderFilterStrategy headerFilterStrategy;
    /**
     * Populate Camel message from Restlet request
     * 
     * @param request message to be copied from
     * @param exchange to be populated
     * @throws Exception 
     */
    public void populateExchangeFromRestletRequest(Request request,
            Exchange exchange) throws Exception {
        Message inMessage = exchange.getIn();
        // extract headers from restlet 
        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {
            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), 
                    entry.getValue())) {
                inMessage.setHeader(entry.getKey(), entry.getValue());
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Populate exchange from Restlet request header: "" 
                            + entry.getKey() + "" value: "" + entry.getValue());
                }
            }
        }
        // copy query string to header
        String query = request.getResourceRef().getQuery();
        if (null != query) {
            inMessage.setHeader(RestletConstants.QUERY_STRING, query);
        }
        if (!request.isEntityAvailable()) {
            return;
        }
        Form form = new Form(request.getEntity());
        if (form != null) {
            for (Map.Entry<String, String> entry : form.getValuesMap().entrySet()) {
                // extract body added to the form as the key which has null value
                if (entry.getValue() == null) {
                    inMessage.setBody(entry.getKey());
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Populate exchange from Restlet request body: "" + entry.getValue());
                    }
                } else {
                    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), 
                            entry.getValue())) {
                        inMessage.setHeader(entry.getKey(), entry.getValue());
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Populate exchange from Restlet request user header: "" 
                                    + entry.getKey() + "" value: "" + entry.getValue());
                        }
                    }
                }
            }
        }        
    }   
    /**
     * Populate Restlet Request from Camel message
     * 
     * @param request to be populated
     * @param exchange message to be copied from
     */
    public void populateRestletRequestFromExchange(Request request,
            Exchange exchange) {
        request.setReferrerRef(""camel-restlet"");
        String body = exchange.getIn().getBody(String.class);
        Form form = new Form();
        // add the body as the key in the form with null value
        form.add(body, null);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Populate Restlet request from exchange body: "" + body);
        }
        // login and password are filtered by header filter strategy
        String login = (String) exchange.getIn().getHeader(RestletConstants.LOGIN);
        String password = (String) exchange.getIn().getHeader(RestletConstants.PASSWORD);
        if (login != null && password != null) {
            ChallengeResponse authentication = new ChallengeResponse(
                    ChallengeScheme.HTTP_BASIC, login, password);
            request.setChallengeResponse(authentication);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Basic HTTP Authentication has been applied"");
            }
        }
        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {
            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), 
                    entry.getValue())) {
                if (entry.getKey().startsWith(""org.restlet."")) {
                    // put the org.restlet headers in attributes
                    request.getAttributes().put(entry.getKey(), entry.getValue());
                } else {
                    // put the user stuff in the form
                    form.add(entry.getKey(), entry.getValue().toString());   
                }
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Populate Restlet request from exchange header: "" 
                            + entry.getKey() + "" value: "" + entry.getValue());
                }
            }
        }
        request.setEntity(form.getWebRepresentation());
    }
    /**
     * Populate Restlet request from Camel message
     *  
     * @param exchange message to be copied from 
     * @param response to be populated
     */
    public void populateRestletResponseFromExchange(Exchange exchange,
            Response response) {
        // get content type
        Message out = exchange.getOut();
        MediaType mediaType = out.getHeader(RestletConstants.MEDIA_TYPE, MediaType.class);
        if (mediaType == null) {
            Object body = out.getBody();
            mediaType = MediaType.TEXT_PLAIN;
            if (body instanceof String) {
                mediaType = MediaType.TEXT_PLAIN;
            } else if (body instanceof StringSource || body instanceof DOMSource) {
                mediaType = MediaType.TEXT_XML;
            }
        }
        // get response code
        Integer responseCode = out.getHeader(RestletConstants.RESPONSE_CODE, Integer.class);
        if (responseCode != null) {
            response.setStatus(Status.valueOf(responseCode));
        }
        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {
            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), 
                    entry.getValue())) {
                response.getAttributes().put(entry.getKey(), entry.getValue());
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Populate Restlet response from exchange header: "" 
                            + entry.getKey() + "" value: "" + entry.getValue());
                }
            }
        }
        String text = out.getBody(String.class);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Populate Restlet response from exchange body: "" + text);
        }
        response.setEntity(text, mediaType);
    }
    /**
     * Populate Camel message from Restlet response
     * 
     * @param exchange to be populated
     * @param response message to be copied from
     * @throws IOException 
     */
    public void populateExchangeFromRestletResponse(Exchange exchange,
            Response response) throws IOException {
        for (Map.Entry<String, Object> entry : response.getAttributes().entrySet()) {
            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), 
                    entry.getValue())) {
                exchange.getOut().setHeader(entry.getKey(), entry.getValue());
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Populate exchange from Restlet response header: "" 
                            + entry.getKey() + "" value: "" + entry.getValue());
                }
            }
        }
        String text = response.getEntity().getText();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Populate exchange from Restlet response: "" + text);
        }
        if (exchange.getPattern().isOutCapable()) {
            exchange.getOut().setBody(text);
        } else {
            throw new RuntimeCamelException(""Exchange is incapable of receiving response: "" 
                    + exchange);
        }
    }
    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }
    public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {
        headerFilterStrategy = strategy;
    }
}
"
org.apache.camel.builder.sql.SqlBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.util.ObjectHelper;
import org.josql.Query;
import org.josql.QueryExecutionException;
import org.josql.QueryParseException;
/**
 * A builder of SQL {@link org.apache.camel.Expression} and
 * {@link org.apache.camel.Predicate} implementations
 * 
 * @version $Revision$
 */
public class SqlBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private Query query;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public SqlBuilder(Query query) {
        this.query = query;
    }
    public Object evaluate(E exchange) {
        return evaluateQuery(exchange);
    }
    public boolean matches(E exchange) {
        List list = evaluateQuery(exchange);
        return matches(exchange, list);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        List list = evaluateQuery(exchange);
        if (!matches(exchange, list)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as found "" + list);
        }
    }
    // Builder API
    // -----------------------------------------------------------------------
    /**
     * Creates a new builder for the given SQL query string
     * 
     * @param sql the SQL query to perform
     * @return a new builder
     * @throws QueryParseException if there is an issue with the SQL
     */
    public static <E extends Exchange> SqlBuilder<E> sql(String sql) throws QueryParseException {
        Query q = new Query();
        q.parse(sql);
        return new SqlBuilder(q);
    }
    /**
     * Adds the variable value to be used by the SQL query
     */
    public SqlBuilder<E> variable(String name, Object value) {
        getVariables().put(name, value);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public Map<String, Object> getVariables() {
        return variables;
    }
    public void setVariables(Map<String, Object> properties) {
        this.variables = properties;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected boolean matches(E exchange, List list) {
        return ObjectHelper.matches(list);
    }
    protected List evaluateQuery(E exchange) {
        configureQuery(exchange);
        Message in = exchange.getIn();
        List list = in.getBody(List.class);
        if (list == null) {
            list = Collections.singletonList(in.getBody());
        }
        try {
            return query.execute(list).getResults();
        } catch (QueryExecutionException e) {
            throw new RuntimeExpressionException(e);
        }
    }
    protected void configureQuery(E exchange) {
        // lets pass in the headers as variables that the SQL can use
        addVariables(exchange.getProperties());
        addVariables(exchange.getIn().getHeaders());
        addVariables(getVariables());
        query.setVariable(""exchange"", exchange);
        query.setVariable(""in"", exchange.getIn());
        query.setVariable(""out"", exchange.getOut());
    }
    protected void addVariables(Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            query.setVariable(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.component.quartz.StatefulCamelJob,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.SchedulerContext;
import org.quartz.SchedulerException;
import org.quartz.StatefulJob;
/**
 * @author martin.gilday
 *
 */
public class StatefulCamelJob implements StatefulJob {
    /* (non-Javadoc)
     * @see org.quartz.Job#execute(org.quartz.JobExecutionContext)
     */
    public void execute(final JobExecutionContext context) throws JobExecutionException {
        SchedulerContext schedulerContext;
        try {
            schedulerContext = context.getScheduler().getContext();
        } catch (SchedulerException e) {
            throw new JobExecutionException(""Failed to obtain scheduler context for job "" + context.getJobDetail().getName());
        }
        CamelContext camelContext = (CamelContext) schedulerContext.get(QuartzEndpoint.CONTEXT_KEY);
        String endpointUri = (String) context.getJobDetail().getJobDataMap().get(QuartzEndpoint.ENDPOINT_KEY);
        QuartzEndpoint quartzEndpoint =    (QuartzEndpoint) camelContext.getEndpoint(endpointUri);
        quartzEndpoint.onJobExecute(context);
    }
}
"
org.apache.camel.converter.jaxb.PropertyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""property"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class PropertyType {
    @XmlAttribute
    private String key;
    @XmlAnyElement(lax = true)
    private Object value;
    public String getKey() {
        return key;
    }
    public void setKey(String key) {
        this.key = key;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}"
org.apache.camel.component.xslt.XsltComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xslt;
import java.util.Map;
import javax.xml.transform.TransformerFactory;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.xml.XsltBuilder;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.util.ObjectHelper;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/xslt.html"">XSLT Component</a>
 * for performing XSLT transforms of messages
 *
 * @version $Revision$
 */
public class XsltComponent extends ResourceBasedComponent {
    private XmlConverter xmlConverter;
    public XmlConverter getXmlConverter() {
        return xmlConverter;
    }
    public void setXmlConverter(XmlConverter xmlConverter) {
        this.xmlConverter = xmlConverter;
    }
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Resource resource = resolveMandatoryResource(remaining);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        XsltBuilder xslt = newInstance(XsltBuilder.class);
        // lets allow the converter to be configured
        XmlConverter converter = null;
        String converterName = getAndRemoveParameter(parameters, ""converter"", String.class);        
        if (converterName != null) {
            converter = mandatoryLookup(converterName, XmlConverter.class);
        }
        if (converter == null) {
            converter = getXmlConverter();
        }
        if (converter != null) {
            xslt.setConverter(converter);
        }
        String transformerFactoryClassName = getAndRemoveParameter(parameters, ""transformerFactoryClass"", String.class);
        TransformerFactory factory = null;
        if (transformerFactoryClassName != null) {
            Class factoryClass = ObjectHelper.loadClass(transformerFactoryClassName);
            if (factoryClass != null) {
                factory = (TransformerFactory) newInstance(factoryClass);
            } else {
                log.warn(""Can't find the TransformerFactoryClass with the class name "" + transformerFactoryClassName);
            }
        }
        String transformerFactoryName = getAndRemoveParameter(parameters, ""transformerFactory"", String.class);        
        if (transformerFactoryName != null) {
            factory = mandatoryLookup(transformerFactoryName, TransformerFactory.class);
        }
        if (factory != null) {
            xslt.getConverter().setTransformerFactory(factory);
        }
        xslt.setTransformerInputStream(resource.getInputStream());
        configureXslt(xslt, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, xslt);
    }
    protected void configureXslt(XsltBuilder xslt, String uri, String remaining, Map parameters) throws Exception {
        setProperties(xslt, parameters);
    }
}
"
org.apache.camel.osgi.Activator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;
import org.springframework.osgi.util.BundleDelegatingClassLoader;
public class Activator implements BundleActivator, SynchronousBundleListener {
    public static final String META_INF_TYPE_CONVERTER = ""META-INF/services/org/apache/camel/TypeConverter"";
    public static final String META_INF_COMPONENT = ""META-INF/services/org/apache/camel/component/"";
    public static final String META_INF_LANGUAGE = ""META-INF/services/org/apache/camel/language/"";
    private static final transient Log LOG = LogFactory.getLog(Activator.class);    
    private static final Map<String, ComponentEntry> COMPONENTS = new HashMap<String, ComponentEntry>();
    private static final Map<URL, TypeConverterEntry> TYPE_CONVERTERS = new HashMap<URL, TypeConverterEntry>();
    private static final Map<String, ComponentEntry> LANGUAGES = new HashMap<String, ComponentEntry>();
    private static Bundle bundle;
    private class ComponentEntry {
        Bundle bundle;
        String path;
        String name;
        Class type;
    }
    private class TypeConverterEntry {
        Bundle bundle;
        URL resource;
        Set<String> converterPackages;
    }
    public void bundleChanged(BundleEvent event) {
        try {
            Bundle bundle = event.getBundle();
            if (event.getType() == BundleEvent.RESOLVED) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Bundle resolved: "" + bundle.getSymbolicName());
                }
                mayBeAddComponentAndLanguageFor(bundle);                
                mayBeAddTypeConverterFor(bundle);
            } else if (event.getType() == BundleEvent.UNRESOLVED) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Bundle unresolved: "" + bundle.getSymbolicName());
                }
                mayBeRemoveComponentAndLanguageFor(bundle);                
                mayBeRemoveTypeConverterFor(bundle);
            }
        } catch (Throwable e) {
            LOG.fatal(""Exception handing bundle changed event"", e);
        }
    }
    protected synchronized void addComponentEntry(String entryPath, Bundle bundle, Map<String, ComponentEntry> entries) {
        Enumeration e = bundle.getEntryPaths(entryPath);
        if (e != null) {
            while (e.hasMoreElements()) {
                String path = (String)e.nextElement();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Found entry: "" + path + "" in bundle "" + bundle.getSymbolicName());
                }
                ComponentEntry entry = new ComponentEntry();
                entry.bundle = bundle;
                entry.path = path;
                entry.name = path.substring(path.lastIndexOf(""/"") + 1);
                entries.put(entry.name, entry);
            }
        }
    }
    protected void mayBeAddComponentAndLanguageFor(Bundle bundle) {        
        addComponentEntry(META_INF_COMPONENT, bundle, COMPONENTS);
        addComponentEntry(META_INF_LANGUAGE, bundle, LANGUAGES);
    }
    protected synchronized void mayBeAddTypeConverterFor(Bundle bundle) {
        try {
            Enumeration e = bundle.getResources(META_INF_TYPE_CONVERTER);
            if (e != null) {
                while (e.hasMoreElements()) {
                    URL resource = (URL)e.nextElement();
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Found entry: "" + resource + "" in bundle "" + bundle.getSymbolicName());
                    }
                    TypeConverterEntry entry = new TypeConverterEntry();
                    entry.bundle = bundle;                   
                    entry.resource = resource;
                    entry.converterPackages = getConverterPackages(resource);
                    TYPE_CONVERTERS.put(resource, entry);
                }
            }
        } catch (IOException ignore) {
            // can't find the resource
        }
    }
    protected void mayBeRemoveComponentAndLanguageFor(Bundle bundle) {
        removeComponentEntry(bundle, COMPONENTS);
        removeComponentEntry(bundle, LANGUAGES);        
    }
    protected void removeComponentEntry(Bundle bundle, Map<String, ComponentEntry> entries) {
        ComponentEntry[] entriesArray = entries.values().toArray(new ComponentEntry[0]);
        for (ComponentEntry entry : entriesArray) {        
            if (entry.bundle == bundle) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Removing entry: "" + entry.path + "" in bundle "" + bundle.getSymbolicName());
                }
                entries.remove(entry.name);
            }
        }        
    }
    protected synchronized void mayBeRemoveTypeConverterFor(Bundle bundle) {
        TypeConverterEntry[] entriesArray = TYPE_CONVERTERS.values().toArray(new TypeConverterEntry[0]);
        for (TypeConverterEntry entry : entriesArray) {
            if (entry.bundle == bundle) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Removing entry: "" + entry.resource + "" in bundle "" + bundle.getSymbolicName());
                }
                COMPONENTS.remove(entry.resource);
            }
        }
    }
    public void start(BundleContext context) throws Exception {
        bundle = context.getBundle();       
        context.addBundleListener(this);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""checking existing bundles"");
        }
        for (Bundle bundle : context.getBundles()) {
            if (bundle.getState() == Bundle.RESOLVED || bundle.getState() == Bundle.STARTING
                || bundle.getState() == Bundle.ACTIVE || bundle.getState() == Bundle.STOPPING) {
                mayBeAddComponentAndLanguageFor(bundle);
                mayBeAddTypeConverterFor(bundle);
            }
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""actived"");
        }
    }    
    public void stop(BundleContext context) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""removing the components of existing bundles"");
        }
        for (Bundle bundle : context.getBundles()) {
            if (bundle.getState() == Bundle.RESOLVED || bundle.getState() == Bundle.STARTING 
                || bundle.getState() == Bundle.ACTIVE || bundle.getState() == Bundle.STOPPING) {
                mayBeRemoveComponentAndLanguageFor(bundle);
                mayBeRemoveTypeConverterFor(bundle);
            }
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""stopped"");
        }
    }
    protected Set<String> getConverterPackages(URL resource) {
        Set<String> packages = new HashSet<String>();
        if (resource != null) {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader(new InputStreamReader(resource.openStream()));
                while (true) {
                    String line = reader.readLine();
                    if (line == null) {
                        break;
                    }
                    line = line.trim();
                    if (line.startsWith(""#"") || line.length() == 0) {
                        continue;
                    }
                    tokenize(packages, line);
                }
            } catch (Exception ignore) {
                // Do nothing here
            } finally {
                if (reader != null) {
                    ObjectHelper.close(reader, null, LOG);
                }
            }
        }
        return packages;
    }
    protected void tokenize(Set<String> packages, String line) {
        StringTokenizer iter = new StringTokenizer(line, "","");
        while (iter.hasMoreTokens()) {
            String name = iter.nextToken().trim();
            if (name.length() > 0) {
                packages.add(name);
            }
        }
    }
    protected static Bundle getBundle() {
        return bundle;
    }
    protected static synchronized String[] findTypeConverterPackageNames() {
        Set<String> packages = new HashSet<String>();
        for (TypeConverterEntry entry : TYPE_CONVERTERS.values()) {
            for (String packageName : entry.converterPackages) {
                packages.add(packageName);
            }
        }
        return packages.toArray(new String[packages.size()]);
    }
    public static synchronized Class getComponent(String name) throws Exception {
        return getClassFromEntries(name, COMPONENTS);
    }
    public static synchronized Class getLanguage(String name) throws Exception {
        return getClassFromEntries(name, LANGUAGES);
    }
    protected static synchronized Class getClassFromEntries(String name, Map<String, ComponentEntry> entries) throws Exception {
        ComponentEntry entry = entries.get(name);
        if (entry == null) {
            return null;
        }
        if (entry.type == null) {
            URL url = entry.bundle.getEntry(entry.path);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""The entry "" + name + ""'s url is"" + url);
            }
            // lets load the file
            Properties properties = new Properties();
            BufferedInputStream reader = null;
            try {
                reader = new BufferedInputStream(url.openStream());
                properties.load(reader);
            } finally {
                try {
                    if (reader != null) {
                        reader.close();
                    }
                } catch (Exception ignore) {
                }
            }
            String classname = (String)properties.get(""class"");
            ClassLoader loader = BundleDelegatingClassLoader.createBundleClassLoaderFor(entry.bundle);
            entry.type = loader.loadClass(classname);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found entry: "" + name + "" via type: "" + entry.type.getName());
        }
        return entry.type;
    }
}
"
org.apache.camel.Body,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being the body of an inbound {@link Message}
 * 
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Body {
}
"
org.apache.camel.bam.processor.ActivityMonitorEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.util.Date;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A timer engine to monitor for expired activities and perform whatever actions
 * are required.
 * 
 * @version $Revision$
 */
public class ActivityMonitorEngine extends ServiceSupport implements Runnable {
    private static final Log LOG = LogFactory.getLog(ActivityMonitorEngine.class);
    private JpaTemplate template;
    private TransactionTemplate transactionTemplate;
    private ProcessRules rules;
    private int escalateLevel;
    private long windowMillis = 1000L;
    private Thread thread;
    private boolean useLocking;
    public ActivityMonitorEngine(JpaTemplate template, TransactionTemplate transactionTemplate, ProcessRules rules) {
        this.template = template;
        this.transactionTemplate = transactionTemplate;
        this.rules = rules;
    }
    public boolean isUseLocking() {
        return useLocking;
    }
    public void setUseLocking(boolean useLocking) {
        this.useLocking = useLocking;
    }
    public void run() {
        LOG.debug(""Starting to poll for timeout events"");
        while (!isStopped()) {
            try {
                long now = System.currentTimeMillis();
                long nextPoll = now + windowMillis;
                final Date timeNow = new Date(now);
                transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                    protected void doInTransactionWithoutResult(TransactionStatus status) {
                        //List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.escalationLevel = ?1 and x.timeOverdue < ?2"", escalateLevel, timeNow);
                        List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.timeOverdue < ?1"", timeNow);
                        for (ActivityState activityState : list) {
                            fireExpiredEvent(activityState);
                        }
                    }
                });
                long timeToSleep = nextPoll - System.currentTimeMillis();
                if (timeToSleep > 0) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Sleeping for "" + timeToSleep + "" millis"");
                    }
                    try {
                        Thread.sleep(timeToSleep);
                    } catch (InterruptedException e) {
                        LOG.debug(""Caught: "" + e, e);
                    }
                }
            } catch (Exception e) {
                LOG.error(""Caught: "" + e, e);
            }
        }
    }
    protected void fireExpiredEvent(final ActivityState activityState) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Trying to fire expiration of: "" + activityState);
        }
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                // lets try lock the object first
                if (isUseLocking()) {
                    LOG.info(""Attempting to lock: "" + activityState);
                    entityManager.lock(activityState, LockModeType.WRITE);
                    LOG.info(""Grabbed lock: "" + activityState);
                }
                try {
                    rules.processExpired(activityState);
                } catch (Exception e) {
                    LOG.error(""Failed to process expiration of: "" + activityState + "". Reason: "" + e, e);
                }
                activityState.setTimeOverdue(null);
                //activityState.setEscalationLevel(escalateLevel + 1);
                return null;
            }
        });
    }
    protected void doStart() throws Exception {
        rules.start();
        thread = new Thread(this, ""ActivityMonitorEngine"");
        thread.start();
    }
    protected void doStop() throws Exception {
        if (thread != null) {
            thread = null;
        }
        rules.stop();
    }
}
"
org.apache.camel.Expression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An <a href=""http://activemq.apache.org/camel/expression.html"">expression</a>
 * provides a plugin strategy for evaluating expressions on a message exchange to support things like
 * <a href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting languages</a>,
 * <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well
 * as any arbitrary Java expression.
 *
 *
 * @version $Revision$
 */
public interface Expression<E extends Exchange> {
    /**
     * Returns the value of the expression on the given exchange
     *
     * @param exchange the message exchange on which to evaluate the expression
     * @return the value of the expression
     */
    Object evaluate(E exchange);
}
"
org.apache.camel.converter.NIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some core java.nio based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class NIOConverter {
    private static final transient Log LOG = LogFactory.getLog(NIOConverter.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private NIOConverter() {
    }
    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        return buffer.array();
    }
    @Converter
    public static String toString(ByteBuffer buffer, Exchange exchange) {
        return IOConverter.toString(buffer.array(), exchange);
    }
    @Converter
    public static ByteBuffer toByteBuffer(byte[] data) {
        return ByteBuffer.wrap(data);
    }
    @Converter
    public static ByteBuffer toByteBuffer(File file) throws IOException {
        InputStream in = null;
        try {
            byte[] buf = new byte[(int)file.length()];
            in = new BufferedInputStream(new FileInputStream(file));
            int sizeLeft = (int)file.length();
            int offset = 0;
            while (sizeLeft > 0) {
                int readSize = in.read(buf, offset, sizeLeft);
                sizeLeft -= readSize;
                offset += readSize;
            }
            return ByteBuffer.wrap(buf);
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
            } catch (IOException e) {
                LOG.warn(""Failed to close file stream: "" + file.getPath(), e);
            }
        }
    }
    @Converter
    public static ByteBuffer toByteBuffer(String value, Exchange exchange) {
        ByteBuffer buf = ByteBuffer.allocate(value.length());
        byte[] bytes = null;
        if (exchange != null) {
            String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
            if (charsetName != null) {
                try {
                    bytes = value.getBytes(charsetName);
                } catch (UnsupportedEncodingException e) {
                    LOG.warn(""Can't convert the byte to String with the charset "" + charsetName, e);
                }
            }
        }
        if (bytes == null) {
            bytes = value.getBytes();
        }
        buf.put(bytes);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Long value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putLong(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Float value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putFloat(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Double value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putDouble(value);
        return buf;
    }
    @Converter
    public static InputStream toInputStream(ByteBuffer bufferbuffer) {
        return IOConverter.toInputStream(toByteArray(bufferbuffer));
    }
}
"
org.apache.camel.component.jms.MessageJMSPropertyAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision$
 */
public class MessageJMSPropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessageJMSPropertyAccessException(JMSException e) {
        super(""Failed to access a JMS property: "" + e, e);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
public class RemoteFileBinding {
    public Object extractBodyFromOutputStream(RemoteFileExchange exchange, OutputStream outputStream) {
        return outputStream;
    }
}
"
org.apache.camel.component.jhc.BufferingHttpServiceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.http.ConnectionReuseStrategy;
import org.apache.http.HttpEntity;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.MethodNotSupportedException;
import org.apache.http.ProtocolException;
import org.apache.http.ProtocolVersion;
import org.apache.http.UnsupportedHttpVersionException;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.nio.ContentDecoder;
import org.apache.http.nio.ContentEncoder;
import org.apache.http.nio.NHttpServerConnection;
import org.apache.http.nio.NHttpServiceHandler;
import org.apache.http.nio.entity.ContentBufferEntity;
import org.apache.http.nio.entity.ContentOutputStream;
import org.apache.http.nio.protocol.NHttpServiceHandlerBase;
import org.apache.http.nio.util.ByteBufferAllocator;
import org.apache.http.nio.util.ContentInputBuffer;
import org.apache.http.nio.util.ContentOutputBuffer;
import org.apache.http.nio.util.HeapByteBufferAllocator;
import org.apache.http.nio.util.SimpleInputBuffer;
import org.apache.http.nio.util.SimpleOutputBuffer;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpProcessor;
import org.apache.http.protocol.HttpRequestHandler;
import org.apache.http.util.EncodingUtils;
/**
 * HTTP service handler implementation that buffers the content of HTTP messages
 * entirely in memory and processes HTTP requests on the main I/O thread.
 *
 * <p>This service handler should be used only when dealing with HTTP messages
 * that are known to be limited in length</p>
 *
 * @author <a href=""mailto:oleg at ural.ru"">Oleg Kalnichevski</a>
 *
 */
public class BufferingHttpServiceHandler extends NHttpServiceHandlerBase
                                         implements NHttpServiceHandler {
    public BufferingHttpServiceHandler(
            final HttpProcessor httpProcessor,
            final HttpResponseFactory responseFactory,
            final ConnectionReuseStrategy connStrategy,
            final ByteBufferAllocator allocator,
            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, allocator, params);
    }
    public BufferingHttpServiceHandler(
            final HttpProcessor httpProcessor,
            final HttpResponseFactory responseFactory,
            final ConnectionReuseStrategy connStrategy,
            final HttpParams params) {
        this(httpProcessor, responseFactory, connStrategy,
                new HeapByteBufferAllocator(), params);
    }
    public void connected(final NHttpServerConnection conn) {
        HttpContext context = conn.getContext();
        ServerConnState connState = new ServerConnState(allocator);
        context.setAttribute(CONN_STATE, connState);
        if (this.eventListener != null) {
            this.eventListener.connectionOpen(conn);
        }
    }
    public void requestReceived(final NHttpServerConnection conn) {
        HttpContext context = conn.getContext();
        HttpRequest request = conn.getHttpRequest();
        request.setParams(this.params);
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        // Update connection state
        connState.resetInput();
        connState.setRequest(request);
        connState.setInputState(ServerConnState.REQUEST_RECEIVED);
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        HttpResponse response;
        try {
            if (request instanceof HttpEntityEnclosingRequest) {
                if (((HttpEntityEnclosingRequest) request).expectContinue()) {
                    response = this.responseFactory.newHttpResponse(
                        ver, HttpStatus.SC_CONTINUE, context);
                    request.setParams(this.params);
                    if (this.expectationVerifier != null) {
                        try {
                            this.expectationVerifier.verify(request, response, context);
                        } catch (HttpException ex) {
                            response = this.responseFactory.newHttpResponse(
                                    HttpVersion.HTTP_1_0,
                                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                                    context);
                            request.setParams(this.params);
                            handleException(ex, response);
                        }
                    }
                    if (response.getStatusLine().getStatusCode() < 200) {
                        // Send 1xx response indicating the server expections
                        // have been met
                        conn.submitResponse(response);
                    } else {
                        // The request does not meet the server expections
                        conn.resetInput();
                        connState.resetInput();
                        sendResponse(conn, response);
                    }
                }
                // Request content is expected.
                // Wait until the request content is fully received
            } else {
                // No request content is expected.
                // Process request right away
                conn.suspendInput();
                processRequest(conn, request);
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void closed(final NHttpServerConnection conn) {
        if (this.eventListener != null) {
            this.eventListener.connectionClosed(conn);
        }
    }
    public void exception(final NHttpServerConnection conn, final HttpException httpex) {
        HttpContext context = conn.getContext();
        try {
            HttpResponse response = this.responseFactory.newHttpResponse(
                HttpVersion.HTTP_1_0, HttpStatus.SC_INTERNAL_SERVER_ERROR, context);
            response.setParams(this.params);
            handleException(httpex, response);
            response.setEntity(null);
            sendResponse(conn, response);
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {
        HttpContext context = conn.getContext();
        HttpRequest request = conn.getHttpRequest();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentInputBuffer buffer = connState.getInbuffer();
        // Update connection state
        connState.setInputState(ServerConnState.REQUEST_BODY_STREAM);
        try {
            buffer.consumeContent(decoder);
            if (decoder.isCompleted()) {
                // Request entity has been fully received
                connState.setInputState(ServerConnState.REQUEST_BODY_DONE);
                // Create a wrapper entity instead of the original one
                HttpEntityEnclosingRequest entityReq = (HttpEntityEnclosingRequest) request;
                if (entityReq.getEntity() != null) {
                    entityReq.setEntity(new ContentBufferEntity(
                            entityReq.getEntity(),
                            connState.getInbuffer()));
                }
                conn.suspendInput();
                processRequest(conn, request);
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void responseReady(final NHttpServerConnection conn) {
    }
    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {
        HttpContext context = conn.getContext();
        HttpResponse response = conn.getHttpResponse();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentOutputBuffer buffer = connState.getOutbuffer();
        // Update connection state
        connState.setOutputState(ServerConnState.RESPONSE_BODY_STREAM);
        try {
            buffer.produceContent(encoder);
            if (encoder.isCompleted()) {
                connState.setOutputState(ServerConnState.RESPONSE_BODY_DONE);
                connState.resetOutput();
                if (!this.connStrategy.keepAlive(response, context)) {
                    conn.close();
                } else {
                    conn.requestInput();
                }
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        }
    }
    protected void handleException(final HttpException ex, final HttpResponse response) {
        int code = HttpStatus.SC_INTERNAL_SERVER_ERROR;
        if (ex instanceof MethodNotSupportedException) {
            code = HttpStatus.SC_NOT_IMPLEMENTED;
        } else if (ex instanceof UnsupportedHttpVersionException) {
            code = HttpStatus.SC_HTTP_VERSION_NOT_SUPPORTED;
        } else if (ex instanceof ProtocolException) {
            code = HttpStatus.SC_BAD_REQUEST;
        }
        response.setStatusCode(code);
        byte[] msg = EncodingUtils.getAsciiBytes(ex.getMessage());
        ByteArrayEntity entity = new ByteArrayEntity(msg);
        entity.setContentType(""text/plain; charset=US-ASCII"");
        response.setEntity(entity);
    }
    protected void processRequest(
            final NHttpServerConnection conn,
            final HttpRequest request) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        HttpResponse response = this.responseFactory.newHttpResponse(
            ver, HttpStatus.SC_OK, conn.getContext());
        request.setParams(this.params);
        context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
        context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
        context.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
        try {
            this.httpProcessor.process(request, context);
            HttpRequestHandler handler = null;
            if (this.handlerResolver != null) {
                String requestURI = request.getRequestLine().getUri();
                handler = this.handlerResolver.lookup(requestURI);
            }
            if (handler != null) {
                handler.handle(request, response, context);
            } else {
                response.setStatusCode(HttpStatus.SC_NOT_IMPLEMENTED);
            }
        } catch (HttpException ex) {
            response = this.responseFactory.newHttpResponse(HttpVersion.HTTP_1_0,
                HttpStatus.SC_INTERNAL_SERVER_ERROR, context);
            request.setParams(this.params);
            handleException(ex, response);
        }
        sendResponse(conn, response);
    }
    protected void sendResponse(
            final NHttpServerConnection conn,
            final HttpResponse response) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentOutputBuffer buffer = connState.getOutbuffer();
        this.httpProcessor.process(response, context);
        if (!canResponseHaveBody(connState.getRequest(), response)) {
            response.setEntity(null);
        }
        conn.submitResponse(response);
        // Update connection state
        connState.setOutputState(ServerConnState.RESPONSE_SENT);
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            OutputStream outstream = new ContentOutputStream(buffer);
            entity.writeTo(outstream);
            outstream.flush();
            outstream.close();
        } else {
            connState.resetOutput();
            if (!this.connStrategy.keepAlive(response, context)) {
                conn.close();
            } else {
                conn.requestInput();
            }
        }
    }
    static class ServerConnState {
        public static final int READY                      = 0;
        public static final int REQUEST_RECEIVED           = 1;
        public static final int REQUEST_BODY_STREAM        = 2;
        public static final int REQUEST_BODY_DONE          = 4;
        public static final int RESPONSE_SENT              = 8;
        public static final int RESPONSE_BODY_STREAM       = 16;
        public static final int RESPONSE_BODY_DONE         = 32;
        private SimpleInputBuffer inbuffer;
        private ContentOutputBuffer outbuffer;
        private int inputState;
        private int outputState;
        private HttpRequest request;
        private final ByteBufferAllocator allocator;
        public ServerConnState(final ByteBufferAllocator allocator) {
            super();
            this.inputState = READY;
            this.outputState = READY;
            this.allocator = allocator;
        }
        public ContentInputBuffer getInbuffer() {
            if (this.inbuffer == null) {
                this.inbuffer = new SimpleInputBuffer(2048, allocator);
            }
            return this.inbuffer;
        }
        public ContentOutputBuffer getOutbuffer() {
            if (this.outbuffer == null) {
                this.outbuffer = new SimpleOutputBuffer(2048, allocator);
            }
            return this.outbuffer;
        }
        public int getInputState() {
            return this.inputState;
        }
        public void setInputState(int inputState) {
            this.inputState = inputState;
        }
        public int getOutputState() {
            return this.outputState;
        }
        public void setOutputState(int outputState) {
            this.outputState = outputState;
        }
        public HttpRequest getRequest() {
            return this.request;
        }
        public void setRequest(final HttpRequest request) {
            this.request = request;
        }
        public void resetInput() {
            this.inbuffer = null;
            this.request = null;
            this.inputState = READY;
        }
        public void resetOutput() {
            this.outbuffer = null;
            this.outputState = READY;
        }
    }
}
"
org.apache.camel.component.jmx.JMXExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * A {@link Exchange} for JMX notification
 *
 * @version $Revision$
 */
public class JMXExchange extends DefaultExchange {
    public JMXExchange(CamelContext camelContext, ExchangePattern pattern, Notification notification) {
        super(camelContext, pattern);
        setIn(new JMXMessage(notification));
    }
}
"
org.apache.camel.component.mail.MailUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.text.DateFormat;
import java.util.Date;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
/**
 * Mail utility class.
 * <p>
 * Parts of the code copied from Apache ServiceMix.
 *
 * @version $Revision$
 */
public final class MailUtils {
    public static final int DEFAULT_PORT_SMTP = 25;
    public static final int DEFAULT_PORT_SMTPS = 465;
    public static final int DEFAULT_PORT_POP3 = 110;
    public static final int DEFAULT_PORT_POP3S = 995;
    public static final int DEFAULT_PORT_NNTP = 119;
    public static final int DEFAULT_PORT_IMAP = 143;
    public static final int DEFAULT_PORT_IMAPS = 993;
    public static final String PROTOCOL_SMTP = ""smtp"";
    public static final String PROTOCOL_SMTPS = ""smtps"";
    public static final String PROTOCOL_POP3 = ""pop3"";
    public static final String PROTOCOL_POP3S = ""pop3s"";
    public static final String PROTOCOL_NNTP = ""nntp"";
    public static final String PROTOCOL_IMAP = ""imap"";
    public static final String PROTOCOL_IMAPS = ""imaps"";
    private MailUtils() {
    }
    /**
     * Returns the default port for a given protocol.
     * <p>
     * If a protocol could not successfully be determined the default port number for SMTP protocol is returned.
     *
     * @param protocol the protocol
     * @return the default port
     */
    public static int getDefaultPortForProtocol(final String protocol) {
        int port = DEFAULT_PORT_SMTP;
        if (protocol != null) {
            if (protocol.equalsIgnoreCase(PROTOCOL_IMAP)) {
                port = DEFAULT_PORT_IMAP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_IMAPS)) {
                port = DEFAULT_PORT_IMAPS;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_NNTP)) {
                port = DEFAULT_PORT_NNTP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_POP3)) {
                port = DEFAULT_PORT_POP3;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_POP3S)) {
                port = DEFAULT_PORT_POP3S;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_SMTP)) {
                port = DEFAULT_PORT_SMTP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_SMTPS)) {
                port = DEFAULT_PORT_SMTPS;
            } else {
                port = DEFAULT_PORT_SMTP;
            }
        }
        return port;
    }
    /**
     * Gets a log dump of the given message that can be used for tracing etc.
     *
     * @param message the Mail message
     * @return a log string with important fields dumped
     */
    public static String dumpMessage(Message message) {
        try {
            StringBuilder sb = new StringBuilder();
            int number = message.getMessageNumber();
            sb.append(""messageNumber=["").append(number).append(""]"");
            Address[] from = message.getFrom();
            if (from != null) {
                for (Address adr : from) {
                    sb.append("", from=["").append(adr).append(""]"");
                }
            }
            Address[] to = message.getRecipients(Message.RecipientType.TO);
            if (to != null) {
                for (Address adr : to) {
                    sb.append("", to=["").append(adr).append(""]"");
                }
            }
            String subject = message.getSubject();
            if (subject != null) {
                sb.append("", subject=["").append(subject).append(""]"");
            }
            Date sentDate = message.getSentDate();
            if (sentDate != null) {
                sb.append("", sentDate=["").append(DateFormat.getDateTimeInstance().format(sentDate)).append(""]"");
            }
            Date receivedDate = message.getReceivedDate();
            if (receivedDate != null) {
                sb.append("", receivedDate=["").append(DateFormat.getDateTimeInstance().format(receivedDate)).append(""]"");
            }
            return sb.toString();
        } catch (MessagingException e) {
            // ignore the error and just return tostring 
            return message.toString();
        }
    }
}
"
org.apache.camel.component.uface.swing.SwingBrowser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import java.awt.*;
import javax.swing.*;
import org.apache.camel.component.uface.UFaceBrowser;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spring.Main;
import org.ufacekit.ui.UIComposite;
import org.ufacekit.ui.swing.SwingComposite;
import org.ufacekit.ui.swing.SwingFactory;
import org.ufacekit.ui.swing.databinding.swing.SwingRealm;
/**
 * @version $Revision$
 */
public class SwingBrowser extends UFaceBrowser {
    static {
        SwingRealm.createDefault();
    }
    public SwingBrowser(DefaultCamelContext camelContext) {
        super(camelContext);
    }
    public void run() {
        JFrame frame = new JFrame();
        frame.setTitle(""Camel Browser"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Container container = frame.getContentPane();
        UIComposite composite = new SwingComposite(container, new SwingFactory().newFillLayout());
        createBrowserUI(composite);
        frame.pack();
        frame.setSize(650, 500);
        frame.setVisible(true);
    }
}
"
org.apache.camel.component.jpa.QueryBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import javax.persistence.EntityManager;
import javax.persistence.Query;
/**
 * A builder of query expressions
 * 
 * @version $Revision$
 */
public abstract class QueryBuilder implements QueryFactory {
    ParameterBuilder parameterBuilder;
    /**
     * Creates a query builder using the JPA query syntax
     * 
     * @param query JPA query language to create
     * @return a query builder
     */
    public static QueryBuilder query(final String query) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createQuery(query);
            }
            @Override
            public String toString() {
                return ""Query: "" + query + "" params: "" + getParameterDescription();
            }
        };
    }
    /**
     * Creates a named query
     */
    public static QueryBuilder namedQuery(final String namedQuery) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createNamedQuery(namedQuery);
            }
            @Override
            public String toString() {
                return ""Named: "" + namedQuery + getParameterDescription();
            }
        };
    }
    /**
     * Creates a native SQL query
     */
    public static QueryBuilder nativeQuery(final String nativeQuery) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createNativeQuery(nativeQuery);
            }
            @Override
            public String toString() {
                return ""NativeQuery: "" + nativeQuery + getParameterDescription();
            }
        };
    }
    /**
     * Specifies the parameters to the query
     * 
     * @param parameters the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(Object... parameters) {
        return parameters(Arrays.asList(parameters));
    }
    /**
     * Specifies the parameters to the query as an ordered collection of
     * parameters
     * 
     * @param parameters the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(final Collection parameters) {
        checkNoParametersConfigured();
        parameterBuilder = new ParameterBuilder() {
            public void populateQuery(EntityManager entityManager, Query query) {
                int counter = 0;
                for (Object parameter : parameters) {
                    query.setParameter(counter++, parameter);
                }
            }
            @Override
            public String toString() {
                return ""Parameters: "" + parameters;
            }
        };
        return this;
    }
    /**
     * Specifies the parameters to the query as a Map of key/value pairs
     * 
     * @param parameterMap the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(final Map<String, Object> parameterMap) {
        checkNoParametersConfigured();
        parameterBuilder = new ParameterBuilder() {
            public void populateQuery(EntityManager entityManager, Query query) {
                Set<Map.Entry<String, Object>> entries = parameterMap.entrySet();
                for (Map.Entry<String, Object> entry : entries) {
                    query.setParameter(entry.getKey(), entry.getValue());
                }
            }
            @Override
            public String toString() {
                return ""Parameters: "" + parameterMap;
            }
        };
        return this;
    }
    protected void checkNoParametersConfigured() {
        if (parameterBuilder != null) {
            throw new IllegalArgumentException(""Cannot add parameters to a QueryBuilder which already has parameters configured"");
        }
    }
    public Query createQuery(EntityManager entityManager) {
        Query query = makeQueryObject(entityManager);
        populateQuery(entityManager, query);
        return query;
    }
    protected String getParameterDescription() {
        if (parameterBuilder == null) {
            return """";
        } else {
            return "" "" + parameterBuilder.toString();
        }
    }
    protected void populateQuery(EntityManager entityManager, Query query) {
        if (parameterBuilder != null) {
            parameterBuilder.populateQuery(entityManager, query);
        }
    }
    protected abstract Query makeQueryObject(EntityManager entityManager);
    /**
     * A plugin strategy to populate the query with parameters
     */
    protected abstract static class ParameterBuilder {
        public abstract void populateQuery(EntityManager entityManager, Query query);
    }
}
"
