metric_name,file
org.apache.log4j.Appender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   Implement this interface for your own strategies for outputting log
   statements.
   @author Ceki G&uuml;lc&uuml; 
*/
public interface Appender {
  /**
     Add a filter to the end of the filter list.
     @since 0.9.0
   */
  void addFilter(Filter newFilter);
  /**
     Returns the head Filter. The Filters are organized in a linked list
     and so all Filters on this Appender are available through the result.
     @return the head Filter or null, if no Filters are present
     @since 1.1
  */
  public
  Filter getFilter();
  /**
     Clear the list of filters by removing all the filters in it.
     @since 0.9.0
   */
  public
  void clearFilters();
  /**
     Release any resources allocated within the appender such as file
     handles, network connections, etc.
     <p>It is a programming error to append to a closed appender.
     @since 0.8.4
  */
  public
  void close();
  /**
     Log in <code>Appender</code> specific way. When appropriate,
     Loggers will call the <code>doAppend</code> method of appender
     implementations in order to log. */
  public
  void doAppend(LoggingEvent event);
  /**
     Get the name of this appender. The name uniquely identifies the
     appender.  */
  public
  String getName();
  /**
     Set the {@link ErrorHandler} for this appender.
     @ since 0.9.0
   */
  public
  void setErrorHandler(ErrorHandler errorHandler);
  /**
     Returns the {@link ErrorHandler} for this appender.
     @since 1.1
   */
  public
  ErrorHandler getErrorHandler();
  /**
     Set the {@link Layout} for this appender.
     @since 0.8.1
  */
  public
  void setLayout(Layout layout);
  /**
     Returns this appenders layout.
     @since 1.1
  */
  public
  Layout getLayout();
  /**
     Set the name of this appender. The name is used by other
     components to identify this appender.
     @since 0.8.1
  */
  public
  void setName(String name);
  /**
     Configurators call this method to determine if the appender
    requires a layout. If this method returns <code>true</code>,
    meaning that layout is required, then the configurator will
    configure an layout using the configuration information at its
    disposal.  If this method returns <code>false</code>, meaning that
    a layout is not required, then layout configuration will be
    skipped even if there is available layout configuration
    information at the disposal of the configurator..
     <p>In the rather exceptional case, where the appender
     implementation admits a layout but can also work without it, then
     the appender should return <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout();
}
"
org.apache.log4j.AppenderSkeleton,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;
/** 
   Abstract superclass of the other appenders in the package.
   This class provides the code for common functionality, such as
   support for threshold filtering and support for general filters.
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public abstract class AppenderSkeleton implements Appender, OptionHandler {
  /** The layout variable does not need to be set if the appender
      implementation has its own layout. */
  protected Layout layout;
  /** Appenders are named. */
  protected String name;
  /**
     There is no level threshold filtering by default.  */
  protected Priority threshold;
  /** 
      It is assumed and enforced that errorHandler is never null.
  */
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();
  /** The first filter in the filter chain. Set to <code>null</code>
      initially. */
  protected Filter headFilter;
  /** The last filter in the filter chain. */
  protected Filter tailFilter;
  /**
     Is this appender closed? 
   */
  protected boolean closed = false;
  /**
     Derived appenders should override this method if option structure
     requires it.  */
  public
  void activateOptions() {
  }
  /**
     Add a filter to end of the filter list.
     @since 0.9.0
   */
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.next = newFilter;
      tailFilter = newFilter;    
    }
  }
  /**
     Subclasses of <code>AppenderSkeleton</code> should implement this
     method to perform actual logging. See also {@link #doAppend
     AppenderSkeleton.doAppend} method.
     @since 0.9.0
  */
  abstract
  protected
  void append(LoggingEvent event);
  /**
     Clear the filters chain.
     @since 0.9.0 */
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }
  /**
     Finalize this appender by calling the imlenentation's
     <code>close</code> method.
     @since 0.8.4
  */
  public
  void finalize() {
    // An appender might be closed then garbage collected. There is no
    // point in closing twice.
    if(this.closed) 
      return;
    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }
  /** 
      Return the currently set {@link ErrorHandler} for this
      Appender.  
      @since 0.9.0 */
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }
  /**
     Returns the head Filter.
     @since 1.1
  */
  public
  Filter getFilter() {
    return headFilter;
  }
  /** 
      Return the first filter in the filter chain for this
      Appender. The return value may be <code>null</code> if no is
      filter is set.
  */
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }
  /**
     Returns the layout of this appender. The value may be null.
  */
  public
  Layout getLayout() {
    return layout;
  }
  /**
     Returns the name of this FileAppender.
   */
  public
  final
  String getName() {
    return this.name;
  }
  /**
     Returns this appenders threshold level. See the {@link
     #setThreshold} method for the meaning of this option.
     @since 1.1 */
  public
  Priority getThreshold() {
    return threshold;
  }
  /**
     Check whether the message level is below the appender's
     threshold. If there is no threshold set, then the return value is
     always <code>true</code>.
  */
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }
  /**
     This method performs threshold checks and invokes filters before
     delegating actual logging to the subclasses specific {@link
     AppenderSkeleton#append} method.
   */
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
      return;
    }
    if(!isAsSevereAsThreshold(event.level)) {
      return;
    }
    Filter f = this.headFilter;
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.next;
      }
    }
    this.append(event);    
  }
  /** 
      Set the {@link ErrorHandler} for this Appender.
      @since 0.9.0
  */
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // We do not throw exception here since the cause is probably a
      // bad config file.
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
    }
  }
  /**
     Set the layout for this appender. Note that some appenders have
     their own (fixed) layouts or do not use one. For example, the
     {@link org.apache.log4j.net.SocketAppender} ignores the layout set
     here. 
  */
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }
  /**
     Set the name of this Appender.
   */
  public
  void setName(String name) {
    this.name = name;
  }
  /**
     Set the threshold level. All log events with lower level
     than the threshold level are ignored by the appender.
     <p>In configuration files this option is specified by setting the
     value of the <b>Threshold</b> option to a level
     string, such as ""DEBUG"", ""INFO"" and so on.
     @since 0.8.3 */
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }  
}
"
org.apache.log4j.AsyncAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contibutors:  Aaron Greenhouse <aarong@cs.cmu.edu>
//               Thomas Tuft Muller <ttm@online.no>
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.BoundedFIFO;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import java.util.Enumeration;
/**
   The AsyncAppender lets users log events asynchronously. It uses a
   bounded buffer to store logging events.
   <p>The AsyncAppender will collect the events sent to it and then
   dispatch them to all the appenders that are attached to it. You can
   attach multiple appenders to an AsyncAppender.
   <p>The AsyncAppender uses a separate thread to serve the events in
   its bounded buffer.
   <p>Refer to the results in {@link org.apache.log4j.performance.Logging}
   for the impact of using this appender.
   <p><b>Important note:</b> The <code>AsyncAppender</code> can only
   be script configured using the {@link
   org.apache.log4j.xml.DOMConfigurator}. Refer to example  configuration
   files <a href=""xml/examples/doc-files/sample4.xml"">sample4.xml</a>
   and <a href=""xml/examples/doc-files/sample5.xml"">sample5.xml</a>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public class AsyncAppender extends AppenderSkeleton
                                            implements AppenderAttachable {
  /** The default buffer size is set to 128 events. */
  public static final int DEFAULT_BUFFER_SIZE = 128;
  //static Category cat = Category.getInstance(AsyncAppender.class.getName());
  BoundedFIFO bf = new BoundedFIFO(DEFAULT_BUFFER_SIZE);
  AppenderAttachableImpl aai;
  Dispatcher dispatcher;
  boolean locationInfo = false;
  boolean interruptedWarningMessage = false;
  public
  AsyncAppender() {
    // Note: The dispatcher code assumes that the aai is set once and
    // for all.
    aai = new AppenderAttachableImpl();
    dispatcher = new Dispatcher(bf, this);
    dispatcher.start();
  }
  public
  void addAppender(Appender newAppender) {
    synchronized(aai) {
      aai.addAppender(newAppender);
    }
  }
  public
  void append(LoggingEvent event) {
    // Set the NDC and thread name for the calling thread as these
    // LoggingEvent fields were not set at event creation time.
    event.getNDC();
    event.getThreadName();
    // Get a copy of this thread's MDC.
    event.getMDCCopy();
    if(locationInfo) {
      event.getLocationInformation();
    }
    synchronized(bf) {
      while(bf.isFull()) {
	try {
	  //LogLog.debug(""Waiting for free space in buffer, ""+bf.length());
	  bf.wait();
	} catch(InterruptedException e) {
	  if(!interruptedWarningMessage) {
	    interruptedWarningMessage = true;
	    LogLog.warn(""AsyncAppender interrupted."", e);
	  } else {
	    LogLog.warn(""AsyncAppender interrupted again."");
	  }
	}
      }
      //cat.debug(""About to put new event in buffer."");
      bf.put(event);
      if(bf.wasEmpty()) {
	//cat.debug(""Notifying dispatcher to process events."");
	bf.notify();
      }
    }
  }
  /**
     Close this <code>AsyncAppender</code> by interrupting the
     dispatcher thread which will process all pending events before
     exiting.
  */
  public
  void close() {
    synchronized(this) {
      // avoid multiple close, otherwise one gets NullPointerException
      if(closed) { 
	return;
      }
      closed = true;
    }
    // The following cannot be synchronized on ""this"" because the
    // dispatcher synchronizes with ""this"" in its while loop. If we
    // did synchronize we would systematically get deadlocks when
    // close was called.
    dispatcher.close();
    try {
      dispatcher.join();
    } catch(InterruptedException e) {
      LogLog.error(""Got an InterruptedException while waiting for the ""+
		   ""dispatcher to finish."", e);
    }
    dispatcher = null;
    bf = null;
  }
  public
  Enumeration getAllAppenders() {
    synchronized(aai) {
      return aai.getAllAppenders();
    }
  }
  public
  Appender getAppender(String name) {
    synchronized(aai) {
      return aai.getAppender(name);
    }
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
  */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
     Is the appender passed as parameter attached to this category?
   */
  public
  boolean isAttached(Appender appender) {
    return aai.isAttached(appender);
  }
  /**
     The <code>AsyncAppender</code> does not require a layout. Hence,
     this method always returns <code>false</code>. */
  public
  boolean requiresLayout() {
    return false;
  }
  public
  void removeAllAppenders() {
    synchronized(aai) {
      aai.removeAllAppenders();
    }
  }
  public
  void removeAppender(Appender appender) {
    synchronized(aai) {
      aai.removeAppender(appender);
    }
  }
  public
  void removeAppender(String name) {
    synchronized(aai) {
      aai.removeAppender(name);
    }
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the event that will be ultimately logged will likely to
     contain the wrong location information (if present in the log
     format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     The <b>BufferSize</b> option takes a non-negative integer
     value.  This integer value determines the maximum size of the
     bounded buffer. Increasing the size of the buffer is always
     safe. However, if an existing buffer holds unwritten elements,
     then <em>decreasing the buffer size will result in event
     loss.</em> Nevertheless, while script configuring the
     AsyncAppender, it is safe to set a buffer size smaller than the
     {@link #DEFAULT_BUFFER_SIZE default buffer size} because
     configurators guarantee that an appender cannot be used before
     being completely configured.
   */
  public
  void setBufferSize(int size) {
    bf.resize(size);
  }
  /**
     Returns the current value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bf.getMaxSize();
  }
}
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// ----------------------------------------------------------------------------
class Dispatcher extends Thread {
  BoundedFIFO bf;
  AppenderAttachableImpl aai;
  boolean interrupted = false;
  AsyncAppender container;
  Dispatcher(BoundedFIFO bf, AsyncAppender container) {
    this.bf = bf;
    this.container = container;
    this.aai = container.aai;
    // set the dispatcher priority to lowest possible value
    this.setPriority(Thread.MIN_PRIORITY);
    this.setName(""Dispatcher-""+getName());
    // set the dispatcher priority to MIN_PRIORITY plus or minus 2
    // depending on the direction of MIN to MAX_PRIORITY.
    //+ (Thread.MAX_PRIORITY > Thread.MIN_PRIORITY ? 1 : -1)*2);
  }
  void close() {
    synchronized(bf) {
      interrupted = true;
      // We have a waiting dispacther if and only if bf.length is
      // zero.  In that case, we need to give it a death kiss.
      if(bf.length() == 0) {
	bf.notify();
      }
    }
  }
  /**
     The dispatching strategy is to wait until there are events in the
     buffer to process. After having processed an event, we release
     the monitor (variable bf) so that new events can be placed in the
     buffer, instead of keeping the monitor and processing the remaining
     events in the buffer.
    <p>Other approaches might yield better results.
  */
  public
  void run() {
    //Category cat = Category.getInstance(Dispatcher.class.getName());
    LoggingEvent event;
    while(true) {
      synchronized(bf) {
	if(bf.length() == 0) {
	  // Exit loop if interrupted but only if the the buffer is empty.
	  if(interrupted) {
	    //cat.info(""Exiting."");
	    return;
	  }
	  try {
	    //LogLog.debug(""Waiting for new event to dispatch."");
	    bf.wait();
	  } catch(InterruptedException e) {
	    LogLog.error(""The dispathcer should not be interrupted."");
	    break;
	  }
	}
	event = bf.get();
	if(bf.wasFull()) {
	  //LogLog.debug(""Notifying AsyncAppender about freed space."");
	  bf.notify();
	}
      } // synchronized
      // The synchronization on parent is necessary to protect against
      // operations on the aai object of the parent
      synchronized(container.aai) {
	if(aai != null && event != null) {
	  aai.appendLoopOnAppenders(event);
	}
      }
    } // while
  }
}
"
org.apache.log4j.BasicConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//              ""Muly Oved"" <mulyoved@hotmail.com>
package org.apache.log4j;
/**
   Use this class to quickly configure the package.
   <p>For file based configuration see {@link
   PropertyConfigurator}. For XML based configuration see {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}.
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public class BasicConfigurator {
  protected BasicConfigurator() {
  }
  /**
     Add a {@link ConsoleAppender} that uses {@link PatternLayout}
     using the {@link PatternLayout#TTCC_CONVERSION_PATTERN} and
     prints to <code>System.out</code> to the root category.  */
  static
  public
  void configure() {
    Logger root = Logger.getRootLogger();
    root.addAppender(new ConsoleAppender(
           new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
  }
  /**
     Add <code>appender</code> to the root category.
     @param appender The appender to add to the root category.
  */
  static
  public
  void configure(Appender appender) {
    Logger root = Logger.getRootLogger();
    root.addAppender(appender);
  }
  /**
     Reset the default hierarchy to its defaut. It is equivalent to
     calling
     <code>Category.getDefaultHierarchy().resetConfiguration()</code>.
     See {@link Hierarchy#resetConfiguration()} for more details.  */
  public
  static
  void resetConfiguration() {
    LogManager.resetConfiguration();
  }
}
"
org.apache.log4j.Category,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contibutors: Alex Blewitt <Alex.Blewitt@ioshq.com>
//              Markus Oestreicher <oes@zurich.ibm.com>
//              Frank Hoering <fhr@zurich.ibm.com>
//              Nelson Minar <nelson@media.mit.edu>
//              Jim Cakalic <jim_cakalic@na.biomerieux.com>
//              Avy Sharell <asharell@club-internet.fr>
//              Ciaran Treanor <ciaran@xelector.com>
//              Jeff Turner <jeff@socialchange.net.au>
//              Michael Horwitz <MHorwitz@siemens.co.za>
//              Calvin Chan <calvin.chan@hic.gov.au>
//              Aaron Greenhouse <aarong@cs.cmu.edu>
//              Beat Meier <bmeier@infovia.com.ar>
//              Colin Sampaleanu <colinml1@exis.com>
package org.apache.log4j;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import java.util.Enumeration;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
/**
   <font color=""#AA2222""><b>This class has been deprecated and
   replaced by the {@link Logger} <em>subclass</em>.</b></font> It
   will be kept around to preserve backward compatibility until mid
   2003.
   <p><code>Logger</code> is a subclass of Category, i.e. it extends
   Category. In other words, a logger <em>is</em> a category. Thus,
   all operations that can be performed on a category can be performed
   on a logger. Whenever log4j is asked to produce a Category object,
   it will instead produce a Logger object. However, methods that
   previously accepted category objects still continue to accept
   category objects.
   <p>For example, the following are all legal and will work as expected.
   <pre>
   &nbsp;&nbsp;&nbsp;// Deprecated form:
   &nbsp;&nbsp;&nbsp;Category cat = Category.getInstance(""foo.bar"")
   &nbsp;&nbsp;&nbsp;// Preferred form for retrieving loggers:
   &nbsp;&nbsp;&nbsp;Logger logger = Logger.getLogger(""foo.bar"")
   </pre>
   <p>The first form is deprecated and should be avoided.
   <p><b>There is absolutely no need for new client code to use or
   refer to the <code>Category</code> class.</b> Whenever possible,
   please avoid referring to it or using it.
  <p>See the <a href=""../../../../manual.html"">short manual</a> for an
  introduction on this class.
  @author Ceki G&uuml;lc&uuml;
  @author Anders Kristensen */
public class Category implements AppenderAttachable {
  /**
     The hierarchy where categories are attached to by default.
  */
  //static
  //public
  //final Hierarchy defaultHierarchy = new Hierarchy(new
  //					   RootCategory(Level.DEBUG));
  static int nooptimize;
  /**
     The name of this category.
  */
  protected String   name;
  /**
     The assigned level of this category.  The
     <code>level</code> variable need not be assigned a value in
     which case it is inherited form the hierarchy.  */
  volatile protected Level level;
  /**
     The parent of this category. All categories have at least one
     ancestor which is the root category. */
  volatile protected Category parent;
  /**
     The fully qualified name of the Category class. See also the
     getFQCN method. */
  private static final String FQCN = Category.class.getName();
  protected ResourceBundle resourceBundle;
  // Categories need to know what Hierarchy they are in
  protected LoggerRepository repository;
  AppenderAttachableImpl aai;
  /** Additivity is set to true by default, that is children inherit
      the appenders of their ancestors by default. If this variable is
      set to <code>false</code> then the appenders found in the
      ancestors of this category are not used. However, the children
      of this category will inherit its appenders, unless the children
      have their additivity flag set to <code>false</code> too. See
      the user manual for more details. */
  protected boolean additive = true;
  /**
     This constructor created a new <code>Category</code> instance and
     sets its name.
     <p>It is intended to be used by sub-classes only. You should not
     create categories directly.
     @param name The name of the category.
  */
  protected
  Category(String name) {
    this.name = name;
  }
  /**
     Add <code>newAppender</code> to the list of appenders of this
     Category instance.
     <p>If <code>newAppender</code> is already in the list of
     appenders, then it won't be added again.
  */
  synchronized
  public
  void addAppender(Appender newAppender) {
    if(aai == null) {
      aai = new AppenderAttachableImpl();
    }
    aai.addAppender(newAppender);
    repository.fireAddAppenderEvent(this, newAppender);
  }
  /**
     If <code>assertion</code> parameter is <code>false</code>, then
     logs <code>msg</code> as an {@link #error(Object) error} statement.
     <p>The <code>assert</code> method has been renamed to
     <code>assertLog</code> because <code>assert</code> is a language
     reserved word in JDK 1.4.
     @param assertion
     @param msg The message to print if <code>assertion</code> is
     false.
     @since 1.2 */
  public
  void assertLog(boolean assertion, String msg) {
    if(!assertion)
      this.error(msg);
  }
  /**
     Call the appenders in the hierrachy starting at
     <code>this</code>.  If no appenders could be found, emit a
     warning.
     <p>This method calls all the appenders inherited from the
     hierarchy circumventing any evaluation of whether to log or not
     to log the particular log request.
     @param event the event to log.  */
  public
  void callAppenders(LoggingEvent event) {
    int writes = 0;
    for(Category c = this; c != null; c=c.parent) {
      // Protected against simultaneous call to addAppender, removeAppender,...
      synchronized(c) {
	if(c.aai != null) {
	  writes += c.aai.appendLoopOnAppenders(event);
	}
	if(!c.additive) {
	  break;
	}
      }
    }
    if(writes == 0) {
      repository.emitNoAppenderWarning(this);
    }
  }
  /**
     Close all attached appenders implementing the AppenderAttachable
     interface.
     @since 1.0
  */
  synchronized
  void closeNestedAppenders() {
    Enumeration enum = this.getAllAppenders();
    if(enum != null) {
      while(enum.hasMoreElements()) {
	Appender a = (Appender) enum.nextElement();
	if(a instanceof AppenderAttachable) {
	  a.close();
	}
      }
    }
  }
  /**
    Log a message object with the {@link Level#DEBUG DEBUG} level.
    <p>This method first checks if this category is <code>DEBUG</code>
    enabled by comparing the level of this category with the {@link
    Level#DEBUG DEBUG} level. If this category is
    <code>DEBUG</code> enabled, then it converts the message object
    (passed as parameter) to a string by invoking the appropriate
    {@link org.apache.log4j.or.ObjectRenderer}. It then proceeds to call all the
    registered appenders in this category and also higher in the
    hierarchy depending on the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #debug(Object,
    Throwable)} form instead.
    @param message the message object to log. */
  public
  void debug(Object message) {
    if(repository.isDisabled(Level.DEBUG_INT))
      return;
    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel())) {
      forcedLog(FQCN, Level.DEBUG, message, null);
    }
  }
  /**
   Log a message object with the <code>DEBUG</code> level including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #debug(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void debug(Object message, Throwable t) {
    if(repository.isDisabled(Level.DEBUG_INT))
      return;
    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.DEBUG, message, t);
  }
  /**
    Log a message object with the {@link Level#ERROR ERROR} Level.
    <p>This method first checks if this category is <code>ERROR</code>
    enabled by comparing the level of this category with {@link
    Level#ERROR ERROR} Level. If this category is <code>ERROR</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link
    org.apache.log4j.or.ObjectRenderer}. It proceeds to call all the
    registered appenders in this category and also higher in the
    hierarchy depending on the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #error(Object,
    Throwable)} form instead.
    @param message the message object to log */
  public
  void error(Object message) {
    if(repository.isDisabled(Level.ERROR_INT))
      return;
    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.ERROR, message, null);
  }
  /**
   Log a message object with the <code>ERROR</code> level including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #error(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void error(Object message, Throwable t) {
    if(repository.isDisabled(Level.ERROR_INT))
      return;
    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.ERROR, message, t);
  }
  /**
     If the named category exists (in the default hierarchy) then it
     returns a reference to the category, otherwise it returns
     <code>null</code>.
     @deprecated Please use {@link LogManager#exists} instead.
     @version 0.8.5 */
  public
  static
  Logger exists(String name) {
    return LogManager.exists(name);
  }
  /**
    Log a message object with the {@link Level#FATAL FATAL} Level.
    <p>This method first checks if this category is <code>FATAL</code>
    enabled by comparing the level of this category with {@link
    Level#FATAL FATAL} Level. If the category is <code>FATAL</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate
    {@link org.apache.log4j.or.ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #fatal(Object, Throwable)} form
    instead.
    @param message the message object to log */
  public
  void fatal(Object message) {
    if(repository.isDisabled(Level.FATAL_INT))
      return;
    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.FATAL, message, null);
  }
  /**
   Log a message object with the <code>FATAL</code> level including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #fatal(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void fatal(Object message, Throwable t) {
    if(repository.isDisabled(Level.FATAL_INT))
      return;
    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.FATAL, message, t);
  }
  /**
     This method creates a new logging event and logs the event
     without further checks.  */
  protected
  void forcedLog(String fqcn, Priority level, Object message, Throwable t) {
    callAppenders(new LoggingEvent(fqcn, this, level, message, t));
  }
  /**
     Get the additivity flag for this Category instance.
  */
  public
  boolean getAdditivity() {
    return additive;
  }
  /**
     Get the appenders contained in this category as an {@link
     Enumeration}. If no appenders can be found, then a {@link NullEnumeration}
     is returned.
     @return Enumeration An enumeration of the appenders in this category.  */
  synchronized
  public
  Enumeration getAllAppenders() {
    if(aai == null)
      return NullEnumeration.getInstance();
    else
      return aai.getAllAppenders();
  }
  /**
     Look for the appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return
     <code>null</code> otherwise.  */
  synchronized
  public
  Appender getAppender(String name) {
     if(aai == null || name == null)
      return null;
     return aai.getAppender(name);
  }
  /**
     Starting from this category, search the category hierarchy for a
     non-null level and return it. Otherwise, return the level of the
     root category.
     <p>The Category class is designed so that this method executes as
     quickly as possible.
   */
  public
  Level getEffectiveLevel() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.level != null)
	return c.level;
    }
    return null; // If reached will cause an NullPointerException.
  }
  /**
     @deprecated Has been replaced by the {@link #getEffectiveLevel}
     method.  */
  public
  Priority getChainedPriority() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.level != null)
	return c.level;
    }
    return null; // If reached will cause an NullPointerException.
  }
  /**
     Returns all the currently defined categories in the default
     hierarchy as an {@link java.util.Enumeration Enumeration}.
     <p>The root category is <em>not</em> included in the returned
     {@link Enumeration}.
     @deprecated Please use {@link LogManager#getCurrentLoggers()} instead.
  */
  public
  static
  Enumeration getCurrentCategories() {
    return LogManager.getCurrentLoggers();
  }
  /**
     Return the default Hierarchy instance.
     @deprecated Please use {@link LogManager#getLoggerRepository()} instead.
     @since 1.0
   */
  public
  static
  LoggerRepository getDefaultHierarchy() {
    return LogManager.getLoggerRepository();
  }
  /**
     Return the the {@link Hierarchy} where this <code>Category</code>
     instance is attached.
     @deprecated Please use {@link #getLoggerRepository} instead.
     @since 1.1 */
  public
  LoggerRepository  getHierarchy() {
    return repository;
  }
  /**
     Return the the {@link LoggerRepository} where this
     <code>Category</code> is attached.
     @since 1.2 */
  public
  LoggerRepository  getLoggerRepository() {
    return repository;
  }
 /**
     Retrieve a category with named as the <code>name</code>
     parameter. If the named category already exists, then the
     existing instance will be reutrned. Otherwise, a new instance is
     created.
     By default, categories do not have a set level but inherit
     it from the hierarchy. This is one of the central features of
     log4j.
     <b>Deprecated</b> Please use {@link Logger#getLogger(String)}
     instead.
     @param name The name of the category to retrieve.  */
  public
  static
  Category getInstance(String name) {
     nooptimize++;
    return LogManager.getLogger(name);
  }
 /**
    Shorthand for <code>getInstance(clazz.getName())</code>.
    @param clazz The name of <code>clazz</code> will be used as the
    name of the category to retrieve.  See {@link
    #getInstance(String)} for more detailed information.
    <b>Deprecated</b> Please use {@link Logger#getLogger(Class)} instead.
    @since 1.0 */
  public
  static
  Category getInstance(Class clazz) {
    nooptimize++;
    return LogManager.getLogger(clazz);
  }
  /**
     Return the category name.  */
  public
  final
  String getName() {
    return name;
  }
  /**
     Returns the parent of this category. Note that the parent of a
     given category may change during the lifetime of the category.
     <p>The root category will return <code>null</code>.
     @since 1.2
  */
  final
  public
  Category getParent() {
    return this.parent;
  }
  /**
     Returns the assigned {@link Level}, if any, for this Category.
     @return Level - the assigned Level, can be <code>null</code>.
  */
  final
  public
  Level getLevel() {
    return this.level;
  }
  /**
     @deprecated Please use {@link #getLevel} instead.
  */
  final
  public
  Level getPriority() {
    return this.level;
  }
  /**
     Return the root of the default category hierrachy.
     <p>The root category is always instantiated and available. It's
     name is ""root"".
     <p>Nevertheless, calling {@link #getInstance
     Category.getInstance(""root"")} does not retrieve the root category
     but a category just under root named ""root"".
     <b>Deprecated</b> Use {@link Logger#getRootLogger()} instead.
   */
  final
  public
  static
  Category getRoot() {
    return LogManager.getRootLogger();
  }
  /**
     Return the <em>inherited</em> {@link ResourceBundle} for this
     category.
     <p>This method walks the hierarchy to find the appropriate
     resource bundle. It will return the resource bundle attached to
     the closest ancestor of this category, much like the way
     priorities are searched. In case there is no bundle in the
     hierarchy then <code>null</code> is returned.
     @since 0.9.0 */
  public
  ResourceBundle getResourceBundle() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.resourceBundle != null)
	return c.resourceBundle;
    }
    // It might be the case that there is no resource bundle
    return null;
  }
  /**
     Returns the string resource coresponding to <code>key</code> in
     this category's inherited resource bundle. See also {@link
     #getResourceBundle}.
     <p>If the resource cannot be found, then an {@link #error error}
     message will be logged complaining about the missing resource.
  */
  protected
  String getResourceBundleString(String key) {
    ResourceBundle rb = getResourceBundle();
    // This is one of the rare cases where we can use logging in order
    // to report errors from within log4j.
    if(rb == null) {
      //if(!hierarchy.emittedNoResourceBundleWarning) {
      //error(""No resource bundle has been set for category ""+name);
      //hierarchy.emittedNoResourceBundleWarning = true;
      //}
      return null;
    }
    else {
      try {
	return rb.getString(key);
      }
      catch(MissingResourceException mre) {
	error(""No resource is associated with key \""""+key+""\""."");
	return null;
      }
    }
  }
  /**
    Log a message object with the {@link Level#INFO INFO} Level.
    <p>This method first checks if this category is <code>INFO</code>
    enabled by comparing the level of this category with {@link
    Level#INFO INFO} Level. If the category is <code>INFO</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate
    {@link org.apache.log4j.or.ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #info(Object, Throwable)} form
    instead.
    @param message the message object to log */
  public
  void info(Object message) {
    if(repository.isDisabled(Level.INFO_INT))
      return;
    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.INFO, message, null);
  }
  /**
   Log a message object with the <code>INFO</code> level including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #info(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void info(Object message, Throwable t) {
    if(repository.isDisabled(Level.INFO_INT))
      return;
    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.INFO, message, t);
  }
  /**
     Is the appender passed as parameter attached to this category?
   */
  public
  boolean isAttached(Appender appender) {
    if(appender == null || aai == null)
      return false;
    else {
      return aai.isAttached(appender);
    }
  }
  /**
    *  Check whether this category is enabled for the <code>DEBUG</code>
    *  Level.
    *
    *  <p> This function is intended to lessen the computational cost of
    *  disabled log debug statements.
    *
    *  <p> For some <code>cat</code> Category object, when you write,
    *  <pre>
    *      cat.debug(""This is entry number: "" + i );
    *  </pre>
    *
    *  <p>You incur the cost constructing the message, concatenatiion in
    *  this case, regardless of whether the message is logged or not.
    *
    *  <p>If you are worried about speed, then you should write
    *  <pre>
    * 	 if(cat.isDebugEnabled()) {
    * 	   cat.debug(""This is entry number: "" + i );
    * 	 }
    *  </pre>
    *
    *  <p>This way you will not incur the cost of parameter
    *  construction if debugging is disabled for <code>cat</code>. On
    *  the other hand, if the <code>cat</code> is debug enabled, you
    *  will incur the cost of evaluating whether the category is debug
    *  enabled twice. Once in <code>isDebugEnabled</code> and once in
    *  the <code>debug</code>.  This is an insignificant overhead
    *  since evaluating a category takes about 1%% of the time it
    *  takes to actually log.
    *
    *  @return boolean - <code>true</code> if this category is debug
    *  enabled, <code>false</code> otherwise.
    *   */
  public
  boolean isDebugEnabled() {
    if(repository.isDisabled( Level.DEBUG_INT))
      return false;
    return Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel());
  }
  /**
     Check whether this category is enabled for a given {@link
     Level} passed as parameter.
     See also {@link #isDebugEnabled}.
     @return boolean True if this category is enabled for <code>level</code>.
  */
  public
  boolean isEnabledFor(Priority level) {
    if(repository.isDisabled(level.level))
      return false;
    return level.isGreaterOrEqual(this.getEffectiveLevel());
  }
  /**
    Check whether this category is enabled for the info Level.
    See also {@link #isDebugEnabled}.
    @return boolean - <code>true</code> if this category is enabled
    for level info, <code>false</code> otherwise.
  */
  public
  boolean isInfoEnabled() {
    if(repository.isDisabled(Level.INFO_INT))
      return false;
    return Level.INFO.isGreaterOrEqual(this.getEffectiveLevel());
  }
  /**
     Log a localized message. The user supplied parameter
     <code>key</code> is replaced by its localized version from the
     resource bundle.
     @see #setResourceBundle
     @since 0.8.4 */
  public
  void l7dlog(Priority priority, String key, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {
      String msg = getResourceBundleString(key);
      // if message corresponding to 'key' could not be found in the
      // resource bundle, then default to 'key'.
      if(msg == null) {
	msg = key;
      }
      forcedLog(FQCN, priority, msg, t);
    }
  }
  /**
     Log a localized and parameterized message. First, the user
     supplied <code>key</code> is searched in the resource
     bundle. Next, the resulting pattern is formatted using
     {@link java.text.MessageFormat#format(String,Object[])} method with the
     user supplied object array <code>params</code>.
     @since 0.8.4
  */
  public
  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {
      String pattern = getResourceBundleString(key);
      String msg;
      if(pattern == null)
	msg = key;
      else
	msg = java.text.MessageFormat.format(pattern, params);
      forcedLog(FQCN, priority, msg, t);
    }
  }
  /**
     This generic form is intended to be used by wrappers.
   */
  public
  void log(Priority priority, Object message, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, priority, message, t);
  }
 /**
    This generic form is intended to be used by wrappers.
 */
  public
  void log(Priority priority, Object message) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, priority, message, null);
  }
  /**
     This is the most generic printing method. It is intended to be
     invoked by <b>wrapper</b> classes.
     @param callerFQCN The wrapper class' fully qualified class name.
     @param level The level of the logging request.
     @param message The message of the logging request.
     @param t The throwable of the logging request, may be null.  */
  public
  void log(String callerFQCN, Priority level, Object message, Throwable t) {
    if(repository.isDisabled(level.level)) {
      return;
    }
    if(level.isGreaterOrEqual(this.getEffectiveLevel())) {
      forcedLog(callerFQCN, level, message, t);
    }
  }
  /**
     Remove all previously added appenders from this Category
     instance.
     <p>This is useful when re-reading configuration information.
  */
  synchronized
  public
  void removeAllAppenders() {
    if(aai != null) {
      aai.removeAllAppenders();
      aai = null;
    }
  }
  /**
     Remove the appender passed as parameter form the list of appenders.
     @since 0.8.2
  */
  synchronized
  public
  void removeAppender(Appender appender) {
    if(appender == null || aai == null)
      return;
    aai.removeAppender(appender);
  }
  /**
     Remove the appender with the name passed as parameter form the
     list of appenders.
     @since 0.8.2 */
  synchronized
  public
  void removeAppender(String name) {
    if(name == null || aai == null) return;
    aai.removeAppender(name);
  }
  /**
     Set the additivity flag for this Category instance.
     @since 0.8.1
   */
  public
  void setAdditivity(boolean additive) {
    this.additive = additive;
  }
  /**
     Only the Hiearchy class can set the hiearchy of a
     category. Default package access is MANDATORY here.  */
  final
  void setHierarchy(LoggerRepository repository) {
    this.repository = repository;
  }
  /**
     Set the level of this Category. If you are passing any of
     <code>Level.DEBUG</code>, <code>Level.INFO</code>,
     <code>Level.WARN</code>, <code>Level.ERROR</code>,
     <code>Level.FATAL</code> as a parameter, you need to case them as
     Level.
     <p>As in <pre> &nbsp;&nbsp;&nbsp;logger.setLevel((Level) Level.DEBUG); </pre>
     <p>Null values are admitted.  */
  public
  void setLevel(Level level) {
    this.level = level;
  }
  /**
     Set the level of this Category.
     <p>Null values are admitted.
     @deprecated Please use {@link #setLevel} instead.
  */
  public
  void setPriority(Priority priority) {
    this.level = (Level) priority;
  }
  /**
     Set the resource bundle to be used with localized logging
     methods {@link #l7dlog(Priority,String,Throwable)} and {@link
     #l7dlog(Priority,String,Object[],Throwable)}.
     @since 0.8.4
   */
  public
  void setResourceBundle(ResourceBundle bundle) {
    resourceBundle = bundle;
  }
  /**
     Calling this method will <em>safely</em> close and remove all
     appenders in all the categories including root contained in the
     default hierachy.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.
     @deprecated Please use {@link LogManager#shutdown()} instead.
     @since 1.0
  */
  public
  static
  void shutdown() {
    LogManager.shutdown();
  }
  /**
    Log a message object with the {@link Level#WARN WARN} Level.
    <p>This method first checks if this category is <code>WARN</code>
    enabled by comparing the level of this category with {@link
    Level#WARN WARN} Level. If the category is <code>WARN</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate
    {@link org.apache.log4j.or.ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hieararchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #warn(Object, Throwable)} form
    instead.  <p>
    @param message the message object to log.  */
  public
  void warn(Object message) {
    if(repository.isDisabled( Level.WARN_INT))
      return;
    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.WARN, message, null);
  }
  /**
   Log a message with the <code>WARN</code> level including the
   stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #warn(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void warn(Object message, Throwable t) {
    if(repository.isDisabled(Level.WARN_INT))
      return;
    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.WARN, message, t);
  }
}
"
org.apache.log4j.CategoryKey,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
/**
   CategoryKey is heavily used internally to accelerate hash table searches.
   @author Ceki G&uuml;lc&uuml; 
*/
class CategoryKey {
  String   name;  
  int hashCache;
  CategoryKey(String name) {
    this.name = name.intern();
    hashCache = name.hashCode();
  }
  final
  public  
  int hashCode() {
    return hashCache;
  }
  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name == ((CategoryKey)rArg ).name;
    else 
      return false;
  }
}
"
org.apache.log4j.ConsoleAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.LogLog;
/**
   ConsoleAppender appends log events to <code>System.out</code> or
   <code>System.err</code> using a layout specified by the
   user. The default target is <code>System.out</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 1.1 */
public class ConsoleAppender extends WriterAppender {
  public static final String SYSTEM_OUT = ""System.out"";
  public static final String SYSTEM_ERR = ""System.err"";
  protected String target = SYSTEM_OUT;
  /**
     The default constructor does nothing.
   */
  public ConsoleAppender() {
  }
  public ConsoleAppender(Layout layout) {
    this(layout, SYSTEM_OUT);
  }
  public ConsoleAppender(Layout layout, String target) {
    this.layout = layout;
    if (SYSTEM_OUT.equals(target)) {
      setWriter(new OutputStreamWriter(System.out));
    } else if (SYSTEM_ERR.equalsIgnoreCase(target)) {
      setWriter(new OutputStreamWriter(System.err));
    } else {
      targetWarn(target);
    }
  }
  /**
     Sets the value of the <b>Target</b> option. Recognized values are
     ""System.out"" and ""System.err"". Any other value will be ignored.
  */
  public
  void setTarget(String value) {
    String v = value.trim();
    if (SYSTEM_OUT.equalsIgnoreCase(v)) {
      target = SYSTEM_OUT;
    } else if (SYSTEM_ERR.equalsIgnoreCase(v)) {
      target = SYSTEM_ERR;
    } else {
      targetWarn(value);
    }
  }
  /**
      Returns the current value of the <b>Target</b> property. The default
      value of the option is ""System.out"".
      See also {@link #setTarget}.
  */
  public
  String getTarget() {
    return target;
  }
  void targetWarn(String val) {
    LogLog.warn(""[""+val+""] should be System.out or System.err."");
    LogLog.warn(""Using System.out (default)."");
  }
  public
  void activateOptions() {
    if(target.equals(SYSTEM_OUT)) {
      setWriter(new OutputStreamWriter(System.out));
    } else {
      setWriter(new OutputStreamWriter(System.err));
    }
  }
  /**
     Override the parent method to do nothing.
   */
  protected
  final
  void closeWriter() {
  }
}
"
org.apache.log4j.DailyRollingFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Locale;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
/**
   DailyRollingFileAppender extends {@link FileAppender} so that the
   underlying file is rolled over at a user chosen frequency.
   <p>The rolling schedule is specified by the <b>DatePattern</b>
   option. This pattern should follow the {@link SimpleDateFormat}
   conventions. In particular, you <em>must</em> escape literal text
   within a pair of single quotes. A formatted version of the date
   pattern is used as the suffix for the rolled file name.
   <p>For example, if the <b>File</b> option is set to
   <code>/foo/bar.log</code> and the <b>DatePattern</b> set to
   <code>'.'yyyy-MM-dd</code>, on 2001-02-16 at midnight, the logging
   file <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-02-16</code> and logging for 2001-02-17
   will continue in <code>/foo/bar.log</code> until it rolls over
   the next day.
   <p>Is is possible to specify monthly, weekly, half-daily, daily,
   hourly, or minutely rollover schedules.
   <p><table border=""1"" cellpadding=""2"">
   <tr>
   <th>DatePattern</th>
   <th>Rollover schedule</th>
   <th>Example</th>
   <tr>
   <td><code>'.'yyyy-MM</code>
   <td>Rollover at the beginning of each month</td>
   <td>Assuming the first day of the week is Sunday, at Sunday 00:00,
   March 25th, 2001, <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03</code>. Logging for the month of April
   will be output to <code>/foo/bar.log</code> until it rolls over
   at the beginning of May.
   <tr>
   <td><code>'.'yyyy-ww</code>
   <td>Rollover at the first day of each week. The first day of the
   week depends on the locale.</td>
   <td>At midnight, on March 31st, 2001, <code>/foo/bar.log</code>
   will be copied to <code>/foo/bar.log.2001-08</code>. Logging for
   the 9th week of 2001 will be output to <code>/foo/bar.log</code>
   until it is rolled over the next week.
   <tr>
   <td><code>'.'yyyy-MM-dd</code>
   <td>Rollover at midnight each day.</td>
   <td>At midnight, on March 9th, 2001, <code>/foo/bar.log</code> will
   be copied to <code>/foo/bar.log.2001-03-08</code>. Logging for the
   9th day of March will be output to <code>/foo/bar.log</code> until
   it is rolled over the next day.
   <tr>
   <td><code>'.'yyyy-MM-dd-a</code>
   <td>Rollover at midnight and midday of each day.</td>
   <td>At noon, on March 9th, 2001, <code>/foo/bar.log</code> will be
   copied to <code>/foo/bar.log.2001-03-09-AM</code>. Logging for the
   afternoon of the 9th will be output to <code>/foo/bar.log</code>
   until it is rolled over the next morning, i.e at midnight 00:00.
   <tr>
   <td><code>'.'yyyy-MM-dd-HH</code>
   <td>Rollover at the top of every hour.</td>
   <td>At approximately 11:00,000, on March 9th, 2001,
   <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03-09-10</code>. Logging for the 11th hour
   of the 9th of March will be output to <code>/foo/bar.log</code>
   until it is rolled over at the beginning of the next hour.
   <tr>
   <td><code>'.'yyyy-MM-dd-HH-mm</code>
   <td>Rollover at the beginning of every minute.</td>
   <td>At approximately 11:23,000, on March 9th, 2001,
   <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03-09-10-22</code>. Logging for the minute
   of 11:23 (9th of March) will be output to
   <code>/foo/bar.log</code> until it is rolled over the next minute.
   </table>
   <p>Do not use the colon "":"" character in anywhere in the
   <b>DatePattern</b> option. The text before the colon is interpeted
   as the protocol specificaion of a URL which is probably not what
   you want.
   @author Eirik Lygre
   @author Ceki G&uuml;lc&uuml; */
public class DailyRollingFileAppender extends FileAppender {
  // The code assumes that the following constants are in a increasing
  // sequence.
  static final int TOP_OF_TROUBLE=-1;
  static final int TOP_OF_MINUTE = 0;
  static final int TOP_OF_HOUR   = 1;
  static final int HALF_DAY      = 2;
  static final int TOP_OF_DAY    = 3;
  static final int TOP_OF_WEEK   = 4;
  static final int TOP_OF_MONTH  = 5;
  /**
     The date pattern. By default, the pattern is set to
     ""'.'yyyy-MM-dd"" meaning daily rollover.
   */
  private String datePattern = ""'.'yyyy-MM-dd"";
  /**
     The actual formatted filename that is currently being written to.
  */
  private String scheduledFilename;
  /**
     The timestamp when we shall next recompute the filename.
  */
  private long nextCheck = System.currentTimeMillis () - 1;
  Date now = new Date();
  SimpleDateFormat sdf;
  RollingCalendar rc = new RollingCalendar();
  int checkPeriod = TOP_OF_TROUBLE;
  static final TimeZone gmtTimeZone = TimeZone.getTimeZone(""GMT"");
  /**
     The default constructor does nothing. */
  public
  DailyRollingFileAppender() {
  }
  /**
    Instantiate a <code>DailyRollingFileAppender</code> and open the
    file designated by <code>filename</code>. The opened filename will
    become the ouput destination for this appender.
    */
  public DailyRollingFileAppender (Layout layout, String filename,
				   String datePattern) throws IOException {
    super(layout, filename, true);
    this.datePattern = datePattern;
    activateOptions();
  }
  /**
     The <b>DatePattern</b> takes a string in the same format as
     expected by {@link SimpleDateFormat}. This options determines the
     rollover schedule.
   */
  public
  void setDatePattern(String pattern) {
    datePattern = pattern;
  }
  /** Returns the value of the <b>DatePattern</b> option. */
  public
  String getDatePattern() {
    return datePattern;
  }
  public
  void activateOptions() {
    super.activateOptions();
    if(datePattern != null && fileName != null) {
      now.setTime(System.currentTimeMillis());
      sdf = new SimpleDateFormat(datePattern);
      int type = computeCheckPeriod();
      printPeriodicity(type);
      rc.setType(type);
      File file = new File(fileName);
      scheduledFilename = fileName+sdf.format(new Date(file.lastModified()));
    } else {
      LogLog.error(""Either Filename or DatePattern options are not set for [""+
		   name+""]."");
    }
  }
  void printPeriodicity(int type) {
    switch(type) {
    case TOP_OF_MINUTE:
      LogLog.debug(""Appender [""+name+""] to be rolled every minute."");
      break;
    case TOP_OF_HOUR:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled on top of every hour."");
      break;
    case HALF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midday and midnight."");
      break;
    case TOP_OF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midnight."");
      break;
    case TOP_OF_WEEK:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of week."");
      break;
    case TOP_OF_MONTH:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of every month."");
      break;
    default:
      LogLog.warn(""Unknown periodicity for appender [""+name+""]."");
    }
  }
  // This method computes the roll over period by looping over the
  // periods, starting with the shortest, and stopping when the r0 is
  // different from from r1, where r0 is the epoch formatted according
  // the datePattern (supplied by the user) and r1 is the
  // epoch+nextMillis(i) formatted according to datePattern. All date
  // formatting is done in GMT and not local format because the test
  // logic is based on comparisons relative to 1970-01-01 00:00:00
  // GMT (the epoch).
  int computeCheckPeriod() {
    RollingCalendar rollingCalendar = new RollingCalendar(gmtTimeZone, Locale.ENGLISH);
    // set sate to 1970-01-01 00:00:00 GMT
    Date epoch = new Date(0);
    if(datePattern != null) {
      for(int i = TOP_OF_MINUTE; i <= TOP_OF_MONTH; i++) {
	SimpleDateFormat simpleDateFormat = new SimpleDateFormat(datePattern);
	simpleDateFormat.setTimeZone(gmtTimeZone); // do all date formatting in GMT
	String r0 = simpleDateFormat.format(epoch);
	rollingCalendar.setType(i);
	Date next = new Date(rollingCalendar.getNextCheckMillis(epoch));
	String r1 =  simpleDateFormat.format(next);
	//System.out.println(""Type = ""+i+"", r0 = ""+r0+"", r1 = ""+r1);
	if(r0 != null && r1 != null && !r0.equals(r1)) {
	  return i;
	}
      }
    }
    return TOP_OF_TROUBLE; // Deliberately head for trouble...
  }
  /**
     Rollover the current file to a new file.
  */
  void rollOver() throws IOException {
    /* Compute filename, but only if datePattern is specified */
    if (datePattern == null) {
      errorHandler.error(""Missing DatePattern option in rollOver()."");
      return;
    }
    String datedFilename = fileName+sdf.format(now);
    if (scheduledFilename.equals(datedFilename)) {
      return;
    }
    // close current file, and rename it to datedFilename
    this.closeFile();
    File target  = new File(scheduledFilename);
    if (target.exists()) {
      target.delete();
    }
    File file = new File(fileName);
    file.renameTo(target);
    LogLog.debug(fileName +"" -> ""+ scheduledFilename);
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false, this.bufferedIO, this.bufferSize);
    }
    catch(IOException e) {
      errorHandler.error(""setFile(""+fileName+"", false) call failed."");
    }
    scheduledFilename = datedFilename;
  }
  /**
     This method differentiates DailyRollingFileAppender from its
     super class.
     <p>Before actually logging, this method will check whether it is
     time to do a rollover. If it is, it will schedule the next
     rollover time and then rollover.
  */
  protected
  void subAppend(LoggingEvent event) {
    long n = System.currentTimeMillis();
    if (n >= nextCheck) {
      now.setTime(n);
      nextCheck = rc.getNextCheckMillis(now);
      try {
	rollOver();
      }
      catch(IOException ioe) {
	LogLog.error(""rollOver() failed."", ioe);
      }
    }
    super.subAppend(event);
   }
}
/**
   RollingCalendar is a helper class to
   DailyRollingFileAppender. Using this class, it is easy to compute
   and access the next Millis().
   It subclasses the standard {@link GregorianCalendar}-object, to
   allow access to the protected function getTimeInMillis(), which it
   then exports.
   @author <a HREF=""mailto:eirik.lygre@evita.no"">Eirik Lygre</a> */
class RollingCalendar extends GregorianCalendar {
  int type = DailyRollingFileAppender.TOP_OF_TROUBLE;
  RollingCalendar() {
    super();
  }  
  RollingCalendar(TimeZone tz, Locale locale) {
    super(tz, locale);
  }  
  void setType(int type) {
    this.type = type;
  }
  public
  long getNextCheckMillis(Date now) {
    return getNextCheckDate(now).getTime();
  }
  public
  Date getNextCheckDate(Date now) {
    this.setTime(now);
    switch(type) {
    case DailyRollingFileAppender.TOP_OF_MINUTE:
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MINUTE, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_HOUR:
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.HOUR_OF_DAY, 1);
	break;
    case DailyRollingFileAppender.HALF_DAY:
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	int hour = get(Calendar.HOUR_OF_DAY);
	if(hour < 12) {
	  this.set(Calendar.HOUR_OF_DAY, 12);
	} else {
	  this.set(Calendar.HOUR_OF_DAY, 0);
	  this.add(Calendar.DAY_OF_MONTH, 1);
	}
	break;
    case DailyRollingFileAppender.TOP_OF_DAY:
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.DATE, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_WEEK:
	this.set(Calendar.DAY_OF_WEEK, getFirstDayOfWeek());
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.WEEK_OF_YEAR, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_MONTH:
	this.set(Calendar.DATE, 1);
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MONTH, 1);
	break;
    default:
	throw new IllegalStateException(""Unknown periodicity type."");
    }
    return getTime();
  }
}
"
org.apache.log4j.DefaultCategoryFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggerFactory;
class DefaultCategoryFactory implements LoggerFactory {
  DefaultCategoryFactory() {
  }    
  public
  Logger makeNewLoggerInstance(String name) {
    return new Logger(name);
  }    
}
"
org.apache.log4j.FileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileOutputStream;
import java.io.BufferedWriter;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>
//              Ben Sandee
/**
   FileAppender appends log events to a file.
   <p>Support for <code>java.io.Writer</code> and console appending
   has been deprecated and then removed. See the replacement
   solutions: {@link WriterAppender} and {@link ConsoleAppender}.
   @author Ceki G&uuml;lc&uuml; */
public class FileAppender extends WriterAppender {
  /** Append to or truncate the file? The default value for this
      variable is <code>true</code>, meaning that by default a
      <code>FileAppender</code> will append to an existing file and
      not truncate it.
      <p>This option is meaningful only if the FileAppender opens the
      file.
  */
  protected boolean fileAppend = true;
  /**
     The name of the log file. */
  protected String fileName = null;
  /**
     Do we do bufferedIO? */
  protected boolean bufferedIO = false;
  /**
     How big should the IO buffer be? Default is 8K. */
  protected int bufferSize = 8*1024;
  /**
     The default constructor does not do anything.
  */
  public
  FileAppender() {
  }
  /**
    Instantiate a <code>FileAppender</code> and open the file
    designated by <code>filename</code>. The opened filename will
    become the output destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file designated by
    <code>filename</code> will be truncated before being opened.
    <p>If the <code>bufferedIO</code> parameter is <code>true</code>,
    then buffered IO will be used to write to the output file.
  */
  public
  FileAppender(Layout layout, String filename, boolean append, boolean bufferedIO,
	       int bufferSize) throws IOException {
    this.layout = layout;
    this.setFile(filename, append, bufferedIO, bufferSize);
  }
  /**
    Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file designated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  FileAppender(Layout layout, String filename, boolean append)
                                                             throws IOException {
    this.layout = layout;
    this.setFile(filename, append, false, bufferSize);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }
  /**
     The <b>File</b> property takes a string value which should be the
     name of the file to append to.
     <p><font color=""#DD0044""><b>Note that the special values
     ""System.out"" or ""System.err"" are no longer honored.</b></font>
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.  */
  public void setFile(String file) {
    // Trim spaces from both ends. The users probably does not want
    // trailing spaces in file names.
    String val = file.trim();
    fileName = val;
  }
  /**
      Returns the value of the <b>Append</b> option.
   */
  public
  boolean getAppend() {
    return fileAppend;
  }
  /** Returns the value of the <b>File</b> option. */
  public
  String getFile() {
    return fileName;
  }
  /**
     If the value of <b>File</b> is not <code>null</code>, then {@link
     #setFile} is called with the values of <b>File</b>  and
     <b>Append</b> properties.
     @since 0.8.1 */
  public
  void activateOptions() {
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend, bufferedIO, bufferSize);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    } else {
      //LogLog.error(""File option not set for appender [""+name+""]."");
      LogLog.warn(""File option not set for appender [""+name+""]."");
      LogLog.warn(""Are you using FileAppender instead of ConsoleAppender?"");
    }
  }
 /**
     Closes the previously opened file.
  */
  protected
  void closeFile() {
    if(this.qw != null) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
	// Exceptionally, it does not make sense to delegate to an
	// ErrorHandler. Since a closed appender is basically dead.
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }
  /**
     Get the value of the <b>BufferedIO</b> option.
     <p>BufferedIO will significatnly increase performance on heavily
     loaded systems.
  */
  public
  boolean getBufferedIO() {
    return this.bufferedIO;
  }
  /**
     Get the size of the IO buffer.
  */
  public
  int getBufferSize() {
    return this.bufferSize;
  }
  /**
     The <b>Append</b> option takes a boolean value. It is set to
     <code>true</code> by default. If true, then <code>File</code>
     will be opened in append mode by {@link #setFile setFile} (see
     above). Otherwise, {@link #setFile setFile} will open
     <code>File</code> in truncate mode.
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
   */
  public
  void setAppend(boolean flag) {
    fileAppend = flag;
  }
  /**
     The <b>BufferedIO</b> option takes a boolean value. It is set to
     <code>false</code> by default. If true, then <code>File</code>
     will be opened and the resulting {@link java.io.Writer} wrapped
     around a {@link BufferedWriter}.
     BufferedIO will significatnly increase performance on heavily
     loaded systems.
  */
  public
  void setBufferedIO(boolean bufferedIO) {
    this.bufferedIO = bufferedIO;
    if(bufferedIO) {
      immediateFlush = false;
    }
  }
  /**
     Set the size of the IO buffer.
  */
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
  }
  /**
    <p>Sets and <i>opens</i> the file where the log output will
    go. The specified file must be writable.
    <p>If there was already an opened file, then the previous file
    is closed first.
    <p><b>Do not use this method directly. To configure a FileAppender
    or one of its subclasses, set its properties one by one and then
    call activateOptions.</b>
    @param fileName The path to the log file.
    @param append   If true will append to fileName. Otherwise will
        truncate fileName.  */
  public
  synchronized
  void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)
                                                            throws IOException {
    LogLog.debug(""setFile called: ""+fileName+"", ""+append);
    // It does not make sense to have immediate flush and bufferedIO.
    if(bufferedIO) {
      setImmediateFlush(false);
    }
    reset();
    Writer fw = createWriter(new FileOutputStream(fileName, append));
    if(bufferedIO) {
      fw = new BufferedWriter(fw, bufferSize);
    }
    this.setQWForFiles(fw);
    this.fileName = fileName;
    this.fileAppend = append;
    this.bufferedIO = bufferedIO;
    this.bufferSize = bufferSize;
    writeHeader();
    LogLog.debug(""setFile ended"");
  }
  /**
     Sets the quiet writer being used.
     This method is overriden by {@link RollingFileAppender}.
   */
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }
  /**
     Close any previously opened file and call the parent's
     <code>reset</code>.  */
  protected
  void reset() {
    closeFile();
    this.fileName = null;
    super.reset();
  }
}
"
org.apache.log4j.Hierarchy,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// WARNING This class MUST not have references to the Category or
// WARNING RootCategory classes in its static initiliazation neither
// WARNING directly nor indirectly.
// Contributors:
//                Luke Blanshard <luke@quiq.com>
//                Mario Schomburg - IBM Global Services/Germany
//                Anders Kristensen
//                Igor Poteryaev
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.HierarchyEventListener;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.Appender;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.helpers.LogLog;
/**
   This class is specialized in retrieving loggers by name and also
   maintaining the logger hierarchy.
   <p><em>The casual user does not have to deal with this class
   directly.</em>
   <p>The structure of the logger hierarchy is maintained by the
   {@link #getLogger} method. The hierarchy is such that children link
   to their parent but parents do not have any pointers to their
   children. Moreover, loggers can be instantiated in any order, in
   particular descendant before ancestor.
   <p>In case a descendant is created before a particular ancestor,
   then it creates a provision node for the ancestor and adds itself
   to the provision node. Other descendants of the same ancestor add
   themselves to the previously created provision node.
   @author Ceki G&uuml;lc&uuml;
*/
public class Hierarchy implements LoggerRepository, RendererSupport {
  private LoggerFactory defaultFactory;
  private Vector listeners;
  Hashtable ht;
  Logger root;
  RendererMap rendererMap;
  int thresholdInt;
  Level threshold;
  boolean emittedNoAppenderWarning = false;
  boolean emittedNoResourceBundleWarning = false;
  /**
     Create a new logger hierarchy.
     @param root The root of the new hierarchy.
   */
  public
  Hierarchy(Logger root) {
    ht = new Hashtable();
    listeners = new Vector(1);
    this.root = root;
    // Enable all level levels by default.
    setThreshold(Level.ALL);
    this.root.setHierarchy(this);
    rendererMap = new RendererMap();
    defaultFactory = new DefaultCategoryFactory();
  }
  /**
     Add an object renderer for a specific class.
   */
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }
  public
  void addHierarchyEventListener(HierarchyEventListener listener) {
    if(listeners.contains(listener)) {
      LogLog.warn(""Ignoring attempt to add an existent listener."");
    } else {
      listeners.addElement(listener);
    }
  }
  /**
     This call will clear all logger definitions from the internal
     hashtable. Invoking this method will irrevocably mess up the
     logger hierarchy.
     <p>You should <em>really</em> know what you are doing before
     invoking this method.
     @since 0.9.0 */
  public
  void clear() {
    //System.out.println(""\n\nAbout to clear internal hash table."");
    ht.clear();
  }
  public
  void emitNoAppenderWarning(Category cat) {
    // No appenders in hierarchy, warn user only once.
    if(!this.emittedNoAppenderWarning) {
      LogLog.warn(""No appenders could be found for logger ("" +
		   cat.getName() + "")."");
      LogLog.warn(""Please initialize the log4j system properly."");
      this.emittedNoAppenderWarning = true;
    }
  }
  /**
     Check if the named logger exists in the hierarchy. If so return
     its reference, otherwise returns <code>null</code>.
     @param name The name of the logger to search for.
  */
  public
  Logger exists(String name) {
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Logger) {
      return (Logger) o;
    } else {
      return null;
    }
  }
  /**
     The string form of {@link #setThreshold(Level)}.
  */
  public
  void setThreshold(String levelStr) {
    Level l = (Level) Level.toLevel(levelStr, null);
    if(l != null) {
      setThreshold(l);
    } else {
      LogLog.warn(""Could not convert [""+levelStr+""] to Level."");
    }
  }
  /**
     Enable logging for logging requests with level <code>l</code> or
     higher. By default all levels are enabled.
     @param l The minimum level for which logging requests are sent to
     their appenders.  */
  public
  void setThreshold(Level l) {
    if(l != null) {
      thresholdInt = l.level;
      threshold = l;
    }
  }
  public
  void fireAddAppenderEvent(Category logger, Appender appender) {
    if(listeners != null) {
      int size = listeners.size();
      HierarchyEventListener listener;
      for(int i = 0; i < size; i++) {
	listener = (HierarchyEventListener) listeners.elementAt(i);
	listener.addAppenderEvent(logger, appender);
      }
    }
  }
  void fireRemoveAppenderEvent(Category logger, Appender appender) {
    if(listeners != null) {
      int size = listeners.size();
      HierarchyEventListener listener;
      for(int i = 0; i < size; i++) {
	listener = (HierarchyEventListener) listeners.elementAt(i);
	listener.removeAppenderEvent(logger, appender);
      }
    }
  }
  /**
     Returns a {@link Level} representation of the <code>enable</code>
     state.
     @since 1.2 */
  public
  Level getThreshold() {
    return threshold;
  }
  /**
     Returns an integer representation of the this repository's
     threshold.
     @since 1.2 */
  //public
  //int getThresholdInt() {
  //  return thresholdInt;
  //}
  /**
     Return a new logger instance named as the first parameter using
     the default factory.
     <p>If a logger of that name already exists, then it will be
     returned.  Otherwise, a new logger will be instantiated and
     then linked with its existing ancestors as well as children.
     @param name The name of the logger to retrieve.
 */
  public
  Logger getLogger(String name) {
    return getLogger(name, defaultFactory);
  }
 /**
     Return a new logger instance named as the first parameter using
     <code>factory</code>.
     <p>If a logger of that name already exists, then it will be
     returned.  Otherwise, a new logger will be instantiated by the
     <code>factory</code> parameter and linked with its existing
     ancestors as well as children.
     @param name The name of the logger to retrieve.
     @param factory The factory that will make the new logger instance.
 */
  public
  Logger getLogger(String name, LoggerFactory factory) {
    //System.out.println(""getInstance(""+name+"") called."");
    CategoryKey key = new CategoryKey(name);
    // Synchronize to prevent write conflicts. Read conflicts (in
    // getChainedLevel method) are possible only if variable
    // assignments are non-atomic.
    Logger logger;
    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	logger = factory.makeNewLoggerInstance(name);
	logger.setHierarchy(this);
	ht.put(key, logger);
	updateParents(logger);
	return logger;
      } else if(o instanceof Logger) {
	return (Logger) o;
      } else if (o instanceof ProvisionNode) {
	//System.out.println(""(""+name+"") ht.get(this) returned ProvisionNode"");
	logger = factory.makeNewLoggerInstance(name);
	logger.setHierarchy(this);
	ht.put(key, logger);
	updateChildren((ProvisionNode) o, logger);
	updateParents(logger);
	return logger;
      }
      else {
	// It should be impossible to arrive here
	return null;  // but let's keep the compiler happy.
      }
    }
  }
  /**
     Returns all the currently defined categories in this hierarchy as
     an {@link java.util.Enumeration Enumeration}.
     <p>The root logger is <em>not</em> included in the returned
     {@link Enumeration}.  */
  public
  Enumeration getCurrentLoggers() {
    // The accumlation in v is necessary because not all elements in
    // ht are Logger objects as there might be some ProvisionNodes
    // as well.
    Vector v = new Vector(ht.size());
    Enumeration elems = ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Logger) {
	v.addElement(o);
      }
    }
    return v.elements();
  }
  /**
     @deprecated Please use {@link #getCurrentLoggers} instead.
   */
  public
  Enumeration getCurrentCategories() {
    return getCurrentLoggers();
  }
  /**
     Get the renderer map for this hierarchy.
  */
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }
  /**
     Get the root of this hierarchy.
     @since 0.9.0
   */
  public
  Logger getRootLogger() {
    return root;
  }
  /**
     This method will return <code>true</code> if this repository is
     disabled for <code>level</code> object passed as parameter and
     <code>false</code> otherwise. See also the {@link
     #setThreshold(Level) threshold} emthod.  */
  public
  boolean isDisabled(int level) {
    return thresholdInt > level;
  }
  /**
     @deprecated Deprecated with no replacement.
  */
  public
  void overrideAsNeeded(String override) {
    LogLog.warn(""The Hiearchy.overrideAsNeeded method has been deprecated."");
  }
  /**
     Reset all values contained in this hierarchy instance to their
     default.  This removes all appenders from all categories, sets
     the level of all non-root categories to <code>null</code>,
     sets their additivity flag to <code>true</code> and sets the level
     of the root logger to {@link Level#DEBUG DEBUG}.  Moreover,
     message disabling is set its default ""off"" value.
     <p>Existing categories are not removed. They are just reset.
     <p>This method should be used sparingly and with care as it will
     block all logging until it is completed.</p>
     @since 0.8.5 */
  public
  void resetConfiguration() {
    getRootLogger().setLevel((Level) Level.DEBUG);
    root.setResourceBundle(null);
    setThreshold(Level.ALL);
    // the synchronization is needed to prevent JDK 1.2.x hashtable
    // surprises
    synchronized(ht) {
      shutdown(); // nested locks are OK
      Enumeration cats = getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.setLevel(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    rendererMap.clear();
  }
  /**
     Does mothing.
     @deprecated Deprecated with no replacement.
   */
  public
  void setDisableOverride(String override) {
    LogLog.warn(""The Hiearchy.setDisableOverride method has been deprecated."");
  }
  /**
     Used by subclasses to add a renderer to the hierarchy passed as parameter.
   */
  public
  void setRenderer(Class renderedClass, ObjectRenderer renderer) {
    rendererMap.put(renderedClass, renderer);
  }
  /**
     Shutting down a hierarchy will <em>safely</em> close and remove
     all appenders in all categories including the root logger.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a logger
     and again to a nested appender.
     @since 1.0 */
  public
  void shutdown() {
    Logger root = getRootLogger();
    // begin by closing nested appenders
    root.closeNestedAppenders();
    synchronized(ht) {
      Enumeration cats = this.getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.closeNestedAppenders();
      }
      // then, remove all appenders
      root.removeAllAppenders();
      cats = this.getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.removeAllAppenders();
      }
    }
  }
  /**
     This method loops through all the *potential* parents of
     'cat'. There 3 possible cases:
     1) No entry for the potential parent of 'cat' exists
        We create a ProvisionNode for this potential parent and insert
        'cat' in that provision node.
     2) There entry is of type Logger for the potential parent.
        The entry is 'cat's nearest existing parent. We update cat's
        parent field with this entry. We also break from the loop
        because updating our parent's parent is our parent's
        responsibility.
     3) There entry is of type ProvisionNode for this potential parent.
        We add 'cat' to the list of children for this potential parent.
   */
  final
  private
  void updateParents(Logger cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;
    //System.out.println(""UpdateParents called for "" + name);
    // if name = ""w.x.y.z"", loop thourgh ""w.x.y"", ""w.x"" and ""w"", but not ""w.x.y.z""
    for(int i = name.lastIndexOf('.', length-1); i >= 0;
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);
      //System.out.println(""Updating parent : "" + substr);
      CategoryKey key = new CategoryKey(substr); // simple constructor
      Object o = ht.get(key);
      // Create a provision node for a future parent.
      if(o == null) {
	//System.out.println(""No parent ""+substr+"" found. Creating ProvisionNode."");
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      } else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	//System.out.println(""Linking "" + cat.name + "" -> "" + ((Category) o).name);
	break; // no need to update the ancestors of the closest ancestor
      } else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      } else {
	Exception e = new IllegalStateException(""unexpected object type "" +
					o.getClass() + "" in ht."");
	e.printStackTrace();
      }
    }
    // If we could not find any existing parents, then link with root.
    if(!parentFound)
      cat.parent = root;
  }
  /**
      We update the links for all the children that placed themselves
      in the provision node 'pn'. The second argument 'cat' is a
      reference for the newly created Logger, parent of all the
      children in 'pn'
      We loop on all the children 'c' in 'pn':
         If the child 'c' has been already linked to a child of
         'cat' then there is no need to update 'c'.
	 Otherwise, we set cat's parent field to c's parent and set
	 c's parent field to cat.
  */
  final
  private
  void updateChildren(ProvisionNode pn, Logger logger) {
    //System.out.println(""updateChildren called for "" + logger.name);
    final int last = pn.size();
    for(int i = 0; i < last; i++) {
      Logger l = (Logger) pn.elementAt(i);
      //System.out.println(""Updating child "" +p.name);
      // Unless this child already points to a correct (lower) parent,
      // make cat.parent point to l.parent and l.parent to cat.
      if(!l.parent.name.startsWith(logger.name)) {
	logger.parent = l.parent;
	l.parent = logger;
      }
    }
  }
}
"
org.apache.log4j.HTMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.Transform;
/**
   This layout outputs events in a HTML table.
   @author Ceki G&uuml;lc&uuml;
 */
public class HTMLLayout extends Layout {
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  /**
     A string constant used in naming the option for setting the the
     HTML document title.  Current value of this string
     constant is <b>Title</b>.
  */
  public static final String TITLE_OPTION = ""Title"";
  // Print no location info by default
  boolean locationInfo = false;
  String title = ""Log4J Log Messages"";
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output.
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
    The <b>Title</b> option takes a String value. This option sets the
    document title of the generated HTML document.
    <p>Defaults to 'Log4J Log Messages'.
  */
  public
  void setTitle(String title) {
    this.title = title;
  }
  /**
     Returns the current value of the <b>Title</b> option.
  */
  public
  String getTitle() {
    return title;
  }
 /**
     Returns the content type output by this layout, i.e ""text/html"".
  */
  public
  String getContentType() {
    return ""text/html"";
  }
  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }
  public
  String format(LoggingEvent event) {
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    sbuf.append(Layout.LINE_SEP + ""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - event.getStartTime());
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\"""" + event.getThreadName() + "" thread\"">"");
    sbuf.append(Transform.escapeTags(event.getThreadName()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\""Level\"">"");
    if (event.level.equals(Level.DEBUG)) {
      sbuf.append(""<font color=\""#339933\"">"");
      sbuf.append(event.level);
      sbuf.append(""</font>"");
    }
    else if(event.level.isGreaterOrEqual(Level.WARN)) {
      sbuf.append(""<font color=\""#993300\""><strong>"");
      sbuf.append(event.level);
      sbuf.append(""</strong></font>"");
    } else {
      sbuf.append(event.level);
    }
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\"""" + event.categoryName + "" category\"">"");
    sbuf.append(Transform.escapeTags(event.categoryName));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    if(locationInfo) {
      LocationInfo locInfo = event.getLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(Transform.escapeTags(locInfo.getFileName()));
      sbuf.append(':');
      sbuf.append(locInfo.getLineNumber());
      sbuf.append(""</td>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<td title=\""Message\"">"");
    sbuf.append(Transform.escapeTags(event.getRenderedMessage()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    if (event.getNDC() != null) {
      sbuf.append(""<tr><td bgcolor=\""#EEEEEE\"" style=\""font-size : xx-small;\"" colspan=\""6\"" title=\""Nested Diagnostic Context\"">"");
      sbuf.append(""NDC: "" + Transform.escapeTags(event.getNDC()));
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }
    String[] s = event.getThrowableStrRep();
    if(s != null) {
      sbuf.append(""<tr><td bgcolor=\""#993300\"" style=\""color:White; font-size : xx-small;\"" colspan=\""6\"">"");
      appendThrowableAsHTML(s, sbuf);
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }
    return sbuf.toString();
  }
  void appendThrowableAsHTML(String[] s, StringBuffer sbuf) {
    if(s != null) {
      int len = s.length;
      if(len == 0)
	return;
      sbuf.append(Transform.escapeTags(s[0]));
      sbuf.append(Layout.LINE_SEP);
      for(int i = 1; i < len; i++) {
	sbuf.append(TRACE_PREFIX);
	sbuf.append(Transform.escapeTags(s[i]));
	sbuf.append(Layout.LINE_SEP);
      }
    }
  }
  /**
     Returns appropriate HTML headers.
  */
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" \""http://www.w3.org/TR/html4/loose.dtd\"">""  + Layout.LINE_SEP);
    sbuf.append(""<html>"" + Layout.LINE_SEP);
    sbuf.append(""<head>"" + Layout.LINE_SEP);
    sbuf.append(""<title>"" + title + ""</title>"" + Layout.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">""  + Layout.LINE_SEP);
    sbuf.append(""<!--""  + Layout.LINE_SEP);
    sbuf.append(""body, table {font-family: arial,sans-serif; font-size: x-small;}"" + Layout.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"" + Layout.LINE_SEP);
    sbuf.append(""-->"" + Layout.LINE_SEP);
    sbuf.append(""</style>"" + Layout.LINE_SEP);
    sbuf.append(""</head>"" + Layout.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"" + Layout.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"" + Layout.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"" + Layout.LINE_SEP);
    sbuf.append(""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Time</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Thread</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Level</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Category</th>"" + Layout.LINE_SEP);
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    return sbuf.toString();
  }
  /**
     Returns the appropriate HTML footers.
  */
  public
  String getFooter() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""</table>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""</body></html>"");
    return sbuf.toString();
  }
  /**
     The HTML layout handles the throwable contained in logging
     events. Hence, this method return <code>false</code>.  */
  public
  boolean ignoresThrowable() {
    return false;
  }
}
"
org.apache.log4j.Layout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   Extend this abstract class to create your own log layout format.
   @author Ceki G&uuml;lc&uuml;
*/
public abstract class Layout implements OptionHandler {
  // Note that the line.separator property can be looked up even by
  // applets.
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();
  /**
     Implement this method to create your own layout format.
  */
  abstract
  public
  String format(LoggingEvent event);
  /**
     Returns the content type output by this layout. The base class
     returns ""text/plain"". 
  */
  public
  String getContentType() {
    return ""text/plain"";
  }
  /**
     Returns the header for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getHeader() {
    return null;
  }
  /**
     Returns the footer for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getFooter() {
    return null;
  }
  /**
     If the layout handles the throwable object contained within
     {@link LoggingEvent}, then the layout should return
     <code>false</code>. Otherwise, if the layout ignores throwable
     object, then the layout should return <code>true</code>.
     <p>The {@link SimpleLayout}, {@link TTCCLayout}, {@link
     PatternLayout} all return <code>true</code>. The {@link
     org.apache.log4j.xml.XMLLayout} returns <code>false</code>.
     @since 0.8.4 */
  abstract
  public
  boolean ignoresThrowable();
}
"
org.apache.log4j.Level,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// Contributors:  Kitching Simon <Simon.Kitching@orange.ch>
//                Nicholas Wolff
package org.apache.log4j;
/**
   Defines the minimum set of levels recognized by the system, that is
   <code>OFF</code>, <code>FATAL</code>, <code>ERROR</code>,
   <code>WARN</code>, <code>INFO</code, <code>DEBUG</code> and
   <code>ALL</code>.
   <p>The <code>Level</code> class may be subclassed to define a larger
   level set.
   @author Ceki G&uuml;lc&uuml;
 */
public class Level extends Priority {
  /**
     The <code>OFF</code> has the highest possible rank and is
     intended to turn off logging.  */
  final static public Level OFF = new Level(OFF_INT, ""OFF"", 0);
  /**
     The <code>FATAL</code> level designates very severe error
     events that will presumably lead the application to abort.
   */
  final static public Level FATAL = new Level(FATAL_INT, ""FATAL"", 0);
  /**
     The <code>ERROR</code> level designates error events that
     might still allow the application to continue running.  */
  final static public Level ERROR = new Level(ERROR_INT, ""ERROR"", 3);
  /**
     The <code>WARN</code> level designates potentially harmful situations.
  */
  final static public Level WARN  = new Level(WARN_INT, ""WARN"",  4);
  /**
     The <code>INFO</code> level designates informational messages
     that highlight the progress of the application at coarse-grained
     level.  */
  final static public Level INFO  = new Level(INFO_INT, ""INFO"",  6);
  /**
     The <code>DEBUG</code> Level designates fine-grained
     informational events that are most useful to debug an
     application.  */
  final static public Level DEBUG = new Level(DEBUG_INT, ""DEBUG"", 7);
  /**
     The <code>ALL</code> has the lowest possible rank and is intended to
     turn on all logging.  */
  final static public Level ALL = new Level(ALL_INT, ""ALL"", 7);
  /**
     Instantiate a Level object.
   */
  protected
  Level(int level, String levelStr, int syslogEquivalent) {
    super(level, levelStr, syslogEquivalent);
  }
  /**
     Convert the string passed as argument to a level. If the
     conversion fails, then this method returns {@link #DEBUG}. 
  */
  public
  static
  Level toLevel(String sArg) {
    return (Level) toLevel(sArg, Level.DEBUG);
  }
  /**
    Convert an integer passed as argument to a level. If the
    conversion fails, then this method returns {@link #DEBUG}.
  */
  public
  static
  Level toLevel(int val) {
    return (Level) toLevel(val, Level.DEBUG);
  }
  /**
    Convert an integer passed as argument to a level. If the
    conversion fails, then this method returns the specified default.
  */
  public
  static
  Level toLevel(int val, Level defaultLevel) {
    switch(val) {
    case ALL_INT: return ALL;
    case DEBUG_INT: return Level.DEBUG;
    case INFO_INT: return Level.INFO;
    case WARN_INT: return Level.WARN;
    case ERROR_INT: return Level.ERROR;
    case FATAL_INT: return Level.FATAL;
    case OFF_INT: return OFF;
    default: return defaultLevel;
    }
  }
  /**
     Convert the string passed as argument to a level. If the
     conversion fails, then this method returns the value of
     <code>defaultLevel</code>.  
  */
  public
  static
  Level toLevel(String sArg, Level defaultLevel) {                  
    if(sArg == null)
       return defaultLevel;
    String s = sArg.toUpperCase();
    if(s.equals(""ALL"")) return Level.ALL; 
    if(s.equals(""DEBUG"")) return Level.DEBUG; 
    //if(s.equals(""FINE"")) return Level.FINE; 
    if(s.equals(""INFO""))  return Level.INFO;
    if(s.equals(""WARN""))  return Level.WARN;  
    if(s.equals(""ERROR"")) return Level.ERROR;
    if(s.equals(""FATAL"")) return Level.FATAL;
    if(s.equals(""OFF"")) return Level.OFF;
    return defaultLevel;
  }
}
"
org.apache.log4j.Logger,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggerFactory;
/**
  This is the central class in the log4j package. Most logging
  operations, except configuration, are done through this class.
  @since log4j 1.2
  @author Ceki G&uuml;lc&uuml; */
public class Logger extends Category {
  /**
     The fully qualified name of the Level class. See also the
     getFQCN method. */
  private static final String FQCN = Level.class.getName();
  protected
  Logger(String name) {
    super(name);
  }
  /**
    Log a message object with the {@link Level#FINE FINE} level which
    is just an alias for the {@link Level#DEBUG DEBUG} level.
    <p>This method first checks if this category is <code>DEBUG</code>
    enabled by comparing the level of this category with the {@link
    Level#DEBUG DEBUG} level. If this category is
    <code>DEBUG</code> enabled, then it converts the message object
    (passed as parameter) to a string by invoking the appropriate
    {@link org.apache.log4j.or.ObjectRenderer}. It then proceeds to call all the
    registered appenders in this category and also higher in the
    hierarchy depending on the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #debug(Object,
    Throwable)} form instead.
    @param message the message object to log. */
  //public
  //void fine(Object message) {
  //  if(repository.isDisabled(Level.DEBUG_INT))
  //	return;
  //  if(Level.DEBUG.isGreaterOrEqual(this.getChainedLevel())) {
  //	forcedLog(FQCN, Level.DEBUG, message, null);
  //  }
  //}
  /**
   Log a message object with the <code>FINE</code> level including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #fine(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  //public
  //void fine(Object message, Throwable t) {
  //  if(repository.isDisabled(Level.DEBUG_INT))
  //	return;
  //  if(Level.DEBUG.isGreaterOrEqual(this.getChainedLevel()))
  //	forcedLog(FQCN, Level.FINE, message, t);
  //}
  /**
     Retrieve a logger by name.
  */
  static
  public
  Logger getLogger(String name) {
    return LogManager.getLogger(name);
  }
  /**
     Same as calling <code>getLogger(clazz.getName())</code>.
   */
  static
  public
  Logger getLogger(Class clazz) {
    return LogManager.getLogger(clazz.getName());
  }
  /**
     Retrieve the root logger.
   */
  public
  static
  Logger getRootLogger() {
    return LogManager.getRootLogger();
  }
  /**
     Like {@link #getLogger(String)} except that the type of logger
     instantiated depends on the type returned by the {@link
     LoggerFactory#makeNewLoggerInstance} method of the
     <code>factory</code> parameter.
     <p>This method is intended to be used by sub-classes.
     @param name The name of the logger to retrieve.
     @param factory A {@link LoggerFactory} implementation that will
     actually create a new Instance.
     @since 0.8.5 */
  public
  static
  Logger getLogger(String name, LoggerFactory factory) {
    return LogManager.getLogger(name, factory);
  }
}
"
org.apache.log4j.LogManager,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.RepositorySelector;
import org.apache.log4j.spi.DefaultRepositorySelector;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.Enumeration;
/**
  Use the <code>LogManager</code> to retreive instances of {@link Logger}.
  @author Ceki G&uuml;lc&uuml;
*/
public class LogManager {
  /**
     This string constant is set to <b>log4j.properties</b> the name
     of the file that will be searched by default in classpath. If the
     file can be found, then it is fed to the {@link
     PropertyConfigurator}.
     See also {@link #DEFAULT_CONFIGURATION_KEY} for a more general
     alternative.
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     @since 0.8.5 */
     static public final String DEFAULT_CONFIGURATION_FILE = ""log4j.properties"";
  /**
     This string constant is set to <b>log4j.configuration</b>. 
     <p>It corresponds to name of a system property that, if set,
     specifies the name of the resource containing the properties file
     or {@link URL} with which log4j should configure itself. See
     {@link OptionConverter#selectAndConfigure} for more detailed
     information on the processing of this option.
     <p>Setting the <b>log4j.configuration</b> system property
     overrides the default search for the file <b>log4j.properties</b>.
     <p>Note that all property keys are case sensitive.  
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     @since 1.0 */
     static final public String DEFAULT_CONFIGURATION_KEY=""log4j.configuration"";
 /**
     This string constant is set to <b>log4j.configuratorClass</b>. 
     <p>It corresponds to name of a system property that, if set,
     specifies the class name to use to automatically configure
     log4j. See {@link OptionConverter#selectAndConfigure} for more
     detailed information on the processing of this option.
     <p>Setting the <b>log4j.configuration</b> system property
     overrides the default search for the file <b>log4j.properties</b>.
     <p>Note that all property keys are case sensitive.  
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     @since 1.2 */
     static final public String CONFIGURATOR_CLASS_KEY=""log4j.configuratorClass"";
  /**
      Setting the system property <b>log4j.defaultInitOverride</b> to
      ""true"" or any other value than ""false"" will skip default
      configuration process.
     <p>The current value of the DEFAULT_INIT_OVERRIDE_KEY string
     constant is <b>log4j.defaultInitOverride</b>.
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     <p>Note that all property keys are case sensitive.  
     @since 0.8.5 */
  public static final String DEFAULT_INIT_OVERRIDE_KEY = 
                                                 ""log4j.defaultInitOverride"";
  static private Object guard = null;
  static private RepositorySelector repositorySelector;
  static {
    // By default we use a DefaultRepositorySelector which always returns 'h'.
    Hierarchy h = new Hierarchy(new RootCategory((Level) Level.DEBUG));
    repositorySelector = new DefaultRepositorySelector(h);
    /** Search for the properties file log4j.properties in the CLASSPATH.  */
    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,
						       null);
    // if there is no default init override, them get the resource
    // specified by the user or the default config file.
    if(override == null || ""false"".equalsIgnoreCase(override)) {
      String resource = OptionConverter.getSystemProperty(
						  DEFAULT_CONFIGURATION_KEY, 
						  DEFAULT_CONFIGURATION_FILE);
      String configuratorClassName = OptionConverter.getSystemProperty(
                                                   CONFIGURATOR_CLASS_KEY, 
						   null);
      URL url = null;
      try {
	// so, resource is not a URL:
	// attempt to get the resource from the class path
	url = new URL(resource);
      } catch (MalformedURLException ex) {
	url = Loader.getResource(resource); 
      }	
      // If we have a non-null url, then delegate the rest of the
      // configuration to the OptionConverter.selectAndConfigure
      // method.
      if(url != null) {
	LogLog.debug(""Using URL [""+url+""] for automatic log4j configuration."");        
	OptionConverter.selectAndConfigure(url, configuratorClassName, 
					   LogManager.getLoggerRepository());
      } else {
	LogLog.debug(""Could not find resource: [""+resource+""]."");
      }
    }  
  } 
  /**
     Sets <code>LoggerFactory</code> but only if the correct
     <em>guard</em> is passed as parameter.
     <p>Initally the guard is null.  If the guard is
     <code>null</code>, then invoking this method sets the logger
     factory and the guard. Following invocations will throw a {@link
     IllegalArgumentException}, unless the previously set
     <code>guard</code> is passed as the second parameter.
     <p>This allows a high-level component to set the {@link
     RepositorySelector} used by the <code>LogManager</code>.
     <p>For example, when tomcat starts it will be able to install its
     own repository selector. However, if and when Tomcat is embedded
     within JBoss, then JBoss will install its own repository selector
     and Tomcat will use the repository selector set by its container,
     JBoss.  */
  static
  public
  void setRepositorySelector(RepositorySelector selector, Object guard) 
                                                 throws IllegalArgumentException {
    if((LogManager.guard != null) && (LogManager.guard != guard)) {
      throw new IllegalArgumentException(
           ""Attempted to reset the LoggerFactory without possessing the guard."");
    }
    if(selector == null) {
      throw new IllegalArgumentException(""RepositorySelector must be non-null."");
    }
    LogManager.guard = guard;
    LogManager.repositorySelector = selector;
  }
  static
  public
  LoggerRepository getLoggerRepository() {
    return repositorySelector.getLoggerRepository();
  }
  /**
     Retrieve the appropriate root logger.
   */
  public
  static 
  Logger getRootLogger() {
     // Delegate the actual manufacturing of the logger to the logger repository.
    return repositorySelector.getLoggerRepository().getRootLogger();
  }
  /**
     Retrieve the appropriate {@link Logger} instance.  
  */
  public
  static 
  Logger getLogger(String name) {
     // Delegate the actual manufacturing of the logger to the logger repository.
    return repositorySelector.getLoggerRepository().getLogger(name);
  }
 /**
     Retrieve the appropriate {@link Logger} instance.  
  */
  public
  static 
  Logger getLogger(Class clazz) {
     // Delegate the actual manufacturing of the logger to the logger repository.
    return repositorySelector.getLoggerRepository().getLogger(clazz.getName());
  }
  /**
     Retrieve the appropriate {@link Logger} instance.  
  */
  public
  static 
  Logger getLogger(String name, LoggerFactory factory) {
     // Delegate the actual manufacturing of the logger to the logger repository.
    return repositorySelector.getLoggerRepository().getLogger(name, factory);
  }  
  public
  static
  Logger exists(String name) {
    return repositorySelector.getLoggerRepository().exists(name);
  }
  public
  static
  Enumeration getCurrentLoggers() {
    return repositorySelector.getLoggerRepository().getCurrentLoggers();
  }
  public
  static
  void shutdown() {
    repositorySelector.getLoggerRepository().shutdown();
  }
  public
  static
  void resetConfiguration() {
    repositorySelector.getLoggerRepository().resetConfiguration();
  }
}
"
org.apache.log4j.MDC,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j;
import java.util.Hashtable;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.ThreadLocalMap;
/**
   The MDC class is similar to the {@link NDC} class except that it is
   based on a map instead of a stack. It provides <em>mapped
   diagnostic contexts</em>. A <em>Mapped Diagnostic Context</em>, or
   MDC in short, is an instrument for distinguishing interleaved log
   output from different sources. Log output is typically interleaved
   when a server handles multiple clients near-simultaneously.
   <p><b><em>The MDC is managed on a per thread basis</em></b>. A
   child thread automatically inherits a <em>copy</em> of the mapped
   diagnostic context of its parent.
   <p>The MDC class requires JDK 1.2 or above. Under JDK 1.1 the MDC
   will always return empty values but otherwise will not affect or
   harm your application.
   @since 1.2
   @author Ceki G&uuml;lc&uuml; */
public class MDC {
  final static MDC mdc = new MDC();
  static final int HT_SIZE = 7;
  boolean java1;
  Object tlm;
  private
  MDC() {
    java1 = Loader.isJava1();
    if(!java1) {
      tlm = new ThreadLocalMap();
    }
  }
  /**
     Put a context value (the <code>o</code> parameter) as identified
     with the <code>key</code> parameter into the current thread's
     context map.
     <p>If the current thread does not have a context map it is
     created as a side effect.
   */
  static
  public
  void put(String key, Object o) {
    mdc.put0(key, o);
  }
  /**
     Get the context identified by the <code>key</code> parameter.
     <p>This method has no side effects.
   */
  static 
  public
  Object get(String key) {
    return mdc.get0(key);
  }
  /**
     Remove the the context identified by the <code>key</code>
     parameter.
  */
  static 
  public
  void remove(String key) {
    mdc.remove0(key);
  }
  /**
     Get the current thread's MDC as a hashtable.
   */
  public
  static
  Hashtable getContext() {
    return mdc.getContext0();
  }
  private
  void put0(String key, Object o) {
    if(java1) {
      return;
    } else {
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht == null) {
	ht = new Hashtable(HT_SIZE);
	((ThreadLocalMap)tlm).set(ht);
      }    
      ht.put(key, o);
    }
  }
  private
  Object get0(String key) {
    if(java1) {
      return null;
    } else {       
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht != null) {
	return ht.get(key);
      } else {
	return null;
      }
    }
  }
  private
  void remove0(String key) {
    if(!java1) {
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht != null) {
	ht.remove(key);
      } 
    }
  }
  private
  Hashtable getContext0() {
     if(java1) {
      return null;
    } else {       
      return (Hashtable) ((ThreadLocalMap)tlm).get();
    }
  }
}
"
org.apache.log4j.NDC,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
//      Contributors:      Dan Milstein 
//                         Ray Millard
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.log4j.helpers.LogLog;
/**
   The NDC class implements <i>nested diagnostic contexts</i> as
   defined by Neil Harrison in the article ""Patterns for Logging
   Diagnostic Messages"" part of the book ""<i>Pattern Languages of
   Program Design 3</i>"" edited by Martin et al.
   <p>A Nested Diagnostic Context, or NDC in short, is an instrument
   to distinguish interleaved log output from different sources. Log
   output is typically interleaved when a server handles multiple
   clients near-simultaneously.
   <p>Interleaved log output can still be meaningful if each log entry
   from different contexts had a distinctive stamp. This is where NDCs
   come into play.
   <p><em><b>Note that NDCs are managed on a per thread
   basis</b></em>. NDC operations such as {@link #push push}, {@link
   #pop}, {@link #clear}, {@link #getDepth} and {@link #setMaxDepth}
   affect the NDC of the <em>current</em> thread only. NDCs of other
   threads remain unaffected.
   <p>For example, a servlet can build a per client request NDC
   consisting the clients host name and other information contained in
   the the request. <em>Cookies</em> are another source of distinctive
   information. To build an NDC one uses the {@link #push push}
   operation. Simply put,
   <p><ul>
     <li>Contexts can be nested.
     <p><li>When entering a context, call <code>NDC.push</code>. As a
     side effect, if there is no nested diagnostic context for the
     current thread, this method will create it.
     <p><li>When leaving a context, call <code>NDC.pop</code>.
     <p><li><b>When exiting a thread make sure to call {@link #remove
     NDC.remove()}</b>.  
   </ul>
   <p>There is no penalty for forgetting to match each
   <code>push</code> operation with a corresponding <code>pop</code>,
   except the obvious mismatch between the real application context
   and the context set in the NDC.
   <p>If configured to do so, {@link PatternLayout} and {@link
   TTCCLayout} instances automatically retrieve the nested diagnostic
   context for the current thread without any user intervention.
   Hence, even if a servlet is serving multiple clients
   simultaneously, the logs emanating from the same code (belonging to
   the same category) can still be distinguished because each client
   request will have a different NDC tag.
   <p>Heavy duty systems should call the {@link #remove} method when
   leaving the run method of a thread. This ensures that the memory
   used by the thread can be freed by the Java garbage
   collector. There is a mechanism to lazily remove references to dead
   threads. In practice, this means that you can be a little sloppy
   and sometimes forget to call {@link #remove} before exiting a
   thread.
   <p>A thread may inherit the nested diagnostic context of another
   (possibly parent) thread using the {@link #inherit inherit}
   method. A thread may obtain a copy of its NDC with the {@link
   #cloneStack cloneStack} method and pass the reference to any other
   thread, in particular to a child.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.0
*/
public class NDC {
  // The synchronized keyword is not used in this class. This may seem
  // dangerous, especially since the class will be used by
  // multiple-threads. In particular, all threads share the same
  // hashtable (the ""ht"" variable). This is OK since java hashtables
  // are thread safe. Same goes for Stacks.
  // More importantly, when inheriting diagnostic contexts the child
  // thread is handed a clone of the parent's NDC.  It follows that
  // each thread has its own NDC (i.e. stack).
  static Hashtable ht = new Hashtable();
  static int pushCounter = 0; // the number of times push has been called
                              // after the latest call to lazyRemove
  // The number of times we allow push to be called before we call lazyRemove
  // 5 is a relatively small number. As such, lazyRemove is not called too
  // frequently. We thus avoid the cost of creating an Enumeration too often.
  // The higher this number, the longer is the avarage period for which all
  // logging calls in all threads are blocked.
  static final int REAP_THRESHOLD = 5;
  // No instances allowed.
  private NDC() {}
  /**
     Clear any nested diagnostic information if any. This method is
     useful in cases where the same thread can be potentially used
     over and over in different unrelated contexts.
     <p>This method is equivalent to calling the {@link #setMaxDepth}
     method with a zero <code>maxDepth</code> argument.
     @since 0.8.4c */
  public
  static
  void clear() {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null) 
      stack.setSize(0);    
  }
  /**
     Clone the diagnostic context for the current thread.
     <p>Internally a diagnostic context is represented as a stack.  A
     given thread can supply the stack (i.e. diagnostic context) to a
     child thread so that the child can inherit the parent thread's
     diagnostic context.
     <p>The child thread uses the {@link #inherit inherit} method to
     inherit the parent's diagnostic context.
     @return Stack A clone of the current thread's  diagnostic context.
  */
  public
  static
  Stack cloneStack() {
    Object o = ht.get(Thread.currentThread());
    if(o == null)
      return null;
    else {
      Stack stack = (Stack) o;
      return (Stack) stack.clone();
    }
  }
  /**
     Inherit the diagnostic context of another thread.
     <p>The parent thread can obtain a reference to its diagnostic
     context using the {@link #cloneStack} method.  It should
     communicate this information to its child so that it may inherit
     the parent's diagnostic context.
     <p>The parent's diagnostic context is cloned before being
     inherited. In other words, once inherited, the two diagnostic
     contexts can be managed independently.
     <p>In java, a child thread cannot obtain a reference to its
     parent, unless it is directly handed the reference. Consequently,
     there is no client-transparent way of inheriting diagnostic
     contexts. Do you know any solution to this problem?
     @param stack The diagnostic context of the parent thread.
  */
  public
  static
  void inherit(Stack stack) {
    if(stack != null)
      ht.put(Thread.currentThread(), stack);
  }
  /**
     Used when printing the diagnostic context.
  */
  static
  public
  String get() {
    Stack s = (Stack) ht.get(Thread.currentThread());
    if(s != null && !s.isEmpty()) 
      return ((DiagnosticContext) s.peek()).fullMessage;
    else
      return null;
  }
  /**
     Get the current nesting depth of this diagnostic context.
     @see #setMaxDepth
     @since 0.7.5
   */
  public
  static
  int getDepth() {
    Stack stack = (Stack) ht.get(Thread.currentThread());          
    if(stack == null)
      return 0;
    else
      return stack.size();      
  }
  private
  static
  void lazyRemove() {
    // The synchronization on ht is necessary to prevent JDK 1.2.x from
    // throwing ConcurrentModificationExceptions at us. This sucks BIG-TIME.
    // One solution is to write our own hashtable implementation.
    Vector v;
    synchronized(ht) {
      // Avoid calling clean-up too often.
      if(++pushCounter <= REAP_THRESHOLD) {
	return; // We release the lock ASAP.
      } else {
	pushCounter = 0; // OK let's do some work.
      }
      int misses = 0;
      v = new Vector(); 
      Enumeration enum = ht.keys();
      // We give up after 4 straigt missses. That is 4 consecutive
      // inspected threads in 'ht' that turn out to be alive.
      // The higher the proportion on dead threads in ht, the higher the
      // chances of removal.
      while(enum.hasMoreElements() && (misses <= 4)) {
	Thread t = (Thread) enum.nextElement();
	if(t.isAlive()) {
	  misses++;
	} else {
	  misses = 0;
	  v.addElement(t);
	}
      }
    } // synchronized
    int size = v.size();
    for(int i = 0; i < size; i++) {
      Thread t = (Thread) v.elementAt(i);
      LogLog.debug(""Lazy NDC removal for thread ["" + t.getName() + ""] (""+ 
		   ht.size() + "")."");
      ht.remove(t);
    }
  }
  /**
     Clients should call this method before leaving a diagnostic
     context.
     <p>The returned value is the value that was pushed last. If no
     context is available, then the empty string """" is returned.
     @return String The innermost diagnostic context.
     */
  public
  static
  String pop() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty()) 
      return ((DiagnosticContext) stack.pop()).message;
    else
      return """";
  }
  /**
     Looks at the last diagnostic context at the top of this NDC
     without removing it.
     <p>The returned value is the value that was pushed last. If no
     context is available, then the empty string """" is returned.
     @return String The innermost diagnostic context.
     */
  public
  static
  String peek() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty())
      return ((DiagnosticContext) stack.peek()).message;
    else
      return """";
  }
  /**
     Push new diagnostic context information for the current thread.
     <p>The contents of the <code>message</code> parameter is
     determined solely by the client.  
     @param message The new diagnostic context information.  */
  public
  static
  void push(String message) {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack == null) {
      DiagnosticContext dc = new DiagnosticContext(message, null);      
      stack = new Stack();
      ht.put(key, stack);
      stack.push(dc);
    } else if (stack.isEmpty()) {
      DiagnosticContext dc = new DiagnosticContext(message, null);            
      stack.push(dc);
    } else {
      DiagnosticContext parent = (DiagnosticContext) stack.peek();
      stack.push(new DiagnosticContext(message, parent));
    }    
  }
  /**
     Remove the diagnostic context for this thread.
     <p>Each thread that created a diagnostic context by calling
     {@link #push} should call this method before exiting. Otherwise,
     the memory used by the <b>thread</b> cannot be reclaimed by the
     VM.
     <p>As this is such an important problem in heavy duty systems and
     because it is difficult to always guarantee that the remove
     method is called before exiting a thread, this method has been
     augmented to lazily remove references to dead threads. In
     practice, this means that you can be a little sloppy and
     occasionally forget to call {@link #remove} before exiting a
     thread. However, you must call <code>remove</code> sometime. If
     you never call it, then your application is sure to run out of
     memory.
  */
  static
  public
  void remove() {
    ht.remove(Thread.currentThread());
    // Lazily remove dead-thread references in ht.
    lazyRemove();    
  }
  /**
     Set maximum depth of this diagnostic context. If the current
     depth is smaller or equal to <code>maxDepth</code>, then no
     action is taken.
     <p>This method is a convenient alternative to multiple {@link
     #pop} calls. Moreover, it is often the case that at the end of
     complex call sequences, the depth of the NDC is
     unpredictable. The <code>setMaxDepth</code> method circumvents
     this problem.
     <p>For example, the combination
     <pre>
       void foo() {
       &nbsp;  int depth = NDC.getDepth();
       &nbsp;  ... complex sequence of calls
       &nbsp;  NDC.setMaxDepth(depth);
       }
     </pre>
     ensures that between the entry and exit of foo the depth of the
     diagnostic stack is conserved.
     @see #getDepth
     @since 0.7.5 */
  static
  public
  void setMaxDepth(int maxDepth) {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null && maxDepth < stack.size()) 
      stack.setSize(maxDepth);
  }
  // =====================================================================
   private static class DiagnosticContext {
    String fullMessage;
    String message;
    DiagnosticContext(String message, DiagnosticContext parent) {
      this.message = message;
      if(parent != null) {
	fullMessage = parent.fullMessage + ' ' + message;
      } else {
	fullMessage = message;
      }
    }
  }
}
"
org.apache.log4j.PatternLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
package org.apache.log4j;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Anders Kristensen <akristensen@dynamicsoft.com>
/**
   A flexible layout configurable with pattern string.
   <p>The goal of this class is to {@link #format format} a {@link
   LoggingEvent} and return the results as a String. The results
   depend on the <em>conversion pattern</em>.
   <p>The conversion pattern is closely related to the conversion
   pattern of the printf function in C. A conversion pattern is
   composed of literal text and format control expressions called
   <em>conversion specifiers</em>.
   <p><i>You are free to insert any literal text within the conversion
   pattern.</i>
   <p>Each conversion specifier starts with a percent sign (%) and is
   followed by optional <em>format modifiers</em> and a <em>conversion
   character</em>. The conversion character specifies the type of
   data, e.g. category, priority, date, thread name. The format
   modifiers control such things as field width, padding, left and
   right justification. The following is a simple example.
   <p>Let the conversion pattern be <b>""%-5p [%t]: %m%n""</b> and assume
   that the log4j environment was set to use a PatternLayout. Then the
   statements
   <pre>
   Category root = Category.getRoot();
   root.debug(""Message 1"");
   root.warn(""Message 2"");
   </pre>
   would yield the output
   <pre>
   DEBUG [main]: Message 1
   WARN  [main]: Message 2
   </pre>
   <p>Note that there is no explicit separator between text and
   conversion specifiers. The pattern parser knows when it has reached
   the end of a conversion specifier when it reads a conversion
   character. In the example above the conversion specifier
   <b>%-5p</b> means the priority of the logging event should be left
   justified to a width of five characters.
   The recognized conversion characters are
   <p>
   <table border=""1"" CELLPADDING=""8"">
   <th>Conversion Character</th>
   <th>Effect</th>
   <tr>
     <td align=center><b>c</b></td>
     <td>Used to output the category of the logging event. The
     category conversion specifier can be optionally followed by
     <em>precision specifier</em>, that is a decimal constant in
     brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the category name will be
     printed. By default the category name is printed in full.
     <p>For example, for the category name ""a.b.c"" the pattern
     <b>%c{2}</b> will output ""b.c"".
     </td>
   </tr>
   <tr>
     <td align=center><b>C</b></td>
     <td>Used to output the fully qualified class name of the caller
     issuing the logging request. This conversion specifier
     can be optionally followed by <em>precision specifier</em>, that
     is a decimal constant in brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the class name will be
     printed. By default the class name is output in fully qualified form.
     <p>For example, for the class name ""org.apache.xyz.SomeClass"", the
     pattern <b>%C{1}</b> will output ""SomeClass"".
     <p><b>WARNING</b> Generating the caller class information is
     slow. Thus, it's use should be avoided unless execution speed is
     not an issue.
     </td>
     </tr>
   <tr> <td align=center><b>d</b></td> <td>Used to output the date of
	 the logging event. The date conversion specifier may be
	 followed by a <em>date format specifier</em> enclosed between
	 braces. For example, <b>%d{HH:mm:ss,SSS}</b> or
	 <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;HH:mm:ss,SSS}</b>.  If no
	 date format specifier is given then ISO8601 format is
	 assumed.
	 <p>The date format specifier admits the same syntax as the
	 time pattern string of the {@link
	 java.text.SimpleDateFormat}. Although part of the standard
	 JDK, the performance of <code>SimpleDateFormat</code> is
	 quite poor.
	 <p>For better results it is recommended to use the log4j date
	 formatters. These can be specified using one of the strings
	 ""ABSOLUTE"", ""DATE"" and ""ISO8601"" for specifying {@link
	 org.apache.log4j.helpers.AbsoluteTimeDateFormat
	 AbsoluteTimeDateFormat}, {@link
	 org.apache.log4j.helpers.DateTimeDateFormat DateTimeDateFormat}
	 and respectively {@link
	 org.apache.log4j.helpers.ISO8601DateFormat
	 ISO8601DateFormat}. For example, <b>%d{ISO8601}</b> or
	 <b>%d{ABSOLUTE}</b>.
	 <p>These dedicated date formatters perform significantly
	 better than {@link java.text.SimpleDateFormat}.
     </td>
   </tr>
   <tr>
   <td align=center><b>F</b></td>
   <td>Used to output the file name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
   <td align=center><b>l</b></td>
     <td>Used to output location information of the caller which generated
     the logging event.
     <p>The location information depends on the JVM implementation but
     usually consists of the fully qualified name of the calling
     method followed by the callers source the file name and line
     number between parentheses.
     <p>The location information can be very useful. However, it's
     generation is <em>extremely</em> slow. It's use should be avoided
     unless execution speed is not an issue.
     </td>
   </tr>
   <tr>
   <td align=center><b>L</b></td>
   <td>Used to output the line number from where the logging request
   was issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>m</b></td>
     <td>Used to output the application supplied message associated with
     the logging event.</td>
   </tr>
   <tr>
   <td align=center><b>M</b></td>
   <td>Used to output the method name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>n</b></td>
     <td>Outputs the platform dependent line separator character or
     characters.
     <p>This conversion character offers practically the same
     performance as using non-portable line separator strings such as
     ""\n"", or ""\r\n"". Thus, it is the preferred way of specifying a
     line separator.
   </tr>
   <tr>
     <td align=center><b>p</b></td>
     <td>Used to output the priority of the logging event.</td>
   </tr>
   <tr>
     <td align=center><b>r</b></td>
     <td>Used to output the number of milliseconds elapsed since the start
     of the application until the creation of the logging event.</td>
   </tr>
   <tr>
     <td align=center><b>t</b></td>
     <td>Used to output the name of the thread that generated the
     logging event.</td>
   </tr>
   <tr>
     <td align=center><b>x</b></td>
     <td>Used to output the NDC (nested diagnostic context) associated
     with the thread that generated the logging event.
     </td>
   </tr>
   <tr>
     <td align=center><b>X</b></td>
     <td> 
     <p>Used to output the MDC (mapped diagnostic context) associated
     with the thread that generated the logging event. The <b>X</b>
     conversion character <em>must</em> be followed by the key for the
     map placed between braces, as in <b>%X{clientNumber}</b> where
     <code>clientNumber</code> is the key. The value in the MDC
     corresponding to the key will be output.</p>
     <p>See {@link MDC} class for more details.
     </p>
     </td>
   </tr>
   <tr>
     <td align=center><b>%</b></td>
     <td>The sequence %% outputs a single percent sign.
     </td>
   </tr>
   </table>
   <p>By default the relevant information is output as is. However,
   with the aid of format modifiers it is possible to change the
   minimum field width, the maximum field width and justification.
   <p>The optional format modifier is placed between the percent sign
   and the conversion character.
   <p>The first optional format modifier is the <em>left justification
   flag</em> which is just the minus (-) character. Then comes the
   optional <em>minimum field width</em> modifier. This is a decimal
   constant that represents the minimum number of characters to
   output. If the data item requires fewer characters, it is padded on
   either the left or the right until the minimum width is
   reached. The default is to pad on the left (right justify) but you
   can specify right padding with the left justification flag. The
   padding character is space. If the data item is larger than the
   minimum field width, the field is expanded to accommodate the
   data. The value is never truncated.
   <p>This behavior can be changed using the <em>maximum field
   width</em> modifier which is designated by a period followed by a
   decimal constant. If the data item is longer than the maximum
   field, then the extra characters are removed from the
   <em>beginning</em> of the data item and not from the end. For
   example, it the maximum field width is eight and the data item is
   ten characters long, then the first two characters of the data item
   are dropped. This behavior deviates from the printf function in C
   where truncation is done from the end.
   <p>Below are various format modifier examples for the category
   conversion specifier.
   <p>
   <TABLE BORDER=1 CELLPADDING=8>
   <th>Format modifier
   <th>left justify
   <th>minimum width
   <th>maximum width
   <th>comment
   <tr>
   <td align=center>%20c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>none</td>
   <td>Left pad with spaces if the category name is less than 20
   characters long.
   <tr> <td align=center>%-20c</td> <td align=center>true</td> <td
   align=center>20</td> <td align=center>none</td> <td>Right pad with
   spaces if the category name is less than 20 characters long.
   <tr>
   <td align=center>%.30c</td>
   <td align=center>NA</td>
   <td align=center>none</td>
   <td align=center>30</td>
   <td>Truncate from the beginning if the category name is longer than 30
   characters.
   <tr>
   <td align=center>%20.30c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Left pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.
   <tr>
   <td align=center>%-20.30c</td>
   <td align=center>true</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Right pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.
   </table>
   <p>Below are some examples of conversion patterns.
   <dl>
   <p><dt><b>%r [%t] %-5p %c %x - %m\n</b>
   <p><dd>This is essentially the TTCC layout.
   <p><dt><b>%-6r [%15.15t] %-5p %30.30c %x - %m\n</b>
   <p><dd>Similar to the TTCC layout except that the relative time is
   right padded if less than 6 digits, thread name is right padded if
   less than 15 characters and truncated if longer and the category
   name is left padded if shorter than 30 characters and truncated if
   longer.
  </dl>
   <p>The above text is largely inspired from Peter A. Darnell and
   Philip E. Margolis' highly recommended book ""C -- a Software
   Engineering Approach"", ISBN 0-387-97389-3.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2 */
public class PatternLayout extends Layout {
  /** Default pattern string for log output. Currently set to the
      string <b>""%m%n""</b> which just prints the application supplied
      message. */
  public final static String DEFAULT_CONVERSION_PATTERN =""%m%n"";
  /** A conversion pattern equivalent to the TTCCCLayout.
      Current value is <b>%r [%t] %p %c %x - %m%n</b>. */
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  private String pattern;
  private PatternConverter head;
  private String timezone;
  /**
     Constructs a PatternLayout using the DEFAULT_LAYOUT_PATTERN.
     The default pattern just produces the application supplied message.
  */
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }
  /**
     Constructs a PatternLayout using the supplied conversion pattern.
  */
  public PatternLayout(String pattern) {
    this.pattern = pattern;
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN :
			     pattern).parse();
  }
   /**
     Set the <b>ConversionPattern</b> option. This is the string which
     controls formatting and consists of a mix of literal content and
     conversion specifiers.
   */
  public
  void setConversionPattern(String conversionPattern) {
    pattern = conversionPattern;
    head = createPatternParser(conversionPattern).parse();
  }
  /**
     Returns the value of the <b>ConversionPattern</b> option.
   */
  public
  String getConversionPattern() {
    return pattern;
  }
  /**
     Does not do anything as options become effective
  */
  public
  void activateOptions() {
    // nothing to do.
  }
 /**
     The PatternLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
  /**
    Returns PatternParser used to parse the conversion string. Subclasses
    may override this to return a subclass of PatternParser which recognize
    custom conversion characters.
    @since 0.9.0
  */
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }
  /**
     Produces a formatted string as specified by the conversion pattern.
  */
  public String format(LoggingEvent event) {
    // Reset working stringbuffer
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    PatternConverter c = head;
    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
}
"
org.apache.log4j.Priority,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// Contributors:  Kitching Simon <Simon.Kitching@orange.ch>
package org.apache.log4j;
/**
   <font color=""#AA4444"">Refrain from using this class directly, use
   the {@link Level} class instead.</font>
   @author Ceki G&uuml;lc&uuml; */
public class Priority {
  int level;
  String levelStr;
  int syslogEquivalent;
  public final static int OFF_INT = Integer.MAX_VALUE;
  public final static int FATAL_INT = 50000;
  public final static int ERROR_INT = 40000;
  public final static int WARN_INT  = 30000;
  public final static int INFO_INT  = 20000;
  public final static int DEBUG_INT = 10000;
    //public final static int FINE_INT = DEBUG_INT;
  public final static int ALL_INT = Integer.MIN_VALUE;
  /**
     The <code>FATAL</code> level designates very severe error
     events that will presumably lead the application to abort.
   */
  final static public Priority FATAL = new Level(FATAL_INT, ""FATAL"", 0);
  /**
     The <code>ERROR</code> level designates error events that
     might still allow the application to continue running.  */
  final static public Priority ERROR = new Level(ERROR_INT, ""ERROR"", 3);
  /**
     The <code>WARN</code> level designates potentially harmful situations.
  */
  final static public Priority WARN  = new Level(WARN_INT, ""WARN"",  4);
  /**
     The <code>INFO</code> level designates informational messages
     that highlight the progress of the application at coarse-grained
     level.  */
  final static public Priority INFO  = new Level(INFO_INT, ""INFO"",  6);
  /**
     The <code>DEBUG</code> priority designates fine-grained
     informational events that are most useful to debug an
     application.  */
  final static public Priority DEBUG = new Level(DEBUG_INT, ""DEBUG"", 7);
  /**
     Instantiate a level object.
   */
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }
  /**
     Two priorities are equal if their level fields are equal.
     @since 1.2
   */
  public
  boolean equals(Object o) {
    if(o instanceof Priority) {
      Priority r = (Priority) o;
      return (this.level == r.level);
    } else {
      return false;
    }
  }
  /**
     Return the syslog equivalent of this priority as an integer.
   */
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }
  /**
     Returns <code>true</code> if this level has a higher or equal
     level than the level passed as argument, <code>false</code>
     otherwise.  
     <p>You should think twice before overriding the default
     implementation of <code>isGreaterOrEqual</code> method.
  */
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }
  /**
     Return all possible priorities as an array of Level objects in
     descending order.
     @deprecated This method will be removed with no replacement.
  */
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Level.WARN, 
			   Priority.INFO, Priority.DEBUG};
  }
  /**
     Returns the string representation of this priority.
   */
  final
  public
  String toString() {
    return levelStr;
  }
  /**
     Returns the integer representation of this level.
   */
  public
  final
  int toInt() {
    return level;
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns {@link #DEBUG}. 
     @deprecated Please use the {@link Level#toLevel(String)} method instead.}
  */
  public
  static
  Priority toPriority(String sArg) {
    return Level.toLevel(sArg);
  }
  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns {@link #DEBUG}.
  */
  public
  static
  Priority toPriority(int val) {
    return toPriority(val, Priority.DEBUG);
  }
  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns the specified default.
  */
  public
  static
  Priority toPriority(int val, Priority defaultPriority) {
    return Level.toLevel(val, (Level) defaultPriority);
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns the value of
     <code>defaultPriority</code>.  
  */
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    return Level.toLevel(sArg, (Level) defaultPriority);
  }
}
"
org.apache.log4j.PropertyConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//               Anders Kristensen <akristensen@dynamicsoft.com>
package org.apache.log4j;
import org.apache.log4j.DefaultCategoryFactory;
import org.apache.log4j.config.PropertySetter;
//import org.apache.log4j.config.PropertySetterException;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;
import java.util.Enumeration;
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Hashtable;
/**
   Extends {@link BasicConfigurator} to provide configuration from an
   external file.  See <b>{@link #doConfigure(String, LoggerRepository)}</b> for the
   expected format.
   <p>It is sometimes useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.debug</b> variable.
   <P>As of log4j version 0.8.5, at class initialization time class,
   the file <b>log4j.properties</b> will be searched from the search
   path used to load classes. If the file can be found, then it will
   be fed to the {@link PropertyConfigurator#configure(java.net.URL)}
   method.
   <p>The <code>PropertyConfigurator</code> does not handle the
   advanced configuration features supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator} such as
   support for {@link org.apache.log4j.spi.Filter Filters}, custom
   {@link org.apache.log4j.spi.ErrorHandler ErrorHandlers}, nested
   appenders such as the {@link org.apache.log4j.AsyncAppender
   AsyncAppender}, etc.
   <p>All option <em>values</em> admit variable substitution. The
   syntax of variable substitution is similar to that of Unix
   shells. The string between an opening <b>&quot;${&quot;</b> and
   closing <b>&quot;}&quot;</b> is interpreted as a key. The value of
   the substituted variable can be defined as a system property or in
   the configuration file itself. The value of the key is first
   searched in the system properties, and if not found there, it is
   then searched in the configuration file being parsed.  The
   corresponding value replaces the ${variableName} sequence. For
   example, if <code>java.home</code> system property is set to
   <code>/home/xyz</code>, then every occurrence of the sequence
   <code>${java.home}</code> will be interpreted as
   <code>/home/xyz</code>.
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.1 */
public class PropertyConfigurator implements Configurator {
  /**
     Used internally to keep track of configured appenders.
   */
  protected Hashtable registry = new Hashtable(11);
  protected LoggerFactory loggerFactory = new DefaultCategoryFactory();
  static final String      CATEGORY_PREFIX = ""log4j.category."";
  static final String      LOGGER_PREFIX   = ""log4j.logger."";
  static final String       FACTORY_PREFIX = ""log4j.factory"";
  static final String    ADDITIVITY_PREFIX = ""log4j.additivity."";
  static final String ROOT_CATEGORY_PREFIX = ""log4j.rootCategory"";
  static final String ROOT_LOGGER_PREFIX   = ""log4j.rootLogger"";
  static final String      APPENDER_PREFIX = ""log4j.appender."";
  static final String      RENDERER_PREFIX = ""log4j.renderer."";
  static final String      THRESHOLD_PREFIX = ""log4j.threshold"";
  /** Key for specifying the {@link org.apache.log4j.spi.LoggerFactory
      LoggerFactory}.  Currently set to ""<code>log4j.loggerFactory</code>"".  */
  public static final String LOGGER_FACTORY_KEY = ""log4j.loggerFactory"";
  static final private String INTERNAL_ROOT_NAME = ""root"";
  /**
    Read configuration from a file. <b>The existing configuration is
    not cleared nor reset.</b> If you require a different behavior,
    then call {@link BasicConfigurator#resetConfiguration
    resetConfiguration} method before calling
    <code>doConfigure</code>.
    <p>The configuration file consists of statements in the format
    <code>key=value</code>. The syntax of different configuration
    elements are discussed below.
    <h3>Repository-wide threshold</h3>
    <p>The repository-wide threshold filters logging requests by level
    regardless of logger. The syntax is:
    <pre>
    log4j.threshold=[level]
    </pre>
    <p>The level value can consist of the string values OFF, FATAL,
    ERROR, WARN, INFO, DEBUG, ALL or a <em>custom level</e> value. A
    custom level value can be specified in the form
    level#classname. By default the repository-wide threshold is set
    to the lowest possible value, namely the level <code>ALL</code>.
    </p>
    <h3>Appender configuration</h3>
    <p>Appender configuration syntax is:
    <pre>
    # For appender named <i>appenderName</i>, set its class.
    # Note: The appender name can contain dots.
    log4j.appender.appenderName=fully.qualified.name.of.appender.class
    # Set appender specific options.
    log4j.appender.appenderName.option1=value1
    ...
    log4j.appender.appenderName.optionN=valueN
    </pre>
    For each named appender you can configure its {@link Layout}. The
    syntax for configuring an appender's layout is:
    <pre>
    log4j.appender.appenderName.layout=fully.qualified.name.of.layout.class
    log4j.appender.appenderName.layout.option1=value1
    ....
    log4j.appender.appenderName.layout.optionN=valueN
    </pre>
    <h3>Configuring loggers</h3>
    <p>The syntax for configuring the root logger is:
    <pre>
      log4j.rootLogger=[level], appenderName, appenderName, ...
    </pre>
    <p>This syntax means that an optional <em>level</em> can be
    supplied followed by appender names separated by commas.
    <p>The level value can consist of the string values OFF, FATAL,
    ERROR, WARN, INFO, DEBUG, ALL or a <em>custom level</em> value. A
    custom level value can be specified in the form
    <code>level#classname</code>.
    <p>If a level value is specified, then the root level is set
    to the corresponding level.  If no level value is specified,
    then the root level remains untouched.
    <p>The root logger can be assigned multiple appenders.
    <p>Each <i>appenderName</i> (separated by commas) will be added to
    the root logger. The named appender is defined using the
    appender syntax defined above.
    <p>For non-root categories the syntax is almost the same:
    <pre>
    log4j.logger.logger_name=[level|INHERITED], appenderName, appenderName, ...
    </pre>
    <p>The meaning of the optional level value is discussed above
    in relation to the root logger. In addition however, the value
    INHERITED can be specified meaning that the named logger should
    inherit its level from the logger hierarchy.
    <p>If no level value is supplied, then the level of the
    named logger remains untouched.
    <p>By default categories inherit their level from the
    hierarchy. However, if you set the level of a logger and
    later decide that that logger should inherit its level, then
    you should specify INHERITED as the value for the level value.
    <p>Similar to the root logger syntax, each <i>appenderName</i>
    (separated by commas) will be attached to the named logger.
    <p>See the <a href=""../../../../manual.html#additivity"">appender
    additivity rule</a> in the user manual for the meaning of the
    <code>additivity</code> flag.
    <h3>ObjectRenderers</h3>
    You can customize the way message objects of a given type are
    converted to String before being logged. This is done by
    specifying an {@link org.apache.log4j.or.ObjectRenderer ObjectRenderer}
    for the object type would like to customize.
    <p>The syntax is:
    <pre>
    log4j.renderer.fully.qualified.name.of.rendered.class=fully.qualified.name.of.rendering.class
    </pre>
    As in,
    <pre>
    log4j.renderer.my.Fruit=my.FruitRenderer
    </pre>
    <h3>Logger Factories</h3>
    The usage of custom logger factories is discouraged and no longer
    documented.
    <h3>Example</h3>
    <p>An example configuration is given below. Other configuration
    file examples are given in the <code>examples</code> folder.
    <pre>
    # Set options for appender named ""A1"".
    # Appender ""A1"" will be a SyslogAppender
    log4j.appender.A1=org.apache.log4j.net.SyslogAppender
    # The syslog daemon resides on www.abc.net
    log4j.appender.A1.SyslogHost=www.abc.net
    # A1's layout is a PatternLayout, using the conversion pattern
    # <b>%r %-5p %c{2} %M.%L %x - %m\n</b>. Thus, the log output will
    # include # the relative time since the start of the application in
    # milliseconds, followed by the level of the log request,
    # followed by the two rightmost components of the logger name,
    # followed by the callers method name, followed by the line number,
    # the nested disgnostic context and finally the message itself.
    # Refer to the documentation of {@link PatternLayout} for further information
    # on the syntax of the ConversionPattern key.
    log4j.appender.A1.layout=org.apache.log4j.PatternLayout
    log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c{2} %M.%L %x - %m\n
    # Set options for appender named ""A2""
    # A2 should be a RollingFileAppender, with maximum file size of 10 MB
    # using at most one backup file. A2's layout is TTCC, using the
    # ISO8061 date format with context printing enabled.
    log4j.appender.A2=org.apache.log4j.RollingFileAppender
    log4j.appender.A2.MaxFileSize=10MB
    log4j.appender.A2.MaxBackupIndex=1
    log4j.appender.A2.layout=org.apache.log4j.TTCCLayout
    log4j.appender.A2.layout.ContextPrinting=enabled
    log4j.appender.A2.layout.DateFormat=ISO8601
    # Root logger set to DEBUG using the A2 appender defined above.
    log4j.rootLogger=DEBUG, A2
    # Logger definitions:
    # The SECURITY logger inherits is level from root. However, it's output
    # will go to A1 appender defined above. It's additivity is non-cumulative.
    log4j.logger.SECURITY=INHERIT, A1
    log4j.additivity.SECURITY=false
    # Only warnings or above will be logged for the logger ""SECURITY.access"".
    # Output will go to A1.
    log4j.logger.SECURITY.access=WARN
    # The logger ""class.of.the.day"" inherits its level from the
    # logger hierarchy.  Output will go to the appender's of the root
    # logger, A2 in this case.
    log4j.logger.class.of.the.day=INHERIT
    </pre>
    <p>Refer to the <b>setOption</b> method in each Appender and
    Layout for class specific options.
    <p>Use the <code>#</code> or <code>!</code> characters at the
    beginning of a line for comments.
   <p>
   @param configFileName The name of the configuration file where the
   configuration information is stored.
  */
  public
  void doConfigure(String configFileName, LoggerRepository hierarchy) {
    Properties props = new Properties();
    try {
      FileInputStream istream = new FileInputStream(configFileName);
      props.load(istream);
      istream.close();
    }
    catch (IOException e) {
      LogLog.error(""Could not read configuration file [""+configFileName+""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configFileName+""]."");
      return;
    }
    // If we reach here, then the config file is alright.
    doConfigure(props, hierarchy);
  }
  /**
   */
  static
  public
  void configure(String configFilename) {
    new PropertyConfigurator().doConfigure(configFilename,
					   LogManager.getLoggerRepository());
  }
  /**
     Read configuration options from url <code>configURL</code>.
     @since 0.8.2
   */
  public
  static
  void configure(java.net.URL configURL) {
    new PropertyConfigurator().doConfigure(configURL,
					   LogManager.getLoggerRepository());
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, LoggerRepository)} for the expected format.
  */
  static
  public
  void configure(Properties properties) {
    new PropertyConfigurator().doConfigure(properties,
					   LogManager.getLoggerRepository());
  }
  /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used.
     @param configFilename A file in key=value format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.
      @param configFilename A file in key=value format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    PropertyWatchdog pdog = new PropertyWatchdog(configFilename);
    pdog.setDelay(delay);
    pdog.start();
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, LoggerRepository)} for the expected format.
  */
  public
  void doConfigure(Properties properties, LoggerRepository hierarchy) {
    String value = properties.getProperty(LogLog.DEBUG_KEY);
    if(value == null) {
      value = properties.getProperty(LogLog.CONFIG_DEBUG_KEY);
      if(value != null)
	LogLog.warn(""[log4j.configDebug] is deprecated. Use [log4j.debug] instead."");
    }
    if(value != null) {
      LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
    }
    String thresholdStr = OptionConverter.findAndSubst(THRESHOLD_PREFIX,
						       properties);
    if(thresholdStr != null) {
      hierarchy.setThreshold(OptionConverter.toLevel(thresholdStr,
						     (Level) Level.ALL));
      LogLog.debug(""Hierarchy threshold set to [""+hierarchy.getThreshold()+""]."");
    }
    configureRootCategory(properties, hierarchy);
    configureLoggerFactory(properties);
    parseCatsAndRenderers(properties, hierarchy);
    LogLog.debug(""Finished configuring."");
    // We don't want to hold references to appenders preventing their
    // garbage collection.
    registry.clear();
  }
  /**
     Read configuration options from url <code>configURL</code>.
   */
  public
  void doConfigure(java.net.URL configURL, LoggerRepository hierarchy) {
    Properties props = new Properties();
    LogLog.debug(""Reading configuration from URL "" + configURL);
    try {
      props.load(configURL.openStream());
    }
    catch (java.io.IOException e) {
      LogLog.error(""Could not read configuration file from URL ["" + configURL
		   + ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configURL +""]."");
      return;
    }
    doConfigure(props, hierarchy);
  }
  // --------------------------------------------------------------------------
  // Internal stuff
  // --------------------------------------------------------------------------
  /**
     Check the provided <code>Properties</code> object for a
     {@link org.apache.log4j.spi.LoggerFactory LoggerFactory}
     entry specified by {@link #LOGGER_FACTORY_KEY}.  If such an entry
     exists, an attempt is made to create an instance using the default
     constructor.  This instance is used for subsequent Category creations
     within this configurator.
     @see #parseCatsAndRenderers
   */
  protected void configureLoggerFactory(Properties props) {
    String factoryClassName = OptionConverter.findAndSubst(LOGGER_FACTORY_KEY,
							   props);
    if(factoryClassName != null) {
      LogLog.debug(""Setting category factory to [""+factoryClassName+""]."");
      loggerFactory = (LoggerFactory)
	          OptionConverter.instantiateByClassName(factoryClassName,
							 LoggerFactory.class,
							 loggerFactory);
      PropertySetter.setProperties(loggerFactory, props, FACTORY_PREFIX + ""."");
    }
  }
  /*
  void configureOptionHandler(OptionHandler oh, String prefix,
			      Properties props) {
    String[] options = oh.getOptionStrings();
    if(options == null)
      return;
    String value;
    for(int i = 0; i < options.length; i++) {
      value =  OptionConverter.findAndSubst(prefix + options[i], props);
      LogLog.debug(
         ""Option "" + options[i] + ""=["" + (value == null? ""N/A"" : value)+""]."");
      // Some option handlers assume that null value are not passed to them.
      // So don't remove this check
      if(value != null) {
	oh.setOption(options[i], value);
      }
    }
    oh.activateOptions();
  }
  */
  void configureRootCategory(Properties props, LoggerRepository hierarchy) {
    String effectiveFrefix = ROOT_LOGGER_PREFIX;
    String value = OptionConverter.findAndSubst(ROOT_LOGGER_PREFIX, props);
    if(value == null) {
      value = OptionConverter.findAndSubst(ROOT_CATEGORY_PREFIX, props);
      effectiveFrefix = ROOT_CATEGORY_PREFIX;
    }
    if(value == null)
      LogLog.debug(""Could not find root logger information. Is this OK?"");
    else {
      Logger root = hierarchy.getRootLogger();
      synchronized(root) {
	parseCategory(props, root, effectiveFrefix, INTERNAL_ROOT_NAME, value);
      }
    }
  }
  /**
     Parse non-root elements, such non-root categories and renderers.
  */
  protected
  void parseCatsAndRenderers(Properties props, LoggerRepository hierarchy) {
    Enumeration enum = props.propertyNames();
    while(enum.hasMoreElements()) {
      String key = (String) enum.nextElement();
      if(key.startsWith(CATEGORY_PREFIX) || key.startsWith(LOGGER_PREFIX)) {
	String loggerName = null;
	if(key.startsWith(CATEGORY_PREFIX)) {
	  loggerName = key.substring(CATEGORY_PREFIX.length());
	} else if(key.startsWith(LOGGER_PREFIX)) {
	  loggerName = key.substring(LOGGER_PREFIX.length());
	}
	String value =  OptionConverter.findAndSubst(key, props);
	Logger logger = hierarchy.getLogger(loggerName, loggerFactory);
	synchronized(logger) {
	  parseCategory(props, logger, key, loggerName, value);
	  parseAdditivityForLogger(props, logger, loggerName);
	}
      } else if(key.startsWith(RENDERER_PREFIX)) {
	String renderedClass = key.substring(RENDERER_PREFIX.length());
	String renderingClass = OptionConverter.findAndSubst(key, props);
	if(hierarchy instanceof RendererSupport) {
	  RendererMap.addRenderer((RendererSupport) hierarchy, renderedClass,
				  renderingClass);
	}
      }
    }
  }
  /**
     Parse the additivity option for a non-root category.
   */
  void parseAdditivityForLogger(Properties props, Logger cat,
				  String loggerName) {
    String value = OptionConverter.findAndSubst(ADDITIVITY_PREFIX + loggerName,
					     props);
    LogLog.debug(""Handling ""+ADDITIVITY_PREFIX + loggerName+""=[""+value+""]"");
    // touch additivity only if necessary
    if((value != null) && (!value.equals(""""))) {
      boolean additivity = OptionConverter.toBoolean(value, true);
      LogLog.debug(""Setting additivity for \""""+loggerName+""\"" to ""+
		   additivity);
      cat.setAdditivity(additivity);
    }
  }
  /**
     This method must work for the root category as well.
   */
  void parseCategory(Properties props, Logger logger, String optionKey,
		     String loggerName, String value) {
    LogLog.debug(""Parsing for ["" +loggerName +""] with value=["" + value+""]."");
    // We must skip over ',' but not white space
    StringTokenizer st = new StringTokenizer(value, "","");
    // If value is not in the form "", appender.."" or """", then we should set
    // the level of the loggeregory.
    if(!(value.startsWith("","") || value.equals(""""))) {
      // just to be on the safe side...
      if(!st.hasMoreTokens())
	return;
      String levelStr = st.nextToken();
      LogLog.debug(""Level token is ["" + levelStr + ""]."");
      // If the level value is inherited, set category level value to
      // null. We also check that the user has not specified inherited for the
      // root category.
      if(levelStr.equalsIgnoreCase(INHERITED) &&
                                	 !loggerName.equals(INTERNAL_ROOT_NAME)) {
	logger.setLevel(null);
      } else {
	logger.setLevel(OptionConverter.toLevel(levelStr, (Level) Level.DEBUG));
      }
      LogLog.debug(""Category "" + loggerName + "" set to "" + logger.getLevel());
    }
    // Begin by removing all existing appenders.
    logger.removeAllAppenders();
    Appender appender;
    String appenderName;
    while(st.hasMoreTokens()) {
      appenderName = st.nextToken().trim();
      if(appenderName == null || appenderName.equals("",""))
	continue;
      LogLog.debug(""Parsing appender named \"""" + appenderName +""\""."");
      appender = parseAppender(props, appenderName);
      if(appender != null) {
	logger.addAppender(appender);
      }
    }
  }
  Appender parseAppender(Properties props, String appenderName) {
    Appender appender = registryGet(appenderName);
    if((appender != null)) {
      LogLog.debug(""Appender \"""" + appenderName + ""\"" was already parsed."");
      return appender;
    }
    // Appender was not previously initialized.
    String prefix = APPENDER_PREFIX + appenderName;
    String layoutPrefix = prefix + "".layout"";
    appender = (Appender) OptionConverter.instantiateByKey(props, prefix,
					      org.apache.log4j.Appender.class,
					      null);
    if(appender == null) {
      LogLog.error(
              ""Could not instantiate appender named \"""" + appenderName+""\""."");
      return null;
    }
    appender.setName(appenderName);
    if(appender instanceof OptionHandler) {
      if(appender.requiresLayout()) {
	Layout layout = (Layout) OptionConverter.instantiateByKey(props,
								  layoutPrefix,
								  Layout.class,
								  null);
	if(layout != null) {
	  appender.setLayout(layout);
	  LogLog.debug(""Parsing layout options for \"""" + appenderName +""\""."");
	  //configureOptionHandler(layout, layoutPrefix + ""."", props);
          PropertySetter.setProperties(layout, props, layoutPrefix + ""."");
	  LogLog.debug(""End of parsing for \"""" + appenderName +""\""."");
	}
      }
      //configureOptionHandler((OptionHandler) appender, prefix + ""."", props);
      PropertySetter.setProperties(appender, props, prefix + ""."");
      LogLog.debug(""Parsed \"""" + appenderName +""\"" options."");
    }
    registryPut(appender);
    return appender;
  }
  void  registryPut(Appender appender) {
    registry.put(appender.getName(), appender);
  }
  Appender registryGet(String name) {
    return (Appender) registry.get(name);
  }
}
class PropertyWatchdog extends FileWatchdog {
  PropertyWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new PropertyConfigurator().doConfigure(filename,
					   LogManager.getLoggerRepository());
  }
}
"
org.apache.log4j.ProvisionNode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.util.Vector;
class ProvisionNode extends Vector {
  ProvisionNode(Logger logger) {
    super();
    this.addElement(logger);
  }
}
"
org.apache.log4j.RollingFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.File;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;
/**
   RollingFileAppender extends FileAppender to backup the log files when
   they reach a certain size.
   @author Heinz Richter
   @author Ceki G&uuml;lc&uuml;
*/
public class RollingFileAppender extends FileAppender {
  /**
     The default maximum file size is 10MB.
  */
  protected long maxFileSize = 10*1024*1024;
  /**
     There is one backup file by default.
   */
  protected int  maxBackupIndex  = 1;
  /**
     The default constructor simply calls its {@link
     FileAppender#FileAppender parents constructor}.  */
  public
  RollingFileAppender() {
    super();
  }
  /**
    Instantiate a RollingFileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file desginated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }
  /**
     Returns the value of the <b>MaxBackupIndex</b> option.
   */
  public
  int getMaxBackupIndex() {
    return maxBackupIndex;
  }
 /**
    Get the maximum size that the output file is allowed to reach
    before being rolled over to backup files.
    @since 1.1
 */
  public
  long getMaximumFileSize() {
    return maxFileSize;
  }
  /**
     Implements the usual roll over behaviour.
     <p>If <code>MaxBackupIndex</code> is positive, then files
     {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
     are renamed to {<code>File.2</code>, ...,
     <code>File.MaxBackupIndex</code>}. Moreover, <code>File</code> is
     renamed <code>File.1</code> and closed. A new <code>File</code> is
     created to receive further log output.
     <p>If <code>MaxBackupIndex</code> is equal to zero, then the
     <code>File</code> is truncated with no backup files created.
   */
  public // synchronization not necessary since doAppend is alreasy synched
  void rollOver() {
    File target;
    File file;
    LogLog.debug(""rolling over count="" + ((CountingQuietWriter) qw).getCount());
    LogLog.debug(""maxBackupIndex=""+maxBackupIndex);
    // If maxBackups <= 0, then there is no file renaming to be done.
    if(maxBackupIndex > 0) {
      // Delete the oldest file, to keep Windows happy.
      file = new File(fileName + '.' + maxBackupIndex);
      if (file.exists())
       file.delete();
      // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
      for (int i = maxBackupIndex - 1; i >= 1; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  LogLog.debug(""Renaming file "" + file + "" to "" + target);
	  file.renameTo(target);
	}
      }
      // Rename fileName to fileName.1
      target = new File(fileName + ""."" + 1);
      this.closeFile(); // keep windows happy.
      file = new File(fileName);
      LogLog.debug(""Renaming file "" + file + "" to "" + target);
      file.renameTo(target);
    }
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false, bufferedIO, bufferSize);
    }
    catch(IOException e) {
      LogLog.error(""setFile(""+fileName+"", false) call failed."", e);
    }
  }
  public
  synchronized
  void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)
                                                                 throws IOException {
    super.setFile(fileName, append, this.bufferedIO, this.bufferSize);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }
  /**
     Set the maximum number of backup files to keep around.
     <p>The <b>MaxBackupIndex</b> option determines how many backup
     files are kept before the oldest is erased. This option takes
     a positive integer value. If set to zero, then there will be no
     backup files and the log file will be truncated when it reaches
     <code>MaxFileSize</code>.
   */
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;
  }
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     <p>This method is equivalent to {@link #setMaxFileSize} except
     that it is required for differentiating the setter taking a
     <code>long</code> argument from the setter taking a
     <code>String</code> argument by the JavaBeans {@link
     java.beans.Introspector Introspector}.
     @see #setMaxFileSize(String)
 */
  public
  void setMaximumFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     <p>In configuration files, the <b>MaxFileSize</b> option takes an
     long integer in the range 0 - 2^63. You can specify the value
     with the suffixes ""KB"", ""MB"" or ""GB"" so that the integer is
     interpreted being expressed respectively in kilobytes, megabytes
     or gigabytes. For example, the value ""10KB"" will be interpreted
     as 10240.
   */
  public
  void setMaxFileSize(String value) {
    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
  }
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }
  /**
     This method differentiates RollingFileAppender from its super
     class.
     @since 0.9.0
  */
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if((fileName != null) &&
                     ((CountingQuietWriter) qw).getCount() >= maxFileSize)
      this.rollOver();
   }
}
"
org.apache.log4j.SimpleLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
/**
   SimpleLayout consists of the level of the log statement,
   followed by "" - "" and then the log message itself. For example,
   <pre>
           DEBUG - Hello world
   </pre>
   <p>
   @author Ceki G&uuml;lc&uuml;
   @since version 0.7.0
   <p>{@link PatternLayout} offers a much more powerful alternative.
*/
public class SimpleLayout extends Layout {
  StringBuffer sbuf = new StringBuffer(128);
  public SimpleLayout() {
  }
  public
  void activateOptions() {
  }
  /**
     Returns the log statement in a format consisting of the
     <code>level</code>, followed by "" - "" and then the
     <code>message</code>. For example, <pre> INFO - ""A message""
     </pre>
     <p>The <code>category</code> parameter is ignored.
     <p>
     @return A byte array in SimpleLayout format.
    */
  public
  String format(LoggingEvent event) {
    sbuf.setLength(0);
    sbuf.append(event.level.toString());
    sbuf.append("" - "");
    sbuf.append(event.getRenderedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
/**
     The SimpleLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
org.apache.log4j.TTCCLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// Contributors: Christopher Williams
//               Mathias Bogaert
package org.apache.log4j;
import org.apache.log4j.helpers.DateLayout;
import org.apache.log4j.spi.LoggingEvent;
/**
 TTCC layout format consists of time, thread, category and nested
 diagnostic context information, hence the name.
 <p>Each of the four fields can be individually enabled or
 disabled. The time format depends on the <code>DateFormat</code>
 used.
 <p>Here is an example TTCCLayout output with the
 {@link org.apache.log4j.helpers.RelativeTimeDateFormat}.
 <pre>
176 [main] INFO  org.apache.log4j.examples.Sort - Populating an array of 2 elements in reverse order.
225 [main] INFO  org.apache.log4j.examples.SortAlgo - Entered the sort method.
262 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=1 - Outer loop.
276 [main] DEBUG org.apache.log4j.examples.SortAlgo.SWAP i=1 j=0 - Swapping intArray[0] = 1 and intArray[1] = 0
290 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=0 - Outer loop.
304 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Dump of interger array:
317 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [0] = 0
331 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [1] = 1
343 [main] INFO  org.apache.log4j.examples.Sort - The next log statement should be an error message.
346 [main] ERROR org.apache.log4j.examples.SortAlgo.DUMP - Tried to dump an uninitialized array.
        at org.apache.log4j.examples.SortAlgo.dump(SortAlgo.java:58)
        at org.apache.log4j.examples.Sort.main(Sort.java:64)
467 [main] INFO  org.apache.log4j.examples.Sort - Exiting main method.
</pre>
  <p>The first field is the number of milliseconds elapsed since the
  start of the program. The second field is the thread outputting the
  log statement. The third field is the level, the fourth field is
  the category to which the statement belongs.
  <p>The fifth field (just before the '-') is the nested diagnostic
  context.  Note the nested diagnostic context may be empty as in the
  first two statements. The text after the '-' is the message of the
  statement.
  <p><b>WARNING</b> Do not use the same TTCCLayout instance from
  within different appenders. The TTCCLayout is not thread safe when
  used in his way. However, it is perfectly safe to use a TTCCLayout
  instance from just one appender.
  <p>{@link PatternLayout} offers a much more flexible alternative.
  @author Ceki G&uuml;lc&uuml;
  @author <A HREF=""mailto:heinz.richter@ecmwf.int"">Heinz Richter</a>
*/
public class TTCCLayout extends DateLayout {
  // Internal representation of options
  private boolean threadPrinting    = true;
  private boolean categoryPrefixing = true;
  private boolean contextPrinting   = true;
  protected final StringBuffer buf = new StringBuffer(256);
  /**
     Instantiate a TTCCLayout object with {@link
     org.apache.log4j.helpers.RelativeTimeDateFormat} as the date
     formatter in the local time zone.
     @since 0.7.5 */
  public TTCCLayout() {
    this.setDateFormat(RELATIVE_TIME_DATE_FORMAT, null);
  }
  /**
     Instantiate a TTCCLayout object using the local time zone. The
     DateFormat used will depend on the <code>dateFormatType</code>.
     <p>This constructor just calls the {@link
     DateLayout#setDateFormat} method.
     */
  public TTCCLayout(String dateFormatType) {
    this.setDateFormat(dateFormatType);
  }
  /**
     The <b>ThreadPrinting</b> option specifies whether the name of the
     current thread is part of log output or not. This is true by default.
   */
  public
  void setThreadPrinting(boolean threadPrinting) {
    this.threadPrinting = threadPrinting;
  }
  /**
     Returns value of the <b>ThreadPrinting</b> option.
   */
  public
  boolean getThreadPrinting() {
    return threadPrinting;
  }
  /**
     The <b>CategoryPrefixing</b> option specifies whether {@link Category}
     name is part of log output or not. This is true by default.
   */
  public
  void setCategoryPrefixing(boolean categoryPrefixing) {
    this.categoryPrefixing = categoryPrefixing;
  }
  /**
     Returns value of the <b>CategoryPrefixing</b> option.
   */
  public
  boolean getCategoryPrefixing() {
    return categoryPrefixing;
  }
  /**
     The <b>ContextPrinting</b> option specifies log output will include
     the nested context information belonging to the current thread.
     This is true by default.
   */
  public
  void setContextPrinting(boolean contextPrinting) {
    this.contextPrinting = contextPrinting;
  }
  /**
     Returns value of the <b>ContextPrinting</b> option.
   */
  public
  boolean getContextPrinting() {
    return contextPrinting;
  }
  /**
   In addition to the level of the statement and message, the
   returned byte array includes time, thread, category and {@link NDC}
   information.
   <p>Time, thread, category and diagnostic context are printed
   depending on options.
    @param category
    @param level
    @param message
  */
  public
  String format(LoggingEvent event) {
    // Reset buf
    buf.setLength(0);
    dateFormat(buf, event);
    if(this.threadPrinting) {
      buf.append('[');
      buf.append(event.getThreadName());
      buf.append(""] "");
    }
    buf.append(event.level.toString());
    buf.append(' ');
    if(this.categoryPrefixing) {
      buf.append(event.categoryName);
      buf.append(' ');
    }
    if(this.contextPrinting) {
       String ndc = event.getNDC();
      if(ndc != null) {
	buf.append(ndc);
	buf.append(' ');
      }
    }
    buf.append(""- "");
    buf.append(event.getRenderedMessage());
    buf.append(LINE_SEP);
    return buf.toString();
  }
 /**
     The TTCCLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
org.apache.log4j.WriterAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>
//              Ben Sandee
/**
   WriterAppender appends log events to a {@link java.io.Writer} or an
   {@link java.io.OutputStream} depending on the user's choice.
   @author Ceki G&uuml;lc&uuml;
   @since 1.1 */
public class WriterAppender extends AppenderSkeleton {
  /**
     Immediate flush means that the underlying writer or output stream
     will be flushed at the end of each append operation. Immediate
     flush is slower but ensures that each append request is actually
     written. If <code>immediateFlush</code> is set to
     <code>false</code>, then there is a good chance that the last few
     logs events are not actually written to persistent media if and
     when the application crashes.
     <p>The <code>immediateFlush</code> variable is set to
     <code>true</code> by default.
  */
  protected boolean immediateFlush = true;
  /**
     The encoding to use when opening an InputStream.  <p>The
     <code>encoding</code> variable is set to <code>null</null> by
     default which results in the utilization of the system's default
     encoding.  */
  protected String encoding;
  /**
     This is the {@link QuietWriter quietWriter} where we will write
     to.
  */
  protected QuietWriter qw;
  /**
     This default constructor does nothing.  */
  public
  WriterAppender() {
  }
  /**
     Instantiate a WriterAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  */
  public
  WriterAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }
  /**
     Instantiate a WriterAppender and set the output destination to
     <code>writer</code>.
     <p>The <code>writer</code> must have been previously opened by
     the user.  */
  public
  WriterAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }
  /**
     If the <b>ImmediateFlush</b> option is set to
     <code>true</code>, the appender will flush at the end of each
     write. This is the default behavior. If the option is set to
     <code>false</code>, then the underlying stream can defer writing
     to physical medium to a later time.
     <p>Avoiding the flush operation at the end of each append results in
     a performance gain of 10 to 20 percent. However, there is safety
     tradeoff involved in skipping flushing. Indeed, when flushing is
     skipped, then it is likely that the last few log events will not
     be recorded on disk when the application exits. This is a high
     price to pay even for a 20% performance gain.
   */
  public
  void setImmediateFlush(boolean value) {
    immediateFlush = value;
  }
  /**
     Returns value of the <b>ImmediateFlush</b> option.
   */
  public
  boolean getImmediateFlush() {
    return immediateFlush;
  }
  /**
     Does nothing.
  */
  public
  void activateOptions() {
  }
  /**
     This method is called by the {@link AppenderSkeleton#doAppend}
     method.
     <p>If the output stream exists and is writable then write a log
     statement to the output stream. Otherwise, write a single warning
     message to <code>System.err</code>.
     <p>The format of the output will depend on this appender's
     layout.
  */
  public
  void append(LoggingEvent event) {
    // Reminder: the nesting of calls is:
    //
    //    doAppend()
    //      - check threshold
    //      - filter
    //      - append();
    //        - checkEntryConditions();
    //        - subAppend();
    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   }
  /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.closed) {
      LogLog.warn(""Not allowed to write to a closed appender."");
      return false;
    }
    if(this.qw == null) {
      errorHandler.error(""No output stream or file set for the appender named [""+
			name+""]."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for the appender named [""+ name+""]."");
      return false;
    }
    return true;
  }
  /**
     Close this appender instance. The underlying stream or writer is
     also closed.
     <p>Closed appenders cannot be reused.
     @see #setWriter
     @since 0.8.4 */
  public
  synchronized
  void close() {
    if(this.closed)
      return;
    this.closed = true;
    writeFooter();
    reset();
  }
  /**
     Close the underlying {@link java.io.Writer}.
  */
  protected
  void closeWriter() {
    if(qw != null) {
      try {
	qw.close();
      } catch(IOException e) {
	LogLog.error(""Could not close "" + qw, e); // do need to invoke an error handler
	                                          // at  this late stage
      }
    }
  }
  /**
     Returns an OutputStreamWriter when passed an OutputStream.  The
     encoding used will depend on the value of the
     <code>encoding</code> property.  If the encoding value is
     specified incorrectly the writer will be opened using the default
     system encoding (an error message will be printed to the loglog.  */
  protected
  OutputStreamWriter createWriter(OutputStream os) {
    OutputStreamWriter retval = null;
    String enc = getEncoding();
    if(enc != null) {
      try {
	retval = new OutputStreamWriter(os, enc);
      } catch(IOException e) {
	LogLog.warn(""Error initializing output writer."");
	LogLog.warn(""Unsupported encoding?"");
      }
    }
    if(retval == null) {
      retval = new OutputStreamWriter(os);
    }
    return retval;
  }
  public
  String getEncoding() {
    return encoding;
  }
  public
  void setEncoding(String value) {
    encoding = value;
  }
  /**
     Set the {@link ErrorHandler} for this WriterAppender and also the
     underlying {@link QuietWriter} if any. */
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
      if(this.qw != null) {
	this.qw.setErrorHandler(eh);
      }
    }
  }
  /**
    <p>Sets the Writer where the log output will go. The
    specified Writer must be opened by the user and be
    writable.
    <p>The <code>java.io.Writer</code> will be closed when the
    appender instance is closed.
    <p><b>WARNING:</b> Logging to an unopened Writer will fail.
    <p>
    @param writer An already opened Writer.  */
  public
  synchronized
  void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    //this.tp = new TracerPrintWriter(qw);
    writeHeader();
  }
  /**
     Actual writing occurs here.
     <p>Most subclasses of <code>WriterAppender</code> will need to
     override this method.
     @since 0.9.0 */
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  this.qw.write(s[i]);
	  this.qw.write(Layout.LINE_SEP);
	}
      }
    }
    if(this.immediateFlush) {
      this.qw.flush();
    }
  }
  /**
     The WriterAppender requires a layout. Hence, this method returns
     <code>true</code>.
  */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Clear internal references to the writer and other variables.
     Subclasses can override this method for an alternate closing
     behavior.  */
  protected
  void reset() {
    closeWriter();
    this.qw = null;
    //this.tp = null;
  }
  /**
     Write a footer as produced by the embedded layout's {@link
     Layout#getFooter} method.  */
  protected
  void writeFooter() {
    if(layout != null) {
      String f = layout.getFooter();
      if(f != null && this.qw != null) {
	this.qw.write(f);
	this.qw.flush();
      }
    }
  }
  /**
     Write a header as produced by the embedded layout's {@link
     Layout#getHeader} method.  */
  protected
  void writeHeader() {
    if(layout != null) {
      String h = layout.getHeader();
      if(h != null && this.qw != null)
	this.qw.write(h);
    }
  }
}
"
org.apache.log4j.chainsaw.ControlPanel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
/**
 * Represents the controls for filtering, pausing, exiting, etc.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 */
class ControlPanel extends JPanel {
    /** use the log messages **/
    private static final Category LOG = 
                                  Category.getInstance(ControlPanel.class);
    /**
     * Creates a new <code>ControlPanel</code> instance.
     *
     * @param aModel the model to control
     */
    ControlPanel(final MyTableModel aModel) {
        setBorder(BorderFactory.createTitledBorder(""Controls: ""));
        final GridBagLayout gridbag = new GridBagLayout();
        final GridBagConstraints c = new GridBagConstraints();
        setLayout(gridbag);
        // Pad everything
        c.ipadx = 5;
        c.ipady = 5;
        // Add the 1st column of labels
        c.gridx = 0;
        c.anchor = GridBagConstraints.EAST;
        c.gridy = 0;
        JLabel label = new JLabel(""Filter Level:"");
        gridbag.setConstraints(label, c);
        add(label);
        c.gridy++;
        label = new JLabel(""Filter Thread:"");
        gridbag.setConstraints(label, c);
        add(label);
        c.gridy++;
        label = new JLabel(""Filter Category:"");
        gridbag.setConstraints(label, c);
        add(label);
        c.gridy++;
        label = new JLabel(""Filter NDC:"");
        gridbag.setConstraints(label, c);
        add(label);
        c.gridy++;
        label = new JLabel(""Filter Message:"");
        gridbag.setConstraints(label, c);
        add(label);
        // Add the 2nd column of filters
        c.weightx = 1;
        //c.weighty = 1;
        c.gridx = 1;
        c.anchor = GridBagConstraints.WEST;
        c.gridy = 0;
        final Priority[] allPriorities = Priority.getAllPossiblePriorities();
        final JComboBox priorities = new JComboBox(allPriorities);
        final Priority lowest = allPriorities[allPriorities.length - 1];
        priorities.setSelectedItem(lowest);
        aModel.setPriorityFilter(lowest);
        gridbag.setConstraints(priorities, c);
        add(priorities);
        priorities.setEditable(false);
        priorities.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.setPriorityFilter(
                        (Priority) priorities.getSelectedItem());
                }
            });
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridy++;
        final JTextField threadField = new JTextField("""");
        threadField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setThreadFilter(threadField.getText());
                }
                public void removeUpdate(DocumentEvent aEvente) {
                    aModel.setThreadFilter(threadField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setThreadFilter(threadField.getText());
                }
            });
        gridbag.setConstraints(threadField, c);
        add(threadField);
        c.gridy++;
        final JTextField catField = new JTextField("""");
        catField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
            });
        gridbag.setConstraints(catField, c);
        add(catField);
        c.gridy++;
        final JTextField ndcField = new JTextField("""");
        ndcField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
            });
        gridbag.setConstraints(ndcField, c);
        add(ndcField);
        c.gridy++;
        final JTextField msgField = new JTextField("""");
        msgField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
            });
        gridbag.setConstraints(msgField, c);
        add(msgField);
        // Add the 3rd column of buttons
        c.weightx = 0;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.EAST;
        c.gridx = 2;
        c.gridy = 0;
        final JButton exitButton = new JButton(""Exit"");
        exitButton.setMnemonic('x');
        exitButton.addActionListener(ExitAction.INSTANCE);
        gridbag.setConstraints(exitButton, c);
        add(exitButton);
        c.gridy++;
        final JButton clearButton = new JButton(""Clear"");
        clearButton.setMnemonic('c');
        clearButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.clear();
                }
            });
        gridbag.setConstraints(clearButton, c);
        add(clearButton);
        c.gridy++;
        final JButton toggleButton = new JButton(""Pause"");
        toggleButton.setMnemonic('p');
        toggleButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.toggle();
                    toggleButton.setText(
                        aModel.isPaused() ? ""Resume"" : ""Pause"");
                }
            });
        gridbag.setConstraints(toggleButton, c);
        add(toggleButton);
    }
}
"
org.apache.log4j.chainsaw.DetailPanel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.awt.BorderLayout;
import java.text.MessageFormat;
import java.util.Date;
import javax.swing.BorderFactory;
import javax.swing.JEditorPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.apache.log4j.Category;
/**
 * A panel for showing a stack trace.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 */
class DetailPanel
    extends JPanel
    implements ListSelectionListener
{
    /** used to log events **/
    private static final Category LOG =
        Category.getInstance(DetailPanel.class);
    /** used to format the logging event **/
    private static final MessageFormat FORMATTER = new MessageFormat(
        ""<b>Time:</b> <code>{0,time,medium}</code>"" +
        ""&nbsp;&nbsp;<b>Priority:</b> <code>{1}</code>"" +
        ""&nbsp;&nbsp;<b>Thread:</b> <code>{2}</code>"" +
        ""&nbsp;&nbsp;<b>NDC:</b> <code>{3}</code>"" +
        ""<br><b>Category:</b> <code>{4}</code>"" +
        ""<br><b>Location:</b> <code>{5}</code>"" +
        ""<br><b>Message:</b>"" +
        ""<pre>{6}</pre>"" +
        ""<b>Throwable:</b>"" +
        ""<pre>{7}</pre>"");
    /** the model for the data to render **/
    private final MyTableModel mModel;
    /** pane for rendering detail **/
    private final JEditorPane mDetails;
    /**
     * Creates a new <code>DetailPanel</code> instance.
     *
     * @param aTable the table to listen for selections on
     * @param aModel the model backing the table
     */
    DetailPanel(JTable aTable, final MyTableModel aModel) {
        mModel = aModel;
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder(""Details: ""));
        mDetails = new JEditorPane();
        mDetails.setEditable(false);
        mDetails.setContentType(""text/html"");
        add(new JScrollPane(mDetails), BorderLayout.CENTER);
        final ListSelectionModel rowSM = aTable.getSelectionModel();
        rowSM.addListSelectionListener(this);
    }
    /** @see ListSelectionListener **/
    public void valueChanged(ListSelectionEvent aEvent) {
        //Ignore extra messages.
        if (aEvent.getValueIsAdjusting()) {
            return;
        }
        final ListSelectionModel lsm = (ListSelectionModel) aEvent.getSource();
        if (lsm.isSelectionEmpty()) {
            mDetails.setText(""Nothing selected"");
        } else {
            final int selectedRow = lsm.getMinSelectionIndex();
            final EventDetails e = mModel.getEventDetails(selectedRow);
            final Object[] args =
            {
                new Date(e.getTimeStamp()),
                e.getPriority(),
                escape(e.getThreadName()),
                escape(e.getNDC()),
                escape(e.getCategoryName()),
                escape(e.getLocationDetails()),
                escape(e.getMessage()),
                escape(getThrowableStrRep(e))
            };
            mDetails.setText(FORMATTER.format(args));
            mDetails.setCaretPosition(0);
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////////////////////
    /**
     * Returns a string representation of a throwable.
     *
     * @param aEvent contains the throwable information
     * @return a <code>String</code> value
     */
    private static String getThrowableStrRep(EventDetails aEvent) {
        final String[] strs = aEvent.getThrowableStrRep();
        if (strs == null) {
            return null;
        }
        final StringBuffer sb = new StringBuffer();
        for (int i = 0; i < strs.length; i++) {
            sb.append(strs[i]).append(""\n"");
        }
        return sb.toString();
    }
    /**
     * Escape &lt;, &gt; &amp; and &quot; as their entities. It is very
     * dumb about &amp; handling.
     * @param aStr the String to escape.
     * @return the escaped String
     */
    private String escape(String aStr) {
        if (aStr == null) {
            return null;
        }
        final StringBuffer buf = new StringBuffer();
        for (int i = 0; i < aStr.length(); i++) {
            char c = aStr.charAt(i);
            switch (c) {
            case '<':
                buf.append(""&lt;"");
                break;
            case '>':
                buf.append(""&gt;"");
                break;
            case '\""':
                buf.append(""&quot;"");
                break;
            case '&':
                buf.append(""&amp;"");
                break;
            default:
                buf.append(c);
                break;
            }
        }
        return buf.toString();
    }
}
"
org.apache.log4j.chainsaw.EventDetails,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.LoggingEvent;
/**
 * Represents the details of a logging event. It is intended to overcome the
 * problem that a LoggingEvent cannot be constructed with purely fake data.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 * @version 1.0
 */
class EventDetails {
    /** the time of the event **/
    private final long mTimeStamp;
    /** the priority of the event **/
    private final Priority mPriority;
    /** the category of the event **/
    private final String mCategoryName;
    /** the NDC for the event **/
    private final String mNDC;
    /** the thread for the event **/
    private final String mThreadName;
    /** the msg for the event **/
    private final String mMessage;
    /** the throwable details the event **/
    private final String[] mThrowableStrRep;
    /** the location details for the event **/
    private final String mLocationDetails;
    /**
     * Creates a new <code>EventDetails</code> instance.
     * @param aTimeStamp a <code>long</code> value
     * @param aPriority a <code>Priority</code> value
     * @param aCategoryName a <code>String</code> value
     * @param aNDC a <code>String</code> value
     * @param aThreadName a <code>String</code> value
     * @param aMessage a <code>String</code> value
     * @param aThrowableStrRep a <code>String[]</code> value
     * @param aLocationDetails a <code>String</code> value
     */
    EventDetails(long aTimeStamp,
                 Priority aPriority,
                 String aCategoryName,
                 String aNDC,
                 String aThreadName,
                 String aMessage,
                 String[] aThrowableStrRep,
                 String aLocationDetails)
    {
        mTimeStamp = aTimeStamp;
        mPriority = aPriority;
        mCategoryName = aCategoryName;
        mNDC = aNDC;
        mThreadName = aThreadName;
        mMessage = aMessage;
        mThrowableStrRep = aThrowableStrRep;
        mLocationDetails = aLocationDetails;
    }
    /**
     * Creates a new <code>EventDetails</code> instance.
     *
     * @param aEvent a <code>LoggingEvent</code> value
     */
    EventDetails(LoggingEvent aEvent) {
        this(aEvent.timeStamp,
             aEvent.level,
             aEvent.categoryName,
             aEvent.getNDC(),
             aEvent.getThreadName(),
             aEvent.getRenderedMessage(),
             aEvent.getThrowableStrRep(),
             (aEvent.getLocationInformation() == null)
             ? null : aEvent.getLocationInformation().fullInfo);
    }
    /** @see #mTimeStamp **/
    long getTimeStamp() {
        return mTimeStamp;
    }
    /** @see #mPriority **/
    Priority getPriority() {
        return mPriority;
    }
    /** @see #mCategoryName **/
    String getCategoryName() {
        return mCategoryName;
    }
    /** @see #mNDC **/
    String getNDC() {
        return mNDC;
    }
    /** @see #mThreadName **/
    String getThreadName() {
        return mThreadName;
    }
    /** @see #mMessage **/
    String getMessage() {
        return mMessage;
    }
    /** @see #mLocationDetails **/
    String getLocationDetails(){
        return mLocationDetails;
    }
    /** @see #mThrowableStrRep **/
    String[] getThrowableStrRep() {
        return mThrowableStrRep;
    }
}
"
org.apache.log4j.chainsaw.ExitAction,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import org.apache.log4j.Category;
/**
 * Encapsulates the action to exit.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 * @version 1.0
 */
class ExitAction
    extends AbstractAction
{
    /** use to log messages **/
    private static final Category LOG = Category.getInstance(ExitAction.class);
    /** The instance to share **/
    public static final ExitAction INSTANCE = new ExitAction();
    /** Stop people creating instances **/
    private ExitAction() {}
    /**
     * Will shutdown the application.
     * @param aIgnore ignored
     */
    public void actionPerformed(ActionEvent aIgnore) {
        LOG.info(""shutting down"");
        System.exit(0);
    }
}
"
org.apache.log4j.chainsaw.LoadXMLAction,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import javax.swing.AbstractAction;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import org.apache.log4j.Category;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
/**
 * Encapsulates the action to load an XML file.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 * @version 1.0
 */
class LoadXMLAction
    extends AbstractAction
{
    /** use to log messages **/
    private static final Category LOG =
        Category.getInstance(LoadXMLAction.class);
    /** the parent frame **/
    private final JFrame mParent;
    /**
     * the file chooser - configured to allow only the selection of a
     * single file.
     */
    private final JFileChooser mChooser = new JFileChooser();
    {
        mChooser.setMultiSelectionEnabled(false);
        mChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
    }
    /** parser to read XML files **/
    private final XMLReader mParser;
    /** the content handler **/
    private final XMLFileHandler mHandler;
    /**
     * Creates a new <code>LoadXMLAction</code> instance.
     *
     * @param aParent the parent frame
     * @param aModel the model to add events to
     * @exception SAXException if an error occurs
     * @throws ParserConfigurationException if an error occurs
     */
    LoadXMLAction(JFrame aParent, MyTableModel aModel)
        throws SAXException, ParserConfigurationException
    {
        mParent = aParent;
        mHandler = new XMLFileHandler(aModel);
        mParser = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
        mParser.setContentHandler(mHandler);
    }
    /**
     * Prompts the user for a file to load events from.
     * @param aIgnore an <code>ActionEvent</code> value
     */
    public void actionPerformed(ActionEvent aIgnore) {
        LOG.info(""load file called"");
        if (mChooser.showOpenDialog(mParent) == JFileChooser.APPROVE_OPTION) {
            LOG.info(""Need to load a file"");
            final File chosen = mChooser.getSelectedFile();
            LOG.info(""loading the contents of "" + chosen.getAbsolutePath());
            try {
                final int num = loadFile(chosen.getAbsolutePath());
                JOptionPane.showMessageDialog(
                    mParent,
                    ""Loaded "" + num + "" events."",
                    ""CHAINSAW"",
                    JOptionPane.INFORMATION_MESSAGE);
            } catch (Exception e) {
                LOG.warn(""caught an exception loading the file"", e);
                JOptionPane.showMessageDialog(
                    mParent,
                    ""Error parsing file - "" + e.getMessage(),
                    ""CHAINSAW"",
                    JOptionPane.ERROR_MESSAGE);
            }
        }
    }
    /**
     * Loads the contents of file into the model
     *
     * @param aFile the file to extract events from
     * @return the number of events loaded
     * @throws SAXException if an error occurs
     * @throws IOException if an error occurs
     */
    private int loadFile(String aFile)
        throws SAXException, IOException
    {
        synchronized (mParser) {
            // Create a dummy document to parse the file
            final StringBuffer buf = new StringBuffer();
            buf.append(""<?xml version=\""1.0\"" standalone=\""yes\""?>\n"");
            buf.append(""<!DOCTYPE log4j:eventSet "");
            buf.append(""[<!ENTITY data SYSTEM \""file:///"");
            buf.append(aFile);
            buf.append(""\"">]>\n"");
            buf.append(""<log4j:eventSet xmlns:log4j=\""Claira\"">\n"");
            buf.append(""&data;\n"");
            buf.append(""</log4j:eventSet>\n"");
            final InputSource is =
                new InputSource(new StringReader(buf.toString()));
            mParser.parse(is);
            return mHandler.getNumEvents();
        }
    }
}
"
org.apache.log4j.chainsaw.LoggingReceiver,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.io.EOFException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import org.apache.log4j.Logger;
import org.apache.log4j.spi.LoggingEvent;
/**
 * A daemon thread the processes connections from a
 * <code>org.apache.log4j.net.SocketAppender.html</code>.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 */
class LoggingReceiver extends Thread {
    /** used to log messages **/
    private static final Logger logger = Logger.getLogger(LoggingReceiver.class);
    /**
     * Helper that actually processes a client connection. It receives events
     * and adds them to the supplied model.
     *
     * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
     */
    private class Slurper implements Runnable {
        /** socket connection to read events from **/
        private final Socket mClient;
        /**
         * Creates a new <code>Slurper</code> instance.
         *
         * @param aClient socket to receive events from
         */
        Slurper(Socket aClient) {
            mClient = aClient;
        }
        /** loops getting the events **/
        public void run() {
            logger.debug(""Starting to get data"");
            try {
                final ObjectInputStream ois =
                    new ObjectInputStream(mClient.getInputStream());
                while (true) {
                    final LoggingEvent event = (LoggingEvent) ois.readObject();
                    mModel.addEvent(new EventDetails(event));
                }
            } catch (EOFException e) {
                logger.info(""Reached EOF, closing connection"");
            } catch (SocketException e) {
                logger.info(""Caught SocketException, closing connection"");
            } catch (IOException e) {
                logger.warn(""Got IOException, closing connection"", e);
            } catch (ClassNotFoundException e) {
                logger.warn(""Got ClassNotFoundException, closing connection"", e);
            }
            try {
                mClient.close();
            } catch (IOException e) {
                logger.warn(""Error closing connection"", e);
            }
        }
    }
    /** where to put the events **/
    private final MyTableModel mModel;
    /** server for listening for connections **/
    private final ServerSocket mSvrSock;
    /**
     * Creates a new <code>LoggingReceiver</code> instance.
     *
     * @param aModel model to place put received into
     * @param aPort port to listen on
     * @throws IOException if an error occurs
     */
    LoggingReceiver(MyTableModel aModel, int aPort) throws IOException {
        setDaemon(true);
        mModel = aModel;
        mSvrSock = new ServerSocket(aPort);
    }
    /** Listens for client connections **/
    public void run() {
        logger.info(""Thread started"");
        try {
            while (true) {
                logger.debug(""Waiting for a connection"");
                final Socket client = mSvrSock.accept();
                logger.debug(""Got a connection from "" +
                          client.getInetAddress().getHostName());
                final Thread t = new Thread(new Slurper(client));
                t.setDaemon(true);
                t.start();
            }
        } catch (IOException e) {
            logger.error(""Error in accepting connections, stopping."", e);
        }
    }
}
"
org.apache.log4j.chainsaw.Main,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.util.Properties;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
 * The main application.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 */
public class Main
    extends JFrame
{
    /** the default port number to listen on **/
    private static final int DEFAULT_PORT = 4445;
    /** name of property for port name **/
    public static final String PORT_PROP_NAME = ""chainsaw.port"";
    /** use to log messages **/
    private static final Category LOG = Category.getInstance(Main.class);
    /**
     * Creates a new <code>Main</code> instance.
     */
    private Main() {
        super(""CHAINSAW - Log4J Log Viewer"");
        // create the all important model
        final MyTableModel model = new MyTableModel();
        //Create the menu bar.
        final JMenuBar menuBar = new JMenuBar();
        setJMenuBar(menuBar);
        final JMenu menu = new JMenu(""File"");
        menuBar.add(menu);
        try {
            final LoadXMLAction lxa = new LoadXMLAction(this, model);
            final JMenuItem loadMenuItem = new JMenuItem(""Load file..."");
            menu.add(loadMenuItem);
            loadMenuItem.addActionListener(lxa);
        } catch (NoClassDefFoundError e) {
            LOG.info(""Missing classes for XML parser"", e);
            JOptionPane.showMessageDialog(
                this,
                ""XML parser not in classpath - unable to load XML events."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
        } catch (Exception e) {
            LOG.info(""Unable to create the action to load XML files"", e);
            JOptionPane.showMessageDialog(
                this,
                ""Unable to create a XML parser - unable to load XML events."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
        }
        final JMenuItem exitMenuItem = new JMenuItem(""Exit"");
        menu.add(exitMenuItem);
        exitMenuItem.addActionListener(ExitAction.INSTANCE);
        // Add control panel
        final ControlPanel cp = new ControlPanel(model);
        getContentPane().add(cp, BorderLayout.NORTH);
        // Create the table
        final JTable table = new JTable(model);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        final JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setBorder(BorderFactory.createTitledBorder(""Events: ""));
        scrollPane.setPreferredSize(new Dimension(900, 300));
        // Create the details
        final JPanel details = new DetailPanel(table, model);
        details.setPreferredSize(new Dimension(900, 300));
        // Add the table and stack trace into a splitter
        final JSplitPane jsp =
            new JSplitPane(JSplitPane.VERTICAL_SPLIT, scrollPane, details);
        getContentPane().add(jsp, BorderLayout.CENTER);
        addWindowListener(new WindowAdapter() {
                public void windowClosing(WindowEvent aEvent) {
                    ExitAction.INSTANCE.actionPerformed(null);
                }
            });
        pack();
        setVisible(true);
        setupReceiver(model);
    }
    /**
     * Setup recieving messages.
     *
     * @param aModel a <code>MyTableModel</code> value
     */
    private void setupReceiver(MyTableModel aModel) {
        int port = DEFAULT_PORT;
        final String strRep = System.getProperty(PORT_PROP_NAME);
        if (strRep != null) {
            try {
                port = Integer.parseInt(strRep);
            } catch (NumberFormatException nfe) {
                LOG.fatal(""Unable to parse "" + PORT_PROP_NAME +
                          "" property with value "" + strRep + ""."");
                JOptionPane.showMessageDialog(
                    this,
                    ""Unable to parse port number from '"" + strRep +
                    ""', quitting."",
                    ""CHAINSAW"",
                    JOptionPane.ERROR_MESSAGE);
                System.exit(1);
            }
        }
        try {
            final LoggingReceiver lr = new LoggingReceiver(aModel, port);
            lr.start();
        } catch (IOException e) {
            LOG.fatal(""Unable to connect to socket server, quiting"", e);
            JOptionPane.showMessageDialog(
                this,
                ""Unable to create socket on port "" + port + "", quitting."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    // static methods
    ////////////////////////////////////////////////////////////////////////////
    /** initialise log4j **/
    private static void initLog4J() {
        final Properties props = new Properties();
        props.setProperty(""log4j.rootCategory"", ""DEBUG, A1"");
        props.setProperty(""log4j.appender.A1"",
                          ""org.apache.log4j.ConsoleAppender"");
        props.setProperty(""log4j.appender.A1.layout"",
                          ""org.apache.log4j.TTCCLayout"");
        PropertyConfigurator.configure(props);
    }
    /**
     * The main method.
     *
     * @param aArgs ignored
     */
    public static void main(String[] aArgs) {
        initLog4J();
        new Main();
    }
}
"
org.apache.log4j.chainsaw.MyTableModel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import javax.swing.table.AbstractTableModel;
import org.apache.log4j.Priority;
import org.apache.log4j.Category;
/**
 * Represents a list of <code>EventDetails</code> objects that are sorted on
 * logging time. Methods are provided to filter the events that are visible.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 */
class MyTableModel
    extends AbstractTableModel
{
    /** used to log messages **/
    private static final Category LOG =
        Category.getInstance(MyTableModel.class);
    /** use the compare logging events **/
    private static final Comparator MY_COMP = new Comparator()
    {
        /** @see Comparator **/
        public int compare(Object aObj1, Object aObj2) {
            if ((aObj1 == null) && (aObj2 == null)) {
                return 0; // treat as equal
            } else if (aObj1 == null) {
                return -1; // null less than everything
            } else if (aObj2 == null) {
                return 1; // think about it. :->
            }
            // will assume only have LoggingEvent
            final EventDetails le1 = (EventDetails) aObj1;
            final EventDetails le2 = (EventDetails) aObj2;
            if (le1.getTimeStamp() < le2.getTimeStamp()) {
                return 1;
            }
            // assume not two events are logged at exactly the same time
            return -1;
        }
        };
    /**
     * Helper that actually processes incoming events.
     * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
     */
    private class Processor
        implements Runnable
    {
        /** loops getting the events **/
        public void run() {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // ignore
                }
                synchronized (mLock) {
                    if (mPaused) {
                        continue;
                    }
                    boolean toHead = true; // were events added to head
                    boolean needUpdate = false;
                    final Iterator it = mPendingEvents.iterator();
                    while (it.hasNext()) {
                        final EventDetails event = (EventDetails) it.next();
                        mAllEvents.add(event);
                        toHead = toHead && (event == mAllEvents.first());
                        needUpdate = needUpdate || matchFilter(event);
                    }
                    mPendingEvents.clear();
                    if (needUpdate) {
                        updateFilteredEvents(toHead);
                    }
                }
            }
        }
    }
    /** names of the columns in the table **/
    private static final String[] COL_NAMES = {
        ""Time"", ""Priority"", ""Trace"", ""Category"", ""NDC"", ""Message""};
    /** definition of an empty list **/
    private static final EventDetails[] EMPTY_LIST =  new EventDetails[] {};
    /** used to format dates **/
    private static final DateFormat DATE_FORMATTER =
        DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);
    /** the lock to control access **/
    private final Object mLock = new Object();
    /** set of all logged events - not filtered **/
    private final SortedSet mAllEvents = new TreeSet(MY_COMP);
    /** events that are visible after filtering **/
    private EventDetails[] mFilteredEvents = EMPTY_LIST;
    /** list of events that are buffered for processing **/
    private final List mPendingEvents = new ArrayList();
    /** indicates whether event collection is paused to the UI **/
    private boolean mPaused = false;
    /** filter for the thread **/
    private String mThreadFilter = """";
    /** filter for the message **/
    private String mMessageFilter = """";
    /** filter for the NDC **/
    private String mNDCFilter = """";
    /** filter for the category **/
    private String mCategoryFilter = """";
    /** filter for the priority **/
    private Priority mPriorityFilter = Priority.DEBUG;
    /**
     * Creates a new <code>MyTableModel</code> instance.
     *
     */
    MyTableModel() {
        final Thread t = new Thread(new Processor());
        t.setDaemon(true);
        t.start();
    }
    ////////////////////////////////////////////////////////////////////////////
    // Table Methods
    ////////////////////////////////////////////////////////////////////////////
    /** @see javax.swing.table.TableModel **/
    public int getRowCount() {
        synchronized (mLock) {
            return mFilteredEvents.length;
        }
    }
    /** @see javax.swing.table.TableModel **/
    public int getColumnCount() {
        // does not need to be synchronized
        return COL_NAMES.length;
    }
    /** @see javax.swing.table.TableModel **/
    public String getColumnName(int aCol) {
        // does not need to be synchronized
        return COL_NAMES[aCol];
    }
    /** @see javax.swing.table.TableModel **/
    public Class getColumnClass(int aCol) {
        // does not need to be synchronized
        return (aCol == 2) ? Boolean.class : Object.class;
    }
    /** @see javax.swing.table.TableModel **/
    public Object getValueAt(int aRow, int aCol) {
        synchronized (mLock) {
            final EventDetails event = mFilteredEvents[aRow];
            if (aCol == 0) {
                return DATE_FORMATTER.format(new Date(event.getTimeStamp()));
            } else if (aCol == 1) {
                return event.getPriority();
            } else if (aCol == 2) {
                return (event.getThrowableStrRep() == null)
                    ? Boolean.FALSE : Boolean.TRUE;
            } else if (aCol == 3) {
                return event.getCategoryName();
            } else if (aCol == 4) {
                return event.getNDC();
            }
            return event.getMessage();
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    // Public Methods
    ////////////////////////////////////////////////////////////////////////////
    /**
     * Sets the priority to filter events on. Only events of equal or higher
     * property are now displayed.
     *
     * @param aPriority the priority to filter on
     */
    public void setPriorityFilter(Priority aPriority) {
        synchronized (mLock) {
            mPriorityFilter = aPriority;
            updateFilteredEvents(false);
        }
    }
    /**
     * Set the filter for the thread field.
     *
     * @param aStr the string to match
     */
    public void setThreadFilter(String aStr) {
        synchronized (mLock) {
            mThreadFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }
    /**
     * Set the filter for the message field.
     *
     * @param aStr the string to match
     */
    public void setMessageFilter(String aStr) {
        synchronized (mLock) {
            mMessageFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }
    /**
     * Set the filter for the NDC field.
     *
     * @param aStr the string to match
     */
    public void setNDCFilter(String aStr) {
        synchronized (mLock) {
            mNDCFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }
    /**
     * Set the filter for the category field.
     *
     * @param aStr the string to match
     */
    public void setCategoryFilter(String aStr) {
        synchronized (mLock) {
            mCategoryFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }
    /**
     * Add an event to the list.
     *
     * @param aEvent a <code>EventDetails</code> value
     */
    public void addEvent(EventDetails aEvent) {
        synchronized (mLock) {
            mPendingEvents.add(aEvent);
        }
    }
    /**
     * Clear the list of all events.
     */
    public void clear() {
        synchronized (mLock) {
            mAllEvents.clear();
            mFilteredEvents = new EventDetails[0];
            mPendingEvents.clear();
            fireTableDataChanged();
        }
    }
    /** Toggle whether collecting events **/
    public void toggle() {
        synchronized (mLock) {
            mPaused = !mPaused;
        }
    }
    /** @return whether currently paused collecting events **/
    public boolean isPaused() {
        synchronized (mLock) {
            return mPaused;
        }
    }
    /**
     * Get the throwable information at a specified row in the filtered events.
     *
     * @param aRow the row index of the event
     * @return the throwable information
     */
    public EventDetails getEventDetails(int aRow) {
        synchronized (mLock) {
            return mFilteredEvents[aRow];
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////////////////////
    /**
     * Update the filtered events data structure.
     * @param aInsertedToFront indicates whether events were added to front of
     *        the events. If true, then the current first event must still exist
     *        in the list after the filter is applied.
     */
    private void updateFilteredEvents(boolean aInsertedToFront) {
        final long start = System.currentTimeMillis();
        final List filtered = new ArrayList();
        final int size = mAllEvents.size();
        final Iterator it = mAllEvents.iterator();
        while (it.hasNext()) {
            final EventDetails event = (EventDetails) it.next();
            if (matchFilter(event)) {
                filtered.add(event);
            }
        }
        final EventDetails lastFirst = (mFilteredEvents.length == 0)
            ? null
            : mFilteredEvents[0];
        mFilteredEvents = (EventDetails[]) filtered.toArray(EMPTY_LIST);
        if (aInsertedToFront && (lastFirst != null)) {
            final int index = filtered.indexOf(lastFirst);
            if (index < 1) {
                LOG.warn(""In strange state"");
                fireTableDataChanged();
            } else {
                fireTableRowsInserted(0, index - 1);
            }
        } else {
            fireTableDataChanged();
        }
        final long end = System.currentTimeMillis();
        LOG.debug(""Total time [ms]: "" + (end - start)
                  + "" in update, size: "" + size);
    }
    /**
     * Returns whether an event matches the filters.
     *
     * @param aEvent the event to check for a match
     * @return whether the event matches
     */
    private boolean matchFilter(EventDetails aEvent) {
        if (aEvent.getPriority().isGreaterOrEqual(mPriorityFilter) &&
            (aEvent.getThreadName().indexOf(mThreadFilter) >= 0) &&
            (aEvent.getCategoryName().indexOf(mCategoryFilter) >= 0) &&
            ((mNDCFilter.length() == 0) ||
             ((aEvent.getNDC() != null) &&
              (aEvent.getNDC().indexOf(mNDCFilter) >= 0))))
        {
            final String rm = aEvent.getMessage();
            if (rm == null) {
                // only match if we have not filtering in place
                return (mMessageFilter.length() == 0);
            } else {
                return (rm.indexOf(mMessageFilter) >= 0);
            }
        }
        return false; // by default not match
    }
}
"
org.apache.log4j.chainsaw.XMLFileHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.chainsaw;
import java.util.StringTokenizer;
import org.apache.log4j.Priority;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
/**
 * A content handler for document containing Log4J events logged using the
 * XMLLayout class. It will create events and add them to a supplied model.
 *
 * @author <a href=""mailto:oliver@puppycrawl.com"">Oliver Burn</a>
 * @version 1.0
 */
class XMLFileHandler
    extends DefaultHandler
{
    /** represents the event tag **/
    private static final String TAG_EVENT = ""log4j:event"";
    /** represents the message tag **/
    private static final String TAG_MESSAGE = ""log4j:message"";
    /** represents the ndc tag **/
    private static final String TAG_NDC = ""log4j:NDC"";
    /** represents the throwable tag **/
    private static final String TAG_THROWABLE = ""log4j:throwable"";
    /** represents the location info tag **/
    private static final String TAG_LOCATION_INFO = ""log4j:locationInfo"";
    /** where to put the events **/
    private final MyTableModel mModel;
    /** the number of events in the document **/
    private int mNumEvents;
    /** the current element being parsed **/
    private String mCurrentElement;
    /** the time of the event **/
    private long mTimeStamp;
    /** the priority of the event **/
    private Priority mPriority;
    /** the category of the event **/
    private String mCategoryName;
    /** the NDC for the event **/
    private String mNDC;
    /** the thread for the event **/
    private String mThreadName;
    /** the msg for the event **/
    private String mMessage;
    /** the throwable details the event **/
    private String[] mThrowableStrRep;
    /** the location details for the event **/
    private String mLocationDetails;
    /**
     * Creates a new <code>XMLFileHandler</code> instance.
     *
     * @param aModel where to add the events
     */
    XMLFileHandler(MyTableModel aModel) {
        mModel = aModel;
    }
    /** @see DefaultHandler **/
    public void startDocument()
        throws SAXException
    {
        mNumEvents = 0;
    }
    /** @see DefaultHandler **/
    public void characters(char[] aChars, int aStart, int aLength) {
        if (mCurrentElement == TAG_NDC) {
            mNDC = new String(aChars, aStart, aLength);
        } else if (mCurrentElement == TAG_MESSAGE) {
            mMessage = new String(aChars, aStart, aLength);
        } else if (mCurrentElement == TAG_THROWABLE) {
            final StringTokenizer st =
                new StringTokenizer(new String(aChars, aStart, aLength), ""\t"");
            mThrowableStrRep = new String[st.countTokens()];
            if (mThrowableStrRep.length > 0) {
                mThrowableStrRep[0] = st.nextToken();
                for (int i = 1; i < mThrowableStrRep.length; i++) {
                    mThrowableStrRep[i] = ""\t"" + st.nextToken();
                }
            }
        }
    }
    /** @see DefaultHandler **/
    public void endElement(String aNamespaceURI,
                           String aLocalName,
                           String aQName)
    {
        if (TAG_EVENT.equals(aQName)) {
            addEvent();
            resetData();
        } else if (mCurrentElement != TAG_EVENT) {
            mCurrentElement = TAG_EVENT; // hack - but only thing I care about
        }
    }
    /** @see DefaultHandler **/
    public void startElement(String aNamespaceURI,
                             String aLocalName,
                             String aQName,
                             Attributes aAtts)
    {
        if (TAG_EVENT.equals(aQName)) {
            mThreadName = aAtts.getValue(""thread"");
            mTimeStamp = Long.parseLong(aAtts.getValue(""timestamp""));
            mCategoryName = aAtts.getValue(""category"");
            mPriority = Priority.toPriority(aAtts.getValue(""level""));
        } else if (TAG_LOCATION_INFO.equals(aQName)) {
            mLocationDetails = aAtts.getValue(""class"") + "".""
                + aAtts.getValue(""method"")
                + ""("" + aAtts.getValue(""file"") + "":"" + aAtts.getValue(""line"")
                + "")"";
        } else if (TAG_NDC.equals(aQName)) {
            mCurrentElement = TAG_NDC;
        } else if (TAG_MESSAGE.equals(aQName)) {
            mCurrentElement = TAG_MESSAGE;
        } else if (TAG_THROWABLE.equals(aQName)) {
            mCurrentElement = TAG_THROWABLE;
        }
    }
    /** @return the number of events in the document **/
    int getNumEvents() {
        return mNumEvents;
    }
    ////////////////////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////////////////////
    /** Add an event to the model **/
    private void addEvent() {
        mModel.addEvent(new EventDetails(mTimeStamp,
                                         mPriority,
                                         mCategoryName,
                                         mNDC,
                                         mThreadName,
                                         mMessage,
                                         mThrowableStrRep,
                                         mLocationDetails));
        mNumEvents++;
    }
    /** Reset the data for an event **/
    private void resetData() {
        mTimeStamp = 0;
        mPriority = null;
        mCategoryName = null;
        mNDC = null;
        mThreadName = null;
        mMessage = null;
        mThrowableStrRep = null;
        mLocationDetails = null;
    }
}
"
org.apache.log4j.config.PropertyGetter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.config;
import java.beans.*;
import java.lang.reflect.*;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
/**
   Used for inferring configuration information for a log4j's component.
   @author  Anders Kristensen
 */
public class PropertyGetter {
  protected static final Object[] NULL_ARG = new Object[] {};
  protected Object obj;
  protected PropertyDescriptor[] props;
  public interface PropertyCallback {
    void foundProperty(Object obj, String prefix, String name, Object value);
  }
  /**
    Create a new PropertyGetter for the specified Object. This is done
    in prepartion for invoking {@link
    #getProperties(PropertyGetter.PropertyCallback, String)} one or
    more times.
    @param obj the object for which to set properties */
  public
  PropertyGetter(Object obj) throws IntrospectionException {
    BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
    props = bi.getPropertyDescriptors();
    this.obj = obj;
  }
  public
  static
  void getProperties(Object obj, PropertyCallback callback, String prefix) {
    try {
      new PropertyGetter(obj).getProperties(callback, prefix);
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect object "" + obj, ex);
    }
  }
  public
  void getProperties(PropertyCallback callback, String prefix) {
    for (int i = 0; i < props.length; i++) {
      Method getter = props[i].getReadMethod();
      if (getter == null) continue;
      if (!isHandledType(getter.getReturnType())) {
	//System.err.println(""Ignoring "" + props[i].getName() +"" "" + getter.getReturnType());
	continue;
      }
      String name = props[i].getName();
      try {
	Object result = getter.invoke(obj, NULL_ARG);
	//System.err.println(""PROP "" + name +"": "" + result);
	if (result != null) {
	  callback.foundProperty(obj, prefix, name, result);
	}
      } catch (Exception ex) {
	LogLog.warn(""Failed to get value of property "" + name);
      }
    }
  }
  protected
  boolean isHandledType(Class type) {
    return String.class.isAssignableFrom(type) ||
      Integer.TYPE.isAssignableFrom(type) ||
      Long.TYPE.isAssignableFrom(type)    ||
      Boolean.TYPE.isAssignableFrom(type) ||
      Priority.class.isAssignableFrom(type);
  }
}
"
org.apache.log4j.config.PropertyPrinter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.config;
import java.io.*;
import java.util.*;
import org.apache.log4j.*;
/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on a {@link PrintWriter}.
   @author  Anders Kristensen
 */
public class PropertyPrinter implements PropertyGetter.PropertyCallback {
  protected int numAppenders = 0;
  protected Hashtable appenderNames = new Hashtable();
  protected Hashtable layoutNames   = new Hashtable();
  protected PrintWriter out;
  protected boolean doCapitalize;
  public
  PropertyPrinter(PrintWriter out) {
    this(out, false);
  }
  public
  PropertyPrinter(PrintWriter out, boolean doCapitalize) {
    this.out = out;
    this.doCapitalize = doCapitalize;
    print(out);
    out.flush();
  }
  protected
  String genAppName() {
    return ""A"" + numAppenders++;
  }
  /**
     Returns true if the specified appender name is considered to have
     been generated, i.e. if it is of the form A[0-9]+.
  */
  protected
  boolean isGenAppName(String name) {
    if (name.length() < 2 || name.charAt(0) != 'A') return false;
    for (int i = 0; i < name.length(); i++) {
      if (name.charAt(i) < '0' || name.charAt(i) > '9') return false;
    }
    return true;
  }
  /**
   * Prints the configuration of the default log4j hierarchy as a Java
   * properties file on the specified Writer.
   * 
   * <p>N.B. print() can be invoked only once!
   */
  public
  void print(PrintWriter out) {
    printOptions(out, Category.getRoot());
    Enumeration cats = Category.getCurrentCategories();
    while (cats.hasMoreElements()) {
      printOptions(out, (Category) cats.nextElement());
    }
  }
  protected
  void printOptions(PrintWriter out, Category cat) {
    Enumeration appenders = cat.getAllAppenders();
    Level prio = cat.getLevel();
    String appenderString = (prio == null ? """" : prio.toString());
    while (appenders.hasMoreElements()) {
      Appender app = (Appender) appenders.nextElement();
      String name;
      if ((name = (String) appenderNames.get(app)) == null) {
        // first assign name to the appender
        if ((name = app.getName()) == null || isGenAppName(name)) {
            name = genAppName();
        }
        appenderNames.put(app, name);
        printOptions(out, app, ""log4j.appender.""+name);
        if (app.getLayout() != null) {
          printOptions(out, app.getLayout(), ""log4j.appender.""+name+"".layout"");
        }
      }
      appenderString += "", "" + name;
    }
    String catKey = (cat == Category.getRoot())
        ? ""log4j.rootCategory""
        : ""log4j.category."" + cat.getName();
    if (appenderString != """") {
      out.println(catKey + ""="" + appenderString);
    }
  }
  protected
  void printOptions(PrintWriter out, Object obj, String fullname) {
    out.println(fullname + ""="" + obj.getClass().getName());
    PropertyGetter.getProperties(obj, this, fullname + ""."");
  }
  public void foundProperty(Object obj, String prefix, String name, Object value) {
    // XXX: Properties encode value.toString()
    if (obj instanceof Appender && ""name"".equals(name)) {
      return;
    }
    if (doCapitalize) {
      name = capitalize(name);
    }
    out.println(prefix + name + ""="" + value.toString());
  }
  public static String capitalize(String name) {
    if (Character.isLowerCase(name.charAt(0))) {
      if (name.length() == 1 || Character.isLowerCase(name.charAt(1))) {
        StringBuffer newname = new StringBuffer(name);
        newname.setCharAt(0, Character.toUpperCase(name.charAt(0)));
        return newname.toString();
      }
    }
    return name;
  }
  // for testing
  public static void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out));
  }
}
"
org.apache.log4j.config.PropertySetter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// Contributors:  Georg Lundesgaard
package org.apache.log4j.config;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
/**
   General purpose Object property setter. Clients repeatedly invokes
   {@link #setProperty setProperty(name,value)} in order to invoke setters
   on the Object specified in the constructor. This class relies on the
   JavaBeans {@link Introspector} to analyze the given Object Class using
   reflection.
   <p>Usage:
   <pre>
     PropertySetter ps = new PropertySetter(anObject);
     ps.set(""name"", ""Joe"");
     ps.set(""age"", ""32"");
     ps.set(""isMale"", ""true"");
   </pre>
   will cause the invocations anObject.setName(""Joe""), anObject.setAge(32),
   and setMale(true) if such methods exist with those signatures.
   Otherwise an {@link IntrospectionException} are thrown.
   @author Anders Kristensen
   @since 1.1
 */
public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link #setProperty} one or more times.
    @param obj  the object for which to set properties
   */
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  /**
     Uses JavaBeans {@link Introspector} to computer setters of object to be
     configured.
   */
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect ""+obj+"": "" + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  /**
     Set the properties of an object passed as a parameter in one
     go. The <code>properties</code> are parsed relative to a
     <code>prefix</code>.
     @param obj The object to configure.
     @param properties A java.util.Properties containing keys and values.
     @param prefix Only keys having the specified prefix will be set.
  */
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  /**
     Set the properites for the object that match the
     <code>prefix</code> passed as parameter.
   */
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      // handle only properties that start with the desired frefix.
      if (key.startsWith(prefix)) {
	// ignore key if it contains dots after the prefix
        if (key.indexOf('.', len + 1) > 0) {
	  //System.err.println(""----------Ignoring---[""+key
	  //	     +""], prefix=[""+prefix+""]."");
	  continue;
	}
	String value = OptionConverter.findAndSubst(key, properties);
        key = key.substring(len);
        if (""layout"".equals(key) && obj instanceof Appender) {
          continue;
        }        
        setProperty(key, value);
      }
    }
    activate();
  }
  /**
     Set a property on this PropertySetter's Object. If successful, this
     method will invoke a setter method on the underlying Object. The
     setter is the one for the specified property name and the value is
     determined partly from the setter argument type and partly from the
     value specified in the call to this method.
     <p>If the setter expects a String no conversion is necessary.
     If it expects an int, then an attempt is made to convert 'value'
     to an int using new Integer(value). If the setter expects a boolean,
     the conversion is by new Boolean(value).
     @param name    name of the property
     @param value   String value of the property
   */
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    //LogLog.debug(""---------Key: ""+name+"", type=""+prop.getPropertyType());
    if (prop == null) {
      LogLog.warn(""No such property ["" + name + ""] in ""+
		  obj.getClass().getName()+""."" );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn(""Failed to set property ["" + name +
                    ""] to value \"""" + value + ""\"". "" + ex.getMessage());
      }
    }
  }
  /** 
      Set the named property given a {@link PropertyDescriptor}.
      @param prop A PropertyDescriptor describing the characteristics
      of the property to set.
      @param name The named of the property to set.
      @param value The value of the property.      
   */
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException(""No setter for property [""+name+""]."");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException(""#params for setter != 1"");
    }
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException(""Conversion to type [""+paramTypes[0]+
					""] failed. Reason: ""+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          ""Conversion to type [""+paramTypes[0]+""] failed."");
    }
    LogLog.debug(""Setting property ["" + name + ""] to ["" +arg+""]."");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (Exception ex) {
      throw new PropertySetterException(ex);
    }
  }
  /**
     Convert <code>val</code> a String parameter to an object of a
     given type.
  */
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;
    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if (""true"".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if (""false"".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return OptionConverter.toLevel(v, (Level) Level.DEBUG);
    }
    return null;
  }
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }
}
"
org.apache.log4j.config.PropertySetterException,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.config;
/**
 * Thrown when an error is encountered whilst attempting to set a property
 * using the {@link PropertySetter} utility class.
 * 
 * @author Anders Kristensen
 * @since 1.1
 */
public class PropertySetterException extends Exception {
  protected Throwable rootCause;
  public
  PropertySetterException(String msg) {
    super(msg);
  }
  public
  PropertySetterException(Throwable rootCause)
  {
    super();
    this.rootCause = rootCause;
  }
  /**
     Returns descriptive text on the cause of this exception.
   */
  public
  String getMessage() {
    String msg = super.getMessage();
    if (msg == null && rootCause != null) {
      msg = rootCause.getMessage();
    }
    return msg;
  }
}"
org.apache.log4j.helpers.AbsoluteTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} in the format ""HH:mm:ss,SSS"" for example,
   ""15:49:37,459"".
   @author Ceki G&uuml;lc&uuml;
   @author Andrew Vajoczki    
   @since 0.7.5
*/
public class AbsoluteTimeDateFormat extends DateFormat {
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.AbsoluteTimeDateFormat} in layouts. Current
     value is <b>ABSOLUTE</b>.  */
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.DateTimeDateFormat} in layouts.  Current
     value is <b>DATE</b>.
  */
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.ISO8601DateFormat} in layouts. Current
     value is <b>ISO8601</b>.
  */
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";
  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }
  private static long   previousTime;
  private static char[] previousTimeWithoutMillis = new char[9]; // ""HH:mm:ss.""
  /**
     Appends to <code>sbuf</code> the time in the format
     ""HH:mm:ss,SSS"" for example, ""15:49:37,459""
     @param date the date to format
     @param sbuf the string buffer to write to
     @param fieldPosition remains untouched
    */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    long now = date.getTime();
    int millis = (int)(now % 1000);
    if ((now - millis) != previousTime) {
      // We reach this point at most once per second
      // across all threads instead of each time format()
      // is called. This saves considerable CPU time.
      calendar.setTime(date);
      int start = sbuf.length();
      int hour = calendar.get(Calendar.HOUR_OF_DAY);
      if(hour < 10) {
	sbuf.append('0');
      }
      sbuf.append(hour);
      sbuf.append(':');
      int mins = calendar.get(Calendar.MINUTE);
      if(mins < 10) {
	sbuf.append('0');
      }
      sbuf.append(mins);
      sbuf.append(':');
      int secs = calendar.get(Calendar.SECOND);
      if(secs < 10) {
	sbuf.append('0');
      }
      sbuf.append(secs);
      sbuf.append(',');      
      // store the time string for next time to avoid recomputation
      sbuf.getChars(start, sbuf.length(), previousTimeWithoutMillis, 0);
      previousTime = now - millis;
    }
    else {
      sbuf.append(previousTimeWithoutMillis);
    }
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    sbuf.append(millis);
    return sbuf;
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.AppenderAttachableImpl,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;
/**
   A straightforward implementation of the {@link AppenderAttachable}
   interface.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AppenderAttachableImpl implements AppenderAttachable {
  /** Array of appenders. */
  protected Vector  appenderList;
  /**
     Attach an appender. If the appender is already in the list in
     won't be added again.
  */
  public
  void addAppender(Appender newAppender) {
    // Null values for newAppender parameter are strictly forbidden.
    if(newAppender == null)
      return;
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }
  /**
     Call the <code>doAppend</code> method on all attached appenders.  */
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;
    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }
  /**
     Get all attached appenders as an Enumeration. If there are no
     attached appenders <code>null</code> is returned.
     @return Enumeration An enumeration of attached appenders.
   */
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }
  /**
     Look for an attached appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return null
     otherwise.  
   */
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;
     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }
  /**
     Returns <code>true</code> if the specified appender is in the
     list of attached appenders, <code>false</code> otherwise.
     @since 1.2 */
  public 
  boolean isAttached(Appender appender) {
    if(appenderList == null || appender == null)
      return false;
     int size = appenderList.size();
     Appender a;
     for(int i = 0; i < size; i++) {
       a  = (Appender) appenderList.elementAt(i);
       if(a == appender)
	  return true;
     }
     return false;    
  }
  /**
     Remove all previously attached appenders.
  */
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }
  /**
     Remove the appender passed as parameter form the list of attached
     appenders.  */
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }
 /**
    Remove the appender with the name passed as parameter form the
    list of appenders.  
  */
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }
}
"
org.apache.log4j.helpers.BoundedFIFO,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// Contributors:     Mathias Bogaert
//                   joelr@viair.com
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <code>BoundedFIFO</code> serves as the bounded first-in-first-out
   buffer heavily used by the {@link org.apache.log4j.AsyncAppender}.
   @author Ceki G&uuml;lc&uuml; 
   @since version 0.9.1 */
public class BoundedFIFO {
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;
  /**
     Instantiate a new BoundedFIFO with a maximum size passed as argument.
   */
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  /**
     Get the first element in the buffer. Returns <code>null</code> if
     there are no elements in the buffer.  */
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    LoggingEvent r = buf[first];
    buf[first] = null; // help garbage collection
    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }
  /**
     Place a {@link LoggingEvent} in the buffer. If the buffer is full
     then the event is <b>silently dropped</b>. It is the caller's
     responsability to make sure that the buffer has free space.  */
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }
  /**
     Get the maximum size of the buffer.
   */
  public 
  int getMaxSize() {
    return maxSize;
  }
  /**
     Return <code>true</code> if the buffer is full, i.e. of the
     number of elements in the buffer equals the buffer size. */
  public 
  boolean isFull() {
    return numElements == maxSize;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElements;
  } 
  int min(int a, int b) {
    return a < b ? a : b;
  }
  /**
     Resize the buffer to a new size. If the new size is smaller than
     the old size events might be lost.
     @since 1.1
   */
  synchronized
  public 
  void resize(int newSize) {
    if(newSize == maxSize) 
      return;
   LoggingEvent[] tmp = new LoggingEvent[newSize];
   // we should not copy beyond the buf array
   int len1 = maxSize - first;
   // we should not copy beyond the tmp array
   len1 = min(len1, newSize);
   // er.. how much do we actually need to copy?
   // We should not copy more than the actual number of elements.
   len1 = min(len1, numElements);
   // Copy from buf starting a first, to tmp, starting at position 0, len1 elements.
   System.arraycopy(buf, first, tmp, 0, len1);
   // Are there any uncopied elements and is there still space in the new array?
   int len2 = 0;
   if((len1 < numElements) && (len1 < newSize)) {
     len2 = numElements - len1;
     len2 = min(len2, newSize - len1);
     System.arraycopy(buf, 0, tmp, len1, len2);
   }
   this.buf = tmp;
   this.maxSize = newSize;    
   this.first=0;   
   this.numElements = len1+len2;
   this.next = this.numElements;
   if(this.next == this.maxSize) // this should never happen, but again, it just might.
     this.next = 0;
  }
  /**
     Returns <code>true</code> if there is just one element in the
     buffer. In other words, if there were no elements before the last
     {@link #put} operation completed.  */
  public
  boolean wasEmpty() {
    return numElements == 1;
  }
  /**
      Returns <code>true</code> if the number of elements in the
      buffer plus 1 equals the maximum buffer size, returns
      <code>false</code> otherwise. */
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }
}
"
org.apache.log4j.helpers.CountingQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   Counts the number of bytes written.
   @author Heinz Richter, heinz.richter@frogdot.com
   @since 0.8.1
   */
public class CountingQuietWriter extends QuietWriter {
  protected long count;
  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }
  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }
  public
  long getCount() {
    return count;
  }
  public
  void setCount(long count) {
    this.count = count;
  }
}
"
org.apache.log4j.helpers.CyclicBuffer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   CyclicBuffer is used by other appenders to hold {@link LoggingEvent
   LoggingEvents} for immediate or differed display.
   <p>This buffer gives read access to any element in the buffer not
   just the first or last element.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public class CyclicBuffer {
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;
  /**
     Instantiate a new CyclicBuffer of at most <code>maxSize</code> events.
     The <code>maxSize</code> argument must a positive integer.
     @param maxSize The maximum number of elements in the buffer.
  */
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
  /**
     Add an <code>event</code> as the last event in the buffer.
   */
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;
    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }
  /**
     Get the <i>i</i>th oldest event currently in the buffer. If
     <em>i</em> is outside the range 0 to the number of elements
     currently in the buffer, then <code>null</code> is returned.
  */
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;
    return ea[(first + i) % maxSize];
  }
  public 
  int getMaxSize() {
    return maxSize;
  }
  /**
     Get the oldest (first) element in the buffer. The oldest element
     is removed from the buffer.
  */
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElems;
  } 
  /**
     Resize the cyclic buffer to <code>newSize</code>.
     @throws IllegalArgumentException if <code>newSize</code> is negative.
   */
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; // nothing to do
    LoggingEvent[] temp = new  LoggingEvent[newSize];
    int loopLen = newSize < numElems ? newSize : numElems;
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
    if (loopLen == newSize) {
      last = 0;
    } else {
      last = loopLen;
    }
  }
}
"
org.apache.log4j.helpers.DateLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;
/**
   This abstract layout takes care of all the date related options and
   formatting work.
   @author Ceki G&uuml;lc&uuml;
 */
abstract public class DateLayout extends Layout {
  /**
     String constant designating no time information. Current value of
     this constant is <b>NULL</b>.
  */
  public final static String NULL_DATE_FORMAT = ""NULL"";
  /**
     String constant designating relative time. Current value of
     this constant is <b>RELATIVE</b>.
   */
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";
  protected FieldPosition pos = new FieldPosition(0);
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String TIMEZONE_OPTION = ""TimeZone"";  
  private String timeZoneID;
  private String dateFormatOption;  
  protected DateFormat dateFormat;
  protected Date date = new Date();
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
  /**
    The value of the <b>DateFormat</b> option should be either an
    argument to the constructor of {@link SimpleDateFormat} or one of
    the srings ""NULL"", ""RELATIVE"", ""ABSOLUTE"", ""DATE"" or ""ISO8601.
   */
  public
  void setDateFormat(String dateFormat) {
    if (dateFormat != null) {
        dateFormatOption = dateFormat;
    }
    setDateFormat(dateFormatOption, TimeZone.getDefault());
  }
  /**
     Returns value of the <b>DateFormat</b> option.
   */
  public
  String getDateFormat() {
    return dateFormatOption;
  }
  /**
    The <b>TimeZoneID</b> option is a time zone ID string in the format
    expected by the {@link TimeZone#getTimeZone} method.
   */
  public
  void setTimeZone(String timeZone) {
    this.timeZoneID = timeZone;
  }
  /**
     Returns value of the <b>TimeZone</b> option.
   */
  public
  String getTimeZone() {
    return timeZoneID;
  }
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }
  public
  void dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }
  /**
     Sets the {@link DateFormat} used to format time and date in the
     zone determined by <code>timeZone</code>.
   */
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  /**
     Sets the DateFormat used to format date and time in the time zone
     determined by <code>timeZone</code> parameter. The {@link DateFormat} used
     will depend on the <code>dateFormatType</code>.
     <p>The recognized types are {@link #NULL_DATE_FORMAT}, {@link
     #RELATIVE_TIME_DATE_FORMAT} {@link
     AbsoluteTimeDateFormat#ABS_TIME_DATE_FORMAT}, {@link
     AbsoluteTimeDateFormat#DATE_AND_TIME_DATE_FORMAT} and {@link
     AbsoluteTimeDateFormat#ISO8601_DATE_FORMAT}. If the
     <code>dateFormatType</code> is not one of the above, then the
     argument is assumed to be a date pattern for {@link
     SimpleDateFormat}.
  */
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 
    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
}
"
org.apache.log4j.helpers.DateTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormatSymbols;
/**
   Formats a {@link Date} in the format ""dd MMM YYYY HH:mm:ss,SSS"" for example,
   ""06 Nov 1994 15:49:37,459"".
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class DateTimeDateFormat extends AbsoluteTimeDateFormat {
  String[] shortMonths;
  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }
  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }
  /**
     Appends to <code>sbuf</code> the date in the format ""dd MMM YYYY
     HH:mm:ss,SSS"" for example, ""06 Nov 1994 08:49:37,459"".
     @param sbuf the string buffer to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    calendar.setTime(date);
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10)
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');
    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');
    return super.format(date, sbuf, fieldPosition);
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }
}
"
org.apache.log4j.helpers.FileWatchdog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
// Contributors:  Mathias Bogaert
package org.apache.log4j.helpers;
import java.io.File;
import org.apache.log4j.helpers.LogLog;
/**
   Check every now and then that a certain file has not changed. If it
   has, then call the {@link #doOnChange} method.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public abstract class FileWatchdog extends Thread {
  /**
     The default delay between every file modification check, set to 60
     seconds.  */
  static final public long DEFAULT_DELAY = 60000; 
  /**
     The name of the file to observe  for changes.
   */
  protected String filename;
  /**
     The delay to observe between every check. By default set {@link
     #DEFAULT_DELAY}. */
  protected long delay = DEFAULT_DELAY; 
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  boolean interrupted = false;
  protected
  FileWatchdog(String filename) {
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }
  /**
     Set the delay to observe between each check of the file changes.
   */
  public
  void setDelay(long delay) {
    this.delay = delay;
  }
  abstract 
  protected 
  void doOnChange();
  protected
  void checkAndConfigure() {
    boolean fileExists;
    try {
      fileExists = file.exists();
    } catch(SecurityException  e) {
      LogLog.warn(""Was not allowed to read check file existance, file:[""+
		  filename+""]."");
      interrupted = true; // there is no point in continuing
      return;
    }
    if(fileExists) {
      long l = file.lastModified(); // this can also throw a SecurityException
      if(l > lastModif) {           // however, if we reached this point this
	lastModif = l;              // is very unlikely.
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }
  public
  void run() {    
    while(!interrupted) {
      try {
	Thread.currentThread().sleep(delay);
      } catch(InterruptedException e) {
	// no interruption expected
      }
      checkAndConfigure();
    }
  }
}
"
org.apache.log4j.helpers.FormattingInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
/**
   FormattingInfo instances contain the information obtained when parsing
   formatting modifiers in conversion modifiers.
   @author <a href=mailto:jim_cakalic@na.biomerieux.com>Jim Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2   
 */
public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }
  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
"
org.apache.log4j.helpers.ISO8601DateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
// Contributors: Arndt Schoenewald <arndt@ibm23093i821.mc.schoenewald.de>
/**
   Formats a {@link Date} in the format ""YYYY-mm-dd HH:mm:ss,SSS"" for example
   ""1999-11-27 15:49:37,459"".
   <p>Refer to the <a
   href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
   International Standard Date and Time Notation</a> for more
   information on this format.
   @author Ceki G&uuml;lc&uuml;
   @author Andrew Vajoczki
   @since 0.7.5
*/
public class ISO8601DateFormat extends AbsoluteTimeDateFormat {
  public
  ISO8601DateFormat() {
  }
  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }
  static private long   lastTime;
  static private char[] lastTimeString = new char[20];
  /**
     Appends a date in the format ""YYYY-mm-dd HH:mm:ss,SSS""
     to <code>sbuf</code>. For example: ""1999-11-27 15:49:37,459"".
     @param sbuf the <code>StringBuffer</code> to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    long now = date.getTime();
    int millis = (int)(now % 1000);
    if ((now - millis) != lastTime) {
      // We reach this point at most once per second
      // across all threads instead of each time format()
      // is called. This saves considerable CPU time.
      calendar.setTime(date);
      int start = sbuf.length();
      int year =  calendar.get(Calendar.YEAR);
      sbuf.append(year);
      String month;
      switch(calendar.get(Calendar.MONTH)) {
      case Calendar.JANUARY: month = ""-01-""; break;
      case Calendar.FEBRUARY: month = ""-02-"";  break;
      case Calendar.MARCH: month = ""-03-""; break;
      case Calendar.APRIL: month = ""-04-"";  break;
      case Calendar.MAY: month = ""-05-""; break;
      case Calendar.JUNE: month = ""-06-"";  break;
      case Calendar.JULY: month = ""-07-""; break;
      case Calendar.AUGUST: month = ""-08-"";  break;
      case Calendar.SEPTEMBER: month = ""-09-""; break;
      case Calendar.OCTOBER: month = ""-10-""; break;
      case Calendar.NOVEMBER: month = ""-11-"";  break;
      case Calendar.DECEMBER: month = ""-12-"";  break;
      default: month = ""-NA-""; break;
      }
      sbuf.append(month);
      int day = calendar.get(Calendar.DAY_OF_MONTH);
      if(day < 10)
	sbuf.append('0');
      sbuf.append(day);
      sbuf.append(' ');
      int hour = calendar.get(Calendar.HOUR_OF_DAY);
      if(hour < 10) {
	sbuf.append('0');
      }
      sbuf.append(hour);
      sbuf.append(':');
      int mins = calendar.get(Calendar.MINUTE);
      if(mins < 10) {
	sbuf.append('0');
      }
      sbuf.append(mins);
      sbuf.append(':');
      int secs = calendar.get(Calendar.SECOND);
      if(secs < 10) {
	sbuf.append('0');
      }
      sbuf.append(secs);
      sbuf.append(',');
      // store the time string for next time to avoid recomputation
      sbuf.getChars(start, sbuf.length(), lastTimeString, 0);
      lastTime = now - millis;
    }
    else {
      sbuf.append(lastTimeString);
    }
    if (millis < 100)
      sbuf.append('0');
    if (millis < 10)
      sbuf.append('0');
    sbuf.append(millis);
    return sbuf;
  }
  /**
    This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }
}
"
org.apache.log4j.helpers.Loader,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.helpers;
import java.net.URL;
//import java.awt.Image;
//import java.awt.Toolkit;
/**
   Load resources (or images) from various sources.
  @author Ceki G&uuml;lc&uuml;
 */
public class Loader  { 
  static final String TSTR = ""Caught Exception while in Loader.getResource. This may be innocuous."";
  // We conservatively assume that we are running under Java 1.x
  static private boolean java1 = true;
  static {
    String prop = OptionConverter.getSystemProperty(""java.version"", null);
    if(prop != null) {
      int i = prop.indexOf('.');
      if(i != -1) {	
	if(prop.charAt(i+1) != '1')
	  java1 = false;
      } 
    }
  }
  /**
     This method will search for <code>resource</code> in different
     places. The rearch order is as follows:
     <ol>
     <p><li>Search for <code>resource</code> using the thread context
     class loader under Java2. If that fails, search for
     <code>resource</code> using the class loader that loaded this
     class (<code>Loader</code>). Under JDK 1.1, only the the class
     loader that loaded this class (<code>Loader</code>) is used.
     <p><li>Try one last time with
     <code>ClassLoader.getSystemResource(resource)</code>, that is is
     using the system class loader in JDK 1.2 and virtual machine's
     built-in class loader in JDK 1.1.
     </ol>
  */
  static
  public
  URL getResource(String resource) {
    ClassLoader classLoader = null;
    URL url = null;
    try {
      if(!java1) {
	classLoader = Thread.currentThread().getContextClassLoader();	
	if(classLoader != null) {
	  LogLog.debug(""Trying to find [""+resource+""] using context classloader ""
		       +classLoader+""."");
	  url = classLoader.getResource(resource);      
	  if(url != null) {
	    return url;
	  }
	}
      }
      // We could not find resource. Ler us now try with the
      // classloader that loaded this class.
      classLoader = Loader.class.getClassLoader(); 
      if(classLoader == null) {
	LogLog.warn(""Loader.class.getClassLoader returned null!"");
      } else {
	LogLog.debug(""Trying to find [""+resource+""] using ""+classLoader
		     +"" class loader."");
	url = classLoader.getResource(resource);
	if(url != null) {
	  return url;
	}
      }
    } catch(Throwable t) {
      LogLog.warn(TSTR, t);
    }
    // Last ditch attempt: get the resource from the class path. It
    // may be the case that clazz was loaded by the Extentsion class
    // loader which the parent of the system class loader. Hence the
    // code below.
    LogLog.debug(""Trying to find [""+resource+
		 ""] using ClassLoader.getSystemResource()."");
    return ClassLoader.getSystemResource(resource);
  } 
  /**
     Are we running under JDK 1.x?        
  */
  public
  static
  boolean isJava1() {
    return java1;
  }
  /**
     Load the specified class using the <code>Thread</code>
     <code>contextClassLoader</code> if running under Java2 or current
     class loader if running under JDK 1.1.
  */
  static
  public 
  Class loadClass (Double clazz) throws ClassNotFoundException {
    return null;
    //    if(java1) {
    //	return Class.forName(clazz);
    //    } else {
    //	try {
    //	  return Thread.currentThread().getContextClassLoader().loadClass(clazz);
    //	} catch(Exception e) {
    //	  // we reached here because
    //	  // currentThread().getContextClassLoader() is null or because
    //	  // of a security exceptio, or because clazz could not be
    //	  // loaded, in any case we now try one more time
    //	  return Class.forName(clazz);
    //	}
    //    }
  } 
}
"
org.apache.log4j.helpers.LogLog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
/**
   This class used to output log statements from within the log4j package.
   <p>Log4j components cannot make log4j logging calls. However, it is
   sometimes useful for the user to learn about what log4j is
   doing. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable.
   <p>All log4j internal debug calls go to <code>System.out</code>
   where as internal error messages are sent to
   <code>System.err</code>. All internal messages are prepended with
   the string ""log4j: "".
   @since 0.8.2
   @author Ceki G&uuml;lc&uuml;
*/
public class LogLog {
  /**
     Defining this value makes log4j print log4j-internal debug
     statements to <code>System.out</code>.
    <p> The value of this string is <b>log4j.debug</b>.
    <p>Note that the search for all option names is case sensitive.  */
  public static final String DEBUG_KEY=""log4j.debug"";
  /**
     Defining this value makes log4j components print log4j-internal
     debug statements to <code>System.out</code>.
    <p> The value of this string is <b>log4j.configDebug</b>.
    <p>Note that the search for all option names is case sensitive.  
    @deprecated Use {@link #DEBUG_KEY} instead.
  */
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";
  protected static boolean debugEnabled = false;  
  /**
     In quietMode not even errors generate any output.
   */
  private static boolean quietMode = false;
  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  private static final String WARN_PREFIX = ""log4j:WARN "";
  static {
    String key = OptionConverter.getSystemProperty(DEBUG_KEY, null);
    if(key == null) {
      key = OptionConverter.getSystemProperty(CONFIG_DEBUG_KEY, null);
    }
    if(key != null) { 
      debugEnabled = OptionConverter.toBoolean(key, true);
    }
  }
  /**
     Allows to enable/disable log4j internal logging.
   */
  static
  public
  void setInternalDebugging(boolean enabled) {
    debugEnabled = enabled;
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
    }
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg, Throwable t) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.
  */
  public
  static
  void error(String msg) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
  }  
  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.  
  */
  public
  static
  void error(String msg, Throwable t) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
  /**
     In quite mode no LogLog generates strictly no output, not even
     for errors. 
     @param quietMode A true for not
  */
  public
  static
  void setQuietMode(boolean quietMode) {
    LogLog.quietMode = quietMode;
  }
  /**
     This method is used to output log4j internal warning
     statements. There is no way to disable warning statements.
     Output goes to <code>System.err</code>.  */
  public
  static
  void warn(String msg) {
    if(quietMode)
      return;
    System.err.println(WARN_PREFIX+msg);
  }  
  /**
     This method is used to output log4j internal warnings. There is
     no way to disable warning statements.  Output goes to
     <code>System.err</code>.  */
  public
  static
  void warn(String msg, Throwable t) {
    if(quietMode)
      return;
    System.err.println(WARN_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
org.apache.log4j.helpers.NullEnumeration,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
  An always-empty Enumerator.
  @author Anders Kristensen
  @since version 1.0
 */
public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  private
  NullEnumeration() {
  }
  public
  static
  NullEnumeration getInstance() {
    return instance;
  }
  public
  boolean hasMoreElements() {
    return false;
  }
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
org.apache.log4j.helpers.OnlyOnceErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import  org.apache.log4j.spi.ErrorHandler;
import  org.apache.log4j.spi.LoggingEvent;
import  org.apache.log4j.Logger;
import  org.apache.log4j.Appender;
/**
   The <code>OnlyOnceErrorHandler</code> implements log4j's default
   error handling policy which consists of emitting a message for the
   first error in an appender and ignoring all following errors.
   <p>The error message is printed on <code>System.err</code>. 
   <p>This policy aims at protecting an otherwise working application
   from being flooded with error messages when logging fails.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class OnlyOnceErrorHandler implements ErrorHandler {
  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";
  boolean firstTime = true;
  /**
     Does not do anything.
   */
  public 
  void setLogger(Logger logger) {
  }
  /**
     No options to activate.
  */
  public 
  void activateOptions() {
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.  */
  public
  void error(String message, Exception e, int errorCode) { 
    error(message, e, errorCode, null);
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.
   */
  public
  void error(String message, Exception e, int errorCode, LoggingEvent event) {
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }
  /**
     Print a the error message passed as parameter on
     <code>System.err</code>.  
  */
  public 
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
  /**
     Does not do anything.
   */
  public
  void setAppender(Appender appender) {
  }
  /**
     Does not do anything.
   */
  public
  void setBackupAppender(Appender appender) {
  }
}
"
org.apache.log4j.helpers.OptionConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.util.Properties;
import java.net.URL;
import org.apache.log4j.Level;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.PropertyConfigurator;
// Contributors:   Avy Sharell (sharell@online.fr)
//                 Matthieu Verbert (mve@zurich.ibm.com)
//                 Colin Sampaleanu
/**
   A convenience class to convert property values to specific types.
   @author Ceki G&uuml;lc&uuml;
   @author Simon Kitching;
   @author Anders Kristensen
*/
public class OptionConverter {
  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;
  /** OptionConverter is a static class. */
  private OptionConverter() {}
  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];
    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);
    return a;
  }
  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);
    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';
	else if(c == '\""') c = '\""';
	else if(c == '\'') c = '\'';
	else if(c == '\\') c = '\\';
      }
      sbuf.append(c);
    }
    return sbuf.toString();
  }
  /**
     Very similar to <code>System.getProperty</code> except
     that the {@link SecurityException} is hidden.
     @param key The key to search for.
     @param def The default value to return.
     @return the string value of the system property, or the default
     value if there is no property with that key.
     @since 1.1 */
  public
  static
  String getSystemProperty(String key, String def) {
    try {
      return System.getProperty(key, def);
    } catch(Throwable e) { // MS-Java throws com.ms.security.SecurityExceptionEx
      LogLog.debug(""Was not allowed to read system property \""""+key+""\""."");
      return def;
    }
  }
  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {
    // Get the value of the property in string form
    String className = findAndSubst(key, props);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    // Trim className to avoid trailing spaces that cause problems.
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }
  /**
     If <code>value</code> is ""true"", then <code>true</code> is
     returned. If <code>value</code> is ""false"", then
     <code>true</code> is returned. Otherwise, <code>default</code> is
     returned.
     <p>Case of value is unimportant.  */
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal))
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }
  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }
  /**
     Converts a standard or custom priority level to a Level
     object.  <p> If <code>value</code> is of form
     ""level#classname"", then the specified class' toLevel method
     is called to process the specified level string; if no '#'
     character is present, then the default {@link org.apache.log4j.Level}
     class is used to process the level value.
     <p>As a special case, if the <code>value</code> parameter is
     equal to the string ""NULL"", then the value <code>null</code> will
     be returned.
     <p> If any error occurs while converting the value to a level,
     the <code>defaultValue</code> parameter, which may be
     <code>null</code>, is returned.
     <p> Case of <code>value</code> is insignificant for the level level, but is
     significant for the class name part, if present.
     @since 1.1 */
  public
  static
  Level toLevel(String value, Level defaultValue) {
    if(value == null)
      return defaultValue;
    int hashIndex = value.indexOf('#');
    if (hashIndex == -1) {
      if(""NULL"".equalsIgnoreCase(value)) {
	return null;
      } else {
	// no class name specified : use standard Level class
	return(Level) Level.toLevel(value, defaultValue);
      }
    }
    Level result = defaultValue;
    String clazz = value.substring(hashIndex+1);
    String levelName = value.substring(0, hashIndex);
    // This is degenerate case but you never know.
    if(""NULL"".equalsIgnoreCase(levelName)) {
	return null;
    }
    LogLog.debug(""toLevel"" + "":class=["" + clazz + ""]""
		 + "":pri=["" + levelName + ""]"");
    try {
      Class customLevel = Class.forName(clazz);
      // get a ref to the specified class' static method
      // toLevel(String, org.apache.log4j.Level)
      Class[] paramTypes = new Class[] { String.class,
					 org.apache.log4j.Level.class
                                       };
      java.lang.reflect.Method toLevelMethod =
                      customLevel.getMethod(""toLevel"", paramTypes);
      // now call the toLevel method, passing level string + default
      Object[] params = new Object[] {levelName, defaultValue};
      Object o = toLevelMethod.invoke(null, params);
      result = (Level) o;
    } catch(ClassNotFoundException e) {
      LogLog.warn(""custom level class ["" + clazz + ""] not found."");
    } catch(NoSuchMethodException e) {
      LogLog.warn(""custom level class ["" + clazz + ""]""
        + "" does not have a constructor which takes one string parameter"", e);
    } catch(java.lang.reflect.InvocationTargetException e) {
      LogLog.warn(""custom level class ["" + clazz + ""]""
		   + "" could not be instantiated"", e);
    } catch(ClassCastException e) {
      LogLog.warn(""class ["" + clazz
        + ""] is not a subclass of org.apache.log4j.Level"", e);
    } catch(IllegalAccessException e) {
      LogLog.warn(""class [""+clazz+
		   ""] cannot be instantiated due to access restrictions"", e);
    } catch(Exception e) {
      LogLog.warn(""class [""+clazz+""], level [""+levelName+
		   ""] conversion failed."", e);
    }
    return result;
   }
  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;
    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;
    if((index = s.indexOf(""KB"")) != -1) {
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }
  /**
     Find the value corresponding to <code>key</code> in
     <code>props</code>. Then perform variable substitution on the
     found value.
 */
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null)
      return null;
    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }
  }
  /**
     Instantiate an object given a class name. Check that the
     <code>className</code> is a subclass of
     <code>superClass</code>. If that test fails or the object could
     not be instantiated, then <code>defaultValue</code> is returned.
     @param className The fully qualified class name of the object to instantiate.
     @param superClass The class to which the new object should belong.
     @param defaultValue The object to return in case of non-fulfillment
   */
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Class.forName(className);
	if(!superClass.isAssignableFrom(classObj)) {
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" variable."");
	  return defaultValue;
	}
	return classObj.newInstance();
      } catch (Exception e) {
	LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;
  }
  /**
     Perform variable substitution in string <code>val</code> from the
     values of keys found in the system propeties.
     <p>The variable substitution delimeters are <b>${</b> and <b>}</b>.
     <p>For example, if the System properties contains ""key=value"", then
     the call
     <pre>
     String s = OptionConverter.substituteVars(""Value of key is ${key}."");
     </pre>
     will set the variable <code>s</code> to ""Value of key is value."".
     <p>If no value could be found for the specified key, then the
     <code>props</code> parameter is searched, if the value could not
     be found there, then substitution defaults to the empty string.
     <p>For example, if system propeties contains no value for the key
     ""inexistentKey"", then the call
     <pre>
     String s = OptionConverter.subsVars(""Value of inexistentKey is [${inexistentKey}]"");
     </pre>
     will set <code>s</code> to ""Value of inexistentKey is []""
     <p>An {@link java.lang.IllegalArgumentException} is thrown if
     <code>val</code> contains a start delimeter ""${"" which is not
     balanced by a stop delimeter ""}"". </p>
     <p><b>Author</b> Avy Sharell</a></p>
     @param val The string on which variable substitution is performed.
     @throws IllegalArgumentException if <code>val</code> is malformed.
  */
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {
    StringBuffer sbuf = new StringBuffer();
    int i = 0;
    int j, k;
    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	// no more variables
	if(i==0) { // this is a simple string
	  return val;
	} else { // add the tail string which contails no variables and return the result.
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      } else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j
					     + '.');
	} else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  // first try in System properties
	  String replacement = getSystemProperty(key, null);
	  // then try props parameter
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }
	  if(replacement != null) {
	    // Do variable substitution on the replacement string
	    // such that we can solve ""Hello ${x2}"" as ""Hello p1"" 
            // the where the properties are
	    // x1=p1
            // x2=${x1}
	    String recursiveReplacement = substVars(replacement, props);
	    sbuf.append(recursiveReplacement);
	  }
	  i = k + DELIM_STOP_LEN;
	}
      }
    }
  }
  /**
     Configure log4j given a URL.
     <p>The url must point to a file or resource which will be interpreted by
     a new instance of a log4j configurator.
     <p>All configurations steps are taken on the
     <code>hierarchy</code> passed as a parameter.
     <p>
     @param url The location of the configuration file or resource.
     @param clazz The classname, of the log4j configurator which will parse
     the file or resource at <code>url</code>. This must be a subclass of
     {@link Configurator}, or null. If this value is null then a default
     configurator of {@link PropertyConfigurator} is used, unless the
     filename pointed to by <code>url</code> ends in '.xml', in which case
     {@link org.apache.log4j.xml.DOMConfigurator} is used.
     @param hierarchy The {@link org.apache.log4j.Hierarchy} to act on.
     @since 1.1.4 */
  static
  public
  void selectAndConfigure(URL url, String clazz, LoggerRepository hierarchy) {
   Configurator configurator = null;
   String filename = url.getFile();
   if(clazz == null && filename != null && filename.endsWith("".xml"")) {
     clazz = ""org.apache.log4j.xml.DOMConfigurator"";
   }
   if(clazz != null) {
     LogLog.debug(""Preferred configurator class: "" + clazz);
     configurator = (Configurator) instantiateByClassName(clazz,
							  Configurator.class,
							  null);
     if(configurator == null) {
   	  LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
   	  return;
     }
   } else {
     configurator = new PropertyConfigurator();
   }
   configurator.doConfigure(url, hierarchy);
  }
}
"
org.apache.log4j.helpers.PatternConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <p>PatternConverter is an abtract class that provides the
   formatting functionality that derived classes need.
   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting a logging event in a converter specific manner.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2
 */
public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  protected
  PatternConverter() {  }
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }
  /**
     Derived pattern converters must override this method in order to
     convert conversion specifiers in the correct way.
  */
  abstract
  protected
  String convert(LoggingEvent event);
  /**
     A template method for formatting in a converter specific way.
   */
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);
    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }
    int len = s.length();
    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32 spaces
  /**
     Fast space padding method.
  */
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.helpers.PatternParser,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>
//                 Reinhard Deschler <reinhard.deschler@web.de>
/**
   Most of the work of the {@link org.apache.log4j.PatternLayout} class
   is delegated to the PatternParser class.
   <p>It is this class that parses conversion patterns and creates
   a chained list of {@link OptionConverter OptionConverters}.
   @author <a href=mailto:""cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.2
*/
public class PatternParser {
  private static final char ESCAPE_CHAR = '%';
  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int MINUS_STATE = 2;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;
  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;
  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int LEVEL_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;
  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;
  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();
    state = LITERAL_STATE;
  }
  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;
    }
  }
  protected
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }
  /**
     The option is expected to be in decimal and positive. In case of
     error, zero is returned.  */
  protected
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }
    }
    return r;
  }
  public
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE:
        // In literal state, the last char is always a literal.
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {
          // peek at the next char.
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; // move pointer
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; // move pointer
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              //LogLog.debug(""Parsed LITERAL converter: \""""
              //           +currentLiteral+""\""."");
            }
            currentLiteral.setLength(0);
            currentLiteral.append(c); // append %
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else
	    finalizeConverter(c);
	} // switch
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9')
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9')
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } // switch
    } // while
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      //LogLog.debug(""Parsed LITERAL converter: \""""+currentLiteral+""\""."");
    }
    return head;
  }
  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());
      //LogLog.debug(""CATEGORY converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      //LogLog.debug(""CLASS_NAME converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;
      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT))
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}
      }
      pc = new DatePatternConverter(formattingInfo, df);
      //LogLog.debug(""DATE converter {""+dateFormatStr+""}."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      //LogLog.debug(""File name converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      //LogLog.debug(""Location converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      //LogLog.debug(""LINE NUMBER converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      //LogLog.debug(""MESSAGE converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      //LogLog.debug(""METHOD converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, LEVEL_CONVERTER);
      //LogLog.debug(""LEVEL converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo,
					 RELATIVE_TIME_CONVERTER);
      //LogLog.debug(""RELATIVE time converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      //LogLog.debug(""THREAD converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
      /*case 'u':
      if(i < patternLength) {
	char cNext = pattern.charAt(i);
	if(cNext >= '0' && cNext <= '9') {
	  pc = new UserFieldPatternConverter(formattingInfo, cNext - '0');
	  LogLog.debug(""USER converter [""+cNext+""]."");
	  formattingInfo.dump();
	  currentLiteral.setLength(0);
	  i++;
	}
	else
	  LogLog.error(""Unexpected char"" +cNext+"" at position ""+i);
      }
      break;*/
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      //LogLog.debug(""NDC converter."");
      currentLiteral.setLength(0);
      break;
    case 'X':
      String xOpt = extractOption();
      pc = new MDCPatternConverter(formattingInfo, xOpt);
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char ["" +c+""] at position ""+i
		   +"" in conversion patterrn."");
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }
    addConverter(pc);
  }
  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    // Add the pattern converter to the list.
    addToList(pc);
    // Next pattern is assumed to be a literal.
    state = LITERAL_STATE;
    // Reset formatting info
    formattingInfo.reset();
  }
  // ---------------------------------------------------------------------
  //                      PatternConverters
  // ---------------------------------------------------------------------
  private static class BasicPatternConverter extends PatternConverter {
    int type;
    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER:
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case LEVEL_CONVERTER:
	return event.level.toString();
      case NDC_CONVERTER:
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.getRenderedMessage();
      }
      default: return null;
      }
    }
  }
  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;
    LiteralPatternConverter(String value) {
      literal = value;
    }
    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }
    public
    String convert(LoggingEvent event) {
      return literal;
    }
  }
  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;
    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;
    }
    public
    String convert(LoggingEvent event) {
      date.setTime(event.timeStamp);
      String converted = null;
      try {
        converted = df.format(date);
      }
      catch (Exception ex) {
        LogLog.error(""Error occured while converting date."", ex);
      }
      return converted;
    }
  }
  private static class MDCPatternConverter extends PatternConverter {
    private String key;
    MDCPatternConverter(FormattingInfo formattingInfo, String key) {
      super(formattingInfo);
      this.key = key;
    }
    public
    String convert(LoggingEvent event) {
      Object val = event.getMDC(key);
      if(val == null) {
	return null;
      } else {
	return val.toString();
      }
    }
  }
  private class LocationPatternConverter extends PatternConverter {
    int type;
    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      LocationInfo locationInfo = event.getLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER:
	return locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER:
	return locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER:
	return locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER:
	return locationInfo.getFileName();
      default: return null;
      }
    }
  }
  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;
    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;
    }
    abstract
    String getFullyQualifiedName(LoggingEvent event);
    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();
	// We substract 1 from 'len' when assigning to 'end' to avoid out of
	// bounds exception in return r.substring(end+1, len). This can happen if
	// precision is 1 and the category name ends with a dot.
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }
    }
  }
  private class ClassNamePatternConverter extends NamedPatternConverter {
    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLocationInformation().getClassName();
    }
  }
  private class CategoryPatternConverter extends NamedPatternConverter {
    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      return event.categoryName;
    }
  }
}
"
org.apache.log4j.helpers.QuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   QuietWriter does not throw exceptions when things go
   wrong. Instead, it delegates error handling to its {@link ErrorHandler}. 
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.3
*/
public class QuietWriter extends FilterWriter {
  protected ErrorHandler errorHandler;
  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }
  public
  void write(String string) {
    try {
      out.write(string);
    } catch(IOException e) {
      errorHandler.error(""Failed to write [""+string+""]."", e, 
			 ErrorCode.WRITE_FAILURE);
    }
  }
  public
  void flush() {
    try {
      out.flush();
    } catch(IOException e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }
  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // This is a programming error on the part of the enclosing appender.
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
org.apache.log4j.helpers.RelativeTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} by printing the number of milliseconds
   elapsed since the start of the application.  This is the fastest
   printing DateFormat in the package.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class RelativeTimeDateFormat extends DateFormat {
  protected final long startTime;
  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  /**
     Appends to <code>sbuf</code> the number of milliseconds elapsed
     since the start of the application. 
     @since 0.7.5
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    //System.err.println("":""+ date.getTime() + "" - "" + startTime);
    return sbuf.append((date.getTime() - startTime));
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.SyslogQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import org.apache.log4j.spi.ErrorHandler;
/**
   SyslogQuietWriter extends QuietWriter by prepending the syslog
   level code before each printed String.
   @since 0.7.3
*/
public class SyslogQuietWriter extends QuietWriter {
  int syslogFacility;
  int level;
  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }
  public
  void setLevel(int level) {
    this.level = level;
  }
  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }
  public
  void write(String string) {
    super.write(""<""+(syslogFacility | level)+"">"" + string);
  }
}
"
org.apache.log4j.helpers.SyslogWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;
/**
   SyslogWriter is a wrapper around the java.net.DatagramSocket class
   so that it behaves like a java.io.Writer.
   @since 0.7.3
*/
public class SyslogWriter extends Writer {
  final int SYSLOG_PORT = 514;
  static String syslogHost;
  private InetAddress address;
  private DatagramSocket ds;
  public
  SyslogWriter(String syslogHost) {
    this.syslogHost = syslogHost;
    try {      
      this.address = InetAddress.getByName(syslogHost);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace(); 
      LogLog.error(""Could not instantiate DatagramSocket to "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
  }
  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  public
  void write(String string) throws IOException {
    DatagramPacket packet = new DatagramPacket(string.getBytes(),
					       string.length(), 
					       address, SYSLOG_PORT);
    if(this.ds != null)
      ds.send(packet);
  }
  public
  void flush() {}
  public
  void close() {}
}
"
org.apache.log4j.helpers.ThreadLocalMap,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.helpers;
import java.util.Hashtable;
/**
   <code>ThreadLocalMap</code> extends {@link InheritableThreadLocal}
   to bequeath a copy of the hashtable of the MDC of the parent
   thread.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2
*/
final public class ThreadLocalMap extends InheritableThreadLocal {
  public
  final
  Object childValue(Object parentValue) {
    Hashtable ht = (Hashtable) parentValue;
    if(ht != null) {
      return ht.clone();
    } else {
      return null;
    }
  }
}
"
org.apache.log4j.helpers.Transform,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
/**
   Utility class for transforming strings.
 */
public class Transform {
  /**
   * This method takes a string which may contain HTML tags (ie, <b>, <table>,
   * etc) and converts the '<' and '>' characters to their HTML escape
   * sequences.
   *
   * @param input The text to be converted.
   * @return The input string with the characters '<' and '>' replaced with
   *  &lt; and &gt; respectively.
   */
  static 
  public 
  String escapeTags(String input) {
    //Check if the string is null or zero length -- if so, return
    //what was sent in.
    if( input == null || input.length() == 0 ) {
      return input;
    }
    //Use a StringBuffer in lieu of String concatenation -- it is
    //much more efficient this way.
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    int len = input.length();
    for(int i=0; i < len; i++) {
      ch = input.charAt(i);
      if(ch == '<') {
	buf.append(""&lt;"");
      } else if(ch == '>') {
	buf.append(""&gt;"");
      } else {
	buf.append(ch);
      }
    }
    return buf.toString();
  }
}
"
org.apache.log4j.jdbc.JDBCAppender,"package org.apache.log4j.jdbc;
import org.apache.log4j.*;
import org.apache.log4j.spi.*;
import org.apache.log4j.PatternLayout;
import java.util.ArrayList;
import java.util.Iterator;
import java.sql.DriverManager;
import java.sql.Connection;
import java.sql.Statement;
import java.sql.SQLException;
/**
  The JDBCAppender provides for sending log events to a database.
  <p>Each append call adds to an <code>ArrayList</code> buffer.  When
  the buffer is filled each log event is placed in a sql statement
  (configurable) and executed.
  <b>BufferSize</b>, <b>db URL</b>, <b>User</b>, & <b>Password</b> are
  configurable options in the standard log4j ways.
  <p>The <code>setSql(String sql)</code> sets the SQL statement to be
  used for logging -- this statement is sent to a
  <code>PatternLayout</code> (either created automaticly by the
  appender or added by the user).  Therefore by default all the
  conversion patterns in <code>PatternLayout</code> can be used
  inside of the statement.  (see the test cases for examples)
  <p>Overriding the {@link #getLogStatement} method allows more
  explicit control of the statement used for logging.
  <p>For use as a base class:
    <ul>
    <li>Override <code>getConnection()</code> to pass any connection
    you want.  Typically this is used to enable application wide
    connection pooling.
     <li>Override <code>closeConnection(Connection con)</code> -- if
     you override getConnection make sure to implement
     <code>closeConnection</code> to handle the connection you
     generated.  Typically this would return the connection to the
     pool it came from.
     <li>Override <code>getLogStatement(LoggingEvent event)</code> to
     produce specialized or dynamic statements. The default uses the
     sql option value.
    </ul>
    @author: Kevin Steppe (<A HREF=""mailto:ksteppe@pacbell.net"">ksteppe@pacbell.net</A>)
*/
public class JDBCAppender extends org.apache.log4j.AppenderSkeleton
    implements org.apache.log4j.Appender {
  /**
   * URL of the DB for default connection handling
   */
  protected String databaseURL = ""jdbc:odbc:myDB"";
  /**
   * User to connect as for default connection handling
   */
  protected String databaseUser = ""me"";
  /**
   * User to use for default connection handling
   */
  protected String databasePassword = ""mypassword"";
  /**
   * Connection used by default.  The connection is opened the first time it
   * is needed and then held open until the appender is closed (usually at
   * garbage collection).  This behavior is best modified by creating a
   * sub-class and overriding the <code>getConnection</code> and
   * <code>closeConnection</code> methods.
   */
  protected Connection connection = null;
  /**
   * Stores the string given to the pattern layout for conversion into a SQL
   * statement, eg: insert into LogTable (Thread, Class, Message) values
   * (""%t"", ""%c"", ""%m"")
   *
   * Be careful of quotes in your messages!
   *
   * Also see PatternLayout.
   */
  protected String sqlStatement = """";
  /**
   * size of LoggingEvent buffer before writting to the database.
   * Default is 1.
   */
  protected int bufferSize = 1;
  /**
   * ArrayList holding the buffer of Logging Events.
   */
  protected ArrayList buffer;
  /**
   * Helper object for clearing out the buffer
   */
  protected ArrayList removes;
  public JDBCAppender() {
    super();
    buffer = new ArrayList(bufferSize);
    removes = new ArrayList(bufferSize);
  }
  /**
   * Adds the event to the buffer.  When full the buffer is flushed.
   */
  public void append(LoggingEvent event) {
    buffer.add(event);
    if (buffer.size() >= bufferSize)
      flushBuffer();
  }
  /**
   * By default getLogStatement sends the event to the required Layout object.
   * The layout will format the given pattern into a workable SQL string.
   *
   * Overriding this provides direct access to the LoggingEvent
   * when constructing the logging statement.
   *
   */
  protected String getLogStatement(LoggingEvent event) {
    return getLayout().format(event);
  }
  /**
   *
   * Override this to provide an alertnate method of getting
   * connections (such as caching).  One method to fix this is to open
   * connections at the start of flushBuffer() and close them at the
   * end.  I use a connection pool outside of JDBCAppender which is
   * accessed in an override of this method.
   * */
  protected void execute(String sql) throws SQLException {
    Connection con = null;
    Statement stmt = null;
    try {
        con = getConnection();
        stmt = con.createStatement();
        stmt.executeUpdate(sql);
    } catch (SQLException e) {
       if (stmt != null)
	     stmt.close();
       throw e;
    }
    stmt.close();
    closeConnection(con);
    //System.out.println(""Execute: "" + sql);
  }
  /**
   * Override this to return the connection to a pool, or to clean up the
   * resource.
   *
   * The default behavior holds a single connection open until the appender
   * is closed (typically when garbage collected).
   */
  protected void closeConnection(Connection con) {
  }
  /**
   * Override this to link with your connection pooling system.
   *
   * By default this creates a single connection which is held open
   * until the object is garbage collected.
   */
  protected Connection getConnection() throws SQLException {
      if (!DriverManager.getDrivers().hasMoreElements())
	     setDriver(""sun.jdbc.odbc.JdbcOdbcDriver"");
      if (connection == null) {
        connection = DriverManager.getConnection(databaseURL, databaseUser,
					databasePassword);
      }
      return connection;
  }
  /**
   * Closes the appender, flushing the buffer first then closing the default
   * connection if it is open.
   */
  public void close()
  {
    flushBuffer();
    try {
      if (connection != null && !connection.isClosed())
          connection.close();
    } catch (SQLException e) {
        errorHandler.error(""Error closing connection"", e, ErrorCode.GENERIC_FAILURE);
    }
    this.closed = true;
  }
  /**
   * loops through the buffer of LoggingEvents, gets a
   * sql string from getLogStatement() and sends it to execute().
   * Errors are sent to the errorHandler.
   *
   * If a statement fails the LoggingEvent stays in the buffer!
   */
  public void flushBuffer() {
    //Do the actual logging
    removes.ensureCapacity(buffer.size());
    for (Iterator i = buffer.iterator(); i.hasNext();) {
      try {
        LoggingEvent logEvent = (LoggingEvent)i.next();
	    String sql = getLogStatement(logEvent);
	    execute(sql);
        removes.add(logEvent);
      }
      catch (SQLException e) {
	    errorHandler.error(""Failed to excute sql"", e,
			   ErrorCode.FLUSH_FAILURE);
      }
    }
    buffer.removeAll(removes);
    //buffer.clear();
  }
  /** closes the appender before disposal */
  public void finalize() {
    close();
  }
  /**
   * JDBCAppender builds a layout internally if one is not provided.
   */
  public boolean requiresLayout() {
    return false;
  }
  /**
   *
   */
  public void setSql(String s) {
    sqlStatement = s;
    if (getLayout() == null) {
        this.setLayout(new PatternLayout(s));
    }
    else {
        ((PatternLayout)getLayout()).setConversionPattern(s);
    }
  }
  /**
   * Returns pre-formated statement eg: insert into LogTable (msg) values (""%m"")
   */
  public String getSql() {
    return sqlStatement;
  }
  public void setUser(String user) {
    databaseUser = user;
  }
  public void setURL(String url) {
    databaseURL = url;
  }
  public void setPassword(String password) {
    databasePassword = password;
  }
  public void setBufferSize(int newBufferSize) {
    bufferSize = newBufferSize;
    buffer.ensureCapacity(bufferSize);
    removes.ensureCapacity(bufferSize);
  }
  public String getUser() {
    return databaseUser;
  }
  public String getURL() {
    return databaseURL;
  }
  public String getPassword() {
    return databasePassword;
  }
  public int getBufferSize() {
    return bufferSize;
  }
  /**
   * Ensures that the given driver class has been loaded for sql connection
   * creation.
   */
  public void setDriver(String driverClass) {
    try {
      Class.forName(driverClass);
    } catch (Exception e) {
      errorHandler.error(""Failed to load driver"", e,
			 ErrorCode.GENERIC_FAILURE);
    }
  }
}
"
org.apache.log4j.jmx.AbstractDynamicMBean,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.jmx;
//import java.lang.reflect.Constructor;
import java.util.Iterator;
import javax.management.DynamicMBean;
import javax.management.AttributeList;
import javax.management.Attribute;
import javax.management.RuntimeOperationsException;
import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import org.apache.log4j.Logger;
public abstract class AbstractDynamicMBean implements DynamicMBean,
                                                      MBeanRegistration {
  String dClassName;
  MBeanServer server;
  /**
   * Enables the to get the values of several attributes of the Dynamic MBean.
   */
  public
  AttributeList getAttributes(String[] attributeNames) {
    // Check attributeNames is not null to avoid NullPointerException later on
    if (attributeNames == null) {
      throw new RuntimeOperationsException(
			   new IllegalArgumentException(""attributeNames[] cannot be null""),
			   ""Cannot invoke a getter of "" + dClassName);
    }
    AttributeList resultList = new AttributeList();
    // if attributeNames is empty, return an empty result list
    if (attributeNames.length == 0)
      return resultList;
    // build the result attribute list
    for (int i=0 ; i<attributeNames.length ; i++){
      try {
	Object value = getAttribute((String) attributeNames[i]);
	resultList.add(new Attribute(attributeNames[i],value));
      } catch (Exception e) {
	e.printStackTrace();
      }
    }
    return(resultList);
  }
  /**
   * Sets the values of several attributes of the Dynamic MBean, and returns the
   * list of attributes that have been set.
   */
  public AttributeList setAttributes(AttributeList attributes) {
    // Check attributes is not null to avoid NullPointerException later on
    if (attributes == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""AttributeList attributes cannot be null""),
		    ""Cannot invoke a setter of "" + dClassName);
    }
    AttributeList resultList = new AttributeList();
    // if attributeNames is empty, nothing more to do
    if (attributes.isEmpty())
      return resultList;
    // for each attribute, try to set it and add to the result list if successfull
    for (Iterator i = attributes.iterator(); i.hasNext();) {
      Attribute attr = (Attribute) i.next();
      try {
	setAttribute(attr);
	String name = attr.getName();
	Object value = getAttribute(name);
	resultList.add(new Attribute(name,value));
      } catch(Exception e) {
	e.printStackTrace();
      }
    }
    return(resultList);
  }
  protected
  abstract
  Logger getLogger();
  public
  void postDeregister() {
    getLogger().debug(""postDeregister is called."");
  }
  public
  void postRegister(java.lang.Boolean registrationDone) {
  }
  public
  void preDeregister() {
    getLogger().debug(""preDeregister called."");
  }
  public
  ObjectName preRegister(MBeanServer server, ObjectName name) {
    getLogger().debug(""preRegister called. Server=""+server+ "", name=""+name);
    this.server = server;
    return name;
  }
}
"
org.apache.log4j.jmx.Agent,"package org.apache.log4j.jmx;
import javax.management.ObjectName;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import com.sun.jdmk.comm.HtmlAdaptorServer;
import org.apache.log4j.Category;
public class Agent {
  static Category log = Category.getInstance(Agent.class);
  public Agent() {
  }
  public
  void start() {
    MBeanServer server = MBeanServerFactory.createMBeanServer();
    HtmlAdaptorServer html = new HtmlAdaptorServer();
    try {
      log.info(""Registering HtmlAdaptorServer instance."");
      server.registerMBean(html, new ObjectName(""Adaptor:name=html,port=8082""));
      log.info(""Registering HierarchyDynamicMBean instance."");
      HierarchyDynamicMBean hdm = new HierarchyDynamicMBean();
      server.registerMBean(hdm, new ObjectName(""log4j:hiearchy=default""));
    } catch(Exception e) {
      log.error(""Problem while regitering MBeans instances."", e);
      return;
    }
    html.start();
  }
}
"
org.apache.log4j.jmx.AppenderDynamicMBean,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.jmx;
import java.lang.reflect.Constructor;
import org.apache.log4j.*;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
import java.util.Vector;
import java.util.Hashtable;
import java.lang.reflect.Method;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.ObjectName;
import javax.management.MBeanInfo;
import javax.management.Attribute;
import javax.management.MBeanServer;
import javax.management.MBeanException;
import javax.management.AttributeNotFoundException;
import javax.management.RuntimeOperationsException;
import javax.management.ReflectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import java.beans.Introspector;
import java.beans.BeanInfo;
import java.beans.PropertyDescriptor;
import java.beans.IntrospectionException;
public class AppenderDynamicMBean extends AbstractDynamicMBean {
  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();
  private Hashtable dynamicProps = new Hashtable(5);
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[2];
  private String dDescription =
     ""This MBean acts as a management facade for log4j appenders."";
  // This category instance is for logging.
  private static Logger cat = Logger.getLogger(AppenderDynamicMBean.class);
  // We wrap this appender instance.
  private Appender appender;
  public  AppenderDynamicMBean(Appender appender) throws IntrospectionException {
    this.appender = appender;
    buildDynamicMBeanInfo();
  }
  private
  void buildDynamicMBeanInfo() throws IntrospectionException {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""AppenderDynamicMBean(): Constructs a AppenderDynamicMBean instance"",
	     constructors[0]);
    BeanInfo bi = Introspector.getBeanInfo(appender.getClass());
    PropertyDescriptor[] pd = bi.getPropertyDescriptors();
    int size = pd.length;
    for(int i = 0; i < size; i++) {
      String name = pd[i].getName();
      Method readMethod =  pd[i].getReadMethod();
      Method writeMethod =  pd[i].getWriteMethod();
      if(readMethod != null) {
	Class returnClass = readMethod.getReturnType();
	if(isSupportedType(returnClass)) {
	  String returnClassName;
	  if(returnClass.isAssignableFrom(Priority.class)) {
	    returnClassName = ""java.lang.String"";
	  } else {
	    returnClassName = returnClass.getName();
	  }
	  dAttributes.add(new MBeanAttributeInfo(name,
						 returnClassName,
						 ""Dynamic"",
						 true,
						 writeMethod != null,
						 false));
	  dynamicProps.put(name, new MethodUnion(readMethod, writeMethod));
	}
      }
    }
    MBeanParameterInfo[] params = new MBeanParameterInfo[0];
    dOperations[0] = new MBeanOperationInfo(""activateOptions"",
					    ""activateOptions(): add an appender"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
    params = new MBeanParameterInfo[1];
    params[0] = new MBeanParameterInfo(""layout class"", ""java.lang.String"",
				       ""layout class"");
    dOperations[1] = new MBeanOperationInfo(""setLayout"",
					    ""setLayout(): add a layout"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }
  private
  boolean isSupportedType(Class clazz) {
    if(clazz.isPrimitive()) {
      return true;
    }
    if(clazz == String.class) {
      return true;
    }
    if(clazz.isAssignableFrom(Priority.class)) {
      return true;
    }
    return false;
  }
  public
  MBeanInfo getMBeanInfo() {
    cat.debug(""getMBeanInfo called."");
    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);
    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }
  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {
    if(operationName.equals(""activateOptions"") &&
                     appender instanceof OptionHandler) {
      OptionHandler oh = (OptionHandler) appender;
      oh.activateOptions();
      return ""Options activated."";
    } else if (operationName.equals(""setLayout"")) {
      Layout layout = (Layout) OptionConverter.instantiateByClassName((String)
								      params[0],
								      Layout.class,
								      null);
      appender.setLayout(layout);
      registerLayoutMBean(layout);
    }
    return null;
  }
  void registerLayoutMBean(Layout layout) {
    if(layout == null)
      return;
    String name = appender.getName()+"",layout=""+layout.getClass().getName();
    cat.debug(""Adding LayoutMBean:""+name);
    ObjectName objectName = null;
    try {
      LayoutDynamicMBean appenderMBean = new LayoutDynamicMBean(layout);
      objectName = new ObjectName(""log4j:appender=""+name);
      server.registerMBean(appenderMBean, objectName);
      dAttributes.add(new MBeanAttributeInfo(""appender=""+name,
					     ""javax.management.ObjectName"",
					     ""The ""+name+"" layout."",
					     true,
					     true,
					     false));
    } catch(Exception e) {
      cat.error(""Could not add DynamicLayoutMBean for [""+name+""]."", e);
    }
  }
  protected
  Logger getLogger() {
    return cat;
  }
  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {
       // Check attributeName is not null to avoid NullPointerException later on
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }
    cat.debug(""getAttribute called with [""+attributeName+""]."");
    if(attributeName.startsWith(""appender=""+appender.getName()+"",layout"")) {
      try {
	return new ObjectName(""log4j:""+attributeName );
      } catch(Exception e) {
	cat.error(""attributeName"", e);
      }
    }
    MethodUnion mu = (MethodUnion) dynamicProps.get(attributeName);
    //cat.debug(""----name=""+attributeName+"", b=""+b);
    if(mu != null && mu.readMethod != null) {
      try {
	return mu.readMethod.invoke(appender, null);
      } catch(Exception e) {
	return null;
      }
    }
    // If attributeName has not been recognized throw an AttributeNotFoundException
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));
  }
  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {
    // Check attribute is not null to avoid NullPointerException later on
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();
    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }
    MethodUnion mu = (MethodUnion) dynamicProps.get(name);
    if(mu != null && mu.writeMethod != null) {
      Object[] o = new Object[1];
      Class[] params = mu.writeMethod.getParameterTypes();
      if(params[0] == org.apache.log4j.Priority.class) {
	value = OptionConverter.toLevel((String) value,
					(Level) getAttribute(name));
      }
      o[0] = value;
      try {
	mu.writeMethod.invoke(appender,  o);
      } catch(Exception e) {
	cat.error(""FIXME"", e);
      }
    } else if(name.endsWith("".layout"")) {
    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }
  public
  ObjectName preRegister(MBeanServer server, ObjectName name) {
    cat.debug(""preRegister called. Server=""+server+ "", name=""+name);
    this.server = server;
    registerLayoutMBean(appender.getLayout());
    return name;
  }
}
"
org.apache.log4j.jmx.HierarchyDynamicMBean,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.jmx;
import java.lang.reflect.Constructor;
import org.apache.log4j.*;
import org.apache.log4j.spi.HierarchyEventListener;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Vector;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.ObjectName;
import javax.management.MBeanInfo;
import javax.management.Attribute;
import javax.management.MBeanException;
import javax.management.AttributeNotFoundException;
import javax.management.RuntimeOperationsException;
import javax.management.ReflectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.NotificationBroadcasterSupport;
import javax.management.NotificationBroadcaster;
import javax.management.Notification;
import javax.management.NotificationListener;
import javax.management.NotificationFilter;
import javax.management.NotificationFilterSupport;
import javax.management.ListenerNotFoundException;
public class HierarchyDynamicMBean extends AbstractDynamicMBean
                                   implements HierarchyEventListener,
                                              NotificationBroadcaster {
  static final String ADD_APPENDER = ""addAppender."";
  static final String THRESHOLD = ""threshold"";
  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];
  private Vector vAttributes = new Vector();
  private String dClassName = this.getClass().getName();
  private String dDescription =
     ""This MBean acts as a management facade for org.apache.log4j.Hierarchy."";
  private NotificationBroadcasterSupport nbs = new NotificationBroadcasterSupport();
  private LoggerRepository hierarchy;
  private static Logger log = Logger.getLogger(HierarchyDynamicMBean.class);
  public HierarchyDynamicMBean() {
    hierarchy = LogManager.getLoggerRepository();
    buildDynamicMBeanInfo();
  }
  private
  void buildDynamicMBeanInfo() {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
         ""HierarchyDynamicMBean(): Constructs a HierarchyDynamicMBean instance"",
	 constructors[0]);
    vAttributes.add(new MBeanAttributeInfo(THRESHOLD,
					   ""java.lang.String"",
					   ""The \""threshold\"" state of the hiearchy."",
					   true,
					   true,
					   false));
    MBeanParameterInfo[] params = new MBeanParameterInfo[1];
    params[0] = new MBeanParameterInfo(""name"", ""java.lang.String"",
				       ""Create a logger MBean"" );
    dOperations[0] = new MBeanOperationInfo(""addLoggerMBean"",
				    ""addLoggerMBean(): add a loggerMBean"",
				    params ,
				    ""javax.management.ObjectName"",
				    MBeanOperationInfo.ACTION);
  }
  public
  ObjectName addLoggerMBean(String name) {
    Logger cat = Logger.exists(name);
    if(cat != null) {
      return addLoggerMBean(cat);
    } else {
      return null;
    }
  }
  ObjectName addLoggerMBean(Logger logger) {
    String name = logger.getName();
    ObjectName objectName = null;
    try {
      LoggerDynamicMBean loggerMBean = new LoggerDynamicMBean(logger);
      objectName = new ObjectName(""log4j"", ""logger"", name);
      server.registerMBean(loggerMBean, objectName);
      NotificationFilterSupport nfs = new NotificationFilterSupport();
      nfs.enableType(ADD_APPENDER+logger.getName());
      log.debug(""---Adding logger [""+name+""] as listener."");
      nbs.addNotificationListener(loggerMBean, nfs, null);
      vAttributes.add(new MBeanAttributeInfo(""logger=""+name,
					     ""javax.management.ObjectName"",
					     ""The ""+name+"" logger."",
					     true,
					     true, // this makes the object
					     // clickable
					     false));
    } catch(Exception e) {
      log.error(""Couls not add loggerMBean for [""+name+""]."");
    }
    return objectName;
  }
  public
  void addNotificationListener(NotificationListener listener,
			       NotificationFilter filter,
			       java.lang.Object handback) {
    nbs.addNotificationListener(listener, filter, handback);
  }
  protected
  Logger getLogger() {
    return log;
  }
  public
  MBeanInfo getMBeanInfo() {
    //cat.debug(""getMBeanInfo called."");
    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[vAttributes.size()];
    vAttributes.toArray(attribs);
    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }
  public
  MBeanNotificationInfo[] getNotificationInfo(){
    return nbs.getNotificationInfo();
  }
  public
  Object invoke(String operationName,
		Object params[],
		String signature[]) throws MBeanException,
                                           ReflectionException {
    if (operationName == null) {
      throw new RuntimeOperationsException(
        new IllegalArgumentException(""Operation name cannot be null""),
	""Cannot invoke a null operation in "" + dClassName);
    }
    // Check for a recognized operation name and call the corresponding operation
    if(operationName.equals(""addLoggerMBean"")) {
      return addLoggerMBean((String)params[0]);
    } else {
      throw new ReflectionException(
	    new NoSuchMethodException(operationName),
	    ""Cannot find the operation "" + operationName + "" in "" + dClassName);
    }
  }
  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                    MBeanException,
                                                    ReflectionException {
    // Check attributeName is not null to avoid NullPointerException later on
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }
    log.debug(""Called getAttribute with [""+attributeName+""]."");
    // Check for a recognized attributeName and call the corresponding getter
    if (attributeName.equals(THRESHOLD)) {
      return hierarchy.getThreshold();
    } else if(attributeName.startsWith(""logger"")) {
      int k = attributeName.indexOf(""%3D"");
      String val = attributeName;
      if(k > 0) {
	val = attributeName.substring(0, k)+'='+ attributeName.substring(k+3);
      }
      try {
	return new ObjectName(""log4j:""+val);
      } catch(Exception e) {
	log.error(""Could not create ObjectName"" + val);
      }
    }
    // If attributeName has not been recognized throw an AttributeNotFoundException
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));
  }
  public
  void addAppenderEvent(Category logger, Appender appender) {
    log.debug(""addAppenderEvent called: logger=""+logger.getName()+
	      "", appender=""+appender.getName());
    Notification n = new Notification(ADD_APPENDER+logger.getName(), this, 0);
    n.setUserData(appender);
    log.debug(""sending notification."");
    nbs.sendNotification(n);
  }
 public
  void removeAppenderEvent(Category cat, Appender appender) {
    log.debug(""removeAppenderCalled: logger=""+cat.getName()+
	      "", appender=""+appender.getName());
  }
  public
  void postRegister(java.lang.Boolean registrationDone) {
    log.debug(""postRegister is called."");
    hierarchy.addHierarchyEventListener(this);
    Logger root = hierarchy.getRootLogger();
    addLoggerMBean(root);
  }
  public
  void removeNotificationListener(NotificationListener listener)
                                         throws ListenerNotFoundException {
    nbs.removeNotificationListener(listener);
  }
  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {
    // Check attribute is not null to avoid NullPointerException later on
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
	  ""Cannot invoke a setter of ""+dClassName+"" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();
    if (name == null) {
      throw new RuntimeOperationsException(
               new IllegalArgumentException(""Attribute name cannot be null""),
	       ""Cannot invoke the setter of ""+dClassName+
	       "" with null attribute name"");
    }
    if(name.equals(THRESHOLD)) {
      Level l = OptionConverter.toLevel((String) value,
					   hierarchy.getThreshold());
      hierarchy.setThreshold(l);
    }
  }
}
"
org.apache.log4j.jmx.LayoutDynamicMBean,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.jmx;
import java.lang.reflect.Constructor;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
import java.util.Vector;
import java.util.Hashtable;
import java.lang.reflect.Method;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanInfo;
import javax.management.Attribute;
import javax.management.MBeanException;
import javax.management.AttributeNotFoundException;
import javax.management.RuntimeOperationsException;
import javax.management.ReflectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import java.beans.Introspector;
import java.beans.BeanInfo;
import java.beans.PropertyDescriptor;
import java.beans.IntrospectionException;
public class LayoutDynamicMBean extends AbstractDynamicMBean {
  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();
  private Hashtable dynamicProps = new Hashtable(5);
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];
  private String dDescription =
     ""This MBean acts as a management facade for log4j layouts."";
  // This category instance is for logging.
  private static Logger cat = Logger.getLogger(LayoutDynamicMBean.class);
  // We wrap this layout instance.
  private Layout layout;
  public  LayoutDynamicMBean(Layout layout) throws IntrospectionException {
    this.layout = layout;
    buildDynamicMBeanInfo();
  }
  private
  void buildDynamicMBeanInfo() throws IntrospectionException {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""LayoutDynamicMBean(): Constructs a LayoutDynamicMBean instance"",
	     constructors[0]);
    BeanInfo bi = Introspector.getBeanInfo(layout.getClass());
    PropertyDescriptor[] pd = bi.getPropertyDescriptors();
    int size = pd.length;
    for(int i = 0; i < size; i++) {
      String name = pd[i].getName();
      Method readMethod =  pd[i].getReadMethod();
      Method writeMethod =  pd[i].getWriteMethod();
      if(readMethod != null) {
	Class returnClass = readMethod.getReturnType();
	if(isSupportedType(returnClass)) {
	  String returnClassName;
	  if(returnClass.isAssignableFrom(Level.class)) {
	    returnClassName = ""java.lang.String"";
	  } else {
	    returnClassName = returnClass.getName();
	  }
	  dAttributes.add(new MBeanAttributeInfo(name,
						 returnClassName,
						 ""Dynamic"",
						 true,
						 writeMethod != null,
						 false));
	  dynamicProps.put(name, new MethodUnion(readMethod, writeMethod));
	}
      }
    }
    MBeanParameterInfo[] params = new MBeanParameterInfo[0];
    dOperations[0] = new MBeanOperationInfo(""activateOptions"",
					    ""activateOptions(): add an layout"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }
  private
  boolean isSupportedType(Class clazz) {
    if(clazz.isPrimitive()) {
      return true;
    }
    if(clazz == String.class) {
      return true;
    }
    if(clazz.isAssignableFrom(Level.class)) {
      return true;
    }
    return false;
  }
  public
  MBeanInfo getMBeanInfo() {
    cat.debug(""getMBeanInfo called."");
    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);
    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }
  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {
    if(operationName.equals(""activateOptions"") &&
                     layout instanceof OptionHandler) {
      OptionHandler oh = (OptionHandler) layout;
      oh.activateOptions();
      return ""Options activated."";
    }
    return null;
  }
  protected
  Logger  getLogger() {
    return cat;
  }
  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {
       // Check attributeName is not null to avoid NullPointerException later on
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }
    MethodUnion mu = (MethodUnion) dynamicProps.get(attributeName);
    cat.debug(""----name=""+attributeName+"", mu=""+mu);
    if(mu != null && mu.readMethod != null) {
      try {
	return mu.readMethod.invoke(layout, null);
      } catch(Exception e) {
	return null;
      }
    }
    // If attributeName has not been recognized throw an AttributeNotFoundException
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));
  }
  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {
    // Check attribute is not null to avoid NullPointerException later on
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();
    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }
    MethodUnion mu = (MethodUnion) dynamicProps.get(name);
    if(mu != null && mu.writeMethod != null) {
      Object[] o = new Object[1];
      Class[] params = mu.writeMethod.getParameterTypes();
      if(params[0] == org.apache.log4j.Priority.class) {
	value = OptionConverter.toLevel((String) value,
					(Level) getAttribute(name));
      }
      o[0] = value;
      try {
	mu.writeMethod.invoke(layout,  o);
      } catch(Exception e) {
	cat.error(""FIXME"", e);
      }
    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }
}
"
org.apache.log4j.jmx.LoggerDynamicMBean,"package org.apache.log4j.jmx;
import java.lang.reflect.Constructor;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import org.apache.log4j.Appender;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Vector;
import java.util.Enumeration;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.ObjectName;
import javax.management.MBeanInfo;
import javax.management.Attribute;
import javax.management.MBeanException;
import javax.management.AttributeNotFoundException;
import javax.management.RuntimeOperationsException;
import javax.management.ReflectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.NotificationListener;
import javax.management.Notification;
public class LoggerDynamicMBean extends AbstractDynamicMBean
                                  implements NotificationListener {
  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];
  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();
  private String dDescription =
     ""This MBean acts as a management facade for a org.apache.log4j.Logger instance."";
  // This Logger instance is for logging.
  private static Logger cat = Logger.getLogger(LoggerDynamicMBean.class);
  // We wrap this Logger instance.
  private Logger logger;
  public LoggerDynamicMBean(Logger logger) {
    this.logger = logger;
    buildDynamicMBeanInfo();
  }
  public
  void handleNotification(Notification notification, Object handback) {
    cat.debug(""Received notification: ""+notification.getType());
    registerAppenderMBean((Appender) notification.getUserData() );
  }
  private
  void buildDynamicMBeanInfo() {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""HierarchyDynamicMBean(): Constructs a HierarchyDynamicMBean instance"",
	     constructors[0]);
    dAttributes.add(new MBeanAttributeInfo(""name"",
					   ""java.lang.String"",
					   ""The name of this Logger."",
					   true,
					   false,
					   false));
    dAttributes.add(new MBeanAttributeInfo(""priority"",
					   ""java.lang.String"",
					   ""The priority of this logger."",
					   true,
					   true,
					   false));
    MBeanParameterInfo[] params = new MBeanParameterInfo[2];
    params[0] = new MBeanParameterInfo(""class name"", ""java.lang.String"",
				       ""add an appender to this logger"");
    params[1] = new MBeanParameterInfo(""appender name"", ""java.lang.String"",
				       ""name of the appender"");
    dOperations[0] = new MBeanOperationInfo(""addAppender"",
					    ""addAppender(): add an appender"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }
  protected
  Logger getLogger() {
    return logger;
  }
  public
  MBeanInfo getMBeanInfo() {
    //cat.debug(""getMBeanInfo called."");
    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);
    MBeanInfo mb = new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
    //cat.debug(""getMBeanInfo exit."");
    return mb;
  }
  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {
    if(operationName.equals(""addAppender"")) {
      addAppender((String) params[0], (String) params[1]);
      return ""Hello world."";
    }
    return null;
  }
  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {
       // Check attributeName is not null to avoid NullPointerException later on
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }
    // Check for a recognized attributeName and call the corresponding getter
    if (attributeName.equals(""name"")) {
      return logger.getName();
    }  else if(attributeName.equals(""priority"")) {
      Level l = logger.getLevel();
      if(l == null) {
	return null;
      } else {
	return l.toString();
      }
    } else if(attributeName.startsWith(""appender="")) {
      try {
	return new ObjectName(""log4j:""+attributeName );
      } catch(Exception e) {
	cat.error(""Could not create ObjectName"" + attributeName);
      }
    }
    // If attributeName has not been recognized throw an AttributeNotFoundException
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));
  }
  void addAppender(String appenderClass, String appenderName) {
    cat.debug(""addAppender called with ""+appenderClass+"", ""+appenderName);
    Appender appender = (Appender)
       OptionConverter.instantiateByClassName(appenderClass,
					      org.apache.log4j.Appender.class,
					      null);
    appender.setName(appenderName);
    logger.addAppender(appender);
    //appenderMBeanRegistration();
  }
  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {
    // Check attribute is not null to avoid NullPointerException later on
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();
    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }
    if(name.equals(""priority"")) {
      if (value instanceof String) {
	String s = (String) value;
	Level p = logger.getLevel();
	if(s.equalsIgnoreCase(""NULL"")) {
	  p = null;
	} else {
	  p = OptionConverter.toLevel(s, p);
	}
	logger.setPriority(p);
      }
    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }
  void appenderMBeanRegistration() {
    Enumeration enum = logger.getAllAppenders();
    while(enum.hasMoreElements()) {
      Appender appender = (Appender) enum.nextElement();
      registerAppenderMBean(appender);
    }
  }
  void registerAppenderMBean(Appender appender) {
    String name = appender.getName();
    cat.debug(""Adding AppenderMBean for appender named ""+name);
    ObjectName objectName = null;
    try {
      AppenderDynamicMBean appenderMBean = new AppenderDynamicMBean(appender);
      objectName = new ObjectName(""log4j"", ""appender"", name);
      server.registerMBean(appenderMBean, objectName);
      dAttributes.add(new MBeanAttributeInfo(""appender=""+name,
					     ""javax.management.ObjectName"",
					     ""The ""+name+"" appender."",
					     true,
					     true,
					     false));
    } catch(Exception e) {
      cat.error(""Could not add appenderMBean for [""+name+""]."", e);
    }
  }
  public
  void postRegister(java.lang.Boolean registrationDone) {
    appenderMBeanRegistration();
  }
}
"
org.apache.log4j.jmx.MethodUnion,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.jmx;
import java.lang.reflect.Method;
class MethodUnion {
  Method readMethod;
  Method writeMethod;
  MethodUnion( Method readMethod, Method writeMethod) {
    this.readMethod = readMethod;
    this.writeMethod = writeMethod;
  }
}
"
org.apache.log4j.jmx.T,"import org.apache.log4j.jmx.Agent;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.*;
public class T {
  public static void main(String[] args) {
    Category cat = Category.getInstance(T.class);
    Layout layout = new PatternLayout(""%r %p [%t] %c - %m%n"");
    ConsoleAppender consoleAppender = new ConsoleAppender(layout);
    consoleAppender.setName(""console"");
    BasicConfigurator.configure(consoleAppender);
    Agent agent = new Agent();
    agent.start();
  }
}
"
org.apache.log4j.lf5.AppenderFinalizer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
/**
 * <code>AppenderFinalizer</code> has a single method that will finalize
 * resources associated with a <code>LogBrokerMonitor</code> in the event
 * that the <code>LF5Appender</code> class is destroyed, and the class loader
 * is garbage collected.
 *
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class AppenderFinalizer {
  //--------------------------------------------------------------------------
  // Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Protected Variables:
  //--------------------------------------------------------------------------
  protected LogBrokerMonitor _defaultMonitor = null;
  //--------------------------------------------------------------------------
  // Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Constructors:
  //--------------------------------------------------------------------------
  public AppenderFinalizer(LogBrokerMonitor defaultMonitor) {
    _defaultMonitor = defaultMonitor;
  }
  //--------------------------------------------------------------------------
  // Public Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Protected Methods:
  //--------------------------------------------------------------------------
  /**
   * @throws java.lang.Throwable
   */
  protected void finalize() throws Throwable {
    System.out.println(""Disposing of the default LogBrokerMonitor instance"");
    _defaultMonitor.dispose();
  }
  //--------------------------------------------------------------------------
  // Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.DefaultLF5Configurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerRepository;
import java.io.IOException;
import java.net.URL;
/**
 * The <code>DefaultLF5Configurator</code> provides a default
 * configuration for the <code>LF5Appender</code>.
 *
 * Note: The preferred method for configuring a <code>LF5Appender</code>
 * is to use the <code>LF5Manager</code> class. This class ensures
 * that configuration does not occur multiple times, and improves system
 * performance. Reconfiguring the monitor multiple times can result in
 * unexpected behavior.
 *
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class DefaultLF5Configurator implements Configurator {
  //--------------------------------------------------------------------------
  // Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Constructors:
  //--------------------------------------------------------------------------
  /**
   * This class should never be instantiated! It implements the <code>
   * Configurator</code>
   * interface, but does not provide the same functionality as full
   * configurator class.
   */
  private DefaultLF5Configurator() {
  }
  //--------------------------------------------------------------------------
  // Public Methods:
  //--------------------------------------------------------------------------
  /**
   * This method configures the <code>LF5Appender</code> using a
   * default configuration file. The default configuration file is
   * <bold>defaultconfig.properties</bold>.
   * @throws java.io.IOException
   */
  public static void configure() throws IOException {
    String resource =
        ""/org/apache/log4j/lf5/config/defaultconfig.properties"";
    URL configFileResource =
        DefaultLF5Configurator.class.getResource(resource);
    if (configFileResource != null) {
      PropertyConfigurator.configure(configFileResource);
    } else {
      throw new IOException(""Error: Unable to open the resource"" +
          resource);
    }
  }
  /**
   * This is a dummy method that will throw an
   * <code>IllegalStateException</code> if used.
   */
  public void doConfigure(URL configURL, LoggerRepository repository) {
    throw new IllegalStateException(""This class should NOT be"" +
        "" instantiated!"");
  }
  //--------------------------------------------------------------------------
  // Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.LF5Appender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import org.apache.log4j.lf5.util.Resource;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.spi.LoggingEvent;
import java.awt.*;
/**
 * <code>LF5Appender</code> logs events to a swing based logging
 * console. The swing console supports turning categories on and off,
 * multiple detail level views, as well as full text searching and many
 * other capabilties.
 *
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class LF5Appender extends AppenderSkeleton {
  //--------------------------------------------------------------------------
  // Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Protected Variables:
  //--------------------------------------------------------------------------
  protected LogBrokerMonitor _logMonitor;
  protected static LogBrokerMonitor _defaultLogMonitor;
  protected static AppenderFinalizer _finalizer;
  //--------------------------------------------------------------------------
  // Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Constructors:
  //--------------------------------------------------------------------------
  /**
   * Constructs a <code>LF5Appender</code> using the default instance of
   * the <code>LogBrokerMonitor</code>. This constructor should <bold>always
   * </bold> be  preferred over the
   * <code>LF5Appender(LogBrokerMonitor monitor)</code>
   * constructor, unless you need to spawn additional log monitoring
   * windows.
   */
  public LF5Appender() {
    this(getDefaultInstance());
  }
  /**
   * Constructs a <code>LF5Appender<code> using an instance of
   * a <code>LogBrokerMonitor<code> supplied by the user. This
   * constructor should only be used when you need to spawn
   * additional log monitoring windows.
   *
   * @param monitor An instance of a <code>LogBrokerMonitor<code>
   * created by the user.
   */
  public LF5Appender(LogBrokerMonitor monitor) {
    if (monitor != null) {
      _logMonitor = monitor;
    }
  }
  //--------------------------------------------------------------------------
  // Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Appends a <code>LoggingEvent</code> record to the
   * <code>LF5Appender</code>.
   * @param event The <code>LoggingEvent</code>
   * to be appended.
   */
  public void append(LoggingEvent event) {
    // Retrieve the information from the log4j LoggingEvent.
    String category = event.categoryName;
    String logMessage = event.getRenderedMessage();
    String nestedDiagnosticContext = event.getNDC();
    String threadDescription = event.getThreadName();
    String level = event.level.toString();
    long time = event.timeStamp;
    LocationInfo locationInfo = event.getLocationInformation();
    // Add the logging event information to a LogRecord
    Log4JLogRecord record = new Log4JLogRecord();
    record.setCategory(category);
    record.setMessage(logMessage);
    record.setLocation(locationInfo.fullInfo);
    record.setMillis(time);
    record.setThreadDescription(threadDescription);
    if (nestedDiagnosticContext != null) {
      record.setNDC(nestedDiagnosticContext);
    } else {
      record.setNDC("""");
    }
    if (event.getThrowableInformation() != null) {
      record.setThrownStackTrace(event.getThrowableInformation());
    }
    try {
      record.setLevel(LogLevel.valueOf(level));
    } catch (LogLevelFormatException e) {
      // If the priority level doesn't match one of the predefined
      // log levels, then set the level to warning.
      record.setLevel(LogLevel.WARN);
    }
    if (_logMonitor != null) {
      _logMonitor.addMessage(record);
    }
  }
  /**
   * This method is an empty implementation of the close() method inherited
   * from the <code>org.apache.log4j.Appender</code> interface.
   */
  public void close() {
  }
  /**
   * Returns a value that indicates whether this appender requires a
   * <code>Layout</code>. This method always returns false.
   * No layout is required for the <code>LF5Appender</code>.
   */
  public boolean requiresLayout() {
    return false;
  }
  /**
   * This method is used to set the property that controls whether
   * the <code>LogBrokerMonitor</code> is hidden or closed when a user
   * exits
   * the monitor. By default, the <code>LogBrokerMonitor</code> will hide
   * itself when the log window is exited, and the swing thread will
   * continue to run in the background. If this property is
   * set to true, the <code>LogBrokerMonitor</code> will call System.exit(0)
   * and will shut down swing thread and the virtual machine.
   *
   * @param callSystemExitOnClose A boolean value indicating whether
   * to call System.exit(0) when closing the log window.
   */
  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {
    _logMonitor.setCallSystemExitOnClose(callSystemExitOnClose);
  }
  /**
   * The equals method compares two LF5Appenders and determines whether
   * they are equal. Two <code>Appenders</code> will be considered equal
   * if, and only if, they both contain references to the same <code>
   * LogBrokerMonitor</code>.
   *
   * @param compareTo A boolean value indicating whether
   * the two LF5Appenders are equal.
   */
  public boolean equals(LF5Appender compareTo) {
    // If both reference the same LogBrokerMonitor, they are equal.
    return _logMonitor == compareTo.getLogBrokerMonitor();
  }
  public LogBrokerMonitor getLogBrokerMonitor() {
    return _logMonitor;
  }
  public static void main(String[] args) {
    new LF5Appender();
  }
  public void setMaxNumberOfRecords(int maxNumberOfRecords) {
    _defaultLogMonitor.setMaxNumberOfLogRecords(maxNumberOfRecords);
  }
  //--------------------------------------------------------------------------
  // Protected Methods:
  //--------------------------------------------------------------------------
  /**
   * @return The default instance of the <code>LogBrokerMonitor</code>.
   */
  protected static synchronized LogBrokerMonitor getDefaultInstance() {
    if (_defaultLogMonitor == null) {
      try {
        _defaultLogMonitor =
            new LogBrokerMonitor(LogLevel.getLog4JLevels());
        _finalizer = new AppenderFinalizer(_defaultLogMonitor);
        _defaultLogMonitor.setFrameSize(getDefaultMonitorWidth(),
            getDefaultMonitorHeight());
        _defaultLogMonitor.setFontSize(12);
        _defaultLogMonitor.show();
      } catch (SecurityException e) {
        _defaultLogMonitor = null;
      }
    }
    return _defaultLogMonitor;
  }
  /**
   * @return the screen width from Toolkit.getScreenSize()
   * if possible, otherwise returns 800
   * @see java.awt.Toolkit
   */
  protected static int getScreenWidth() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().width;
    } catch (Throwable t) {
      return 800;
    }
  }
  /**
   * @return the screen height from Toolkit.getScreenSize()
   * if possible, otherwise returns 600
   * @see java.awt.Toolkit
   */
  protected static int getScreenHeight() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().height;
    } catch (Throwable t) {
      return 600;
    }
  }
  protected static int getDefaultMonitorWidth() {
    return (3 * getScreenWidth()) / 4;
  }
  protected static int getDefaultMonitorHeight() {
    return (3 * getScreenHeight()) / 4;
  }
  //--------------------------------------------------------------------------
  // Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  // Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.Log4JLogRecord,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import org.apache.log4j.spi.ThrowableInformation;
/**
 * A <code>Log4JLogRecord</code> encapsulates
 * the details of your log4j <code>LoggingEvent</code> in a format usable
 * by the <code>LogBrokerMonitor</code>.
 *
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class Log4JLogRecord extends LogRecord {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Constructs an instance of a <code>Log4JLogRecord</code>.
   */
  public Log4JLogRecord() {
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Determines which <code>Priority</code> levels will
   * be displayed in colored font when the <code>LogMonitorAppender</code>
   * renders this log message. By default, messages will be colored
   * red if they are of <code>Priority</code> ERROR or FATAL.
   *
   * @return true if the log level is ERROR or FATAL.
   */
  public boolean isSevereLevel() {
    boolean isSevere = false;
    if (LogLevel.ERROR.equals(getLevel()) ||
        LogLevel.FATAL.equals(getLevel())) {
      isSevere = true;
    }
    return isSevere;
  }
  /**
   * Set stack trace information associated with this Log4JLogRecord.
   * When this method is called, the stack trace in a
   * String-based format is made
   * available via the getThrownStackTrace() method.
   *
   * @param throwableInfo An org.apache.log4j.spi.ThrowableInformation to
   * associate with this Log4JLogRecord.
   * @see #getThrownStackTrace()
   */
  public void setThrownStackTrace(ThrowableInformation throwableInfo) {
    String[] stackTraceArray = throwableInfo.getThrowableStrRep();
    StringBuffer stackTrace = new StringBuffer();
    String nextLine;
    for (int i = 0; i < stackTraceArray.length; i++) {
      nextLine = stackTraceArray[i] + ""\n"";
      stackTrace.append(nextLine);
    }
    _thrownStackTrace = stackTrace.toString();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.LogLevel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import java.awt.*;
import java.util.*;
import java.util.List;
/**
 * The LogLevel class defines a set of standard logging levels.
 *
 * The logging Level objects are ordered and are specified by ordered
 * integers. Enabling logging at a given level also enables logging at all
 * higher levels.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brent Sprecher
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogLevel implements java.io.Serializable {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  // log4j log levels.
  public final static LogLevel FATAL = new LogLevel(""FATAL"", 0);
  public final static LogLevel ERROR = new LogLevel(""ERROR"", 1);
  public final static LogLevel WARN = new LogLevel(""WARN"", 2);
  public final static LogLevel INFO = new LogLevel(""INFO"", 3);
  public final static LogLevel DEBUG = new LogLevel(""DEBUG"", 4);
  // jdk1.4 log levels NOTE: also includes INFO
  public final static LogLevel SEVERE = new LogLevel(""SEVERE"", 1);
  public final static LogLevel WARNING = new LogLevel(""WARNING"", 2);
  public final static LogLevel CONFIG = new LogLevel(""CONFIG"", 4);
  public final static LogLevel FINE = new LogLevel(""FINE"", 5);
  public final static LogLevel FINER = new LogLevel(""FINER"", 6);
  public final static LogLevel FINEST = new LogLevel(""FINEST"", 7);
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected String _label;
  protected int _precedence;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private static LogLevel[] _log4JLevels;
  private static LogLevel[] _jdk14Levels;
  private static LogLevel[] _allDefaultLevels;
  private static Map _logLevelMap;
  private static Map _logLevelColorMap;
  private static Map _registeredLogLevelMap = new HashMap();
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  static {
    _log4JLevels = new LogLevel[]{FATAL, ERROR, WARN, INFO, DEBUG};
    _jdk14Levels = new LogLevel[]{SEVERE, WARNING, INFO,
                                  CONFIG, FINE, FINER, FINEST};
    _allDefaultLevels = new LogLevel[]{FATAL, ERROR, WARN, INFO, DEBUG,
                                       SEVERE, WARNING, CONFIG, FINE, FINER, FINEST};
    _logLevelMap = new HashMap();
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelMap.put(_allDefaultLevels[i].getLabel(), _allDefaultLevels[i]);
    }
    // prepopulate map with levels and text color of black
    _logLevelColorMap = new HashMap();
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelColorMap.put(_allDefaultLevels[i], Color.black);
    }
  }
  public LogLevel(String label, int precedence) {
    _label = label;
    _precedence = precedence;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Return the Label of the LogLevel.
   */
  public String getLabel() {
    return _label;
  }
  /**
   * Returns true if the level supplied is encompassed by this level.
   * For example, LogLevel.SEVERE encompasses no other LogLevels and
   * LogLevel.FINE encompasses all other LogLevels.  By definition,
   * a LogLevel encompasses itself.
   */
  public boolean encompasses(LogLevel level) {
    if (level.getPrecedence() <= getPrecedence()) {
      return true;
    }
    return false;
  }
  /**
   * Convert a log level label into a LogLevel object.
   *
   * @param level The label of a level to be converted into a LogLevel.
   * @return LogLevel The LogLevel with a label equal to level.
   * @throws LogLevelFormatException Is thrown when the level can not be
   *         converted into a LogLevel.
   */
  public static LogLevel valueOf(String level)
      throws LogLevelFormatException {
    LogLevel logLevel = null;
    if (level != null) {
      level = level.trim().toUpperCase();
      logLevel = (LogLevel) _logLevelMap.get(level);
    }
    // Didn't match, Check for registered LogLevels
    if (logLevel == null && _registeredLogLevelMap.size() > 0) {
      logLevel = (LogLevel) _registeredLogLevelMap.get(level);
    }
    if (logLevel == null) {
      StringBuffer buf = new StringBuffer();
      buf.append(""Error while trying to parse ("" + level + "") into"");
      buf.append("" a LogLevel."");
      throw new LogLevelFormatException(buf.toString());
    }
    return logLevel;
  }
  /**
   * Registers a used defined LogLevel.
   *
   * @param logLevel The log level to be registered. Cannot be a default LogLevel
   * @return LogLevel The replaced log level.
   */
  public static LogLevel register(LogLevel logLevel) {
    if (logLevel == null) return null;
    // ensure that this is not a default log level
    if (_logLevelMap.get(logLevel.getLabel()) == null) {
      return (LogLevel) _registeredLogLevelMap.put(logLevel.getLabel(), logLevel);
    }
    return null;
  }
  public static void register(LogLevel[] logLevels) {
    if (logLevels != null) {
      for (int i = 0; i < logLevels.length; i++) {
        register(logLevels[i]);
      }
    }
  }
  public static void register(List logLevels) {
    if (logLevels != null) {
      Iterator it = logLevels.iterator();
      while (it.hasNext()) {
        register((LogLevel) it.next());
      }
    }
  }
  public boolean equals(Object o) {
    boolean equals = false;
    if (o instanceof LogLevel) {
      if (this.getPrecedence() ==
          ((LogLevel) o).getPrecedence()) {
        equals = true;
      }
    }
    return equals;
  }
  public int hashCode() {
    return _label.hashCode();
  }
  public String toString() {
    return _label;
  }
  // set a text color for a specific log level
  public void setLogLevelColorMap(LogLevel level, Color color) {
    // remove the old entry
    _logLevelColorMap.remove(level);
    // add the new color entry
    if (color == null) {
      color = Color.black;
    }
    _logLevelColorMap.put(level, color);
  }
  public static void resetLogLevelColorMap() {
    // empty the map
    _logLevelColorMap.clear();
    // repopulate map and reset text color black
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelColorMap.put(_allDefaultLevels[i], Color.black);
    }
  }
  /**
   * @return A <code>List</code> of <code>LogLevel</code> objects that map
   * to log4j <code>Priority</code> objects.
   */
  public static List getLog4JLevels() {
    return Arrays.asList(_log4JLevels);
  }
  public static List getJdk14Levels() {
    return Arrays.asList(_jdk14Levels);
  }
  public static List getAllDefaultLevels() {
    return Arrays.asList(_allDefaultLevels);
  }
  public static Map getLogLevelColorMap() {
    return _logLevelColorMap;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected int getPrecedence() {
    return _precedence;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.LogLevelFormatException,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
/**
 * Thrown to indicate that the client has attempted to convert a string
 * to one the LogLevel types, but the string does not have the appropriate
 * format.
 *
 * @author Michael J. Sikorsky<
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class LogLevelFormatException extends Exception {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogLevelFormatException(String message) {
    super(message);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.LogRecord,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
/**
 * LogRecord.  A LogRecord encapsulates the details of your desired log
 * request.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public abstract class LogRecord implements java.io.Serializable {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected static long _seqCount = 0;
  protected LogLevel _level;
  protected String _message;
  protected long _sequenceNumber;
  protected long _millis;
  protected String _category;
  protected String _thread;
  protected String _thrownStackTrace;
  protected Throwable _thrown;
  protected String _ndc;
  protected String _location;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogRecord() {
    super();
    _millis = System.currentTimeMillis();
    _category = ""Debug"";
    _message = """";
    _level = LogLevel.INFO;
    _sequenceNumber = getNextId();
    _thread = Thread.currentThread().toString();
    _ndc = """";
    _location = """";
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Get the level of this LogRecord.
   *
   * @return The LogLevel of this record.
   * @see #setLevel(LogLevel)
   * @see LogLevel
   */
  public LogLevel getLevel() {
    return (_level);
  }
  /**
   * Set the level of this LogRecord.
   *
   * @param level The LogLevel for this record.
   * @see #getLevel()
   * @see LogLevel
   */
  public void setLevel(LogLevel level) {
    _level = level;
  }
  /**
   * Abstract method. Must be overridden to indicate what log level
   * to show in red.
   */
  public abstract boolean isSevereLevel();
  /**
   * @return true if getThrown().toString() is a non-empty string.
   */
  public boolean hasThrown() {
    Throwable thrown = getThrown();
    if (thrown == null) {
      return false;
    }
    String thrownString = thrown.toString();
    return thrownString != null && thrownString.trim().length() != 0;
  }
  /**
   * @return true if isSevereLevel() or hasThrown() returns true.
   */
  public boolean isFatal() {
    return isSevereLevel() || hasThrown();
  }
  /**
   * Get the category asscociated with this LogRecord.  For a more detailed
   * description of what a category is see setCategory().
   *
   * @return The category of this record.
   * @see #setCategory(String)
   */
  public String getCategory() {
    return (_category);
  }
  /**
   * Set the category associated with this LogRecord. A category represents
   * a hierarchical dot (""."") separated namespace for messages.
   * The definition of a category is application specific, but a common convention
   * is as follows:
   *
   * <p>
   * When logging messages
   * for a particluar class you can use its class name:
   * com.thoughtworks.framework.servlet.ServletServiceBroker.<br><br>
   * Futhermore, to log a message for a particular method in a class
   * add the method name:
   * com.thoughtworks.framework.servlet.ServletServiceBroker.init().
   * </p>
   *
   * @param category The category for this record.
   * @see #getCategory()
   */
  public void setCategory(String category) {
    _category = category;
  }
  /**
   * Get the message asscociated with this LogRecord.
   *
   * @return The message of this record.
   * @see #setMessage(String)
   */
  public String getMessage() {
    return (_message);
  }
  /**
   * Set the message associated with this LogRecord.
   *
   * @param message The message for this record.
   * @see #getMessage()
   */
  public void setMessage(String message) {
    _message = message;
  }
  /**
   * Get the sequence number associated with this LogRecord.  Sequence numbers
   * are generally assigned when a LogRecord is constructed.  Sequence numbers
   * start at 0 and increase with each newly constructed LogRocord.
   *
   * @return The sequence number of this record.
   * @see #setSequenceNumber(long)
   */
  public long getSequenceNumber() {
    return (_sequenceNumber);
  }
  /**
   * Set the sequence number assocsiated with this LogRecord.  A sequence number
   * will automatically be assigned to evey newly constructed LogRecord, however,
   * this method can override the value.
   *
   * @param number The sequence number.
   * @see #getSequenceNumber()
   */
  public void setSequenceNumber(long number) {
    _sequenceNumber = number;
  }
  /**
   * Get the event time of this record in milliseconds from 1970.
   * When a LogRecord is constructed the event time is set but may be
   * overridden by calling setMillis();
   *
   * @return The event time of this record in milliseconds from 1970.
   * @see #setMillis(long)
   */
  public long getMillis() {
    return _millis;
  }
  /**
   * Set the event time of this record.  When a LogRecord is constructed
   * the event time is set but may be overridden by calling this method.
   *
   * @param millis The time in milliseconds from 1970.
   * @see #getMillis()
   */
  public void setMillis(long millis) {
    _millis = millis;
  }
  /**
   * Get the thread description asscociated with this LogRecord.  When a
   * LogRecord is constructed, the thread description is set by calling:
   * Thread.currentThread().toString().  You may supply a thread description
   * of your own by calling the setThreadDescription(String) method.
   *
   * @return The thread description of this record.
   * @see #setThreadDescription(String)
   */
  public String getThreadDescription() {
    return (_thread);
  }
  /**
   * Set the thread description associated with this LogRecord.  When a
   * LogRecord is constructed, the thread description is set by calling:
   * Thread.currentThread().toString().  You may supply a thread description
   * of your own by calling this method.
   *
   * @param threadDescription The description of the thread for this record.
   * @see #getThreadDescription()
   */
  public void setThreadDescription(String threadDescription) {
    _thread = threadDescription;
  }
  /**
   * Get the stack trace in a String-based format for the associated Throwable
   * of this LogRecord.  The stack trace in a String-based format is set
   * when the setThrown(Throwable) method is called.
   *
   * <p>
   * Why do we need this method considering that we
   * have the getThrown() and setThrown() methods?
   * A Throwable object may not be serializable, however, a String representation
   * of it is.  Users of LogRecords should generally call this method over
   * getThrown() for the reasons of serialization.
   * </p>
   *
   * @return The Stack Trace for the asscoiated Throwable of this LogRecord.
   * @see #setThrown(Throwable)
   * @see #getThrown()
   */
  public String getThrownStackTrace() {
    return (_thrownStackTrace);
  }
  /**
   * Set the ThrownStackTrace for the log record.
   *
   * @param trace A String to associate with this LogRecord
   * @see #getThrownStackTrace()
   */
  public void setThrownStackTrace(String trace) {
    _thrownStackTrace = trace;
  }
  /**
   * Get the Throwable associated with this LogRecord.
   *
   * @return The LogLevel of this record.
   * @see #setThrown(Throwable)
   * @see #getThrownStackTrace()
   */
  public Throwable getThrown() {
    return (_thrown);
  }
  /**
   * Set the Throwable associated with this LogRecord.  When this method
   * is called, the stack trace in a String-based format is made
   * available via the getThrownStackTrace() method.
   *
   * @param thrown A Throwable to associate with this LogRecord.
   * @see #getThrown()
   * @see #getThrownStackTrace()
   */
  public void setThrown(Throwable thrown) {
    if (thrown == null) {
      return;
    }
    _thrown = thrown;
    StringWriter sw = new StringWriter();
    PrintWriter out = new PrintWriter(sw);
    thrown.printStackTrace(out);
    out.flush();
    _thrownStackTrace = sw.toString();
    try {
      out.close();
      sw.close();
    } catch (IOException e) {
      // Do nothing, this should not happen as it is StringWriter.
    }
    out = null;
    sw = null;
  }
  /**
   * Return a String representation of this LogRecord.
   */
  public String toString() {
    StringBuffer buf = new StringBuffer();
    buf.append(""LogRecord: ["" + _level + "", "" + _message + ""]"");
    return (buf.toString());
  }
  /**
   * Get the NDC (nested diagnostic context) for this record.
   *
   * @return The string representing the NDC.
   */
  public String getNDC() {
    return _ndc;
  }
  /**
   * Set the NDC (nested diagnostic context) for this record.
   *
   * @param ndc A string representing the NDC.
   */
  public void setNDC(String ndc) {
    _ndc = ndc;
  }
  /**
   * Get the location in code where this LogRecord originated.
   *
   * @return The string containing the location information.
   */
  public String getLocation() {
    return _location;
  }
  /**
   * Set the location in code where this LogRecord originated.
   *
   * @param ndc A string containing location information.
   */
  public void setLocation(String location) {
    _location = location;
  }
  /**
   * Resets that sequence number to 0.
   *
   */
  public static synchronized void resetSequenceNumber() {
    _seqCount = 0;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected static synchronized long getNextId() {
    _seqCount++;
    return _seqCount;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.LogRecordFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
/**
 * An interface for classes which filters LogRecords.  Implementations
 * represent a rule or condition which LogRecords may pass or fail.
 * @see LogRecord
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public interface LogRecordFilter {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * @return true if the specified LogRecord satisfies whatever condition
   * implementing class tests for.
   */
  public boolean passes(LogRecord record);
}
"
org.apache.log4j.lf5.PassingLogRecordFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
/**
 * An implementation of LogRecordFilter which always returns true.
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public class PassingLogRecordFilter implements LogRecordFilter {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * @return true;
   */
  public boolean passes(LogRecord record) {
    return true;
  }
  /**
   * Does nothing.
   */
  public void reset() {
    // do nothing
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.StartLogFactor5,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
/**
 * Starts an instance of the LogFactor5 console for off-line viewing.
 *
 * @author Brad Marlborough
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class StartLogFactor5 {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Main - starts a an instance of the LogFactor5 console and configures
   * the console settings.
   */
  public final static void main(String[] args) {
    LogBrokerMonitor monitor = new LogBrokerMonitor(
        LogLevel.getLog4JLevels());
    monitor.setFrameSize(LF5Appender.getDefaultMonitorWidth(),
        LF5Appender.getDefaultMonitorHeight());
    monitor.setFontSize(12);
    monitor.show();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.AdapterLogRecord,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import java.io.PrintWriter;
import java.io.StringWriter;
/**
 * <p>A LogRecord to be used with the LogMonitorAdapter</p>
 *
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class AdapterLogRecord extends LogRecord {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private static LogLevel severeLevel = null;
  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public AdapterLogRecord() {
    super();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void setCategory(String category) {
    super.setCategory(category);
    super.setLocation(getLocationInfo(category));
  }
  public boolean isSevereLevel() {
    if (severeLevel == null) return false;
    return severeLevel.equals(getLevel());
  }
  public static void setSevereLevel(LogLevel level) {
    severeLevel = level;
  }
  public static LogLevel getSevereLevel() {
    return severeLevel;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected String getLocationInfo(String category) {
    String stackTrace = stackTraceToString(new Throwable());
    String line = parseLine(stackTrace, category);
    return line;
  }
  protected String stackTraceToString(Throwable t) {
    String s = null;
    synchronized (sw) {
      t.printStackTrace(pw);
      s = sw.toString();
      sw.getBuffer().setLength(0);
    }
    return s;
  }
  protected String parseLine(String trace, String category) {
    int index = trace.indexOf(category);
    if (index == -1) return null;
    trace = trace.substring(index);
    trace = trace.substring(0, trace.indexOf("")"") + 1);
    return trace;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.DateFormatManager,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
/**
 * Date format manager.
 * Utility class to help manage consistent date formatting and parsing.
 * It may be advantageous to have multiple DateFormatManagers per
 * application.  For example, one for handling the output (formatting) of
 * dates, and another one for handling the input (parsing) of dates.
 *
 * @author Robert Shaw
 * @author Michael J. Sikorsky
 */
// Contributed by ThoughtWorks Inc.
public class DateFormatManager {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private TimeZone _timeZone = null;
  private Locale _locale = null;
  private String _pattern = null;
  private DateFormat _dateFormat = null;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public DateFormatManager() {
    super();
    configure();
  }
  public DateFormatManager(TimeZone timeZone) {
    super();
    _timeZone = timeZone;
    configure();
  }
  public DateFormatManager(Locale locale) {
    super();
    _locale = locale;
    configure();
  }
  public DateFormatManager(String pattern) {
    super();
    _pattern = pattern;
    configure();
  }
  public DateFormatManager(TimeZone timeZone, Locale locale) {
    super();
    _timeZone = timeZone;
    _locale = locale;
    configure();
  }
  public DateFormatManager(TimeZone timeZone, String pattern) {
    super();
    _timeZone = timeZone;
    _pattern = pattern;
    configure();
  }
  public DateFormatManager(Locale locale, String pattern) {
    super();
    _locale = locale;
    _pattern = pattern;
    configure();
  }
  public DateFormatManager(TimeZone timeZone, Locale locale, String pattern) {
    super();
    _timeZone = timeZone;
    _locale = locale;
    _pattern = pattern;
    configure();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public synchronized TimeZone getTimeZone() {
    if (_timeZone == null) {
      return TimeZone.getDefault();
    } else {
      return _timeZone;
    }
  }
  public synchronized void setTimeZone(TimeZone timeZone) {
    timeZone = timeZone;
    configure();
  }
  public synchronized Locale getLocale() {
    if (_locale == null) {
      return Locale.getDefault();
    } else {
      return _locale;
    }
  }
  public synchronized void setLocale(Locale locale) {
    _locale = locale;
    configure();
  }
  public synchronized String getPattern() {
    return _pattern;
  }
  /**
   * Set the pattern. i.e. ""EEEEE, MMMMM d, yyyy hh:mm aaa""
   */
  public synchronized void setPattern(String pattern) {
    _pattern = pattern;
    configure();
  }
  /**
   * This method has been deprecated in favour of getPattern().
   * @deprecated Use getPattern().
   */
  public synchronized String getOutputFormat() {
    return _pattern;
  }
  /**
   * This method has been deprecated in favour of setPattern().
   * @deprecated Use setPattern().
   */
  public synchronized void setOutputFormat(String pattern) {
    _pattern = pattern;
    configure();
  }
  public synchronized DateFormat getDateFormatInstance() {
    return _dateFormat;
  }
  public synchronized void setDateFormatInstance(DateFormat dateFormat) {
    _dateFormat = dateFormat;
    // No reconfiguration necessary!
  }
  public String format(Date date) {
    return getDateFormatInstance().format(date);
  }
  public String format(Date date, String pattern) {
    DateFormat formatter = null;
    formatter = getDateFormatInstance();
    if (formatter instanceof SimpleDateFormat) {
      formatter = (SimpleDateFormat) (formatter.clone());
      ((SimpleDateFormat) formatter).applyPattern(pattern);
    }
    return formatter.format(date);
  }
  /**
   * @throws java.text.ParseException
   */
  public Date parse(String date) throws ParseException {
    return getDateFormatInstance().parse(date);
  }
  /**
   * @throws java.text.ParseException
   */
  public Date parse(String date, String pattern) throws ParseException {
    DateFormat formatter = null;
    formatter = getDateFormatInstance();
    if (formatter instanceof SimpleDateFormat) {
      formatter = (SimpleDateFormat) (formatter.clone());
      ((SimpleDateFormat) formatter).applyPattern(pattern);
    }
    return formatter.parse(date);
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  private synchronized void configure() {
    _dateFormat = SimpleDateFormat.getDateTimeInstance(DateFormat.FULL,
        DateFormat.FULL,
        getLocale());
    _dateFormat.setTimeZone(getTimeZone());
    if (_pattern != null) {
      ((SimpleDateFormat) _dateFormat).applyPattern(_pattern);
    }
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.LogFileParser,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import org.apache.log4j.lf5.Log4JLogRecord;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogLevelFormatException;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.lf5.viewer.LogFactor5ErrorDialog;
import org.apache.log4j.lf5.viewer.LogFactor5LoadingDialog;
import javax.swing.*;
import java.io.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/**
 * Provides utility methods for input and output streams.
 *
 * @author Brad Marlborough
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class LogFileParser implements Runnable {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  public static final String RECORD_DELIMITER = ""[slf5s.start]"";
  public static final String ATTRIBUTE_DELIMITER = ""[slf5s."";
  public static final String DATE_DELIMITER = ATTRIBUTE_DELIMITER + ""DATE]"";
  public static final String THREAD_DELIMITER = ATTRIBUTE_DELIMITER + ""THREAD]"";
  public static final String CATEGORY_DELIMITER = ATTRIBUTE_DELIMITER + ""CATEGORY]"";
  public static final String LOCATION_DELIMITER = ATTRIBUTE_DELIMITER + ""LOCATION]"";
  public static final String MESSAGE_DELIMITER = ATTRIBUTE_DELIMITER + ""MESSAGE]"";
  public static final String PRIORITY_DELIMITER = ATTRIBUTE_DELIMITER + ""PRIORITY]"";
  public static final String NDC_DELIMITER = ATTRIBUTE_DELIMITER + ""NDC]"";
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private static SimpleDateFormat _sdf = new SimpleDateFormat(""dd MMM yyyy HH:mm:ss,S"");
  private LogBrokerMonitor _monitor;
  LogFactor5LoadingDialog _loadDialog;
  private InputStream _in = null;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogFileParser(File file) throws IOException,
      FileNotFoundException {
    this(new FileInputStream(file));
  }
  public LogFileParser(InputStream stream) throws IOException {
    _in = stream;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Starts a new thread to parse the log file and create a LogRecord.
   * See run().
   * @param LogBrokerMonitor
   */
  public void parse(LogBrokerMonitor monitor) throws RuntimeException {
    _monitor = monitor;
    Thread t = new Thread(this);
    t.start();
  }
  /**
   * Parses the file and creates new log records and adds the record
   * to the monitor.
   */
  public void run() {
    int index = 0;
    int counter = 0;
    LogRecord temp;
    boolean isLogFile = false;
    _loadDialog = new LogFactor5LoadingDialog(
        _monitor.getBaseFrame(), ""Loading file..."");
    try {
      String logRecords = loadLogFile(_in);
      while ((counter = logRecords.indexOf(RECORD_DELIMITER, index)) != -1) {
        temp = createLogRecord(logRecords.substring(index, counter));
        isLogFile = true;
        if (temp != null) {
          _monitor.addMessage(temp);
        }
        index = counter + RECORD_DELIMITER.length();
      }
      if (index < logRecords.length() && isLogFile) {
        temp = createLogRecord(logRecords.substring(index));
        if (temp != null) {
          _monitor.addMessage(temp);
        }
      }
      if (isLogFile == false) {
        throw new RuntimeException(""Invalid log file format"");
      }
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          destroyDialog();
        }
      });
    } catch (RuntimeException e) {
      destroyDialog();
      displayError(""Error - Invalid log file format.\nPlease see documentation""
          + "" on how to load log files."");
    } catch (IOException e) {
      destroyDialog();
      displayError(""Error - Unable to load log file!"");
    }
    _in = null;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void displayError(String message) {
    LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
        _monitor.getBaseFrame(), message);
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  private void destroyDialog() {
    _loadDialog.hide();
    _loadDialog.dispose();
  }
  /**
   * Loads a log file from a web server into the LogFactor5 GUI.
   */
  private String loadLogFile(InputStream stream) throws IOException {
    BufferedInputStream br = new BufferedInputStream(stream);
    int count = 0;
    int size = br.available();
    StringBuffer sb = null;
    if (size > 0) {
      sb = new StringBuffer(size);
    } else {
      sb = new StringBuffer(1024);
    }
    while ((count = br.read()) != -1) {
      sb.append((char) count);
    }
    br.close();
    br = null;
    return sb.toString();
  }
  private String parseAttribute(String name, String record) {
    int index = record.indexOf(name);
    if (index == -1) {
      return null;
    }
    return getAttribute(index, record);
  }
  private long parseDate(String record) {
    try {
      String s = parseAttribute(DATE_DELIMITER, record);
      if (s == null) {
        return 0;
      }
      Date d = _sdf.parse(s);
      return d.getTime();
    } catch (ParseException e) {
      return 0;
    }
  }
  private LogLevel parsePriority(String record) {
    String temp = parseAttribute(PRIORITY_DELIMITER, record);
    if (temp != null) {
      try {
        return LogLevel.valueOf(temp);
      } catch (LogLevelFormatException e) {
        return LogLevel.DEBUG;
      }
    }
    return LogLevel.DEBUG;
  }
  private String parseThread(String record) {
    return parseAttribute(THREAD_DELIMITER, record);
  }
  private String parseCategory(String record) {
    return parseAttribute(CATEGORY_DELIMITER, record);
  }
  private String parseLocation(String record) {
    return parseAttribute(LOCATION_DELIMITER, record);
  }
  private String parseMessage(String record) {
    return parseAttribute(MESSAGE_DELIMITER, record);
  }
  private String parseNDC(String record) {
    return parseAttribute(NDC_DELIMITER, record);
  }
  private String parseThrowable(String record) {
    return getAttribute(record.length(), record);
  }
  private LogRecord createLogRecord(String record) {
    if (record == null || record.trim().length() == 0) {
      return null;
    }
    LogRecord lr = new Log4JLogRecord();
    lr.setMillis(parseDate(record));
    lr.setLevel(parsePriority(record));
    lr.setCategory(parseCategory(record));
    lr.setLocation(parseLocation(record));
    lr.setThreadDescription(parseThread(record));
    lr.setNDC(parseNDC(record));
    lr.setMessage(parseMessage(record));
    lr.setThrownStackTrace(parseThrowable(record));
    return lr;
  }
  private String getAttribute(int index, String record) {
    int start = record.lastIndexOf(ATTRIBUTE_DELIMITER, index - 1);
    if (start == -1) {
      return record.substring(0, index);
    }
    start = record.indexOf(""]"", start);
    return record.substring(start + 1, index).trim();
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.LogMonitorAdapter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
/**
 * <p>LogMonitorAdapter facilitates the usage of the LogMonitor</p>
 *
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class LogMonitorAdapter {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  public static final int LOG4J_LOG_LEVELS = 0;
  public static final int JDK14_LOG_LEVELS = 1;
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private LogBrokerMonitor _logMonitor;
  private LogLevel _defaultLevel = null;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  private LogMonitorAdapter(List userDefinedLevels) {
    super();
    // set the default level to be the first entry in the list
    _defaultLevel = (LogLevel) userDefinedLevels.get(0);
    _logMonitor = new LogBrokerMonitor(userDefinedLevels);
    _logMonitor.setFrameSize(getDefaultMonitorWidth(),
        getDefaultMonitorHeight());
    _logMonitor.setFontSize(12);
    _logMonitor.show();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * <p>Creates an instance of LogMonitorAdapter using the
   * log levels inticated by the parameter. Log4J and JDK1.4 both have default
   * LogLevels which are set but these levels can be overriden.<p>
   *
   * @param loglevels An integer representing either Log4J or JDK1.4 logging levels
   * @return LogMonitorAdapter
   */
  public static LogMonitorAdapter newInstance(int loglevels) {
    LogMonitorAdapter adapter;
    if (loglevels == JDK14_LOG_LEVELS) {
      adapter = newInstance(LogLevel.getJdk14Levels());
      adapter.setDefaultLevel(LogLevel.FINEST);
      adapter.setSevereLevel(LogLevel.SEVERE);
    } else {
      adapter = newInstance(LogLevel.getLog4JLevels());
      adapter.setDefaultLevel(LogLevel.DEBUG);
      adapter.setSevereLevel(LogLevel.FATAL);
    }
    return adapter;
  }
  /**
   * <p>Creates an instance of LogMonitorAdapter using the specified LogLevels.
   * The first LogLevel in the array is used as the default LogLevel unless
   * changed using the setDefaultLevel method.<p>
   *
   * @param userDefined An array of user defined LogLevel objects.
   * @return LogMonitorAdapter
   */
  public static LogMonitorAdapter newInstance(LogLevel[] userDefined) {
    if (userDefined == null) {
      return null;
    }
    return newInstance(Arrays.asList(userDefined));
  }
  /**
   * <p>Creates an instance of LogMonitorAdapter using the specified LogLevels.
   * The first LogLevel in the List is used as the default LogLevel unless
   * changed using the setDefaultLevel method.<p>
   *
   * @param userDefined A list of user defined LogLevel objects.
   * @return LogMonitorAdapter
   */
  public static LogMonitorAdapter newInstance(List userDefinedLevels) {
    return new LogMonitorAdapter(userDefinedLevels);
  }
  /**
   * <p>Adds a LogRecord to the LogMonitor.<p>
   *
   * @param record The LogRecord object to be logged in the logging monitor.
   */
  public void addMessage(LogRecord record) {
    _logMonitor.addMessage(record);
  }
  /**
   * <p>Set the maximum number of records to be displayed in the monitor<p>
   *
   * @param maxNumberOfRecords
   */
  public void setMaxNumberOfRecords(int maxNumberOfRecords) {
    _logMonitor.setMaxNumberOfLogRecords(maxNumberOfRecords);
  }
  /**
   * <p>Set the default log level to be used when logging messages without
   * specifying a LogLevel.<p>
   *
   * @param level
   */
  public void setDefaultLevel(LogLevel level) {
    _defaultLevel = level;
  }
  /**
   * <p>Gets the default LogLevel for the Adapter.<p>
   *
   * @return LogLevel
   */
  public LogLevel getDefaultLevel() {
    return _defaultLevel;
  }
  /**
   * <p>Sets the Severe LogLevel.</p>
   *
   * @param level
   */
  public void setSevereLevel(LogLevel level) {
    AdapterLogRecord.setSevereLevel(level);
  }
  /**
   * <p>Gets the current Severe LogLevel <p>
   *
   * @return LogLevel
   */
  public LogLevel getSevereLevel() {
    return AdapterLogRecord.getSevereLevel();
  }
  /**
   * <p>Log a complete message to the Monitor.<p>
   *
   * @param category The category to be used
   * @param level The log level to apply to the message
   * @param message The message
   * @param t The throwable content of the message
   * @param NDC The NDC really only applies to Log4J and the parameter can
   *            usually be ignored.
   */
  public void log(String category, LogLevel level, String message,
      Throwable t, String NDC) {
    AdapterLogRecord record = new AdapterLogRecord();
    record.setCategory(category);
    record.setMessage(message);
    record.setNDC(NDC);
    record.setThrown(t);
    if (level == null) {
      record.setLevel(getDefaultLevel());
    } else {
      record.setLevel(level);
    }
    addMessage(record);
  }
  /**
   * <p>Log a message to the Monitor and use the default LogLevel.<p>
   *
   * @param category The category to be used
   * @param message The message
   */
  public void log(String category, String message) {
    log(category, null, message);
  }
  /**
   * <p>Log a message to the Monitor.<p>
   *
   * @param category The category to be used
   * @param level The log level to apply to the message
   * @param message The message
   * @param NDC
   */
  public void log(String category, LogLevel level, String message, String NDC) {
    log(category, level, message, null, NDC);
  }
  /**
   * <p>Log a message to the Monitor.<p>
   *
   * @param category The category to be used
   * @param level The log level to apply to the message
   * @param message The message
   * @param t The throwable content of the message
   */
  public void log(String category, LogLevel level, String message,
      Throwable t) {
    log(category, level, message, t, null);
  }
  /**
   * <p>Log a message to the Monitor.<p>
   *
   * @param category The category to be used
   * @param level The log level to apply to the message
   * @param message The message
   */
  public void log(String category, LogLevel level, String message) {
    log(category, level, message, null, null);
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  /**
   * @return the screen width from Toolkit.getScreenSize()
   * if possible, otherwise returns 800
   * @see java.awt.Toolkit
   */
  protected static int getScreenWidth() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().width;
    } catch (Throwable t) {
      return 800;
    }
  }
  /**
   * @return the screen height from Toolkit.getScreenSize()
   * if possible, otherwise returns 600
   * @see java.awt.Toolkit
   */
  protected static int getScreenHeight() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().height;
    } catch (Throwable t) {
      return 600;
    }
  }
  protected static int getDefaultMonitorWidth() {
    return (3 * getScreenWidth()) / 4;
  }
  protected static int getDefaultMonitorHeight() {
    return (3 * getScreenHeight()) / 4;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.ProductProperties,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
/**
 * ProductProperties holds the properties dealing with
 * this product.  There is never a need
 * for multiple instances of this class, thus this class
 * is a singleton.
 *
 * The properties file format is as follows:
 *
 *  #Any arbitrary comments are denoted with a #
 *
 *  #Mandatory properties
 *  product.name=<Product name>
 *  product.version.number=<Product version number>
 *  product.release.date=<Product release date>
 *  product.release.type=<Product release type>
 *
 *
 * Note that this class will throw an ExceptionInInitializerError if
 * initialization fails, or if the required properties are absent.
 *
 * @author Robert Shaw
 * @author Michael J. Sikorsky
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class ProductProperties {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  /** Collection of properties. */
  protected Properties _productProperties;
  //protected final boolean _validFlag;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private static ProductProperties _reference = null;
  private static Object _synchronizingObject = new Object();
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Construct an ProductProperties with the mandatory properties.
   * Use the constructor that configures a ProductProperties
   * off of a properties file if you wish to take advantage
   * of additional properties.
   *
   */
  private ProductProperties() {
    this(new Resource(""org/apache/log4j/lf5/lf5.properties""));
  }
  private ProductProperties(Resource resource) {
    super();
    _productProperties = new Properties();
    try {
      InputStream source = getSource(resource);
      byte[] contents = StreamUtils.getBytes(source);
      _productProperties = getProperties(contents);
      source.close();
      validateProductProperties();
    } catch (Exception e) {
      String error = e.getMessage();
      throw new ExceptionInInitializerError(error);
    }
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public static ProductProperties getInstance() {
    if (_reference == null) {
      synchronized (_synchronizingObject) {
        if (_reference == null) {
          _reference = new ProductProperties();
        }
      }
    }
    return _reference;
  }
  /**
   * Mandatory internally recognized property.
   */
  public static String getPropertyNameOfProductName() {
    return ""product.name"";
  }
  /**
   * Mandatory internally recognized property.
   */
  public static String getPropertyNameOfProductVersionNumber() {
    return ""product.version.number"";
  }
  /**
   * Mandatory internally recognized property.
   */
  public static String getPropertyNameOfProductReleaseDate() {
    return ""product.release.date"";
  }
  /**
   * Get the product name.
   */
  public String getProductName() {
    return _productProperties.getProperty(getPropertyNameOfProductName());
  }
  /**
   * Set the product name.
   */
  public void setProductName(String productName) {
    _productProperties.setProperty(getPropertyNameOfProductName(),
        productName);
  }
  /**
   * Get the product version number.
   */
  public String getProductVersionNumber() {
    return
        _productProperties.getProperty(getPropertyNameOfProductVersionNumber());
  }
  /**
   * Set the product version number.
   */
  public void setProductVersionNumber(String productVersionNumber) {
    _productProperties.setProperty(getPropertyNameOfProductVersionNumber(),
        productVersionNumber);
  }
  /**
   * Get the product release date.
   */
  public String getProductReleaseDate() {
    return
        _productProperties.getProperty(getPropertyNameOfProductReleaseDate());
  }
  /**
   * Set the product release date.
   */
  public void setProductReleaseDate(String productReleaseDate) {
    _productProperties.setProperty(getPropertyNameOfProductReleaseDate(),
        productReleaseDate);
  }
  /**
   * Retrieve any of the mandatory properties, or any additional
   * properties that were placed in the database configuration file.
   */
  public String get(String name) {
    return _productProperties.getProperty(name);
  }
  /**
   * Set any property.
   */
  public Object set(String name, String value) {
    return _productProperties.setProperty(name, value);
  }
  public String getLogFactor5() {
    return getString(""lf5"");
  }
  public String getString(String propertyName) {
    return String.valueOf(get(propertyName));
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  /**
   * @throws java.lang.Exception
   */
  protected void validateProductProperties() throws Exception {
    String value = null;
    value = getProductVersionNumber();
    if ((value == null) || value.equals("""")) {
      throw new Exception(""Product version number is null."");
    }
    value = getProductReleaseDate();
    if ((value == null) || value.equals("""")) {
      throw new Exception(""Product release date is null."");
    }
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  private InputStream getSource(Resource resource) {
    return new BufferedInputStream(
        ResourceUtils.getResourceAsStream(this, resource));
  }
  private Properties getProperties(byte[] contents) throws IOException {
    ByteArrayInputStream source = new ByteArrayInputStream(contents);
    Properties result = new Properties();
    result.load(source);
    source.close();
    return result;
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.Resource,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
/**
 * Resource encapsulates access to Resources via the Classloader.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class Resource {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected String _name;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Default, no argument constructor.
   */
  public Resource() {
    super();
  }
  /**
   * Construct a Resource given a name.
   *
   * @see #setName(String)
   */
  public Resource(String name) {
    _name = name;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Set the name of the resource.
   * <p>
   * A resource is some data (images, audio, text, etc) that can be accessed
   * by class code in a way that is independent of the location of the code.
   * </p>
   * <p>
   * The name of a resource is a ""/""-separated path name that identifies
   * the resource.
   * </p>
   *
   * @see #getName()
   */
  public void setName(String name) {
    _name = name;
  }
  /**
   * Get the name of the resource.  Set setName() for a description of
   * a resource.
   *
   * @see #setName
   */
  public String getName() {
    return (_name);
  }
  /**
   * Get the InputStream for this Resource.  Uses the classloader
   * from this Resource.
   *
   * @see #getInputStreamReader
   * @see ResourceUtils
   */
  public InputStream getInputStream() {
    InputStream in = ResourceUtils.getResourceAsStream(this, this);
    return (in);
  }
  /**
   * Get the InputStreamReader for this Resource. Uses the classloader from
   * this Resource.
   *
   * @see #getInputStream
   * @see ResourceUtils
   */
  public InputStreamReader getInputStreamReader() {
    InputStream in = ResourceUtils.getResourceAsStream(this, this);
    if (in == null) {
      return null;
    }
    InputStreamReader reader = new InputStreamReader(in);
    return reader;
  }
  /**
   * Get the URL of the Resource.  Uses the classloader from this Resource.
   *
   * @see ResourceUtils
   */
  public URL getURL() {
    return (ResourceUtils.getResourceAsURL(this, this));
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.ResourceUtils,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import java.io.InputStream;
import java.net.URL;
/**
 * ResourceUtils.  Provide a set of convenience methods for working with
 * Resources.
 *
 * @see org.apache.log4j.lf5.util.Resource
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class ResourceUtils {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Get the InputStream for this resource.  Note: to convert an InputStream
   * into an InputReader, use: new InputStreamReader(InputStream).
   *
   * @param object   The object to grab the Classloader from.
   *                 This parameter is quite important from a
   *                 visibility of resources standpoint as the
   *                 hierarchy of Classloaders plays a role.
   *
   * @param resource The resource to load.
   *
   * @return If the Resource was found, the InputStream, otherwise null.
   *
   * @see Resource
   * @see #getResourceAsURL(Object,Resource)
   * @see InputStream
   */
  public static InputStream getResourceAsStream(Object object, Resource resource) {
    ClassLoader loader = object.getClass().getClassLoader();
    InputStream in = null;
    if (loader != null) {
      in = loader.getResourceAsStream(resource.getName());
    } else {
      in = ClassLoader.getSystemResourceAsStream(resource.getName());
    }
    return in;
  }
  /**
   * Get the URL for this resource.
   *
   * @param object   The object to grab the Classloader from.
   *                 This parameter is quite important from a
   *                 visibility of resources standpoint as the
   *                 hierarchy of Classloaders plays a role.
   *
   * @param resource The resource to load.
   *
   * @return If the Resource was found, the URL, otherwise null.
   *
   * @see Resource
   * @see #getResourceAsStream(Object,Resource)
   */
  public static URL getResourceAsURL(Object object, Resource resource) {
    ClassLoader loader = object.getClass().getClassLoader();
    URL url = null;
    if (loader != null) {
      url = loader.getResource(resource.getName());
    } else {
      url = ClassLoader.getSystemResource(resource.getName());
    }
    return (url);
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.util.StreamUtils,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.util;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
/**
 * Provides utility methods for input and output streams.
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public abstract class StreamUtils {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  /**
   * Default value is 2048.
   */
  public static final int DEFAULT_BUFFER_SIZE = 2048;
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Copies information from the input stream to the output stream using
   * a default buffer size of 2048 bytes.
   * @throws java.io.IOException
   */
  public static void copy(InputStream input, OutputStream output)
      throws IOException {
    copy(input, output, DEFAULT_BUFFER_SIZE);
  }
  /**
   * Copies information from the input stream to the output stream using
   * the specified buffer size
   * @throws java.io.IOException
   */
  public static void copy(InputStream input,
      OutputStream output,
      int bufferSize)
      throws IOException {
    byte[] buf = new byte[bufferSize];
    int bytesRead = input.read(buf);
    while (bytesRead != -1) {
      output.write(buf, 0, bytesRead);
      bytesRead = input.read(buf);
    }
    output.flush();
  }
  /**
   * Copies information between specified streams and then closes
   * both of the streams.
   * @throws java.io.IOException
   */
  public static void copyThenClose(InputStream input, OutputStream output)
      throws IOException {
    copy(input, output);
    input.close();
    output.close();
  }
  /**
   * @returns a byte[] containing the information contained in the
   * specified InputStream.
   * @throws java.io.IOException
   */
  public static byte[] getBytes(InputStream input)
      throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    copy(input, result);
    result.close();
    return result.toByteArray();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.FilteredLogTableModel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;
import org.apache.log4j.lf5.PassingLogRecordFilter;
import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
/**
 * A TableModel for LogRecords which includes filtering support.
 *
 * @author Richard Wan
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class FilteredLogTableModel
    extends AbstractTableModel {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected LogRecordFilter _filter = new PassingLogRecordFilter();
  protected List _allRecords = new ArrayList();
  protected List _filteredRecords;
  protected int _maxNumberOfLogRecords = 5000;
  protected String[] _colNames = {""Date"",
                                  ""Thread"",
                                  ""Message #"",
                                  ""Level"",
                                  ""NDC"",
                                  ""Category"",
                                  ""Message"",
                                  ""Location"",
                                  ""Thrown""};
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public FilteredLogTableModel() {
    super();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void setLogRecordFilter(LogRecordFilter filter) {
    _filter = filter;
  }
  public LogRecordFilter getLogRecordFilter() {
    return _filter;
  }
  public String getColumnName(int i) {
    return _colNames[i];
  }
  public int getColumnCount() {
    return _colNames.length;
  }
  public int getRowCount() {
    return getFilteredRecords().size();
  }
  public int getTotalRowCount() {
    return _allRecords.size();
  }
  public Object getValueAt(int row, int col) {
    LogRecord record = getFilteredRecord(row);
    return getColumn(col, record);
  }
  public void setMaxNumberOfLogRecords(int maxNumRecords) {
    if (maxNumRecords > 0) {
      _maxNumberOfLogRecords = maxNumRecords;
    }
  }
  public synchronized boolean addLogRecord(LogRecord record) {
    _allRecords.add(record);
    if (_filter.passes(record) == false) {
      return false;
    }
    getFilteredRecords().add(record);
    fireTableRowsInserted(getRowCount(), getRowCount());
    trimRecords();
    return true;
  }
  /**
   * Forces the LogTableModel to requery its filters to determine
   * which records to display.
   */
  public synchronized void refresh() {
    _filteredRecords = createFilteredRecordsList();
    fireTableDataChanged();
  }
  public synchronized void fastRefresh() {
    _filteredRecords.remove(0);
    fireTableRowsDeleted(0, 0);
  }
  /**
   * Clears all records from the LogTableModel
   */
  public synchronized void clear() {
    _allRecords.clear();
    _filteredRecords.clear();
    fireTableDataChanged();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected List getFilteredRecords() {
    if (_filteredRecords == null) {
      refresh();
    }
    return _filteredRecords;
  }
  protected List createFilteredRecordsList() {
    List result = new ArrayList();
    Iterator records = _allRecords.iterator();
    LogRecord current;
    while (records.hasNext()) {
      current = (LogRecord) records.next();
      if (_filter.passes(current)) {
        result.add(current);
      }
    }
    return result;
  }
  protected LogRecord getFilteredRecord(int row) {
    List records = getFilteredRecords();
    int size = records.size();
    if (row < size) {
      return (LogRecord) records.get(row);
    }
    // a minor problem has happened. JTable has asked for
    // a row outside the bounds, because the size of
    // _filteredRecords has changed while it was looping.
    // return the last row.
    return (LogRecord) records.get(size - 1);
  }
  protected Object getColumn(int col, LogRecord lr) {
    if (lr == null) {
      return ""NULL Column"";
    }
    String date = new Date(lr.getMillis()).toString();
    switch (col) {
      case 0:
        return date + "" ("" + lr.getMillis() + "")"";
      case 1:
        return lr.getThreadDescription();
      case 2:
        return new Long(lr.getSequenceNumber());
      case 3:
        return lr.getLevel();
      case 4:
        return lr.getNDC();
      case 5:
        return lr.getCategory();
      case 6:
        return lr.getMessage();
      case 7:
        return lr.getLocation();
      case 8:
        return lr.getThrownStackTrace();
      default:
        String message = ""The column number "" + col + ""must be between 0 and 8"";
        throw new IllegalArgumentException(message);
    }
  }
  // We don't want the amount of rows to grow without bound,
  // leading to a out-of-memory-exception.  Especially not good
  // in a production environment :)
  // This method & clearLogRecords() are synchronized so we don't
  // delete rows that don't exist.
  protected void trimRecords() {
    if (needsTrimming()) {
      trimOldestRecords();
    }
  }
  protected boolean needsTrimming() {
    return (_allRecords.size() > _maxNumberOfLogRecords);
  }
  protected void trimOldestRecords() {
    synchronized (_allRecords) {
      int trim = numberOfRecordsToTrim();
      if (trim > 1) {
        List oldRecords =
            _allRecords.subList(0, trim);
        oldRecords.clear();
        refresh();
      } else {
        _allRecords.remove(0);
        fastRefresh();
      }
    }
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  private int numberOfRecordsToTrim() {
    return _allRecords.size() - _maxNumberOfLogRecords;
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LF5SwingUtils,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.*;
import javax.swing.table.TableModel;
import java.awt.*;
/**
 * Provides methods to accomplish common yet non-trivial tasks
 * with Swing. Obvious implementations of these methods have been
 * tried and failed.
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public class LF5SwingUtils {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Selects a the specified row in the specified JTable and scrolls
   * the specified JScrollpane to the newly selected row. More importantly,
   * the call to repaint() delayed long enough to have the table
   * properly paint the newly selected row which may be offscre
   * @param table should belong to the specified JScrollPane
   */
  public static void selectRow(int row, JTable table, JScrollPane pane) {
    if (table == null || pane == null) {
      return;
    }
    if (contains(row, table.getModel()) == false) {
      return;
    }
    moveAdjustable(row * table.getRowHeight(), pane.getVerticalScrollBar());
    selectRow(row, table.getSelectionModel());
    // repaint must be done later because moveAdjustable
    // posts requests to the swing thread which must execute before
    // the repaint logic gets executed.
    repaintLater(table);
  }
  /**
   * Makes the specified Adjustable track if the view area expands and
   * the specified Adjustable is located near the of the view.
   */
  public static void makeScrollBarTrack(Adjustable scrollBar) {
    if (scrollBar == null) {
      return;
    }
    scrollBar.addAdjustmentListener(new TrackingAdjustmentListener());
  }
  /**
   * Makes the vertical scroll bar of the specified JScrollPane
   * track if the view expands (e.g. if rows are added to an underlying
   * table).
   */
  public static void makeVerticalScrollBarTrack(JScrollPane pane) {
    if (pane == null) {
      return;
    }
    makeScrollBarTrack(pane.getVerticalScrollBar());
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected static boolean contains(int row, TableModel model) {
    if (model == null) {
      return false;
    }
    if (row < 0) {
      return false;
    }
    if (row >= model.getRowCount()) {
      return false;
    }
    return true;
  }
  protected static void selectRow(int row, ListSelectionModel model) {
    if (model == null) {
      return;
    }
    model.setSelectionInterval(row, row);
  }
  protected static void moveAdjustable(int location, Adjustable scrollBar) {
    if (scrollBar == null) {
      return;
    }
    scrollBar.setValue(location);
  }
  /**
   * Work around for JTable/viewport bug.
   * @link http://developer.java.sun.com/developer/bugParade/bugs/4205145.html
   */
  protected static void repaintLater(final JComponent component) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        component.repaint();
      }
    });
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LogBrokerMonitor,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;
import org.apache.log4j.lf5.util.DateFormatManager;
import org.apache.log4j.lf5.util.LogFileParser;
import org.apache.log4j.lf5.util.ProductProperties;
import org.apache.log4j.lf5.util.StreamUtils;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;
import org.apache.log4j.lf5.viewer.configure.ConfigurationManager;
import org.apache.log4j.lf5.viewer.configure.MRUFileManager;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.util.List;
/**
 * LogBrokerMonitor
 *.
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brad Marlborough
 * @author Richard Wan
 * @author Brent Sprecher
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class LogBrokerMonitor {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  public static final String DETAILED_VIEW = ""Detailed"";
//    public static final String STANDARD_VIEW = ""Standard"";
//    public static final String COMPACT_VIEW = ""Compact"";
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected JFrame _logMonitorFrame;
  protected int _logMonitorFrameWidth = 550;
  protected int _logMonitorFrameHeight = 500;
  protected LogTable _table;
  protected CategoryExplorerTree _categoryExplorerTree;
  protected String _searchText;
  protected String _NDCTextFilter = """";
  protected LogLevel _leastSevereDisplayedLogLevel = LogLevel.DEBUG;
  protected JScrollPane _logTableScrollPane;
  protected JLabel _statusLabel;
  protected Object _lock = new Object();
  protected JComboBox _fontSizeCombo;
  protected int _fontSize = 10;
  protected String _fontName = ""Dialog"";
  protected String _currentView = DETAILED_VIEW;
  protected boolean _loadSystemFonts = false;
  protected boolean _trackTableScrollPane = true;
  protected Dimension _lastTableViewportSize;
  protected boolean _callSystemExitOnClose = false;
  protected List _displayedLogBrokerProperties = new Vector();
  protected Map _logLevelMenuItems = new HashMap();
  protected Map _logTableColumnMenuItems = new HashMap();
  protected List _levels = null;
  protected List _columns = null;
  protected boolean _isDisposed = false;
  protected ConfigurationManager _configurationManager = null;
  protected MRUFileManager _mruFileManager = null;
  protected File _fileLocation = null;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Construct a LogBrokerMonitor.
   */
  public LogBrokerMonitor(List logLevels) {
    _levels = logLevels;
    _columns = LogTableColumn.getLogTableColumns();
    // This allows us to use the LogBroker in command line tools and
    // have the option for it to shutdown.
    String callSystemExitOnClose =
        System.getProperty(""monitor.exit"");
    if (callSystemExitOnClose == null) {
      callSystemExitOnClose = ""false"";
    }
    callSystemExitOnClose = callSystemExitOnClose.trim().toLowerCase();
    if (callSystemExitOnClose.equals(""true"")) {
      _callSystemExitOnClose = true;
    }
    initComponents();
    _logMonitorFrame.addWindowListener(
        new LogBrokerMonitorWindowAdaptor(this));
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Show the frame for the LogBrokerMonitor. Dispatched to the
   * swing thread.
   */
  public void show(final int delay) {
    if (_logMonitorFrame.isVisible()) {
      return;
    }
    // This request is very low priority, let other threads execute first.
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        Thread.yield();
        pause(delay);
        _logMonitorFrame.setVisible(true);
      }
    });
  }
  public void show() {
    show(0);
  }
  /**
   * Dispose of the frame for the LogBrokerMonitor.
   */
  public void dispose() {
    _logMonitorFrame.dispose();
    _isDisposed = true;
    if (_callSystemExitOnClose == true) {
      System.exit(0);
    }
  }
  /**
   * Hide the frame for the LogBrokerMonitor.
   */
  public void hide() {
    _logMonitorFrame.setVisible(false);
  }
  /**
   * Get the DateFormatManager for formatting dates.
   */
  public DateFormatManager getDateFormatManager() {
    return _table.getDateFormatManager();
  }
  /**
   * Set the date format manager for formatting dates.
   */
  public void setDateFormatManager(DateFormatManager dfm) {
    _table.setDateFormatManager(dfm);
  }
  /**
   * Get the value of whether or not System.exit() will be called
   * when the LogBrokerMonitor is closed.
   */
  public boolean getCallSystemExitOnClose() {
    return _callSystemExitOnClose;
  }
  /**
   * Set the value of whether or not System.exit() will be called
   * when the LogBrokerMonitor is closed.
   */
  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {
    _callSystemExitOnClose = callSystemExitOnClose;
  }
  /**
   * Add a log record message to be displayed in the LogTable.
   * This method is thread-safe as it posts requests to the SwingThread
   * rather than processing directly.
   */
  public void addMessage(final LogRecord lr) {
    if (_isDisposed == true) {
      // If the frame has been disposed of, do not log any more
      // messages.
      return;
    }
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        _categoryExplorerTree.getExplorerModel().addLogRecord(lr);
        _table.getFilteredLogTableModel().addLogRecord(lr); // update table
        updateStatusLabel(); // show updated counts
      }
    });
  }
  public void setMaxNumberOfLogRecords(int maxNumberOfLogRecords) {
    _table.getFilteredLogTableModel().setMaxNumberOfLogRecords(maxNumberOfLogRecords);
  }
  public JFrame getBaseFrame() {
    return _logMonitorFrame;
  }
  public void setTitle(String title) {
    _logMonitorFrame.setTitle(title + "" - LogFactor5"");
  }
  public void setFrameSize(int width, int height) {
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    if (0 < width && width < screen.width) {
      _logMonitorFrameWidth = width;
    }
    if (0 < height && height < screen.height) {
      _logMonitorFrameHeight = height;
    }
    updateFrameSize();
  }
  public void setFontSize(int fontSize) {
    changeFontSizeCombo(_fontSizeCombo, fontSize);
    // setFontSizeSilently(actualFontSize); - changeFontSizeCombo fires event
    // refreshDetailTextArea();
  }
  public void addDisplayedProperty(Object messageLine) {
    _displayedLogBrokerProperties.add(messageLine);
  }
  public Map getLogLevelMenuItems() {
    return _logLevelMenuItems;
  }
  public Map getLogTableColumnMenuItems() {
    return _logTableColumnMenuItems;
  }
  public JCheckBoxMenuItem getTableColumnMenuItem(LogTableColumn column) {
    return getLogTableColumnMenuItem(column);
  }
  public CategoryExplorerTree getCategoryExplorerTree() {
    return _categoryExplorerTree;
  }
  // Added in version 1.2 - gets the value of the NDC text filter
  // This value is set back to null each time the Monitor is initialized.
  public String getNDCTextFilter() {
    return _NDCTextFilter;
  }
  // Added in version 1.2 - sets the NDC Filter based on
  // a String passed in by the user.  This value is persisted
  // in the XML Configuration file.
  public void setNDCLogRecordFilter(String textFilter) {
    _table.getFilteredLogTableModel().
        setLogRecordFilter(createNDCLogRecordFilter(textFilter));
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void setSearchText(String text) {
    _searchText = text;
  }
  // Added in version 1.2 - Sets the text filter for the NDC
  protected void setNDCTextFilter(String text) {
    // if no value is set, set it to a blank string
    // otherwise use the value provided
    if (text == null) {
      _NDCTextFilter = """";
    } else {
      _NDCTextFilter = text;
    }
  }
  // Added in version 1.2 - Uses a different filter that sorts
  // based on an NDC string passed in by the user.  If the string
  // is null or is an empty string, we do nothing.
  protected void sortByNDC() {
    String text = _NDCTextFilter;
    if (text == null || text.length() == 0) {
      return;
    }
    // Use new NDC filter
    _table.getFilteredLogTableModel().
        setLogRecordFilter(createNDCLogRecordFilter(text));
  }
  protected void findSearchText() {
    String text = _searchText;
    if (text == null || text.length() == 0) {
      return;
    }
    int startRow = getFirstSelectedRow();
    int foundRow = findRecord(
        startRow,
        text,
        _table.getFilteredLogTableModel().getFilteredRecords()
    );
    selectRow(foundRow);
  }
  protected int getFirstSelectedRow() {
    return _table.getSelectionModel().getMinSelectionIndex();
  }
  protected void selectRow(int foundRow) {
    if (foundRow == -1) {
      String message = _searchText + "" not found."";
      JOptionPane.showMessageDialog(
          _logMonitorFrame,
          message,
          ""Text not found"",
          JOptionPane.INFORMATION_MESSAGE
      );
      return;
    }
    LF5SwingUtils.selectRow(foundRow, _table, _logTableScrollPane);
  }
  protected int findRecord(
      int startRow,
      String searchText,
      List records
      ) {
    if (startRow < 0) {
      startRow = 0; // start at first element if no rows are selected
    } else {
      startRow++; // start after the first selected row
    }
    int len = records.size();
    for (int i = startRow; i < len; i++) {
      if (matches((LogRecord) records.get(i), searchText)) {
        return i; // found a record
      }
    }
    // wrap around to beginning if when we reach the end with no match
    len = startRow;
    for (int i = 0; i < len; i++) {
      if (matches((LogRecord) records.get(i), searchText)) {
        return i; // found a record
      }
    }
    // nothing found
    return -1;
  }
  /**
   * Check to see if the any records contain the search string.
   * Searching now supports NDC messages and date.
   */
  protected boolean matches(LogRecord record, String text) {
    String message = record.getMessage();
    String NDC = record.getNDC();
    if (message == null && NDC == null || text == null) {
      return false;
    }
    if (message.toLowerCase().indexOf(text.toLowerCase()) == -1 &&
        NDC.toLowerCase().indexOf(text.toLowerCase()) == -1) {
      return false;
    }
    return true;
  }
  /**
   * When the fontsize of a JTextArea is changed, the word-wrapped lines
   * may become garbled.  This method clears and resets the text of the
   * text area.
   */
  protected void refresh(JTextArea textArea) {
    String text = textArea.getText();
    textArea.setText("""");
    textArea.setText(text);
  }
  protected void refreshDetailTextArea() {
    refresh(_table._detailTextArea);
  }
  protected void clearDetailTextArea() {
    _table._detailTextArea.setText("""");
  }
  /**
   * Changes the font selection in the combo box and returns the
   * size actually selected.
   * @return -1 if unable to select an appropriate font
   */
  protected int changeFontSizeCombo(JComboBox box, int requestedSize) {
    int len = box.getItemCount();
    int currentValue;
    Object currentObject;
    Object selectedObject = box.getItemAt(0);
    int selectedValue = Integer.parseInt(String.valueOf(selectedObject));
    for (int i = 0; i < len; i++) {
      currentObject = box.getItemAt(i);
      currentValue = Integer.parseInt(String.valueOf(currentObject));
      if (selectedValue < currentValue && currentValue <= requestedSize) {
        selectedValue = currentValue;
        selectedObject = currentObject;
      }
    }
    box.setSelectedItem(selectedObject);
    return selectedValue;
  }
  /**
   * Does not update gui or cause any events to be fired.
   */
  protected void setFontSizeSilently(int fontSize) {
    _fontSize = fontSize;
    setFontSize(_table._detailTextArea, fontSize);
    selectRow(0);
    setFontSize(_table, fontSize);
  }
  protected void setFontSize(Component component, int fontSize) {
    Font oldFont = component.getFont();
    Font newFont =
        new Font(oldFont.getFontName(), oldFont.getStyle(), fontSize);
    component.setFont(newFont);
  }
  protected void updateFrameSize() {
    _logMonitorFrame.setSize(_logMonitorFrameWidth, _logMonitorFrameHeight);
    centerFrame(_logMonitorFrame);
  }
  protected void pause(int millis) {
    try {
      Thread.sleep(millis);
    } catch (InterruptedException e) {
    }
  }
  protected void initComponents() {
    //
    // Configure the Frame.
    //
    ProductProperties props = ProductProperties.getInstance();
    _logMonitorFrame = new JFrame(""LogFactor5"");
    _logMonitorFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
    String resource =
        ""/org/apache/log4j/lf5/viewer/images/lf5_small_icon.gif"";
    URL lf5IconURL = getClass().getResource(resource);
    if (lf5IconURL != null) {
      _logMonitorFrame.setIconImage(new ImageIcon(lf5IconURL).getImage());
    }
    updateFrameSize();
    //
    // Configure the LogTable.
    //
    JTextArea detailTA = createDetailTextArea();
    JScrollPane detailTAScrollPane = new JScrollPane(detailTA);
    _table = new LogTable(detailTA);
    setView(_currentView, _table);
    _table.setFont(new Font(_fontName, Font.PLAIN, _fontSize));
    _logTableScrollPane = new JScrollPane(_table);
    if (_trackTableScrollPane) {
      _logTableScrollPane.getVerticalScrollBar().addAdjustmentListener(
          new TrackingAdjustmentListener()
      );
    }
    // Configure the SplitPane between the LogTable & DetailTextArea
    //
    JSplitPane tableViewerSplitPane = new JSplitPane();
    tableViewerSplitPane.setOneTouchExpandable(true);
    tableViewerSplitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
    tableViewerSplitPane.setLeftComponent(_logTableScrollPane);
    tableViewerSplitPane.setRightComponent(detailTAScrollPane);
    // Make sure to do this last..
    //tableViewerSplitPane.setDividerLocation(1.0); Doesn't work
    //the same under 1.2.x & 1.3
    // ""350"" is a magic number that provides the correct default
    // behaviour under 1.2.x & 1.3.  For example, bumping this
    // number to 400, causes the pane to be completely open in 1.2.x
    // and closed in 1.3
    tableViewerSplitPane.setDividerLocation(350);
    //
    // Configure the CategoryExplorer
    //
    _categoryExplorerTree = new CategoryExplorerTree();
    _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());
    JScrollPane categoryExplorerTreeScrollPane =
        new JScrollPane(_categoryExplorerTree);
    categoryExplorerTreeScrollPane.setPreferredSize(new Dimension(130, 400));
    // Load most recently used file list
    _mruFileManager = new MRUFileManager();
    //
    // Configure the SplitPane between the CategoryExplorer & (LogTable/Detail)
    //
    JSplitPane splitPane = new JSplitPane();
    splitPane.setOneTouchExpandable(true);
    splitPane.setRightComponent(tableViewerSplitPane);
    splitPane.setLeftComponent(categoryExplorerTreeScrollPane);
    // Do this last.
    splitPane.setDividerLocation(130);
    //
    // Add the MenuBar, StatusArea, CategoryExplorer|LogTable to the
    // LogMonitorFrame.
    //
    _logMonitorFrame.getRootPane().setJMenuBar(createMenuBar());
    _logMonitorFrame.getContentPane().add(splitPane, BorderLayout.CENTER);
    _logMonitorFrame.getContentPane().add(createToolBar(),
        BorderLayout.NORTH);
    _logMonitorFrame.getContentPane().add(createStatusArea(),
        BorderLayout.SOUTH);
    makeLogTableListenToCategoryExplorer();
    addTableModelProperties();
    //
    // Configure ConfigurationManager
    //
    _configurationManager = new ConfigurationManager(this, _table);
  }
  protected LogRecordFilter createLogRecordFilter() {
    LogRecordFilter result = new LogRecordFilter() {
      public boolean passes(LogRecord record) {
        CategoryPath path = new CategoryPath(record.getCategory());
        return
            getMenuItem(record.getLevel()).isSelected() &&
            _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
      }
    };
    return result;
  }
  // Added in version 1.2 - Creates a new filter that sorts records based on
  // an NDC string passed in by the user.
  protected LogRecordFilter createNDCLogRecordFilter(String text) {
    _NDCTextFilter = text;
    LogRecordFilter result = new LogRecordFilter() {
      public boolean passes(LogRecord record) {
        String NDC = record.getNDC();
        CategoryPath path = new CategoryPath(record.getCategory());
        if (NDC == null || _NDCTextFilter == null) {
          return false;
        } else if (NDC.toLowerCase().indexOf(_NDCTextFilter.toLowerCase()) == -1) {
          return false;
        } else {
          return getMenuItem(record.getLevel()).isSelected() &&
              _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
        }
      }
    };
    return result;
  }
  protected void updateStatusLabel() {
    _statusLabel.setText(getRecordsDisplayedMessage());
  }
  protected String getRecordsDisplayedMessage() {
    FilteredLogTableModel model = _table.getFilteredLogTableModel();
    return getStatusText(model.getRowCount(), model.getTotalRowCount());
  }
  protected void addTableModelProperties() {
    final FilteredLogTableModel model = _table.getFilteredLogTableModel();
    addDisplayedProperty(new Object() {
      public String toString() {
        return getRecordsDisplayedMessage();
      }
    });
    addDisplayedProperty(new Object() {
      public String toString() {
        return ""Maximum number of displayed LogRecords: ""
            + model._maxNumberOfLogRecords;
      }
    });
  }
  protected String getStatusText(int displayedRows, int totalRows) {
    StringBuffer result = new StringBuffer();
    result.append(""Displaying: "");
    result.append(displayedRows);
    result.append("" records out of a total of: "");
    result.append(totalRows);
    result.append("" records."");
    return result.toString();
  }
  protected void makeLogTableListenToCategoryExplorer() {
    ActionListener listener = new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    };
    _categoryExplorerTree.getExplorerModel().addActionListener(listener);
  }
  protected JPanel createStatusArea() {
    JPanel statusArea = new JPanel();
    JLabel status =
        new JLabel(""No log records to display."");
    _statusLabel = status;
    status.setHorizontalAlignment(JLabel.LEFT);
    statusArea.setBorder(BorderFactory.createEtchedBorder());
    statusArea.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
    statusArea.add(status);
    return (statusArea);
  }
  protected JTextArea createDetailTextArea() {
    JTextArea detailTA = new JTextArea();
    detailTA.setFont(new Font(""Monospaced"", Font.PLAIN, 14));
    detailTA.setTabSize(3);
    detailTA.setLineWrap(true);
    detailTA.setWrapStyleWord(false);
    return (detailTA);
  }
  protected JMenuBar createMenuBar() {
    JMenuBar menuBar = new JMenuBar();
    menuBar.add(createFileMenu());
    menuBar.add(createEditMenu());
    menuBar.add(createLogLevelMenu());
    menuBar.add(createViewMenu());
    menuBar.add(createConfigureMenu());
    menuBar.add(createHelpMenu());
    return (menuBar);
  }
  protected JMenu createLogLevelMenu() {
    JMenu result = new JMenu(""Log Level"");
    result.setMnemonic('l');
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      result.add(getMenuItem((LogLevel) levels.next()));
    }
    result.addSeparator();
    result.add(createAllLogLevelsMenuItem());
    result.add(createNoLogLevelsMenuItem());
    result.addSeparator();
    result.add(createLogLevelColorMenu());
    result.add(createResetLogLevelColorMenuItem());
    return result;
  }
  protected JMenuItem createAllLogLevelsMenuItem() {
    JMenuItem result = new JMenuItem(""Show all LogLevels"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogLevels(true);
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }
  protected JMenuItem createNoLogLevelsMenuItem() {
    JMenuItem result = new JMenuItem(""Hide all LogLevels"");
    result.setMnemonic('h');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogLevels(false);
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }
  protected JMenu createLogLevelColorMenu() {
    JMenu colorMenu = new JMenu(""Configure LogLevel Colors"");
    colorMenu.setMnemonic('c');
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      colorMenu.add(createSubMenuItem((LogLevel) levels.next()));
    }
    return colorMenu;
  }
  protected JMenuItem createResetLogLevelColorMenuItem() {
    JMenuItem result = new JMenuItem(""Reset LogLevel Colors"");
    result.setMnemonic('r');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        // reset the level colors in the map
        LogLevel.resetLogLevelColorMap();
        // refresh the table
        _table.getFilteredLogTableModel().refresh();
      }
    });
    return result;
  }
  protected void selectAllLogLevels(boolean selected) {
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      getMenuItem((LogLevel) levels.next()).setSelected(selected);
    }
  }
  protected JCheckBoxMenuItem getMenuItem(LogLevel level) {
    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logLevelMenuItems.get(level));
    if (result == null) {
      result = createMenuItem(level);
      _logLevelMenuItems.put(level, result);
    }
    return result;
  }
  protected JMenuItem createSubMenuItem(LogLevel level) {
    final JMenuItem result = new JMenuItem(level.toString());
    final LogLevel logLevel = level;
    result.setMnemonic(level.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showLogLevelColorChangeDialog(result, logLevel);
      }
    });
    return result;
  }
  protected void showLogLevelColorChangeDialog(JMenuItem result, LogLevel level) {
    JMenuItem menuItem = result;
    Color newColor = JColorChooser.showDialog(
        _logMonitorFrame,
        ""Choose LogLevel Color"",
        result.getForeground());
    if (newColor != null) {
      // set the color for the record
      level.setLogLevelColorMap(level, newColor);
      _table.getFilteredLogTableModel().refresh();
    }
  }
  protected JCheckBoxMenuItem createMenuItem(LogLevel level) {
    JCheckBoxMenuItem result = new JCheckBoxMenuItem(level.toString());
    result.setSelected(true);
    result.setMnemonic(level.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }
  // view menu
  protected JMenu createViewMenu() {
    JMenu result = new JMenu(""View"");
    result.setMnemonic('v');
    Iterator columns = getLogTableColumns();
    while (columns.hasNext()) {
      result.add(getLogTableColumnMenuItem((LogTableColumn) columns.next()));
    }
    result.addSeparator();
    result.add(createAllLogTableColumnsMenuItem());
    result.add(createNoLogTableColumnsMenuItem());
    return result;
  }
  protected JCheckBoxMenuItem getLogTableColumnMenuItem(LogTableColumn column) {
    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logTableColumnMenuItems.get(column));
    if (result == null) {
      result = createLogTableColumnMenuItem(column);
      _logTableColumnMenuItems.put(column, result);
    }
    return result;
  }
  protected JCheckBoxMenuItem createLogTableColumnMenuItem(LogTableColumn column) {
    JCheckBoxMenuItem result = new JCheckBoxMenuItem(column.toString());
    result.setSelected(true);
    result.setMnemonic(column.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        // update list of columns and reset the view
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }
  protected List updateView() {
    ArrayList updatedList = new ArrayList();
    Iterator columnIterator = _columns.iterator();
    while (columnIterator.hasNext()) {
      LogTableColumn column = (LogTableColumn) columnIterator.next();
      JCheckBoxMenuItem result = getLogTableColumnMenuItem(column);
      // check and see if the checkbox is checked
      if (result.isSelected()) {
        updatedList.add(column);
      }
    }
    return updatedList;
  }
  protected JMenuItem createAllLogTableColumnsMenuItem() {
    JMenuItem result = new JMenuItem(""Show all Columns"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogTableColumns(true);
        // update list of columns and reset the view
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }
  protected JMenuItem createNoLogTableColumnsMenuItem() {
    JMenuItem result = new JMenuItem(""Hide all Columns"");
    result.setMnemonic('h');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogTableColumns(false);
        // update list of columns and reset the view
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }
  protected void selectAllLogTableColumns(boolean selected) {
    Iterator columns = getLogTableColumns();
    while (columns.hasNext()) {
      getLogTableColumnMenuItem((LogTableColumn) columns.next()).setSelected(selected);
    }
  }
  protected JMenu createFileMenu() {
    JMenu fileMenu = new JMenu(""File"");
    fileMenu.setMnemonic('f');
    JMenuItem exitMI;
    fileMenu.add(createOpenMI());
    fileMenu.add(createOpenURLMI());
    fileMenu.addSeparator();
    fileMenu.add(createCloseMI());
    createMRUFileListMI(fileMenu);
    fileMenu.addSeparator();
    fileMenu.add(createExitMI());
    return fileMenu;
  }
  /**
   * Menu item added to allow log files to be opened with
   * the LF5 GUI.
   */
  protected JMenuItem createOpenMI() {
    JMenuItem result = new JMenuItem(""Open..."");
    result.setMnemonic('o');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestOpen();
      }
    });
    return result;
  }
  /**
   * Menu item added to allow log files loaded from a URL
   * to be opened by the LF5 GUI.
   */
  protected JMenuItem createOpenURLMI() {
    JMenuItem result = new JMenuItem(""Open URL..."");
    result.setMnemonic('u');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestOpenURL();
      }
    });
    return result;
  }
  protected JMenuItem createCloseMI() {
    JMenuItem result = new JMenuItem(""Close"");
    result.setMnemonic('c');
    result.setAccelerator(KeyStroke.getKeyStroke(""control Q""));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestClose();
      }
    });
    return result;
  }
  /**
   * Creates a Most Recently Used file list to be
   * displayed in the File menu
   */
  protected void createMRUFileListMI(JMenu menu) {
    String[] files = _mruFileManager.getMRUFileList();
    if (files != null) {
      menu.addSeparator();
      for (int i = 0; i < files.length; i++) {
        JMenuItem result = new JMenuItem((i + 1) + "" "" + files[i]);
        result.setMnemonic(i + 1);
        result.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            requestOpenMRU(e);
          }
        });
        menu.add(result);
      }
    }
  }
  protected JMenuItem createExitMI() {
    JMenuItem result = new JMenuItem(""Exit"");
    result.setMnemonic('x');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestExit();
      }
    });
    return result;
  }
  protected JMenu createConfigureMenu() {
    JMenu configureMenu = new JMenu(""Configure"");
    configureMenu.setMnemonic('c');
    configureMenu.add(createConfigureSave());
    configureMenu.add(createConfigureReset());
    configureMenu.add(createConfigureMaxRecords());
    return configureMenu;
  }
  protected JMenuItem createConfigureSave() {
    JMenuItem result = new JMenuItem(""Save"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        saveConfiguration();
      }
    });
    return result;
  }
  protected JMenuItem createConfigureReset() {
    JMenuItem result = new JMenuItem(""Reset"");
    result.setMnemonic('r');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        resetConfiguration();
      }
    });
    return result;
  }
  protected JMenuItem createConfigureMaxRecords() {
    JMenuItem result = new JMenuItem(""Set Max Number of Records"");
    result.setMnemonic('m');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        setMaxRecordConfiguration();
      }
    });
    return result;
  }
  protected void saveConfiguration() {
    _configurationManager.save();
  }
  protected void resetConfiguration() {
    _configurationManager.reset();
  }
  protected void setMaxRecordConfiguration() {
    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(
        getBaseFrame(), ""Set Max Number of Records"", """", 10);
    String temp = inputDialog.getText();
    if (temp != null) {
      try {
        setMaxNumberOfLogRecords(Integer.parseInt(temp));
      } catch (NumberFormatException e) {
        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
            getBaseFrame(),
            ""'"" + temp + ""' is an invalid parameter.\nPlease try again."");
        setMaxRecordConfiguration();
      }
    }
  }
  protected JMenu createHelpMenu() {
    JMenu helpMenu = new JMenu(""Help"");
    helpMenu.setMnemonic('h');
    helpMenu.add(createHelpProperties());
    helpMenu.addSeparator();
    helpMenu.add(createHelpAbout());
    return helpMenu;
  }
  protected JMenuItem createHelpProperties() {
    final String title = ""LogFactor5 Properties"";
    final JMenuItem result = new JMenuItem(title);
    result.setMnemonic('l');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showPropertiesDialog(title);
      }
    });
    return result;
  }
  protected void showPropertiesDialog(String title) {
    JOptionPane.showMessageDialog(
        _logMonitorFrame,
        _displayedLogBrokerProperties.toArray(),
        title,
        JOptionPane.PLAIN_MESSAGE
    );
  }
  protected JMenuItem createHelpAbout() {
    JMenuItem aboutMI = new JMenuItem(""About LogFactor5..."");
    aboutMI.setMnemonic('a');
    //aboutMI.setAccelerator( KeyStroke.getKeyStroke(""control A"") );
    aboutMI.addActionListener(
        new ActionListener() {
          protected LogFactor5AboutDialog dialog =
              new LogFactor5AboutDialog(_logMonitorFrame);
          public void actionPerformed(ActionEvent e) {
            dialog.show();
          }
        }
    );
    return aboutMI;
  }
  protected JMenu createEditMenu() {
    JMenu editMenu = new JMenu(""Edit"");
    editMenu.setMnemonic('e');
    editMenu.add(createEditFindMI());
    editMenu.add(createEditFindNextMI());
    editMenu.addSeparator();
    editMenu.add(createEditSortNDCMI());
    editMenu.add(createEditRestoreAllNDCMI());
    return editMenu;
  }
  protected JMenuItem createEditFindNextMI() {
    JMenuItem editFindNextMI = new JMenuItem(""Find Next"");
    editFindNextMI.setMnemonic('n');
    editFindNextMI.setAccelerator(KeyStroke.getKeyStroke(""F3""));
    editFindNextMI.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        findSearchText();
      }
    });
    return editFindNextMI;
  }
  protected JMenuItem createEditFindMI() {
    JMenuItem editFindMI = new JMenuItem(""Find"");
    editFindMI.setMnemonic('f');
    editFindMI.setAccelerator(KeyStroke.getKeyStroke(""control F""));
    editFindMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            String inputValue =
                JOptionPane.showInputDialog(
                    _logMonitorFrame,
                    ""Find text: "",
                    ""Search Record Messages"",
                    JOptionPane.QUESTION_MESSAGE
                );
            setSearchText(inputValue);
            findSearchText();
          }
        }
    );
    return editFindMI;
  }
  // Added version 1.2 - Allows users to Sort Log Records by an
  // NDC text filter. A new LogRecordFilter was created to
  // sort the records.
  protected JMenuItem createEditSortNDCMI() {
    JMenuItem editSortNDCMI = new JMenuItem(""Sort by NDC"");
    editSortNDCMI.setMnemonic('s');
    editSortNDCMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            String inputValue =
                JOptionPane.showInputDialog(
                    _logMonitorFrame,
                    ""Sort by this NDC: "",
                    ""Sort Log Records by NDC"",
                    JOptionPane.QUESTION_MESSAGE
                );
            setNDCTextFilter(inputValue);
            sortByNDC();
            _table.getFilteredLogTableModel().refresh();
            updateStatusLabel();
          }
        }
    );
    return editSortNDCMI;
  }
  // Added in version 1.2 - Resets the LogRecordFilter back to default
  // filter.
  protected JMenuItem createEditRestoreAllNDCMI() {
    JMenuItem editRestoreAllNDCMI = new JMenuItem(""Restore all NDCs"");
    editRestoreAllNDCMI.setMnemonic('r');
    editRestoreAllNDCMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());
            // reset the text filter
            setNDCTextFilter("""");
            _table.getFilteredLogTableModel().refresh();
            updateStatusLabel();
          }
        }
    );
    return editRestoreAllNDCMI;
  }
  protected JToolBar createToolBar() {
    JToolBar tb = new JToolBar();
    tb.putClientProperty(""JToolBar.isRollover"", Boolean.TRUE);
    JComboBox fontCombo = new JComboBox();
    JComboBox fontSizeCombo = new JComboBox();
    _fontSizeCombo = fontSizeCombo;
    ClassLoader cl = this.getClass().getClassLoader();
    URL newIconURL = cl.getResource(""org/apache/log4j/viewer/"" +
        ""images/channelexplorer_new.gif"");
    ImageIcon newIcon = null;
    if (newIconURL != null) {
      newIcon = new ImageIcon(newIconURL);
    }
    JButton newButton = new JButton(""Clear Log Table"");
    if (newIcon != null) {
      newButton.setIcon(newIcon);
    }
    newButton.setToolTipText(""Clear Log Table."");
    //newButton.setBorder(BorderFactory.createEtchedBorder());
    newButton.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _table.clearLogRecords();
            _categoryExplorerTree.getExplorerModel().resetAllNodeCounts();
            updateStatusLabel();
            clearDetailTextArea();
            LogRecord.resetSequenceNumber();
          }
        }
    );
    Toolkit tk = Toolkit.getDefaultToolkit();
    // This will actually grab all the fonts
    String[] fonts;
    if (_loadSystemFonts) {
      fonts = GraphicsEnvironment.
          getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
    } else {
      fonts = tk.getFontList();
    }
    for (int j = 0; j < fonts.length; j++) {
      fontCombo.addItem(fonts[j]);
    }
    fontCombo.setSelectedItem(_fontName);
    fontCombo.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            JComboBox box = (JComboBox) e.getSource();
            String font = (String) box.getSelectedItem();
            _table.setFont(new Font(font, Font.PLAIN, _fontSize));
            _fontName = font;
          }
        }
    );
    fontSizeCombo.addItem(""8"");
    fontSizeCombo.addItem(""9"");
    fontSizeCombo.addItem(""10"");
    fontSizeCombo.addItem(""12"");
    fontSizeCombo.addItem(""14"");
    fontSizeCombo.addItem(""16"");
    fontSizeCombo.addItem(""18"");
    fontSizeCombo.addItem(""24"");
    fontSizeCombo.setSelectedItem(String.valueOf(_fontSize));
    fontSizeCombo.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            JComboBox box = (JComboBox) e.getSource();
            String size = (String) box.getSelectedItem();
            int s = Integer.valueOf(size).intValue();
            setFontSizeSilently(s);
            refreshDetailTextArea();
            _fontSize = s;
          }
        }
    );
    tb.add(new JLabel("" Font: ""));
    tb.add(fontCombo);
    tb.add(fontSizeCombo);
    tb.addSeparator();
    tb.addSeparator();
    tb.add(newButton);
    newButton.setAlignmentY(0.5f);
    newButton.setAlignmentX(0.5f);
    fontCombo.setMaximumSize(fontCombo.getPreferredSize());
    fontSizeCombo.setMaximumSize(
        fontSizeCombo.getPreferredSize());
    return (tb);
  }
//    protected void setView(String viewString, LogTable table) {
//        if (STANDARD_VIEW.equals(viewString)) {
//            table.setStandardView();
//        } else if (COMPACT_VIEW.equals(viewString)) {
//            table.setCompactView();
//        } else if (DETAILED_VIEW.equals(viewString)) {
//            table.setDetailedView();
//        } else {
//            String message = viewString + ""does not match a supported view."";
//            throw new IllegalArgumentException(message);
//        }
//        _currentView = viewString;
//    }
  protected void setView(String viewString, LogTable table) {
    if (DETAILED_VIEW.equals(viewString)) {
      table.setDetailedView();
    } else {
      String message = viewString + ""does not match a supported view."";
      throw new IllegalArgumentException(message);
    }
    _currentView = viewString;
  }
  protected JComboBox createLogLevelCombo() {
    JComboBox result = new JComboBox();
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      result.addItem(levels.next());
    }
    result.setSelectedItem(_leastSevereDisplayedLogLevel);
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        JComboBox box = (JComboBox) e.getSource();
        LogLevel level = (LogLevel) box.getSelectedItem();
        setLeastSevereDisplayedLogLevel(level);
      }
    });
    result.setMaximumSize(result.getPreferredSize());
    return result;
  }
  protected void setLeastSevereDisplayedLogLevel(LogLevel level) {
    if (level == null || _leastSevereDisplayedLogLevel == level) {
      return; // nothing to do
    }
    _leastSevereDisplayedLogLevel = level;
    _table.getFilteredLogTableModel().refresh();
    updateStatusLabel();
  }
  /**
   * Ensures that the Table's ScrollPane Viewport will ""track"" with updates
   * to the Table.  When the vertical scroll bar is at its bottom anchor
   * and tracking is enabled then viewport will stay at the bottom most
   * point of the component.  The purpose of this feature is to allow
   * a developer to watch the table as messages arrive and not have to
   * scroll after each new message arrives.  When the vertical scroll bar
   * is at any other location, then no tracking will happen.
   * @deprecated tracking is now done automatically.
   */
  protected void trackTableScrollPane() {
    // do nothing
  }
  protected void centerFrame(JFrame frame) {
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    Dimension comp = frame.getSize();
    frame.setLocation(((screen.width - comp.width) / 2),
        ((screen.height - comp.height) / 2));
  }
  /**
   * Uses a JFileChooser to select a file to opened with the
   * LF5 GUI.
   */
  protected void requestOpen() {
    JFileChooser chooser;
    if (_fileLocation == null) {
      chooser = new JFileChooser();
    } else {
      chooser = new JFileChooser(_fileLocation);
    }
    int returnVal = chooser.showOpenDialog(_logMonitorFrame);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File f = chooser.getSelectedFile();
      if (loadLogFile(f)) {
        _fileLocation = chooser.getSelectedFile();
        _mruFileManager.set(f);
        updateMRUList();
      }
    }
  }
  /**
   * Uses a Dialog box to accept a URL to a file to be opened
   * with the LF5 GUI.
   */
  protected void requestOpenURL() {
    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(
        getBaseFrame(), ""Open URL"", ""URL:"");
    String temp = inputDialog.getText();
    if (temp != null) {
      if (temp.indexOf(""://"") == -1) {
        temp = ""http://"" + temp;
      }
      try {
        URL url = new URL(temp);
        if (loadLogFile(url)) {
          _mruFileManager.set(url);
          updateMRUList();
        }
      } catch (MalformedURLException e) {
        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
            getBaseFrame(), ""Error reading URL."");
      }
    }
  }
  /**
   * Removes old file list and creates a new file list
   * with the updated MRU list.
   */
  protected void updateMRUList() {
    JMenu menu = _logMonitorFrame.getJMenuBar().getMenu(0);
    menu.removeAll();
    menu.add(createOpenMI());
    menu.add(createOpenURLMI());
    menu.addSeparator();
    menu.add(createCloseMI());
    createMRUFileListMI(menu);
    menu.addSeparator();
    menu.add(createExitMI());
  }
  protected void requestClose() {
    setCallSystemExitOnClose(false);
    closeAfterConfirm();
  }
  /**
   * Opens a file in the MRU list.
   */
  protected void requestOpenMRU(ActionEvent e) {
    String file = e.getActionCommand();
    StringTokenizer st = new StringTokenizer(file);
    String num = st.nextToken().trim();
    file = st.nextToken(""\n"");
    try {
      int index = Integer.parseInt(num) - 1;
      InputStream in = _mruFileManager.getInputStream(index);
      LogFileParser lfp = new LogFileParser(in);
      lfp.parse(this);
      _mruFileManager.moveToTop(index);
      updateMRUList();
    } catch (Exception me) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Unable to load file "" + file);
    }
  }
  protected void requestExit() {
    _mruFileManager.save();
    setCallSystemExitOnClose(true);
    closeAfterConfirm();
  }
  protected void closeAfterConfirm() {
    StringBuffer message = new StringBuffer();
    if (_callSystemExitOnClose == false) {
      message.append(""Are you sure you want to close the logging "");
      message.append(""console?\n"");
      message.append(""(Note: This will not shut down the Virtual Machine,\n"");
      message.append(""or the Swing event thread.)"");
    } else {
      message.append(""Are you sure you want to exit?\n"");
      message.append(""This will shut down the Virtual Machine.\n"");
    }
    String title =
        ""Are you sure you want to dispose of the Logging Console?"";
    if (_callSystemExitOnClose == true) {
      title = ""Are you sure you want to exit?"";
    }
    int value = JOptionPane.showConfirmDialog(
        _logMonitorFrame,
        message.toString(),
        title,
        JOptionPane.OK_CANCEL_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null
    );
    if (value == JOptionPane.OK_OPTION) {
      dispose();
    }
  }
  protected Iterator getLogLevels() {
    return _levels.iterator();
  }
  protected Iterator getLogTableColumns() {
    return _columns.iterator();
  }
  /**
   * Loads and parses a log file.
   */
  protected boolean loadLogFile(File file) {
    boolean ok = false;
    try {
      LogFileParser lfp = new LogFileParser(file);
      lfp.parse(this);
      ok = true;
    } catch (IOException e) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Error reading "" + file.getName());
    }
    return ok;
  }
  /**
   * Loads a parses a log file running on a server.
   */
  protected boolean loadLogFile(URL url) {
    boolean ok = false;
    try {
      LogFileParser lfp = new LogFileParser(url.openStream());
      lfp.parse(this);
      ok = true;
    } catch (IOException e) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Error reading URL:"" + url.getFile());
    }
    return ok;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
  class LogBrokerMonitorWindowAdaptor extends WindowAdapter {
    protected LogBrokerMonitor _monitor;
    public LogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor) {
      _monitor = monitor;
    }
    public void windowClosing(WindowEvent ev) {
      _monitor.requestClose();
    }
  }
}
"
org.apache.log4j.lf5.viewer.LogFactor5AboutDialog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import org.apache.log4j.lf5.util.ProductProperties;
import org.apache.log4j.lf5.util.Resource;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.URL;
/**
 * LogFactor5AboutDialog
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brent Sprecher
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogFactor5AboutDialog extends JDialog {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public LogFactor5AboutDialog(Frame owner) {
    super(owner, ""About LogFactor5"", true);
    ProductProperties props = ProductProperties.getInstance();
    setTitle(""About LogFactor5"");
    JPanel imagePanel = new JPanel();
    Resource aboutResource = new Resource(""org/apache/log4j/lf5/viewer/images/"" +
        ""lf5_about.gif"");
    URL aboutIconURL = aboutResource.getURL();
    ImageIcon aboutIcon = null;
    if (aboutIconURL != null) {
      aboutIcon = new ImageIcon(aboutIconURL);
    }
    JLabel imageLabel = new JLabel();
    if (aboutIcon != null) {
      imageLabel.setIcon(aboutIcon);
    }
    imagePanel.add(imageLabel);
    JPanel textPanel = new JPanel();
    textPanel.setLayout(new GridLayout(3, 1));
    int numberOfRows = 13;
    numberOfRows = 11; // we need less room for a registered user.
    JPanel mainPanel = new JPanel();
    mainPanel.setLayout(new GridLayout(numberOfRows, 1));
    JLabel aboutLF5 = new JLabel(""LogFactor5 v"" + props.getProductVersionNumber(), JLabel.CENTER);
    aboutLF5.setHorizontalAlignment(SwingConstants.CENTER);
    JLabel donate = new JLabel(""Contributed by ThoughtWorks Inc."");
    donate.setHorizontalAlignment(SwingConstants.CENTER);
    mainPanel.add(aboutLF5);
    mainPanel.add(Box.createVerticalStrut(10));
    mainPanel.add(donate);
    mainPanel.add(Box.createVerticalStrut(10));
    JButton ok = new JButton(""OK"");
    JPanel southPanel = new JPanel();
    southPanel.setLayout(new FlowLayout());
    southPanel.add(ok);
    ok.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            hide();
          }
        }
    );
    getContentPane().add(imagePanel, BorderLayout.NORTH);
    getContentPane().add(mainPanel, BorderLayout.CENTER);
    getContentPane().add(southPanel, BorderLayout.SOUTH);
    setSize(414, 400);
    center();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void center() {
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    Dimension comp = getSize();
    setLocation(((screen.width - comp.width) / 2),
        ((screen.height - comp.height) / 2));
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LogFactor5Dialog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.*;
import java.awt.*;
/**
 * LogFactor5Dialog
 *
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public abstract class LogFactor5Dialog extends JDialog {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  protected static final Font DISPLAY_FONT = new Font(""Arial"", Font.BOLD, 12);
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  protected LogFactor5Dialog(JFrame jframe, String message, boolean modal) {
    super(jframe, message, modal);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void show() {
    pack();
    minimumSizeDialog(this, 200, 100);
    centerWindow(this);
    super.show();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  protected void centerWindow(Window win) {
    Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
    // If larger than screen, reduce window width or height
    if (screenDim.width < win.getSize().width) {
      win.setSize(screenDim.width, win.getSize().height);
    }
    if (screenDim.height < win.getSize().height) {
      win.setSize(win.getSize().width, screenDim.height);
    }
    // Center Frame, Dialogue or Window on screen
    int x = (screenDim.width - win.getSize().width) / 2;
    int y = (screenDim.height - win.getSize().height) / 2;
    win.setLocation(x, y);
  }
  protected void wrapStringOnPanel(String message,
      Container container) {
    GridBagConstraints c = getDefaultConstraints();
    c.gridwidth = GridBagConstraints.REMAINDER;
    // Insets() args are top, left, bottom, right
    c.insets = new Insets(0, 0, 0, 0);
    GridBagLayout gbLayout = (GridBagLayout) container.getLayout();
    while (message.length() > 0) {
      int newLineIndex = message.indexOf('\n');
      String line;
      if (newLineIndex >= 0) {
        line = message.substring(0, newLineIndex);
        message = message.substring(newLineIndex + 1);
      } else {
        line = message;
        message = """";
      }
      Label label = new Label(line);
      label.setFont(DISPLAY_FONT);
      gbLayout.setConstraints(label, c);
      container.add(label);
    }
  }
  protected GridBagConstraints getDefaultConstraints() {
    GridBagConstraints constraints = new GridBagConstraints();
    constraints.weightx = 1.0;
    constraints.weighty = 1.0;
    constraints.gridheight = 1; // One row high
    // Insets() args are top, left, bottom, right
    constraints.insets = new Insets(4, 4, 4, 4);
    // fill of NONE means do not change size
    constraints.fill = GridBagConstraints.NONE;
    // WEST means align left
    constraints.anchor = GridBagConstraints.WEST;
    return constraints;
  }
  protected void minimumSizeDialog(Component component,
      int minWidth,
      int minHeight) {
    // set the min width
    if (component.getSize().width < minWidth)
      component.setSize(minWidth, component.getSize().height);
    // set the min height
    if (component.getSize().height < minHeight)
      component.setSize(component.getSize().width, minHeight);
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.viewer.LogFactor5ErrorDialog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
/**
 * LogFactor5ErrorDialog
 *
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogFactor5ErrorDialog extends LogFactor5Dialog {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogFactor5ErrorDialog(JFrame jframe, String message) {
    super(jframe, ""Error"", true);
    JButton ok = new JButton(""Ok"");
    ok.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
      }
    });
    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());
    bottom.add(ok);
    JPanel main = new JPanel();
    main.setLayout(new GridBagLayout());
    wrapStringOnPanel(message, main);
    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    show();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.viewer.LogFactor5InputDialog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
/**
 * LogFactor5InputDialog
 *
 * Creates a popup input dialog box so that users can enter
 * a URL to open a log file from.
 *
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogFactor5InputDialog extends LogFactor5Dialog {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  public static final int SIZE = 30;
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private JTextField _textField;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Configures an input dialog box using a defualt size for the text field.
   * param jframe the frame where the dialog will be loaded from.
   * param title the title of the dialog box.
   * param label the label to be put in the dialog box.
   */
  public LogFactor5InputDialog(JFrame jframe, String title, String label) {
    this(jframe, title, label, SIZE);
  }
  /**
   * Configures an input dialog box.
   * param jframe the frame where the dialog will be loaded from.
   * param title the title of the dialog box.
   * param label the label to be put in the dialog box.
   * param size the size of the text field.
   */
  public LogFactor5InputDialog(JFrame jframe, String title, String label,
      int size) {
    super(jframe, title, true);
    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());
    JPanel main = new JPanel();
    main.setLayout(new FlowLayout());
    main.add(new JLabel(label));
    _textField = new JTextField(size);
    main.add(_textField);
    addKeyListener(new KeyAdapter() {
      public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_ENTER) {
          hide();
        }
      }
    });
    JButton ok = new JButton(""Ok"");
    ok.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
      }
    });
    JButton cancel = new JButton(""Cancel"");
    cancel.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
        // set the text field to blank just in case
        // a file was selected before the Cancel
        // button was pressed.
        _textField.setText("""");
      }
    });
    bottom.add(ok);
    bottom.add(cancel);
    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    pack();
    centerWindow(this);
    show();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public String getText() {
    String s = _textField.getText();
    if (s != null && s.trim().length() == 0) {
      return null;
    }
    return s;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.viewer.LogFactor5LoadingDialog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.*;
import java.awt.*;
/**
 * LogFactor5LoadingDialog
 *
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogFactor5LoadingDialog extends LogFactor5Dialog {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogFactor5LoadingDialog(JFrame jframe, String message) {
    super(jframe, ""LogFactor5"", false);
    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());
    JPanel main = new JPanel();
    main.setLayout(new GridBagLayout());
    wrapStringOnPanel(message, main);
    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    show();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}"
org.apache.log4j.lf5.viewer.LogTable,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import org.apache.log4j.lf5.util.DateFormatManager;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import java.awt.*;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
/**
 * LogTable.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brad Marlborough
 * @author Brent Sprecher
 */
// Contributed by ThoughtWorks Inc.
public class LogTable extends JTable {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected int _rowHeight = 30;
  protected JTextArea _detailTextArea;
  // For the columns:
  protected int _numCols = 9;
  protected TableColumn[] _tableColumns = new TableColumn[_numCols];
  protected int[] _colWidths = {40, 40, 40, 70, 70, 360, 440, 200, 60};
  protected LogTableColumn[] _colNames = LogTableColumn.getLogTableColumnArray();
  protected int _colDate = 0;
  protected int _colThread = 1;
  protected int _colMessageNum = 2;
  protected int _colLevel = 3;
  protected int _colNDC = 4;
  protected int _colCategory = 5;
  protected int _colMessage = 6;
  protected int _colLocation = 7;
  protected int _colThrown = 8;
  protected DateFormatManager _dateFormatManager = null;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogTable(JTextArea detailTextArea) {
    super();
    init();
    _detailTextArea = detailTextArea;
    setModel(new FilteredLogTableModel());
    Enumeration columns = getColumnModel().getColumns();
    int i = 0;
    while (columns.hasMoreElements()) {
      TableColumn col = (TableColumn) columns.nextElement();
      col.setCellRenderer(new LogTableRowRenderer());
      col.setPreferredWidth(_colWidths[i]);
      _tableColumns[i] = col;
      i++;
    }
    ListSelectionModel rowSM = getSelectionModel();
    rowSM.addListSelectionListener(new LogTableListSelectionListener(this));
    //setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Get the DateFormatManager for formatting dates.
   */
  public DateFormatManager getDateFormatManager() {
    return _dateFormatManager;
  }
  /**
   * Set the date format manager for formatting dates.
   */
  public void setDateFormatManager(DateFormatManager dfm) {
    _dateFormatManager = dfm;
  }
  public synchronized void clearLogRecords() {
    //For JDK1.3
    //((DefaultTableModel)getModel()).setRowCount(0);
    // For JDK1.2.x
    getFilteredLogTableModel().clear();
  }
  public FilteredLogTableModel getFilteredLogTableModel() {
    return (FilteredLogTableModel) getModel();
  }
  // default view if a view is not set and saved
  public void setDetailedView() {
    //TODO: Defineable Views.
    TableColumnModel model = getColumnModel();
    // Remove all the columns:
    for (int f = 0; f < _numCols; f++) {
      model.removeColumn(_tableColumns[f]);
    }
    // Add them back in the correct order:
    for (int i = 0; i < _numCols; i++) {
      model.addColumn(_tableColumns[i]);
    }
    //SWING BUG:
    sizeColumnsToFit(-1);
  }
  public void setView(List columns) {
    TableColumnModel model = getColumnModel();
    // Remove all the columns:
    for (int f = 0; f < _numCols; f++) {
      model.removeColumn(_tableColumns[f]);
    }
    Iterator selectedColumns = columns.iterator();
    Vector columnNameAndNumber = getColumnNameAndNumber();
    while (selectedColumns.hasNext()) {
      // add the column to the view
      model.addColumn(_tableColumns[columnNameAndNumber.indexOf(selectedColumns.next())]);
    }
    //SWING BUG:
    sizeColumnsToFit(-1);
  }
  public void setFont(Font font) {
    super.setFont(font);
    Graphics g = this.getGraphics();
    if (g != null) {
      FontMetrics fm = g.getFontMetrics(font);
      int height = fm.getHeight();
      _rowHeight = height + height / 3;
      setRowHeight(_rowHeight);
    }
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void init() {
    setRowHeight(_rowHeight);
    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  }
  // assign a column number to a column name
  protected Vector getColumnNameAndNumber() {
    Vector columnNameAndNumber = new Vector();
    for (int i = 0; i < _colNames.length; i++) {
      columnNameAndNumber.add(i, _colNames[i]);
    }
    return columnNameAndNumber;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
  class LogTableListSelectionListener implements ListSelectionListener {
    protected JTable _table;
    public LogTableListSelectionListener(JTable table) {
      _table = table;
    }
    public void valueChanged(ListSelectionEvent e) {
      //Ignore extra messages.
      if (e.getValueIsAdjusting()) {
        return;
      }
      ListSelectionModel lsm = (ListSelectionModel) e.getSource();
      if (lsm.isSelectionEmpty()) {
        //no rows are selected
      } else {
        StringBuffer buf = new StringBuffer();
        int selectedRow = lsm.getMinSelectionIndex();
        for (int i = 0; i < _numCols - 1; i++) {
          String value = """";
          Object obj = _table.getModel().getValueAt(selectedRow, i);
          if (obj != null) {
            value = obj.toString();
          }
          buf.append(_colNames[i] + "":"");
          buf.append(""\t"");
          if (i == _colThread || i == _colMessage || i == _colLevel) {
            buf.append(""\t""); // pad out the date.
          }
          if (i == _colDate || i == _colNDC) {
            buf.append(""\t\t""); // pad out the date.
          }
//               if( i == _colSequence)
//               {
//                  buf.append(""\t\t\t""); // pad out the Sequnce.
//               }
          buf.append(value);
          buf.append(""\n"");
        }
        buf.append(_colNames[_numCols - 1] + "":\n"");
        Object obj = _table.getModel().getValueAt(selectedRow, _numCols - 1);
        if (obj != null) {
          buf.append(obj.toString());
        }
        _detailTextArea.setText(buf.toString());
      }
    }
  }
}
"
org.apache.log4j.lf5.viewer.LogTableColumn,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * LogTableColumn
 *
 * @author Michael J. Sikorsky
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogTableColumn implements java.io.Serializable {
  // log4j table columns.
  public final static LogTableColumn DATE = new LogTableColumn(""Date"");
  public final static LogTableColumn THREAD = new LogTableColumn(""Thread"");
  public final static LogTableColumn MESSAGE_NUM = new LogTableColumn(""Message #"");
  public final static LogTableColumn LEVEL = new LogTableColumn(""Level"");
  public final static LogTableColumn NDC = new LogTableColumn(""NDC"");
  public final static LogTableColumn CATEGORY = new LogTableColumn(""Category"");
  public final static LogTableColumn MESSAGE = new LogTableColumn(""Message"");
  public final static LogTableColumn LOCATION = new LogTableColumn(""Location"");
  public final static LogTableColumn THROWN = new LogTableColumn(""Thrown"");
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected String _label;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private static LogTableColumn[] _log4JColumns;
  private static Map _logTableColumnMap;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  static {
    _log4JColumns = new LogTableColumn[]{DATE, THREAD, MESSAGE_NUM, LEVEL, NDC, CATEGORY,
                                         MESSAGE, LOCATION, THROWN};
    _logTableColumnMap = new HashMap();
    for (int i = 0; i < _log4JColumns.length; i++) {
      _logTableColumnMap.put(_log4JColumns[i].getLabel(), _log4JColumns[i]);
    }
  }
  public LogTableColumn(String label) {
    _label = label;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Return the Label of the LogLevel.
   */
  public String getLabel() {
    return _label;
  }
  /**
   * Convert a column label into a LogTableColumn object.
   *
   * @param level The label of a level to be converted into a LogTableColumn.
   * @return LogTableColumn The LogTableColumn with a label equal to column.
   * @throws LogTableColumnFormatException Is thrown when the column can not be
   *         converted into a LogTableColumn.
   */
  public static LogTableColumn valueOf(String column)
      throws LogTableColumnFormatException {
    LogTableColumn tableColumn = null;
    if (column != null) {
      column = column.trim();
      tableColumn = (LogTableColumn) _logTableColumnMap.get(column);
    }
    if (tableColumn == null) {
      StringBuffer buf = new StringBuffer();
      buf.append(""Error while trying to parse ("" + column + "") into"");
      buf.append("" a LogTableColumn."");
      throw new LogTableColumnFormatException(buf.toString());
    }
    return tableColumn;
  }
  public boolean equals(Object o) {
    boolean equals = false;
    if (o instanceof LogTableColumn) {
      if (this.getLabel() ==
          ((LogTableColumn) o).getLabel()) {
        equals = true;
      }
    }
    return equals;
  }
  public int hashCode() {
    return _label.hashCode();
  }
  public String toString() {
    return _label;
  }
  /**
   * @return A <code>List</code> of <code>LogTableColumn/code> objects that map
   * to log4j <code>Column</code> objects.
   */
  public static List getLogTableColumns() {
    return Arrays.asList(_log4JColumns);
  }
  public static LogTableColumn[] getLogTableColumnArray() {
    return _log4JColumns;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LogTableColumnFormatException,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
/**
 * Thrown to indicate that the client has attempted to convert a string
 * to one the LogLevel types, but the string does not have the appropriate
 * format.
 *
 * @author Michael J. Sikorsky
 */
// Contributed by ThoughtWorks Inc.
public class LogTableColumnFormatException extends Exception {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogTableColumnFormatException(String message) {
    super(message);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LogTableModel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import javax.swing.table.DefaultTableModel;
/**
 * LogTableModel
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class LogTableModel extends DefaultTableModel {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public LogTableModel(Object[] colNames, int numRows) {
    super(colNames, numRows);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public boolean isCellEditable(int row, int column) {
    return (false);
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.LogTableRowRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;
/**
 * LogTableRowRenderer
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class LogTableRowRenderer extends DefaultTableCellRenderer {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected boolean _highlightFatal = true;
  protected Color _color = new Color(230, 230, 230);
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public Component getTableCellRendererComponent(JTable table,
      Object value,
      boolean isSelected,
      boolean hasFocus,
      int row,
      int col) {
    if ((row % 2) == 0) {
      setBackground(_color);
    } else {
      setBackground(Color.white);
    }
    FilteredLogTableModel model = (FilteredLogTableModel) table.getModel();
    LogRecord record = model.getFilteredRecord(row);
    setForeground(getLogLevelColor(record.getLevel()));
    return (super.getTableCellRendererComponent(table,
        value,
        isSelected,
        hasFocus,
        row, col));
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected Color getLogLevelColor(LogLevel level) {
    return (Color) LogLevel.getLogLevelColorMap().get(level);
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.TrackingAdjustmentListener,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer;
import java.awt.*;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
/**
 * An AdjustmentListener which ensures that an Adjustable (e.g. a Scrollbar)
 * will ""track"" when the Adjustable expands.
 * For example, when a vertical scroll bar is at its bottom anchor,
 * the scrollbar will remain at the bottom.  When the vertical scroll bar
 * is at any other location, then no tracking will happen.
 * An instance of this class should only listen to one Adjustable as
 * it retains state information about the Adjustable it listens to.
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public class TrackingAdjustmentListener implements AdjustmentListener {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected int _lastMaximum = -1;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void adjustmentValueChanged(AdjustmentEvent e) {
    Adjustable bar = e.getAdjustable();
    int currentMaximum = bar.getMaximum();
    if (bar.getMaximum() == _lastMaximum) {
      return; // nothing to do, the adjustable has not expanded
    }
    int bottom = bar.getValue() + bar.getVisibleAmount();
    if (bottom + bar.getUnitIncrement() >= _lastMaximum) {
      bar.setValue(bar.getMaximum()); // use the most recent maximum
    }
    _lastMaximum = currentMaximum;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryAbstractCellEditor,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.EventListenerList;
import javax.swing.table.TableCellEditor;
import javax.swing.tree.TreeCellEditor;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.EventObject;
/**
 * CategoryAbstractCellEditor.  Base class to handle the some common
 * details of cell editing.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryAbstractCellEditor implements TableCellEditor, TreeCellEditor {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected EventListenerList _listenerList = new EventListenerList();
  protected Object _value;
  protected ChangeEvent _changeEvent = null;
  protected int _clickCountToStart = 1;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public Object getCellEditorValue() {
    return _value;
  }
  public void setCellEditorValue(Object value) {
    _value = value;
  }
  public void setClickCountToStart(int count) {
    _clickCountToStart = count;
  }
  public int getClickCountToStart() {
    return _clickCountToStart;
  }
  public boolean isCellEditable(EventObject anEvent) {
    if (anEvent instanceof MouseEvent) {
      if (((MouseEvent) anEvent).getClickCount() < _clickCountToStart) {
        return false;
      }
    }
    return true;
  }
  public boolean shouldSelectCell(EventObject anEvent) {
    if (this.isCellEditable(anEvent)) {
      if (anEvent == null ||
          ((MouseEvent) anEvent).getClickCount() >= _clickCountToStart) {
        return true;
      }
    }
    return false;
  }
  public boolean stopCellEditing() {
    fireEditingStopped();
    return true;
  }
  public void cancelCellEditing() {
    fireEditingCanceled();
  }
  public void addCellEditorListener(CellEditorListener l) {
    _listenerList.add(CellEditorListener.class, l);
  }
  public void removeCellEditorListener(CellEditorListener l) {
    _listenerList.remove(CellEditorListener.class, l);
  }
  public Component getTreeCellEditorComponent(
      JTree tree, Object value,
      boolean isSelected,
      boolean expanded,
      boolean leaf, int row) {
    return null;
  }
  public Component getTableCellEditorComponent(
      JTable table, Object value,
      boolean isSelected,
      int row, int column) {
    return null;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void fireEditingStopped() {
    Object[] listeners = _listenerList.getListenerList();
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CellEditorListener.class) {
        if (_changeEvent == null) {
          _changeEvent = new ChangeEvent(this);
        }
        ((CellEditorListener) listeners[i + 1]).editingStopped(_changeEvent);
      }
    }
  }
  protected void fireEditingCanceled() {
    Object[] listeners = _listenerList.getListenerList();
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CellEditorListener.class) {
        if (_changeEvent == null) {
          _changeEvent = new ChangeEvent(this);
        }
        ((CellEditorListener) listeners[i + 1]).editingCanceled(_changeEvent);
      }
    }
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryElement,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
/**
 * CategoryElement represents a single element or part of a Category.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryElement {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected String _categoryTitle;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryElement() {
    super();
  }
  public CategoryElement(String title) {
    _categoryTitle = title;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public String getTitle() {
    return (_categoryTitle);
  }
  public void setTitle(String title) {
    _categoryTitle = title;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerLogRecordFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;
import java.util.Enumeration;
/**
 * An implementation of LogRecordFilter based on a CategoryExplorerModel
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public class CategoryExplorerLogRecordFilter implements LogRecordFilter {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected CategoryExplorerModel _model;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryExplorerLogRecordFilter(CategoryExplorerModel model) {
    _model = model;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * @return true if the CategoryExplorer model specified at construction
   * is accepting the category of the specified LogRecord.  Has a side-effect
   * of adding the CategoryPath of the LogRecord to the explorer model
   * if the CategoryPath is new.
   */
  public boolean passes(LogRecord record) {
    CategoryPath path = new CategoryPath(record.getCategory());
    return _model.isCategoryPathActive(path);
  }
  /**
   * Resets the counters for the contained CategoryNodes to zero.
   */
  public void reset() {
    resetAllNodes();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void resetAllNodes() {
    Enumeration nodes = _model.getRootCategoryNode().depthFirstEnumeration();
    CategoryNode current;
    while (nodes.hasMoreElements()) {
      current = (CategoryNode) nodes.nextElement();
      current.resetNumberOfContainedRecords();
      _model.nodeChanged(current);
    }
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerModel,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import org.apache.log4j.lf5.LogRecord;
import javax.swing.*;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Enumeration;
/**
 * CategoryExplorerModel
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brent Sprecher
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class CategoryExplorerModel extends DefaultTreeModel {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected boolean _renderFatal = true;
  protected ActionListener _listener = null;
  protected ActionEvent _event = new ActionEvent(this,
      ActionEvent.ACTION_PERFORMED,
      ""Nodes Selection changed"");
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryExplorerModel(CategoryNode node) {
    super(node);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void addLogRecord(LogRecord lr) {
    CategoryPath path = new CategoryPath(lr.getCategory());
    addCategory(path); // create category path if it is new
    CategoryNode node = getCategoryNode(path);
    node.addRecord(); // update category node
    if (_renderFatal && lr.isFatal()) {
      TreeNode[] nodes = getPathToRoot(node);
      int len = nodes.length;
      CategoryNode parent;
      // i = 0 gives root node
      // skip node and root, loop through ""parents"" in between
      for (int i = 1; i < len - 1; i++) {
        parent = (CategoryNode) nodes[i];
        parent.setHasFatalChildren(true);
        nodeChanged(parent);
      }
      node.setHasFatalRecords(true);
      nodeChanged(node);
    }
  }
  public CategoryNode getRootCategoryNode() {
    return (CategoryNode) getRoot();
  }
  public CategoryNode getCategoryNode(String category) {
    CategoryPath path = new CategoryPath(category);
    return (getCategoryNode(path));
  }
  /**
   * returns null if no CategoryNode exists.
   */
  public CategoryNode getCategoryNode(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; // Start condition.
    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);
      // If the two nodes have matching titles they are considered equal.
      Enumeration children = parent.children();
      boolean categoryAlreadyExists = false;
      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();
        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          // This is now the new parent node.
          parent = node;
          break; // out of the while, and back to the for().
        }
      }
      if (categoryAlreadyExists == false) {
        return null; // Didn't find the Node.
      }
    }
    return (parent);
  }
  /**
   * @return true if all the nodes in the specified CategoryPath are
   * selected.
   */
  public boolean isCategoryPathActive(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; // Start condition.
    boolean active = false;
    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);
      // If the two nodes have matching titles they are considered equal.
      Enumeration children = parent.children();
      boolean categoryAlreadyExists = false;
      active = false;
      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();
        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          // This is now the new parent node.
          parent = node;
          if (parent.isSelected()) {
            active = true;
          }
          break; // out of the while, and back to the for().
        }
      }
      if (active == false || categoryAlreadyExists == false) {
        return false;
      }
    }
    return (active);
  }
  /**
   * <p>Method altered by Richard Hurst such that it returns the CategoryNode
   * corresponding to the CategoryPath</p>
   *
   * @param CategoryPath
   * @returns CategoryNode
   */
  public CategoryNode addCategory(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; // Start condition.
    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);
      // If the two nodes have matching titles they are considered equal.
      Enumeration children = parent.children();
      boolean categoryAlreadyExists = false;
      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();
        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          // This is now the new parent node.
          parent = node;
          break;
        }
      }
      if (categoryAlreadyExists == false) {
        // We need to add the node.
        CategoryNode newNode = new CategoryNode(element.getTitle());
        //This method of adding a new node cause parent roots to be
        // collapsed.
        //parent.add( newNode );
        //reload(parent);
        // This doesn't force the nodes to collapse.
        insertNodeInto(newNode, parent, parent.getChildCount());
        refresh(newNode);
        // The newly added node is now the parent.
        parent = newNode;
      }
    }
    return parent;
  }
  public void update(CategoryNode node, boolean selected) {
    if (node.isSelected() == selected) {
      return; // nothing was changed, nothing to do
    }
    // select parents or deselect children
    if (selected) {
      setParentSelection(node, true);
    } else {
      setDescendantSelection(node, false);
    }
  }
  public void setDescendantSelection(CategoryNode node, boolean selected) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      // does the current node need to be changed?
      if (current.isSelected() != selected) {
        current.setSelected(selected);
        nodeChanged(current);
      }
    }
    notifyActionListeners();
  }
  public void setParentSelection(CategoryNode node, boolean selected) {
    TreeNode[] nodes = getPathToRoot(node);
    int len = nodes.length;
    CategoryNode parent;
    // i = 0 gives root node, i=len-1 gives this node
    // skip the root node
    for (int i = 1; i < len; i++) {
      parent = (CategoryNode) nodes[i];
      if (parent.isSelected() != selected) {
        parent.setSelected(selected);
        nodeChanged(parent);
      }
    }
    notifyActionListeners();
  }
  public synchronized void addActionListener(ActionListener l) {
    _listener = AWTEventMulticaster.add(_listener, l);
  }
  public synchronized void removeActionListener(ActionListener l) {
    _listener = AWTEventMulticaster.remove(_listener, l);
  }
  public void resetAllNodeCounts() {
    Enumeration nodes = getRootCategoryNode().depthFirstEnumeration();
    CategoryNode current;
    while (nodes.hasMoreElements()) {
      current = (CategoryNode) nodes.nextElement();
      current.resetNumberOfContainedRecords();
      nodeChanged(current);
    }
  }
  /**
   * <p>Returns the CategoryPath to the specified CategoryNode</p>
   *
   * @param CategoryNode The target CategoryNode
   * @returns CategoryPath
   */
  public TreePath getTreePathToRoot(CategoryNode node) {
    if (node == null) {
      return null;
    }
    return (new TreePath(getPathToRoot(node)));
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void notifyActionListeners() {
    if (_listener != null) {
      _listener.actionPerformed(_event);
    }
  }
  /**
   * Fires a nodechanged event on the SwingThread.
   */
  protected void refresh(final CategoryNode node) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        nodeChanged(node); // remind the tree to render the new node
      }
    });
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import javax.swing.event.TreeModelEvent;
import javax.swing.tree.TreePath;
import java.awt.event.MouseEvent;
/**
 * CategoryExplorerTree
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 * @author Brent Sprecher
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class CategoryExplorerTree extends JTree {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected CategoryExplorerModel _model;
  protected boolean _rootAlreadyExpanded = false;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   * Construct a CategoryExplorerTree with a specific model.
   */
  public CategoryExplorerTree(CategoryExplorerModel model) {
    super(model);
    _model = model;
    init();
  }
  /**
   * Construct a CategoryExplorerTree and create a default CategoryExplorerModel.
   */
  public CategoryExplorerTree() {
    super();
    CategoryNode rootNode = new CategoryNode(""Categories"");
    _model = new CategoryExplorerModel(rootNode);
    setModel(_model);
    init();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public CategoryExplorerModel getExplorerModel() {
    return (_model);
  }
  public String getToolTipText(MouseEvent e) {
    try {
      return super.getToolTipText(e);
    } catch (Exception ex) {
      return """";
    }
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void init() {
    // Put visible lines on the JTree.
    putClientProperty(""JTree.lineStyle"", ""Angled"");
    // Configure the Tree with the appropriate Renderers and Editors.
    CategoryNodeRenderer renderer = new CategoryNodeRenderer();
    setEditable(true);
    setCellRenderer(renderer);
    CategoryNodeEditor editor = new CategoryNodeEditor(_model);
    setCellEditor(new CategoryImmediateEditor(this,
        new CategoryNodeRenderer(),
        editor));
    setShowsRootHandles(true);
    setToolTipText("""");
    ensureRootExpansion();
  }
  protected void expandRootNode() {
    if (_rootAlreadyExpanded) {
      return;
    }
    _rootAlreadyExpanded = true;
    TreePath path = new TreePath(_model.getRootCategoryNode().getPath());
    expandPath(path);
  }
  protected void ensureRootExpansion() {
    _model.addTreeModelListener(new TreeModelAdapter() {
      public void treeNodesInserted(TreeModelEvent e) {
        expandRootNode();
      }
    });
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryImmediateEditor,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import javax.swing.tree.DefaultTreeCellEditor;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.EventObject;
/**
 * CategoryImmediateEditor
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryImmediateEditor extends DefaultTreeCellEditor {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  private CategoryNodeRenderer renderer;
  protected Icon editingIcon = null;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryImmediateEditor(JTree tree,
      CategoryNodeRenderer renderer,
      CategoryNodeEditor editor) {
    super(tree, renderer, editor);
    this.renderer = renderer;
    renderer.setIcon(null);
    renderer.setLeafIcon(null);
    renderer.setOpenIcon(null);
    renderer.setClosedIcon(null);
    super.editingIcon = null;
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public boolean shouldSelectCell(EventObject e) {
    boolean rv = false;  // only mouse events
    if (e instanceof MouseEvent) {
      MouseEvent me = (MouseEvent) e;
      TreePath path = tree.getPathForLocation(me.getX(),
          me.getY());
      CategoryNode node = (CategoryNode)
          path.getLastPathComponent();
      rv = node.isLeaf() /*|| !inCheckBoxHitRegion(me)*/;
    }
    return rv;
  }
  public boolean inCheckBoxHitRegion(MouseEvent e) {
    TreePath path = tree.getPathForLocation(e.getX(),
        e.getY());
    if (path == null) {
      return false;
    }
    CategoryNode node = (CategoryNode) path.getLastPathComponent();
    boolean rv = false;
    if (true) {
      // offset and lastRow DefaultTreeCellEditor
      // protected members
      Rectangle bounds = tree.getRowBounds(lastRow);
      Dimension checkBoxOffset =
          renderer.getCheckBoxOffset();
      bounds.translate(offset + checkBoxOffset.width,
          checkBoxOffset.height);
      rv = bounds.contains(e.getPoint());
    }
    return true;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected boolean canEditImmediately(EventObject e) {
    boolean rv = false;
    if (e instanceof MouseEvent) {
      MouseEvent me = (MouseEvent) e;
      rv = inCheckBoxHitRegion(me);
    }
    return rv;
  }
  protected void determineOffset(JTree tree, Object value,
      boolean isSelected, boolean expanded,
      boolean leaf, int row) {
    // Very important: means that the tree won't jump around.
    offset = 0;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import java.util.Enumeration;
/**
 * CategoryNode
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryNode extends DefaultMutableTreeNode {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected boolean _selected = true;
  protected int _numberOfContainedRecords = 0;
  protected int _numberOfRecordsFromChildren = 0;
  protected boolean _hasFatalChildren = false;
  protected boolean _hasFatalRecords = false;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  /**
   *
   */
  public CategoryNode(String title) {
    setUserObject(title);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public String getTitle() {
    return (String) getUserObject();
  }
  public void setSelected(boolean s) {
    if (s != _selected) {
      _selected = s;
    }
  }
  public boolean isSelected() {
    return _selected;
  }
  /**
   * @deprecated
   */
  public void setAllDescendantsSelected() {
    Enumeration children = children();
    while (children.hasMoreElements()) {
      CategoryNode node = (CategoryNode) children.nextElement();
      node.setSelected(true);
      node.setAllDescendantsSelected();
    }
  }
  /**
   * @deprecated
   */
  public void setAllDescendantsDeSelected() {
    Enumeration children = children();
    while (children.hasMoreElements()) {
      CategoryNode node = (CategoryNode) children.nextElement();
      node.setSelected(false);
      node.setAllDescendantsDeSelected();
    }
  }
  public String toString() {
    return (getTitle());
  }
  public boolean equals(Object obj) {
    if (obj instanceof CategoryNode) {
      CategoryNode node = (CategoryNode) obj;
      String tit1 = getTitle().toLowerCase();
      String tit2 = node.getTitle().toLowerCase();
      if (tit1.equals(tit2)) {
        return (true);
      }
    }
    return (false);
  }
  public int hashCode() {
    return (getTitle().hashCode());
  }
  public void addRecord() {
    _numberOfContainedRecords++;
    addRecordToParent();
  }
  public int getNumberOfContainedRecords() {
    return _numberOfContainedRecords;
  }
  public void resetNumberOfContainedRecords() {
    _numberOfContainedRecords = 0;
    _numberOfRecordsFromChildren = 0;
    _hasFatalRecords = false;
    _hasFatalChildren = false;
  }
  public boolean hasFatalRecords() {
    return _hasFatalRecords;
  }
  public boolean hasFatalChildren() {
    return _hasFatalChildren;
  }
  public void setHasFatalRecords(boolean flag) {
    _hasFatalRecords = flag;
  }
  public void setHasFatalChildren(boolean flag) {
    _hasFatalChildren = flag;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected int getTotalNumberOfRecords() {
    return getNumberOfRecordsFromChildren() + getNumberOfContainedRecords();
  }
  /**
   * Passes up the addition from child to parent
   */
  protected void addRecordFromChild() {
    _numberOfRecordsFromChildren++;
    addRecordToParent();
  }
  protected int getNumberOfRecordsFromChildren() {
    return _numberOfRecordsFromChildren;
  }
  protected void addRecordToParent() {
    TreeNode parent = getParent();
    if (parent == null) {
      return;
    }
    ((CategoryNode) parent).addRecordFromChild();
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeEditor,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Enumeration;
/**
 * CategoryNodeEditor
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryNodeEditor extends CategoryAbstractCellEditor {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected CategoryNodeEditorRenderer _renderer;
  protected CategoryNode _lastEditedNode;
  protected JCheckBox _checkBox;
  protected CategoryExplorerModel _categoryModel;
  protected JTree _tree;
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryNodeEditor(CategoryExplorerModel model) {
    _renderer = new CategoryNodeEditorRenderer();
    _checkBox = _renderer.getCheckBox();
    _categoryModel = model;
    _checkBox.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _categoryModel.update(_lastEditedNode, _checkBox.isSelected());
        stopCellEditing();
      }
    });
    _renderer.addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) {
        if ((e.getModifiers() & MouseEvent.BUTTON3_MASK) != 0) {
          showPopup(_lastEditedNode, e.getX(), e.getY());
        }
        stopCellEditing();
      }
    });
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public Component getTreeCellEditorComponent(JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row) {
    _lastEditedNode = (CategoryNode) value;
    _tree = tree;
    return _renderer.getTreeCellRendererComponent(tree,
        value, selected, expanded,
        leaf, row, true);
    // hasFocus ignored
  }
  public Object getCellEditorValue() {
    return _lastEditedNode.getUserObject();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected JMenuItem createPropertiesMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Properties"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showPropertiesDialog(node);
      }
    });
    return result;
  }
  protected void showPropertiesDialog(CategoryNode node) {
    JOptionPane.showMessageDialog(
        _tree,
        getDisplayedProperties(node),
        ""Category Properties: "" + node.getTitle(),
        JOptionPane.PLAIN_MESSAGE
    );
  }
  protected Object getDisplayedProperties(CategoryNode node) {
    ArrayList result = new ArrayList();
    result.add(""Category: "" + node.getTitle());
    if (node.hasFatalRecords()) {
      result.add(""Contains at least one fatal LogRecord."");
    }
    if (node.hasFatalChildren()) {
      result.add(""Contains descendants with a fatal LogRecord."");
    }
    result.add(""LogRecords in this category alone: "" +
        node.getNumberOfContainedRecords());
    result.add(""LogRecords in descendant categories: "" +
        node.getNumberOfRecordsFromChildren());
    result.add(""LogRecords in this category including descendants: "" +
        node.getTotalNumberOfRecords());
    return result.toArray();
  }
  protected void showPopup(CategoryNode node, int x, int y) {
    JPopupMenu popup = new JPopupMenu();
    popup.setSize(150, 400);
    //
    // Configure the Popup
    //
    if (node.getParent() == null) {
      popup.add(createRemoveMenuItem());
      popup.addSeparator();
    }
    popup.add(createSelectDescendantsMenuItem(node));
    popup.add(createUnselectDescendantsMenuItem(node));
    popup.addSeparator();
    popup.add(createExpandMenuItem(node));
    popup.add(createCollapseMenuItem(node));
    popup.addSeparator();
    popup.add(createPropertiesMenuItem(node));
    popup.show(_renderer, x, y);
  }
  protected JMenuItem createSelectDescendantsMenuItem(final CategoryNode node) {
    JMenuItem selectDescendants =
        new JMenuItem(""Select All Descendant Categories"");
    selectDescendants.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _categoryModel.setDescendantSelection(node, true);
          }
        }
    );
    return selectDescendants;
  }
  protected JMenuItem createUnselectDescendantsMenuItem(final CategoryNode node) {
    JMenuItem unselectDescendants =
        new JMenuItem(""Deselect All Descendant Categories"");
    unselectDescendants.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _categoryModel.setDescendantSelection(node, false);
          }
        }
    );
    return unselectDescendants;
  }
  protected JMenuItem createExpandMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Expand All Descendant Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        expandDescendants(node);
      }
    });
    return result;
  }
  protected JMenuItem createCollapseMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Collapse All Descendant Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        collapseDescendants(node);
      }
    });
    return result;
  }
  /**
   * This featured was moved from the LogBrokerMonitor class
   * to the CategoryNodeExplorer so that the Category tree
   * could be pruned from the Category Explorer popup menu.
   * This menu option only appears when a user right clicks on
   * the Category parent node.
   *
   * See removeUnusedNodes()
   */
  protected JMenuItem createRemoveMenuItem() {
    JMenuItem result = new JMenuItem(""Remove All Empty Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        while (removeUnusedNodes() > 0) ;
      }
    });
    return result;
  }
  protected void expandDescendants(CategoryNode node) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      expand(current);
    }
  }
  protected void collapseDescendants(CategoryNode node) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      collapse(current);
    }
  }
  /**
   * Removes any inactive nodes from the Category tree.
   */
  protected int removeUnusedNodes() {
    int count = 0;
    CategoryNode root = _categoryModel.getRootCategoryNode();
    Enumeration enum = root.depthFirstEnumeration();
    while (enum.hasMoreElements()) {
      CategoryNode node = (CategoryNode) enum.nextElement();
      if (node.isLeaf() && node.getNumberOfContainedRecords() == 0
          && node.getParent() != null) {
        _categoryModel.removeNodeFromParent(node);
        count++;
      }
    }
    return count;
  }
  protected void expand(CategoryNode node) {
    _tree.expandPath(getTreePath(node));
  }
  protected TreePath getTreePath(CategoryNode node) {
    return new TreePath(node.getPath());
  }
  protected void collapse(CategoryNode node) {
    _tree.collapsePath(getTreePath(node));
  }
  //-----------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeEditorRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import java.awt.*;
/**
 * CategoryNodeEditorRenderer
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryNodeEditorRenderer extends CategoryNodeRenderer {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public Component getTreeCellRendererComponent(
      JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row,
      boolean hasFocus) {
    Component c = super.getTreeCellRendererComponent(tree,
        value, selected, expanded,
        leaf, row, hasFocus);
    return c;
  }
  public JCheckBox getCheckBox() {
    return _checkBox;
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.*;
import javax.swing.tree.DefaultTreeCellRenderer;
import java.awt.*;
import java.net.URL;
/**
 * CategoryNodeRenderer
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryNodeRenderer extends DefaultTreeCellRenderer {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  public static final Color FATAL_CHILDREN = new Color(189, 113, 0);
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected JCheckBox _checkBox = new JCheckBox();
  protected JPanel _panel = new JPanel();
  protected static ImageIcon _sat = null;
//   protected JLabel              _label  = new JLabel();
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryNodeRenderer() {
    _panel.setBackground(UIManager.getColor(""Tree.textBackground""));
    if (_sat == null) {
      // Load the satellite image.
      String resource =
          ""/org/apache/log4j/lf5/viewer/images/channelexplorer_satellite.gif"";
      URL satURL = getClass().getResource(resource);
      _sat = new ImageIcon(satURL);
    }
    setOpaque(false);
    _checkBox.setOpaque(false);
    _panel.setOpaque(false);
    // The flowlayout set to LEFT is very important so that the editor
    // doesn't jump around.
    _panel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
    _panel.add(_checkBox);
    _panel.add(this);
    setOpenIcon(_sat);
    setClosedIcon(_sat);
    setLeafIcon(_sat);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public Component getTreeCellRendererComponent(
      JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row,
      boolean hasFocus) {
    CategoryNode node = (CategoryNode) value;
    //FileNode node = (FileNode)value;
    //String s = tree.convertValueToText(value, selected,
    //						   expanded, leaf, row, hasFocus);
    super.getTreeCellRendererComponent(
        tree, value, selected, expanded,
        leaf, row, hasFocus);
    if (row == 0) {
      // Root row -- no check box
      _checkBox.setVisible(false);
    } else {
      _checkBox.setVisible(true);
      _checkBox.setSelected(node.isSelected());
    }
    String toolTip = buildToolTip(node);
    _panel.setToolTipText(toolTip);
    if (node.hasFatalChildren()) {
      this.setForeground(FATAL_CHILDREN);
    }
    if (node.hasFatalRecords()) {
      this.setForeground(Color.red);
    }
    return _panel;
  }
  public Dimension getCheckBoxOffset() {
    return new Dimension(0, 0);
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected String buildToolTip(CategoryNode node) {
    StringBuffer result = new StringBuffer();
    result.append(node.getTitle()).append("" contains a total of "");
    result.append(node.getTotalNumberOfRecords());
    result.append("" LogRecords."");
    result.append("" Right-click for more info."");
    return result.toString();
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import java.util.LinkedList;
import java.util.StringTokenizer;
/**
 * CategoryPath is a collection of CategoryItems which represent a
 * path of categories.
 *
 * @author Michael J. Sikorsky
 * @author Robert Shaw
 */
// Contributed by ThoughtWorks Inc.
public class CategoryPath {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  protected LinkedList _categoryElements = new LinkedList();
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public CategoryPath() {
    super();
  }
  /**
   * Construct a CategoryPath.  If the category is null, it defaults to ""Debug"".
   */
  public CategoryPath(String category) {
    String processedCategory = category;
    if (processedCategory == null) {
      processedCategory = ""Debug"";
    }
    processedCategory.replace('/', '.');
    processedCategory = processedCategory.replace('\\', '.');
    StringTokenizer st = new StringTokenizer(processedCategory, ""."");
    while (st.hasMoreTokens()) {
      String element = st.nextToken();
      addCategoryElement(new CategoryElement(element));
    }
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * returns the number of CategoryElements.
   */
  public int size() {
    int count = _categoryElements.size();
    return (count);
  }
  public boolean isEmpty() {
    boolean empty = false;
    if (_categoryElements.size() == 0) {
      empty = true;
    }
    return (empty);
  }
  /**
   * Removes all categoryElements.
   */
  public void removeAllCategoryElements() {
    _categoryElements.clear();
  }
  /**
   * Adds the specified categoryElement to the end of the categoryElement set.
   */
  public void addCategoryElement(CategoryElement categoryElement) {
    _categoryElements.addLast(categoryElement);
  }
  /**
   * Returns the CategoryElement at the specified index.
   */
  public CategoryElement categoryElementAt(int index) {
    return ((CategoryElement) _categoryElements.get(index));
  }
  public String toString() {
    StringBuffer out = new StringBuffer(100);
    out.append(""\n"");
    out.append(""===========================\n"");
    out.append(""CategoryPath:                   \n"");
    out.append(""---------------------------\n"");
    out.append(""\nCategoryPath:\n\t"");
    if (this.size() > 0) {
      for (int i = 0; i < this.size(); i++) {
        out.append(this.categoryElementAt(i).toString());
        out.append(""\n\t"");
      }
    } else {
      out.append(""<<NONE>>"");
    }
    out.append(""\n"");
    out.append(""===========================\n"");
    return (out.toString());
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.categoryexplorer.TreeModelAdapter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.categoryexplorer;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
/**
 * Default implementation of TreeModelListener which does nothing.
 *
 * @author Richard Wan
 */
// Contributed by ThoughtWorks Inc.
public class TreeModelAdapter implements TreeModelListener {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void treeNodesChanged(TreeModelEvent e) {
  }
  public void treeNodesInserted(TreeModelEvent e) {
  }
  public void treeNodesRemoved(TreeModelEvent e) {
  }
  public void treeStructureChanged(TreeModelEvent e) {
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.configure.ConfigurationManager,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.configure;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogLevelFormatException;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.lf5.viewer.LogTable;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerModel;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNode;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;
import org.apache.log4j.lf5.viewer.LogTableColumn;
import org.apache.log4j.lf5.viewer.LogTableColumnFormatException;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import javax.swing.*;
import javax.swing.tree.TreePath;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.List;
/**
 * <p>ConfigurationManager handles the storage and retrival of the state of
 * the CategoryExplorer
 *
 * @author Richard Hurst
 * @author Brad Marlborough
 */
// Contributed by ThoughtWorks Inc.
public class ConfigurationManager extends Object {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  private static final String CONFIG_FILE_NAME = ""lf5_configuration.xml"";
  private static final String NAME = ""name"";
  private static final String PATH = ""path"";
  private static final String SELECTED = ""selected"";
  private static final String EXPANDED = ""expanded"";
  private static final String CATEGORY = ""category"";
  private static final String FIRST_CATEGORY_NAME = ""Categories"";
  private static final String LEVEL = ""level"";
  private static final String COLORLEVEL = ""colorlevel"";
  private static final String COLOR = ""color"";
  private static final String RED = ""red"";
  private static final String GREEN = ""green"";
  private static final String BLUE = ""blue"";
  private static final String COLUMN = ""column"";
  private static final String NDCTEXTFILTER = ""searchtext"";
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private LogBrokerMonitor _monitor = null;
  private LogTable _table = null;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public ConfigurationManager(LogBrokerMonitor monitor, LogTable table) {
    super();
    _monitor = monitor;
    _table = table;
    load();
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  public void save() {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();
    CategoryNode root = model.getRootCategoryNode();
    StringBuffer xml = new StringBuffer(2048);
    openXMLDocument(xml);
    openConfigurationXML(xml);
    processLogRecordFilter(_monitor.getNDCTextFilter(), xml);
    processLogLevels(_monitor.getLogLevelMenuItems(), xml);
    processLogLevelColors(_monitor.getLogLevelMenuItems(),
        LogLevel.getLogLevelColorMap(), xml);
    processLogTableColumns(LogTableColumn.getLogTableColumns(), xml);
    processConfigurationNode(root, xml);
    closeConfigurationXML(xml);
    store(xml.toString());
  }
  public void reset() {
    deleteConfigurationFile();
    collapseTree();
    selectAllNodes();
  }
  public static String treePathToString(TreePath path) {
    // count begins at one so as to not include the 'Categories' - root category
    StringBuffer sb = new StringBuffer();
    CategoryNode n = null;
    Object[] objects = path.getPath();
    for (int i = 1; i < objects.length; i++) {
      n = (CategoryNode) objects[i];
      if (i > 1) {
        sb.append(""."");
      }
      sb.append(n.getTitle());
    }
    return sb.toString();
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  protected void load() {
    File file = new File(getFilename());
    if (file.exists()) {
      try {
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.
            newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        Document doc = docBuilder.parse(file);
        processRecordFilter(doc);
        processCategories(doc);
        processLogLevels(doc);
        processLogLevelColors(doc);
        processLogTableColumns(doc);
      } catch (Exception e) {
        // ignore all error and just continue as if there was no
        // configuration xml file but do report a message
        System.err.println(""Unable process configuration file at "" +
            getFilename() + "". Error Message="" + e.getMessage());
      }
    }
  }
  // Added in version 1.2 - reads in the NDC text filter from the
  // xml configuration file.  If the value of the filter is not null
  // or an empty string ("""") then the manager will set the LogBrokerMonitor's
  // LogRecordFilter to use the NDC LogRecordFilter.  Otherwise, the
  // LogBrokerMonitor will use the default LogRecordFilter.
  protected void processRecordFilter(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(NDCTEXTFILTER);
    // there is only one value stored
    Node n = nodeList.item(0);
    // add check for backwards compatibility  as this feature was added in
    // version 1.2
    if (n == null) {
      return;
    }
    NamedNodeMap map = n.getAttributes();
    String text = getValue(map, NAME);
    if (text == null || text.equals("""")) {
      return;
    }
    _monitor.setNDCLogRecordFilter(text);
  }
  protected void processCategories(Document doc) {
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();
    CategoryExplorerModel model = tree.getExplorerModel();
    NodeList nodeList = doc.getElementsByTagName(CATEGORY);
    // determine where the starting node is
    NamedNodeMap map = nodeList.item(0).getAttributes();
    int j = (getValue(map, NAME).equalsIgnoreCase(FIRST_CATEGORY_NAME)) ? 1 : 0;
    // iterate backwards throught the nodeList so that expansion of the
    // list can occur
    for (int i = nodeList.getLength() - 1; i >= j; i--) {
      Node n = nodeList.item(i);
      map = n.getAttributes();
      CategoryNode chnode = model.addCategory(new CategoryPath(getValue(map, PATH)));
      chnode.setSelected((getValue(map, SELECTED).equalsIgnoreCase(""true"")) ? true : false);
      if (getValue(map, EXPANDED).equalsIgnoreCase(""true"")) ;
      tree.expandPath(model.getTreePathToRoot(chnode));
    }
  }
  protected void processLogLevels(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(LEVEL);
    Map menuItems = _monitor.getLogLevelMenuItems();
    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        JCheckBoxMenuItem item =
            (JCheckBoxMenuItem) menuItems.get(LogLevel.valueOf(name));
        item.setSelected(getValue(map, SELECTED).equalsIgnoreCase(""true""));
      } catch (LogLevelFormatException e) {
        // ignore it will be on by default.
      }
    }
  }
  protected void processLogLevelColors(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(COLORLEVEL);
    Map logLevelColors = LogLevel.getLogLevelColorMap();
    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      // check for backwards compatibility since this feature was added
      // in version 1.3
      if (n == null) {
        return;
      }
      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        LogLevel level = LogLevel.valueOf(name);
        int red = Integer.parseInt(getValue(map, RED));
        int green = Integer.parseInt(getValue(map, GREEN));
        int blue = Integer.parseInt(getValue(map, BLUE));
        Color c = new Color(red, green, blue);
        if (level != null) {
          level.setLogLevelColorMap(level, c);
        }
      } catch (LogLevelFormatException e) {
        // ignore it will be on by default.
      }
    }
  }
  protected void processLogTableColumns(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(COLUMN);
    Map menuItems = _monitor.getLogTableColumnMenuItems();
    List selectedColumns = new ArrayList();
    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      // check for backwards compatibility since this feature was added
      // in version 1.3
      if (n == null) {
        return;
      }
      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        LogTableColumn column = LogTableColumn.valueOf(name);
        JCheckBoxMenuItem item =
            (JCheckBoxMenuItem) menuItems.get(column);
        item.setSelected(getValue(map, SELECTED).equalsIgnoreCase(""true""));
        if (item.isSelected()) {
          selectedColumns.add(column);
        }
      } catch (LogTableColumnFormatException e) {
        // ignore it will be on by default.
      }
      if (selectedColumns.isEmpty()) {
        _table.setDetailedView();
      } else {
        _table.setView(selectedColumns);
      }
    }
  }
  protected String getValue(NamedNodeMap map, String attr) {
    Node n = map.getNamedItem(attr);
    return n.getNodeValue();
  }
  protected void collapseTree() {
    // collapse everything except the first category
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();
    for (int i = tree.getRowCount() - 1; i > 0; i--) {
      tree.collapseRow(i);
    }
  }
  protected void selectAllNodes() {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();
    CategoryNode root = model.getRootCategoryNode();
    Enumeration all = root.breadthFirstEnumeration();
    CategoryNode n = null;
    while (all.hasMoreElements()) {
      n = (CategoryNode) all.nextElement();
      n.setSelected(true);
    }
  }
  protected void store(String s) {
    try {
      PrintWriter writer = new PrintWriter(new FileWriter(getFilename()));
      writer.print(s);
      writer.close();
    } catch (IOException e) {
      // do something with this error.
      e.printStackTrace();
    }
  }
  protected void deleteConfigurationFile() {
    try {
      File f = new File(getFilename());
      if (f.exists()) {
        f.delete();
      }
    } catch (SecurityException e) {
      System.err.println(""Cannot delete "" + getFilename() +
          "" because a security violation occured."");
    }
  }
  protected String getFilename() {
    String home = System.getProperty(""user.home"");
    String sep = (home.startsWith(MRUFileManager.UNIX_SEPARATOR))
        ? MRUFileManager.UNIX_SEPARATOR : MRUFileManager.DOS_SEPARATOR;
    return home + sep + ""lf5"" + sep + CONFIG_FILE_NAME;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  private void processConfigurationNode(CategoryNode node, StringBuffer xml) {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();
    Enumeration all = node.breadthFirstEnumeration();
    CategoryNode n = null;
    while (all.hasMoreElements()) {
      n = (CategoryNode) all.nextElement();
      exportXMLElement(n, model.getTreePathToRoot(n), xml);
    }
  }
  private void processLogLevels(Map logLevelMenuItems, StringBuffer xml) {
    xml.append(""\t<loglevels>\r\n"");
    Iterator it = logLevelMenuItems.keySet().iterator();
    while (it.hasNext()) {
      LogLevel level = (LogLevel) it.next();
      JCheckBoxMenuItem item = (JCheckBoxMenuItem) logLevelMenuItems.get(level);
      exportLogLevelXMLElement(level.getLabel(), item.isSelected(), xml);
    }
    xml.append(""\t</loglevels>\r\n"");
  }
  private void processLogLevelColors(Map logLevelMenuItems, Map logLevelColors, StringBuffer xml) {
    xml.append(""\t<loglevelcolors>\r\n"");
    // iterate through the list of log levels being used (log4j, jdk1.4, custom levels)
    Iterator it = logLevelMenuItems.keySet().iterator();
    while (it.hasNext()) {
      LogLevel level = (LogLevel) it.next();
      // for each level, get the associated color from the log level color map
      Color color = (Color) logLevelColors.get(level);
      exportLogLevelColorXMLElement(level.getLabel(), color, xml);
    }
    xml.append(""\t</loglevelcolors>\r\n"");
  }
  private void processLogTableColumns(List logTableColumnMenuItems, StringBuffer xml) {
    xml.append(""\t<logtablecolumns>\r\n"");
    Iterator it = logTableColumnMenuItems.iterator();
    while (it.hasNext()) {
      LogTableColumn column = (LogTableColumn) it.next();
      JCheckBoxMenuItem item = _monitor.getTableColumnMenuItem(column);
      exportLogTableColumnXMLElement(column.getLabel(), item.isSelected(), xml);
    }
    xml.append(""\t</logtablecolumns>\r\n"");
  }
  // Added in version 1.2 - stores the NDC text filter in the xml file
  // for future use.
  private void processLogRecordFilter(String text, StringBuffer xml) {
    xml.append(""\t<"").append(NDCTEXTFILTER).append("" "");
    xml.append(NAME).append(""=\"""").append(text).append(""\"""");
    xml.append(""/>\r\n"");
  }
  private void openXMLDocument(StringBuffer xml) {
    xml.append(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\r\n"");
  }
  private void openConfigurationXML(StringBuffer xml) {
    xml.append(""<configuration>\r\n"");
  }
  private void closeConfigurationXML(StringBuffer xml) {
    xml.append(""</configuration>\r\n"");
  }
  private void exportXMLElement(CategoryNode node, TreePath path, StringBuffer xml) {
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();
    xml.append(""\t<"").append(CATEGORY).append("" "");
    xml.append(NAME).append(""=\"""").append(node.getTitle()).append(""\"" "");
    xml.append(PATH).append(""=\"""").append(treePathToString(path)).append(""\"" "");
    xml.append(EXPANDED).append(""=\"""").append(tree.isExpanded(path)).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(node.isSelected()).append(""\""/>\r\n"");
  }
  private void exportLogLevelXMLElement(String label, boolean selected, StringBuffer xml) {
    xml.append(""\t\t<"").append(LEVEL).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(selected);
    xml.append(""\""/>\r\n"");
  }
  private void exportLogLevelColorXMLElement(String label, Color color, StringBuffer xml) {
    xml.append(""\t\t<"").append(COLORLEVEL).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(RED).append(""=\"""").append(color.getRed()).append(""\"" "");
    xml.append(GREEN).append(""=\"""").append(color.getGreen()).append(""\"" "");
    xml.append(BLUE).append(""=\"""").append(color.getBlue());
    xml.append(""\""/>\r\n"");
  }
  private void exportLogTableColumnXMLElement(String label, boolean selected, StringBuffer xml) {
    xml.append(""\t\t<"").append(COLUMN).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(selected);
    xml.append(""\""/>\r\n"");
  }
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces:
  //--------------------------------------------------------------------------
}
"
org.apache.log4j.lf5.viewer.configure.MRUFileManager,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.
 */
package org.apache.log4j.lf5.viewer.configure;
import java.io.*;
import java.net.URL;
import java.util.Iterator;
import java.util.LinkedList;
/**
 * <p>MRUFileManager handles the storage and retrival the most
 * recently opened log files.
 *
 * @author Brad Marlborough
 * @author Richard Hurst
 */
// Contributed by ThoughtWorks Inc.
public class MRUFileManager {
  //--------------------------------------------------------------------------
  //   Constants:
  //--------------------------------------------------------------------------
  private static final String CONFIG_FILE_NAME = ""mru_file_manager"";
  private static final int DEFAULT_MAX_SIZE = 3;
  public static final String UNIX_SEPARATOR = ""/"";
  public static final String DOS_SEPARATOR = ""\\"";
  //--------------------------------------------------------------------------
  //   Protected Variables:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Private Variables:
  //--------------------------------------------------------------------------
  private int _maxSize = 0;
  private LinkedList _mruFileList;
  //--------------------------------------------------------------------------
  //   Constructors:
  //--------------------------------------------------------------------------
  public MRUFileManager() {
    load();
    setMaxSize(DEFAULT_MAX_SIZE);
  }
  public MRUFileManager(int maxSize) {
    load();
    setMaxSize(maxSize);
  }
  //--------------------------------------------------------------------------
  //   Public Methods:
  //--------------------------------------------------------------------------
  /**
   * Saves a list of MRU files out to a file.
   */
  public void save() {
    File file = new File(getFilename());
    try {
      ObjectOutputStream oos = new ObjectOutputStream(new
          FileOutputStream(file));
      oos.writeObject(_mruFileList);
      oos.flush();
      oos.close();
    } catch (Exception e) {
      // do nothing
      e.printStackTrace();
    }
  }
  /**
   * Gets the size of the MRU file list.
   */
  public int size() {
    return _mruFileList.size();
  }
  /**
   * Returns a particular file name stored in a MRU file
   * list based on an index value.
   */
  public Object getFile(int index) {
    if (index < size()) {
      return _mruFileList.get(index);
    }
    return null;
  }
  /**
   * Returns a input stream to the resource at the specified index
   */
  public InputStream getInputStream(int index) throws IOException,
      FileNotFoundException {
    if (index < size()) {
      Object o = getFile(index);
      if (o instanceof File) {
        return getInputStream((File) o);
      } else {
        return getInputStream((URL) o);
      }
    }
    return null;
  }
  /**
   * Adds a file name to the MRU file list.
   */
  public void set(File file) {
    setMRU(file);
  }
  /**
   * Adds a url to the MRU file list.
   */
  public void set(URL url) {
    setMRU(url);
  }
  /**
   * Gets the list of files stored in the MRU file list.
   */
  public String[] getMRUFileList() {
    if (size() == 0) {
      return null;
    }
    String[] ss = new String[size()];
    for (int i = 0; i < size(); i++) {
      Object o = getFile(i);
      if (o instanceof File) {
        ss[i] = ((File) o).getAbsolutePath();
      } else // must be a url
      {
        ss[i] = o.toString();
      }
    }
    return ss;
  }
  /**
   * Moves the the index to the top of the MRU List
   *
   * @param index The index to be first in the mru list
   */
  public void moveToTop(int index) {
    _mruFileList.add(0, _mruFileList.remove(index));
  }
  /**
   * Creates the directory where the MRU file list will be written.
   * The ""lf5"" directory is created in the Documents and Settings
   * directory on Windows 2000 machines and where ever the user.home
   * variable points on all other platforms.
   */
  public static void createConfigurationDirectory() {
    String home = System.getProperty(""user.home"");
    String sep = (home.startsWith(UNIX_SEPARATOR)) ? UNIX_SEPARATOR : DOS_SEPARATOR;
    File f = new File(home + sep + ""lf5"");
    if (!f.exists()) {
      try {
        f.mkdir();
      } catch (SecurityException e) {
        e.printStackTrace();
      }
    }
  }
  //--------------------------------------------------------------------------
  //   Protected Methods:
  //--------------------------------------------------------------------------
  /**
   * Gets an input stream for the corresponding file.
   *
   * @param file The file to create the input stream from.
   * @return InputStream
   */
  protected InputStream getInputStream(File file) throws IOException,
      FileNotFoundException {
    BufferedInputStream reader =
        new BufferedInputStream(new FileInputStream(file));
    return reader;
  }
  /**
   * Gets an input stream for the corresponding URL.
   *
   * @param url The url to create the input stream from.
   * @return InputStream
   */
  protected InputStream getInputStream(URL url) throws IOException {
    return url.openStream();
  }
  /**
   * Adds an object to the mru.
   */
  protected void setMRU(Object o) {
    int index = _mruFileList.indexOf(o);
    if (index == -1) {
      _mruFileList.add(0, o);
      setMaxSize(_maxSize);
    } else {
      moveToTop(index);
    }
  }
  /**
   * Loads the MRU file list in from a file and stores it in a LinkedList.
   * If no file exists, a new LinkedList is created.
   */
  protected void load() {
    createConfigurationDirectory();
    File file = new File(getFilename());
    if (file.exists()) {
      try {
        ObjectInputStream ois = new ObjectInputStream(
            new FileInputStream(file));
        _mruFileList = (LinkedList) ois.readObject();
        ois.close();
        // check that only files and url are in linked list
        Iterator it = _mruFileList.iterator();
        while (it.hasNext()) {
          Object o = it.next();
          if (!(o instanceof File) && !(o instanceof URL)) {
            it.remove();
          }
        }
      } catch (Exception e) {
        _mruFileList = new LinkedList();
      }
    } else {
      _mruFileList = new LinkedList();
    }
  }
  protected String getFilename() {
    String home = System.getProperty(""user.home"");
    String sep = (home.startsWith(UNIX_SEPARATOR)) ? UNIX_SEPARATOR : DOS_SEPARATOR;
    return home + sep + ""lf5"" + sep + CONFIG_FILE_NAME;
  }
  /**
   * Ensures that the MRU list will have a MaxSize.
   */
  protected void setMaxSize(int maxSize) {
    if (maxSize < _mruFileList.size()) {
      for (int i = 0; i < _mruFileList.size() - maxSize; i++) {
        _mruFileList.removeFirst();
      }
    }
    _maxSize = maxSize;
  }
  //--------------------------------------------------------------------------
  //   Private Methods:
  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //   Nested Top-Level Classes or Interfaces
  //--------------------------------------------------------------------------
}"
org.apache.log4j.net.JMSAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.LogLog;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple appender based on JMS.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSAppender extends AppenderSkeleton {
  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;
  String topicBindingName;
  String tcfBindingName;
  boolean locationInfo;
  public
  JMSAppender() {
  }
  /**
     The <b>TopicConnectionFactoryBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>TopicConnectionFactory</code> from the JNDI context.
   */
  public
  void setTopicConnectionFactoryBindingName(String tcfBindingName) {
    this.tcfBindingName = tcfBindingName;
  }
  /**
     Returns the value of the <b>TopicConnectionFactoryBindingName</b> option.
   */
  public
  String getTopicConnectionFactoryBindingName() {
    return tcfBindingName;
  }
  /**
     The <b>TopicBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>Topic</code> from the JNDI context.
   */
  public
  void setTopicBindingName(String topicBindingName) {
    this.topicBindingName = topicBindingName;
  }
  /**
     Returns the value of the <b>TopicBindingName</b> option.
   */
  public
  String getTopicBindingName() {
    return topicBindingName;
  }
  /**
     Returns value of the <b>LocationInfo</b> property which
     determines whether location (stack) info is sent to the remote
     subscriber. */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  public
  void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;
    try {
      Context ctx = new InitialContext();
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, tcfBindingName);
      topicConnection = topicConnectionFactory.createTopicConnection();
      topicConnection.start();
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic) lookup(ctx, topicBindingName);
      topicPublisher = topicSession.createPublisher(topic);
      ctx.close();
    } catch(Exception e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }
  protected
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }
  }
  protected
  boolean checkEntryConditions() {
    String fail = null;
    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    }
    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");
      return false;
    } else {
      return true;
    }
  }
  /**
     Close this JMSAppender. Closing releases all resources used by the
     appender. A closed appender cannot be re-opened. */
  public
  synchronized // avoid concurrent append and close operations
  void close() {
    if(this.closed)
      return;
    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;
    try {
      if(topicSession != null)
	topicSession.close();
      if(topicConnection != null)
	topicConnection.close();
    } catch(Exception e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);
    }
    // Help garbage collection
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }
  /**
     This method called by {@link AppenderSkeleton#doAppend} method to
     do most of the real appending work.  */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      if(locationInfo) {
	event.getLocationInformation();
      }
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(Exception e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e,
			 ErrorCode.GENERIC_FAILURE);
    }
  }
  /**
      If true, the information sent to the remote subscriber will include
      location information. By default no location information is sent
      to the subscriber.  */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  public
  boolean requiresLayout() {
    return false;
  }
}
"
org.apache.log4j.net.JMSSink,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.net;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.LogManager;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.or.jms.MessageRenderer;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple application receiving the logging events sent by a JMSAppender.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSSink  {
  static public void main(String[] args) {
    if(args.length != 3) {
      usage(""Wrong number of arguments."");
    }
    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    PropertyConfigurator.configure(args[2]);
    LoggerRepository rep = LogManager.getLoggerRepository();
    if(rep instanceof RendererSupport) {
      ((RendererSupport) rep).setRenderer(Message.class, new MessageRenderer());
    }
    try {
      Context ctx = new InitialContext();
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx,
                                                               tcfBindingName);
      TopicConnection topicConnection =
	                        topicConnectionFactory.createTopicConnection();
      topicConnection.start();
      TopicSession topicSession = topicConnection.createTopicSession(false,
                                                       Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic)ctx.lookup(topicBindingName);
      //TopicSubscriber topicSubscriber = topicSession.createSubscriber(topic);
      TopicSubscriber topicSubscriber =
           topicSession.createDurableSubscriber(topic, ""x"");
      LoggingEvent event;
      Category remoteCategory;
      while(true) {
	ObjectMessage msg = (ObjectMessage)topicSubscriber.receive();
	event = (LoggingEvent) msg.getObject();
	remoteCategory = Category.getInstance(event.categoryName);
	remoteCategory.callAppenders(event);
	// dump the JMSMessage
	// remoteCategory.debug(msg);
      }
    } catch(Exception e) {
      LogLog.error(""Could not read JMS message."", e);
    }
  }
  protected
  static
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.SimpleSocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import org.apache.log4j.Category;
import org.apache.log4j.LogManager;
import org.apache.log4j.PropertyConfigurator;
/**
   A simple {@link SocketNode} based server.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SimpleSocketServer port configFile
     where <em>port</em> is a part number where the server listens and
     <em>configFile</em> is a configuration file fed to the {@link
     PropertyConfigurator}.
   </pre>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SimpleSocketServer  {
  static Category cat = Category.getInstance(SimpleSocketServer.class.getName());
  static int port;
  public
  static
  void main(String argv[]) {
    if(argv.length == 2)
      init(argv[0], argv[1]);
    else
      usage(""Wrong number of arguments."");
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");
	new Thread(new SocketNode(socket,
				  LogManager.getLoggerRepository())).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);
  }
}
"
org.apache.log4j.net.SMTPAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Level;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import java.util.Properties;
import java.util.Date;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;
/**
   Send an e-mail when a specific logging event occurs, typically on
   errors or fatal errors.
   <p>The number of logging events delivered in this e-mail depend on
   the value of <b>BufferSize</b> option. The
   <code>SMTPAppender</code> keeps only the last
   <code>BufferSize</code> logging events in its cyclic buffer. This
   keeps memory requirements at a reasonable level while still
   delivering useful application context.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class SMTPAppender extends AppenderSkeleton {
  private String to;
  private String from;
  private String subject;
  private String smtpHost;
  private int bufferSize = 512;
  private boolean locationInfo = false;
  protected CyclicBuffer cb = new CyclicBuffer(bufferSize);
  protected Message msg;
  protected TriggeringEventEvaluator evaluator;
  /**
     The default constructor will instantiate the appender with a
     {@link TriggeringEventEvaluator} that will trigger on events with
     level ERROR or higher.*/
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }
  /**
     Use <code>evaluator</code> passed as parameter as the {@link
     TriggeringEventEvaluator} for this SMTPAppender.  */
  public
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }
  /**
     Activate the specified options, such as the smtp host, the
     recipient, from, etc. */
  public
  void activateOptions() {
    Properties props = new Properties (System.getProperties());
    if (smtpHost != null)
      props.put(""mail.smtp.host"", smtpHost);
    Session session = Session.getInstance(props, null);
    //session.setDebug(true);
    msg = new MimeMessage(session);
     try {
       if (from != null)
	 msg.setFrom(getAddress(from));
       else
	 msg.setFrom();
       msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       if(subject != null)
	 msg.setSubject(subject);
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }
  }
  /**
     Perform SMTPAppender specific appending actions, mainly adding
     the event to a cyclic buffer and checking if the event triggers
     an e-mail to be sent. */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    event.getThreadName();
    event.getNDC();
    if(locationInfo) {
      event.getLocationInformation();
    }
    cb.add(event);
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }
 /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }
    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }
  synchronized
  public
  void close() {
    this.closed = true;
  }
  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
  /**
     Returns value of the <b>To</b> option.
   */
  public
  String getTo() {
    return to;
  }
  /**
     The <code>SMTPAppender</code> requires a {@link
     org.apache.log4j.Layout layout}.  */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Send the contents of the cyclic buffer as an e-mail message.
   */
  protected
  void sendBuffer() {
    // Note: this code already owns the monitor for this
    // appender. This frees us from needing to synchronize on 'cb'.
    try {
      MimeBodyPart part = new MimeBodyPart();
      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length();
      for(int i = 0; i < len; i++) {
	//sbuf.append(MimeUtility.encodeText(layout.format(cb.get())));
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null)
	sbuf.append(t);
      part.setContent(sbuf.toString(), layout.getContentType());
      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);
      msg.setSentDate(new Date());
      Transport.send(msg);
    } catch(Exception e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }
  /**
     Returns value of the <b>EvaluatorClass</b> option.
   */
  public
  String getEvaluatorClass() {
    return evaluator == null ? null : evaluator.getClass().getName();
  }
  /**
     Returns value of the <b>From</b> option.
   */
  public
  String getFrom() {
    return from;
  }
  /**
     Returns value of the <b>Subject</b> option.
   */
  public
  String getSubject() {
    return subject;
  }
  /**
     The <b>From</b> option takes a string value which should be a
     e-mail address of the sender.
   */
  public
  void setFrom(String from) {
    this.from = from;
  }
  /**
     The <b>Subject</b> option takes a string value which should be a
     the subject of the e-mail message.
   */
  public
  void setSubject(String subject) {
    this.subject = subject;
  }
  /**
     The <b>BufferSize</b> option takes a positive integer
     representing the maximum number of logging events to collect in a
     cyclic buffer. When the <code>BufferSize</code> is reached,
     oldest events are deleted as new events are added to the
     buffer. By default the size of the cyclic buffer is 512 events.
   */
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
    cb.resize(bufferSize);
  }
  /**
     The <b>SMTPHost</b> option takes a string value which should be a
     the host name of the SMTP server that will send the e-mail message.
   */
  public
  void setSMTPHost(String smtpHost) {
    this.smtpHost = smtpHost;
  }
  /**
     Returns value of the <b>SMTPHost</b> option.
   */
  public
  String getSMTPHost() {
    return smtpHost;
  }
  /**
     The <b>To</b> option takes a string value which should be a
     comma separated list of e-mail address of the recipients.
   */
  public
  void setTo(String to) {
    this.to = to;
  }
  /**
     Returns value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bufferSize;
  }
  /**
     The <b>EvaluatorClass</b> option takes a string value
     representing the name of the class implementing the {@link
     TriggeringEventEvaluator} interface. A corresponding object will
     be instantiated and assigned as the triggering event evaluator
     for the SMTPAppender.
   */
  public
  void setEvaluatorClass(String value) {
      evaluator = (TriggeringEventEvaluator)
                OptionConverter.instantiateByClassName(value,
					   TriggeringEventEvaluator.class,
						       evaluator);
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the layout that formats the events as they are sent out
     in an e-mail is likely to place the wrong location information
     (if present in the format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
}
class DefaultEvaluator implements TriggeringEventEvaluator {
  /**
     Is this <code>event</code> the e-mail triggering event?
     <p>This method returns <code>true</code>, if the event level
     has ERROR level or higher. Otherwise it returns
     <code>false</code>. */
  public
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.level.isGreaterOrEqual(Level.ERROR);
  }
}
"
org.apache.log4j.net.SocketAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// Contributors: Dan MacDonald <dan@redknee.com>
package org.apache.log4j.net;
import java.net.InetAddress;
import java.net.Socket;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.AppenderSkeleton;
/**
    Sends {@link LoggingEvent} objects to a remote a log server,
    usually a {@link SocketNode}.
    <p>The SocketAppender has the following properties:
    <ul>
      <p><li>If sent to a {@link SocketNode}, remote logging is
      non-intrusive as far as the log event is concerned. In other
      words, the event will be logged with the same time stamp, {@link
      org.apache.log4j.NDC}, location info as if it were logged locally by
      the client.
      <p><li>SocketAppenders do not use a layout. They ship a
      serialized {@link LoggingEvent} object to the server side.
      <p><li>Remote logging uses the TCP protocol. Consequently, if
      the server is reachable, then log events will eventually arrive
      at the server.
      <p><li>If the remote server is down, the logging requests are
      simply dropped. However, if and when the server comes back up,
      then event transmission is resumed transparently. This
      transparent reconneciton is performed by a <em>connector</em>
      thread which periodically attempts to connect to the server.
      <p><li>Logging events are automatically <em>buffered</em> by the
      native TCP implementation. This means that if the link to server
      is slow but still faster than the rate of (log) event production
      by the client, the client will not be affected by the slow
      network connection. However, if the network connection is slower
      then the rate of event production, then the client can only
      progress at the network rate. In particular, if the network link
      to the the server is down, the client will be blocked.
      <p>On the other hand, if the network link is up, but the server
      is down, the client will not be blocked when making log requests
      but the log events will be lost due to server unavailability.
      <p><li>Even if a <code>SocketAppender</code> is no longer
      attached to any category, it will not be garbage collected in
      the presence of a connector thread. A connector thread exists
      only if the connection to the server is down. To avoid this
      garbage collection problem, you should {@link #close} the the
      <code>SocketAppender</code> explicitly. See also next item.
      <p>Long lived applications which create/destroy many
      <code>SocketAppender</code> instances should be aware of this
      garbage collection problem. Most other applications can safely
      ignore it.
      <p><li>If the JVM hosting the <code>SocketAppender</code> exits
      before the <code>SocketAppender</code> is closed either
      explicitly or subsequent to garbage collection, then there might
      be untransmitted data in the pipe which might be lost. This is a
      common problem on Windows based systems.
      <p>To avoid lost data, it is usually sufficient to {@link
      #close} the <code>SocketAppender</code> either explicitly or by
      calling the {@link org.apache.log4j.LogManager#shutdown} method
      before exiting the application.
     </ul>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SocketAppender extends AppenderSkeleton {
  /**
     The default port number of remote logging server (4560).
  */
  static final int DEFAULT_PORT                 = 4560;
  /**
     The default reconnection delay (30000 milliseconds or 30 seconds).
  */
  static final int DEFAULT_RECONNECTION_DELAY   = 30000;
  /**
     We remember host name as String in addition to the resolved
     InetAddress so that it can be returned via getOption().
  */
  String remoteHost;
  InetAddress address;
  int port = DEFAULT_PORT;
  ObjectOutputStream oos;
  int reconnectionDelay = DEFAULT_RECONNECTION_DELAY;
  boolean locationInfo = false;
  private Connector connector;
  int counter = 0;
  // reset the ObjectOutputStream every 70 calls
  //private static final int RESET_FREQUENCY = 70;
  private static final int RESET_FREQUENCY = 1;
  public SocketAppender() {
  }
  /**
     Connects to remote server at <code>address</code> and <code>port</code>.
  */
  public
  SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.remoteHost = address.getHostName();
    this.port = port;
    connect(address, port);
  }
  /**
     Connects to remote server at <code>host</code> and <code>port</code>.
  */
  public
  SocketAppender(String host, int port) {
    this.port = port;
    this.address = getAddressByName(host);
    this.remoteHost = host;
    connect(address, port);
  }
  /**
     Connect to the specified <b>RemoteHost</b> and <b>Port</b>.
  */
  public
  void activateOptions() {
    connect(address, port);
  }
  /**
     Close this appender.
     <p>This will mark the appender as closed and
     call then {@link #cleanUp} method.
  */
  synchronized
  public
  void close() {
    if(closed)
      return;
    this.closed = true;
    cleanUp();
  }
  /**
     Drop the connection to the remote host and release the underlying
     connector thread if it has been created
   */
  public
  void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      }
      catch(IOException e) {
	LogLog.error(""Could not close oos."", e);
      }
      oos = null;
    }
    if(connector != null) {
      //LogLog.debug(""Interrupting the connector."");
      connector.interrupted = true;
      connector = null;  // allow gc
    }
  }
  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      // First, close the previous connection if any.
      cleanUp();
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    }
    catch(IOException e) {
      LogLog.error(""Could not connect to remote log4j server at [""
		   +address.getHostName()+""]. We will try again later."", e);
      fireConnector();
    }
  }
  public
  void append(LoggingEvent event) {
    if(event == null)
      return;
    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppender named \""""+
			this.name+""\""."");
      return;
    }
    if(oos != null) {
      try {
	if(locationInfo) {
	   event.getLocationInformation();
	}
	oos.writeObject(event);
	//LogLog.debug(""=========Flushing."");
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  // Failing to reset the object output stream every now and
	  // then creates a serious memory leak.
	  //System.err.println(""Doing oos.reset()"");
	  oos.reset();
	}
      }
      catch(IOException e) {
	oos = null;
	LogLog.warn(""Detected problem with connection: ""+e);
	if(reconnectionDelay > 0) {
	  fireConnector();
	}
      }
    }
  }
  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();
    }
  }
  static
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    }
    catch(Exception e) {
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }
  /**
     The SocketAppender does not use a layout. Hence, this method returns
     <code>false</code>.
  */
  public
  boolean requiresLayout() {
    return false;
  }
  /**
     The <b>RemoteHost</b> option takes a string value which should be
     the host name of the server where a {@link SocketNode} is running.
   */
  public
  void setRemoteHost(String host) {
    address = getAddressByName(host);
    remoteHost = host;
  }
  /**
     Returns value of the <b>RemoteHost</b> option.
   */
  public
  String getRemoteHost() {
    return remoteHost;
  }
  /**
     The <b>Port</b> option takes a positive integer representing
     the port where the server is waiting for connections.
   */
  public
  void setPort(int port) {
    this.port = port;
  }
  /**
     Returns value of the <b>Port</b> option.
   */
  public
  int getPort() {
    return port;
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. If true,
     the information sent to the remote host will include location
     information. By default no location information is sent to the server.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
     The <b>ReconnectionDelay</b> option takes a positive integer
     representing the number of milliseconds to wait between each
     failed connection attempt to the server. The default value of
     this option is 30000 which corresponds to 30 seconds.
     <p>Setting this option to zero turns off reconnection
     capability.
   */
  public
  void setReconnectionDelay(int delay) {
    this.reconnectionDelay = delay;
  }
  /**
     Returns value of the <b>ReconnectionDelay</b> option.
   */
  public
  int getReconnectionDelay() {
    return reconnectionDelay;
  }
  /**
     The Connector will reconnect when the server becomes available
     again.  It does this by attempting to open a new connection every
     <code>reconnectionDelay</code> milliseconds.
     <p>It stops trying whenever a connection is established. It will
     restart to try reconnect to the server when previpously open
     connection is droppped.
     @author  Ceki G&uuml;lc&uuml;
     @since 0.8.4
  */
  class Connector extends Thread {
    boolean interrupted = false;
    public
    void run() {
      Socket socket;
      while(!interrupted) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream());
	    connector = null;
	    break;
	  }
	}
	catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	}
	catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	}
	catch(IOException e) {
	  LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      //LogLog.debug(""Exiting Connector.run() method."");
    }
    /**
       public
       void finalize() {
       LogLog.debug(""Connector finalize() has been called."");
       }
    */
  }
}
"
org.apache.log4j.net.SocketHubAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.net;
import java.util.Vector;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.SocketException;
import java.io.ObjectOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetAddress;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.AppenderSkeleton;
/**
  Sends {@link LoggingEvent} objects to a set of remote log servers,
  usually a {@link SocketNode SocketNodes}.
  <p>Acts just like {@link SocketAppender} except that instead of
  connecting to a given remote log server,
  <code>SocketHubAppender</code> accepts connections from the remote
  log servers as clients.  It can accept more than one connection.
  When a log event is received, the event is sent to the set of
  currently connected remote log servers. Implemented this way it does
  not require any update to the configuration file to send data to
  another remote log server. The remote log server simply connects to
  the host and port the <code>SocketHubAppender</code> is running on.
  <p>The <code>SocketHubAppender</code> does not store events such
  that the remote side will events that arrived after the
  establishment of its connection. Once connected, events arrive in
  order as guaranteed by the TCP protocol.
  <p>This implementation borrows heavily from the {@link
  SocketAppender}.
  <p>The SocketHubAppender has the following characteristics:
  <ul>
  <p><li>If sent to a {@link SocketNode}, logging is non-intrusive as
  far as the log event is concerned. In other words, the event will be
  logged with the same time stamp, {@link org.apache.log4j.NDC},
  location info as if it were logged locally.
  <p><li><code>SocketHubAppender</code> does not use a layout. It
  ships a serialized {@link LoggingEvent} object to the remote side.
  <p><li><code>SocketHubAppender</code> relies on the TCP
  protocol. Consequently, if the remote side is reachable, then log
  events will eventually arrive at remote client.
  <p><li>If no remote clients are attached, the logging requests are
  simply dropped.
  <p><li>Logging events are automatically <em>buffered</em> by the
  native TCP implementation. This means that if the link to remote
  client is slow but still faster than the rate of (log) event
  production, the application will not be affected by the slow network
  connection. However, if the network connection is slower then the
  rate of event production, then the local application can only
  progress at the network rate. In particular, if the network link to
  the the remote client is down, the application will be blocked.
  <p>On the other hand, if the network link is up, but the remote
  client is down, the client will not be blocked when making log
  requests but the log events will be lost due to client
  unavailability. 
  <p>The single remote client case extends to multiple clients
  connections. The rate of logging will be determined by the slowest
  link.
  <p><li>If the JVM hosting the <code>SocketHubAppender</code> exits
  before the <code>SocketHubAppender</code> is closed either
  explicitly or subsequent to garbage collection, then there might
  be untransmitted data in the pipe which might be lost. This is a
  common problem on Windows based systems.
  <p>To avoid lost data, it is usually sufficient to {@link #close}
  the <code>SocketHubAppender</code> either explicitly or by calling
  the {@link org.apache.log4j.LogManager#shutdown} method before
  exiting the application.
  </ul>
  @author Mark Womack */
public class SocketHubAppender extends AppenderSkeleton {
  /**
     The default port number of the ServerSocket will be created on. */
  static final int DEFAULT_PORT = 4560;
  private int port = DEFAULT_PORT;
  private Vector oosList = new Vector();
  private ServerMonitor serverMonitor = null;
  private boolean locationInfo = false;
  public SocketHubAppender() { }
  /**
     Connects to remote server at <code>address</code> and <code>port</code>. */
  public
  SocketHubAppender(int _port) {
    port = _port;
    startServer();
  }
  /**
     Set up the socket server on the specified port.  */
  public
  void activateOptions() {
    startServer();
  }
  /**
     Close this appender. 
     <p>This will mark the appender as closed and
     call then {@link #cleanUp} method. */
  synchronized
  public
  void close() {
    if(closed)
      return;
	LogLog.debug(""closing SocketHubAppender "" + getName());
    this.closed = true;
    cleanUp();
	LogLog.debug(""SocketHubAppender "" + getName() + "" closed"");
  }
  /**
     Release the underlying ServerMonitor thread, and drop the connections
     to all connected remote servers. */
  public 
  void cleanUp() {
    // stop the monitor thread
	LogLog.debug(""stopping ServerSocket"");
    serverMonitor.stopMonitor();
    serverMonitor = null;
    // close all of the connections
	LogLog.debug(""closing client connections"");
    while (oosList.size() != 0) {
      ObjectOutputStream oos = (ObjectOutputStream)oosList.elementAt(0);
      if(oos != null) {
        try {
        	oos.close();
        }
        catch(IOException e) {
        	LogLog.error(""could not close oos."", e);
        }
        oosList.removeElementAt(0);     
      }
    }
  }
  /**
    Append an event to all of current connections. */
  public
  void append(LoggingEvent event) {
	// if no event or no open connections, exit now
    if(event == null || oosList.size() == 0)
      return;
    // set up location info if requested
    if (locationInfo) {
    	event.getLocationInformation();	
    } 
	// loop through the current set of open connections, appending the event to each
    for (int streamCount = 0; streamCount < oosList.size(); streamCount++) {    	
      ObjectOutputStream oos = null;
      try {
        oos = (ObjectOutputStream)oosList.elementAt(streamCount);
      }
      catch (ArrayIndexOutOfBoundsException e) {
        // catch this, but just don't assign a value
        // this should not really occur as this method is
        // the only one that can remove oos's (besides cleanUp).
      }
      // list size changed unexpectedly? Just exit the append.
      if (oos == null)
        break;
      try {
      	oos.writeObject(event);
      	oos.flush();
    	// Failing to reset the object output stream every now and
    	// then creates a serious memory leak.
    	// right now we always reset. TODO - set up frequency counter per oos?
    	oos.reset();
      }
      catch(IOException e) {
      	// there was an io exception so just drop the connection
      	oosList.removeElementAt(streamCount);
      	LogLog.debug(""dropped connection"");
      	// decrement to keep the counter in place (for loop always increments)
      	streamCount--;
      }
    }
  }
  /**
     The SocketHubAppender does not use a layout. Hence, this method returns
     <code>false</code>. */
  public
  boolean requiresLayout() {
    return false;
  }
  /**
     The <b>Port</b> option takes a positive integer representing
     the port where the server is waiting for connections. */
  public
  void setPort(int _port) {
    port = _port;
  }
  /**
     Returns value of the <b>Port</b> option. */
  public
  int getPort() {
    return port;
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. If true,
     the information sent to the remote host will include location
     information. By default no location information is sent to the server. */
  public
  void setLocationInfo(boolean _locationInfo) {
    locationInfo = _locationInfo;
  }
  /**
     Returns value of the <b>LocationInfo</b> option. */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
    Start the ServerMonitor thread. */
  private
  void startServer() {
    serverMonitor = new ServerMonitor(port, oosList);
  }
  /**
    This class is used internally to monitor a ServerSocket
    and register new connections in a vector passed in the
    constructor. */
  private
  class ServerMonitor implements Runnable {
    private int port;
    private Vector oosList;
    private boolean keepRunning;
    private Thread monitorThread;
    /**
      Create a thread and start the monitor. */
    public
    ServerMonitor(int _port, Vector _oosList) {
      port = _port;
      oosList = _oosList;
      keepRunning = true;
      monitorThread = new Thread(this);
      monitorThread.setDaemon(true);
      monitorThread.start();
    }
    /**
      Stops the monitor. This method will not return until
      the thread has finished executing. */
    public
    synchronized
    void stopMonitor() {
      if (keepRunning) {
    	LogLog.debug(""server monitor thread shutting down"");
        keepRunning = false;
        try {
          monitorThread.join();
        }
        catch (InterruptedException e) {
          // do nothing?
        }
        // release the thread
        monitorThread = null;
    	LogLog.debug(""server monitor thread shut down"");
      }
    }
    /**
      Method that runs, monitoring the ServerSocket and adding connections as
      they connect to the socket. */
    public
    void run() {
      ServerSocket serverSocket = null;
      try {
        serverSocket = new ServerSocket(port);
        serverSocket.setSoTimeout(1000);
      }
      catch (Exception e) {
        LogLog.error(""exception setting timeout, shutting down server socket."", e);
        keepRunning = false;
        return;
      }
      try {
    	try {
        	serverSocket.setSoTimeout(1000);
    	}
    	catch (SocketException e) {
          LogLog.error(""exception setting timeout, shutting down server socket."", e);
          return;
    	}
    	while (keepRunning) {
          Socket socket = null;
          try {
            socket = serverSocket.accept();
          }
          catch (InterruptedIOException e) {
            // timeout occurred, so just loop
          }
          catch (SocketException e) {
            LogLog.error(""exception accepting socket, shutting down server socket."", e);
            keepRunning = false;
          }
          catch (IOException e) {
            LogLog.error(""exception accepting socket."", e);
          }
          // if there was a socket accepted
          if (socket != null) {
            try {
              InetAddress remoteAddress = socket.getInetAddress();
              LogLog.debug(""accepting connection from "" + remoteAddress.getHostName() 
			   + "" ("" + remoteAddress.getHostAddress() + "")"");
              // create an ObjectOutputStream
              ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
              // add it to the oosList.  OK since Vector is synchronized.
              oosList.addElement(oos);
            }
            catch (IOException e) {
              LogLog.error(""exception creating output stream on socket."", e);
            }
          }
        }
      }
      finally {
    	// close the socket
    	try {
    		serverSocket.close();
    	}
    	catch (IOException e) {
    		// do nothing with it?
    	}
      }
    }
  }
}
"
org.apache.log4j.net.SocketNode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.net;
import java.net.Socket;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.BufferedInputStream;
import org.apache.log4j.*;
import org.apache.log4j.spi.*;
// Contributors:  Moses Hohman <mmhohman@rainbow.uchicago.edu>
/**
   Read {@link LoggingEvent} objects sent from a remote client using
   Sockets (TCP). These logging events are logged according to local
   policy, as if they were generated locally.
   <p>For example, the socket node might decide to log events to a
   local file and also resent them to a second socket node.
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4
*/
public class SocketNode implements Runnable {
  Socket socket;
  LoggerRepository hierarchy;
  ObjectInputStream ois;
  static Logger logger = Logger.getLogger(SocketNode.class);
  public
  SocketNode(Socket socket, LoggerRepository hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(
                         new BufferedInputStream(socket.getInputStream()));
    }
    catch(Exception e) {
      logger.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }
  //public
  //void finalize() {
  //System.err.println(""-------------------------Finalize called"");
  // System.err.flush();
  //}
  public void run() {
    LoggingEvent event;
    Logger remoteLogger;
    try {
      while(true) {
	event = (LoggingEvent) ois.readObject();
	remoteLogger = hierarchy.getLogger(event.categoryName);
	event.logger = remoteLogger;
	if(event.level.isGreaterOrEqual(remoteLogger.getEffectiveLevel())) {
	  remoteLogger.callAppenders(event);
	}
      }
    }
    catch(java.io.EOFException e) {
      logger.info(""Caught java.io.EOFException closing conneciton."");
    } catch(java.net.SocketException e) {
      logger.info(""Caught java.net.SocketException closing conneciton."");
    } catch(IOException e) {
      logger.info(""Caught java.io.IOException: ""+e);
      logger.info(""Closing connection."");
    } catch(Exception e) {
      logger.error(""Unexpected exception. Closing conneciton."", e);
    }
    try {
      ois.close();
    } catch(Exception e) {
      logger.info(""Could not close connection."", e);
    }
  }
}
"
org.apache.log4j.net.SocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.io.File;
import java.util.Hashtable;
import org.apache.log4j.*;
import org.apache.log4j.spi.*;
/**
   A {@link SocketNode} based server that uses a different hierarchy
   for each client.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SocketServer port configFile configDir
     where <b>port</b> is a part number where the server listens,
           <b>configFile</b> is a configuration file fed to the {@link PropertyConfigurator} and
           <b>configDir</b> is a path to a directory containing configuration files, possibly one for each client host.
     </pre>
     <p>The <code>configFile</code> is used to configure the log4j
     default hierarchy that the <code>SocketServer</code> will use to
     report on its actions.
     <p>When a new connection is opened from a previously unknown
     host, say <code>foo.bar.net</code>, then the
     <code>SocketServer</code> will search for a configuration file
     called <code>foo.bar.net.lcf</code> under the directory
     <code>configDir</code> that was passed as the third argument. If
     the file can be found, then a new hierarchy is instantiated and
     configured using the configuration file
     <code>foo.bar.net.lcf</code>. If and when the host
     <code>foo.bar.net</code> opens another connection to the server,
     then the previously configured hierarchy is used.
     <p>In case there is no file called <code>foo.bar.net.lcf</code>
     under the directory <code>configDir</code>, then the
     <em>generic</em> hierarchy is used. The generic hierarchy is
     configured using a configuration file called
     <code>generic.lcf</code> under the <code>configDir</code>
     directory. If no such file exists, then the generic hierarchy will be
     identical to the log4j default hierarchy.
     <p>Having different client hosts log using different hierarchies
     ensures the total independence of the clients with respect to
     their logging settings.
     <p>Currently, the hierarchy that will be used for a given request
     depends on the IP address of the client host. For example, two
     separate applicatons running on the same host and logging to the
     same server will share the same hierarchy. This is perfectly safe
     except that it might not provide the right amount of independence
     between applications. The <code>SocketServer</code> is intended
     as an example to be enhanced in order to implement more elaborate
     policies.
    @author  Ceki G&uuml;lc&uuml;
    @since 1.0 */
public class SocketServer  {
  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";
  static Category cat = Category.getInstance(SocketServer.class);
  static SocketServer server;
  static int port;
  // key=inetAddress, value=hierarchy
  Hashtable hierarchyMap;
  LoggerRepository genericHierarchy;
  File dir;
  public
  static
  void main(String argv[]) {
    if(argv.length == 3)
      init(argv[0], argv[1], argv[2]);
    else
      usage(""Wrong number of arguments."");
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);
	LoggerRepository h = (LoggerRepository) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	}
	cat.info(""Starting new socket node."");
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);
    File dir = new File(dirStr);
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }
  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }
  // This method assumes that there is no hiearchy for inetAddress
  // yet. It will configure one and return it.
  LoggerRepository configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    // We assume that the toSting method of InetAddress returns is in
    // the format hostname/d1.d2.d3.d4 e.g. torino/192.168.1.1
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);
      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootCategory((Level) Priority.DEBUG));
	hierarchyMap.put(inetAddress, h);
	new PropertyConfigurator().doConfigure(configFile.getAbsolutePath(), h);
	return h;
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }
  LoggerRepository  genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootCategory((Level) Priority.DEBUG));
	new PropertyConfigurator().doConfigure(f.getAbsolutePath(), genericHierarchy);
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = LogManager.getLoggerRepository();
      }
    }
    return genericHierarchy;
  }
}
"
org.apache.log4j.net.SyslogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.helpers.SyslogQuietWriter;
// Contributors: Yves Bossel <ybossel@opengets.cl>
//               Christopher Taylor <cstaylor@pacbell.net>
/**
    Use SyslogAppender to send log messages to a remote syslog daemon.
    @author Ceki G&uuml;lc&uuml;
    @author Anders Kristensen
 */
public class SyslogAppender extends AppenderSkeleton {
  // The following constants are extracted from a syslog.h file
  // copyrighted by the Regents of the University of California
  // I hope nobody at Berkley gets offended.
  /** Kernel messages */
  final static public int LOG_KERN     = 0;
  /** Random user-level messages */
  final static public int LOG_USER     = 1<<3;
  /** Mail system */
  final static public int LOG_MAIL     = 2<<3;
  /** System daemons */
  final static public int LOG_DAEMON   = 3<<3;
  /** security/authorization messages */
  final static public int LOG_AUTH     = 4<<3;
  /** messages generated internally by syslogd */
  final static public int LOG_SYSLOG   = 5<<3;
  /** line printer subsystem */
  final static public int LOG_LPR      = 6<<3;
  /** network news subsystem */
  final static public int LOG_NEWS     = 7<<3;
  /** UUCP subsystem */
  final static public int LOG_UUCP     = 8<<3;
  /** clock daemon */
  final static public int LOG_CRON     = 9<<3;
  /** security/authorization  messages (private) */
  final static public int LOG_AUTHPRIV = 10<<3;
  /** ftp daemon */
  final static public int LOG_FTP      = 11<<3;
  // other codes through 15 reserved for system use
  /** reserved for local use */
  final static public int LOG_LOCAL0 = 16<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL1 = 17<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL2 = 18<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL3 = 19<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL4 = 20<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL5 = 21<<3;
  /** reserved for local use */
  final static public int LOG_LOCAL6 = 22<<3;
  /** reserved for local use*/
  final static public int LOG_LOCAL7 = 23<<3;
  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;
  static final String TAB = ""    "";
  // Have LOG_USER as default
  int syslogFacility = LOG_USER;
  String facilityStr;
  boolean facilityPrinting = false;
  //SyslogTracerPrintWriter stp;
  SyslogQuietWriter sqw;
  String syslogHost;
  public
  SyslogAppender() {
    this.initSyslogFacilityStr();
  }
  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;
    this.initSyslogFacilityStr();
  }
  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }
  /**
     Release any resources held by this SyslogAppender.
     @since 0.8.4
   */
  synchronized
  public
  void close() {
    closed = true;
    // A SyslogWriter is UDP based and needs no opening. Hence, it
    // can't be closed. We just unset the variables here.
    sqw = null;
  }
  private
  void initSyslogFacilityStr() {
    facilityStr = getFacilityString(this.syslogFacility);
    if (facilityStr == null) {
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    } else {
      facilityStr += "":"";
    }
  }
  /**
     Returns the specified syslog facility as a lower-case String,
     e.g. ""kern"", ""user"", etc.
  */
  public
  static
  String getFacilityString(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN:      return ""kern"";
    case LOG_USER:      return ""user"";
    case LOG_MAIL:      return ""mail"";
    case LOG_DAEMON:    return ""daemon"";
    case LOG_AUTH:      return ""auth"";
    case LOG_SYSLOG:    return ""syslog"";
    case LOG_LPR:       return ""lpr"";
    case LOG_NEWS:      return ""news"";
    case LOG_UUCP:      return ""uucp"";
    case LOG_CRON:      return ""cron"";
    case LOG_AUTHPRIV:  return ""authpriv"";
    case LOG_FTP:       return ""ftp"";
    case LOG_LOCAL0:    return ""local0"";
    case LOG_LOCAL1:    return ""local1"";
    case LOG_LOCAL2:    return ""local2"";
    case LOG_LOCAL3:    return ""local3"";
    case LOG_LOCAL4:    return ""local4"";
    case LOG_LOCAL5:    return ""local5"";
    case LOG_LOCAL6:    return ""local6"";
    case LOG_LOCAL7:    return ""local7"";
    default:            return null;
    }
  }
  /**
     Returns the integer value corresponding to the named syslog
     facility, or -1 if it couldn't be recognized.
     @param facilityName one of the strings KERN, USER, MAIL, DAEMON,
            AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, LOCAL0,
            LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7.
            The matching is case-insensitive.
     @since 1.1
  */
  public
  static
  int getFacility(String facilityName) {
    if(facilityName != null) {
      facilityName = facilityName.trim();
    }
    if(""KERN"".equalsIgnoreCase(facilityName)) {
      return LOG_KERN;
    } else if(""USER"".equalsIgnoreCase(facilityName)) {
      return LOG_USER;
    } else if(""MAIL"".equalsIgnoreCase(facilityName)) {
      return LOG_MAIL;
    } else if(""DAEMON"".equalsIgnoreCase(facilityName)) {
      return LOG_DAEMON;
    } else if(""AUTH"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTH;
    } else if(""SYSLOG"".equalsIgnoreCase(facilityName)) {
      return LOG_SYSLOG;
    } else if(""LPR"".equalsIgnoreCase(facilityName)) {
      return LOG_LPR;
    } else if(""NEWS"".equalsIgnoreCase(facilityName)) {
      return LOG_NEWS;
    } else if(""UUCP"".equalsIgnoreCase(facilityName)) {
      return LOG_UUCP;
    } else if(""CRON"".equalsIgnoreCase(facilityName)) {
      return LOG_CRON;
    } else if(""AUTHPRIV"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTHPRIV;
    } else if(""FTP"".equalsIgnoreCase(facilityName)) {
      return LOG_FTP;
    } else if(""LOCAL0"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL0;
    } else if(""LOCAL1"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL1;
    } else if(""LOCAL2"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL2;
    } else if(""LOCAL3"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL3;
    } else if(""LOCAL4"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL4;
    } else if(""LOCAL5"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL5;
    } else if(""LOCAL6"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL6;
    } else if(""LOCAL7"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL7;
    } else {
      return -1;
    }
  }
  public
  void append(LoggingEvent event) {
    if(!isAsSevereAsThreshold(event.level))
      return;
    // We must not attempt to append if sqw is null.
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }
    String buffer = (facilityPrinting? facilityStr : """") +
                          layout.format(event);
    sqw.setLevel(event.level.getSyslogEquivalent());
    sqw.write(buffer);
    String[] s = event.getThrowableStrRep();
    if (s != null) {
      int len = s.length;
      if(len > 0) {
	sqw.write(s[0]);
	for(int i = 1; i < len; i++) {
	    sqw.write(TAB+s[i].substring(1));
	}
      }
    }
  }
  /**
     This method returns immediately as options are activated when they
     are set.
  */
  public
  void activateOptions() {
  }
  /**
     The SyslogAppender requires a layout. Hence, this method returns
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
    The <b>SyslogHost</b> option is the name of the the syslog host
    where log output should go.
    <b>WARNING</b> If the SyslogHost is not set, then this appender
    will fail.
   */
  public
  void setSyslogHost(String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost),
				     syslogFacility, errorHandler);
    //this.stp = new SyslogTracerPrintWriter(sqw);
    this.syslogHost = syslogHost;
  }
  /**
     Returns the value of the <b>SyslogHost</b> option.
   */
  public
  String getSyslogHost() {
    return syslogHost;
  }
  /**
     Set the syslog facility. This is the <b>Facility</b> option.
     <p>The <code>facilityName</code> parameter must be one of the
     strings KERN, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP,
     CRON, AUTHPRIV, FTP, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4,
     LOCAL5, LOCAL6, LOCAL7. Case is unimportant.
     @since 0.8.1 */
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;
    syslogFacility = getFacility(facilityName);
    if (syslogFacility == -1) {
      System.err.println(""[""+facilityName +
                  ""] is an unknown syslog facility. Defaulting to [USER]."");
      syslogFacility = LOG_USER;
    }
    this.initSyslogFacilityStr();
    // If there is already a sqw, make it use the new facility.
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }
  /**
     Returns the value of the <b>Facility</b> option.
   */
  public
  String getFacility() {
    return getFacilityString(syslogFacility);
  }
  /**
    If the <b>FacilityPrinting</b> option is set to true, the printed
    message will include the facility name of the application. It is
    <em>false</em> by default.
   */
  public
  void setFacilityPrinting(boolean on) {
    facilityPrinting = on;
  }
  /**
     Returns the value of the <b>FacilityPrinting</b> option.
   */
  public
  boolean getFacilityPrinting() {
    return facilityPrinting;
  }
}
"
org.apache.log4j.net.TelnetAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.net;
import java.io.*;
import java.net.*;
import java.util.*;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.helpers.LogLog;
/**
  <p>The TelnetAppender is a log4j appender that specializes in
  writing to a read-only socket.  The output is provided in a
  telnet-friendly way so that a log can be monitored over TCP/IP.
  Clients using telnet connect to the socket and receive log data.
  This is handy for remote monitoring, especially when monitoring a
  servlet.
  <p>Here is a list of the available configuration options:
  <table border=1>
   <tr>
   <th>Name</th>
   <th>Requirement</th>
   <th>Description</th>
   <th>Sample Value</th>
   </tr>
   <tr>
   <td>Port</td>
   <td>optional</td>
   <td>This parameter determines the port to use for announcing log events.  The default port is 23 (telnet).</td>
   <td>5875</td>
   </table>
   @author <a HREF=""mailto:jay@v-wave.com"">Jay Funnell</a>
*/
public class TelnetAppender extends AppenderSkeleton {
  private SocketHandler sh;
  private int port = 23;
  /** 
      This appender requires a layout to format the text to the
      attached client(s). */
  public boolean requiresLayout() {
    return true;
  }
  /** all of the options have been set, create the socket handler and
      wait for connections. */
  public void activateOptions() {
    try {
      sh = new SocketHandler(port);
      sh.start();
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  public
  int getPort() {
    return port;
  }
  public
  void setPort(int port) {
    this.port = port;
  }
  /** shuts down the appender. */
  public void close() {
    sh.finalize();
  }
  /** Handles a log event.  For this appender, that means writing the
    message to each connected client.  */
  protected void append(LoggingEvent event) {
    sh.send(this.layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  sh.send(s[i]);
	  sh.send(Layout.LINE_SEP);
	}
      }
    }
  }
  //---------------------------------------------------------- SocketHandler:
  /** The SocketHandler class is used to accept connections from
      clients.  It is threaded so that clients can connect/disconnect
      asynchronously. */
  protected class SocketHandler extends Thread {
    private boolean done = false;
    private Vector writers = new Vector();
    private Vector connections = new Vector();
    private ServerSocket serverSocket;
    private int MAX_CONNECTIONS = 20;
    /** make sure we close all network connections when this handler is destroyed. */
    public void finalize() {
      for(Enumeration e = connections.elements();e.hasMoreElements();) {
        try {
          ((Socket)e.nextElement()).close();
        } catch(Exception ex) {
        }
      }
      try {
        serverSocket.close();
      } catch(Exception ex) {
      }
      done = true;
    }
    /** sends a message to each of the clients in telnet-friendly output. */
    public void send(String message) {
      Enumeration ce = connections.elements();
      for(Enumeration e = writers.elements();e.hasMoreElements();) {
        Socket sock = (Socket)ce.nextElement();
        PrintWriter writer = (PrintWriter)e.nextElement();
        writer.print(message);
        if(writer.checkError()) {
          // The client has closed the connection, remove it from our list:
          connections.remove(sock);
          writers.remove(writer);
        }
      }
    }
    /** 
	Continually accepts client connections.  Client connections
        are refused when MAX_CONNECTIONS is reached. 
    */
    public void run() {
      while(!done) {
        try {
          Socket newClient = serverSocket.accept();
          PrintWriter pw = new PrintWriter(newClient.getOutputStream());
          if(connections.size() < MAX_CONNECTIONS) {
            connections.addElement(newClient);
            writers.addElement(pw);
            pw.print(""TelnetAppender v1.0 ("" + connections.size() 
		     + "" active connections)\r\n\r\n"");
            pw.flush();
          } else {
            pw.print(""Too many connections.\r\n"");
            pw.flush();
            newClient.close();
          }
        } catch(Exception e) {
          LogLog.error(""Encountered error while in SocketHandler loop."", e);
        }
      }
    }
    public SocketHandler(int port) throws IOException {
      serverSocket = new ServerSocket(port);
    }
  }
}
"
org.apache.log4j.net.test.Loop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
import org.apache.log4j.net.SocketAppender;
public class Loop {
  public static void main(String[] args) {
    Category root = Category.getRoot();
    Category cat = Category.getInstance(Loop.class.getName());
    if(args.length != 2) 
      usage(""Wrong number of arguments."");     
    String host = args[0];
    int port = 0;
    try {
      port = Integer.valueOf(args[1]).intValue();
    }
    catch (NumberFormatException e) {
        usage(""Argument ["" + args[1]  + ""] is not in proper int form."");
    }
    SocketAppender sa = new SocketAppender(host, port);
    Layout layout = new PatternLayout(""%5p [%t] %x %c - %m\n"");
    Appender so = new ConsoleAppender(layout, ""System.out"");
    root.addAppender(sa);
    root.addAppender(so);
    int i = 0;
    while(true) {
      NDC.push(""""+ (i++));
      cat.debug(""Debug message."");
      root.info(""Info message."");
      NDC.pop();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +Loop.class.getName() + "" host port"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.test.SMTPMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
public class SMTPMin {
  static Category cat = Category.getInstance(SMTPMin.class);
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      usage(""Wrong number of arguments."");
    NDC.push(""some context"");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SMTPMin.class.getName()
		       + "" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    Category.shutdown();
    Thread.currentThread().getThreadGroup().list();
  }
}
"
org.apache.log4j.net.test.SocketMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.InputStreamReader;
public class SocketMin {
  static Category cat = Category.getInstance(SyslogMin.class.getName());
  static SocketAppender s;
  public
  static
  void main(String argv[]) {
    if(argv.length == 3)
      init(argv[0], argv[1]);
    else
      usage(""Wrong number of arguments."");
    NDC.push(""some context"");
    if(argv[2].equals(""true""))
      loop();
    else
      test();
    s.close();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SocketMin.class
		       + "" host port true|false"");
    System.exit(1);
  }
  static
  void init(String host, String portStr) {
    Category root = Category.getRoot();
    BasicConfigurator.configure();
    try {
      int port   = Integer.parseInt(portStr);
      cat.info(""Creating socket appender (""+host+"",""+port+"")."");
      s = new SocketAppender(host, port);
      s.setName(""S"");
      root.addAppender(s);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    catch(Exception e) {
      System.err.println(""Could not start!"");
      e.printStackTrace();
      System.exit(1);
    }
  }
  static
  void loop() {
    Category root = Category.getRoot();
    InputStreamReader in = new InputStreamReader(System.in);
    System.out.println(""Type 'q' to quit"");
    int i;
    int k = 0;
    while (true) {
      cat.debug(""Message "" + k++);
      cat.info(""Message "" + k++);
      cat.warn(""Message "" + k++);
      cat.error(""Message "" + k++, new Exception(""Just testing""));
      try {i = in.read(); }
      catch(Exception e) { return; }
      if(i == -1) break;
      if(i == 'q') break;
      if(i == 'r') {
	System.out.println(""Removing appender S"");
	root.removeAppender(""S"");
      }
    }
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.net.test.SyslogMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
public class SyslogMin {
  static Category CAT = Category.getInstance(SyslogMin.class.getName());
  public
  static
  void main(String argv[]) {
      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SyslogMin.class + "" configFile"");
    System.exit(1);
  }
  static
  void ProgramInit(String configFile) {
    int port = 0;
    PropertyConfigurator.configure(configFile);
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    CAT.debug( ""Message "" + i++);
    CAT.info( ""Message "" + i++);
    CAT.warn( ""Message "" + i++);
    CAT.error( ""Message "" + i++);
    CAT.log(Priority.FATAL, ""Message "" + i++);
    CAT.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.nt.NTEventLogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt;
import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Level;
import org.apache.log4j.helpers.LogLog;
import java.io.*;
/**
   Append to the NT event log system.
   <p><b>WARNING</b> This appender can only be installed and used on a
   Windows system.
   <p>Do not forget to place the file NTEventLogAppender.dll in a
   directory that is on the PATH of the Windows system. Otherwise, you
   will get a java.lang.UnsatisfiedLinkError.
   @author <a href=""mailto:cstaylor@pacbell.net"">Chris Taylor</a>
   @author <a href=""mailto:jim_cakalic@na.biomerieux.com"">Jim Cakalic</a> */
public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;
  private String source = null;
  private String server = null;
  private static final int FATAL  = Level.FATAL.toInt();
  private static final int ERROR  = Level.ERROR.toInt();
  private static final int WARN   = Level.WARN.toInt();
  private static final int INFO   = Level.INFO.toInt();
  private static final int DEBUG  = Level.DEBUG.toInt();
  public NTEventLogAppender() {
    this(null, null, null);
  }
  public NTEventLogAppender(String source) {
    this(null, source, null);
  }
  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }
  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }
  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }
  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }
    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }
  public
  void close() {
    // unregister ...
  }
  public
  void activateOptions() {
    if (source != null) {
      try {
	_handle = registerEventSource(server, source);
      } catch (Exception e) {
	LogLog.error(""Could not register event source."", e);
	_handle = 0;
      }
    }
  }
  public void append(LoggingEvent event) {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  sbuf.append(s[i]);
	}
      }
    }
    // Normalize the log message level into the supported categories
    int nt_category = event.level.toInt();
    // Anything above FATAL or below DEBUG is labeled as INFO.
    //if (nt_category > FATAL || nt_category < DEBUG) {
    //  nt_category = INFO;
    //}
    reportEvent(_handle, sbuf.toString(), nt_category);
  }
  public
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }
  /**
     The <b>Source</b> option which names the source of the event. The
     current value of this constant is <b>Source</b>.
   */
  public
  void setSource(String source) {
    this.source = source.trim();
  }
  public
  String getSource() {
    return source;
  }
/**
     The <code>NTEventLogAppender</code> requires a layout. Hence,
     this method always returns <code>true</code>. */
  public
  boolean requiresLayout() {
    return true;
  }
  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int level);
  native private void deregisterEventSource(int handle);
  static {
    System.loadLibrary(""NTEventLogAppender"");
  }
}
"
org.apache.log4j.nt.test.NTMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.nt.NTEventLogAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
public class NTMin {
  static Category cat = Category.getInstance(NTMin.class.getName());
  public
  static
  void main(String argv[]) {
    //if(argv.length == 1) {
    init();
    //}
    //else {
    //Usage(""Wrong number of arguments."");
    //}
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + NTMin.class + """");
    System.exit(1);
  }
  static
  void init() {
    BasicConfigurator.configure(new NTEventLogAppender());
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.or.DefaultRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   The default Renderer renders objects by calling their
   <code>toString</code> method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
class DefaultRenderer implements ObjectRenderer {
  DefaultRenderer() {
  }
  /**
     Render the object passed as parameter by calling its
     <code>toString</code> method.  */
  public
  String doRender(Object o) {
    return o.toString();
  }
}  
"
org.apache.log4j.or.ObjectRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   Implement this interface in order to render objects as strings.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public interface ObjectRenderer {
  /**
     Render the object passed as parameter as a String.
   */
  public
  String doRender(Object o);
}
"
org.apache.log4j.or.RendererMap,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Hashtable;
/**
   Map class objects to an {@link ObjectRenderer}.
   @author Ceki G&uuml;lc&uuml;
   @since version 1.0 */
public class RendererMap {
  Hashtable map;
  static ObjectRenderer defaultRenderer = new DefaultRenderer();
  public
  RendererMap() {
    map = new Hashtable();
  }
  /**
     Add a renderer to a hierarchy passed as parameter.
  */
  static
  public
  void addRenderer(RendererSupport repository, String renderedClassName,
		   String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer)
             OptionConverter.instantiateByClassName(renderingClassName,
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not instantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Class.forName(renderedClassName);
	repository.setRenderer(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }
  /**
     Find the appropriate renderer for the class type of the
     <code>o</code> parameter. This is accomplished by calling the
     {@link #get(Class)} method. Once a renderer is found, it is
     applied on the object <code>o</code> and the result is returned
     as a {@link String}. */
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else
      return get(o.getClass()).doRender(o);
  }
  /**
     Syntactic sugar method that calls {@link #get(Class)} with the
     class of the object parameter. */
  public
  ObjectRenderer get(Object o) {
    if(o == null)
      return null;
    else
      return get(o.getClass());
  }
  /**
     Search the parents of <code>clazz</code> for a renderer. The
     renderer closest in the hierarchy will be returned. If no
     renderers could be found, then the default renderer is returned.
     <p>The search first looks for a renderer configured for
     <code>clazz</code>. If a renderer could not be found, then the
     search continues by looking at all the interfaces implemented by
     <code>clazz</code> including the super-interfaces of each
     interface.  If a renderer cannot be found, then the search looks
     for a renderer defined for the parent (superclass) of
     <code>clazz</code>. If that fails, then all the interfaces
     implemented by the parent of <code>clazz</code> are searched and
     so on.
     <p>For example, if A0, A1, A2 are classes and X0, X1, X2, Y0, Y1
     are interfaces where A2 extends A1 which in turn extends A0 and
     similarly X2 extends X1 which extends X0 and Y1 extends Y0. Let
     us also assume that A1 implements the Y0 interface and that A2
     implements the X2 interface.
     <p>The table below shows the results returned by the
     <code>get(A2.class)</code> method depending on the renderers
     added to the map.
     <p><table border=""1"">
     <tr><th>Added renderers</th><th>Value returned by <code>get(A2.class)</code></th>
     <tr><td><code>A0Renderer</code>
         <td align=""center""><code>A0Renderer</code>
     <tr><td><code>A0Renderer, A1Renderer</code>
         <td align=""center""><code>A1Renderer</code>
     <tr><td><code>X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>
     <tr><td><code>A1Renderer, X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>
     </table>
     <p>This search algorithm is not the most natural, although it is
     particularly easy to implement. Future log4j versions
     <em>may</em> implement a more intuitive search
     algorithm. However, the present algorithm should be acceptable in
     the vast majority of circumstances.
 */
  public
  ObjectRenderer get(Class clazz) {
    //System.out.println(""\nget: ""+clazz);
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      //System.out.println(""Searching for class: ""+c);
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }
  ObjectRenderer searchInterfaces(Class c) {
    //System.out.println(""Searching interfaces of class: ""+c);
    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r;
      }
    }
    return null;
  }
  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }
  public
  void clear() {
    map.clear();
  }
  /**
     Register an {@link ObjectRenderer} for <code>clazz</code>.
  */
  public
  void put(Class clazz, ObjectRenderer or) {
    map.put(clazz, or);
  }
}
"
org.apache.log4j.or.ThreadGroupRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.Layout;
/**
   Render {@link ThreadGroup} objects in a format similar to the
   information output by the {@link ThreadGroup#list} method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class ThreadGroupRenderer implements ObjectRenderer {
  public
  ThreadGroupRenderer() {
  }
  /**
     Render a {@link ThreadGroup} object similar to the way that the
     {@link ThreadGroup#list} method output information. 
     <p>The output of a simple program consisting of one
     <code>main</code> thread is:
     <pre>
     java.lang.ThreadGroup[name=main, maxpri=10]
         Thread=[main,5,false]
     </pre>
     <p>The boolean value in thread information is the value returned
     by {@link Thread#isDaemon}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      // this is the best we can do
      return o.toString();
    }    
  }
}  
"
org.apache.log4j.or.jms.MessageRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.or.jms;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.or.ObjectRenderer;
import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;
/**
   Render <code>javax.jms.Message</code> objects.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class MessageRenderer implements ObjectRenderer {
  public
  MessageRenderer() {
  }
  /**
     Render a {@link javax.jms.Message}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof Message) {
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT :
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT :
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());
	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());
	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());
	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());
	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());
	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());
	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());
	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());
	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());
	//Enumeration enum = m.getPropertyNames();
	//while(enum.hasMoreElements()) {
	//  String key = (String) enum.nextElement();
	//  sbuf.append(""; ""+key+""="");
	//  sbuf.append(m.getStringProperty(key));
	//}
      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
org.apache.log4j.or.sax.AttributesRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.or.sax;
import org.apache.log4j.or.ObjectRenderer;
import org.xml.sax.Attributes;
/**
   Render <code>org.xml.sax.Attributes</code> objects.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2 */
public class AttributesRenderer implements ObjectRenderer {
  public
  AttributesRenderer() {
  }
  /**
     Render a {@link org.xml.sax.Attributes}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof Attributes) {
      StringBuffer sbuf = new StringBuffer();
      Attributes a = (Attributes) o;
      int len = a.getLength();
      boolean first = true;
      for(int i = 0; i < len; i++) {
	if(first) {
	  first = false;
	} else {
	  sbuf.append("", "");
	}
	sbuf.append(a.getQName(i));
	sbuf.append('=');
	sbuf.append(a.getValue(i));
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
org.apache.log4j.performance.ConcatVsArray,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.util.Date;
/**
   Measure difference in performance of string concatenation versus
   creating an anonymous string array.
   <p>You should be able to see that anonymous string array
   construction is significatnly faster than string concatenation. The
   difference increases proportionally with the length of the strings
   to be concatanated.
   @author Ceki G&uuml;lc&uuml;
 */
public class ConcatVsArray {
  static
  void  Usage() {
    System.err.println(""Usage: java org.apache.log4j.performance.ConcatVsArray "" +
		       ""string1 string2 runLength\n"" +
		       ""       where runLength is an integer."");
    System.exit(1);
  }
  public static void main(String args[]) {
    if(args.length != 3) {
      Usage();
    }    
    String s1 = args[0];
    String s2 = args[1];
    int runLength = 0;
    try {
      runLength = Integer.parseInt(args[2]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      
    double micros;
    String[] sa;
    long before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      sa = new String[]{s1, s2};
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The anonymous array loop took around "" + micros + "" microseconds."");
    String s;    
    before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      s = s1 + s2;
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The append loop took around "" + micros + "" microseconds."");
  }
}
"
org.apache.log4j.performance.ListVsVector,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import java.util.Vector;
/**
   Compares the performance of looping through a list versus a Vector.
   Chain looping is *20* times faster than vector access on JDK 1.1.7B on NT
*/
public class ListVsVector {
  static int RUN_LENGTH = 1000000;
  static Vector v = new Vector();
  static Chain head;
  static String tmp;
  static
  public 
  void main(String[] args) {
    v.addElement(""aaa"");
    v.addElement(""bbb"");
    v.addElement(""ccc"");
    v.addElement(""ddd"");
    v.addElement(""eee"");
    Chain c = new Chain(""aaa"");
    head = c;
    c.next = new Chain(""bbb""); c = c.next;
    c.next = new Chain(""ccc""); c = c.next;
    c.next = new Chain(""ddd""); c = c.next;
    c.next = new Chain(""eee"");
    double t;
    t = loopChain();
    System.out.println(""Looping thourgh the chain took "" + t);
    t = loopVector();
    System.out.println(""Looping thourgh the vector took "" + t);
  }
  static
  double loopChain() {
    long before = System.currentTimeMillis();
    Chain c;
    for(int i = 0; i < RUN_LENGTH; i++) {
      c = head;
      while(c != null) {
	tmp = c.s;
	c = c.next;
      }
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double loopVector() {
    long before = System.currentTimeMillis();
    int size = v.size();
    for(int i = 0; i < RUN_LENGTH; i++) {
      for(int j = 0; j < size; j++)
	tmp = (String) v.elementAt(j);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static class Chain {
    public String s;
    public Chain next;
    Chain(String s) {
      this.s = s;
    }
    void setNext(Chain c) {
      next = c;
    }
  }
}
"
org.apache.log4j.performance.Logging,"//      Copyright 1996-1999, International Business Machines
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.NDC;
import org.apache.log4j.performance.NOPWriter;
/**
   Measure the performance of logging.
   <p>Experimental results are listed below in units of
   <b>micro-seconds</b>. Measurements were done on a AMD Duron clocked
   at 800Mhz running Windows 2000 and Sun's 1.3 JDK.
<p><table border=1>
<tr>
<th>Layout
<th>NullAppender
<th>FileAppender
<th>FileAppender (no flush)
<th>AsyncAppender (no flush)
<tr>
<td>SimpleLayout
<td>4
<td>21
<td>16
<td>33
<tr>
<td>PatternLayout ""%p - %m%n""
<td>4
<td>21
<td>16
<td>32
<tr>
<td>PatternLayout ""%-5p - %m%n""
<td>4
<td>NA
<td>NA
<td>NA
<tr>
<td>TTCCLayout/RELATIVE
<td>10
<td>37
<td>31
<td>45
<tr>
<td>PatternLayout ""%r [%t] %-5p %c{2} %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.10c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.20c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %c - %m%n""
<td>9
<td>36
<td>29
<td>45
<tr>
<td>TTCCLayout/ISO8601
<td>25
<td>58
<td>51
<td>71
<tr>
<td>PatternLayout ""%d{ISO8601} [%t] %-5p %c %x - %m%n""
<td>28
<td>62
<td>55
<td>76
<tr>
<td>PatternLayout ""%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] %-5p %c %x - %m%n""
<td>46
<td>82
<td>72
<td>94
<tr>
<td>PatternLayout ""%l - %m%n""
<td> 241
<td> 317
<td> 299
<td> 251
<tr>
<td>PatternLayout ""%C.%M.%L - %m%n""
<td>267
<td>NA
<td>NA
<td>NA
</table>
   <p>The results of the measurements (should) show that:
   <ol>
   <li><b>The PatternLayout perforance is very close to the performance of
   a dedicated layout of equivalent format.</b>
   <p><li>Format specifiers in conversion patterns have almost no impact
   on performance.
   <p><li>Formating time and date information is costly. Using relative
   time has the least impact on performance. It is recommended that to
   use log4j specific date formatters such as the {@link
   org.apache.log4j.helpers.ISO8601DateFormat} instead of the standard {@link
   java.text.SimpleDateFormat} because of its poor performance. See
   the <b>%d</b> conversion character in {@link
   org.apache.log4j.PatternLayout}.
   <p><li>Avoiding the flush operation at the end of each append
   results in a performance gain of 10 to 20 percent. However, there
   is safety tradeoff invloved in skipping flushing. Indeed, when
   flushing is skipped, then it is likely that the last few log events
   will not be recorded on disk when the application exits. This is a
   high price to pay even for a 20% performance gain.
   <p><li>The <code>AsyncAppender</code> does not automatically
   increase performance. On the contrary, it significantly degrades
   performance. The performance tests done here very quickly fill up
   the bounded buffer of the <code>AsyncAppender</code> and there is
   cosiderable overhead in managing this bounded buffer.
   <p>On the other hand, had we interleaved logging operations with
   long blocking and non CPU-intensive operations, such as I/O,
   network access, sleeping threads, then the
   <code>AsyncAppender</code> would have tremendously reduced the cost
   of logging in terms of overall application runtime.
   <p>In a variant of this test, we have inserted a short sleep
   operation between every 10 log operations. When the total slept
   time is substracted, logging with the <code>AsyncLogger</code>
   takes no time at all. In other words, logging is done for ""free"".
   <p><li>Extracting location information is comparatively slow. It
   implies at least a ten fold increase in logging time!  It should be
   avoided unless performace is not a concern. It has been reported
   from a trusted source that logging with location information on AIX
   machines will <em>kill</em> your application's performance.
   </ol>
   @author Ceki G&uuml;lc&uuml;
 */
public class Logging {
  static int runLength;
  static int delay = -1;
  /**
     A delay is applied after every <code>burstLen</code> log
     requests.  The default value of this constant is 100.  */
  static  int burstLen = 100;
  static int DELAY_MULT = 1000/burstLen;
  static Category cat = Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static
  void  Usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java ""+Logging.class.getName()+"" confFile runLength [delay] [burstLen]\n""+
      ""        confFile is an XML configuration file and\n""+
      ""        runLength (integer) is the length of test loop.\n""+
      ""        delay is the time in millisecs to wait every bustLen log requests."");
    System.exit(1);
  }
  /**
     <b>Usage:</b> <code>java org.apache.log4j.performance.Logging confFile runLength [delay] [burstLen]</code>
     <p><code>confFile</code> is an XML configuration file and
      <code>runLength</code> (integer) is the length of test loop,
      <code>delay</code> is the time in millisecs to sleep every
      <code>bustLen</code> log requests.
      <p>This application just prints the average time it took to log.
   */
  public static void main(String argv[]) {
    if(argv.length == 2)
      init(argv[0], argv[1], null, null);
    else if( argv.length == 4)
      init(argv[0], argv[1], argv[2], argv[3]);
    else
      Usage(""Wrong number of arguments."");
    NDC.push(""some context"");
    double delta;
    String msg = ""ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890"";
     if(delay <= 0)
      delta = NoDelayLoop(cat, msg);
    else
      delta = DelayedLoop(cat, msg);
    System.out.print((int)delta);
    Category.shutdown();
  }
  /**
    Program wide initialization method.
    */
  static
  void init(String configFile, String runLengthStr, String delayStr,
	    String burstLenStr) {
    try {
      runLength   = Integer.parseInt(runLengthStr);
      if(delayStr != null) {
	delay = Integer.parseInt(delayStr);
      }
      if(delayStr != null) {
	burstLen = Integer.parseInt(burstLenStr);
	DELAY_MULT = 1000/burstLen;
      }
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
    }
    DOMConfigurator.configure(configFile);
  }
  static
  double NoDelayLoop(Category category, String msg) {
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
    }
    return ((System.currentTimeMillis() - before)*1000.0)/runLength;
  }
  static
  double DelayedLoop(Category category, String msg) {
    long before = System.currentTimeMillis();
    int j = 0;
    Thread currentThread = Thread.currentThread();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
      if(j++ == burstLen) {
	j = 0;
	try{currentThread.sleep(delay);}catch(Exception e){}
      }
    }
    double actualTime = ((System.currentTimeMillis()-before)*1000.0/runLength);
    System.out.println(""actual time: ""+actualTime);
    return (actualTime - delay*DELAY_MULT);
  }
}
"
org.apache.log4j.performance.NewVsSetLen,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   This program compares the cost of creating a new StringBuffer and
   converting it to a String versus keeping the same StringBuffer,
   setting its size to zero and then converting it to String.
   <p>The table below gives some figures.
<p>   <table border=""1"" cellpadding=""4"">
   <tr BGCOLOR=""#33CCFF"">
     <th BGCOLOR=""#CCCCCC"" rowspan=""2"">Total Message length
     <th colspan=""2"" align=""center"">0
     <th colspan=""2"" align=""center"">1
     <th colspan=""2"" align=""center"">2
     <th colspan=""2"" align=""center"">4
     <th colspan=""2"" align=""center"">8
   </tr>
   <tr BGCOLOR=""#3366FF"">
     <td>New Buffer</td> <td>setLength</td> 
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">256 
   <td>33 <td>22 
   <td>34 <td>22
   <td>34 <td>22
   <td>34 <td>22 
   <td>33 <td>23
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1024 
   <td>58 <td>41
   <td>59 <td>45
   <td>59 <td>48
   <td>59 <td>51 
   <td>60 <td>44
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">4096 
   <td>146 <td>132
   <td>138 <td>132
   <td>144 <td>126
   <td>142 <td>132
   <td>136 <td>132 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">16384 
   <td>617 <td>593 
   <td>593 <td>609
   <td>601 <td>617
   <td>601 <td>632 
   <td>593 <td>632
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">65536 
   <td>3218 <td>3281
   <td>3093 <td>3125 
   <td>3125 <td>3156
   <td>3125 <td>3281 
   <td>3062 <td>3562
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">262144 
   <td>14750 <td>15125
   <td>14000 <td>15500 
   <td>14000 <td>16125 
   <td>14000 <td>18000 
   <td>14000 <td>21375 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1048576 
   <td>87500 <td>80000
   <td>60500 <td>82000 
   <td>57000 <td>93000 
   <td>57500 <td>118500 
   <td>57500 <td>168500 
   </tr>
   <caption ALIGN=""BOTTOM"">Performance comparisons of new buffer
   creation versus setLength(0) approach for various message sizes and
   secondary loop lengths.
   </caption>
   </table>
   <p>The tests copy a message to a destination string buffer and then
   copy a 256 character buffer to another buffer the number of times
   as specified by the secondary loop length.
   <p>The <code>setLength(0)</code> method is usually faster. However,
   after copying a large string it becomes slow even when copying
   small strings.
   <p>This is due to a peculiarity in the <code>copy</code> method in
   StringBuffer class which creates a character array of the same
   length as the old buffer even if the vast majority of those
   characters are unused. 
   <p>The tests were performed on Linux using IBM's JDK 1.1.8.
   <p>The test script is a crude model of what might happen in
   reality. If you remain unconvinced of its results, then please send
   your alternative measurement scenario.
*/
public class NewVsSetLen {
  static String s;
  static int BIGBUF_LEN = 1048576;
  static int SBUF_LEN = 256;
  static int RUN_LENGTH = BIGBUF_LEN/4;
  static char[] sbuf = new char[SBUF_LEN];
  static char[] bigbuf = new char[BIGBUF_LEN];
  {
    for(int i = 0; i < SBUF_LEN; i++) {
      sbuf[i] = (char) (i);
    }
    for(int i = 0; i < BIGBUF_LEN; i++) {
      bigbuf[i] = (char) (i);
    }
  }
  static
  public 
  void main(String[] args) {    
    int t;
    for(int len = SBUF_LEN; len <= BIGBUF_LEN; len*=4, RUN_LENGTH /= 4) {
      System.out.println(""<td>""+len+""\n"");
      for(int second = 0; second < 16;) {
	System.out.println(""SECOND loop=""+second +"", RUN_LENGTH=""
			   +RUN_LENGTH+"", len=""+len);
	t = (int)newBuffer(len, second);;
	System.out.print(""<td>"" + t);
	t = (int)setLen(len, second);
	System.out.println("" <td>"" + t + "" \n"");
	if(second == 0) {
	  second = 1;
	} else {
	  second *= 2;
	}
      }
    }
  }
  static
  double newBuffer(int size, int second) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < RUN_LENGTH; i++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
    }
    for(int x = 0; x <  second; x++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double setLen(int size, int second) {
    long before = System.currentTimeMillis();
    StringBuffer buf = new StringBuffer(SBUF_LEN);
    for(int i = 0; i < RUN_LENGTH; i++) {
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
      buf.setLength(0);
    }
    for(int x = 0; x < second; x++) {
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
      buf.setLength(0);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.performance.NOPWriter,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.io.Writer;
import java.io.IOException;
/**
  Extends {@link Writer} with methods that return immediately without
  doing anything. This class is used to measure the cost of
  constructing a log message but not actually writing to the
  OutputStream.
  @author  Ceki G&uuml;lc&uuml;
*/
public class NOPWriter extends Writer {
  //public
  //NOPWriter() {
  //}
  public
  void write(char[] cbuf) throws IOException {}
  public
  void write(char[] cbuf, int off, int len) throws IOException {}
  public
  void write(int b) throws IOException {}
  public 
  void write(String s) throws IOException {} 
  public 
  void write(String s, int off, int len) throws IOException {} 
  public 
  void flush() throws IOException {
  }
  public 
  void close() throws IOException {
    System.err.println(""Close called."");
  }
}
"
org.apache.log4j.performance.NotLogging,"//      Copyright 1996-2000, International Business Machines
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
/**
   Measure the performance of evaluating whether to log or not to log,
   but not actually logging.
   <p>This program takes two arguments, a string which should be
   ""true"" for testing shipped code performance and ""false"" for testing
   debug-enabled performance the second argument is the run length of
   the measurement loops.
   <p>The results of the measurement (should) show that
   <ul>
   <p>
   <li>Category evaluation is independent of the length of the category name.
   <p>
   <li>As expected, using the {@link Category#isDebugEnabled
   isDebugEnabled} and {@link Category#isInfoEnabled isInfoEnabled}
   methods eliminates the overhead of message argument construction.
   <p> <li>Message argument construction can be an important slowing
   factor while evaluating whether to log or not.
   </ul>
   @author Ceki G&uuml;lc&uuml;
*/
public class NotLogging {
  static int runLength;
  final static int INITIAL_HASH_SIZE = 101;
  static String  SHORT_MSG = ""Hello World"";
  static Category SHORT_CAT = Category.getInstance(""A0123456789"");
  static Category MEDIUM_CAT= Category.getInstance(""A0123456789.B0123456789"");
  static Category LONG_CAT  =
                   Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static Category INEXISTENT_SHORT_CAT = Category.getInstance(""I0123456789"");
  static Category INEXISTENT_MEDIUM_CAT=
                                Category.getInstance(""I0123456789.B0123456789"");
  static Category INEXISTENT_LONG_CAT=
                     Category.getInstance(""I0123456789.B0123456789.C0123456789"");
  static Category[] CAT_ARRAY = new Category[] {SHORT_CAT, MEDIUM_CAT,
						LONG_CAT, INEXISTENT_SHORT_CAT,
						INEXISTENT_MEDIUM_CAT,
						INEXISTENT_LONG_CAT};
  static
  void  Usage() {
    System.err.println(
      ""Usage: java org.apache.log4j.test.NotLogging true|false runLength\n"" +
      ""true indicates shipped code, false indicates code in development"" +
      ""  where runLength is an int representing the run length of loops\n""+
      ""We suggest that runLength be at least 100'000."");
    System.exit(1);
  }
  public static void main(String argv[]) {
    if(argv.length != 2) {
      Usage();
    }
    ProgramInit(argv);
    double delta;
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = SimpleMessage(CAT_ARRAY[i], SHORT_MSG, runLength);
      System.out.println(""Simple argument,          "" + delta
			 + "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = FullyOptimizedComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Fully optimized complex,  "" + delta +
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = ComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Complex message argument, "" + delta +
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
  }
  /**
    Program wide initialization method.  */
  static
  void ProgramInit(String[] args) {
    try {
      runLength = Integer.parseInt(args[1]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }
    ConsoleAppender appender = new ConsoleAppender(new SimpleLayout());
    if(""false"".equals(args[0])) {
      // nothing to do
    } else if (""true"".equals(args[0])) {
      System.out.println(""Flagging as shipped code."");
      Category.getDefaultHierarchy().setThreshold((Level) Level.WARN);
    } else
      Usage();
    SHORT_CAT.setLevel((Level) Level.INFO);
    Category.getRoot().setLevel((Level) Level.INFO);
  }
  static
  double SimpleMessage(Category category, String msg, long runLength) {
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;
  }
  static
  double FullyOptimizedComplexMessage(Category category, long runLength) {
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      if(category.isDebugEnabled())
	category.debug(""Message"" + i +
		  "" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;
  }
  static
  double ComplexMessage(Category category, long runLength) {
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(""Message"" + i +
		"" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;
  }
}
"
org.apache.log4j.performance.NullAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.AppenderSkeleton;
/**
   A bogus appender which calls the format method of its layout object
   but does not write the result anywhere.
 */
public class NullAppender extends AppenderSkeleton {
  public static String s;
  public String t;
  public
  NullAppender() {}
  public
  NullAppender(Layout layout) {
    this.layout = layout;
  }
  public
  void close() {}
  public
  void doAppend(LoggingEvent event) {
    if(layout != null) {
      t = layout.format(event);
      s = t;
    }
  }
  public
  void append(LoggingEvent event) {
  }
  /**
     This is a bogus appender but it still uses a layout.
  */
  public
  boolean requiresLayout() {
    return true;
  }
}
"
org.apache.log4j.performance.SystemTime,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   Measures the time required to make a System.currentTimeMillis() and
   Thread.currentThread().getName() calls.
   <p>On an 233Mhz NT machine (JDK 1.1.7B) the
   System.currentTimeMillis() call takes under half a microsecond to
   complete whereas the Thread.currentThread().getName() call takes
   about 4 micro-seconds.
*/
public class SystemTime {
  static int RUN_LENGTH = 1000000;
  static
  public 
  void main(String[] args) {    
    double t = systemCurrentTimeLoop();
    System.out.println(""Average System.currentTimeMillis() call took "" + t);
    t = currentThreadNameloop();
    System.out.println(""Average Thread.currentThread().getName() call took "" 
		       + t);
  }
  static
  double systemCurrentTimeLoop() {
    long before = System.currentTimeMillis();
    long l;
    for(int i = 0; i < RUN_LENGTH; i++) {
      l = System.currentTimeMillis();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double currentThreadNameloop() {
    long before = System.currentTimeMillis();
    String t;
    for(int i = 0; i < RUN_LENGTH; i++) {
      t = Thread.currentThread().getName();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.spi.AppenderAttachable,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
import java.util.Enumeration;
/**
   Interface for attaching appenders to objects.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public interface AppenderAttachable {
  /**
     Add an appender.
   */
  public
  void addAppender(Appender newAppender);
  /**
     Get all previously added appenders as an Enumeration.  */
  public
  Enumeration getAllAppenders();
  /**
     Get an appender by name.
   */
  public
  Appender getAppender(String name);
  /**
     Returns <code>true</code> if the specified appender is in list of
     attached attached, <code>false</code> otherwise.
     @since 1.2 */
  public 
  boolean isAttached(Appender appender);
  /**
     Remove all previously added appenders.
  */
  void removeAllAppenders();
  /**
     Remove the appender passed as parameter from the list of appenders.
  */
   void removeAppender(Appender appender);
 /**
    Remove the appender with the name passed as parameter from the
    list of appenders.  
  */
 void
 removeAppender(String name);   
}
"
org.apache.log4j.spi.Configurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.spi.LoggerRepository;
import java.net.URL;
/**
   Implemented by classes capable of configuring log4j using a URL.
   @since 1.0
   @author Anders Kristensen
 */
public interface Configurator {
  /**
     <p><code>ENABLE_KEY</code> is the name of the constant
     holding the string value <b>log4j.enable</b>.
     <p>Setting the system property <b>log4j.disable</b> to DEBUG,
     INFO, WARN, ERROR or FATAL is equivalent to calling the {@link
     Hierarchy#disable} method with the corresponding level.
     @since 1.2 */
  // public static final String ENABLE_KEY = ""log4j.enable"";
  /**
     Special level value signifying inherited behaviour. The
     current value of this string constant is <b>inherited</b>.
  */
  public static final String INHERITED = ""inherited"";
  /**
     Interpret a resource pointed by a URL and set up log4j accordingly.
     The configuration is done relative to the <code>hierarchy</code>
     parameter.
     @param url The URL to parse
     @param hierarchy The hierarchy to operation upon.
   */
  void doConfigure(URL url, LoggerRepository repository);
}
"
org.apache.log4j.spi.DefaultRepositorySelector,"package org.apache.log4j.spi;
public class DefaultRepositorySelector implements RepositorySelector {
  final LoggerRepository repository;
  public
  DefaultRepositorySelector(LoggerRepository repository) {
    this.repository = repository;
  }
  public
  LoggerRepository getLoggerRepository() {
    return repository;
  }
}
"
org.apache.log4j.spi.ErrorCode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
/**
   This interface defines commonly encoutered error codes.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public interface ErrorCode {
  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
org.apache.log4j.spi.ErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
import org.apache.log4j.Logger;
/**
   Appenders may delegate their error handling to
   <code>ErrorHandlers</code>.
   <p>Error handling is a particularly tedious to get right because by
   definition errors are hard to predict and to reproduce. 
   <p>Please take the time to contact the author in case you discover
   that errors are not properly handled. You are most welcome to
   suggest new error handling policies or criticize existing policies.
   @author Ceki G&uuml;lc&uuml;
*/
public interface ErrorHandler extends OptionHandler {
  /**
     Add a reference to a logger to which the failing appender might
     be attached to. The failing appender will be searched and
     replaced only in the loggers you add through this method.
     @param logger One of the loggers that will be searched for the failing
     appender in view of replacement.
     @since 1.2 */
  void setLogger(Logger logger);
  /**
     Equivalent to the {@link #error(String, Exception, int,
     LoggingEvent event)} with the the event parameteter set to
     <code>null</code>.
  */
  void error(String message, Exception e, int errorCode);
  /**
     This method is normally used to just print the error message
     passed as a parameter.       
  */
  void error(String message);
  /**
     This method is invoked to handle the error.
     @param message The message assoicated with the error.
     @param e The Exption that was thrown when the error occured.
     @param errorCode The error code associated with the error. 
     @param event The logging event that the failing appender is asked
            to log.
     @since 1.2 */
  void error(String message, Exception e, int errorCode, LoggingEvent event);
  /**
     Set the appender for which errors are handled. This method is
     usually called when the error handler is configured.
     @since 1.2 */
  void setAppender(Appender appender);
  /**
     Set the appender to falkback upon in case of failure.
     @since 1.2 */
  void setBackupAppender(Appender appender);
}
"
org.apache.log4j.spi.Filter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.spi.LoggingEvent;
/**
   Users should extend this class to implement customized logging
   event filtering. Note that {@link org.apache.log4j.Category} and {@link
   org.apache.log4j.AppenderSkeleton}, the parent class of all standard
   appenders, have built-in filtering rules. It is suggested that you
   first use and understand the built-in rules before rushing to write
   your own custom filters.
   <p>This abstract class assumes and also imposes that filters be
   organized in a linear chain. The {@link #decide
   decide(LoggingEvent)} method of each filter is called sequentially,
   in the order of their addition to the chain.
   <p>The {@link #decide decide(LoggingEvent)} method must return one
   of the integer constants {@link #DENY}, {@link #NEUTRAL} or {@link
   #ACCEPT}.
   <p>If the value {@link #DENY} is returned, then the log event is
   dropped immediately without consulting with the remaining
   filters. 
   <p>If the value {@link #NEUTRAL} is returned, then the next filter
   in the chain is consulted. If there are no more filters in the
   chain, then the log event is logged. Thus, in the presence of no
   filters, the default behaviour is to log all logging events.
   <p>If the value {@link #ACCEPT} is returned, then the log
   event is logged without consulting the remaining filters. 
   <p>The philosophy of log4j filters is largely inspired from the
   Linux ipchains. 
   <p>Note that filtering is only supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}. The {@link
   org.apache.log4j.PropertyConfigurator PropertyConfigurator} does not
   support filters.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public abstract class Filter implements OptionHandler {
  /**
     Points to the next filter in the filter chain.
   */
  public Filter next;
  /**
     The log event must be dropped immediately without consulting
     with the remaining filters, if any, in the chain.  */
  public static final int DENY    = -1;
  /**
     This filter is neutral with respect to the log event. The
     remaining filters, if any, should be consulted for a final decision.
  */
  public static final int NEUTRAL = 0;
  /**
     The log event must be logged immediately without consulting with
     the remaining filters, if any, in the chain.  */
  public static final int ACCEPT  = 1;
  /**
     Usually filters options become active when set. We provide a
     default do-nothing implementation for convenience.
  */
  public
  void activateOptions() {
  }
  /**     
     <p>If the decision is <code>DENY</code>, then the event will be
     dropped. If the decision is <code>NEUTRAL</code>, then the next
     filter, if any, will be invoked. If the decision is ACCEPT then
     the event will be logged without consulting with other filters in
     the chain.
     @param event The LoggingEvent to decide upon.
     @param decision The decision of the filter.  */
  abstract
  public
  int decide(LoggingEvent event);
}
"
org.apache.log4j.spi.HierarchyEventListener,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.*;
/**
   Listen to events occuring within a {@link
   org.apache.log4j.Hierarchy Hierarchy}.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2
 */
public interface HierarchyEventListener {
  //public
  //void categoryCreationEvent(Category cat);
  public
  void addAppenderEvent(Category cat, Appender appender);
  public
  void removeAppenderEvent(Category cat, Appender appender);
}
"
org.apache.log4j.spi.LocationInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contributors: Mathias Rupprecht <mmathias.rupprecht@fja.com>
package org.apache.log4j.spi;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Layout;
/**
   The internal representation of caller location information.
   @since 0.8.3
*/
public class LocationInfo implements java.io.Serializable {
  /**
     Caller's line number.
  */
  transient String lineNumber;
  /**
     Caller's file name.
  */
  transient String fileName;
  /**
     Caller's fully qualified class name.
  */
  transient String className;
  /**
     Caller's method name.
  */
  transient String methodName;
  /**
     All available caller information, in the format
     <code>fully.qualified.classname.of.caller.methodName(Filename.java:line)</code>
    */
  public String fullInfo;
  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);
  /**
     When location information is not available the constant
     <code>NA</code> is returned. Current value of this string
     constant is <b>?</b>.  */
  public final static String NA = ""?"";
  static final long serialVersionUID = -1325822038990805636L;
  // Check if we are running in IBM's visual age.
  static boolean inVisualAge = false;
  static {
    try {
      Class dummy = Class.forName(""com.ibm.uvm.tools.DebugSupport"");
      inVisualAge = true;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) {
      // nothing to do
    }
  }
  /**
     Instantiate location information based on a Throwable. We
     expect the Throwable <code>t</code>, to be in the format
       <pre>
        java.lang.Throwable
        ...
          at org.apache.log4j.PatternLayout.format(PatternLayout.java:413)
          at org.apache.log4j.FileAppender.doAppend(FileAppender.java:183)
        at org.apache.log4j.Category.callAppenders(Category.java:131)
        at org.apache.log4j.Category.log(Category.java:512)
        at callers.fully.qualified.className.methodName(FileName.java:74)
	...
       </pre>
       <p>However, we can also deal with JIT compilers that ""lose"" the
       location information, especially between the parentheses.
    */
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null)
	return;
      String s;
      // Protect against multiple access to sw.
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      //System.out.println(""s is [""+s+""]."");
      int ibegin, iend;
      // Given the current structure of the package, the line
      // containing ""org.apache.log4j.Category."" should be printed just
      // before the caller.
      // This method of searching may not be fastest but it's safer
      // than counting the stack depth which is not guaranteed to be
      // constant across JVM implementations.
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1)
	return;
      ibegin = s.indexOf(Layout.LINE_SEP, ibegin);
      if(ibegin == -1)
	return;
      ibegin+= Layout.LINE_SEP_LEN;
      // determine end of line
      iend = s.indexOf(Layout.LINE_SEP, ibegin);
      if(iend == -1)
	return;
      // VA has a different stack trace format which doesn't
      // need to skip the inital 'at'
      if(!inVisualAge) {
	// back up to first blank character
	ibegin = s.lastIndexOf(""at "", iend);
	if(ibegin == -1)
	  return;
	// Add 3 to skip ""at "";
	ibegin += 3;
      }
      // everything between is the requested stack item
      this.fullInfo = s.substring(ibegin, iend);
    }
    /**
       Return the fully qualified class name of the caller making the
       logging request.
    */
    public
    String getClassName() {
      if(fullInfo == null) return NA;
      if(className == null) {
	// Starting the search from '(' is safer because there is
	// potentially a dot between the parentheses.
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1)
	  className = NA;
	else {
	  iend =fullInfo.lastIndexOf('.', iend);
	  // This is because a stack trace in VisualAge looks like:
          //java.lang.RuntimeException
	  //  java.lang.Throwable()
	  //  java.lang.Exception()
	  //  java.lang.RuntimeException()
	  //  void test.test.B.print()
	  //  void test.test.A.printIndirect()
	  //  void test.test.Run.main(java.lang.String [])
          int ibegin = 0;
	  if (inVisualAge) {
	    ibegin = fullInfo.lastIndexOf(' ', iend)+1;
          }
	  if(iend == -1)
	    className = NA;
	  else
	    className = this.fullInfo.substring(ibegin, iend);
	}
      }
      return className;
    }
    /**
       Return the file name of the caller.
       <p>This information is not always available.
    */
    public
    String getFileName() {
      if(fullInfo == null) return NA;
      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}
      }
      return fileName;
    }
    /**
       Returns the line number of the caller.
       <p>This information is not always available.
    */
    public
    String getLineNumber() {
      if(fullInfo == null) return NA;
      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);
      }
      return lineNumber;
    }
    /**
       Returns the method name of the caller.
    */
    public
    String getMethodName() {
      if(fullInfo == null) return NA;
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);
      }
      return methodName;
    }
}
"
org.apache.log4j.spi.LoggerFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Logger;
/**
  Implement this interface to create new instances of Logger or
  a sub-class of Logger.
  <p>See <code>examples/subclass/MyLogger.java</code> for an example.
  @author Ceki G&uuml;lc&uuml;
  @since version 0.8.5
 */
public interface LoggerFactory {
  public
  Logger makeNewLoggerInstance(String name);
}
"
org.apache.log4j.spi.LoggerRepository,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.*;
import java.util.Enumeration;
/**
   A <code>LoggerRepository</code> is used to create and retrieve
   <code>Loggers</code>. The relation between loggers in a repository
   depends on the repository but typically loggers are arranged in a
   named hierarchy.
   <p>In addition to the creational methods, a
   <code>LoggerRepository</code> can be queried for existing loggers,
   can act as a point of registry for events related to loggers.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2 */
public interface LoggerRepository {
  /**
     Add a {@link HierarchyEventListener} event to the repository.
  */
  public
  void addHierarchyEventListener(HierarchyEventListener listener);
  /**
     Is the repository disabled for a given level? The answer depends
     on the repository threshold and the <code>level</code>
     parameter. See also {@link #setThreshold} method.  */
  boolean isDisabled(int level);
  /**
     Set the repository-wide threshold. All logging requests below the
     threshold are immediately dropped. By default, the threshold is
     set to <code>Level.ALL</code> which has the lowest possible rank.  */
  public
  void setThreshold(Level level);
  /**
      Another form of {@link #setThreshold(Level)} accepting a string
      parameter instead of a <code>Level</code>. */
  public
  void setThreshold(String val);
  public
  void emitNoAppenderWarning(Category cat);
  /**
     Get the repository-wide threshold. See {@link
     #setThreshold(Level)} for an explanation. */
  public
  Level getThreshold();
  public
  Logger getLogger(String name);
  public
  Logger getLogger(String name, LoggerFactory factory);
  public
  Logger getRootLogger();
  public
  abstract
  Logger exists(String name);
  public
  abstract
  void shutdown();
  public
  Enumeration getCurrentLoggers();
  /**
     @deprecated Please use {@link #getCurrentLoggers} instead.  */
  public
  Enumeration getCurrentCategories();
  public
  abstract
  void fireAddAppenderEvent(Category logger, Appender appender);
  public
  abstract
  void resetConfiguration();
}
"
org.apache.log4j.spi.LoggingEvent,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import java.lang.reflect.Method;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.util.Hashtable;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Wolf Siberski
//                 Anders Kristensen <akristensen@dynamicsoft.com>
/**
   The internal representation of logging events. When an affirmative
   decision is made to log then a <code>LoggingEvent</code> instance
   is created. This instance is passed around to the different log4j
   components.
   <p>This class is of concern to those wishing to extend log4j.
   @author Ceki G&uuml;lc&uuml;
   @author James P. Cakalic
   @since 0.8.2 */
public class LoggingEvent implements java.io.Serializable {
  private static long startTime = System.currentTimeMillis();
  /** Fully qualified name of the calling category class. */
  transient public final String fqnOfCategoryClass;
  /** The category of the logging event. The category field is not
  serialized for performance reasons.
  <p>It is set by the LoggingEvent constructor or set by a remote
  entity after deserialization. */
  transient public Category logger;
  /** The category (logger) name. */
  public final String categoryName;
  /** Level of logging event. Level cannot be serializable
      because it is a flyweight.  Due to its special seralization it
      cannot be declared final either. */
  transient public Priority level;
  /** The nested diagnostic context (NDC) of logging event. */
  private String ndc;
  /** The mapped diagnostic context (MDC) of logging event. */
  private Hashtable mdcCopy;
  /** Have we tried to do an NDC lookup? If we did, there is no need
      to do it again.  Note that its value is always false when
      serialized. Thus, a receiving SocketNode will never use it's own
      (incorrect) NDC. See also writeObject method. */
  private boolean ndcLookupRequired = true;
 /** Have we tried to do an MDC lookup? If we did, there is no need to
      do it again.  Note that its value is always false when
      serialized. Thus, a receiving SocketNode will never use it's own
      (incorrect) MDC. See also writeObject method. */
  private boolean mdcLookupRequired = true;
  /** The application supplied message of logging event. */
  transient private Object message;
  /** The application supplied message rendered through the log4j
      objet rendering mechanism.*/
  private String renderedMessage;
  /** The name of thread in which this logging event was generated. */
  private String threadName;
  /** This
      variable contains information about this event's throwable
  */
  private ThrowableInformation throwableInfo;
  /** The number of milliseconds elapsed from 1/1/1970 until logging event
      was created. */
  public final long timeStamp;
  /** Location information for the caller. */
  private LocationInfo locationInfo;
  // Serialization
  static final long serialVersionUID = -868428216207166145L;
  static final Integer[] PARAM_ARRAY = new Integer[1];
  static final String TO_LEVEL = ""toLevel"";
  static final Class[] TO_LEVEL_PARAMS = new Class[] {int.class};
  static final Hashtable methodCache = new Hashtable(3); // use a tiny table
  /**
     Instantiate a LoggingEvent from the supplied parameters.
     <p>Except {@link #timeStamp} all the other fields of
     <code>LoggingEvent</code> are filled when actually needed.
     <p>
     @param category The category of this event.
     @param level The level of this event.
     @param message  The message of this event.
     @param throwable The throwable of this event.  */
  public LoggingEvent(String fqnOfCategoryClass, Category logger,
		      Priority priority, Object message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.logger = logger;
    this.categoryName = logger.getName();
    this.level = priority;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable);
    }
    timeStamp = System.currentTimeMillis();
  }
  /**
     Instantiate a LoggingEvent from the supplied parameters.
     <p>Except {@link #timeStamp} all the other fields of
     <code>LoggingEvent</code> are filled when actually needed.
     <p>
     @param category The category of this event.
     @param timeStamp the timestamp of this logging event
     @param level The level of this event.
     @param message  The message of this event.
     @param throwable The throwable of this event.  */
  public LoggingEvent(String fqnOfCategoryClass, Category logger,
		      long timeStamp, Priority priority, Object message,
		      Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.logger = logger;
    this.categoryName = logger.getName();
    this.level = priority;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable);
    }
    this.timeStamp = timeStamp;
  }
  /**
     Set the location information for this logging event. The collected
     information is cached for future use.
   */
  public
  LocationInfo getLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
    return locationInfo;
  }
  /**
     Return the message for this logging event.
     <p>Before serialization, the returned object is the message
     passed by the user to generate the logging event. After
     serialization, the returned value equals the String form of the
     message possibly after object rendering.
     @since 1.1 */
  public
  Object getMessage() {
    if(message != null) {
      return message;
    } else {
      return getRenderedMessage();
    }
  }
  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc;
  }
  /**
      Returns the the context corresponding to the <code>key</code>
      parameter. If there is a local MDC copy (probably from a remote
      machine, the we use it, if that fails then the current thread's
      <code>MDC</code> is used. 
      <p>Note that <em>both</em> the local MDC copy and the current
      thread's MDC are searched.
  */
  public
  Object getMDC(String key) {
    Object r;
    // Note the mdcCopy is used if it exists. Otherwise we use the MDC
    // that is associated with the thread.
    if(mdcCopy != null) {
      r = mdcCopy.get(key);
      if(r != null) {
        return r;
      }
    }
    return MDC.get(key);
  }
  /**
     Obtain a copy of this thread's MDC prior to serialization or
     asynchronous logging.  */
  public
  void getMDCCopy() {
    if(mdcLookupRequired) {
      ndcLookupRequired = false;
      // the clone call is required for asynchronous logging.
      // See also bug #5932.
      Hashtable t = (Hashtable) MDC.getContext();
      if(t != null) {
	mdcCopy = (Hashtable) t.clone();
      }
    }
  }
  public
  String getRenderedMessage() {
     if(renderedMessage == null && message != null) {
       if(message instanceof String)
	 renderedMessage = (String) message;
       else {
	 LoggerRepository repository = logger.getHierarchy();
	 if(repository instanceof RendererSupport) {
	   RendererSupport rs = (RendererSupport) repository;
	   renderedMessage= rs.getRendererMap().findAndRender(message);
	 } else {
	   renderedMessage = message.toString();
	 }
       }
     }
     return renderedMessage;
  }
  /**
     Returns the time when the application started, in milliseconds
     elapsed since 01.01.1970.  */
  public
  static
  long getStartTime() {
    return startTime;
  }
  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }
  /**
     Returns the throwable information contained within this
     event. May be <code>null</code> if there is no such information.
     <p>Note that the {@link Throwable} object contained within a
     {@link ThrowableInformation} does not survive serialization.
     @since 1.1 */
  public
  ThrowableInformation getThrowableInformation() {
    return throwableInfo;
  }
  /**
     Return this event's throwable's string[] representaion.
  */
  public
  String[] getThrowableStrRep() {
    if(throwableInfo ==  null)
      return null;
    else
      return throwableInfo.getThrowableStrRep();
  }
  private
  void readLevel(ObjectInputStream ois)
                      throws java.io.IOException, ClassNotFoundException {
    int p = ois.readInt();
    try {
      String className = (String) ois.readObject();
      if(className == null) {
	level = Level.toLevel(p);
      } else {
	Method m = (Method) methodCache.get(className);
	if(m == null) {
	  Class clazz = Class.forName(className);
	  // Note that we use Class.getDeclaredMethod instead of
	  // Class.getMethod. This assumes that the Level subclass
	  // implements the toLevel(int) method which is a
	  // requirement. Actually, it does not make sense for Level
	  // subclasses NOT to implement this method. Also note that
	  // only Level can be subclassed and not Priority.
	  m = clazz.getDeclaredMethod(TO_LEVEL, TO_LEVEL_PARAMS);
	  methodCache.put(className, m);
	}
	PARAM_ARRAY[0] = new Integer(p);
	level = (Level) m.invoke(null,  PARAM_ARRAY);
      }
    } catch(Exception e) {
	LogLog.warn(""Level deserialization failed, reverting to default."", e);
	level = Level.toLevel(p);
    }
  }
  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();
    readLevel(ois);
    // Make sure that no location info is available to Layouts
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }
  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    // Aside from returning the current thread name the wgetThreadName
    // method sets the threadName variable.
    this.getThreadName();
    // This sets the renders the message in case it wasn't up to now.
    this.getRenderedMessage();
    // This call has a side effect of setting this.ndc and
    // setting ndcLookupRequired to false if not already false.
    this.getNDC();
    // This call has a side effect of setting this.mdcCopy and
    // setting mdcLookupRequired to false if not already false.
    this.getMDCCopy();
    // This sets the throwable sting representation of the event throwable.
    this.getThrowableStrRep();
    oos.defaultWriteObject();
    // serialize this event's level
    writeLevel(oos);
  }
  private
  void writeLevel(ObjectOutputStream oos) throws java.io.IOException {
    oos.writeInt(level.toInt());
    Class clazz = level.getClass();
    if(clazz == Level.class) {
      oos.writeObject(null);
    } else {
      // writing directly the Class object would be nicer, except that
      // serialized a Class object can not be read back by JDK
      // 1.1.x. We have to resort to this hack instead.
      oos.writeObject(clazz.getName());
    }
  }
}
"
org.apache.log4j.spi.OptionHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
/**
   A string based interface to configure package components.
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.1
 */
public interface OptionHandler {
  /**
     Activate the options that were previously set with calls to option
     setters.
     <p>This allows to defer activiation of the options until all
     options have been set. This is required for components which have
     related options that remain ambigous until all are set.
     <p>For example, the FileAppender has the {@link
     org.apache.log4j.FileAppender#setFile File} and {@link
     org.apache.log4j.FileAppender#setAppend Append} options both of
     which are ambigous until the other is also set.  */
  void activateOptions();
  /**
     Return list of strings that the OptionHandler instance recognizes.
     @deprecated We now use JavaBeans style getters/setters.
   */
  //  String[] getOptionStrings();
  /**
     Set <code>option</code> to <code>value</code>.
     <p>The handling of each option depends on the OptionHandler
     instance. Some options may become active immediately whereas
     other may be activated only when {@link #activateOptions} is
     called.
     @deprecated We now use JavaBeans style getters/setters.
  */
  //void setOption(String option, String value);
}
"
org.apache.log4j.spi.RendererSupport,"package org.apache.log4j.spi;
import org.apache.log4j.*;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
public interface RendererSupport {
  public
  RendererMap getRendererMap();
  public
  void setRenderer(Class renderedClass, ObjectRenderer renderer);
}
"
org.apache.log4j.spi.RepositorySelector,"package org.apache.log4j.spi;
/**
   The <code>LogManager</code> uses one (and only one)
   <code>RepositorySelector</code> implementation to select the
   {@link LoggerRepository} for a particular application context.
   <p>It is the responsability of the <code>RepositorySelector</code>
   implementation to track the application context. Log4j makes no
   assumptions about the application context or on its management.
   <p>See also {@link org.apache.log4j.LogManager LogManager}.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2
 */
public interface RepositorySelector {
  /**
     Returns a {@link LoggerRepository} depending on the
     context. Implementors must make sure that a valid (non-null)
     LoggerRepository is returned.
  */
  public
  LoggerRepository getLoggerRepository();
}
"
org.apache.log4j.spi.RootCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import  org.apache.log4j.*;
import  org.apache.log4j.helpers.LogLog;
// Contibutors: Mathias Bogaert
/**
   RootCategory sits at the top of the category hierachy. It is a
   regular category except that it provides several guarantees.
   <p>First, it cannot be assigned a <code>null</code>
   priority. Second, since root category cannot have a parent, the
   {@link #getChainedLevel} method always returns the value of the
   level field without walking the hierarchy.
   @author Ceki G&uuml;lc&uuml;
 */
final public class RootCategory extends Logger {
  /**
     The root category names itself as ""root"". However, the root
     category cannot be retrieved by name.  
  */
  public
  RootCategory(Level level) {
    super(""root"");
    setLevel(level);
  }
  /**
     Return the assigned level value without walking the category
     hierarchy.
  */
  final
  public 
  Level getChainedLevel() {
    return level;
  }
  /**
     Setting a null value to the level of the root category may have catastrophic
     results. We prevent this here.
     @since 0.8.3 */
  final  
  public
  void setLevel(Level level) {
    if(level == null) {
      LogLog.error(""You have tried to set a null level to root."",
		   new Throwable());
    }
    else {
      this.level = level;
    }
  }
  final  
  public
  void setPriority(Level level) {
    setLevel(level);
  }
}
"
org.apache.log4j.spi.ThrowableInformation,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
import java.io.Writer;
import java.io.PrintWriter;
import java.util.Vector;
/**
 */
public class ThrowableInformation implements java.io.Serializable {
  static final long serialVersionUID = -4748765566864322735L;
  private transient Throwable throwable;
  private String[] rep;
  public
  ThrowableInformation(Throwable throwable) {
    this.throwable = throwable;
  }
  public
  Throwable getThrowable() {
    return throwable;
  }
  public
  String[] getThrowableStrRep() {
    if(rep != null) {
      return (String[]) rep.clone();
    } else {
      VectorWriter vw = new VectorWriter();
      throwable.printStackTrace(vw);
      rep = vw.toStringArray();
      vw.clear();
      return rep;
    }
  }
}
class VectorWriter extends PrintWriter {
  private Vector v;
  VectorWriter() {
    super(new NullWriter());
    v = new Vector();
  }
  // Support for Orion
  public
  void print(Object o) {      
    v.addElement(o.toString());
  }
  // Support for Orion
  public
  void print(char[] s) {
    v.addElement(new String(s));
  }
  // Support for Orion
  public
  void print(String s) {
    v.addElement(s);
  }
  public
  void println(Object o) {      
    v.addElement(o.toString());
  }
  // JDK 1.1.x apprenly uses this form of println while in
  // printStackTrace()
  public
  void println(char[] s) {
    v.addElement(new String(s));
  }
  public  
  void println(String s) {
    v.addElement(s);
  }
  public
  String[] toStringArray() {
    int len = v.size();
    String[] sa = new String[len];
    for(int i = 0; i < len; i++) {
      sa[i] = (String) v.elementAt(i);
    }
    return sa;
  }
  public
  void clear() {
    v.setSize(0);
  }
}  
class NullWriter extends Writer {    
  public 
  void close() {
  }
  public 
  void flush() {
  }
  public
  void write(char[] cbuf, int off, int len) {
  }
}
"
org.apache.log4j.spi.TriggeringEventEvaluator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.spi;
/**
   Implementions of this interface allow certain appenders to decide
   when to perform an appender specific action.
  <p>For example the {@link org.apache.log4j.net.SMTPAppender} sends
  an email when the {@link #isTriggeringEvent} method returns
  <code>true</code> and adds the event to an internal buffer when the
  returned result is <code>false</code>.
  @author Ceki G&uuml;lc&uuml;
  @since version 1.0
 */
public interface TriggeringEventEvaluator {
  /**
     Is this the triggering event?
   */
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
org.apache.log4j.test.AsyncAppenderTest,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
/**
   Test the coordination of the AsyncAppender with its Dispatcher.
   @author  Ceki G&uuml;lc&uuml;
*/
public class AsyncAppenderTest {
  static Category cat = Category.getInstance(AsyncAppenderTest.class);
  static int delayBeforeClose;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile, String delayBeforeCloseStr) {
    DOMConfigurator.configure(configFile);
    try {
      delayBeforeClose   = Integer.parseInt(delayBeforeCloseStr);
    } catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not convert [""+delayBeforeCloseStr+""] to Integer."");
    }      
  }
  static
  void test() {    
    Category root = Category.getRoot();    
    for(int i = 0; i < 100; i++) {      
      root.debug(""Message "" + i);        
    }
    try{Thread.currentThread().sleep(delayBeforeClose);}catch(Exception e){}
    Category.shutdown();
  }
}
"
org.apache.log4j.test.Base64,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.test;
class Base64 {
  final static int MAX_LINE = 76;
  static byte[] asciiEncoding =
    //A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q  
    {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
    //R  S ...                        Z   a   b   c    d    e    f    g
    82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,
    //h    i    j    k    l    m    n    o    p    q    r    s   t     u
    104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
    //v    w    x    y    z   0   1   2   3   4   5   6   7   8   9   +   /
    118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47}; 
  static char[] charEnc = new char[64];
  static {
    for(int i = 0; i < 26; i ++) {
      charEnc[i] = (char) ('A' + i);
      charEnc[i+26] = (char) ('a' + i);
    }
    for(int i = 0; i < 10; i ++) {
      charEnc[i+52] = (char) ('0' + i);
    }
    charEnc[62] = '+';
    charEnc[63] = '/';
  }
  static
  String toString(byte[] inbuf) {
    return toString(inbuf, 0, inbuf.length);
  }
  /**
   */
  static
  String toString(byte[] inbuf, int offset, int length) {
    StringBuffer output = new StringBuffer((length)*4/3 + 1);
    int in;
    char[] out = new char[4];
    int i = offset;
    boolean ended = false;
    int last = offset + length;
    int j;
    int bitsRead;
    while(!ended) {
      in = 0;
      bitsRead = 0;
      for(j = 0; j < 3; j++) {
	if(i == last) {
	  ended = true;
	  break;
	}
	in = (in << 8) | (inbuf[i++] & 0xFF);
	bitsRead += 8;
      }
      while(bitsRead >= 6) {
	bitsRead -= 6;
	output.append(charEnc[(in >>> bitsRead) & 0x3F]);
      }
      if(bitsRead == 4) {
	output.append(charEnc[(in & 0x0F) << 2]);
	output.append(""="");
      }
      else if (bitsRead == 2) {
	output.append(charEnc[(in & 0x03) << 4]);
	output.append(""=="");
      }
    }
    return output.toString();
  }
  public static void main(String[] args) {
    byte[] inbuf = new byte[MAX_LINE];
    while(true) {
      try {
	int read = System.in.read(inbuf, 0, MAX_LINE);
	if(read == -1) break;
	System.out.println(""Read "" + read + "" chars."");
	System.out.println(Base64.toString(inbuf, 0, read));
      }
      catch (Exception e) {
	System.out.println(""Exception "" + e);
      }
    }
  }
}
"
org.apache.log4j.test.CategoryWrapper,"package org.apache.log4j.test;
import org.apache.log4j.*;
/**
   This is just to test that wrapper can work. This implementation is
   actually quite bad and should be avoided.
*/
public class CategoryWrapper {
  Category c;
  static String FQCN = CategoryWrapper.class.getName();
  CategoryWrapper(String name) {
    c = Category.getInstance(name);
  }
  public 
  static 
  void main(String argv[]) {    
    Layout layout = new PatternLayout(""%p [%t] %C %F - %m\n"");
    Appender out = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_OUT);
    CategoryWrapper w1 = new CategoryWrapper(""c1"");
    w1.addAppender(out);
    w1.print(""hello"");
  }
  public 
  void addAppender(Appender appender) {
    c.addAppender(appender);
  }
  public 
  void print(String msg) {
    // You have to supply the fully qualified named of the wrapper
    // class to the specially tailored category.log method for
    // PatternLayout's %C conversion pattern to work.
    // We have to add the "".print"" string because the invocation of
    // wrapper.print method is made from the wrapper itself (main
    // method). This is highly unusual. The fqcn of the wrapper is
    // normally sufficient.
    c.log(FQCN+"".print"", Priority.DEBUG, msg, null);
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+CategoryWrapper.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.ConfigurationFileParsing,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
public class ConfigurationFileParsing {
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) {
      NDC.push(""testing"");
      PropertyConfigurator.configure(argv[0]);
      Category root = Category.getRoot();
      root.debug(""Message 1"");
      root.debug(""Message 2"");      
      NDC.pop();
      Category.shutdown();
    }
    else {
      Usage(""Wrong number of arguments."");
    }
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ConfigurationFileParsing.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DefaultInit,"package org.apache.log4j.test;
import org.apache.log4j.Category;
public class DefaultInit {
  static Category cat = Category.getInstance(DefaultInit.class);
  public static void main( String[] argv) {
    cat.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.DefaultInit "");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DelayedLoop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
/**
   This test program sits in a loop and logs things. Its logging is
   configured by a configuration file. Changes to this configuration
   file are monitored and when a change occurs, the config file is re-read.
   @author Ceki G&uuml;lc&uuml; */
public class DelayedLoop {
  static Category cat = Category.getInstance(DelayedLoop.class);
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DelayedLoop.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    if(configFile.endsWith(""xml"")) {
      DOMConfigurator.configureAndWatch(configFile, 3000);
    } else {
      PropertyConfigurator.configureAndWatch(configFile, 3000);
    }
  }
  static
  void test() {
    int i = 0;
    while(true) {
      cat.debug(""MSG ""+i++);
      try {
	Thread.currentThread().sleep(1000);
      } catch(Exception e) {}
    }
  }
}
"
org.apache.log4j.test.DRFATest,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.test;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.Appender;
import org.apache.log4j.DailyRollingFileAppender;
/**
   This class is used in testing the DailyRollingFileAppender.
   @author  Ceki G&uuml;lc&uuml;
*/
public class DRFATest {
  static Category cat = Category.getInstance(DRFATest.class);
  static int limit;
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ DRFATest.class.getName()+"" length"");
    System.exit(1);
  }
  static
  void init(String limitStr) {
    try {
      limit =  Integer.parseInt(limitStr);
    } catch(java.lang.NumberFormatException e) {
      usage(""Could not convert ""+limitStr+"" to int"");
    }
  }
  static
  void test() {
    Layout layout = new PatternLayout(""%d{yyyy-MM-dd-HH-mm ss:SSS} %m%n"");
    try {
      Appender appender = new DailyRollingFileAppender(layout, ""test"",
						       ""'.'yyyy-MM-dd-HH-mm"" );
      appender.setName(""drfa"");
      BasicConfigurator.configure(appender);
    } catch(Exception e) {
      System.err.println(""Could not create DailyRollingFileAppender"");
      e.printStackTrace();
    }
    System.out.println(""Limit: ""+limit);
    for(int i = 0; i < limit; i++) {
      System.out.println(i);
      cat.debug(""Message""+ i);
      delay(10000);
      if((i % 7) == 0) {
	System.out.println(""Sleeping 1min."");
	delay(60000);
	System.err.println("""");
      }
    }
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.Finalize,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import java.io.InputStreamReader;
import java.util.Enumeration;
public class Finalize {
  static Category CAT = Category.getInstance(Finalize.class.getName());
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Finalize.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    InputStreamReader in = new InputStreamReader(System.in);
    Category root = Category.getRoot();
    System.out.println(""Type 'q' to quit"");
    int j = 0;
    while (true) {
      System.gc();
      try {i = in.read(); }
      catch(Exception e) { return; }
      System.gc();
      System.out.println(""Read [""+i+""]."");
      if(i == -1)
	break;
      else if(i == 'q')
	break;
      else
	root.debug(""Hello "" + (++j));
    }
    //foo(root);
    root.removeAllAppenders();
    System.gc(); delay(3000);
    System.gc(); delay(3000);
    System.gc(); delay(3000);  System.gc();
  }
  static
  void foo(Category cat) {
    Enumeration enum = cat.getAllAppenders();
    while(enum != null && enum.hasMoreElements()) {
      ((org.apache.log4j.Appender) enum.nextElement()).close();
    }
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.FQCNTest,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.test; 
import org.apache.log4j.*;
import org.apache.log4j.spi.*;
//import org.apache.log4j.xml.examples.XPriority;
/** 
   This class is a shallow test of the various appenders and
   layouts. It also tests their reading of the configuration file.
   @author  Ceki G&uuml;lc&uuml;
*/
public class FQCNTest {
  //static Logger cat = Logger.getLoggerInstance(""dddd"");
  public 
  static 
  void main(String argv[]) throws Exception  {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ FQCNTest.class.getName()+""outputFile"");
    System.exit(1);
  } 
  static 
  void init(String file) throws Exception {
    Layout layout = new PatternLayout(""%p %c (%C{2}#%M) - %m%n"");
    FileAppender appender = new FileAppender(layout, file, false);
    appender.setLayout(layout);
    Category root = Category.getRoot();
    root.addAppender(appender);
  }
  static
  void test() {
    X1Logger x1 = X1Logger.getX1Logger(""x1"");
    x1.debug(""hello"");    
    x1.debug1(""hello"");  
    x1.debug2(""hello"");  
  }  
}
// ==========================================================================
// ==========================================================================
// ==========================================================================
class X1Logger extends Logger {
  static String FQCN = X1Logger.class.getName() + ""."";
  private static X1LoggerFactory factory = new X1LoggerFactory();
  public X1Logger(String name) {
    super(name);
  }
  public 
  void debug1(Object message) {    
    super.log(FQCN, Priority.DEBUG, message + "" world."", null);    
  }
  public
  void debug2(Object message) {
    super.log(FQCN, Priority.DEBUG, message, null); 
  }
  protected
  String getFQCN() {
    return X1Logger.FQCN;
  }
  public 
  static
  X1Logger getX1Logger(String name) {
    return ((X1Logger) Logger.getLogger(name, factory)); 
  }
}
class X1LoggerFactory implements LoggerFactory {
  public
  X1LoggerFactory() {
  }
  public
  Logger makeNewLoggerInstance(String name) {
    return new X1Logger(name);
  }
}
"
org.apache.log4j.test.Hello,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
/**
   Very simple log4j usage example.
   @author  Ceki G&uuml;lc&uuml;   
 */
public class Hello {
  static Category cat = Category.getInstance(Hello.class);
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    cat.debug(""Hello world."");
    cat.info(""What a beatiful day."");
  }
}
"
org.apache.log4j.test.L7D,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
// 
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.test; 
import org.apache.log4j.*;
import java.util.*;
import java.text.*;
/**
   This class is a simple test of the localization routines in
   Category class.
   @author Ceki G&uuml;lc&uuml;, IBM Zurich Research Laboratory */
public class L7D {
  static ResourceBundle[] bundles;
  public 
  static 
  void main(String args[]) {
    if(args.length == 3) 
      init(args[0], args[1], args[2]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + L7D.class.getName() +
			""configFile ISO639LanguageCode ISO2166CountryCode"");
    System.exit(1);
  }
  static
  void init(String configFile, String lanCode, String countryCode) {
    PropertyConfigurator.configure(configFile);
    bundles = new ResourceBundle[3];
    try {
      bundles[0] = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
      bundles[1] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
      bundles[2] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH"")); 
    }
    catch(MissingResourceException e) {
      e.printStackTrace();
    }
  }
  static
  void test() { 
    Category root = Category.getRoot();
    for(int i = 0; i < bundles.length; i++) {
      root.setResourceBundle(bundles[i]);
      root.l7dlog(Priority.DEBUG, ""bogus1"", null);            
      root.l7dlog(Priority.INFO, ""test"", null);
      root.l7dlog(Priority.WARN, ""hello_world"", null);
      root.l7dlog(Priority.DEBUG, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.ERROR, ""bogusMsg"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);      
      root.l7dlog(Priority.ERROR, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.INFO, ""bogus2"", null);
    }
  }
}
"
org.apache.log4j.test.MDCStress,"package org.apache.log4j.test;
import org.apache.log4j.*;
import java.util.Random;
public class MDCStress extends Thread {
  static Category root = Category.getRoot();  
  static Category log = Category.getInstance(MDCStress.class);
  static Random random = new Random(17);
  static final int BRANCHING_FACTOR = 2;
  static final int LOOP_LENGTH = 12;
  static int maxThreads;  
  static int threadCounter = 0;  
  static int totalThreads = 0;  
  public 
  static 
  void main(String args[]) {
    Layout layout = new PatternLayout(""%r [%t] depth=%X{depth} total=%X{total} - %m%n"");
    Appender appender = new ConsoleAppender(layout);
    root.addAppender(appender);
    if(args.length != 1) {
      usage();
    }
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    while(true) {
      synchronized(MDCStress.class) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1, 0);
	// wait until all threads are finished
	try {
	  root.debug(""About to wait for notification."");
	  MDCStress.class.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println( ""Usage: ""+MDCStress.class + "" maxThreads"");
    System.exit(1);
  }
  public
  static
  void createChildren(int n, int currentDepth) {
    if (n <= 0)
      return;
    synchronized(MDCStress.class) {
      n = maxThreadsConstained(n);    
      for(int i = 0; i < n; i++) {
	threadCounter++;
	totalThreads++;
	log.debug(""Creating Thread-""+(totalThreads-1));
	new MDCStress(currentDepth+1, totalThreads-1).start();
      }
    }
  }
  int depth;
  int total;
  MDCStress(int depth, int totalThreads) {
    this.depth = depth;
    this.total = totalThreads;
  }
  public
  void run() {
    log.debug(""Entered run()"");
    createChildren(randomInt(BRANCHING_FACTOR), depth);
    MDC.put(""depth"", new Integer(depth));
    MDC.put(""total"", new Integer(this.total));
    log.debug(""Set MDC variables."");   
    createChildren(randomInt(BRANCHING_FACTOR), depth);
    synchronized(MDCStress.class) {
      threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(threadCounter <= 0) {
	MDCStress.class.notify(); // wake up the main thread
      }
    }     
  }
  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = MDCStress.maxThreads - MDCStress.threadCounter;      
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  static
  String randomID() {
    return Integer.toHexString(random.nextInt()& 0xFFFFFF);
  }
}
"
org.apache.log4j.test.MultipleAppenders,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Appender;
import java.util.Enumeration;
import java.util.Vector;
public class MultipleAppenders {
  public 
  static 
  void main(String argv[]) {
    // A1 and A2 should be added to root by reading the config file
    PropertyConfigurator.configure(argv[0]);
    Category root = Category.getRoot();
    Enumeration e1 = root.getAllAppenders();
    Vector v = new Vector(1);
    while(e1.hasMoreElements()) {
      Appender a = (Appender) e1.nextElement();
      v.addElement(a);
      String appenderName = a.getName();	
      if(a != root.getAppender(appenderName)) {
	System.out.println(appenderName + "" lookup failed. Exiting."");
	System.exit(1);
      }
      // attempt to add the existing appender
      root.addAppender(a);
    }
    // attempt to add a null appender
    root.addAppender(null);
    Enumeration e2 = root.getAllAppenders();
    for(int i = 0; i < v.size(); i++) {
      if(v.elementAt(i) != e2.nextElement()) {
      }
    }
    if(e2.hasMoreElements()){
      System.out.println(""Failure, e2 has remaining elements. Exiting."");
      System.exit(1);      
    }
    System.out.println(""OK"");
  }
}
"
org.apache.log4j.test.PatternTest,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
/**
   This class is a test of the PatternLayout class.
   @author Ceki G&uuml;lc&uuml;
*/
public class PatternTest {
  static Category CAT = Category.getInstance(PatternTest.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + PatternTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    CAT.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    CAT.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    CAT.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    CAT.error(""Message "" + ++i);
    root.error(""Message "" + i);
    CAT.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    CAT.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    CAT.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    
    CAT.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    
    CAT.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    CAT.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    
    Category.shutdown();
  }
}
"
org.apache.log4j.test.PrintProperties,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.test;
import java.io.*;
import org.apache.log4j.config.PropertyPrinter;
/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on System.out.
   @author  Anders Kristensen
 */
public class PrintProperties {
  public
  static
  void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out), true);
  }
}"
org.apache.log4j.test.ROFile,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
public class ROFile {
  static Category cat = Category.getInstance(ROFile.class.getName());
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + ROFile.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    cat.debug(""Message "" + ++i);
  }
}
"
org.apache.log4j.test.Shallow,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
// NOTICE: Some tests are sensitive to line numbers!
package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
/**
   This class is a shallow test of the various appenders and
   layouts. It also tests their reading of the configuration file.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Shallow {
  static Category cat = Category.getInstance(Shallow.class);
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName()+""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    if(configFile.endsWith("".xml""))
      DOMConfigurator.configure(configFile);
    else
      PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    NDC.push(""NDC"");
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);
    cat.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);
    cat.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);
    root.setPriority(Priority.FATAL);
    // It is always a good idea to call this method when exiting an
    // application.
    Category.shutdown();
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.ShortSocketServer,"package org.apache.log4j.test;
import java.net.Socket;
import java.net.ServerSocket;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.net.SocketNode;
/**
*/
public class ShortSocketServer  {
  static Category cat = Category.getInstance(ShortSocketServer.class.getName());
  static int port;
  public
  static
  void main(String argv[]) {
    if(argv.length == 2) {
      init(argv[0], argv[1]);
    } else {
      usage(""Wrong number of arguments."");
    }
    try {
      LogLog.debug(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      LogLog.debug(""Waiting to accept a new client."");
      Socket socket = serverSocket.accept();
      LogLog.debug(""Connected to client at "" + socket.getInetAddress());
      LogLog.debug(""Starting new socket node."");
      SocketNode sn = new SocketNode(socket, Category.getDefaultHierarchy());
      Thread t = new Thread(sn);
      t.start();
      t.join();
    }
    catch(Exception e) {
      cat.error(""Error while in main."", e);
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +ShortSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile) {
    try {
      port   = Integer.parseInt(portStr);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);
  }
}
"
org.apache.log4j.test.SpacePad,"package org.apache.log4j.test;
public class SpacePad {
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32
  static public void main(String[] args) {
    StringBuffer sbuf = new StringBuffer();
    for(int i = 0; i < 35; i++) {
      sbuf.setLength(0);
      sbuf.append(""\"""");
      spacePad(sbuf, i);
      sbuf.append(""\"""");
      System.out.println(sbuf.toString());
    }
    sbuf.setLength(0);
    sbuf.append(""\"""");
    spacePad(sbuf, 67);
    sbuf.append(""\"""");
    System.out.println(sbuf.toString());
  }
  static
  public
  void spacePad(StringBuffer sbuf, int length) {
    //LogLog.debug(""Padding with "" + length + "" spaces."");
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.test.StressAsyncAppender,"//  Copyright 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
import java.util.Random;
/**
   Stress test {@link AsyncAppender}.
 */
public class StressAsyncAppender extends Thread {
  static Category root = Category.getRoot();
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int BRANCHING_FACTOR = 4;
  static int maxThreads;
  static long msgCounter = 0;
  static int threadCounter = 0;
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public
  static
  void main(String args[]) {
    if(args.length != 1) {
      usage();
    }
    DOMConfigurator.configure(""xml/stressAsyncAppender.xml"");
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created.
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug(""About to wait for notification."");
	  lock.wait();
	  root.debug(""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println(""Usage: java ""+ StressAsyncAppender.class.getName() +
			"" MAX_THREADS"");
    System.exit(1);
  }
  public
  StressAsyncAppender() {
  }
  public
  void run() {
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug(""In run loop, loopLength = ""+loopLength);
    // half of the way, create new childres
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      synchronized(lock) {
	root.debug(""Message number "" + msgCounter++);
      }
      //delay(1+randomInt(4)*100);
    }
    synchronized(lock) {
      StressAsyncAppender.threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(StressAsyncAppender.threadCounter <= 0) {
	root.debug(""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstrained(n);
      root.debug(""Creating "" + n+ "" child StressAsyncAppender threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressAsyncAppender, threadCounter = "" + (++threadCounter));
	new StressAsyncAppender().start();
      }
    }
  }
  static
  public
  int maxThreadsConstrained(int a) {
    int maxAllowed = StressAsyncAppender.maxThreads -
                                                 StressAsyncAppender.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  void delay(long millis) {
    try {
      Thread.currentThread().sleep(millis);
    } catch(Exception e) {}
  }
}
"
org.apache.log4j.test.StressNDC,"//      Copyright 1996-1999, International Business Machines
//      Corporation and others. All Rights Reserved.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.NDC;
import java.util.Random;
import java.util.Stack;
/**
   Stress test {@link NDC}.
 */
public class StressNDC extends Thread {
  static Category root = Category.getRoot();
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int PUSH_MISS = LOOP_LENGTH/2;
  static final int POP_MISS = PUSH_MISS*2;
  static final int BRANCHING_FACTOR = 4 + 1; // add 1 to the number you want
  static int maxThreads;
  static int msgCounter = 0;
  static int threadCounter = 0;
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public
  static
  void main(String args[]) {
    BasicConfigurator.configure();
    if(args.length != 1) {
      usage();
    }
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    root.debug( ""push(IP=127.0.0.1)"");
    NDC.push(""IP=127.0.0.1"");
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created.
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug( ""About to wait for notification."");
	  lock.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println( ""Usage: java org.apache.log4j.test.StressNDC "" +
			""MAX_THREADS"");
    System.exit(1);
  }
  Stack parentDC;
  public
  StressNDC(Stack parentDC) {
    this.setName(randomID());
    this.parentDC = parentDC;
  }
  public
  void run() {
    NDC.inherit(parentDC);
    int loopLength = StressNDC.randomInt(LOOP_LENGTH);
    root.debug(""In run loop.debug( loopLength = ""+loopLength);
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      if(randomInt(PUSH_MISS) == 0) {
	String id = randomID();
	root.debug( ""push(""+id+"")"");
	NDC.push(id);
      }
      root.debug( ""Message number "" + StressNDC.msgCounter++);
      if(randomInt(POP_MISS) == 0) {
	root.debug( ""pop()"");
	NDC.pop();
      }
    }
    synchronized(lock) {
      StressNDC.threadCounter--;
      root.debug( ""Exiting run loop. "" + threadCounter);
      if(StressNDC.threadCounter <= 0) {
	root.debug( ""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
    // We sometimes forget to remove references
    if((loopLength % 2) == 0) {
      root.debug(""Removing NDC for this thread."");
      NDC.remove();
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstained(n);
      root.debug(""Creating "" + n+ "" child StressNDC threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressNDC, threadCounter = "" + (++threadCounter));
	new StressNDC(NDC.cloneStack()).start();
      }
    }
  }
  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = StressNDC.maxThreads - StressNDC.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  static
  String randomID() {
    return Integer.toString(random.nextInt()& 0xFFFFFF);
  }
}
"
org.apache.log4j.test.SysoutConfigurator,"package org.apache.log4j.test;
import org.apache.log4j.spi.*;
import org.apache.log4j.*;
/**
 * This configurator simply always adds a FileAppender writing to
 * System.out to the root Category and ignores whatever is in the
 * properties file.
 */
public class SysoutConfigurator implements Configurator {
  public
  void
  doConfigure(java.net.URL url,  LoggerRepository hierarchy) {
    Category.getRoot().addAppender(
        new ConsoleAppender(
            new SimpleLayout(), ConsoleAppender.SYSTEM_OUT));
  }
}
"
org.apache.log4j.test.serialization.SerializationUT,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;
import java.util.Hashtable;
import java.net.URL;
import java.net.URLClassLoader;
import java.lang.reflect.Method;
/**
   The SerializationUnitTest checks whether the {@link LoggingEvent}
   objects are compatible across different log4j versions.
   @author Ceki G&uuml;lc&uuml;
*/
public class SerializationUT extends TestCase {
  // String categoryName
  // String ndc
  // boolan ndcLookupRequired
  // String renderedMessage
  // String threadName
  // long timeStamp
  static URLClassLoader classLoader113;
  static Class class113;
  static Object o113;
  static Method serMethod113;
  static Method deserMethod113;
  static URLClassLoader classLoader12a7;
  static Class class12a7;
  static Object o12a7;
  static Method serMethod12a7;
  static Method deserMethod12a7;
  public SerializationUT(String name) {
    super(name);
  }
  public
  void setUp() throws Exception {
    try {
      URL urlLocal = new URL(""file:T/"");
      URL url113 = new URL(""file:T/log4j-1.1.3.jar"");
      classLoader113 = new URLClassLoader(new URL[] {urlLocal, url113});
      class113  = classLoader113.loadClass(""T113"");
      o113 = class113.newInstance();
      serMethod113 = class113.getMethod(""serialize"",
					new Class[] {java.util.Hashtable.class});
      deserMethod113 = class113.getMethod(""deserialize"",
					  new Class[] {byte[].class});
      URL url2a7 = new URL(""file:T/log4j-1.2alpha7.jar"");
      classLoader12a7 = new URLClassLoader(new URL[] {urlLocal, url2a7});
      class12a7 = classLoader12a7.loadClass(""T12"");
      o12a7 = class12a7.newInstance();
      serMethod12a7 = class12a7.getMethod(""serialize"",
					 new Class[] {java.util.Hashtable.class});
      deserMethod12a7 = class12a7.getMethod(""deserialize"",
					   new Class[] {byte[].class});
    } catch(Exception e) {
      e.printStackTrace();
      throw e;
    }
    System.out.println(""---Exiting setup"");
  }
  public
  void tearDown() {
  }
  /**
     Test writing in 1.1.3 and reading from 1.1.3. Here we are testing
     the test.  */
  public
  void test1() throws Exception {
    Hashtable inHt = new Hashtable();
    Hashtable witness = new Hashtable();
    inHt.put(""categoryName"", ""a.b.c"");
    inHt.put(""priorityStr"", ""DEBUG"");
    inHt.put(""message"", ""hello"");
    witness.put(""categoryName"", ""a.b.c"");
    witness.put(""priorityStr"", ""DEBUG"");
    witness.put(""renderedMessage"", ""hello"");
    byte[] buf = (byte[]) serMethod113.invoke(o113, new Object[] {inHt});
    Hashtable outHt = (Hashtable) deserMethod113.invoke(o113, new Object[] {buf});
    System.out.println(""witness""+witness);
    System.out.println(""outHt  ""+outHt);
    assertEquals(witness, outHt);
  }
  /**
     Test writing 1.2 and reading from 1.2. Here we are testing the test.
  */
  public
  void test2() throws Exception {
    Hashtable inHt = new Hashtable();
    Hashtable witness = new Hashtable();
    inHt.put(""categoryName"", ""a.b.c"");
    inHt.put(""priorityStr"", ""DEBUG"");
    inHt.put(""message"", ""hello"");
    witness.put(""categoryName"", ""a.b.c"");
    witness.put(""priorityStr"", ""DEBUG"");
    witness.put(""renderedMessage"", ""hello"");
    byte[] buf = (byte[]) serMethod12a7.invoke(o12a7, new Object[] {inHt});
    Hashtable outHt = (Hashtable) deserMethod12a7.invoke(o12a7, new Object[] {buf});
    assertEquals(witness, outHt);
  }
  /**
     Test writing 1.1.3 and reading from 1.2.
  */
  public
  void test3() throws Exception {
    Hashtable inHt = new Hashtable();
    Hashtable witness = new Hashtable();
    inHt.put(""categoryName"", ""a.b.c"");
    inHt.put(""priorityStr"", ""DEBUG"");
    inHt.put(""message"", ""hello"");
    witness.put(""categoryName"", ""a.b.c"");
    witness.put(""priorityStr"", ""DEBUG"");
    witness.put(""renderedMessage"", ""hello"");
    byte[] buf = (byte[]) serMethod113.invoke(o113, new Object[] {inHt});
    Hashtable outHt = (Hashtable) deserMethod12a7.invoke(o12a7, new Object[] {buf});
    assertEquals(witness, outHt);
  }
  /**
     Test writing 1.2 and reading from 1.1.3.
  */
  public
  void test4() throws Exception {
    Hashtable inHt = new Hashtable();
    Hashtable witness = new Hashtable();
    inHt.put(""categoryName"", ""a.b.c"");
    inHt.put(""priorityStr"", ""DEBUG"");
    inHt.put(""message"", ""hello"");
    Exception e = new ComparableException(""test4"");
    inHt.put(""throwable"", e);
    witness.put(""categoryName"", ""a.b.c"");
    witness.put(""priorityStr"", ""DEBUG"");
    witness.put(""renderedMessage"", ""hello"");
    witness.put(""throwable"", e);
    byte[] buf = (byte[]) serMethod12a7.invoke(o12a7, new Object[] {inHt});
    Hashtable outHt = (Hashtable) deserMethod113.invoke(o113, new Object[] {buf});
    //System.out.println(""witness""+witness);
    //System.out.println(""outHt  ""+outHt);
    assertEquals(witness, outHt);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new SerializationUT(""test1""));
    suite.addTest(new SerializationUT(""test2""));
    suite.addTest(new SerializationUT(""test3""));
    suite.addTest(new SerializationUT(""test4""));
    return suite;
  }
}
class ComparableException extends Exception {
  public ComparableException(String msg) {
    super(msg);
  }
  public boolean equals(Object o) {
    System.out.println(""ComparableException.equals called."");
    if(!(o instanceof ComparableException))
      return false;
    ComparableException r = (ComparableException) o;
    if(r.getMessage() == null) {
      if(getMessage() != null)
	return false;
    } else if(!r.getMessage().equals(getMessage())) {
      return false;
    }
    return true;
  }
}
"
org.apache.log4j.test.serialization.T.T113,"import java.io.*;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.LoggingEvent;
import java.util.Hashtable;
// String categoryName
// String ndc
// boolan ndcLookupRequired
// String renderedMessage
// String threadName
// long timeStamp
// LocationInfo
// ThrowableInformation ti.
public class T113 {
  public
  byte[] serialize(Hashtable ht) {
    try {
      Category category = Category.getInstance((String) ht.get(""categoryName""));
      LoggingEvent event = new LoggingEvent(""org.apache.log4j.Category"", 
					    category, 
					    Priority.toPriority((String)ht.get(""priorityStr"")),
					    ht.get(""message""), 
					    (Throwable) ht.get(""throwable""));
      event.getThreadName();
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(baos);
      oos.writeObject(event);
      oos.flush();
      return baos.toByteArray();
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }
  public
  Hashtable deserialize(byte[] buf) {
    try {
      System.out.println(""deserialize called."");
      ByteArrayInputStream bais = new ByteArrayInputStream(buf);
      ObjectInputStream si = new ObjectInputStream(bais);  
      LoggingEvent event = (LoggingEvent)  si.readObject();	    
      System.out.println(""Desrialization looks successful."");
      return eventToHashtable(event);
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }
  Hashtable eventToHashtable(LoggingEvent event) {
    Hashtable ht = new Hashtable();
    ht.put(""categoryName"", event.categoryName);
    ht.put(""renderedMessage"", event.getRenderedMessage());
    ht.put(""priorityStr"", event.priority.toString());
    ht.put(""throwableInfo"", event.getThrowableInformation());
    return ht;
  }
}
"
org.apache.log4j.test.serialization.T.T12,"import java.io.*;
import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import java.util.Hashtable;
// String categoryName
// String ndc
// boolan ndcLookupRequired
// String renderedMessage
// String threadName
// long timeStamp
// LocationInfo
// ThrowableInformation ti.
public class T12 {
  public
  byte[] serialize(Hashtable ht) {
    try {
      Category category = Category.getInstance((String) ht.get(""categoryName""));
      LoggingEvent event = new LoggingEvent(""org.apache.log4j.Category"", 
					    category, 
					    Level.toLevel((String)ht.get(""priorityStr"")),
					    ht.get(""message""), 
					    (Throwable) ht.get(""throwable""));
      event.getThreadName();
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(baos);
      oos.writeObject(event);
      oos.flush();
      return baos.toByteArray();
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }
  public
  Hashtable deserialize(byte[] buf) {
    try {
      System.out.println(""deserialize called."");
      ByteArrayInputStream bais = new ByteArrayInputStream(buf);
      ObjectInputStream si = new ObjectInputStream(bais);  
      LoggingEvent event = (LoggingEvent)  si.readObject();	    
      System.out.println(""Desrialization looks successful."");
      return eventToHashtable(event);
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }
  Hashtable eventToHashtable(LoggingEvent event) {
    Hashtable ht = new Hashtable();
    ht.put(""categoryName"", event.categoryName);
    ht.put(""renderedMessage"", event.getRenderedMessage());
    ht.put(""priorityStr"", event.level.toString());
    ht.put(""throwableInfo"", event.getThrowableInformation());
    return ht;
  }
}
"
org.apache.log4j.varia.DenyAllFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
/**
   This filter drops all logging events. 
   <p>You can add this filter to the end of a filter chain to
   switch from the default ""accept all unless instructed otherwise""
   filtering behaviour to a ""deny all unless instructed otherwise""
   behaviour.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class DenyAllFilter extends Filter {
  /**
     Returns <code>null</code> as there are no options.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return null;
  }
  /**
     No options to set.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
  }
  /**
     Always returns the integer constant {@link Filter#DENY}
     regardless of the {@link LoggingEvent} parameter.
     @param event The LoggingEvent to filter.
     @return Always returns {@link Filter#DENY}.
  */
  public
  int decide(LoggingEvent event) {
    return Filter.DENY;
  }
}
"
org.apache.log4j.varia.ExternallyRolledFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.varia;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.RollingFileAppender;
import org.apache.log4j.helpers.LogLog;
/**
   This appender listens on a socket on the port specified by the
   <b>Port</b> property for a ""RollOver"" message. When such a message
   is received, the underlying log file is rolled over and an
   acknowledgment message is sent back to the process initiating the
   roll over.
   <p>This method of triggering roll over has the advantage of being
   operating system independent, fast and reliable.
   <p>A simple application {@link Roller} is provided to initiate the
   roll over.
   <p>Note that the initiator is not authenticated. Anyone can trigger
   a rollover. In production environments, it is recommended that you
   add some form of protection to prevent undesired rollovers.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class ExternallyRolledFileAppender extends RollingFileAppender {
  /**
     The string constant sent to initiate a roll over.   Current value of
     this string constant is <b>RollOver</b>.
  */
  static final public String ROLL_OVER = ""RollOver"";
  /**
     The string constant sent to acknowledge a roll over.   Current value of
      this string constant is <b>OK</b>.
  */
  static final public String OK = ""OK"";
  int port = 0;
  HUP hup;
  /**
     The default constructor does nothing but calls its super-class
     constructor.  */
  public
  ExternallyRolledFileAppender() {
  }
  /**
     The <b>Port</b> [roperty is used for setting the port for
     listening to external roll over messages.
  */
  public
  void setPort(int port) {
    this.port = port;
  }
  /**
     Returns value of the <b>Port</b> option.
   */
  public
  int getPort() {
    return port;
  }
  /**
     Start listening on the port specified by a preceding call to
     {@link #setPort}.  */
  public
  void activateOptions() {
    super.activateOptions();
    if(port != 0) {
      if(hup != null) {
	hup.interrupt();
      }
      hup = new HUP(this, port);
      hup.setDaemon(true);
      hup.start();
    }
  }
}
class HUP extends Thread {
  int port;
  ExternallyRolledFileAppender er;
  HUP(ExternallyRolledFileAppender er, int port) {
    this.er = er;
    this.port = port;
  }
  public
  void run() {
    while(!isInterrupted()) {
      try {
	ServerSocket serverSocket = new ServerSocket(port);
	while(true) {
	  Socket socket = serverSocket.accept();
	  LogLog.debug(""Connected to client at "" + socket.getInetAddress());
	  new Thread(new HUPNode(socket, er)).start();
	}
      }
      catch(Exception e) {
	e.printStackTrace();
      }
    }
  }
}
class HUPNode implements Runnable {
  Socket socket;
  DataInputStream dis;
  DataOutputStream dos;
  ExternallyRolledFileAppender er;
  public
  HUPNode(Socket socket, ExternallyRolledFileAppender er) {
    this.socket = socket;
    this.er = er;
    try {
      dis = new DataInputStream(socket.getInputStream());
      dos = new DataOutputStream(socket.getOutputStream());
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  public void run() {
    try {
      String line = dis.readUTF();
      LogLog.debug(""Got external roll over signal."");
      if(ExternallyRolledFileAppender.ROLL_OVER.equals(line)) {
	synchronized(er) {
	  er.rollOver();
	}
	dos.writeUTF(ExternallyRolledFileAppender.OK);
      }
      else {
	dos.writeUTF(""Expecting [RollOver] string."");
      }
      dos.close();
    }
    catch(Exception e) {
      LogLog.error(""Unexpected exception. Exiting HUPNode."", e);
    }
  }
}
"
org.apache.log4j.varia.FallbackErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.varia;
import  org.apache.log4j.spi.ErrorHandler;
import  org.apache.log4j.spi.LoggingEvent;
import  org.apache.log4j.Appender;
import  org.apache.log4j.Logger;
import  org.apache.log4j.helpers.LogLog;
import java.util.Vector;
/**
   The <code>FallbackErrorHandler</code> implements the ErrorHandler
   interface such that a secondary appender may be specified.  This
   secondary appender takes over if the primary appender fails for
   whatever reason.
   <p>The error message is printed on <code>System.err</code>, and
   logged in the new secondary appender.
*/
public class FallbackErrorHandler implements ErrorHandler {
  Appender backup;
  Appender primary;
  Vector loggers;
  public FallbackErrorHandler() {
  }
  /**
     <em>Adds</em> the logger passed as parameter to the list of
     loggers that we need to search for in case of appender failure.
  */
  public 
  void setLogger(Logger logger) {
    LogLog.debug(""FB: Adding logger ["" + logger.getName() + ""]."");
    if(loggers == null) {
      loggers = new Vector();
    }
    loggers.addElement(logger);
  }
  /**
     No options to activate.
  */
  public 
  void activateOptions() {
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.  */
  public
  void error(String message, Exception e, int errorCode) { 
    error(message, e, errorCode, null);
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.
   */
  public
  void error(String message, Exception e, int errorCode, LoggingEvent event) {
    for(int i = 0; i < loggers.size(); i++) {
      Logger l = (Logger) loggers.elementAt(i);
      LogLog.debug(""FB: Searching for [""+primary.getName()+""] in logger""
		   +l.getName());
      //if(l.isAttached(primary)) {
      LogLog.debug(""FB: Replacing [""+primary.getName()+""] by [""
		   + backup.getName() + "" in logger""+ l);
      l.removeAppender(primary);
      LogLog.debug(""FB: Adding appender [""+backup.getName()+""] to logger ""
		   +  l.getName());
      l.addAppender(backup);
    }    
  }
  /**
     Print a the error message passed as parameter on
     <code>System.err</code>.  
  */
  public 
  void error(String message) {
    //if(firstTime) {
    //LogLog.error(message);
    //firstTime = false;
    //}
  }
  /**
     The appender to which this error handler is attached.
   */
  public
  void setAppender(Appender primary) {
    LogLog.debug(""FB: Setting primary appender to ["" + primary.getName() + ""]."");
    this.primary = primary;
  }
  /**
     Set the backup appender.
   */
  public
  void setBackupAppender(Appender backup) {
    LogLog.debug(""FB: Setting backup appender to ["" + backup.getName() + ""]."");
    this.backup = backup;
  }
}
"
org.apache.log4j.varia.LevelMatchFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.Level;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on level matching.
   <p>The filter admits two options <b>LevelToMatch</b> and
   <b>AcceptOnMatch</b>. If there is an exact match between the value
   of the <b>LevelToMatch</b> option and the level of the {@link
   LoggingEvent}, then the {@link #decide} method returns {@link
   Filter#ACCEPT} in case the <b>AcceptOnMatch</b> option value is set
   to <code>true</code>, if it is <code>false</code> then {@link
   Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   @author Ceki G&uuml;lc&uuml;
   @since 1.2 */
public class LevelMatchFilter extends Filter {
  /**
     Do we return ACCEPT when a match occurs. Default is
     <code>true</code>.  */
  boolean acceptOnMatch = true;
  /**
   */
  Level levelToMatch;
  public
  void setLevelToMatch(String level) {
    levelToMatch = OptionConverter.toLevel(level, null);
  }
  public
  String getLevelToMatch() {
    return levelToMatch == null ? null : levelToMatch.toString();
  }
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  /**
     Return the decision of this filter.
     Returns {@link Filter#NEUTRAL} if the <b>LevelToMatch</b> option
     is not set or if there is not match.  Otherwise, if there is a
     match, then the returned decision is {@link Filter#ACCEPT} if the
     <b>AcceptOnMatch</b> property is set to <code>true</code>. The
     returned decision is {@link Filter#DENY} if the
     <b>AcceptOnMatch</b> property is set to false.
  */
  public
  int decide(LoggingEvent event) {
    if(this.levelToMatch == null) {
      return Filter.NEUTRAL;
    }
    boolean matchOccured = false;
    if(this.levelToMatch.equals(event.level)) {
      matchOccured = true;
    } 
    if(matchOccured) {  
      if(this.acceptOnMatch)
	  return Filter.ACCEPT;
      else
	  return Filter.DENY;
    } else {
      return Filter.NEUTRAL;
    }
  }
}
"
org.apache.log4j.varia.ReloadingPropertyConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.Configurator;
import java.net.URL;
import  org.apache.log4j.spi.LoggerRepository;
public class ReloadingPropertyConfigurator implements Configurator {
  PropertyConfigurator delegate = new PropertyConfigurator();
  public ReloadingPropertyConfigurator() {    
  }
  public
  void doConfigure(URL url, LoggerRepository repository) {
  }
}
"
org.apache.log4j.varia.Roller,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
/**
   A simple application to send roll over messages to a potentially
   remote {@link ExternallyRolledFileAppender}. 
   <p>It takes two arguments, the <code>host_name</code> and
   <code>port_number</code> where the
   <code>ExternallyRolledFileAppender</code> is listening.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class Roller {
  static Category cat = Category.getInstance(Roller.class.getName());
  static String host;
  static int port;
  // Static class.
  Roller() {
  }
  /**
     Send a ""RollOver"" message to
     <code>ExternallyRolledFileAppender</code> on <code>host</code>
     and <code>port</code>.
   */
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    roll();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Roller.class.getName() +
			""host_name port_number"");
    System.exit(1);
  }
  static 
  void init(String hostArg, String portArg) {
    host = hostArg;
    try {
      port =  Integer.parseInt(portArg);
    }
    catch(java.lang.NumberFormatException e) {
      usage(""Second argument ""+portArg+"" is not a valid integer."");
    }
  }
  static
  void roll() {
    try {
      Socket socket = new Socket(host, port);
      DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
      DataInputStream dis = new DataInputStream(socket.getInputStream());
      dos.writeUTF(ExternallyRolledFileAppender.ROLL_OVER);
      String rc = dis.readUTF();
      if(ExternallyRolledFileAppender.OK.equals(rc)) {
	cat.info(""Roll over signal acknowledged by remote appender."");
      } else {
	cat.warn(""Unexpected return code ""+rc+"" from remote entity."");
	System.exit(2);
      }
    } catch(IOException e) {
      cat.error(""Could not send roll signal on host ""+host+"" port ""+port+"" ."",
		e);
      System.exit(2);
    }
    System.exit(0);
  }
}
"
org.apache.log4j.varia.StringMatchFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on string matching.
   <p>The filter admits two options <b>StringToMatch</b> and
   <b>AcceptOnMatch</b>. If there is a match between the value of the
   StringToMatch option and the message of the {@link LoggingEvent},
   then the {@link #decide} method returns {@link Filter#ACCEPT} if
   the <b>AcceptOnMatch</b> option value is true, if it is false then
   {@link Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   <p>See configuration files <a
   href=""../xml/doc-files/test6.xml"">test6.xml</a>, <a
   href=""../xml/doc-files/test7.xml"">test7.xml</a>, <a
   href=""../xml/doc-files/test8.xml"">test8.xml</a>, <a
   href=""../xml/doc-files/test9.xml"">test9.xml</a>, and <a
   href=""../xml/doc-files/test10.xml"">test10.xml</a> for examples of
   seeting up a <code>StringMatchFilter</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class StringMatchFilter extends Filter {
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String STRING_TO_MATCH_OPTION = ""StringToMatch"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  boolean acceptOnMatch = true;
  String stringToMatch;
  /**
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return new String[] {STRING_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) { 
    if(key.equalsIgnoreCase(STRING_TO_MATCH_OPTION)) {
      stringToMatch = value;
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
  public
  void setStringToMatch(String s) {
    stringToMatch = s;
  }
  public
  String getStringToMatch() {
    return stringToMatch;
  }
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  /**
     Returns {@link Filter#NEUTRAL} is there is no string match.
   */
  public
  int decide(LoggingEvent event) {
    String msg = event.getRenderedMessage();
    if(msg == null ||  stringToMatch == null)
      return Filter.NEUTRAL;
    if( msg.indexOf(stringToMatch) == -1 ) {
      return Filter.NEUTRAL;
    } else { // we've got a match
      if(acceptOnMatch) {
	return Filter.ACCEPT;
      } else {
	return Filter.DENY;
      }
    }
  }
}
"
org.apache.log4j.varia.test.Loop,"package org.apache.log4j.varia.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
   This test program reads a config file and attempts to log to the
   appenders specified as many times as specified by the second
   loopLength parameter.
   @author Ceki G&uuml;lc&uuml; */
public class Loop {
  static Category cat = Category.getInstance(Loop.class.getName());
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Loop.class.getName() +
			""configFile loopLength"");
    System.exit(1);
  }
  static
  void init(String configFile, String loopStr) {
    PropertyConfigurator.configure(configFile);
    try {
      loopLength   = Integer.parseInt(loopStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret loopLength [""+ loopStr +""]."");
    }
  }
  static
  void test() {
    for(int i=0; i < loopLength; i++) {
      Thread.yield();
      cat.debug(""MSG ""+i);
    }
  }
}
"
org.apache.log4j.xml.DOMConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.xml;
import java.util.*;
import java.net.URL;
import org.w3c.dom.*;
import java.lang.reflect.Method;
import org.apache.log4j.*;
import org.apache.log4j.spi.*;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.helpers.*;
import org.apache.log4j.config.PropertySetter;
import org.xml.sax.InputSource;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.IOException;
import java.net.URL;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.FactoryConfigurationError;
// Contributors:   Mark Womack
//                 Arun Katkere 
/**
   Use this class to initialize the log4j environment using a DOM tree.
   <p>The DTD is specified in <a
   href=""doc-files/log4j.dtd""><b>log4j.dtd</b></a>.
   <p>Sometimes it is useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.debug</b> variable on the java command
   line. Alternatively, set the <code>debug</code> attribute in the
   <code>log4j:configuration</code> element. As in
<pre>
   &lt;log4j:configuration <b>debug=""true""</b> xmlns:log4j=""http://jakarta.apache.org/log4j/"">
   ...
   &lt;/log4j:configuration>
</pre>
   <p>There are sample XML files included in the package.
   @author Christopher Taylor
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.3 */
public class DOMConfigurator implements Configurator {
  static final String CONFIGURATION_TAG = ""log4j:configuration"";
  static final String OLD_CONFIGURATION_TAG = ""configuration"";
  static final String RENDERER_TAG      = ""renderer"";
  static final String APPENDER_TAG 	= ""appender"";
  static final String APPENDER_REF_TAG 	= ""appender-ref"";  
  static final String PARAM_TAG    	= ""param"";
  static final String LAYOUT_TAG	= ""layout"";
  static final String CATEGORY		= ""category"";
  static final String LOGGER		= ""logger"";
  static final String LOGGER_REF	= ""logger-ref"";
  static final String CATEGORY_FACTORY_TAG  = ""categoryFactory"";
  static final String NAME_ATTR		= ""name"";
  static final String CLASS_ATTR        = ""class"";
  static final String VALUE_ATTR	= ""value"";
  static final String ROOT_TAG		= ""root"";
  static final String ROOT_REF		= ""root-ref"";
  static final String LEVEL_TAG	        = ""level"";
  static final String PRIORITY_TAG      = ""priority"";
  static final String FILTER_TAG	= ""filter"";
  static final String ERROR_HANDLER_TAG	= ""errorHandler"";
  static final String REF_ATTR		= ""ref"";
  static final String ADDITIVITY_ATTR    = ""additivity"";  
  static final String THRESHOLD_ATTR       = ""threshold"";
  static final String CONFIG_DEBUG_ATTR  = ""configDebug"";
  static final String INTERNAL_DEBUG_ATTR  = ""debug"";
  static final String RENDERING_CLASS_ATTR = ""renderingClass"";
  static final String RENDERED_CLASS_ATTR = ""renderedClass"";
  static final String EMPTY_STR = """";
  static final Class[] ONE_STRING_PARAM = new Class[] {String.class};
  final static String dbfKey = ""javax.xml.parsers.DocumentBuilderFactory"";
  // key: appenderName, value: appender
  Hashtable appenderBag;
  Properties props;
  LoggerRepository repository;
  /**
     No argument constructor.
  */
  public
  DOMConfigurator () { 
    appenderBag = new Hashtable();
  }
  /**
     Used internally to parse appenders by IDREF name.
  */
  protected
  Appender findAppenderByName(Document doc, String appenderName)  {      
    Appender appender = (Appender) appenderBag.get(appenderName);
    if(appender != null) {
      return appender;
    } else {
      // Doesn't work on DOM Level 1 :
      // Element element = doc.getElementById(appenderName);
      // Endre's hack:
      Element element = null;
      NodeList list = doc.getElementsByTagName(""appender"");
      for (int t=0; t < list.getLength(); t++) {
	Node node = list.item(t);
	NamedNodeMap map= node.getAttributes();
	Node attrNode = map.getNamedItem(""name"");
	if (appenderName.equals(attrNode.getNodeValue())) {
	  element = (Element) node;
	  break;
	}
      }
      // Hack finished.
      if(element == null) {
	LogLog.error(""No appender named [""+appenderName+""] could be found.""); 
	return null;
      } else {
	appender = parseAppender(element);
	appenderBag.put(appenderName, appender);
	return appender;
      }
    } 
  }
  /**
     Used internally to parse appenders by IDREF element.
   */
  protected
  Appender findAppenderByReference(Element appenderRef) {    
    String appenderName = subst(appenderRef.getAttribute(REF_ATTR));    
    Document doc = appenderRef.getOwnerDocument();
    return findAppenderByName(doc, appenderName);
  }
  /**
     Used internally to parse an appender element.
   */
  protected
  Appender parseAppender (Element appenderElement) {
    String className = subst(appenderElement.getAttribute(CLASS_ATTR));
    LogLog.debug(""Class name: ["" + className+']');    
    try {
      Object instance 	= Class.forName(className).newInstance();
      Appender appender	= (Appender)instance;
      PropertySetter propSetter = new PropertySetter(appender);
      appender.setName(subst(appenderElement.getAttribute(NAME_ATTR)));
      NodeList children	= appenderElement.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	/* We're only interested in Elements */
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element)currentNode;
	  // Parse appender parameters 
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	  // Set appender layout
	  else if (currentElement.getTagName().equals(LAYOUT_TAG)) {
	    appender.setLayout(parseLayout(currentElement));
	  }
	  // Add filters
	  else if (currentElement.getTagName().equals(FILTER_TAG)) {
	    parseFilters(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
	    parseErrorHandler(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
	    String refName = subst(currentElement.getAttribute(REF_ATTR));
	    if(appender instanceof AppenderAttachable) {
	      AppenderAttachable aa = (AppenderAttachable) appender;
	      LogLog.debug(""Attaching appender named [""+ refName+
			   ""] to appender named [""+ appender.getName()+""]."");
	      aa.addAppender(findAppenderByReference(currentElement));
	    } else {
	      LogLog.error(""Requesting attachment of appender named [""+
			   refName+ ""] to appender named [""+ appender.getName()+
                ""] which does not implement org.apache.log4j.spi.AppenderAttachable."");
	    }
	  }
	}
      }
      propSetter.activate();
      return appender;
    }
    /* Yes, it's ugly.  But all of these exceptions point to the same
       problem: we can't create an Appender */
    catch (Exception oops) {
      LogLog.error(""Could not create an Appender. Reported error follows."",
		   oops);
      return null;
    }
  }
  /**
     Used internally to parse an {@link ErrorHandler} element.
   */
  protected
  void parseErrorHandler(Element element, Appender appender) {
    ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByClassName(
                                       subst(element.getAttribute(CLASS_ATTR)),
                                       org.apache.log4j.spi.ErrorHandler.class, 
 				       null);
    if(eh != null) {
      eh.setAppender(appender);
      PropertySetter propSetter = new PropertySetter(eh);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  } else if(tagName.equals(APPENDER_REF_TAG)) {
	    eh.setBackupAppender(findAppenderByReference(currentElement));
	  } else if(tagName.equals(LOGGER_REF)) {
	    String loggerName = currentElement.getAttribute(REF_ATTR);	    
	    Logger logger = repository.getLogger(loggerName);
	    eh.setLogger(logger);
	  } else if(tagName.equals(ROOT_REF)) {
	    Logger root = repository.getRootLogger();
	    eh.setLogger(root);
	  }
	}
      }
      propSetter.activate();
      appender.setErrorHandler(eh);
    }
  }
  /**
     Used internally to parse a filter element.
   */
  protected
  void parseFilters(Element element, Appender appender) {
    String clazz = subst(element.getAttribute(CLASS_ATTR));
    Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz,
                                                Filter.class, null);
    if(filter != null) {
      PropertySetter propSetter = new PropertySetter(filter);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  } 
	}
      }
      propSetter.activate();
      LogLog.debug(""Adding filter of type [""+filter.getClass()
		   +""] to appender named [""+appender.getName()+""]."");
      appender.addFilter(filter);
    }    
  }
  /**
     Used internally to parse an category element.
  */
  protected
  void parseCategory (Element loggerElement) {
    // Create a new org.apache.log4j.Category object from the <category> element.
    String catName = subst(loggerElement.getAttribute(NAME_ATTR));
    Logger cat;    
    String className = subst(loggerElement.getAttribute(CLASS_ATTR));
    if(EMPTY_STR.equals(className)) {
      LogLog.debug(""Retreiving an instance of org.apache.log4j.Logger."");
      cat = repository.getLogger(catName);
    }
    else {
      LogLog.debug(""Desired logger sub-class: [""+className+']');
       try {	 
	 Class clazz = Class.forName(className);
	 Method getInstanceMethod = clazz.getMethod(""getLogger"", 
						    ONE_STRING_PARAM);
	 cat = (Logger) getInstanceMethod.invoke(null, new Object[] {catName});
       } catch (Exception oops) {
	 LogLog.error(""Could not retrieve category [""+catName+
		      ""]. Reported error follows."", oops);
	 return;
       }
    }
    // Setting up a category needs to be an atomic operation, in order
    // to protect potential log operations while category
    // configuration is in progress.
    synchronized(cat) {
      boolean additivity = OptionConverter.toBoolean(
                           subst(loggerElement.getAttribute(ADDITIVITY_ATTR)),
			   true);
      LogLog.debug(""Setting [""+cat.getName()+""] additivity to [""+additivity+""]."");
      cat.setAdditivity(additivity);
      parseChildrenOfLoggerElement(loggerElement, cat, false);
    }
  }
  /**
     Used internally to parse the category factory element.
  */
  protected
  void parseCategoryFactory(Element factoryElement) {
    String className = subst(factoryElement.getAttribute(CLASS_ATTR));
    if(EMPTY_STR.equals(className)) {
      LogLog.error(""Category Factory tag "" + CLASS_ATTR + "" attribute not found."");
      LogLog.debug(""No Category Factory configured."");
    }
    else {
      LogLog.debug(""Desired category factory: [""+className+']');
      Object catFactory = OptionConverter.instantiateByClassName(className, 
                                                                 LoggerFactory.class, 
                                                                 null);
      PropertySetter propSetter = new PropertySetter(catFactory);
      Element  currentElement = null;
      Node     currentNode    = null;
      NodeList children       = factoryElement.getChildNodes();
      final int length        = children.getLength();
      for (int loop=0; loop < length; loop++) {
        currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  currentElement = (Element)currentNode;
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
	    setParameter(currentElement, propSetter);
	  }
	}
      }
    }
  }
  /**
     Used internally to parse the roor category element.
  */
  protected
  void parseRoot (Element rootElement) {
    Logger root = repository.getRootLogger();
    // category configuration needs to be atomic
    synchronized(root) {    
      parseChildrenOfLoggerElement(rootElement, root, true);
    }
  }
  /**
     Used internally to parse the children of a category element.
  */
  protected
  void parseChildrenOfLoggerElement(Element catElement,
				      Logger cat, boolean isRoot) {
    PropertySetter propSetter = new PropertySetter(cat);
    // Remove all existing appenders from cat. They will be
    // reconstructed if need be.
    cat.removeAllAppenders();
    NodeList children 	= catElement.getChildNodes();
    final int length 	= children.getLength();
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	if (tagName.equals(APPENDER_REF_TAG)) {
	  Element appenderRef = (Element) currentNode;
	  Appender appender = findAppenderByReference(appenderRef);
	  String refName =  subst(appenderRef.getAttribute(REF_ATTR));
	  if(appender != null)
	    LogLog.debug(""Adding appender named [""+ refName+ 
			 ""] to category [""+cat.getName()+""]."");
	  else 
	    LogLog.debug(""Appender named [""+ refName + ""] not found."");
	  cat.addAppender(appender);
	} else if(tagName.equals(LEVEL_TAG)) {
	  parseLevel(currentElement, cat, isRoot);	
	} else if(tagName.equals(PRIORITY_TAG)) {
	  parseLevel(currentElement, cat, isRoot);
	} else if(tagName.equals(PARAM_TAG)) {
          setParameter(currentElement, propSetter);
	}
      }
    }
    propSetter.activate();
  }
  /**
     Used internally to parse a layout element.
  */  
  protected
  Layout parseLayout (Element layout_element) {
    String className = subst(layout_element.getAttribute(CLASS_ATTR));
    LogLog.debug(""Parsing layout of class: \""""+className+""\"""");		 
    try {
      Object instance 	= Class.forName(className).newInstance();
      Layout layout   	= (Layout)instance;
      PropertySetter propSetter = new PropertySetter(layout);
      NodeList params 	= layout_element.getChildNodes();
      final int length 	= params.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = (Node)params.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	}
      }
      propSetter.activate();
      return layout;
    }
    catch (Exception oops) {
      LogLog.error(""Could not create the Layout. Reported error follows."",
		   oops);
      return null;
    }
  }
  protected 
  void parseRenderer(Element element) {
    String renderingClass = subst(element.getAttribute(RENDERING_CLASS_ATTR));
    String renderedClass = subst(element.getAttribute(RENDERED_CLASS_ATTR));
    if(repository instanceof RendererSupport) {
      RendererMap.addRenderer((RendererSupport) repository, renderedClass, 
			      renderingClass);
    }
  }
  /**
     Used internally to parse a level  element.
  */
  protected
  void parseLevel(Element element, Logger logger, boolean isRoot) {
    String catName = logger.getName();
    if(isRoot) {
      catName = ""root"";
    }
    String priStr = subst(element.getAttribute(VALUE_ATTR));
    LogLog.debug(""Level value for ""+catName+"" is  [""+priStr+""]."");
    if(INHERITED.equals(priStr)) {
      if(isRoot) {
	LogLog.error(""Root level cannot be inherited. Ignoring directive."");
      } else {
	logger.setLevel(null);
      }
    } else {
      String className = subst(element.getAttribute(CLASS_ATTR));      
      if(EMPTY_STR.equals(className)) {	
	logger.setLevel(OptionConverter.toLevel(priStr, Level.DEBUG));
      } else {
	LogLog.debug(""Desired Level sub-class: [""+className+']');
	try {	 
	  Class clazz = Class.forName(className);
	  Method toLevelMethod = clazz.getMethod(""toLevel"", 
						    ONE_STRING_PARAM);
	  Level pri = (Level) toLevelMethod.invoke(null, 
						    new Object[] {priStr});
	  logger.setLevel(pri);
	} catch (Exception oops) {
	  LogLog.error(""Could not create level [""+priStr+
		       ""]. Reported error follows."", oops);
	  return;
	}
      }
    }
    LogLog.debug(catName + "" level set to "" + logger.getLevel());    
  }
  protected
  void setParameter(Element elem, PropertySetter propSetter) {
    String name = subst(elem.getAttribute(NAME_ATTR));
    String value = (elem.getAttribute(VALUE_ATTR));
    value = subst(OptionConverter.convertSpecialChars(value));
    propSetter.setProperty(name, value);
  }
  /**
     Configure log4j using a <code>configuration</code> element as
     defined in the log4j.dtd. 
  */
  static
  public
  void configure (Element element) {
    DOMConfigurator configurator = new DOMConfigurator();
    configurator.doConfigure(element,  LogManager.getLoggerRepository());
  }
 /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used. 
     @param configFilename A log4j configuration file in XML format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.  
      @param configFilename A log4j configuration file in XML format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    XMLWatchdog xdog = new XMLWatchdog(configFilename);
    xdog.setDelay(delay);
    xdog.start();
  }
  public
  void doConfigure(String filename, LoggerRepository repository) {
    FileInputStream fis = null;
    try {
      fis = new FileInputStream(filename);
      doConfigure(fis, repository);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+filename+""]."", e);
    } finally {
      if (fis != null) {
	try {
	  fis.close();
	} catch(java.io.IOException e) {
	  LogLog.error(""Could not close [""+filename+""]."", e);
	}
      }
    }
  }
  public
  void doConfigure(URL url, LoggerRepository repository) {
    try {
      doConfigure(url.openStream(), repository);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+url+""]."", e);
    }
  }
  /**
     Configure log4j by reading in a log4j.dtd compliant XML
     configuration file.
  */
  public
  void doConfigure(InputStream inputStream, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
    doConfigure(new InputSource(inputStream), repository);
  }
  /**
     Configure log4j by reading in a log4j.dtd compliant XML
     configuration file.
  */
  public
  void doConfigure(Reader reader, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
    doConfigure(new InputSource(reader), repository);
  }
  /**
     Configure log4j by reading in a log4j.dtd compliant XML
     configuration file.
  */
  protected
  void doConfigure(InputSource inputSource, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
    DocumentBuilderFactory dbf = null;
    this.repository = repository;
    try { 
      LogLog.debug(""System property is :""+
  	                        OptionConverter.getSystemProperty(dbfKey, 
								  null)); 
      dbf = DocumentBuilderFactory.newInstance();
      LogLog.debug(""Standard DocumentBuilderFactory search succeded."");
      LogLog.debug(""DocumentBuilderFactory is: ""+dbf.getClass().getName());
    } catch(FactoryConfigurationError fce) {
      Exception e = fce.getException();
      LogLog.debug(""Could not instantiate a DocumentBuilderFactory."", e);
      throw fce;
    }
    try {
      // This makes ID/IDREF attributes to have a meaning. Don't ask
      // me why.
      dbf.setValidating(true);
      //dbf.setNamespaceAware(true);
      DocumentBuilder docBuilder = dbf.newDocumentBuilder();
      docBuilder.setErrorHandler(new SAXErrorHandler());
      Class clazz = this.getClass();
      URL dtdURL = clazz.getResource(""/org/apache/log4j/xml/log4j.dtd"");
      if(dtdURL == null) {
	LogLog.error(""Could not find [log4j.dtd]. Used [""+clazz.getClassLoader()+
		     ""] class loader in the search."");
      }
      else {
	LogLog.debug(""URL to log4j.dtd is ["" + dtdURL.toString()+""]."");
	inputSource.setSystemId(dtdURL.toString());
      }
      Document doc = docBuilder.parse(inputSource);
      parse(doc.getDocumentElement());
    } catch (Exception e) {
      // I know this is miserable...
      LogLog.error(""Could not parse input source [""+inputSource+""]."", e);
    }
  }
    /**
       Configure by taking in an DOM element. 
     */
    public void doConfigure(Element element, LoggerRepository repository) {
	this.repository = repository;
	parse(element);
    }
  /**
     A static version of {@link #doConfigure(String, LoggerRepository)}.  */
  static
  public
  void configure(String filename) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(filename, 
				      LogManager.getLoggerRepository());
  }
  /**
     A static version of {@link #doConfigure(URL, LoggerRepository)}.
   */
  static
  public
  void configure(URL url) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(url, LogManager.getLoggerRepository());
  }
  /**
     Used internally to configure the log4j framework by parsing a DOM
     tree of XML elements based on <a
     href=""doc-files/log4j.dtd"">log4j.dtd</a>.
  */
  protected
  void parse(Element element) {
    String rootElementName = element.getTagName();
    if (!rootElementName.equals(CONFIGURATION_TAG)) {
      if(rootElementName.equals(OLD_CONFIGURATION_TAG)) {
	LogLog.warn(""The <""+OLD_CONFIGURATION_TAG+
		     ""> element has been deprecated."");
	LogLog.warn(""Use the <""+CONFIGURATION_TAG+""> element instead."");
      } else {
	LogLog.error(""DOM element is - not a <""+CONFIGURATION_TAG+""> element."");
	return;
      }
    }
    String debugAttrib = subst(element.getAttribute(INTERNAL_DEBUG_ATTR));
    LogLog.debug(""debug attribute= \"""" + debugAttrib +""\""."");
    // if the log4j.dtd is not specified in the XML file, then the
    // ""debug"" attribute is returned as the empty string.
    if(!debugAttrib.equals("""") && !debugAttrib.equals(""null"")) {      
      LogLog.setInternalDebugging(OptionConverter.toBoolean(debugAttrib, true));
    }
    else 
      LogLog.debug(""Ignoring "" + INTERNAL_DEBUG_ATTR + "" attribute."");
    String confDebug = subst(element.getAttribute(CONFIG_DEBUG_ATTR));
    if(!confDebug.equals("""") && !confDebug.equals(""null"")) {      
      LogLog.warn(""The \""""+CONFIG_DEBUG_ATTR+""\"" attribute is deprecated."");
      LogLog.warn(""Use the \""""+INTERNAL_DEBUG_ATTR+""\"" attribute instead."");
      LogLog.setInternalDebugging(OptionConverter.toBoolean(confDebug, true));
    }
    String thresholdStr = subst(element.getAttribute(THRESHOLD_ATTR));
    LogLog.debug(""Threshold =\"""" + thresholdStr +""\""."");
    if(!"""".equals(thresholdStr) && !""null"".equals(thresholdStr)) {
      repository.setThreshold(thresholdStr);
    }
    //Hashtable appenderBag = new Hashtable(11);
    /* Building Appender objects, placing them in a local namespace
       for future reference */
    // First configure each category factory under the root element.
    // Category factories need to be configured before any of
    // categories they support.
    //
    String   tagName = null;
    Element  currentElement = null;
    Node     currentNode = null;
    NodeList children = element.getChildNodes();
    final int length = children.getLength();
    for (int loop = 0; loop < length; loop++) {
      currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	currentElement = (Element) currentNode;
	tagName = currentElement.getTagName();
	if (tagName.equals(CATEGORY_FACTORY_TAG)) {
	  parseCategoryFactory(currentElement);
	}
      }
    }
    for (int loop = 0; loop < length; loop++) {
      currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	currentElement = (Element) currentNode;
	tagName = currentElement.getTagName();
	if (tagName.equals(CATEGORY) || tagName.equals(LOGGER)) {
	  parseCategory(currentElement);
	} else if (tagName.equals(ROOT_TAG)) {
	  parseRoot(currentElement);
	} else if(tagName.equals(RENDERER_TAG)) {
	  parseRenderer(currentElement);
	}
      }
    }
  }
  protected
  String subst(String value) {
    try {
      return OptionConverter.substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.warn(""Could not perform variable substitution."", e);
      return value;
    }
  }
}
class XMLWatchdog extends FileWatchdog {
  XMLWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new DOMConfigurator().doConfigure(filename, 
				      LogManager.getLoggerRepository());
  }
}
"
org.apache.log4j.xml.SAXErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
package org.apache.log4j.xml;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;
import org.apache.log4j.helpers.LogLog;
public class SAXErrorHandler implements ErrorHandler {
  public
  void error(SAXParseException ex) {
    LogLog.error(""Parsing error on line ""+ex.getLineNumber()+"" and column ""
		 +ex.getColumnNumber());
    LogLog.error(ex.getMessage(), ex.getException());
    //LogLog.error(""pid=""+ex.getPublicId()+"" sid=""+ex.getSystemId());
  }
  public
  void fatalError(SAXParseException ex) {
    error(ex);
  }
  public
  void warning(SAXParseException ex) {
    LogLog.warn(""Parsing error on line ""+ex.getLineNumber()+"" and column ""
		+ex.getColumnNumber());
    LogLog.warn(ex.getMessage(), ex.getException());
  }
}
"
org.apache.log4j.xml.XMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.txt file.  */
// Contributors:   Mathias Bogaert
package org.apache.log4j.xml;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.DateLayout;
import org.apache.log4j.helpers.Transform;
/**
   The output of the XMLLayout consists of a series of log4j:event
   elements as defined in the <a
   href=""doc-files/log4j.dtd"">log4j.dtd</a>. It does not output a
   complete well-formed XML file. The output is designed to be
   included as an <em>external entity</em> in a separate file to form
   a correct XML file.
   <p>For example, if <code>abc</code> is the name of the file where
   the XMLLayout ouput goes, then a well-formed XML file would be:
   <pre>
   &lt;?xml version=""1.0"" ?&gt;
   &lt;!DOCTYPE log4j:eventSet SYSTEM ""log4j.dtd"" [&lt;!ENTITY data SYSTEM ""abc""&gt;]&gt;
   &lt;log4j:eventSet version=""1.2"" xmlns:log4j=""http://jakarta.apache.org/log4j/""&gt;
       &nbsp;&nbsp;&data;
   &lt;/log4j:eventSet&gt;
   </pre>
   <p>This approach enforces the independence of the XMLLayout and the
   appender where it is embedded. 
   <p>The <code>version</code> attribute helps components to correctly
   intrepret output generated by XMLLayout. The value of this
   attribute should be ""1.1"" for output generated by log4j versions
   prior to log4j 1.2 (final release) and ""1.2"" for relase 1.2 and
   later.
   @author Ceki  G&uuml;lc&uuml;
   @since 0.9.0 */
public class XMLLayout extends Layout {
  private  final int DEFAULT_SIZE = 256;
  private final int UPPER_LIMIT = 2048;
  private StringBuffer buf = new StringBuffer(DEFAULT_SIZE);
  private boolean locationInfo = false;
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  public
  void activateOptions() {
  }
  /**
     Formats a {@link LoggingEvent} in conformance with the log4j.dtd.  */
  public
  String format(LoggingEvent event) {
    // Reset working buffer. If the buffer is too large, then we need a new
    // one in order to avoid the penalty of creating a large array.
    if(buf.capacity() > UPPER_LIMIT) {
      buf = new StringBuffer(DEFAULT_SIZE);
    } else {
      buf.setLength(0);
    }
    // We yield to the \r\n heresy.
    buf.append(""<log4j:event category=\"""");
    buf.append(event.categoryName);
    buf.append(""\"" timestamp=\"""");
    buf.append(event.timeStamp);
    buf.append(""\"" level=\"""");
    buf.append(event.level);
    buf.append(""\"" thread=\"""");
    buf.append(event.getThreadName());
    buf.append(""\"">\r\n"");
       buf.append(""<log4j:message><![CDATA["");
       buf.append(event.getRenderedMessage());
       buf.append(""]]></log4j:message>\r\n"");       
       String ndc = event.getNDC();
       if(ndc != null) {
	 buf.append(""<log4j:NDC><![CDATA["");
	 buf.append(ndc);
	 buf.append(""]]></log4j:NDC>\r\n"");       
       }
       String[] s = event.getThrowableStrRep();
       if(s != null) {
	 buf.append(""<log4j:throwable><![CDATA["");
	 for(int i = 0; i < s.length; i++) {
	   buf.append(s[i]);
           buf.append(""\r\n"");
	 }
	 buf.append(""]]></log4j:throwable>\r\n"");
       }
       if(locationInfo) { 
	 LocationInfo locationInfo = event.getLocationInformation();	
	 buf.append(""<log4j:locationInfo class=\"""");
	 buf.append(locationInfo.getClassName());
	 buf.append(""\"" method=\"""");
	 buf.append(Transform.escapeTags(locationInfo.getMethodName()));
	 buf.append(""\"" file=\"""");
	 buf.append(locationInfo.getFileName());
	 buf.append(""\"" line=\"""");
	 buf.append(locationInfo.getLineNumber());
	 buf.append(""\""/>\r\n"");
       }
    buf.append(""</log4j:event>\r\n\r\n"");
    return buf.toString();
  }
  /**
     The XMLLayout prints and does not ignore exceptions. Hence the
     return value <code>false</code>.
  */
  public
  boolean ignoresThrowable() {
    return false;
  }
}
"
org.apache.log4j.xml.examples.ReportParserError,"package org.apache.log4j.xml.examples;
import org.apache.log4j.helpers.LogLog;
/**
   This class is needed for validating a log4j.dtd derived XML file.
   @author Joe Kesselman
   @since 0.8.3
 */
public class ReportParserError implements org.xml.sax.ErrorHandler {
  void report(String msg, org.xml.sax.SAXParseException e) {
    LogLog.error(msg+e.getMessage()+ ""\n\tat line=""+ e.getLineNumber()+
		 "" col=""+e.getColumnNumber()+ "" of ""+
		 ""SystemId=\""""+e.getSystemId()+
		 ""\"" PublicID = \""""+e.getPublicId()+'\""');
  }
  public void warning(org.xml.sax.SAXParseException e) {
    report(""WARNING: "", e);
  }
  public void error(org.xml.sax.SAXParseException e) {
    report(""ERROR: "", e);
  }
  public void fatalError(org.xml.sax.SAXParseException e) {
    report(""FATAL: "", e);
  }
}
"
org.apache.log4j.xml.examples.XMLSample,"package org.apache.log4j.xml.examples;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import java.net.*;
/**
   This <a href=""doc-files/XMLSample.java"">example code</a> shows how to
   read an XML based configuration file using a DOM parser.
   <p>Sample XML files <a href=""doc-files/sample1.xml"">sample1.xml</a>
   and <a href=""doc-files/sample2.xml"">sample2.xml</a> are provided.
   <p>Note that the log4j.dtd is not in the local directory.
   It is found by the class loader.
   @author Ceki G&uuml;lc&uuml;
*/
public class XMLSample {
  static Category cat = Category.getInstance(XMLSample.class.getName());
  public
  static
  void main(String argv[]) {
    if(argv.length == 1)
      init(argv[0]);
    else
      Usage(""Wrong number of arguments."");
    sample();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + XMLSample.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void sample() {
    int i = -1;
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
  }
}
"
org.apache.log4j.xml.test.DOMTest,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.test;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
//import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
//import java.io.FileInputStream;
//import org.xml.sax.InputSource;
/**
   @author Ceki G&uuml;lc&uuml;
*/
public class DOMTest {
  static Category cat = Category.getInstance(DOMTest.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DOMTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    Category.shutdown();
  }
}
"
